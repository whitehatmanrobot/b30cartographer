R_REJECTED == ncsResult)
		{
			SetCallState(CNS_TERMINATING_AFTER_INVITE);

			// Issue "soft" leave attempt (to allow auto-terminate)
			ASSERT(m_pConfObject);
			if (S_OK != m_pConfObject->LeaveConference(FALSE))
			{
				m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
				SetCallState(CNS_COMPLETE);
			}
		}
		else
		{
			// make sure that we are not recieving this notification due to
			// the conference going away
			ASSERT(m_pConfObject);
			if (CS_GOING_DOWN != m_pConfObject->GetT120State())
			{
				TRACE_OUT(("COutgoingCall - invite failed / couldn't connect -> leaving"));
			
				m_cnResult = CN_RC_INVITE_FAILED;
				SetCallState(CNS_COMPLETE);

				// Issue "soft" leave attempt (to allow auto-terminate)
				ASSERT(m_pConfObject);
				m_pConfObject->LeaveConference(FALSE);
			}
		}
	}

	DebugExitBOOL(COutgoingCall::OnInviteResult, bRet);
	return bRet;
}

BOOL COutgoingCall::OnQueryRemoteResult(HRESULT ncsResult,
									BOOL fMCU,
									PWSTR pwszConfNames[],
									PWSTR pwszConfDescriptors[])
{
	DebugEntry(COutgoingCall::OnQueryRemoteResult);

	ASSERT ((CNS_QUERYING_REMOTE == m_cnState) ||
			(CNS_QUERYING_REMOTE_AFTER_INVITE == m_cnState));
	ASSERT (NULL == m_bstrConfToJoin);

	if (SUCCEEDED(ncsResult))
	{
		BOOL fRemoteInConf = FALSE;
		if ((NULL != pwszConfNames) && (NULL != pwszConfNames[0]))
		{
			fRemoteInConf = TRUE;
		}

		m_fService = FALSE;
		if (fRemoteInConf && (NULL != pwszConfDescriptors) && (NULL != pwszConfDescriptors[0]))
		{
			if (0 == UnicodeCompare(pwszConfDescriptors[0],RDS_CONFERENCE_DESCRIPTOR))
			{
				m_fService = TRUE;
			}
		}

		if (m_pConfObject->IsConferenceActive())
		{
			if (fMCU)
			{
				TRACE_OUT(("COutgoingCall - QR ok, but is MCU -> complete"));
				m_cnResult = CN_RC_CANT_INVITE_MCU;
			}
			else if (fRemoteInConf)
			{
				TRACE_OUT(("COutgoingCall - QR ok, but callee is in a conference"));
				m_cnResult = CN_RC_INVITE_DENIED_REMOTE_IN_CONF;
			}
			else
			{
				if (CNS_QUERYING_REMOTE_AFTER_INVITE == m_cnState)
				{
					m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
					SetCallState(CNS_COMPLETE);
				}
				else
				{
					SetCallState(CNS_INVITING_REMOTE);

					HRESULT hr = m_pConfObject->InviteConference(m_pszAddr, &m_hRequest);
					if (S_OK != hr)
					{
						// Failure while inviting:
						m_cnResult = CN_RC_INVITE_FAILED;
					}
				}
			}

			if (CN_RC_NOERROR != m_cnResult)
			{
				SetCallState(CNS_COMPLETE);
			}
		}
		else if (fRemoteInConf || fMCU)
		{
			TRACE_OUT(("COutgoingCall - QR succeeded (>0 conf) -> joining"));
			TRACE_OUT(("\tfMCU is %d", fMCU));
		
			// There are remote conferences
			HRESULT hr = E_FAIL; // Assume a failure

			SetCallState(CNS_JOINING_REMOTE);

			if (!fMCU && (NULL == pwszConfNames[1]))
			{
				// we're not calling an MCU and we have just one conference, so join it
				m_bstrConfToJoin = SysAllocString(pwszConfNames[0]);
				hr = m_pConfObject->JoinConference(	m_bstrConfToJoin,
													m_bstrPassword,
													m_pszAddr);
			}
			else
			{
				ASSERT(NULL == m_bstrConfToJoin);
				REMOTE_CONFERENCE remoteConf;
				remoteConf.fMCU = fMCU;
				remoteConf.pwszConfNames = pwszConfNames;
				remoteConf.pbstrConfToJoin = &m_bstrConfToJoin;

				// Ask the app which conference to join
				NotifySink(&remoteConf, OnNotifyRemoteConference);

				if (NULL != m_bstrConfToJoin)
				{
					hr = m_pConfObject->JoinConference(	m_bstrConfToJoin,
														m_bstrPassword,
														m_pszAddr);
				}
			}

			if (S_OK != hr)
			{
				// JoinConference failed!
				m_cnResult = CN_RC_JOIN_FAILED;
				SetCallState(CNS_COMPLETE);
			}
		}
		else
		{
			if (CNS_QUERYING_REMOTE_AFTER_INVITE == m_cnState)
			{
				m_cnResult = CN_RC_CONFERENCE_INVITE_DENIED;
				SetCallState(CNS_COMPLETE);
			}
			else
			{
				// No conferences on remote machine, so create local:
				TRACE_OUT(("COutgoingCall - QR succeeded (no conf)-> creating local"));

				// Create local conf
				ASSERT(m_pConfObject);
				SetCallState(CNS_CREATING_LOCAL);
				HRESULT hr = m_pConfObject->CreateConference();

				if (S_OK != hr)
				{
					// CreateConference failed!
					m_cnResult = CN_RC_CONFERENCE_CREATE_FAILED;
					SetCallState(CNS_COMPLETE);
				}
			}
		}
	}
	else
	{
		// The QueryRemote failed
		switch( ncsResult )
		{
			case UI_RC_USER_REJECTED:
				// The initial QueryRemote failed because GCC symmetry determined
				// that the other node is calling someone, and it might be us
				// See Bug 1886
				TRACE_OUT(("COutgoingCall - QueryRemote rejected -> complete"));
				m_cnResult = CN_RC_REMOTE_PLACING_CALL;
				break;
			case UI_RC_T120_REMOTE_REQUIRE_SECURITY:
				m_cnResult = CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY;
				break;
			case UI_RC_T120_SECURITY_FAILED:
				m_cnResult = CN_RC_SECURITY_FAILED;
				break;
			case UI_RC_T120_REMOTE_NO_SECURITY:
				m_cnResult = CN_RC_CONNECT_REMOTE_NO_SECURITY;
				break;
			case UI_RC_T120_REMOTE_DOWNLEVEL_SECURITY:
				m_cnResult = CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY;
				break;
			case UI_RC_T120_AUTHENTICATION_FAILED:
				m_cnResult = CN_RC_CONNECT_AUTHENTICATION_FAILED;
				break;
			default:
				m_cnResult = CN_RC_CONNECT_FAILED;
				break;
		}
		SetCallState(CNS_COMPLETE);
	}

	DebugExitBOOL(COutgoingCall::OnQueryRemoteResult, TRUE);
	return TRUE;
}

BOOL COutgoingCall::OnConferenceStarted(CONF_HANDLE hNewConf, HRESULT ncsResult)
{
	DebugEntry(COutgoingCall::OnConferenceStarted);

	switch (m_cnState)
	{
		case CNS_CREATING_LOCAL:
		{
			TRACE_OUT(("COutgoingCall (inviting) received ConferenceStarted event"));
			
			if (0 == ncsResult)
			{
				ASSERT(m_pConfObject);
				ASSERT(NULL == m_hRequest);

				SetCallState(CNS_INVITING_REMOTE);

				HRESULT hr = m_pConfObject->InviteConference(m_pszAddr, &m_hRequest);
				if (S_OK != hr)
				{
					m_hRequest = NULL;
					m_cnResult = CN_RC_INVITE_FAILED;
					SetCallState(CNS_COMPLETE);
					
					// Issue "soft" leave attempt (to allow auto-terminate)
					ASSERT(m_pConfObject);
					HRESULT hr = m_pConfObject->LeaveConference(FALSE);
					if (FAILED(hr))
					{
						WARNING_OUT(("Couldn't leave after failed invite"));
					}
				}
			}
			else
			{
				WARNING_OUT(("CreateConference (local) failed - need UI here!"));
				m_cnResult = CN_RC_CONFERENCE_CREATE_FAILED;
				SetCallState(CNS_COMPLETE);
			}
			
			break;
		}

		case CNS_JOINING_REMOTE:
		{
			TRACE_OUT(("COutgoingCall (joining) received ConferenceStarted event"));

			if (0 == ncsResult)
			{
				SetCallState(CNS_COMPLETE);
			}
			else if (UI_RC_INVALID_PASSWORD == ncsResult)
			{
				TRACE_OUT(("COutgoingCall - invalid password, prompt for password"));

				BSTR bstrPassword = NULL;
				REMOTE_PASSWORD remotePw;
				remotePw.bstrConference = m_bstrConfToJoin;
				remotePw.pbstrPassword = &bstrPassword;
				if (NO_ERROR != hNewConf->GetCred(&remotePw.pbRemoteCred, &remotePw.cbRemoteCred))
				{
					remotePw.pbRemoteCred = NULL;
					remotePw.cbRemoteCred = 0;
				}
				remotePw.fIsService = m_fService;
				NotifySink(&remotePw, OnNotifyRemotePassword);

				if (NULL != bstrPassword)
				{
					SysFreeString(m_bstrPassword);
					m_bstrPassword = bstrPassword;

					// reissue join with new password
					ASSERT(m_pConfObject);
					HRESULT ncs =
						m_pConfObject->JoinConference(	m_bstrConfToJoin,
														m_bstrPassword,
														m_pszAddr,
														TRUE); // retry

					if (0 != ncs)
					{
						// JoinConference failed!
						m_cnResult = CN_RC_JOIN_FAILED;
						SetCallState(CNS_COMPLETE);
					}
				}
				else
				{
					// cancel from pw dlg
					m_cnResult = CN_RC_INVALID_PASSWORD;
					SetCallState(CNS_COMPLETE);
					
					ASSERT(m_pConfObject);
					HRESULT hr = m_pConfObject->LeaveConference(TRUE);
					if (FAILED(hr))
					{
						ERROR_OUT(("Couldn't leave after cancelling pw join!"));
					}
				}
			}
			else if (UI_RC_UNKNOWN_CONFERENCE == ncsResult)
			{
				TRACE_OUT(("Join failed (conf does not exist) "
							"- notifying user"));
						
				// error while joining
				m_cnResult = CN_RC_CONFERENCE_DOES_NOT_EXIST;
				SetCallState(CNS_COMPLETE);
			}
			else
			{
				TRACE_OUT(("Join failed - notifying user"));
						
				// error while joining
				m_cnResult = CN_RC_CONFERENCE_JOIN_DENIED;
				SetCallState(CNS_COMPLETE);
			}

			break;
		}

		default:
		{
			if (m_pConfObject->GetConfHandle() == hNewConf)
			{
				WARNING_OUT(("COutgoingCall received unexpected ConferenceStarted event"));
			}
			else
			{
				TRACE_OUT(("COutgoingCall ignoring ConferenceStarted event - not our conf"));
			}
		}
	}

	DebugExitBOOL(COutgoingCall::OnConferenceStarted, TRUE);
	return TRUE;
}





void COutgoingCall::CallComplete()
{
	DebugEntry(COutgoingCall::CallComplete);

	// If this fails, we are being destructed unexpectedly
	
	ASSERT( (m_cnState == CNS_IDLE) ||
			(m_cnState == CNS_COMPLETE));

	// The request handle should have been reset
	ASSERT(NULL == m_hRequest);

	if (!FCanceled() && (CN_RC_NOERROR != m_cnResult))
	{
		ReportError(m_cnResult);
	}

	NM_CALL_STATE state;
	GetState(&state);
	NotifySink((PVOID) state, OnNotifyCallStateChanged);

	TRACE_OUT(("ConfNode destroying addr %s", m_pszAddr));
	DebugExitVOID(COutgoingCall::CallComplete);
}

BOOL COutgoingCall::ReportError(CNSTATUS cns)
{
	DebugEntry(COutgoingCall::ReportError);
	TRACE_OUT(("CNSTATUS 0x%08x", cns));
	
	NotifySink((PVOID)cns, OnNotifyCallError);

	DebugExitBOOL(COutgoingCall::ReportError, TRUE);
	return TRUE;
}



VOID COutgoingCall::SetCallState(CNODESTATE cnState)
{
	NM_CALL_STATE stateOld;
	NM_CALL_STATE stateNew;
	GetState(&stateOld);

	m_cnState = cnState;

	// completion state will be fired off later
	if (CNS_COMPLETE != cnState)
	{
		GetState(&stateNew);
		if (stateOld != stateNew)
		{
			NotifySink((PVOID) stateNew, OnNotifyCallStateChanged);
		}
	}
}

HRESULT COutgoingCall::_Cancel(BOOL fLeaving)
{
	DebugEntry(COutgoingCall::Cancel);

	BOOL fAbortT120 = (m_cnState != CNS_COMPLETE);

	if (fAbortT120)
	{
		m_fCanceled = TRUE;

		// Abort T.120 Call:


		// Attempt to make this transition regardless of our
		// current state:
		SetCallState(CNS_COMPLETE);

		ASSERT(m_pConfObject);

		if (NULL != m_hRequest)
		{
			REQUEST_HANDLE hRequest = m_hRequest;
			m_hRequest = NULL;
			m_pConfObject->CancelInvite(hRequest);
		}

		if (!fLeaving && m_pConfObject->IsConferenceActive())
		{
			HRESULT hr = m_pConfObject->LeaveConference(FALSE);
			if (FAILED(hr))
			{
				WARNING_OUT(("Couldn't leave after disconnecting"));
			}
		}
	}

	DebugExitULONG(COutgoingCall::Abort, m_cnResult);

	return CN_RC_NOERROR ? S_OK : E_FAIL;
}

STDMETHODIMP_(ULONG) COutgoingCall::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) COutgoingCall::Release(void)
{
	return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE COutgoingCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCall) || (riid == IID_IUnknown))
	{
		*ppv = (INmCall *)this;
		TRACE_OUT(("COutgoingCall::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		TRACE_OUT(("CNmCall::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		TRACE_OUT(("COutgoingCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

HRESULT COutgoingCall::IsIncoming(void)
{
	return S_FALSE;
}

HRESULT COutgoingCall::GetState(NM_CALL_STATE *pState)
{
	HRESULT hr = E_POINTER;

	if (NULL != pState)
	{
		if (FCanceled())
		{
			*pState = NM_CALL_CANCELED;
		}
		else
		{
			switch (m_cnState)
			{
				case CNS_IDLE:
					*pState = NM_CALL_INIT;
					break;

				case CNS_SEARCHING:
					*pState = NM_CALL_SEARCH;
					break;

				case CNS_WAITING_T120_OPEN:
				case CNS_QUERYING_REMOTE:
				case CNS_CREATING_LOCAL:
				case CNS_INVITING_REMOTE:
				case CNS_JOINING_REMOTE:
					*pState = NM_CALL_WAIT;
					break;

				case CNS_COMPLETE:
					switch (m_cnResult)
					{
					case CN_RC_NOERROR:
						*pState = NM_CALL_ACCEPTED;
						break;
					case CN_RC_CONFERENCE_JOIN_DENIED:
					case CN_RC_CONFERENCE_INVITE_DENIED:
					case CN_RC_CONFERENCE_DOES_NOT_EXIST:
					case CN_RC_CONNECT_REMOTE_NO_SECURITY:
					case CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY:
					case CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY:
					case CN_RC_TRANSPORT_FAILURE:
					case CN_RC_QUERY_FAILED:
					case CN_RC_CONNECT_FAILED:
						*pState = NM_CALL_REJECTED;
						break;

					case CN_RC_ALREADY_IN_CONFERENCE:
					case CN_RC_CANT_INVITE_MCU:
					case CN_RC_CANT_JOIN_ALREADY_IN_CALL:
					case CN_RC_INVITE_DENIED_REMOTE_IN_CONF:
					case CN_RC_REMOTE_PLACING_CALL:
					case CN_RC_ALREADY_IN_CONFERENCE_MCU:
					case CN_RC_INVALID_PASSWORD:
					default:
						*pState = NM_CALL_CANCELED;
						break;
					}
					break;

				default:
					*pState = NM_CALL_INVALID;
					break;
			}
		}

		hr = S_OK;
	}
	return hr;
}

HRESULT COutgoingCall::GetAddress(BSTR * pbstrAddr)
{
	if (NULL == pbstrAddr)
		return E_POINTER;

	*pbstrAddr = SysAllocString(m_bstrAddr);
	return (*pbstrAddr ? S_OK : E_FAIL);
}


HRESULT COutgoingCall::GetConference(INmConference **ppConference)
{
	HRESULT hr = E_POINTER;

	if (NULL != ppConference)
	{
		*ppConference = m_pConfObject;
		return S_OK;
	}

	return hr;
}

HRESULT COutgoingCall::Accept(void)
{
	return E_UNEXPECTED;
}

HRESULT COutgoingCall::Reject(void)
{
	return E_UNEXPECTED;
}

HRESULT COutgoingCall::Cancel(void)
{
	DebugEntry(COutgoingCall::Cancel);

	AddRef();		// protect against Release() while processing
					// disconnect related indications & callbacks

	HRESULT hr = _Cancel(FALSE);
	
	if (FIsComplete())
	{
		COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
		ASSERT(NULL !=pOprahNCUI);
		pOprahNCUI->OnOutgoingCallCanceled(this);
	}

	DebugExitULONG(COutgoingCall::Abort, m_cnResult);

	Release();

	return hr;
}

/*	O N  N O T I F Y  C A L L  E R R O R  */
/*-------------------------------------------------------------------------
	%%Function: OnNotifyCallError
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyCallError(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pCallNotify);
	CNSTATUS cnStatus = (CNSTATUS)((DWORD_PTR)pv);
	switch (cnStatus)
	{
		case CN_RC_ALREADY_IN_CONFERENCE:
		case CN_RC_CANT_INVITE_MCU:
		case CN_RC_CANT_JOIN_ALREADY_IN_CALL:
		case CN_RC_INVITE_DENIED_REMOTE_IN_CONF:
		case CN_RC_REMOTE_PLACING_CALL:
		case CN_RC_ALREADY_IN_CONFERENCE_MCU:
			((INmCallNotify*)pCallNotify)->NmUI(CONFN_CALL_IN_CONFERENCE);
			break;
		case CN_RC_CONFERENCE_JOIN_DENIED:
		case CN_RC_CONFERENCE_INVITE_DENIED:
		case CN_RC_CONFERENCE_DOES_NOT_EXIST:
		case CN_RC_CONNECT_REMOTE_NO_SECURITY:
		case CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY:
		case CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY:
			((INmCallNotify*)pCallNotify)->NmUI(CONFN_CALL_IGNORED);
			break;
		case CN_RC_CONNECT_FAILED:
			((INmCallNotify*)pCallNotify)->NmUI(CONFN_CALL_FAILED);
			break;
		default:
			break;
	}

	if (IID_INmCallNotify == riid)
	{
		((INmCallNotify*)pCallNotify)->CallError(cnStatus);
	}
	return S_OK;
}

/*	O N  N O T I F Y  R E M O T E  C O N F E R E N C E	*/
/*-------------------------------------------------------------------------
	%%Function: OnNotifyRemoteConference
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyRemoteConference(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	REMOTE_CONFERENCE *prc = (REMOTE_CONFERENCE *)pv;

	// WARNING: pwszConfName is an PWSTR array, not a BSTR

	ASSERT(NULL != pCallNotify);
	((INmCallNotify*)pCallNotify)->RemoteConference(prc->fMCU,
		(BSTR *) prc->pwszConfNames, prc->pbstrConfToJoin);
	return S_OK;
}

/*	O N  N O T I F Y  R E M O T E  P A S S W O R D	*/
/*-------------------------------------------------------------------------
	%%Function: OnNotifyRemotePassword
	
-------------------------------------------------------------------------*/
HRESULT OnNotifyRemotePassword(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	REMOTE_PASSWORD *prp = (REMOTE_PASSWORD *)pv;

	ASSERT(NULL != pCallNotify);
	((INmCallNotify*)pCallNotify)->RemotePassword(prp->bstrConference, prp->pbstrPassword, prp->pbRemoteCred, prp->cbRemoteCred);
	return S_OK;
}

COutgoingCallManager::COutgoingCallManager()
{
}

COutgoingCallManager::~COutgoingCallManager()
{
	// Empty the call list:
	while (!m_CallList.IsEmpty())
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.RemoveHead();
		// Shouldn't have any NULL entries:
		ASSERT(pCall);
		pCall->Release();
	}
}

UINT COutgoingCallManager::GetCallCount()
{
	UINT nNodes = 0;
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		nNodes++;
		m_CallList.GetNext(pos);
	}
	return nNodes;
}


HRESULT COutgoingCallManager::Call(
    INmCall **ppCall,
	COprahNCUI* pManager,
    DWORD dwFlags,
    NM_ADDR_TYPE addrType,
    BSTR bstrAddr,
    BSTR bstrConference,
    BSTR bstrPassword)
{
	DebugEntry(COutgoingCallManager::CallConference);
	HRESULT hr = E_FAIL;
	COutgoingCall* pCall = NULL;
	CConfObject* pConfObject = pManager->GetConfObject();
	
	if (NULL != ppCall)
	{
		*ppCall = NULL;
	}

	if (pConfObject->IsConferenceActive() && (NULL != bstrConference))
	{
		hr= NM_CALLERR_IN_CONFERENCE;	
	}
	else
	{
		if (!pConfObject->IsConferenceActive())
		{
			pConfObject->SetConfSecurity(0 != (CRPCF_SECURE & dwFlags));
		}

		pCall = new COutgoingCall(	pConfObject,
									dwFlags,
									addrType,
									bstrAddr,
									bstrConference,
									bstrPassword);
		if (NULL != pCall)
		{
			m_CallList.AddTail(pCall);

			if (NULL != ppCall)
			{
				pCall->AddRef();

				// This MUST be set before OnNotifyCallCreated
				*ppCall = pCall;
			}

			pCall->AddRef();

			pManager->OnOutgoingCallCreated(pCall);

			pCall->PlaceCall();

			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}

			pCall->Release();

			// let the caller know that we successfully created the call
			// any error will be reported asynchronously
			hr = S_OK;
		}
	}

	DebugExitHRESULT(COutgoingCallManager::CallConference, hr);
	return hr;
}

BOOL COutgoingCallManager::RemoveFromList(COutgoingCall* pCall)
{
	DebugEntry(COutgoingCallManager::RemoveFromList);
	ASSERT(pCall);
	BOOL bRet = FALSE;

	POSITION pos = m_CallList.GetPosition(pCall);
	if (NULL != pos)
	{
		m_CallList.RemoveAt(pos);

		pCall->CallComplete();
		pCall->Release();

		bRet = TRUE;
	}
	else
	{
		WARNING_OUT(("COutgoingCallManager::RemoveFromList() could not match call"));
	}

	DebugExitBOOL(COutgoingCallManager::RemoveFromList, bRet);
	return bRet;
}



VOID COutgoingCallManager::OnConferenceStarted(CONF_HANDLE hConference, HRESULT hResult)
{
	DebugEntry(COutgoingCallManager::OnConferenceStarted);

	// Tell all ConfNode's that a conference has started
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			pCall->AddRef();
			pCall->OnConferenceStarted(hConference, hResult);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
		}
	}

	DebugExitVOID(COutgoingCallManager::OnConferenceStarted);
}

VOID COutgoingCallManager::OnQueryRemoteResult(PVOID pvCallerContext,
										HRESULT hResult,
										BOOL fMCU,
										PWSTR* ppwszConferenceNames,
										PWSTR* ppwszConfDescriptors)
{
	DebugEntry(COutgoingCallManager::OnQueryRemoteResult);

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		// Notify the node that issued the query:
		
		if ((COutgoingCall*) pvCallerContext == pCall)
		{
			pCall->AddRef();
			pCall->OnQueryRemoteResult(	hResult,
										fMCU,
										ppwszConferenceNames,
										ppwszConfDescriptors);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
			break;
		}
	}
	
	DebugExitVOID(COutgoingCallManager::OnQueryRemoteResult);
}

VOID COutgoingCallManager::OnInviteResult(	CONF_HANDLE hConference,
											REQUEST_HANDLE hRequest,
											UINT uNodeID,
											HRESULT hResult)
{
	DebugEntry(COutgoingCallManager::OnInviteResult);

	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(pCall->GetCurrentRequestHandle() == hRequest))
		{
			pCall->AddRef();
			pCall->OnInviteResult(hResult, uNodeID);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
			break;
		}
	}

	DebugExitVOID(COutgoingCallManager::OnInviteResult);
}

VOID COutgoingCallManager::OnConferenceEnded(CONF_HANDLE hConference)
{
	DebugEntry(COutgoingCallManager::OnConferenceEnded);

	// Tell all ConfNode's that a conference has started
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			pCall->AddRef();
			pCall->OnConferenceEnded();
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
		}
	}

	DebugExitVOID(COutgoingCallManager::OnConferenceEnded);
}

VOID COutgoingCallManager::CancelCalls()
{
	DebugEntry(COutgoingCallManager::CancelCalls);

	// Tell all ConfNode's that a conference has started
	POSITION pos = m_CallList.GetHeadPosition();
	while (pos)
	{
		COutgoingCall* pCall = (COutgoingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			pCall->AddRef();
			pCall->_Cancel(TRUE);
			if (pCall->FIsComplete())
			{
				RemoveFromList(pCall);
			}
			pCall->Release();
		}
	}

	DebugExitVOID(COutgoingCallManager::CancelCalls);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\icall.h ===
/***************************************************************************/
/** 				 Microsoft Windows									  **/
/** 		   Copyright(c) Microsoft Corp., 1995-1996					  **/
/***************************************************************************/

//
//	The COutgoingCall class is defined, which is used while placing calls
//

#ifndef _ICALL_H_
#define _ICALL_H_

#include "cncodes.h"		// needed for CNSTATUS and CN_

class CConfObject;

class COutgoingCall : public INmCall, public RefCount, 
    public CConnectionPointContainer
{
private:
	enum CNODESTATE
	{
		CNS_IDLE,

		CNS_SEARCHING,		// dummy state to keep compatible with NM2.X

		CNS_WAITING_T120_OPEN,

		CNS_QUERYING_REMOTE,

		CNS_CREATING_LOCAL,
		CNS_INVITING_REMOTE,
		CNS_TERMINATING_AFTER_INVITE,
		CNS_QUERYING_REMOTE_AFTER_INVITE,

		CNS_JOINING_REMOTE,

		CNS_COMPLETE
	};

	// Attributes:
	CNODESTATE      m_cnState;
	CConfObject*	m_pConfObject;
	REQUEST_HANDLE	m_hRequest;
	BOOL            m_fCanceled;
	
	// User Info
	BSTR            m_bstrAddr;
	LPTSTR          m_pszAddr;
	BSTR            m_bstrConfToJoin;
	BSTR            m_bstrPassword;
	NM_ADDR_TYPE    m_addrType;
	DWORD           m_dwFlags;


	// Info that we obtain during processing
	CNSTATUS        m_cnResult;
	BOOL            m_fService;

	// Protected Methods:
	BOOL			ReportError(CNSTATUS cns);
	VOID			SetCallState(CNODESTATE cnState);

public:

	COutgoingCall(CConfObject* pco, DWORD dwFlags, NM_ADDR_TYPE addrType, BSTR bstrAdr,
		BSTR bstrConference, BSTR bstrPassword);

	~COutgoingCall();

						
	// Methods:
	VOID			PlaceCall(void);
	VOID			CallComplete(void);
	HRESULT 		_Cancel(BOOL fLeaving);

	// Properties:
	DWORD			GetFlags()					{ return m_dwFlags; }
	REQUEST_HANDLE	GetCurrentRequestHandle()	{ return m_hRequest; }
	BOOL			FCanceled() 				{ return m_fCanceled; }
	BOOL			FIsComplete()				{ return (CNS_COMPLETE == m_cnState); }

	BOOL			MatchActiveCallee(LPCTSTR pszDest, BSTR bstrAlias, BSTR bstrConference);


	
	// Event Handlers:
	
	// Received by only this COutgoingCall object
	BOOL			OnQueryRemoteResult(HRESULT ncsResult,
										BOOL fMCU,
										PWSTR pwszConfNames[],
										PWSTR pwszConfDescriptors[]);
	BOOL			OnInviteResult(HRESULT ncsResult, UINT uNodeID);
	
	// Received by all COutgoingCall objects sharing the same conference
	BOOL			OnConferenceEnded();
	
	// Received by all COutgoingCall objects
	BOOL			OnConferenceStarted(CONF_HANDLE hNewConf, 
										HRESULT ncsResult);

	STDMETHODIMP_(ULONG)	AddRef(void);
	STDMETHODIMP_(ULONG)	Release(void);
	STDMETHODIMP			QueryInterface(REFIID riid, PVOID *ppvObj);

	STDMETHODIMP 		IsIncoming(void);
	STDMETHODIMP 		GetState(NM_CALL_STATE *pState);
	STDMETHODIMP 		GetAddress(BSTR *pbstr);
	STDMETHODIMP 		GetConference(INmConference **ppConference);
	STDMETHODIMP 		Accept(void);
	STDMETHODIMP 		Reject(void);
	STDMETHODIMP 		Cancel(void);

};

class COprahNCUI;

class COutgoingCallManager
{
private:
	COBLIST	m_CallList;

	UINT			GetNodeCount();

	BOOL MatchActiveCallee(LPCTSTR pszDest, BSTR bstrAlias, BSTR bstrConference);

public:

	COutgoingCallManager();

	~COutgoingCallManager();

	UINT	GetCallCount();

	BOOL	RemoveFromList(COutgoingCall* pCall);

	HRESULT Call(	INmCall **ppCall,
					COprahNCUI* pManager,
					DWORD dwFlags,
					NM_ADDR_TYPE addrType,
					BSTR bstrAddr,
					BSTR bstrConference,
					BSTR bstrPassword);

	VOID OnConferenceStarted(CONF_HANDLE hConference, HRESULT hResult);

	VOID OnQueryRemoteResult(	PVOID pvCallerContext,
								HRESULT hResult,
								BOOL fMCU,
								PWSTR* ppwszConferenceNames,
								PWSTR* ppwszConfDescriptors);

	VOID OnInviteResult(	CONF_HANDLE hConference,
							REQUEST_HANDLE hRequest,
							UINT uNodeID,
							HRESULT hResult);

	VOID OnConferenceEnded(CONF_HANDLE hConference);

	VOID CancelCalls();
};

#endif // _ICALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\icall_in.cpp ===
// File: icallin.cpp

#include "precomp.h"

#include "cncodes.h"		// needed for CN_
#include "icall_in.h"
#include "imanager.h"

extern HRESULT OnNotifyCallError(IUnknown *pCallNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyCallAccepted(IUnknown *pCallNotify, PVOID pv, REFIID riid);

// Internal code to indicate that there was no security data available in an incoming call.
const int CALL_NO_SECURITY_DATA = -1;


static const IID * g_apiidCP_Call[] =
{
    {&IID_INmCallNotify}
};

CIncomingCall::CIncomingCall(
	COprahNCUI	  * pOprahNCUI,
	BOOL			fInvite,
	CONF_HANDLE		hConf,
	PCWSTR			pcwszNodeName) :
	CConnectionPointContainer(g_apiidCP_Call, ARRAY_ELEMENTS(g_apiidCP_Call)),
	m_pOprahNCUI(pOprahNCUI),
	m_fInvite(fInvite),
	m_hConf(hConf),
	m_bstrCaller(SysAllocString(pcwszNodeName)),
	m_State(NM_CALL_INIT),
	m_dwFlags(0)
{
	DebugEntry(CIncomingCall::CIncomingCall[T120]);

	DebugExitVOID(CIncomingCall::CIncomingCall);
}

CIncomingCall::CIncomingCall(COprahNCUI *pOprahNCUI, 
	DWORD dwFlags) :
	CConnectionPointContainer(g_apiidCP_Call, ARRAY_ELEMENTS(g_apiidCP_Call)),
	m_pOprahNCUI(pOprahNCUI),
	m_fInvite(FALSE),
	m_hConf(NULL),
	m_bstrCaller(NULL),
	m_State(NM_CALL_INIT),
	m_dwFlags(dwFlags),
	m_fMemberAdded(FALSE)
{
	DebugEntry(CIncomingCall::CIncomingCall);

	DebugExitVOID(CIncomingCall::CIncomingCall);
}

CIncomingCall::~CIncomingCall()
{
	DebugEntry(CIncomingCall::~CIncomingCall);

	SysFreeString(m_bstrCaller);

	DebugExitVOID(CIncomingCall::CIncomingCall);
}


void CIncomingCall::Ring()
{
	m_State = NM_CALL_RING;
	NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
}

VOID CIncomingCall::OnIncomingT120Call(BOOL fInvite)
{
	m_fInvite = fInvite;
}

HRESULT CIncomingCall::OnT120ConferenceEnded()
{
	m_hConf = NULL;

	if (NM_CALL_RING == m_State)
	{
		m_State = NM_CALL_CANCELED;
		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
	}

	return S_OK;
}

HRESULT CIncomingCall::Terminate(BOOL fReject)
{
	HRESULT hr = E_FAIL;

	// need to make sure that we are still ringing
	if ((NM_CALL_ACCEPTED != m_State) &&
		(NM_CALL_REJECTED != m_State) &&
		(NM_CALL_CANCELED != m_State))
	{
		m_State = fReject ? NM_CALL_REJECTED : NM_CALL_CANCELED;

		TRACE_OUT(("CIncomingCall: Call not accepted - responding"));

		if (NULL != m_hConf)
		{
			CONF_HANDLE hConf = m_hConf;
			m_hConf = NULL;
			if (m_fInvite)
			{
				hConf->InviteResponse(FALSE);
			}
			else
			{
				CConfObject *pco = ::GetConfObject();
				ASSERT(pco);

				if (pco->GetConfHandle() == hConf)
				{
					hConf->JoinResponse(FALSE);
				}
			}
		}

		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);

		hr = S_OK;
	}

	return hr;
}


STDMETHODIMP_(ULONG) CIncomingCall::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CIncomingCall::Release(void)
{
	return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CIncomingCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCall) || (riid == IID_IUnknown))
	{
		*ppv = (INmCall *)this;
		TRACE_OUT(("CIncomingCall::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		TRACE_OUT(("CIncomingCall::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		TRACE_OUT(("CIncomingCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

HRESULT CIncomingCall::IsIncoming(void)
{
	return S_OK;
}

HRESULT CIncomingCall::GetState(NM_CALL_STATE *pState)
{
	HRESULT hr = E_POINTER;

	if (NULL != pState)
	{
		*pState = m_State;
		hr = S_OK;
	}
	return hr;
}

HRESULT CIncomingCall::GetAddress(BSTR * pbstrName)
{
	if (NULL == pbstrName)
		return E_POINTER;

	*pbstrName = SysAllocString(m_bstrCaller);
	return (*pbstrName ? S_OK : E_FAIL);
}


HRESULT CIncomingCall::GetConference(INmConference **ppConference)
{
#ifdef NOTYET
	*ppConference = NULL;

	CConfObject *pco = ::GetConfObject();
	if (NULL != pco)
	{
		if (pco->GetConfHandle() == m_hConf)
		{
			*ppConference = pco;
			return S_OK;
		}
		return E_UNEXPECTED;
	}
#endif
	return S_FALSE;

}

HRESULT CIncomingCall::Accept(void)
{
	HRESULT hr = E_FAIL;

	// need to make sure that we are still ringing
	if (NM_CALL_RING == m_State)
	{
		m_pOprahNCUI->OnIncomingCallAccepted();

		CConfObject *pco = ::GetConfObject();
		ASSERT(pco);

		if ((NULL != m_hConf) && (pco->GetConfHandle() == m_hConf))
		{
			if (m_fInvite)
			{
				hr = m_hConf->InviteResponse(TRUE);
			}
			else
			if (pco->GetConfHandle() == m_hConf)
			{
				hr = m_hConf->JoinResponse(TRUE);
			}
		}

		if (S_OK == hr)
		{
			// notify all call observers that the call was accepted
			m_State = NM_CALL_ACCEPTED;
			NotifySink((INmConference *) pco, OnNotifyCallAccepted);
		}
		else
		{
			// call went away before it was accepted
			m_State = NM_CALL_CANCELED;
			NotifySink((PVOID)CN_RC_CONFERENCE_ENDED_BEFORE_ACCEPTED, OnNotifyCallError);
		}

		// notify all call observers of the state change
		NotifySink((PVOID) m_State, OnNotifyCallStateChanged);
	}
	else
	{
		hr = ((NM_CALL_ACCEPTED == m_State) ? S_OK : E_FAIL);
	}

	return hr;
}

HRESULT CIncomingCall::Reject(void)
{
	return Terminate(TRUE);
}

HRESULT CIncomingCall::Cancel(void)
{
	return Terminate(FALSE);
}

/*  O N  N O T I F Y  C A L L  A C C E P T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyCallAccepted
    
-------------------------------------------------------------------------*/
HRESULT OnNotifyCallAccepted(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pCallNotify);
	((INmCallNotify*)pCallNotify)->Accepted((INmConference *) pv);
	return S_OK;
}



CIncomingCallManager::CIncomingCallManager()
{
}

CIncomingCallManager::~CIncomingCallManager()
{
	// Empty the call list:
	while (!m_CallList.IsEmpty())
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.RemoveHead();
		// Shouldn't have any NULL entries:
		ASSERT(pCall);
		pCall->Release();
	}
}



VOID CIncomingCallManager::OnT120ConferenceEnded(CONF_HANDLE hConference)
{
	POSITION pos = m_CallList.GetHeadPosition();
	POSITION posItem;
	while (posItem = pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if ((NULL != pCall) &&
			(hConference == pCall->GetConfHandle()))
		{
			if (S_OK == pCall->OnT120ConferenceEnded())
			{
				m_CallList.RemoveAt(posItem);
				pCall->Release();
			}
		}
	}
}

HRESULT CIncomingCallManager::OnIncomingT120Call(
		COprahNCUI *pManager,
		BOOL fInvite,
		CONF_HANDLE hConf,
		PCWSTR pcwszNodeName,
		BOOL fSecure)
{
	HRESULT hr = S_OK;

	CIncomingCall *pCall = new CIncomingCall(pManager,
												 fInvite,
												 hConf,
												 pcwszNodeName);
	if (NULL != pCall)
	{
		// currently we don't add T120 calls to the call list
		pManager->OnIncomingCallCreated(pCall);

		pCall->Ring();

		// we're not holding on to the call so release it
		pCall->Release();
	}
	else
	{
		// unable to accept call
		if (fInvite)
		{
			hr = hConf->InviteResponse(FALSE);
		}
		else
		{
			hConf->JoinResponse(FALSE);
		}

		hr = E_OUTOFMEMORY;
	}

	return hr;
}


VOID CIncomingCallManager::CancelCalls()
{
	DebugEntry(CIncomingCallManager::CancelCalls);

	POSITION pos = m_CallList.GetHeadPosition();
	POSITION posItem;
	while (posItem = pos)
	{
		CIncomingCall* pCall = (CIncomingCall*) m_CallList.GetNext(pos);

		if (NULL != pCall)
		{
			if (SUCCEEDED(pCall->Terminate(FALSE)))
			{
				m_CallList.RemoveAt(posItem);
				pCall->Release();
			}
		}
	}

	DebugExitVOID(CIncomingCallManager::CancelCalls);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\icall_in.h ===
#ifndef _ICALL_IN_H_
#define _ICALL_IN_H_

// BUGBUG:
// This is defined as 128 because the RNC_ROSTER structure has the
// same limitation.  Investigate what the appropriate number is.
const int MAX_CALLER_NAME = 128;

class COprahNCUI;

class CIncomingCall : public INmCall, public RefCount, public CConnectionPointContainer
{
private:
	COprahNCUI	  * m_pOprahNCUI;
	BOOL			m_fInvite;
	CONF_HANDLE 	m_hConf;
	BSTR			m_bstrCaller;
	NM_CALL_STATE	m_State;
	UINT			m_dwFlags;
	BOOL			m_fMemberAdded;

public:
	CIncomingCall(  COprahNCUI *pOprahNCUI, 
						DWORD dwFlags);

	CIncomingCall(	COprahNCUI *pOprahNCUI,
						BOOL fInvite,
						CONF_HANDLE hConf,
						PCWSTR pcwszNodeName);

	~CIncomingCall();

	UINT			GetFlags() { return m_dwFlags; }
	BOOL			DidUserAccept() { return (NM_CALL_ACCEPTED == m_State); }

	VOID			SetConfHandle(CONF_HANDLE hConf) { m_hConf = hConf; }
	CONF_HANDLE		GetConfHandle() { return m_hConf; }
	VOID			OnIncomingT120Call(BOOL fInvite);
	HRESULT			OnT120ConferenceEnded();
	HRESULT			Terminate(BOOL fReject);

	void Ring();

	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	STDMETHODIMP IsIncoming(void);
	STDMETHODIMP GetState(NM_CALL_STATE *pState);
	STDMETHODIMP GetAddress(BSTR *pbstrName);
	STDMETHODIMP GetConference(INmConference **ppConference);
	STDMETHODIMP Accept(void);
	STDMETHODIMP Reject(void);
	STDMETHODIMP Cancel(void);
};

class CIncomingCallManager
{
private:
	COBLIST m_CallList;

public:
	CIncomingCallManager();
	~CIncomingCallManager();

	HRESULT OnIncomingT120Call(
			COprahNCUI *pManager,
			BOOL fInvite,
			CONF_HANDLE hConf,
			PCWSTR pcwszNodeName,
			BOOL fSecure);

	VOID	OnT120ConferenceEnded(CONF_HANDLE hConference);

	VOID CancelCalls();
};

#endif // _ICALL_IN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\ichnldat.h ===
// File: ichnldat.h
//

#ifndef _ICHNLDAT_H_
#define _ICHNLDAT_H_

typedef enum _scState {               /* State of data channel */
	SCS_UNINITIALIZED = 0,           // Nothing is valid
	SCS_CREATESAP,                   // Creating m_gcc_pIAppSap
	SCS_ATTACH,                      // Attaching
	SCS_ENROLL,                      // Enrolling in a conference
	SCS_JOIN_PRIVATE,                // Join the private channel
	SCS_REGRETRIEVE,                 // Checking the registry
	SCS_REGRETRIEVE_NEW,             // new channel must be created
	SCS_REGRETRIEVE_EXISTS,          // channel already exists
	SCS_JOIN_NEW,                    // Creating a new MCS channel
	SCS_REGCHANNEL,                  // Registering the MCS channel
	SCS_JOIN_OLD,                    // Joining an existing channel
	SCS_REGPRIVATE,                  // Register the private channel
	SCS_CONNECTED,                   // m_mcs_channel_id is valid
	SCS_TERMINATING,                 // shutting down
	SCS_JOIN_STATIC_CHANNEL          // Join a static channel
} SCSTATE;


// An application key consists of an MS Object ID + guid identifier + guid + node id
#define cbKeyApp (4 + 1 + sizeof(GUID) + sizeof(DWORD))
#define MAX_CHECKID_COUNT 80  // Maximum number of times to ask for channel Id

typedef struct _tagUcid {
	DWORD     dwUserId;           // Node ID
	ChannelID channelId;          // Private channel ID
	UserID    sender_id_public;
	UserID    sender_id_private;
} UCID;

// CNmMemberId
class CNmMemberId
{
private:
	UINT      m_cCheckId;          // non-zero means checking the ID

	ChannelID m_channelId;         // Private channel ID
	UserID    m_sender_id_public;
	UserID    m_sender_id_private;

	CNmMember *m_pMember;

public:
	CNmMemberId(CNmMember *pMember, UCID *pucid);

	ChannelID GetChannelId(void)  {return m_channelId;}
	ChannelID SenderId(void)      {return m_sender_id_public;}

	VOID  UpdateRosterInfo(UCID * pucid);
	BOOL  FSenderId(UserID id)    {return ((id == m_sender_id_public) || (id == m_sender_id_private));}

	UINT  GetCheckIdCount(void)   {return m_cCheckId;}
	VOID  SetCheckIdCount(UINT c) {m_cCheckId = c;}

	CNmMember *GetMember(void)    {return m_pMember;}
};




// INmChannelData
//
class CNmChannelData :  public INmChannelData,
                        public RefCount,
                    	public CConnectionPointContainer
{
private:
	GUID	m_guid;                  // SetGuid/GetGuid
	BOOL    m_fClosed;               // TRUE when CloseConnection is called
	BOOL    m_fActive;               // TRUE when data channel is active
	DWORD   m_dwUserIdLocal;         // Data channel needs to know local user id
	CConfObject * m_pConference;	 //	Helpful to get member list

	ULONG       m_cMember;           // Number of members in this channel
	COBLIST   * m_pListMemberId;	 // Member id list
	COBLIST	  * m_pListMember;       // Member list
	PGCCEnrollRequest	m_pGCCER;     // Enroll request from enrolling app

public:
	CNmChannelData(CConfObject * pConference, REFGUID rguid);
	~CNmChannelData();


	// Internal functions
	GUID * PGuid(void)      {return &m_guid;}
	VOID UpdatePeer(CNmMember * pMember, UCID *pucid, BOOL fAdd);
	VOID UpdateRoster(UCID * rgPeer, int cPeer, BOOL fAdd, BOOL fRemove);
	VOID UpdateMemberChannelId(DWORD dwUserId, ChannelID channelId);
	HRESULT OpenConnection(void);
	HRESULT CloseConnection(void);

	ULONG IsEmpty()               {return 0 == m_cMember;}
	COBLIST * GetMemberList()     {return m_pListMember;}
	VOID AddMember(CNmMember * pMember);
	VOID RemoveMember(CNmMember * pMember);

	CNmMemberId *GetMemberId(CNmMember *pMember);
	CNmMemberId *GetMemberId(DWORD dwUserId);
	VOID  UpdateRosterInfo(CNmMember *pMember, UCID * pucid);
	ChannelID GetChannelId(CNmMember *pMember);
	CNmMember *PMemberFromSenderId(UserID id);
	CConfObject * PConference() {return m_pConference;}
	DWORD GetLocalId()          {return m_dwUserIdLocal;}

	// INmChannelData methods
	STDMETHODIMP IsActive(void);
	STDMETHODIMP SetActive(BOOL fActive);
	STDMETHODIMP GetConference(INmConference **ppConference);
	STDMETHODIMP EnumMember(IEnumNmMember **ppEnum);
	STDMETHODIMP GetMemberCount(ULONG * puCount);	STDMETHODIMP GetGuid(GUID *pguid);
	STDMETHODIMP SendData(INmMember *pMember, ULONG uSize, LPBYTE pb, ULONG uOptions);
	STDMETHODIMP RegistryAllocateHandle(ULONG numberOfHandlesRequested);
	

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

/////////////////////////////////////////////////////////////


// class CT120Channel

private:
	DWORD DoJoin(SCSTATE scs);

	DWORD DoJoinStatic(ChannelID staticChannel);
	DWORD DoCreateSap(void);
	DWORD DoEnroll(void);
	DWORD DoJoinPrivate(void);
	DWORD DoAttach(void);
	DWORD DoRegRetrieve(void);
	DWORD DoRegChannel(void);
	DWORD DoJoinNew(void);
	DWORD DoJoinOld(void);
	DWORD DoRegPrivate(void);

	VOID  OnEntryConfirmRemote(GCCAppSapMsg * pMsg);
	VOID  OnEntryConfirmLocal(GCCAppSapMsg * pMsg);

public:
	// Methods:
	VOID InitCT120Channel(DWORD dwUserId);

	GUID * m_pGuid;
	CNmChannelData * m_pChannel;

	DWORD   m_dwUserId;
	BYTE    m_keyApp[cbKeyApp];
	BYTE    m_keyChannel[cbKeyApp];

	SCSTATE m_scs;         // Current state

	GCCConferenceID m_gcc_conference_id;
	IGCCAppSap      *m_gcc_pIAppSap;
	GCCSessionKey   m_gcc_session_key;
	GCCRegistryKey  m_gcc_registry_key;
	GCCRegistryItem m_gcc_registry_item;

	GCCRegistryKey  m_registry_key_Private;
	GCCRegistryItem m_registry_item_Private;
	
	ChannelID       m_mcs_channel_id;  // public channel ID
	PIMCSSap	    m_pmcs_sap;

	UserID          m_gcc_node_id;

	// m_mcs_sender_id is the result of MCS_ATTACH_USER_CONFIRM.
	// It is also the "sender_id" in MCS_SEND_DATA_INDICATION
	UserID          m_mcs_sender_id;

	// Properties:
	BOOL    FConnected(void)       {return (SCS_CONNECTED == m_scs);}
	ChannelID GetMcsChannelId()    {return m_mcs_channel_id;}
	ChannelID SenderChannelId()    {return m_mcs_sender_id;}

	VOID    CloseChannel(VOID);
	HRESULT HrSendData(ChannelID channelId, DWORD dwUserId, LPVOID lpv, DWORD cb, ULONG opt);
	VOID    UpdateScState(SCSTATE scs, DWORD dwErr);
	VOID    ProcessEntryConfirm(GCCAppSapMsg * pMsg);
	BOOL    UpdateRoster(GCCAppSapMsg * pMsg);
	VOID    RemovePeer(UINT iPeer);
	VOID    RequestChannelId(DWORD dwUserId);
	VOID    NotifyChannelConnected(void);
	VOID    ProcessHandleConfirm(GCCAppSapMsg * pMsg);

};
DECLARE_STANDARD_TYPES(CNmChannelData);

void CALLBACK NmGccMsgHandler(GCCAppSapMsg * pMsg);
void CALLBACK NmMcsMsgHandler(unsigned int uMsg, LPARAM lParam, PVOID pv);

// list management
POSITION AddNode(PVOID pv, COBLIST **ppList);
PVOID RemoveNodePos(POSITION * pPos, COBLIST *pList);
VOID  RemoveNode(PVOID pv, COBLIST * pList);

// Data Notification Structure
typedef struct {
	INmMember * pMember;
	LPBYTE   pb;
	ULONG    cb;
	ULONG    dwFlags;
} NMN_DATA_XFER;


// Global Routines
VOID FreeMemberIdList(COBLIST ** ppList);
HRESULT	OnNmDataSent(IUnknown *pConferenceNotify, void *pv, REFIID riid);
HRESULT OnNmDataReceived(IUnknown *pConferenceNotify, void *pv, REFIID riid);
HRESULT	OnAllocateHandleConfirm(IUnknown *pConferenceNotify, void *pv, REFIID riid);



#endif // _ICHNLDAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\iconf.cpp ===
// File: iconf.cpp

#include "precomp.h"
#include "version.h"
#include "imanager.h"

// BUGBUG:
// This is defined as 128 because the RNC_ROSTER structure has the
// same limitation.  Investigate what the appropriate number is.
const int MAX_CALLER_NAME = 128;

static const WCHAR _szConferenceNameDefault[] = L"Personal Conference";


static HRESULT OnNotifyStateChanged(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyMemberAdded(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyMemberUpdated(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyMemberRemoved(IUnknown *pConfNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyNmUI(IUnknown *pConfNotify, PVOID pv, REFIID riid);


static const IID * g_apiidCP[] =
{
    {&IID_INmConferenceNotify}
};



CConfObject::CConfObject() :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_hConf				(NULL),
	m_csState			(CS_UNINITIALIZED),
	m_fConferenceCreated(FALSE),
	m_bstrConfName      (NULL),
	m_fServerMode		(FALSE),
	m_uMembers			(0),
	m_ourNodeID			(0),
	m_pMemberLocal      (NULL),
	m_uGCCConferenceID	(0),
	m_fSecure			(FALSE),
	m_cRef				(1)
{
	DebugEntry(CConfObject::CConfObject);

	DebugExitVOID(CConfObject::CConfObject);
}

CConfObject::~CConfObject()
{
	DebugEntry(CConfObject::~CConfObject);

	// Empty the participant list:
	while (!m_MemberList.IsEmpty())
	{
		CNmMember * pMember = (CNmMember *) m_MemberList.RemoveHead();
		// Shouldn't have any NULL entries:
		ASSERT(pMember);
		pMember->Release();
	}

	SysFreeString(m_bstrConfName);

	DebugExitVOID(CConfObject::~CConfObject);
}

VOID CConfObject::SetConfName(BSTR bstr)
{
	SysFreeString(m_bstrConfName);
	m_bstrConfName = SysAllocString(bstr);
}


VOID CConfObject::SetConfSecurity(BOOL fSecure)
{
	NM_CONFERENCE_STATE NmState;

	m_fSecure = fSecure;

	// Force update of the status icon to reflect security
	GetState(&NmState);
	NotifySink((PVOID) NmState, OnNotifyStateChanged);
}


HRESULT CConfObject::CreateConference(void)
{
	DebugEntry(CConfObject::CreateConference);
	HRESULT nsRet = E_FAIL;

	switch (m_csState)
	{
		case CS_UNINITIALIZED:
		case CS_TERMINATED:
		{
			if ((NULL == m_bstrConfName) || (0 == *m_bstrConfName))
			{
				m_bstrConfName = SysAllocString(_szConferenceNameDefault);
			}
			TRACE_OUT(("CConfObject:CreateConference [%ls]", m_bstrConfName));
			
			ASSERT(g_pNodeController);
			ASSERT(NULL == m_hConf);
			nsRet = g_pNodeController->CreateConference(
											m_bstrConfName,
											NULL,
											NULL,
											0,
											m_fSecure,
											&m_hConf);
			
			if (0 == nsRet)
			{
				SetT120State(CS_CREATING);
			}
			else
			{
				m_hConf = NULL;
			}
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't create - bad state"));
			nsRet = E_FAIL;
		}
	}
	
	DebugExitINT(CConfObject::CreateConference, nsRet);
	return nsRet;
}

HRESULT CConfObject::JoinConference(    LPCWSTR pcwszConferenceName,
										LPCWSTR	pcwszPassword,
									 	LPCSTR	pcszAddress,
										BOOL fRetry)
{
	DebugEntry(CConfObject::JoinConference);
	HRESULT nsRet = E_FAIL;



	switch (m_csState)
	{
		case CS_COMING_UP:
		{
			if (!fRetry)
			{
				break;
			}
			// fall through if this is another attempt to join
		}
		case CS_UNINITIALIZED:
		case CS_TERMINATED:
		{
			TRACE_OUT(("CConfObject: Joining conference..."));
			
			ASSERT(g_pNodeController);
			nsRet = g_pNodeController->JoinConference(pcwszConferenceName,
														pcwszPassword,
														pcszAddress,
														m_fSecure,
														&m_hConf);
			
			if (0 == nsRet)
			{
				SetT120State(CS_COMING_UP);
			}
			else
			{
				m_hConf = NULL;
			}
			break;
		}

		case CS_GOING_DOWN:
		default:
		{
			WARNING_OUT(("CConfObject: Can't join - bad state"));
			// BUGBUG: define return values
			nsRet = 1;
		}
	}
	
	DebugExitINT(CConfObject::JoinConference, nsRet);

	return nsRet;
}



HRESULT CConfObject::InviteConference(	LPCSTR	Address,
										REQUEST_HANDLE *phRequest )
{
	DebugEntry(CConfObject::InviteConference);
	HRESULT nsRet = E_FAIL;
	ASSERT(phRequest);

	switch (m_csState)
	{
		case CS_RUNNING:
		{
			TRACE_OUT(("CConfObject: Inviting conference..."));
			
			ASSERT(g_pNodeController);
			ASSERT(m_hConf);
			m_hConf->SetSecurity(m_fSecure);
			nsRet = m_hConf->Invite(Address,
									phRequest);
			
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't invite - bad state"));
			nsRet = E_FAIL;
		}
	}
	
	DebugExitINT(CConfObject::InviteConference, nsRet);
	return nsRet;
}
	
HRESULT CConfObject::LeaveConference(BOOL fForceLeave)
{
	DebugEntry(CConfObject::LeaveConference);
	HRESULT nsRet = E_FAIL;
	REQUEST_HANDLE hReq = NULL;

	switch (m_csState)
	{
		case CS_GOING_DOWN:
		{
			// we're already going down
			nsRet = S_OK;
			break;
		}
	
		case CS_COMING_UP:
		case CS_RUNNING:
		{
			if (FALSE == fForceLeave)
			{
				COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
				if (NULL != pOprahNCUI)
				{
					int nNodes = pOprahNCUI->GetOutgoingCallCount();

					if (m_fServerMode || (nNodes > 1) || (m_uMembers > 1))
					{
						// We are either in the process of calling another node
						// or we have other people in our conference roster
						TRACE_OUT(("CConfObject: Not leaving (there are other nodes)"));
						break;
					}
				}
			}
			
			TRACE_OUT(("CConfObject: Leaving conference..."));
			
			ASSERT(g_pNodeController);
			ASSERT(m_hConf);
			
			SetT120State(CS_GOING_DOWN);
			nsRet = m_hConf->Leave();
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't leave - bad state"));
			break;
		}
	}
	
	DebugExitINT(CConfObject::LeaveConference, nsRet);
	return nsRet;
}
	

BOOL CConfObject::OnT120Invite(CONF_HANDLE hConference, BOOL fSecure)
{
	DebugEntry(CConfObject::OnT120Invite);

	BOOL bRet = FALSE;

	switch (m_csState)
	{
		case CS_UNINITIALIZED:
		case CS_TERMINATED:
		{
			TRACE_OUT(("CConfObject: Accepting a conference invitation..."));
			
			ASSERT(g_pNodeController);
			ASSERT(NULL == m_hConf);
			m_hConf = hConference;

            m_fSecure = fSecure;
			hConference->SetSecurity(m_fSecure);

			// WORKITEM need to issue INmManagerNotify::ConferenceCreated()
			SetT120State(CS_COMING_UP);

			bRet = TRUE;
			break;
		}

		default:
		{
			WARNING_OUT(("CConfObject: Can't accept invite - bad state"));
		}
	}
	
	DebugExitBOOL(CConfObject::OnT120Invite, bRet);
	return bRet;
}

BOOL CConfObject::OnRosterChanged(PNC_ROSTER pRoster)
{
	DebugEntry(CConfObject::OnRosterChanged);

	BOOL bRet = TRUE;
	int i;

	// REVIEW: Could these be done more efficiently?
	
	if (NULL != pRoster)
	{
		UINT nExistingParts = 0;
		// Allocate an array of markers:
		UINT uRosterNodes = pRoster->uNumNodes;
		LPBOOL pMarkArray = new BOOL[uRosterNodes];

		m_ourNodeID = pRoster->uLocalNodeID;
		m_uGCCConferenceID = pRoster->uConferenceID;

		if (NULL != pRoster->pwszConferenceName)
		{
			SysFreeString(m_bstrConfName);
			m_bstrConfName = SysAllocString(pRoster->pwszConferenceName);
		}
		
		if (NULL != pMarkArray)
		{
			// Zero out the array:
            for (UINT i = 0; i < uRosterNodes; i++)
            {
                pMarkArray[i] = FALSE;
            }
			
			// For all participants still in the roster,
			//   clear out the reserved flags and
			//   copy in new UserInfo
			POSITION pos = m_MemberList.GetHeadPosition();
			while (NULL != pos)
			{
				CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
				ASSERT(pMember);
				pMember->RemovePf(PF_INCONFERENCE);
				
				for (UINT uNode = 0; uNode < uRosterNodes; uNode++)
				{
					if (pMember->GetGCCID() == pRoster->nodes[uNode].uNodeID)
					{
						nExistingParts++;
						pMarkArray[uNode] = TRUE;	// mark this node as "existing member"
                    	pMember->AddPf(PF_INCONFERENCE);
						break;
					}
				}

			}
			
			RemoveOldMembers(m_uMembers - nExistingParts);

			if (pRoster->uNumNodes > nExistingParts)
			{
#ifdef _DEBUG
				UINT nAdded = 0;
#endif // _DEBUG
				// At least one participant joined:
				// find the new participant(s)
				for (UINT uNode = 0; uNode < uRosterNodes; uNode++)
				{
					if (FALSE == pMarkArray[uNode]) 	// a new participant?
					{
						BOOL fLocal = FALSE;
						CNmMember * pMember = NULL;

						
						if (m_ourNodeID == pRoster->nodes[uNode].uNodeID)
						{
							fLocal = TRUE;
						}
			
						if (fLocal)
						{
							pMember = GetLocalMember();
						}
						else
						{
							pMember = NULL;
						}

						if(pMember)
						{
#ifdef _DEBUG
    						nAdded++; // a data participant was effectively added
#endif // _DEBUG
						}
						else
						{
							pMember = CreateMember(
												fLocal,
												0,
												&pRoster->nodes[uNode]);
#ifdef _DEBUG
							if (NULL != pMember)
							{
								nAdded++;
							}
#endif // _DEBUG
							AddMember(pMember);
						}
					}
				}
				// Validate that we did the right thing:
				ASSERT(nAdded == (uRosterNodes - nExistingParts));
			}
			delete pMarkArray;
			pMarkArray = NULL;
		}
		else
		{
			ERROR_OUT(("Couldn't allocate pMarkArray - no roster diff done"));
		}

		// Check to decide if we should auto-terminate here..
		if ((1 == pRoster->uNumNodes) &&
			(m_uMembers > 1))
		{
			if (!m_fServerMode)
			{
				LeaveConference(FALSE); // don't force (we could be inviting)
			}
		}	
	}
	else
	{
		WARNING_OUT(("NULL pRoster passed to CConfObject::OnRosterChanged!"));
	}

	DebugExitBOOL(CConfObject::OnRosterChanged, bRet);
	return bRet;
}

VOID CConfObject::AddMember(CNmMember * pMember)
{
	DebugEntry(CConfObject::AddMember);

	if (NULL == pMember)
	{
		ERROR_OUT(("AddMember - null member!"));
        goto Done;
	}

	NM_CONFERENCE_STATE oldNmState, newNmState;
	GetState(&oldNmState);

	m_MemberList.AddTail(pMember);
	m_uMembers++;

	CheckState(oldNmState);

	NotifySink((INmMember *) pMember, OnNotifyMemberAdded);

Done:
	DebugExitVOID(CConfObject::AddMember);
}

VOID CConfObject::RemoveMember(POSITION pos)
{
	DebugEntry(CConfObject::RemoveMember);

	NM_CONFERENCE_STATE oldNmState, newNmState;

	GetState(&oldNmState);

	CNmMember * pMember = (CNmMember *) m_MemberList.RemoveAt(pos);
	--m_uMembers;

	if (pMember->FLocal())
	{
		// this is the local node:
		m_pMemberLocal = NULL;
	}

	NotifySink((INmMember *) pMember, OnNotifyMemberRemoved);
	pMember->Release();

	// Sanity check:
	ASSERT((m_uMembers >= 0) &&
			(m_uMembers < 10000));

	CheckState(oldNmState);

	DebugExitVOID(CConfObject::RemoveMember);
}

BOOL CConfObject::OnConferenceEnded()
{
	DebugEntry(CConfObject::OnConferenceEnded);
	BOOL bRet = TRUE;

	switch (m_csState)
	{
		case CS_GOING_DOWN:
		{
			TRACE_OUT(("ConfEnded received (from CS_GOING_DOWN)"));
			break;
		}

		case CS_RUNNING:
		{
			TRACE_OUT(("ConfEnded received (from CS_RUNNING)"));
			break;
		}

		case CS_COMING_UP:
		{
			TRACE_OUT(("ConfEnded received (from CS_COMING_UP)"));
			break;
		}

		default:
		{
			WARNING_OUT(("ConfEnded received (UNEXPECTED)"));
		}
	}

	if (NULL != m_hConf)
	{
		m_hConf->ReleaseInterface();
		m_hConf = NULL;
	}
	SetT120State(CS_TERMINATED);

	TRACE_OUT(("OnConferenceEnded(), num participants is %d", m_uMembers));

	// Empty the participant list:
	NC_ROSTER FakeRoster;
	ClearStruct(&FakeRoster);
	FakeRoster.uConferenceID = m_uGCCConferenceID;
	OnRosterChanged(&FakeRoster);

	ASSERT(0 == m_ourNodeID);
	ASSERT(0 == m_uMembers);

	// Reset member variables that pertain to a conference
	m_uGCCConferenceID = 0;
	m_fServerMode = FALSE;

	SysFreeString(m_bstrConfName);
	m_bstrConfName = NULL;

	DebugExitBOOL(CConfObject::OnConferenceEnded, bRet);
	return bRet;
}

BOOL CConfObject::OnConferenceStarted(CONF_HANDLE hConf, HRESULT hResult)
{
	DebugEntry(CConfObject::OnConferenceStarted);
	BOOL bRet = TRUE;

	ASSERT(hConf == m_hConf);

	switch (m_csState)
	{
		case CS_CREATING:
		case CS_COMING_UP:
		{
			switch(hResult)
			{
				case S_OK:
					TRACE_OUT(("ConfStarted received -> now running"));
					SetT120State(CS_RUNNING);
					break;
				case UI_RC_INVALID_PASSWORD:
					// nop, don't mess with state
					// the conference is still coming up
					// the incoming call handler will deal with this
					break;
				default:
					SetT120State(CS_GOING_DOWN);
					TRACE_OUT(("ConfStarted failed"));
					break;
			}
			break;
		}

		default:
		{
			WARNING_OUT(("OnConferenceStarted received (UNEXPECTED)"));
			break;
		}
	}

	DebugExitBOOL(CConfObject::OnConferenceStarted, bRet);
	return bRet;
}





VOID CConfObject::RemoveOldMembers(int nExpected)
{
	DebugEntry(CConfObject::RemoveOldMembers);

#ifdef _DEBUG
	int nRemoved = 0;
#endif // _DEBUG
	ASSERT(nExpected >= 0);

	if (nExpected > 0)
	{
		// At least one participant left:
		POSITION pos = m_MemberList.GetHeadPosition();
		while (NULL != pos)
		{
			POSITION oldpos = pos;
			CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
			ASSERT(pMember);
			DWORD dwFlags = pMember->GetDwFlags();
			if (!(PF_INCONFERENCE & dwFlags))
			{
				// This one is not in the data call:
				TRACE_OUT(("CConfObject Roster: %ls (%d) has left.",
							pMember->GetName(), pMember->GetGCCID()));

#ifdef _DEBUG
    			nRemoved++;
#endif // _DEBUG

    			// If they were data only, then remove:
				RemoveMember(oldpos);
			}
		}

		// Validate that we did the right thing:
		ASSERT(nRemoved == nExpected);
	}

	DebugExitVOID(CConfObject::RemoveOldMembers);
}




CNmMember * CConfObject::CreateMember(BOOL fLocal,
												UINT uCaps,
											    NC_ROSTER_NODE_ENTRY* pRosterNode)
{
	DebugEntry(CConfObject::CreateMember);

	ASSERT(NULL != pRosterNode);

	DWORD dwFlags = 0;
	if (fLocal)
	{
		dwFlags |= PF_LOCAL_NODE;
	}
	if (pRosterNode->fMCU)
	{
		dwFlags |= PF_T120_MCU;
	}

	CNmMember * pMember = new CNmMember(pRosterNode->pwszNodeName,
										pRosterNode->uNodeID,
										dwFlags,
										uCaps);

	if (NULL != pMember)
	{
		pMember->SetGccIdParent(pRosterNode->uSuperiorNodeID);
		
		if (fLocal)
		{
			ASSERT(NULL == m_pMemberLocal);
			m_pMemberLocal = pMember;
		}
	}

	TRACE_OUT(("CConfObject Roster: %ls (%d) has joined.", pRosterNode->pwszNodeName, pRosterNode->uNodeID));

	DebugExitPVOID(CConfObject::CreateMember, pMember);
	return pMember;
}

VOID CConfObject::OnMemberUpdated(INmMember *pMember)
{
	NotifySink(pMember, OnNotifyMemberUpdated);
}


VOID CConfObject::SetT120State(CONFSTATE state)
{
	NM_CONFERENCE_STATE oldNmState;

	GetState(&oldNmState);
	m_csState = state;
	if ( state == CS_TERMINATED )
		m_fSecure = FALSE; // Reset secure flag
	CheckState(oldNmState);
}

VOID CConfObject::CheckState(NM_CONFERENCE_STATE oldNmState)
{
	NM_CONFERENCE_STATE newNmState;
	GetState(&newNmState);
	if (oldNmState != newNmState)
	{
		NotifySink((PVOID) newNmState, OnNotifyStateChanged);
		if (NM_CONFERENCE_IDLE == newNmState)
		{
			m_fConferenceCreated = FALSE;
		}
	}
}



ULONG CConfObject::AddRef(void)
{
	return ++m_cRef;
}
	
ULONG CConfObject::Release(void)
{
	ASSERT(m_cRef > 0);

	if (m_cRef > 0)
	{
		m_cRef--;
	}

	ULONG cRef = m_cRef;

	if (0 == cRef)
	{
		delete this;
	}

	return cRef;
}

HRESULT STDMETHODCALLTYPE CConfObject::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if((riid == IID_INmConference) || (riid == IID_IUnknown))
	{
		*ppv = (INmConference *)this;
		TRACE_OUT(("CConfObject::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		TRACE_OUT(("CConfObject::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		TRACE_OUT(("CConfObject::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

HRESULT CConfObject::GetName(BSTR *pbstrName)
{
	HRESULT hr = E_POINTER;

	if (NULL != pbstrName)
	{
		*pbstrName = SysAllocString(m_bstrConfName);
		hr = *pbstrName ? S_OK : E_FAIL;
	}
	return hr;
}

HRESULT CConfObject::GetID(ULONG *puID)
{
	HRESULT hr = E_POINTER;

	if (NULL != puID)
	{
		*puID = m_uGCCConferenceID;
		hr = S_OK;
	}
	return hr;
}

HRESULT CConfObject::GetState(NM_CONFERENCE_STATE *pState)
{
	HRESULT hr = E_POINTER;

	if (NULL != pState)
	{
		hr = S_OK;

		switch (m_csState)
		{
			// Note: All states are valid (at least, for now)
			case CS_CREATING:
			case CS_UNINITIALIZED:
			case CS_TERMINATED:
				*pState = NM_CONFERENCE_IDLE;
				break;

			case CS_COMING_UP:
			case CS_GOING_DOWN:
			case CS_RUNNING:
				if (m_uMembers < 2)
				{
					if (m_fServerMode)
					{
						*pState = NM_CONFERENCE_WAITING;
					}
					else
					{
						*pState = NM_CONFERENCE_INITIALIZING;
					}
				}
				else
				{
					*pState = NM_CONFERENCE_ACTIVE;
				}
				break;
			default:
				hr = E_FAIL;
				break;
		}
	}
	return hr;
}


HRESULT CConfObject::GetTopProvider(INmMember **ppMember)
{
	CNmMember *pMemberRet = NULL;
	HRESULT hr = E_POINTER;

	if (NULL != ppMember)
	{
		POSITION pos = m_MemberList.GetHeadPosition();
		while (NULL != pos)
		{
			CNmMember *pMember = (CNmMember *) m_MemberList.GetNext(pos);
			ASSERT(pMember);

			if (pMember->FTopProvider())
			{
				// We have found the top provider
				pMemberRet = pMember;
				break;
			}
		}

		*ppMember = pMemberRet;
		hr = (NULL != pMemberRet) ? S_OK : S_FALSE;
	}
	return hr;
}


HRESULT CConfObject::EnumMember(IEnumNmMember **ppEnum)
{
	HRESULT hr = E_POINTER;

	if (NULL != ppEnum)
	{
		*ppEnum = new CEnumNmMember(&m_MemberList, m_uMembers);
		hr = (NULL != *ppEnum) ? S_OK : E_OUTOFMEMORY;
	}
	return hr;
}

HRESULT CConfObject::GetMemberCount(ULONG *puCount)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCount)
	{
		*puCount = m_uMembers;
		hr = S_OK;
	}
	return hr;
}


HRESULT CConfObject::FindMember(ULONG gccID, INmMember ** ppMember)
{
    CNmMember * pMember;

    if (!ppMember)
        return E_POINTER;

    pMember = PMemberFromGCCID(gccID);
    if (pMember)
    {
        pMember->AddRef();
    }

    *ppMember = pMember;
    return S_OK;
}




/*  P  M E M B E R  L O C A L  */
/*-------------------------------------------------------------------------
    %%Function: PMemberLocal

-------------------------------------------------------------------------*/
CNmMember * PMemberLocal(COBLIST *pList)
{
	if (NULL != pList)
	{
		POSITION posCurr;
		POSITION pos = pList->GetHeadPosition();
		while (NULL != pos)
		{
			posCurr = pos;
			CNmMember * pMember = (CNmMember *) pList->GetNext(pos);
			ASSERT(NULL != pMember);
			if (pMember->FLocal())
				return pMember;
		}
	}
	return NULL;
}


STDMETHODIMP CConfObject::CreateDataChannel
(
    INmChannelData **   ppChannel,
    REFGUID             rguid
)
{
    HRESULT             hr = E_FAIL;

    DebugEntry(CConfObject::CreateDataChannel);

	if (NULL != ppChannel)
	{
		if (IsBadWritePtr(ppChannel, sizeof(LPVOID)))
			return E_POINTER;
		*ppChannel = NULL;
	}

	if (GUID_NULL == rguid)
	{
		WARNING_OUT(("CreateDataChannel: Null guid"));
		return E_INVALIDARG;
	}

	// Make sure we're in a data conference
	CNmMember * pMember = PMemberLocal(&m_MemberList);
	if (NULL == pMember)
    {
        WARNING_OUT(("CreateDataChannel: No members yet"));
		return E_FAIL;
    }

	CNmChannelData * pChannel = new CNmChannelData(this, rguid);
	if (NULL == pChannel)
	{
		WARNING_OUT(("CreateDataChannel: Unable to create data channel"));
		return E_OUTOFMEMORY;
	}

	hr = pChannel->OpenConnection();
	if (FAILED(hr))
	{
		ERROR_OUT(("CreateDataChannel: Unable to set guid / create T.120 channels"));
		// Failed to create T.120 data channels
		delete pChannel;
		*ppChannel = NULL;
		return hr;
	}

	if (NULL != ppChannel)
	{
		*ppChannel = (INmChannelData *)pChannel;
	}
	else
	{
		pChannel->Release(); // No one is watching this channel? - free it now
	}

	hr = S_OK;

    DebugExitHRESULT(CConfObject::CreateDataChannel, hr);
    return hr;
}



HRESULT CConfObject::IsHosting(void)
{
	return m_fServerMode ? S_OK : S_FALSE;
}


HRESULT CConfObject::Host(void)
{
	HRESULT hr = E_FAIL;

	if (m_fServerMode || IsConferenceActive())
	{
		WARNING_OUT(("Conference already exists!"));
//		ncsRet = UI_RC_CONFERENCE_ALREADY_EXISTS;
	}
	else
	{
		HRESULT ncsRet = CreateConference();
		if (S_OK == ncsRet)
		{
			// The only success case:
			TRACE_OUT(("Create local issued successfully"));
			m_fServerMode = TRUE;
			hr = S_OK;
		}
		else
		{
			// UI?
			WARNING_OUT(("Create local failed!"));
		}
	}
	return hr;
}

HRESULT CConfObject::Leave(void)
{
	DebugEntry(CConfObject::Leave);

	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
		pOprahNCUI->CancelCalls();
	}

	HRESULT hr = S_OK;
	switch (m_csState)
	{
		case CS_GOING_DOWN:
			// we are already exiting
			break;

		case CS_COMING_UP:
		case CS_RUNNING:
		{
			SetT120State(CS_GOING_DOWN);
			ASSERT(m_hConf);
			TRACE_OUT(("Calling IDataConference::Leave"));
			hr = m_hConf->Leave();
			if (FAILED(hr))
			{
				WARNING_OUT(("IDataConference::Leave failed"));
			}
			break;
		}

		default:
			hr = E_FAIL;
			break;
	}

	DebugExitHRESULT(CConfObject::Leave, hr);
	return hr;
}



HRESULT CConfObject::LaunchRemote(REFGUID rguid, INmMember *pMember)
{
	DWORD dwUserId = 0;
	if(m_hConf)
	{
		if (NULL != pMember)
		{
			dwUserId = ((CNmMember*)pMember)->GetGCCID();
		}

		ASSERT(g_pNodeController);
		ASSERT(m_hConf);
		HRESULT nsRet = m_hConf->LaunchGuid(&rguid,
			(PUINT) &dwUserId, (0 == dwUserId) ? 0 : 1);

		return (S_OK == nsRet) ? S_OK : E_FAIL;
	}

	return NM_E_NO_T120_CONFERENCE;
}


/****************************************************************************
*
*	 CLASS:    CConfObject
*
*	 FUNCTION: GetConferenceHandle(DWORD *)
*
*	 PURPOSE:  Gets the T120 conference handle
*
****************************************************************************/

STDMETHODIMP CConfObject::GetConferenceHandle(DWORD_PTR *pdwHandle)
{
	HRESULT hr = E_FAIL;

	if (NULL != pdwHandle)
	{
		CONF_HANDLE hConf = GetConfHandle();
		*pdwHandle = (DWORD_PTR)hConf;
		hr = S_OK;
	}
	return hr;

}

/*  O N  N O T I F Y  S T A T E  C H A N G E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyStateChanged

-------------------------------------------------------------------------*/
HRESULT OnNotifyStateChanged(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->StateChanged((NM_CONFERENCE_STATE)((DWORD_PTR)pv));
	return S_OK;
}

/*  O N  N O T I F Y  M E M B E R  A D D E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyMemberAdded

-------------------------------------------------------------------------*/
HRESULT OnNotifyMemberAdded(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->MemberChanged(NM_MEMBER_ADDED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  M E M B E R  U P D A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyMemberUpdated

-------------------------------------------------------------------------*/
HRESULT OnNotifyMemberUpdated(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->MemberChanged(NM_MEMBER_UPDATED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  M E M B E R  R E M O V E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyMemberRemoved

-------------------------------------------------------------------------*/
HRESULT OnNotifyMemberRemoved(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->MemberChanged(NM_MEMBER_REMOVED, (INmMember *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  N M  U I  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyNmUI

-------------------------------------------------------------------------*/
HRESULT OnNotifyNmUI(IUnknown *pConfNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pConfNotify);

	((INmConferenceNotify*)pConfNotify)->NmUI((CONFN)((DWORD_PTR)pv));
	return S_OK;
}

/*  G E T  C O N F  O B J E C T  */
/*-------------------------------------------------------------------------
    %%Function: GetConfObject

    Global function to get the conference object
-------------------------------------------------------------------------*/
CConfObject * GetConfObject(void)
{
	COprahNCUI *pOprahNCUI = COprahNCUI::GetInstance();
	if (NULL != pOprahNCUI)
	{
		return pOprahNCUI->GetConfObject();
	}
	return NULL;
}

/*  G E T  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: GetConference

    Global function to get the INmConference interface to the conf object
-------------------------------------------------------------------------*/
HRESULT GetConference(INmConference **ppConference)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppConference)
	{
		hr = E_FAIL;
		INmConference *pConference = GetConfObject();
		if (NULL != pConference)
		{
			pConference->AddRef();
			hr = S_OK;
		}
		*ppConference = pConference;
	}
	return hr;
}

/*  G E T  M E M B E R  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: GetMemberList

    Global function to get the member list
-------------------------------------------------------------------------*/
COBLIST * GetMemberList(void)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;
	return pco->GetMemberList();
}



DWORD CConfObject::GetDwUserIdLocal(void)
{
	CNmMember * pMemberLocal = GetLocalMember();

	if (NULL != pMemberLocal)
	{
		return pMemberLocal->GetGCCID();
	}

	return 0;
}


CNmMember * CConfObject::PMemberFromGCCID(UINT uNodeID)
{
	COBLIST* pMemberList = ::GetMemberList();
	if (NULL != pMemberList)
	{
		POSITION pos = pMemberList->GetHeadPosition();
		while (pos)
		{
			CNmMember * pMember = (CNmMember *) pMemberList->GetNext(pos);
			ASSERT(NULL != pMember);
			if (uNodeID == pMember->GetGCCID())
			{
				return pMember;
			}
		}
	}
	return NULL;
}



CNmMember * CConfObject::PMemberFromName(PCWSTR pwszName)
{
	POSITION pos = m_MemberList.GetHeadPosition();
	while (NULL != pos)
	{
		CNmMember * pMember = (CNmMember *) m_MemberList.GetNext(pos);
		if (0 == UnicodeCompare(pwszName, pMember->GetName()))
		{
			return  pMember;
		}
	}
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\iconf.h ===
/***************************************************************************/
/** 				 Microsoft Windows									  **/
/** 		   Copyright(c) Microsoft Corp., 1995-1996					  **/
/***************************************************************************/

//
//	File:		iconf.h
//	Created:	ChrisPi 	12/6/95
//	Modified:
//
//	The CConfObject class is defined
//

#ifndef _ICONF_H_
#define _ICONF_H_

#include <inodecnt.h>
#include "connpnts.h"
#include <atlbase.h>
#include <lst.h>

enum CONFSTATE
{
	CS_UNINITIALIZED,
	CS_CREATING,
	CS_COMING_UP,
	CS_RUNNING,
	CS_GOING_DOWN,
	CS_TERMINATED
};


class CNmMember;

class CConfObject : public INmConference, public CConnectionPointContainer
{
protected:
	COBLIST m_MemberList;

	CONFSTATE		m_csState;
	CONF_HANDLE 	m_hConf;
	BOOL			m_fConferenceCreated;
	BOOL			m_fServerMode;

	BSTR            m_bstrConfName;

	CNmMember * 	m_pMemberLocal;
	UINT			m_uMembers;
	UINT			m_ourNodeID;
	UINT			m_uGCCConferenceID;
	ULONG			m_cRef;
	BOOL			m_fSecure;

	VOID			AddMember(CNmMember * pMember);
	VOID			RemoveMember(POSITION pos);
	VOID			RemoveMember(CNmMember * pMember)
					{
						POSITION pos = m_MemberList.GetPosition(pMember);
						if (NULL != pos)
						{
							RemoveMember(pos);
						}
					}
    VOID            RemoveOldMembers(int nExpected);
	CNmMember * 	CreateMember(BOOL fLocal,
								UINT uCaps,
								NC_ROSTER_NODE_ENTRY* pRosterNode);

	VOID			SetT120State(CONFSTATE state);
	VOID		    CheckState(NM_CONFERENCE_STATE pState);

	HRESULT __stdcall EventNotification(UINT uDirection, UINT uMediaType, UINT uEventCode, UINT uSubCode);


public:
	
	// Methods:

				CConfObject();
				~CConfObject();
    VOID        Init(void) {}
	VOID		OnConferenceCreated() {m_fConferenceCreated = TRUE; }
	VOID		OnMemberUpdated(INmMember *pMember);
	
	HRESULT 	CreateConference(void);
	HRESULT 	JoinConference(LPCWSTR	pcwszConferenceName,
							   LPCWSTR	pcwszPassword,
							   LPCSTR	pcszAddress,
							   BOOL		fRetry = FALSE);
	HRESULT 	InviteConference(LPCSTR pszAddr,
	                             REQUEST_HANDLE *phRequest);
	HRESULT 	LeaveConference(BOOL fForceLeave=TRUE);
	HRESULT		CancelInvite(REQUEST_HANDLE hRequest)
				{
					if (NULL == m_hConf)
					{
						return E_FAIL;
					}
					return m_hConf->CancelInvite(hRequest);
				}

	// Properties:

	BSTR	 	GetConfName()			{ return m_bstrConfName;         };
	UINT		GetOurNodeID()			{ return m_ourNodeID;				};
	UINT		GetGCCConferenceID()	{ return m_uGCCConferenceID;		};
	UINT		GetNumMembers()			{ return m_uMembers;			};
	BOOL		InCall()				{ return (m_uMembers > 0); 	};
	COBLIST*	GetMemberList()			{ return &m_MemberList;		};
	CONF_HANDLE GetConfHandle() 		{ return m_hConf;					};
	CONFSTATE	GetT120State()			{ return m_csState; 				};
	BOOL		IsConferenceActive()	{ return m_hConf != NULL;			};
	BOOL		IsConferenceCreated()	{ return m_fConferenceCreated;		};
	BOOL		IsConfObjSecure()		{ return m_fSecure; };
	CNmMember * GetLocalMember()		{ return m_pMemberLocal;			};

	DWORD       GetDwUserIdLocal(void);

	VOID        SetConfName(BSTR bstr);
	VOID        SetConfSecurity(BOOL fSecure);
	
	CNmMember *	PMemberFromGCCID(UINT uNodeID);
	CNmMember *	PMemberFromName(PCWSTR pwszName);

	// Event Handlers:
	
	// Data Conferencing (R1.1, T.120) events from NCUI:
	BOOL		OnRosterChanged(PNC_ROSTER pRoster);
	BOOL		OnT120Invite(CONF_HANDLE hConference, BOOL fSecure);
	BOOL		OnConferenceEnded();
	BOOL		OnConferenceStarted(CONF_HANDLE hNewConf,
									HRESULT Result);
									
	// INmConference
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	STDMETHODIMP GetName(BSTR *pbstrName);
	STDMETHODIMP GetID(ULONG *puID);
	STDMETHODIMP GetState(NM_CONFERENCE_STATE *pState);
	STDMETHODIMP GetTopProvider(INmMember **ppMember);
	STDMETHODIMP EnumMember(IEnumNmMember **ppEnum);
	STDMETHODIMP GetMemberCount(ULONG *puCount);
    STDMETHODIMP FindMember(ULONG gccID, INmMember ** ppMember);
	STDMETHODIMP IsHosting(void);
	STDMETHODIMP Host(void);
	STDMETHODIMP Leave(void);
	STDMETHODIMP LaunchRemote(REFGUID rguid, INmMember *pMember);
	STDMETHODIMP GetConferenceHandle(DWORD_PTR *pdwHandle);
    STDMETHODIMP CreateDataChannel(INmChannelData ** ppChannel, REFGUID rguid);
};

CConfObject * GetConfObject(void);
HRESULT GetConference(INmConference **ppConference);
COBLIST * GetMemberList(void);

#endif /* _ICONF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\ichnldat.cpp ===
// File: ichnldat.cpp
//
// INmChannelData
//

#include "precomp.h"
#include <confguid.h>

static const IID * g_apiidCP[] =
{
    {&IID_INmChannelDataNotify}
};


#define CopyStruct(pDest, pSrc)  CopyMemory(pDest, pSrc, sizeof(*(pDest)))
#define MAX_NM_PEER  256 // Maximum number of NetMeeting Peer applications/users


#ifdef DEBUG  /* T.120 Debug utilities */
LPCTSTR GetGccErrorString(GCCError uErr);
LPCTSTR GetMcsErrorString(MCSError uErr);
LPCTSTR GetGccResultString(UINT uErr);
LPCTSTR GetMcsResultString(UINT uErr);
#else
#define GetGccErrorString(uErr) ""
#define GetMcsErrorString(uErr) ""
#define GetGccResultString(uErr) ""
#define GetMcsResultString(uErr) ""
#endif /* DEBUG */



// code from nm\ui\conf\cuserdta.cpp:
static unsigned char H221IDGUID[5] = {H221GUIDKEY0,
                                      H221GUIDKEY1,
                                      H221GUIDKEY2,
                                      H221GUIDKEY3,
                                      H221GUIDKEY4};

extern VOID CreateH221AppKeyFromGuid(LPBYTE lpb, GUID * pguid);


/*  S E T  A P P  K E Y */
/*----------------------------------------------------------------------------
    %%Function: SetAppKey

	Set the two pieces of an OctetString (the length and the data.)
	Note that the length always includes the terminating null character.
----------------------------------------------------------------------------*/
VOID SetAppKey(LPOSTR pOct, LPBYTE lpb)
{
	pOct->length = cbKeyApp;
	pOct->value = lpb;
}

/*  C R E A T E  A P P  K E Y */
/*----------------------------------------------------------------------------
    %%Function: CreateAppKey

	Given a guid and a userid, create the appropriate application key.

	The key is formated as:
	0xB5 0x00 0x53 0x4C  - Microsoft Object Identifier
	0x01                 - guid identifier
	<binary guid>        - guid data
	<dword node id>      - user node id
----------------------------------------------------------------------------*/
VOID CreateAppKey(LPBYTE lpb, GUID * pguid, DWORD dwUserId)
{
	CreateH221AppKeyFromGuid(lpb, pguid);
	CopyMemory(lpb + cbKeyApp - sizeof(DWORD), &dwUserId, sizeof(DWORD));

#ifdef DEBUG
	TCHAR szGuid[LENGTH_SZGUID_FORMATTED];
	GuidToSz(pguid, szGuid);
	TRACE_OUT(("CreateAppKey: %s %08X", szGuid, dwUserId));
#endif
}


/*  P  M E M B E R  F R O M  D W  U S E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromDwUserId

-------------------------------------------------------------------------*/
CNmMember * PMemberFromDwUserId(DWORD dwUserId, COBLIST *pList)
{
	if (NULL != pList)
	{
		POSITION posCurr;
		POSITION pos = pList->GetHeadPosition();
		while (NULL != pos)
		{
			posCurr = pos;
			CNmMember * pMember = (CNmMember *) pList->GetNext(pos);
			if (dwUserId == pMember->GetGCCID())
			{
				pMember->AddRef();
				return pMember;
			}
		}
	}
	return NULL;
}


/*  A D D  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: AddNode

    Add a node to a list.
    Initializes the ObList, if necessary.
    Returns the position in the list or NULL if there was a problem.
-------------------------------------------------------------------------*/
POSITION AddNode(PVOID pv, COBLIST ** ppList)
{
	ASSERT(NULL != ppList);
	if (NULL == *ppList)
	{
		*ppList = new COBLIST();
		if (NULL == *ppList)
			return NULL;
	}

	return (*ppList)->AddTail(pv);
}

/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

    Remove a node from a list.
    Sets pPos to NULL
-------------------------------------------------------------------------*/
PVOID RemoveNodePos(POSITION * pPos, COBLIST *pList)
{
	if ((NULL == pList) || (NULL == pPos))
		return NULL;

	PVOID pv = pList->RemoveAt(*pPos);
	*pPos = NULL;
	return pv;
}


/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

-------------------------------------------------------------------------*/
VOID RemoveNode(PVOID pv, COBLIST * pList)
{
	ASSERT(NULL != pv);

	if (NULL != pList)
	{
		POSITION pos = pList->GetPosition(pv);
		RemoveNodePos(&pos, pList);
	}
}

VOID CNmChannelData::InitCT120Channel(DWORD dwUserId)
{
	m_dwUserId = dwUserId;
	m_gcc_conference_id = 0;
	m_gcc_pIAppSap = NULL;
	m_mcs_channel_id = 0;
	m_pmcs_sap = NULL;
	m_gcc_node_id = 0;
	m_scs = SCS_UNINITIALIZED;

	m_pGuid = PGuid();
	ASSERT((NULL != m_pGuid) && (GUID_NULL != *m_pGuid));

	CreateAppKey(m_keyApp, m_pGuid, 0);
	CreateAppKey(m_keyChannel, m_pGuid, dwUserId);

	// initialize other gcc & mcs stuff
	GCCObjectKey FAR * pObjKey;
	ClearStruct(&m_gcc_session_key);
	pObjKey = &(m_gcc_session_key.application_protocol_key);
	pObjKey->key_type = GCC_H221_NONSTANDARD_KEY;
	SetAppKey(&(pObjKey->h221_non_standard_id), m_keyApp);
	ASSERT(0 == m_gcc_session_key.session_id);

	ClearStruct(&m_gcc_registry_item);
	ClearStruct(&m_gcc_registry_key);
	CopyStruct(&m_gcc_registry_key.session_key, &m_gcc_session_key);
	SetAppKey(&m_gcc_registry_key.resource_id, m_keyApp);

	ClearStruct(&m_registry_item_Private);
	ClearStruct(&m_registry_key_Private);
	CopyStruct(&m_registry_key_Private.session_key, &m_gcc_session_key);
	SetAppKey(&m_registry_key_Private.resource_id, m_keyChannel);

	UpdateScState(SCS_UNINITIALIZED, 0);
}


/*  C L O S E  C H A N N E L */
/*----------------------------------------------------------------------------
    %%Function: CloseChannel

	Close the channel.

	Note there are no confirm messages expected for any of the GCC/MCS calls.
----------------------------------------------------------------------------*/
VOID CNmChannelData::CloseChannel(void)
{
	GCCError gccError = GCC_NO_ERROR;
	MCSError mcsError = MCS_NO_ERROR;

	if (SCS_UNINITIALIZED == m_scs)
    {
        WARNING_OUT(("in CT120Channel::CloseChannel, m_scs is SCS_UNINITIALIZED, is this OK?"));
        return;
    }

	TRACE_OUT(("CT120Channel::CloseChannel %08X (userHandle=%p)", m_mcs_channel_id, m_pmcs_sap));

	m_scs = SCS_TERMINATING;

	if (0 != m_mcs_channel_id)
	{
		ASSERT (m_pmcs_sap);
		mcsError = m_pmcs_sap->ChannelLeave(m_mcs_channel_id);
		TRACE_OUT(("CT120Channel::CloseChannel: ChannelLeave %s", GetMcsErrorString(mcsError)));
		m_mcs_channel_id = 0;
	}

	if (NULL != m_pmcs_sap)
	{
		mcsError = m_pmcs_sap->ReleaseInterface();
		TRACE_OUT(("CT120Channel::CloseChannel: MCS ReleaseInterface %s", GetMcsErrorString(mcsError)));
		m_pmcs_sap = NULL;
	}

	if (NULL != m_gcc_pIAppSap)
	{
		m_gcc_pIAppSap->RegistryDeleteEntry(m_gcc_conference_id, &m_registry_key_Private);
		// ignore the above result

        m_gcc_pIAppSap->ReleaseInterface();
		TRACE_OUT(("CT120Channel::CloseChannel: GCCDeleteSap %s", GetGccErrorString(gccError)));
		m_gcc_pIAppSap = NULL;
	}

	m_scs = SCS_UNINITIALIZED;
	m_gcc_conference_id = 0;

	// make sure no one is around
	UpdateRoster(NULL, 0, FALSE, TRUE /* fRemove */);;
}


/*  U P D A T E  S C  S T A T E */
/*----------------------------------------------------------------------------
    %%Function: UpdateScState

	The system progresses from one state to another
	by making an GCC (or MCS) call that is guarenteed to
	produce a notification that calls this function.
	The calling process is released by UnBlockThread.
----------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateScState(SCSTATE scs, DWORD dwErr)
{
    DBGENTRY(CNmChannelData::UpdateScState)
	if (m_scs != scs)
	{
		WARNING_OUT(("UpdateScState - invalid state transition (%d - %d)", m_scs, scs));
		dwErr = INVALID_T120_ERROR; // We should never get here
	}

	if (0 == dwErr)
	{
	switch (m_scs)
		{
	case SCS_UNINITIALIZED:
		dwErr = DoCreateSap();
		break;
	case SCS_CREATESAP:
		dwErr = DoAttach();
		break;
	case SCS_ATTACH:
		dwErr = DoEnroll();
		break;
	case SCS_ENROLL:
		dwErr = DoJoinPrivate();
		break;
	case SCS_JOIN_PRIVATE:
		dwErr = DoRegRetrieve();
		break;
	case SCS_REGRETRIEVE_NEW:
		dwErr = DoJoinNew();
		break;
	case SCS_REGRETRIEVE_EXISTS:
		dwErr = DoJoinOld();
		break;
	case SCS_JOIN_NEW:
		dwErr = DoRegChannel();
		break;
	case SCS_REGCHANNEL:
	case SCS_JOIN_OLD:
		dwErr = DoRegPrivate();
		break;
	case SCS_REGPRIVATE:
		TRACE_OUT((">>>>>>>>>>>UpdateScState: Complete"));
		m_scs = SCS_CONNECTED;
		NotifyChannelConnected();
		break;
	case SCS_CONNECTED:
	case SCS_REGRETRIEVE:
		// we should never be called when we're in these states
		// so, treat it as an error and fall thru to the default case
	default:
		dwErr = INVALID_T120_ERROR; // We should never get here
		break;
		}
	}

	TRACE_OUT(("UpdateScState: New state (%d) channelId=%04X", m_scs, GetMcsChannelId()));

	if (0 != dwErr)
	{
		WARNING_OUT(("UpdateScState: Err=%d", dwErr));
		CloseConnection();
	}

    DBGEXIT(CNmChannelData::UpdateScState)
}

DWORD CNmChannelData::DoCreateSap(void)
{
	ASSERT(SCS_UNINITIALIZED == m_scs);
	m_scs = SCS_CREATESAP;

    GCCError gccError = GCC_CreateAppSap(&m_gcc_pIAppSap, this, NmGccMsgHandler);
	TRACE_OUT(("GCCCreateSap err=%s", GetGccErrorString(gccError)));
	return (DWORD) gccError;
}

DWORD CNmChannelData::DoAttach(void)
{
	ASSERT(SCS_CREATESAP == m_scs);
	m_scs = SCS_ATTACH;

	MCSError mcsError = MCS_AttachRequest(&m_pmcs_sap,
		(DomainSelector) &m_gcc_conference_id,
		sizeof(m_gcc_conference_id),
		NmMcsMsgHandler,
		this,
		ATTACHMENT_DISCONNECT_IN_DATA_LOSS | ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);
	// This generates an async MCS_ATTACH_USER_CONFIRM

	TRACE_OUT(("MCS_AttachRequest err=%s", GetMcsErrorString(mcsError)));
	return (DWORD) mcsError;
}

DWORD CNmChannelData::DoEnroll(void)
{
	ASSERT(SCS_ATTACH == m_scs || SCS_JOIN_STATIC_CHANNEL);
	m_scs = SCS_ENROLL;

	GCCEnrollRequest er;
    GCCRequestTag nReqTag;

	if(m_pGCCER)
	{
		m_pGCCER->pSessionKey = &m_gcc_session_key;
		m_pGCCER->nUserID = m_mcs_sender_id;

	}
	else
	{
    	// fill in enroll request structure
	    ::ZeroMemory(&er, sizeof(er));
	    er.pSessionKey = &m_gcc_session_key;
	    er.fEnrollActively = TRUE;
	    er.nUserID = m_mcs_sender_id;
	    // er.fConductingCapabable = FALSE;
	    er.nStartupChannelType = MCS_DYNAMIC_MULTICAST_CHANNEL;
	    // er.cNonCollapsedCaps = 0;
	    // er.apNonCollapsedCaps = NULL;
	    // er.cCollapsedCaps = 0;
    	// er.apCollapsedCaps = NULL;
	    er.fEnroll = TRUE;
	}

	GCCError gccError = m_gcc_pIAppSap->AppEnroll(m_gcc_conference_id, m_pGCCER != NULL ? m_pGCCER : &er, &nReqTag);

	TRACE_OUT(("GCCApplicationEnrollRequest err=%s", GetGccErrorString(gccError)));

	if (GCC_NO_ERROR != gccError)
	{
		ERROR_OUT(("DoEnroll failed - WHY?"));
	}

	return (DWORD) gccError;
}

// Join the PRIVATE data channel (m_mcs_sender_id)
DWORD CNmChannelData::DoJoinPrivate(void)
{
	ASSERT(SCS_ENROLL == m_scs || SCS_ATTACH == m_scs);
	m_scs = SCS_JOIN_PRIVATE;

	MCSError mcsError = m_pmcs_sap->ChannelJoin(m_mcs_sender_id);
	// This generates an async MCS_CHANNEL_JOIN_CONFIRM

	TRACE_OUT(("MCSChannelJoinRequest (private) %04X, err=%s",
		m_mcs_sender_id, GetMcsErrorString(mcsError)));
	return (DWORD) mcsError;
}


DWORD CNmChannelData::DoRegRetrieve(void)
{
	ASSERT(SCS_JOIN_PRIVATE == m_scs);
	m_scs = SCS_REGRETRIEVE;

	GCCError gccError = m_gcc_pIAppSap->RegistryRetrieveEntry(
		m_gcc_conference_id, &m_gcc_registry_key);
	// This generates an async GCC_RETRIEVE_ENTRY_CONFIRM

	TRACE_OUT(("GCCRegistryRetrieveEntryRequest err=%s", GetGccErrorString(gccError)));
	return (DWORD) gccError;
}

// Register the PUBLIC channel
DWORD CNmChannelData::DoRegChannel(void)
{
	ASSERT(SCS_JOIN_NEW == m_scs);
	m_scs = SCS_REGCHANNEL;

	GCCError gccError = m_gcc_pIAppSap->RegisterChannel(
		m_gcc_conference_id, &m_gcc_registry_key, m_mcs_channel_id);
	// This generates an async GCC_REGISTER_CHANNEL_CONFIRM

	TRACE_OUT(("GCCRegisterChannelRequest err=%s", GetGccErrorString(gccError)));
	return (DWORD) gccError;
}

DWORD CNmChannelData::DoJoinStatic(ChannelID staticChannel)
{
	m_scs = SCS_JOIN_STATIC_CHANNEL;
	MCSError mcsError = m_pmcs_sap->ChannelJoin(staticChannel);
	// This generates an async MCS_CHANNEL_JOIN_CONFIRM

	TRACE_OUT(("MCSChannelJoinRequest %04X, err=%s",
		staticChannel, GetMcsErrorString(mcsError)));
	return (DWORD) mcsError;
}

DWORD CNmChannelData::DoJoin(SCSTATE scs)
{
	m_scs = scs;

	MCSError mcsError = m_pmcs_sap->ChannelJoin(m_mcs_channel_id);
	// This generates an async MCS_CHANNEL_JOIN_CONFIRM

	TRACE_OUT(("MCSChannelJoinRequest %04X, err=%s",
		m_mcs_channel_id, GetMcsErrorString(mcsError)));
	return (DWORD) mcsError;
}

DWORD CNmChannelData::DoJoinNew(void)
{
	ASSERT(0 == m_mcs_channel_id);
	ASSERT(SCS_REGRETRIEVE_NEW == m_scs);
	return DoJoin(SCS_JOIN_NEW);
}

DWORD CNmChannelData::DoJoinOld(void)
{
	ASSERT(0 != m_mcs_channel_id);
	ASSERT(SCS_REGRETRIEVE_EXISTS == m_scs);
	return DoJoin(SCS_JOIN_OLD);
}


// Register the PRIVATE data channel. (m_mcs_sender_id)
DWORD CNmChannelData::DoRegPrivate(void)
{
	ASSERT(0 != m_mcs_sender_id);
	ASSERT((SCS_REGCHANNEL == m_scs) || (SCS_JOIN_OLD == m_scs));
	m_scs = SCS_REGPRIVATE;

	TRACE_OUT(("DoRegPrivate: channelId %04X as private for %08X", m_mcs_sender_id, m_dwUserId));

	GCCError gccError = m_gcc_pIAppSap->RegisterChannel(
			m_gcc_conference_id, &m_registry_key_Private, m_mcs_sender_id);
	// This generates an async GCC_REGISTER_CHANNEL_CONFIRM

	TRACE_OUT(("GCCRegisterChannelRequest err=%s", GetGccErrorString(gccError)));
	return (DWORD) gccError;
}


// deal with a GCC_RETRIEVE_ENTRY_CONFIRM notification
VOID CNmChannelData::ProcessEntryConfirm(GCCAppSapMsg * pMsg)
{
	if (pMsg->RegistryConfirm.pRegKey->resource_id.length >=
	    m_gcc_registry_key.resource_id.length
	    &&
        0 != memcmp(m_gcc_registry_key.resource_id.value,
		pMsg->RegistryConfirm.pRegKey->resource_id.value,
		m_gcc_registry_key.resource_id.length))
	{
		OnEntryConfirmRemote(pMsg);
	}
	else
	{
		OnEntryConfirmLocal(pMsg);
	}
}



// deal with a GCC_REGISTRY_HANDLE_CONFIRM notification
VOID CNmChannelData::ProcessHandleConfirm(GCCAppSapMsg * pMsg)
{
	ASSERT(NULL != pMsg);
	NotifySink(&pMsg->RegAllocHandleConfirm, OnAllocateHandleConfirm);
}


VOID CNmChannelData::OnEntryConfirmRemote(GCCAppSapMsg * pMsg)
{
	DWORD dwUserId;
	ASSERT(cbKeyApp ==
		pMsg->RegistryConfirm.pRegKey->resource_id.length);
	CopyMemory(&dwUserId,
		pMsg->RegistryConfirm.pRegKey->resource_id.value +
		cbKeyApp - sizeof(DWORD), sizeof(DWORD));

	TRACE_OUT(("GCC_RETRIEVE_ENTRY_CONFIRM: user private channelId = %04X for userId=%04X result=%s",
		pMsg->RegistryConfirm.pRegItem->channel_id, dwUserId,
		GetGccResultString(pMsg->RegistryConfirm.nResult)));

	if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
	{
		UpdateMemberChannelId(dwUserId,
			pMsg->RegistryConfirm.pRegItem->channel_id);
	}
	else
	{
		CNmMemberId * pMemberId = GetMemberId(dwUserId);
		if (NULL != pMemberId)
		{
			UINT cCount = pMemberId->GetCheckIdCount();
			if (0 == cCount)
			{
				TRACE_OUT(("CT120Channel: No more ChannelId requests %08X", dwUserId));
			}
			else
			{
				cCount--;
				TRACE_OUT(("CT120Channel: Request Count for %08X = %0d", dwUserId, cCount));
				pMemberId->SetCheckIdCount(cCount);

				// BUGBUG: T.120 should notify us when this information is available
				RequestChannelId(dwUserId);
			}
		}
	}
}

VOID CNmChannelData::OnEntryConfirmLocal(GCCAppSapMsg * pMsg)
{
	TRACE_OUT(("GCC_RETRIEVE_ENTRY_CONFIRM: public channelId = %04X result=%s",
		pMsg->RegistryConfirm.pRegItem->channel_id,
		GetGccResultString(pMsg->RegistryConfirm.nResult)));

	// Processing initial request for guid channel information
	ASSERT(sizeof(m_gcc_registry_item) == sizeof(*(pMsg->RegistryConfirm.pRegItem)));
	CopyMemory(&m_gcc_registry_item, pMsg->RegistryConfirm.pRegItem,
		sizeof(m_gcc_registry_item));
	if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
	{

		m_mcs_channel_id = m_gcc_registry_item.channel_id;
		ASSERT(SCS_REGRETRIEVE == m_scs);
		m_scs = SCS_REGRETRIEVE_EXISTS;
		UpdateScState(SCS_REGRETRIEVE_EXISTS, 0);
	}
	else if (GCC_RESULT_ENTRY_DOES_NOT_EXIST == pMsg->RegistryConfirm.nResult)
	{
		TRACE_OUT((" channel does not exist - proceeding to new state"));
		ASSERT(0 == m_mcs_channel_id);
		ASSERT(SCS_REGRETRIEVE == m_scs);
		m_scs = SCS_REGRETRIEVE_NEW;
		UpdateScState(SCS_REGRETRIEVE_NEW, 0);
	}
}
	

// deal with a GCC_APP_ROSTER_REPORT_INDICATION
BOOL CNmChannelData::UpdateRoster(GCCAppSapMsg * pMsg)
{
	UINT iRoster;
	GCCApplicationRoster * lpAppRoster;
	int iRecord;
	GCCApplicationRecord * lpAppRecord;
	DWORD dwUserId;
	UCID  rgPeerTemp[MAX_NM_PEER];
	int   cPeer;
	int   i;
	BOOL  fAdd = FALSE;
	BOOL  fRemove = FALSE;
	BOOL  fLocal = FALSE;

	TRACE_OUT(("CT120Channel::UpdateRoster: conf=%d, roster count=%d",
		pMsg->AppRosterReportInd.nConfID,
		pMsg->AppRosterReportInd.cRosters));

	ZeroMemory(rgPeerTemp, sizeof(rgPeerTemp));

	/* Create rgPeerTemp[], cPeer */
	cPeer = 0;
	for (iRoster = 0;
		iRoster < pMsg->AppRosterReportInd.cRosters;
		iRoster++)
	{
		lpAppRoster = pMsg->AppRosterReportInd.apAppRosters[iRoster];
		if (lpAppRoster->session_key.session_id != m_gcc_session_key.session_id)
			continue;
		
		// Must pay attention to these flags to avoid GCC weirdness
		if (lpAppRoster->nodes_were_added)
			fAdd = TRUE;
		if (lpAppRoster->nodes_were_removed)
			fRemove = TRUE;

		for (iRecord = 0;
			iRecord < lpAppRoster->number_of_records;
			iRecord++)
		{
			lpAppRecord = lpAppRoster->application_record_list[iRecord];
			TRACE_OUT(("Node=%X, Entity=%X, AppId=%X", lpAppRecord->node_id,
				lpAppRecord->entity_id, lpAppRecord->application_user_id));

			// Search for the node in the list
			dwUserId = lpAppRecord->node_id;
			
			//
			// Check for local node
			//
			fLocal |= (dwUserId == m_dwUserIdLocal);
			
			for (i = 0; i < cPeer; i++)
			{
				if (dwUserId == rgPeerTemp[i].dwUserId)
					break;
			}
			if (i >= cPeer)
			{
				if (cPeer >= MAX_NM_PEER)
					continue; // over our limit!

				// Add the node to our new list
				rgPeerTemp[cPeer++].dwUserId = dwUserId;
			}


			// Make sure we know the sender_id's
			if (MCS_DYNAMIC_PRIVATE_CHANNEL == lpAppRecord->startup_channel_type)
			{
				rgPeerTemp[i].sender_id_private = lpAppRecord->application_user_id;
			}
			else
			{
				rgPeerTemp[i].sender_id_public = lpAppRecord->application_user_id;
			}
		}

		break; // out of for (iRoster) loop
	}

	UpdateRoster(rgPeerTemp, cPeer, fAdd, fRemove);

	return (fAdd && fLocal);
}


/*  H R  S E N D  D A T A */
/*----------------------------------------------------------------------------
    %%Function: HrSendData

	Send data on a specific channel
----------------------------------------------------------------------------*/
HRESULT CNmChannelData::HrSendData(ChannelID channel_id, DWORD dwUserId,
    LPVOID lpv, DWORD cb, ULONG dwFlags)
{
	TRACE_OUT(("CT120Channel::HrSendData: %d bytes", cb));

	PDUPriority priority;
	SendDataFlags allocation = APP_ALLOCATION;
	DataRequestType requestType;

 	if(dwFlags & DATA_TOP_PRIORITY)
 	{
	 	priority = TOP_PRIORITY;
 	}
 	else if (dwFlags & DATA_HIGH_PRIORITY)
 	{
	 	priority = HIGH_PRIORITY;
 	}
    else if (dwFlags & DATA_MEDIUM_PRIORITY)
    {
        priority = MEDIUM_PRIORITY;
    }
    else
 	{
	 	priority = LOW_PRIORITY;
 	}

	if (dwFlags & DATA_UNIFORM_SEND)
	{
		requestType = UNIFORM_SEND_DATA;
	}
    else
    {
        requestType = NORMAL_SEND_DATA;
    }

	if ((0 == m_mcs_channel_id) || (NULL == m_pmcs_sap) || (0 == channel_id))
	{
		WARNING_OUT(("*** Attempted to send data on invalid channel"));
		return E_INVALIDARG;
	}

	MCSError mcsError = m_pmcs_sap->SendData(requestType, channel_id, priority,
									(unsigned char *)lpv, cb, allocation);

	if (0 != mcsError)
	{
		TRACE_OUT(("SendData err=%s", GetMcsErrorString(mcsError)));
		// Usually MCS_TRANSMIT_BUFFER_FULL
		return E_OUTOFMEMORY;
	}

	{	// Inform the app the data has been sent
		NMN_DATA_XFER nmnData;
		nmnData.pMember = NULL;
		nmnData.pb = (LPBYTE) lpv;
		nmnData.cb = cb;
		nmnData.dwFlags = 0;

		if (0 == dwUserId)
		{
			// send out notification with NULL member (BROADCAST)
			NotifySink(&nmnData, OnNmDataSent);
		}
		else
		{
			nmnData.pMember = (INmMember *) PMemberFromDwUserId(dwUserId, GetMemberList());
			if (nmnData.pMember)
			{
				NotifySink(&nmnData, OnNmDataSent);
				nmnData.pMember->Release();
			}
		}
	}

	TRACE_OUT(("SendData completed successfully"));
	return S_OK;
}


// Ask GCC for the private channel id.
VOID CNmChannelData::RequestChannelId(DWORD dwUserId)
{
	BYTE   keyChannel[cbKeyApp];
	GCCRegistryKey  registry_key;

	TRACE_OUT(("Requesting channel id for %08X", dwUserId));

	CopyStruct(&registry_key.session_key, &m_gcc_session_key);
	CreateAppKey(keyChannel, m_pGuid, dwUserId);
	SetAppKey(&registry_key.resource_id, keyChannel);

	GCCError gccError = m_gcc_pIAppSap->RegistryRetrieveEntry(
		m_gcc_conference_id, &registry_key);
	// This generates an async GCC_RETRIEVE_ENTRY_CONFIRM

	if (0 != gccError)
	{
		WARNING_OUT(("RequestChannelId - problem with GCCRegistryRectreiveEntryRequest"));
	}
}


VOID CNmChannelData::NotifyChannelConnected(void)
{
    DBGENTRY(CNmChannelData::NotifyChannelConnected);
	if (S_OK != IsActive())
	{
		CConfObject * pConference = PConference();
		if (NULL != pConference)
		{
		   	m_fActive = TRUE;

            TRACE_OUT(("The channel is now officially active"));
		}
        else
        {
            WARNING_OUT(("PConference is NULL!"));

        }
    }
    DBGEXIT(CNmChannelData::NotifyChannelConnected);
}


/*  N M  G C C  M S G  H A N D L E R  */
/*-------------------------------------------------------------------------
    %%Function: NmGccMsgHandler

-------------------------------------------------------------------------*/
void CALLBACK NmGccMsgHandler(GCCAppSapMsg * pMsg)
{
	TRACE_OUT(("NmGccMsgHandler: [%d]", pMsg->eMsgType));

	CNmChannelData * psc = (CNmChannelData *) (pMsg->pAppData);
	ASSERT(NULL != psc);
	psc->AddRef();

	switch (pMsg->eMsgType)
		{
	case GCC_PERMIT_TO_ENROLL_INDICATION:
		TRACE_OUT((" m_conference_id = %X", pMsg->AppPermissionToEnrollInd.nConfID));
		TRACE_OUT((" permission = %X", pMsg->AppPermissionToEnrollInd.fPermissionGranted));
		if ((SCS_CONNECTED == psc->m_scs) &&
			(0 == pMsg->AppPermissionToEnrollInd.fPermissionGranted))
		{
			psc->CloseConnection();
			break;
		}

		if (SCS_CREATESAP != psc->m_scs)
		{
			TRACE_OUT((" ignoring Enroll Indication"));
			break;
		}
		psc->m_gcc_conference_id = pMsg->AppPermissionToEnrollInd.nConfID;
		psc->UpdateScState(SCS_CREATESAP, !pMsg->AppPermissionToEnrollInd.fPermissionGranted);
		break;

	case GCC_ENROLL_CONFIRM:
		TRACE_OUT((" result = %s", GetGccResultString(pMsg->AppEnrollConfirm.nResult)));

		if (GCC_RESULT_SUCCESSFUL == pMsg->AppEnrollConfirm.nResult)
		{
			TRACE_OUT((" m_conference_id = %X", pMsg->AppEnrollConfirm.nConfID));
			TRACE_OUT((" entity_id = %X", pMsg->AppEnrollConfirm.eidMyself));
			TRACE_OUT((" node_id = %X", pMsg->AppEnrollConfirm.nidMyself));
			psc->m_gcc_node_id = pMsg->AppEnrollConfirm.nidMyself;
		}
		break;

	case GCC_APP_ROSTER_REPORT_INDICATION:
		if(psc->UpdateRoster(pMsg) && psc->m_scs == SCS_ENROLL)
		{
			psc->UpdateScState(SCS_ENROLL, GCC_RESULT_SUCCESSFUL);
		}
		break;

	case GCC_REGISTER_CHANNEL_CONFIRM:
		TRACE_OUT(("GCC_REGISTER_CHANNEL_CONFIRM: channel id = %04X  result = %s",
			pMsg->RegistryConfirm.pRegItem->channel_id,
			GetGccResultString(pMsg->RegistryConfirm.nResult)));
		if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
		{
			if (psc->GetMcsChannelId() ==
				pMsg->RegistryConfirm.pRegItem->channel_id)
			{
				ASSERT((0 == psc->m_gcc_registry_item.item_type) ||
					(GCC_REGISTRY_NONE == psc->m_gcc_registry_item.item_type));

    		    ASSERT(sizeof(psc->m_gcc_registry_item) == sizeof(*(pMsg->RegistryConfirm.pRegItem)));
				CopyMemory(&psc->m_gcc_registry_item, pMsg->RegistryConfirm.pRegItem,
					sizeof(psc->m_gcc_registry_item));
			}
			else
			{
				ASSERT(psc->SenderChannelId() ==
						pMsg->RegistryConfirm.pRegItem->channel_id);
				ASSERT(0 == psc->m_registry_item_Private.item_type);

    		    ASSERT(sizeof(psc->m_registry_item_Private) == sizeof(*(pMsg->RegistryConfirm.pRegItem)));
				CopyMemory(&psc->m_registry_item_Private, pMsg->RegistryConfirm.pRegItem,
					sizeof(psc->m_registry_item_Private));
			}
		}
		ASSERT((SCS_REGCHANNEL == psc->m_scs) || (SCS_REGPRIVATE == psc->m_scs));
		psc->UpdateScState(psc->m_scs, pMsg->RegistryConfirm.nResult);
		break;

	case GCC_RETRIEVE_ENTRY_CONFIRM:
		psc->ProcessEntryConfirm(pMsg);
		break;

	case GCC_ALLOCATE_HANDLE_CONFIRM:
		psc->ProcessHandleConfirm(pMsg);
		break;

	default:
		break;
		}

	psc->Release();
}



/*  N M  M C S  M S G  H A N D L E R  */
/*-------------------------------------------------------------------------
    %%Function: NmMcsMsgHandler

-------------------------------------------------------------------------*/
void CALLBACK NmMcsMsgHandler(unsigned int uMsg, LPARAM lParam, PVOID pv)
{
	CNmChannelData * psc = (CNmChannelData *) pv;
	ASSERT(NULL != psc);
//	TRACE_OUT(("[%s]", GetMcsMsgString(uMsg)));
	psc->AddRef();

	switch (uMsg)
		{
	case MCS_ATTACH_USER_CONFIRM:
	{
		TRACE_OUT(("MCS_ATTACH_USER_CONFIRM channelId=%04X result=%s",
			LOWORD(lParam), GetMcsResultString(HIWORD(lParam))));
		if (RESULT_SUCCESSFUL == HIWORD(lParam))
		{
			TRACE_OUT((" Local m_mcs_sender_id = %04X", LOWORD(lParam)));
			psc->m_mcs_sender_id = LOWORD(lParam);
		}
		psc->UpdateScState(SCS_ATTACH, (DWORD) HIWORD(lParam));
		break;
	}

	case MCS_CHANNEL_JOIN_CONFIRM:
	{
		TRACE_OUT(("MCS_CHANNEL_JOIN_CONFIRM channelId=%04X result=%s",
			LOWORD(lParam), GetMcsResultString(HIWORD(lParam))));
		if (RESULT_SUCCESSFUL == HIWORD(lParam))
		{
			if (psc->m_mcs_sender_id == LOWORD(lParam))
			{
				ASSERT(SCS_JOIN_PRIVATE == psc->m_scs);
			}
			else
			{
				ASSERT((0 == psc->m_mcs_channel_id) ||
					(psc->m_mcs_channel_id == LOWORD(lParam)));

				psc->m_mcs_channel_id = LOWORD(lParam);
			}			
		}
		ASSERT((SCS_JOIN_NEW == psc->m_scs) ||
		       (SCS_JOIN_OLD == psc->m_scs) ||
		       (SCS_JOIN_PRIVATE == psc->m_scs) ||
			   (SCS_CONNECTED == psc->m_scs)||
			   (SCS_JOIN_STATIC_CHANNEL == psc->m_scs));

		psc->UpdateScState(psc->m_scs, (DWORD) HIWORD(lParam));
		break;
	}

	case MCS_UNIFORM_SEND_DATA_INDICATION:
	case MCS_SEND_DATA_INDICATION:  // lParam == SendData *
	{
		SendData * pSendData = (SendData *) lParam;
		ASSERT(NULL != pSendData);
		CNmMember * pMember = psc->PMemberFromSenderId(pSendData->initiator);

		if (NULL != pMember)
		{
            if (uMsg == MCS_UNIFORM_SEND_DATA_INDICATION)
            {
                //
                // Skip UNIFORM notifications that came from us
                //

                ULONG memberID;
                pMember->GetID(&memberID);

                if (memberID == psc->m_gcc_node_id)
                {
                    // We sent this, skip it.
                    goto RelMember;
                }
            }

			ASSERT (pSendData->segmentation == (SEGMENTATION_BEGIN | SEGMENTATION_END));
					
			NMN_DATA_XFER nmnData;
			nmnData.pMember =(INmMember *) pMember;
			nmnData.pb = pSendData->user_data.value;
			nmnData.cb = pSendData->user_data.length;
			nmnData.dwFlags = (ULONG)
				(NM_DF_SEGMENT_BEGIN | NM_DF_SEGMENT_END) |
				((psc->GetMcsChannelId() == pSendData->channel_id) ?
				NM_DF_BROADCAST : NM_DF_PRIVATE);

			psc->NotifySink((PVOID) &nmnData, OnNmDataReceived);

RelMember:
			pMember->Release();
		}
		break;
	}
	
	default:
		break;
		}

	psc->Release();
}



//
//	CNmMemberId
//

CNmMemberId::CNmMemberId(CNmMember *pMember, UCID * pucid) :
	m_channelId(pucid->channelId),
	m_sender_id_public(pucid->sender_id_public),
	m_sender_id_private(pucid->sender_id_private),
	m_cCheckId(0),
	m_pMember(pMember)
{
}

VOID CNmMemberId::UpdateRosterInfo(UCID * pucid)
{
	if (0 == m_channelId)
		m_channelId = pucid->channelId;
	if (0 == m_sender_id_private)
		m_sender_id_private = pucid->sender_id_private;
	if (0 == m_sender_id_public)
		m_sender_id_public = pucid->sender_id_public;
}

//
// CNmChannelData
//

CNmChannelData::CNmChannelData(CConfObject * pConference, REFGUID rguid) :
	CConnectionPointContainer(g_apiidCP, ARRAY_ELEMENTS(g_apiidCP)),
	m_pConference(pConference),
	m_fClosed(TRUE),
	m_fActive(FALSE),
	m_cMember(0),
	m_pListMemberId(NULL),
	m_pListMember(NULL),
	m_pGCCER(NULL)
{
	m_guid = rguid;
	ASSERT(GUID_NULL != rguid);

	m_dwUserIdLocal = pConference->GetDwUserIdLocal();
	ASSERT(INVALID_GCCID != m_dwUserIdLocal);

	TRACE_OUT(("Obj: %08X created CNmChannelData", this));
}


CNmChannelData::~CNmChannelData(void)
{
    DBGENTRY(CNmChannelData::~CNmChannelData);

		// This will keep us from being deleted again...
	++m_ulcRef;

	CloseConnection();

	FreeMemberIdList(&m_pListMemberId);
	delete m_pListMember;

	TRACE_OUT(("Obj: %08X destroyed CNmChannelData", this));

    DBGEXIT(CNmChannelData::~CNmChannelData);
}


/*  A D D  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: AddMember

-------------------------------------------------------------------------*/
VOID CNmChannelData::AddMember(CNmMember * pMember)
{
	TRACE_OUT(("CNmChannelData::AddMember [%ls] id=%08X",
		pMember->GetName(), pMember->GetGCCID()));

	m_cMember++;
	pMember->AddRef();
	AddNode(pMember, &m_pListMember);
}


/*  R E M O V E  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: RemoveMember

-------------------------------------------------------------------------*/
VOID CNmChannelData::RemoveMember(CNmMember * pMember)
{
	TRACE_OUT(("CNmChannelData::RemoveMember [%ls] id=%08X",
		pMember->GetName(), pMember->GetGCCID()));

	m_cMember--;
	ASSERT(m_cMember >= 0);
	RemoveNode(pMember, m_pListMember);

 	pMember->Release(); // Release AFTER notifying everyone
}


/*  O P E N  C O N N E C T I O N  */
/*-------------------------------------------------------------------------
    %%Function: OpenConnection

    Open a T.120 data connection (init both public and private channels)
-------------------------------------------------------------------------*/
HRESULT	CNmChannelData::OpenConnection(void)
{
	TRACE_OUT(("CNmChannelData::OpenConection()"));

	if (!m_fClosed)
		return E_FAIL; // already open
	m_fClosed = FALSE; // need to call CloseConnection after this

	InitCT120Channel(m_dwUserIdLocal);
	return S_OK;
}


/*  C L O S E  C O N N E C T I O N  */
/*-------------------------------------------------------------------------
    %%Function: CloseConnection

	Close the data channel - this matches what is done in OpenConnection
-------------------------------------------------------------------------*/
HRESULT CNmChannelData::CloseConnection(void)
{
	DBGENTRY(CNmChannelData::CloseConnection);

    HRESULT hr = S_OK;

	if (!m_fClosed)
    {
	    m_fClosed = TRUE;

	    // Close any open T.120 channels
		CloseChannel();

	    if (0 != m_cMember)
	    {
		    // force roster update with no peers
		    TRACE_OUT(("CloseConnection: %d members left", m_cMember));
		    UpdateRoster(NULL, 0, FALSE, TRUE /* fRemove */);
		    ASSERT(IsEmpty());
	    }

	    CConfObject * pConference = PConference();
	    if (NULL != pConference)
	    {
	    	m_fActive = FALSE;
	    }
    }

    DBGEXIT_HR(CNmChannelData::CloseConnection, hr);
	return hr;
}


/*  U P D A T E  P E E R  */
/*-------------------------------------------------------------------------
    %%Function: UpdatePeer

-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdatePeer(CNmMember * pMember, UCID *pucid, BOOL fAdd)
{
#ifdef DEBUG
	TRACE_OUT(("UpdatePeer (%08X) fAdd=%d fLocal=%d", pMember, fAdd, pMember->FLocal()));
	if (NULL != pucid)
	{
		TRACE_OUT((" channelId=(%04X) dwUserId=%08X", pucid->channelId, pucid->dwUserId));
	}
#endif /* DEBUG */

	if (fAdd)
	{
		CNmMemberId *pMemberId = new CNmMemberId(pMember, pucid);
		if (NULL != pMemberId)
		{
			AddNode(pMemberId, &m_pListMemberId);
			AddMember(pMember);
		}
	}
	else
	{
		CNmMemberId *pMemberId = GetMemberId(pMember);
		if (NULL != pMemberId)
		{
			RemoveNode(pMemberId, m_pListMemberId);
			delete pMemberId;
			RemoveMember(pMember);
		}
	}
}

/*  U P D A T E  R O S T E R  */
/*-------------------------------------------------------------------------
    %%Function: UpdateRoster

    Update the local peer list based on the new roster data
-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateRoster(UCID * rgPeer, int cPeer, BOOL fAdd, BOOL fRemove)
{
	int   iPeer;
	DWORD dwUserId;
	CNmMember * pMember;
	COBLIST * pList;

	TRACE_OUT(("CNmChannelData::UpdateRoster: %d peers, fAdd=%d, fRemove=%d",
		cPeer, fAdd, fRemove));

	if (NULL != m_pListMemberId)
	{
		for (POSITION pos = m_pListMemberId->GetHeadPosition(); NULL != pos; )
		{
			BOOL fFound = FALSE;
			CNmMemberId *pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			pMember = pMemberId->GetMember();
			ASSERT(NULL != pMember);
			dwUserId = pMember->GetGCCID();

			if (0 != dwUserId)
			{
				for (iPeer = 0; iPeer < cPeer; iPeer++)
				{
					if (dwUserId == rgPeer[iPeer].dwUserId)
					{
						fFound = TRUE;
						// remove from the new list
						// so that the peer will not be added below
						rgPeer[iPeer].dwUserId = 0;

						// no change, but make sure we know sender_ids
						pMemberId->UpdateRosterInfo(&rgPeer[iPeer]);

						// try to find channel id, if necessary
						if ((0 == pMemberId->GetChannelId()) &&
							(0 == pMemberId->GetCheckIdCount())
							&& !pMember->FLocal())
						{
							pMemberId->SetCheckIdCount(MAX_CHECKID_COUNT);
							RequestChannelId(dwUserId);
						}
						break;
					}
				}
			}

			if (!fFound && fRemove)
			{
				pMember->AddRef();

				// Unable to find old peer in new list - delete it
				UpdatePeer(pMember, NULL, FALSE /* fAdd */ );

				pMember->Release();
			}
		}
	}

	if (!fAdd)
		return;


	// Use the conference list to find member data
	pList = PConference()->GetMemberList();
	/* Add new peers */
	for (iPeer = 0; iPeer < cPeer; iPeer++)
	{
		dwUserId = rgPeer[iPeer].dwUserId;
		if (0 == dwUserId)
			continue;

		// PMemberFromDwUserId returns AddRef'd member
		pMember = PMemberFromDwUserId(dwUserId, pList);

		if (NULL == pMember)
		{
			WARNING_OUT(("UpdateRoster: Member not found! dwUserId=%08X", dwUserId));
		}
		else
		{
			UpdatePeer(pMember, &rgPeer[iPeer], TRUE /* fAdd */);
			pMember->Release();
		}
	}
}


/*  U P D A T E  M E M B E R  C H A N N E L  I D  */
/*-------------------------------------------------------------------------
    %%Function: UpdateMemberChannelId

-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateMemberChannelId(DWORD dwUserId, ChannelID channelId)
{
		// PMemberFromDwUserId returns AddRef'd member
	CNmMember * pMember = PMemberFromDwUserId(dwUserId, PConference()->GetMemberList());
	TRACE_OUT(("Member (%08X) private channelId=(%04X)", pMember, channelId));
	if (NULL != pMember)
	{
		UCID ucid;
		ClearStruct(&ucid);
		ucid.channelId = channelId;
		UpdateRosterInfo(pMember, &ucid);
		pMember->Release();
	}
}


/*  G E T  M E M B E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: GetMemberId

-------------------------------------------------------------------------*/
CNmMemberId * CNmChannelData::GetMemberId(CNmMember *pMember)
{
	if (NULL != m_pListMemberId)
	{
		POSITION pos = m_pListMemberId->GetHeadPosition();
		while (NULL != pos)
		{
  			CNmMemberId *pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			if (pMemberId->GetMember() == pMember)
			{
				return pMemberId;
			}
		}
	}
	return NULL;
}

/*  G E T  M E M B E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: GetMemberId

-------------------------------------------------------------------------*/
CNmMemberId * CNmChannelData::GetMemberId(DWORD dwUserId)
{
	if (NULL != m_pListMemberId)
	{
		POSITION pos = m_pListMemberId->GetHeadPosition();
		while (NULL != pos)
		{
			CNmMemberId *pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			CNmMember *pMember = pMemberId->GetMember();
			ASSERT(NULL != pMember);
			if (pMember->GetGCCID() == dwUserId)
			{
				return pMemberId;
			}
		}
	}
	return NULL;
}


/*  U P D A T E  R O S T E R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: UpdateRosterInfo

-------------------------------------------------------------------------*/
VOID CNmChannelData::UpdateRosterInfo(CNmMember *pMember, UCID * pucid)
{
	CNmMemberId *pMemberId = GetMemberId(pMember);
	if (NULL != pMemberId)
	{
		pMemberId->UpdateRosterInfo(pucid);
	}
}

/*  G E T  C H A N N E L  I D  */
/*-------------------------------------------------------------------------
    %%Function: GetChannelId

-------------------------------------------------------------------------*/
ChannelID CNmChannelData::GetChannelId(CNmMember *pMember)
{
	CNmMemberId *pMemberId = GetMemberId(pMember);
	if (NULL != pMemberId)
	{
		return pMemberId->GetChannelId();
	}
	return 0;
}

/*  P  M E M B E R  F R O M  S E N D E R  I D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromSenderId

-------------------------------------------------------------------------*/
CNmMember * CNmChannelData::PMemberFromSenderId(UserID id)
{
	if (NULL != m_pListMemberId)
	{
		POSITION pos = m_pListMemberId->GetHeadPosition();
		while (NULL != pos)
		{
			CNmMemberId * pMemberId = (CNmMemberId *) m_pListMemberId->GetNext(pos);
			ASSERT(NULL != pMemberId);
			if (pMemberId->FSenderId(id))
			{
				CNmMember* pMember = pMemberId->GetMember();
				ASSERT(NULL != pMember);
				pMember->AddRef();
				return pMember;
			}
		}
	}
	return NULL;
}

///////////////////////////
//  CNmChannelData:IUknown

ULONG STDMETHODCALLTYPE CNmChannelData::AddRef(void)
{
    TRACE_OUT(("CNmChannelData::AddRef this = 0x%X", this));
	return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CNmChannelData::Release(void)
{
    TRACE_OUT(("CNmChannelData::Release this = 0x%X", this));
	return RefCount::Release();
}


HRESULT STDMETHODCALLTYPE CNmChannelData::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_IUnknown) ||  (riid == IID_INmChannelData))
	{
		*ppv = (INmChannelData *)this;
		TRACE_OUT(("CNmChannel::QueryInterface(): Returning INmChannelData."));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		TRACE_OUT(("CNmChannel::QueryInterface(): Returning IConnectionPointContainer."));
	}

	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		TRACE_OUT(("CNmChannel::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}



HRESULT STDMETHODCALLTYPE CNmChannelData::GetGuid(GUID *pGuid)
{
	if (NULL == pGuid)
		return E_POINTER;

	*pGuid = m_guid;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::SendData(INmMember *pMember,
    ULONG cb, LPBYTE pv, ULONG uOptions)
{
	HRESULT hr;

	if (!m_fActive)
	{
		// No active Channels, yet
		return E_FAIL;
	}

	if ((NULL == pv) || (0 == cb))
	{
		return S_FALSE;
	}
	if (IsBadReadPtr(pv, cb))
	{
		return E_POINTER;
	}

	CNmMember * pDest = (CNmMember *) pMember;
	COBLIST * pList = GetMemberList();
	if (NULL == pMember)
	{
		hr = HrSendData(GetMcsChannelId(), 0, pv, cb, uOptions);
	}
	else if ((NULL == pList) || (NULL == pList->Lookup(pDest)) )
	{
		// Destination is not in list
		hr = E_INVALIDARG;
	}
	else
	{
		ChannelID channel_id = GetChannelId(pDest);
		if (0 == channel_id)
		{
			WARNING_OUT(("Unable to find user destination channel?"));

			CNmMemberId *pMemberId = GetMemberId(pDest);
			if (NULL == pMemberId)
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				channel_id = pMemberId->SenderId();
				hr = (0 == channel_id) ? E_FAIL : S_OK;
			}
		}
		
		if (SUCCEEDED(hr))
		{
			hr = HrSendData(channel_id, pDest->GetGCCID(), pv, cb, uOptions);
		}
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::RegistryAllocateHandle(ULONG numberOfHandlesRequested)
{
	if (!m_fActive)
	{
		// No active Channels, yet
		return E_FAIL;
	}

	if(numberOfHandlesRequested == 0)
	{
		return E_INVALIDARG;
	}

	//
	// Request handles from gcc
	//
	GCCError gccError = m_gcc_pIAppSap->RegistryAllocateHandle(m_gcc_conference_id, numberOfHandlesRequested);
	
	if(gccError == GCC_NO_ERROR)
	{
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}



HRESULT STDMETHODCALLTYPE CNmChannelData::IsActive(void)
{
	return m_fActive ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::SetActive(BOOL fActive)
{
	TRACE_OUT(("CNmChannelData::SetActive(%d)", fActive));

	NM_CONFERENCE_STATE state;
	// Must be in a non-idle conference
	CConfObject * pConference = PConference();
	pConference->GetState(&state);
	if ((NULL == pConference) || state == NM_CONFERENCE_IDLE)
		return E_FAIL;

	if (fActive)
	{
		if (S_OK == IsActive())
			return S_OK;
		return OpenConnection();
	}
	else
	{
		if (S_FALSE == IsActive())
			return S_OK;
		return CloseConnection();
	}
}


HRESULT STDMETHODCALLTYPE CNmChannelData::GetConference(INmConference **ppConference)
{
	return ::GetConference(ppConference);
}

	

HRESULT STDMETHODCALLTYPE CNmChannelData::EnumMember(IEnumNmMember **ppEnum)
{
	HRESULT hr = E_POINTER;
	if (NULL != ppEnum)
	{
		*ppEnum = new CEnumNmMember( GetMemberList(), m_cMember);

		hr = (NULL != *ppEnum)? S_OK : E_OUTOFMEMORY;
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CNmChannelData::GetMemberCount(ULONG *puCount)
{
	HRESULT hr = E_POINTER;

	if (NULL != puCount)
	{
		*puCount = m_cMember;
		hr = S_OK;
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////
// Utility Functions

HRESULT OnNmDataSent(IUnknown *pChannelDataNotify, void *pv, REFIID riid)
{
	NMN_DATA_XFER * pData = (NMN_DATA_XFER *) pv;

    if (IID_INmChannelDataNotify.Data1 == riid.Data1)
    {
	    ((INmChannelDataNotify*)pChannelDataNotify)->DataSent(
		    pData->pMember, pData->cb, pData->pb);
    }
	return S_OK;
}

HRESULT OnNmDataReceived(IUnknown *pChannelDataNotify, void *pv, REFIID riid)
{
	NMN_DATA_XFER * pData = (NMN_DATA_XFER *) pv;

    if (IID_INmChannelDataNotify.Data1 == riid.Data1)
    {
	    ((INmChannelDataNotify*)pChannelDataNotify)->DataReceived(
		    pData->pMember, pData->cb, pData->pb, pData->dwFlags);
    }
	return S_OK;
}

HRESULT OnAllocateHandleConfirm(IUnknown *pChannelDataNotify, void *pv, REFIID riid)
{


	if(IID_INmChannelDataNotify.Data1 == riid.Data1)
	{
		GCCRegAllocateHandleConfirm *pConfirm =  (GCCRegAllocateHandleConfirm *)pv;

		((INmChannelDataNotify*)pChannelDataNotify)->AllocateHandleConfirm(pConfirm->nFirstHandle,
															    pConfirm->cHandles);
	}											
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////
// Utility Functions

/*  F R E E  M E M B E R  ID  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: FreeMemberIdList

-------------------------------------------------------------------------*/
VOID FreeMemberIdList(COBLIST ** ppList)
{
	DBGENTRY(FreeMemberIdList);

	ASSERT(NULL != ppList);
	if (NULL != *ppList)
	{
		while (!(*ppList)->IsEmpty())
		{
			CNmMemberId * pMemberId = (CNmMemberId *)  (*ppList)->RemoveHead();
			delete pMemberId;
		}
		delete *ppList;
		*ppList = NULL;
	}
}


///////////////////////////////////////////////////////////////////////////
//
// GCC / MCS Errors

#ifdef DEBUG
LPCTSTR _FormatSzErr(LPTSTR psz, UINT uErr)
{
	static char szErr[MAX_PATH];
	wsprintf(szErr, "%s 0x%08X (%d)", psz, uErr, uErr);
	return szErr;
}

#define STRING_CASE(val)               case val: pcsz = #val; break

LPCTSTR GetGccErrorString(GCCError uErr)
{
	LPCTSTR pcsz;

	switch (uErr)
		{
	STRING_CASE(GCC_NO_ERROR);
	STRING_CASE(GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	STRING_CASE(GCC_NOT_INITIALIZED);
	STRING_CASE(GCC_ALREADY_INITIALIZED);
	STRING_CASE(GCC_ALLOCATION_FAILURE);
	STRING_CASE(GCC_NO_SUCH_APPLICATION);
	STRING_CASE(GCC_INVALID_CONFERENCE);

	default:
		pcsz = _FormatSzErr("GccError", uErr);
		break;
		}

	return pcsz;
}

LPCTSTR GetMcsErrorString(MCSError uErr)
{
	LPCTSTR pcsz;

	switch (uErr)
		{
	STRING_CASE(MCS_NO_ERROR);
	STRING_CASE(MCS_USER_NOT_ATTACHED);
	STRING_CASE(MCS_NO_SUCH_USER);
	STRING_CASE(MCS_TRANSMIT_BUFFER_FULL);
	STRING_CASE(MCS_NO_SUCH_CONNECTION);

	default:
		pcsz = _FormatSzErr("McsError", uErr);
		break;
		}

	return pcsz;
}

LPCTSTR GetGccResultString(UINT uErr)
{
	LPCTSTR pcsz;

	switch (uErr)
		{
	STRING_CASE(GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	default:
		pcsz = _FormatSzErr("GccResult", uErr);
		break;
		}

	return pcsz;
}

LPCTSTR GetMcsResultString(UINT uErr)
{
	return _FormatSzErr("McsResult", uErr);
}
#endif /* DEBUG (T.120 Error routines) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\imanager.cpp ===
// File: imanager.cpp

#include "precomp.h"

extern "C"
{
	#include "t120.h"
}
#include <version.h>
#include "icall.h"
#include "icall_in.h"
#include "imanager.h"
#include <objbase.h>

#include <initguid.h>

static HRESULT OnNotifyConferenceCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid);
static HRESULT OnNotifyCallCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid);



INodeController* g_pNodeController = NULL;


COprahNCUI *COprahNCUI::m_pOprahNCUI = NULL;

static const IID * g_apiidCP_Manager[] =
{
    {&IID_INmManagerNotify}
};

COprahNCUI::COprahNCUI(void) :
	m_cRef(1),
	CConnectionPointContainer(g_apiidCP_Manager, ARRAY_ELEMENTS(g_apiidCP_Manager)),
    m_pOutgoingCallManager(NULL),
    m_pIncomingCallManager(NULL),
    m_pConfObject(NULL),
    m_bstrUserName(NULL)
{
    DebugEntry(COprahNCUI::COprahNCUI);
	
	m_pOprahNCUI = this;

    DebugExitVOID(COprahNCUI::COprahNCUI);
}


COprahNCUI::~COprahNCUI()
{
    DebugEntry(COprahNCUI::COprahNCUI);

    if (m_pIncomingCallManager)
    {
    	delete m_pIncomingCallManager;
	    m_pIncomingCallManager = NULL;
    }

    if (m_pOutgoingCallManager)
    {
    	delete m_pOutgoingCallManager;
	    m_pOutgoingCallManager = NULL;
    }

	if (m_pConfObject)
	{
		m_pConfObject->Release();
		m_pConfObject = NULL;
	}

	// cleanup the node controller:
	if (g_pNodeController)
	{
		g_pNodeController->ReleaseInterface();
		g_pNodeController = NULL;
	}

    if (m_bstrUserName)
    {
        SysFreeString(m_bstrUserName);
        m_bstrUserName = NULL;
    }

	m_pOprahNCUI = NULL;

    DebugExitVOID(COprahNCUI::~COprahNCUI);
}


UINT COprahNCUI::GetOutgoingCallCount()
{
    if (m_pOutgoingCallManager)
    {
    	return m_pOutgoingCallManager->GetCallCount();
    }
    else
    {
        return 0;
    }
}

VOID COprahNCUI::OnOutgoingCallCreated(INmCall* pCall)
{
	// notify the UI about this outgoing call
	NotifySink(pCall, OnNotifyCallCreated);

	if (m_pConfObject && !m_pConfObject->IsConferenceCreated())
	{
		m_pConfObject->OnConferenceCreated();
		NotifySink((INmConference*) m_pConfObject, OnNotifyConferenceCreated);
	}
}

VOID COprahNCUI::OnOutgoingCallCanceled(COutgoingCall* pCall)
{
    if (m_pOutgoingCallManager)
    {
    	m_pOutgoingCallManager->RemoveFromList(pCall);
    }
}

VOID COprahNCUI::OnIncomingCallAccepted()
{
	if (m_pConfObject && !m_pConfObject->IsConferenceCreated())
	{
		m_pConfObject->OnConferenceCreated();
		NotifySink((INmConference*) m_pConfObject, OnNotifyConferenceCreated);
	}
}

VOID COprahNCUI::OnIncomingCallCreated(INmCall* pCall)
{
	NotifySink(pCall, OnNotifyCallCreated);
}

VOID COprahNCUI::CancelCalls()
{
    if (m_pOutgoingCallManager)
    {
    	m_pOutgoingCallManager->CancelCalls();
    }

    if (m_pIncomingCallManager)
    {
    	m_pIncomingCallManager->CancelCalls();
    }
}
			


ULONG COprahNCUI::GetAuthenticatedName(PBYTE * ppb)
{
	// Buffer created here should be freed by caller.

	ULONG cb;

	if (::T120_GetSecurityInfoFromGCCID(0,NULL,&cb)) {
		(*ppb) = new BYTE[cb];
		if ((*ppb) != NULL) {
			::T120_GetSecurityInfoFromGCCID(0,*ppb,&cb);
			return cb;
		}
	}
	(* ppb) = NULL;	
	return 0;

}

	
HRESULT COprahNCUI::OnIncomingInviteRequest(CONF_HANDLE hConference,
											PCWSTR pcwszNodeName,
											BOOL				fSecure)
{
	DebugEntry(COprahNCUI::OnIncomingInviteRequest);
	
    if (!m_pConfObject)
    {
        ERROR_OUT(("No m_pConfObject"));
        return E_FAIL;
    }

	if (!m_pConfObject->OnT120Invite(hConference, fSecure))
	{
		// Respond negatively - already in a call
		TRACE_OUT(("Rejecting invite - already in a call"));
		ASSERT(g_pNodeController);
		ASSERT(hConference);
		hConference->InviteResponse(FALSE);
	}
	else if (m_pIncomingCallManager)
	{
		m_pIncomingCallManager->OnIncomingT120Call(	this,
												TRUE,
												hConference,
												pcwszNodeName,
												fSecure);

        //
        // This will simply notify the UI about the call state.
        //
		m_pConfObject->SetConfSecurity(fSecure);
	}

	DebugExitHRESULT(COprahNCUI::OnIncomingInviteRequest, S_OK);
	return S_OK;
}


HRESULT COprahNCUI::OnIncomingJoinRequest(	CONF_HANDLE hConference,
											PCWSTR pcwszNodeName)
{
	DebugEntry(COprahNCUI::OnIncomingJoinRequest);

    if (m_pIncomingCallManager)
    {
    	// shouldn't we be checking for an active conference before accepting a join
	    // or will T120 not present this

    	m_pIncomingCallManager->OnIncomingT120Call(	this,
											FALSE,
											hConference,
											pcwszNodeName,
											m_pConfObject->IsConfObjSecure());
    }

	DebugExitHRESULT(COprahNCUI::OnIncomingJoinRequest, S_OK);
	return S_OK;
}


HRESULT COprahNCUI::OnConferenceStarted(CONF_HANDLE hConference, HRESULT hResult)
{
	DebugEntry(COprahNCUI::OnConferenceStarted);

    if (!m_pConfObject)
    {
        ERROR_OUT(("OnConferenceStarted - no m_pConfObject"));
        return E_FAIL;
    }

	if (m_pConfObject->GetConfHandle() == hConference)
	{
		m_pConfObject->OnConferenceStarted(hConference, hResult);

		m_pOutgoingCallManager->OnConferenceStarted(hConference, hResult);
	}

	DebugExitHRESULT(COprahNCUI::OnConferenceStarted, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnQueryRemoteResult(PVOID pvCallerContext,
										HRESULT hResult,
										BOOL fMCU,
										PWSTR* ppwszConferenceNames,
										PWSTR* ppwszConfDescriptors)
{
	DebugEntry(COprahNCUI::OnQueryRemoteResult);

	if (NO_ERROR == hResult)
	{
		TRACE_OUT(("COprahNCUI: OnQueryRemoteResult Success!"));
	}
	else
	{
		TRACE_OUT(("COprahNCUI: OnQueryRemoteResult Failure!"));
	}

    if (m_pOutgoingCallManager)
    {
    	m_pOutgoingCallManager->OnQueryRemoteResult(pvCallerContext,
												hResult,
												fMCU,
												ppwszConferenceNames,
												ppwszConfDescriptors);
    }
	
	DebugExitHRESULT(COprahNCUI::OnQueryRemoteResult, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnInviteResult(	CONF_HANDLE hConference,
									REQUEST_HANDLE hRequest,
									UINT uNodeID,
									HRESULT hResult)
{
	DebugEntry(COprahNCUI::OnInviteResult);

    if (!m_pConfObject)
    {
        ERROR_OUT(("OnInviteResult - no m_pConfObject"));
        return E_FAIL;
    }


	if (hConference == m_pConfObject->GetConfHandle())
	{
        if (m_pOutgoingCallManager)
        {
    		m_pOutgoingCallManager->OnInviteResult(	hConference,
												hRequest,
												uNodeID,
												hResult);
        }
	}

	DebugExitHRESULT(COprahNCUI::OnInviteResult, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnConferenceEnded(CONF_HANDLE hConference)
{
	DebugEntry(COprahNCUI::OnConferenceEnded);

	if (m_pConfObject && (hConference == m_pConfObject->GetConfHandle()))
	{
		m_pConfObject->OnConferenceEnded();

        if (m_pOutgoingCallManager)
        {
    		m_pOutgoingCallManager->OnConferenceEnded(hConference);
        }

        if (m_pIncomingCallManager)
        {
    		m_pIncomingCallManager->OnT120ConferenceEnded(hConference);
        }
	}

	DebugExitHRESULT(COprahNCUI::OnConferenceEnded, S_OK);
	return S_OK;
}

HRESULT COprahNCUI::OnRosterChanged(CONF_HANDLE hConf, PNC_ROSTER pRoster)
{
	TRACE_OUT(("COprahNCUI::OnRosterChanged"));

    if (!m_pConfObject)
    {
        ERROR_OUT(("OnRosterChanged - no m_pConfObject"));
        return E_FAIL;
    }

	if (hConf == m_pConfObject->GetConfHandle())
	{
		m_pConfObject->OnRosterChanged(pRoster);
	}
	return S_OK;
}



ULONG STDMETHODCALLTYPE COprahNCUI::AddRef(void)
{
    ++m_cRef;
    return m_cRef;
}
	
ULONG STDMETHODCALLTYPE COprahNCUI::Release(void)
{
    if (m_cRef > 0)
    {
        --m_cRef;
    }

    if (!m_cRef)
    {
        delete this;
        return 0;
    }
    else
    {
        return m_cRef;
    }
}

HRESULT STDMETHODCALLTYPE COprahNCUI::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmManager) || (riid == IID_IUnknown))
	{
		*ppv = (INmManager *)this;
		TRACE_OUT(("COprahNCUI::QueryInterface()"));
	}
	else if (riid == IID_IConnectionPointContainer)
	{
		*ppv = (IConnectionPointContainer *) this;
		TRACE_OUT(("COprahNCUI::QueryInterface(): Returning IConnectionPointContainer."));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		TRACE_OUT(("COprahNCUI::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

/*  I N I T I A L I Z E  */
/*-------------------------------------------------------------------------
    %%Function: Initialize

    REVIEW: What should the return value be if any of these parts fail
    to initialize or load?
-------------------------------------------------------------------------*/
HRESULT COprahNCUI::Initialize
(
    BSTR        szName,
    DWORD_PTR   dwCredentials,
    DWORD       port,
    DWORD       flags
)
{
	HRESULT hr = S_OK;

    ASSERT(!m_bstrUserName);
    SysFreeString(m_bstrUserName);
    m_bstrUserName = SysAllocString(szName);

	m_pOutgoingCallManager = new COutgoingCallManager;
    if (!m_pOutgoingCallManager)
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to create outgoing call mgr"));
        return(E_OUTOFMEMORY);
    }

	m_pIncomingCallManager = new CIncomingCallManager;
    if (!m_pIncomingCallManager)
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to create incoming call mgr"));
        return(E_OUTOFMEMORY);
    }

	// The lifetime of this object is up to the reference counting crap
	m_pConfObject = new CConfObject;
    if (!m_pConfObject)
    {
        ERROR_OUT(("COprahNCUI::Initialize -- failed to create conf object"));
        return(E_OUTOFMEMORY);
    }

	m_pConfObject->Init();

    //
    // Create the node controller
    //
    ASSERT(port == DEFAULT_LISTEN_PORT);
    hr = ::T120_CreateNodeController(&g_pNodeController, this, szName,
        dwCredentials, flags);
    if (FAILED(hr))
	{
	    ERROR_OUT(("T120_CreateNodeController() failed!"));
    }

    return hr;
}



HRESULT COprahNCUI::Call
(
    INmCall **ppCall,
    DWORD dwFlags,
    NM_ADDR_TYPE addrType,
	BSTR bstrAddr,
    BSTR bstrConference,
    BSTR bstrPassword
)
{
    BSTR bstrRealAddr;

	DebugEntry(COprahNCUI::Call);

    if (addrType == NM_ADDR_MACHINENAME)
    {
        //
        // Convert to IP Address
        //
        int     cch;
        TCHAR * pszOemName;
        ULONG   ulIpAddress;
        HOSTENT *   pHostEnt;
        WCHAR *   pwszName;

        cch = SysStringLen(bstrAddr);
        pszOemName = new TCHAR[cch + 1];

        if (!pszOemName)
        {
            ERROR_OUT(("Couldn't get OEM Name"));
            return E_OUTOFMEMORY;
        }

        WideCharToMultiByte(CP_ACP, 0, bstrAddr, -1, pszOemName, cch+1, NULL,
            NULL);

        CharUpper(pszOemName);
        CharToOem(pszOemName, pszOemName);

        pHostEnt = gethostbyname(pszOemName);
        if (!pHostEnt ||
            (pHostEnt->h_addrtype != AF_INET) ||
            (pHostEnt->h_length != sizeof(ULONG)) ||
            (pHostEnt->h_addr_list[0] == NULL))
        {
            ulIpAddress = 0;
            WARNING_OUT(("gethostbyname failed"));
        }
        else
        {
            ulIpAddress = *reinterpret_cast<ULONG *>(pHostEnt->h_addr_list[0]);
        }

        delete pszOemName;

        if (!ulIpAddress)
        {
            ERROR_OUT(("gethostbyname failed, returning"));
            return E_FAIL;
        }

        pszOemName = inet_ntoa(*reinterpret_cast<in_addr *>(&ulIpAddress));
        cch = lstrlen(pszOemName);

        pwszName = new WCHAR[cch + 1];
        if (!pwszName)
        {
            ERROR_OUT(("Can't alloc OLE string"));
            return E_OUTOFMEMORY;
        }

        MultiByteToWideChar(CP_ACP, 0, pszOemName, -1, pwszName, cch+1);
        bstrRealAddr = SysAllocString(pwszName);

        delete pwszName;
    }
    else if (addrType == NM_ADDR_IP)
    {
        bstrRealAddr = SysAllocString(bstrAddr);
    }
    else
    {
        ERROR_OUT(("INmManager::Call - bogus addrType %d", addrType));
        return E_FAIL;
    }

	HRESULT hr = m_pOutgoingCallManager->Call(	ppCall,
												this,
												dwFlags,
												addrType,
												bstrRealAddr,
												bstrConference,
												bstrPassword);

    SysFreeString(bstrRealAddr);

	DebugExitHRESULT(COprahNCUI::Call, hr);
	return hr;
}


HRESULT COprahNCUI::CreateConference
(
    INmConference **ppConference,
    BSTR            bstrName,
    BSTR            bstrPassword,
    BOOL            fSecure
)
{
	if (NULL == ppConference)
    {
        ERROR_OUT(("CreateConferenceEx:  null ppConference passed in"));
		return E_POINTER;
    }

	if (m_pConfObject->IsConferenceActive())
	{
		WARNING_OUT(("CreateConference is failing because IsConferenceActive return TRUE"));
		return NM_CALLERR_IN_CONFERENCE;
	}

	m_pConfObject->SetConfName(bstrName);
    m_pConfObject->SetConfSecurity(fSecure);

	if (!m_pConfObject->IsConferenceCreated())
	{
		m_pConfObject->OnConferenceCreated();
	}

	NotifySink((INmConference*) m_pConfObject, OnNotifyConferenceCreated);

	*ppConference = m_pConfObject;
	if(*ppConference)
	{
		(*ppConference)->AddRef();
	}

	return S_OK;
}


/*  O N  N O T I F Y  C O N F E R E N C E  C R E A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyConferenceCreated

-------------------------------------------------------------------------*/
HRESULT OnNotifyConferenceCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pManagerNotify);
	((INmManagerNotify*)pManagerNotify)->ConferenceCreated((INmConference *) pv);
	return S_OK;
}

/*  O N  N O T I F Y  C A L L  C R E A T E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyCallCreated

-------------------------------------------------------------------------*/
HRESULT OnNotifyCallCreated(IUnknown *pManagerNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pManagerNotify);
	((INmManagerNotify*)pManagerNotify)->CallCreated((INmCall *) pv);
	return S_OK;
}


/*  O N  N O T I F Y  C A L L  S T A T E  C H A N G E D  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyCallStateChanged

-------------------------------------------------------------------------*/
HRESULT OnNotifyCallStateChanged(IUnknown *pCallNotify, PVOID pv, REFIID riid)
{
	ASSERT(NULL != pCallNotify);
	((INmCallNotify*)pCallNotify)->StateChanged((NM_CALL_STATE)(DWORD_PTR)pv);
	return S_OK;
}



HRESULT WINAPI CreateNmManager(INmManager ** ppMan)
{
    if (!ppMan)
        return E_POINTER;

	COprahNCUI *pManager = new COprahNCUI();
    if (!pManager)
        return E_OUTOFMEMORY;

    *ppMan = (INmManager *)pManager;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\imember.h ===
// File: iMember.h

#ifndef _IMEMBER_H_
#define _IMEMBER_H_

#include "nmenum.h"

#define INVALID_GCCID      ((DWORD) -1)

// A valid T.120 GCC ID must be in this range:
#define FValidGccId(dw)    ((dw >= 1) && (dw <= 65535))


// *** DO NOT CHANGE these flags without checking the
// corresponding CONF_UF_* items in msconf.h

// PARTICIPANT flags:

enum
{
    PF_INCONFERENCE     = 0x0001,
    PF_LOCAL_NODE       = 0x0002,
    PF_T120_MCU         = 0x0004,
    PF_T120_TOP_PROV    = 0x0008,
};

class CNmMember : public INmMember, public RefCount
{
private:
	BSTR   m_bstrName;            // Display Name
	DWORD  m_dwGCCID;            // GCC UserId
	BOOL   m_fLocal;             // True if local user
	ULONG  m_uCaps;              // Current Roster Caps (CAPFLAG_*)
	ULONG  m_uNmchCaps;           // Current Channel Capabilities (NMCH_*)
	DWORD  m_dwFlags;            // PF_*
	DWORD  m_dwGccIdParent;      // GCCID of parent node

public:
	CNmMember(PWSTR pwszName, DWORD dwGCCID, DWORD dwFlags, ULONG uCaps);
	~CNmMember();

	DWORD GetDwFlags()            {return m_dwFlags;}
	VOID  SetDwFlags(DWORD dw)    {m_dwFlags = dw;}
	
	VOID AddPf(DWORD dw)          {m_dwFlags |= dw;}
	VOID RemovePf(DWORD dw)       {m_dwFlags &= ~dw;}

	VOID SetNmchCaps(ULONG uNmchCaps)    {m_uNmchCaps = uNmchCaps;}
	VOID AddNmchCaps(ULONG uNmchCaps)    {m_uNmchCaps |= uNmchCaps;}
	VOID RemoveNmchCaps(ULONG uNmchCaps) {m_uNmchCaps &= ~uNmchCaps;}

	DWORD GetGCCID()              {return m_dwGCCID;}
	VOID  SetGCCID(DWORD dw)      {m_dwGCCID = dw;}

	DWORD GetGccIdParent()        {return m_dwGccIdParent;}
	VOID  SetGccIdParent(DWORD dw);

	ULONG GetCaps()               {return m_uCaps;}
	VOID  SetCaps(ULONG uCaps)    {m_uCaps = uCaps;}

	
	BOOL  FLocal()                {return m_fLocal;}
	BOOL  FTopProvider()          {return (0 != (m_dwFlags & PF_T120_TOP_PROV));}
	BOOL  FMcu()                  {return (0 != (m_dwFlags & PF_T120_MCU));}

	BSTR GetName()                    {return m_bstrName;}

	// INmMember methods
	HRESULT STDMETHODCALLTYPE GetName(BSTR *pbstrName);
	HRESULT STDMETHODCALLTYPE GetID(ULONG * puID);
	HRESULT STDMETHODCALLTYPE GetConference(INmConference **ppConference);
	HRESULT STDMETHODCALLTYPE IsSelf(void);
	HRESULT STDMETHODCALLTYPE IsMCU(void);
	HRESULT STDMETHODCALLTYPE Eject(void);

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
};

// Utility Functions
CNmMember * GetLocalMember(void);
CNmMember * PMemberFromGCCID(UINT uNodeID);
CNmMember *	PDataMemberFromName(PCWSTR pwszName);

typedef CEnumNmX<IEnumNmMember, &IID_IEnumNmMember, INmMember, CNmMember> CEnumNmMember;

#endif // _IMEMBER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\imember.cpp ===
// File: iMember.cpp
//
// INmMember interface  (participant routines)

#include "precomp.h"
#include "imember.h"
#include "imanager.h" // for g_pNodeController

/*  C  N M  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: CNmMember Constructor
    
-------------------------------------------------------------------------*/
CNmMember::CNmMember(PWSTR pwszName, DWORD dwGCCID, DWORD dwFlags, ULONG uCaps) :
	m_bstrName     (SysAllocString(pwszName)),
	m_dwGCCID      (dwGCCID),
	m_dwFlags      (dwFlags),
	m_uCaps        (uCaps),
	m_uNmchCaps    (0),
	m_dwGccIdParent(INVALID_GCCID)
{
    DebugEntry(CNmMember::CNmMember);

	// Local state never changes
	m_fLocal = 0 != (PF_LOCAL_NODE & m_dwFlags);

    DebugExitVOID(CNmMember::CNmMember);
}


CNmMember::~CNmMember(void)
{
    DebugEntry(CNmMember::~CNmMember);

    if (m_bstrName)
    {
    	SysFreeString(m_bstrName);
        m_bstrName = NULL;
    }

    DebugExitVOID(CNmMember::~CNmMember);
}

VOID CNmMember::SetGccIdParent(DWORD dwGccId)
{
	m_dwGccIdParent = dwGccId;
	if (0 == dwGccId)
	{
		// No Parent means this is the Top Provider
		m_dwFlags |= PF_T120_TOP_PROV;
	}
	else
	{
		m_dwFlags &= ~PF_T120_TOP_PROV;
	}
}



///////////////////////////
//  CNmMember:IUknown

ULONG STDMETHODCALLTYPE CNmMember::AddRef(void)
{
    DebugEntry(CNmMember::AddRef);

    TRACE_OUT(("CNmMember [%ls]:  AddRef this = 0x%X", m_bstrName ? m_bstrName : L"", this));

    ULONG ul = RefCount::AddRef();

    DebugExitULONG(CNmMember::AddRef, ul);
	return ul;
}
	
ULONG STDMETHODCALLTYPE CNmMember::Release(void)
{
    DebugEntry(CNmMember::Release);

    TRACE_OUT(("CNmMember [%ls]: Release this = 0x%X", m_bstrName ? m_bstrName : L"", this));

    ULONG ul = RefCount::Release();

    DebugExitULONG(CNmMember::Release, ul);
	return ul;
}


HRESULT STDMETHODCALLTYPE CNmMember::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmMember) || (riid == IID_IUnknown))
	{
		*ppv = (INmMember *)this;
		TRACE_OUT(("CNmMember::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		TRACE_OUT(("CNmMember::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}



///////////////
// INmMember


HRESULT STDMETHODCALLTYPE CNmMember::GetName(BSTR *pbstrName)
{
	if (NULL == pbstrName)
		return E_POINTER;

	*pbstrName = SysAllocString(m_bstrName);

	return *pbstrName ? S_OK : E_FAIL;
}

HRESULT STDMETHODCALLTYPE CNmMember::GetID(ULONG *puID)
{
	if (NULL == puID)
		return E_POINTER;

	*puID = m_dwGCCID;
	return (0 != m_dwGCCID) ? S_OK : NM_E_NO_T120_CONFERENCE;
}


STDMETHODIMP CNmMember::GetConference(INmConference **ppConference)
{
	return ::GetConference(ppConference);
}

HRESULT STDMETHODCALLTYPE CNmMember::IsSelf(void)
{
	return m_fLocal ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CNmMember::IsMCU(void)
{
	return (m_dwFlags & PF_T120_MCU) ? S_OK : S_FALSE;
}

HRESULT STDMETHODCALLTYPE CNmMember::Eject(void)
{
	if (m_fLocal)
		return E_FAIL; // can't eject ourselves.

	CNmMember * pMemberLocal = GetLocalMember();
	if ((NULL == pMemberLocal) || !pMemberLocal->FTopProvider())
		return E_FAIL; // only top providers should be allowed to do this

	CConfObject * pco = ::GetConfObject();
	if (NULL != pco)
	{
		ASSERT(g_pNodeController);
		ASSERT(pco->GetConfHandle());
		pco->GetConfHandle()->EjectUser(m_dwGCCID);
	}

	return S_OK;
}


///////////////////////////////////////////////////////////////////////
// Utility Functions


/*  G E T  L O C A L  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: GetLocalMember
    
-------------------------------------------------------------------------*/
CNmMember * GetLocalMember(void)
{
	CConfObject * pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->GetLocalMember();
}


/*  P  M E M B E R  F R O M  G  C  C  I  D  */
/*-------------------------------------------------------------------------
    %%Function: PMemberFromGCCID
    
-------------------------------------------------------------------------*/
CNmMember * PMemberFromGCCID(UINT uNodeID)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->PMemberFromGCCID(uNodeID);
}


CNmMember *	PMemberFromName(PCWSTR pwszName)
{
	CConfObject* pco = ::GetConfObject();
	if (NULL == pco)
		return NULL;

	return pco->PMemberFromName(pwszName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\imanager.h ===
#ifndef _IMANAGER_H_
#define _IMANAGER_H_

#include <ias.h>

class COutgoingCall;
class COutgoingCallManager;
class CIncomingCallManager;
class CConfObject;

class COprahNCUI : public INodeControllerEvents, 
				   public INmManager, public CConnectionPointContainer
{
protected:
	static COprahNCUI *m_pOprahNCUI;
	COutgoingCallManager* m_pOutgoingCallManager;
	CIncomingCallManager* m_pIncomingCallManager;

	CConfObject* m_pConfObject;
    BSTR        m_bstrUserName;
    ULONG       m_cRef;

public:
	COprahNCUI();
	~COprahNCUI();

	UINT	GetOutgoingCallCount();
	ULONG	GetAuthenticatedName(PBYTE * ppb);
	VOID	OnOutgoingCallCreated(INmCall* pCall);
	VOID	OnOutgoingCallCanceled(COutgoingCall* pCall);
	VOID	OnIncomingCallAccepted();
	VOID	OnIncomingCallCreated(INmCall* pCall);

	VOID	CancelCalls();

	static COprahNCUI *GetInstance() { return m_pOprahNCUI; }
	CConfObject *GetConfObject() { return m_pConfObject; }
	HRESULT		AbortResolve(UINT uAsyncRequest);

	//
	// INodeControllerEvents methods:
	//
	STDMETHODIMP OnConferenceStarted(	CONF_HANDLE 		hConference,
										HRESULT 			hResult);
	STDMETHODIMP OnConferenceEnded( 	CONF_HANDLE 		hConference);
	STDMETHODIMP OnRosterChanged(		CONF_HANDLE 		hConference,
										PNC_ROSTER			pRoster);
	STDMETHODIMP OnIncomingInviteRequest( CONF_HANDLE 		hConference,
										PCWSTR				pcwszNodeName,
										BOOL				fSecure);
	STDMETHODIMP OnIncomingJoinRequest( CONF_HANDLE 		hConference,
										PCWSTR				pcwszNodeName);
	STDMETHODIMP OnQueryRemoteResult(	PVOID				pvCallerContext,
										HRESULT 			hResult,
										BOOL				fMCU,
										PWSTR*				ppwszConferenceNames,
										PWSTR*                          ppwszConfDescriptors);
	STDMETHODIMP OnInviteResult(		CONF_HANDLE 		hConference,
										REQUEST_HANDLE		hRequest,
										UINT				uNodeID,
										HRESULT 			hResult);

	//
	// INmManager methods
	//
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);
	STDMETHODIMP Initialize(BSTR szName, DWORD_PTR pCredentials, DWORD port, DWORD flags);
    STDMETHODIMP Call(INmCall **ppCall,
						DWORD	dwFlags,
						NM_ADDR_TYPE addrType,
						BSTR bstrAddr,
						BSTR bstrConference,
						BSTR bstrPassword);

    STDMETHODIMP CreateConference(INmConference **ppConference,
                        BSTR  bstrName,
                        BSTR  bstrPassword,
                        BOOL  fSecure);

};

// The global instance that is declared in conf.cpp:
extern INodeController* g_pNodeController;

HRESULT OnNotifyCallStateChanged(IUnknown *pCallNotify, PVOID pv, REFIID riid);

#endif // _IMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\invoklst.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	invoklst.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class
 *		CInvokeSpecifierListContainer.  This class manages the data associated
 *		with an Application Invoke Request or Indication.  This includes a list
 *		of applications to be invoked.  The CInvokeSpecifierListContainer data
 *		container utilizes a CSessKeyContainer container to buffer part of the data
 *		associated with each application invoke specifier.  Each application
 *		invoke specifier also includes a capability ID whose data is buffered
 *		internally by the using a CCapIDContainer container.  The list
 *		of application invoke specifiers is maintained internally by the class
 *		through the use of a Rogue Wave list container.
 *
 *	Protected Instance Variables:
 *		m_InvokeSpecifierList
 *			List of structures used to hold the container data internally.
 *		m_pAPEListPDU
 *			Storage for the "PDU" form of the invoke data.
 *		m_fValidAPEListPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" invoke data.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */

#include "ms_util.h"
#include "invoklst.h"

/*
 *	CInvokeSpecifierListContainer ()
 *
 *	Public Function Description:
 *		This constructor is used to create an CInvokeSpecifierListContainer
 * 		object from a list of "API" application protocol entities.
 */
CInvokeSpecifierListContainer::CInvokeSpecifierListContainer(	
						UINT						number_of_protocol_entities,
						PGCCAppProtocolEntity *	 	app_protocol_entity_list,
						PGCCError					pRetCode)
:
    CRefCount(MAKE_STAMP_ID('I','S','L','C')),
    m_fValidAPEListPDU(FALSE),
    m_cbDataSize(0)
{
	UINT					i;
	PGCCAppProtocolEntity	ape;
	INVOKE_SPECIFIER        *specifier_info;

	/*
	 * Initialize instance variables.
	 */
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Go through the list of application protocol entities (APE's), saving the
	 * necessary information in the internal list of info. structures.
	 */
	for (i = 0; i < number_of_protocol_entities; i++)
	{
		/*
		 * Create a new INVOKE_SPECIFIER structure to hold the data for this
		 * APE.  Check to make sure it was successfully created.
		 */
		DBG_SAVE_FILE_LINE
		specifier_info = new INVOKE_SPECIFIER;
		if (specifier_info != NULL)
		{
			/*
			 * Get the APE from the list.
			 */
			ape = app_protocol_entity_list[i];

			/*
			 * Create a new CSessKeyContainer object to hold the session key.
			 * Check to	make sure construction was successful.
			 */
			DBG_SAVE_FILE_LINE
			specifier_info->session_key = new CSessKeyContainer(&ape->session_key, &rc);
			if ((specifier_info->session_key != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * Save the startup channel type and "invoke" flag.
				 */
				specifier_info->startup_channel_type =ape->startup_channel_type;
				specifier_info->must_be_invoked = ape->must_be_invoked;

				/*
				 * Save the capabilities list for this APE in the internal info.
				 * structure.
				 */
				rc = SaveAPICapabilities(specifier_info,
										ape->number_of_expected_capabilities,
										ape->expected_capabilities_list);

				/*
				 * Insert the new invoke specifier info structure pointer into
				 * the internal list if no error condition exists.
				 */
				if (rc == GCC_NO_ERROR)
				{
					m_InvokeSpecifierList.Append(specifier_info);
				}
				else
				{
					ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error saving caps"));
					break;
				}
			}
			else if (specifier_info->session_key == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error creating CSessKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
			else
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error creating CSessKeyContainer"));
				specifier_info->session_key->Release();
				delete specifier_info;
				break;
			}
		}
		else
		{
			ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error creating INVOKE_SPECIFIER"));
			break;
		}
	}

	*pRetCode = rc;
}

/*
 *	CInvokeSpecifierListContainer ()
 *
 *	Public Function Description:
 *		This constructor is used to create an CInvokeSpecifierListContainer
 *		object from	a "PDU" ApplicationProtocolEntityList.
 */
CInvokeSpecifierListContainer::CInvokeSpecifierListContainer (
					PApplicationProtocolEntityList	 	protocol_entity_list,
					PGCCError							pRetCode)
:
    CRefCount(MAKE_STAMP_ID('I','S','L','C')),
    m_fValidAPEListPDU(FALSE),
    m_cbDataSize(0)
{
	ApplicationInvokeSpecifier		specifier;
	INVOKE_SPECIFIER                *specifier_info;

	GCCError rc = GCC_NO_ERROR;

	while (protocol_entity_list != NULL)
	{
		/*
		 * Create a new INVOKE_SPECIFIER structure to hold the data for this
		 * APE.  Check to make sure it was successfully created.
		 */
		DBG_SAVE_FILE_LINE
		specifier_info = new INVOKE_SPECIFIER;
		if (specifier_info != NULL)
		{
			specifier = protocol_entity_list->value;

			/*
			 * Create a CSessKeyContainer object to hold the session key
			 * internally.  Check to make sure the object is successfully
			 * created.
			 */
			DBG_SAVE_FILE_LINE
			specifier_info->session_key = new CSessKeyContainer(&specifier.session_key, &rc);
			if ((specifier_info->session_key != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * The session key was saved correctly so check to see if a list
				 * of expected capabilities is present and save them if so.
				 */
				if (specifier.bit_mask & EXPECTED_CAPABILITY_SET_PRESENT)
				{
					rc = SavePDUCapabilities(specifier_info, specifier.expected_capability_set);
					if (rc != GCC_NO_ERROR)
					{
						specifier_info->session_key->Release();
						delete specifier_info;
						break;
					}
				}

				/*
				 * Save the startup channel type.  If the channel type is not
				 * present in the PDU then set the channel type in the info
				 * strucuture equal to MCS_NO_CHANNEL_TYPE_SPECIFIED;
				 */
				if (specifier.bit_mask & INVOKE_STARTUP_CHANNEL_PRESENT)
				{
					switch (specifier.invoke_startup_channel)
                    {
                    case CHANNEL_TYPE_STATIC:
						specifier_info->startup_channel_type = MCS_STATIC_CHANNEL;
                        break;
                    case DYNAMIC_MULTICAST:
						specifier_info->startup_channel_type = MCS_DYNAMIC_MULTICAST_CHANNEL;
                        break;
                    case DYNAMIC_PRIVATE:
						specifier_info->startup_channel_type = MCS_DYNAMIC_PRIVATE_CHANNEL;
                        break;
                    case DYNAMIC_USER_ID:
						specifier_info->startup_channel_type = MCS_DYNAMIC_USER_ID_CHANNEL;
                        break;
					}
				}
				else
				{
					specifier_info->startup_channel_type = MCS_NO_CHANNEL_TYPE_SPECIFIED;
				}

				/*
				 * Insert the new invoke specifier info structure pointer into
				 * the internal list if no error condition exists.
				 */
				m_InvokeSpecifierList.Append(specifier_info);
			}
			else if (specifier_info->session_key == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::Construc2: Error creating CSessKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
			else
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::Construc2: Error creating CSessKeyContainer"));
				specifier_info->session_key->Release();
				delete specifier_info;
				break;
			}

			/*
			 * Retrieve the next APE in the list.
			 */
			protocol_entity_list = protocol_entity_list->next;
		}
		else
		{
			ERROR_OUT(("CInvokeSpecifierListContainer::Construc2: Error creating INVOKE_SPECIFIER"));
			break;
		}
	}

	*pRetCode = rc;
}

/*
 *	~CInvokeSpecifierListContainer	()
 *
 *	Public Function Description
 *		The CInvokeSpecifierListContainer destructor is responsible for
 *		freeing any memory allocated to hold the invoke data.
 *
 */
CInvokeSpecifierListContainer::~CInvokeSpecifierListContainer(void)
{
	INVOKE_SPECIFIER *lpInvSpecInfo;

    /*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidAPEListPDU)
		FreeApplicationInvokeSpecifierListPDU ();

	/*
	 * Delete any data containers held internally in the list of info.
	 * structures by iterating through the internal list.
	 */
	m_InvokeSpecifierList.Reset();
 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
	{
		/*
		 * Delete any CSessKeyContainer objects in the INVOKE_SPECIFIER list.
		 */
		if (NULL != lpInvSpecInfo->session_key)
		{
		    lpInvSpecInfo->session_key->Release();
		}

		/*
		 * Iterate through the capabilities list held in the INVOKE_SPECIFIER
		 * structure.
		 */
		lpInvSpecInfo->ExpectedCapItemList.DeleteList();

		/*
		 * Delete the INVOKE_SPECIFIER structure.
		 */
		delete lpInvSpecInfo;
	}
}

/*
 *	LockApplicationInvokeSpecifierList ()
 *
 *	Public Function Description:
 *		This routine locks the invoke specifier data and determines the amount
 *		of memory necessary to hold the associated data.
 */
UINT CInvokeSpecifierListContainer::LockApplicationInvokeSpecifierList(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of
	 * the memory required to hold the data for the application invoke
	 * specifier.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		INVOKE_SPECIFIER            *lpInvSpecInfo;
		APP_CAP_ITEM                *pExpCapData;

		/*
		 * Set aside memory to hold the pointers to the GCCAppProtocolEntity
		 * structures as well as the structures themselves.  The "sizeof" the
		 * structure must be rounded to an even four-byte boundary.
		 */
		m_cbDataSize = m_InvokeSpecifierList.GetCount() *
				(sizeof(PGCCAppProtocolEntity) + ROUNDTOBOUNDARY(sizeof(GCCAppProtocolEntity)));

		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			/*
			 * Lock the data for the session keys, adding the amount of memory
			 * necessary to hold the session key data to the total memory size.
			 */
			m_cbDataSize += lpInvSpecInfo->session_key->LockSessionKeyData();

			lpInvSpecInfo->ExpectedCapItemList.Reset();

			/*
			 * Set aside memory to hold the pointers to the
			 * GCCApplicationCabability	structures as well as the structures
			 * themselves.  The "sizeof" the structure must be rounded to an
			 * even four-byte boundary.
			 */
			m_cbDataSize += lpInvSpecInfo->ExpectedCapItemList.GetCount() *
					( sizeof(PGCCApplicationCapability) + ROUNDTOBOUNDARY (sizeof(GCCApplicationCapability)) );

			/*
			 * Lock the data for the capability ID's, adding the amount of
			 * memory necessary to hold the capability ID data to the total
			 * memory size.
			 */
			while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
			{
				m_cbDataSize += pExpCapData->pCapID->LockCapabilityIdentifierData();
			}
		}
	}

	return m_cbDataSize;
}

/*
 *	GetApplicationInvokeSpecifierList ()
 *
 *	Public Function Description:
 *		This routine retrieves the invoke specifier data in the form of a
 *		list of application protocol entities which are written into the memory
 *		provided.  This routine is called after "locking" the data.
 */
UINT CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierList(
									USHORT		*number_of_protocol_entities,
									LPBYTE		memory)
{
	PGCCAppProtocolEntity *			ape_list_ptr;
	PGCCAppProtocolEntity 			ape_ptr;
	PGCCApplicationCapability 		capability_ptr;
	UINT							data_length = 0;
	Int								ape_counter = 0;
	Int								capability_counter = 0;
	UINT							cbDataSizeToRet = 0;
	INVOKE_SPECIFIER                *lpInvSpecInfo;
	APP_CAP_ITEM                    *pExpCapData;
	
	/*
	 * If the object has been locked, fill in the output structure and
	 * the data referenced by the structure.  Otherwise, report that the object
	 * key has yet to be locked into the "API" form.
	 */
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.  This value was
		 * calculated on the call to "Lock".
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the number of protocol entities and save a pointer to
		 * the memory location passed in.  This is where the pointers to
		 * the GCCAppProtocolEntity	structures will be written.  The actual
		 * structures will be written into memory immediately following the list
		 * of pointers.
		 */
		*number_of_protocol_entities = (USHORT) m_InvokeSpecifierList.GetCount();

		ape_list_ptr = (PGCCAppProtocolEntity *)memory;

		/*
		 * Save the amount of memory needed to hold the list of structure
		 * pointers.
		 */
		data_length = m_InvokeSpecifierList.GetCount() * sizeof(PGCCAppProtocolEntity);

		/*
		 * Move the memory pointer past the list of APE pointers.  This is where
		 * thefirst APE structure will be written.
		 */
		memory += data_length;

		/*
		 * Iterate through the internal list of INVOKE_SPECIFIER structures,
		 * building "API" GCCAppProtocolEntity structures in memory.
		 */
		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			/*
			 * Save the pointer to the APE structure in the list of pointers.
			 */
			ape_ptr = (PGCCAppProtocolEntity)memory;
			ape_list_ptr[ape_counter++] = ape_ptr;

			/*
			 * Move the memory pointer past the APE structure.  This is where
			 * thesession key data will be written.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCAppProtocolEntity));

			/*
			 * Fill in the APE structure starting with the session key.
			 */
			data_length = lpInvSpecInfo->session_key->GetGCCSessionKeyData(&ape_ptr->session_key, memory);

			/*
			 * Move the memory pointer past the session key data.  This is
			 * where the list of pointers to the GCCApplicationCapability
			 * structures will be written so save the pointer in the APE
			 * structure's capabilities list pointer.
			 */
			memory += data_length;

			ape_ptr->expected_capabilities_list = (PGCCApplicationCapability *)memory;

			/*
			 * Go ahead and fill in the APE's channel type and invoke flag.
			 */
			ape_ptr->must_be_invoked = lpInvSpecInfo->must_be_invoked;
			ape_ptr->startup_channel_type = lpInvSpecInfo->startup_channel_type;
			ape_ptr->number_of_expected_capabilities = (USHORT) lpInvSpecInfo->ExpectedCapItemList.GetCount();

			/*
			 * Move the memory pointer past the list of GCCApplicationCapability
			 * pointers.  This is where the first GCCApplicationCapability
			 * structure will be written.
			 */
			memory += (lpInvSpecInfo->ExpectedCapItemList.GetCount() *
					    sizeof(PGCCApplicationCapability));

			/*
			 * Iterate through the list of capabilities, writing the
			 * GCCApplicationCapability structures into memory.
			 */
			capability_counter = 0;
			lpInvSpecInfo->ExpectedCapItemList.Reset();
			while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
			{
				/*
				 * Save the pointer to the capability structure in the list of
				 * pointers.  Move the memory pointer past the capability
				 * structure.  This is where the data associated with the
				 * capability ID will be written.
				 */
				capability_ptr = (PGCCApplicationCapability)memory;
				ape_ptr->expected_capabilities_list[capability_counter++] = capability_ptr;

				memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationCapability));

				/*
				 * Fill in the capability structure and add the amount of data
				 * written into memory to the total data length.
				 */
				data_length = GetApplicationCapability(pExpCapData, capability_ptr, memory);

				/*
				 * Move the	memory pointer past the capability data.
				 */
				memory += data_length;
			}
		}
	}
	else
	{
		number_of_protocol_entities = 0;
		ERROR_OUT(("CInvokeSpecifierListContainer::GetAppInvokeSpecList: Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnLockApplicationInvokeSpecifierList ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated
 *		with the "API" invoke specifier list once the lock count reaches zero.
 */
void CInvokeSpecifierListContainer::UnLockApplicationInvokeSpecifierList(void)
{
	if (Unlock(FALSE) == 0)
	{
		INVOKE_SPECIFIER            *lpInvSpecInfo;
		APP_CAP_ITEM                *pExpCapData;

		/*
		 * Unlock any container data held internally in the list of info.
		 * structures by iterating through the internal list.
		 */
		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			/*
			 * Unlock any CSessKeyContainer objects.
			 */
			lpInvSpecInfo->session_key->UnLockSessionKeyData();

			/*
			 * Iterate through the capabilities list held in the
			 * INVOKE_SPECIFIER structure.
			 */
			lpInvSpecInfo->ExpectedCapItemList.Reset();
			while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
			{
				/*
				 * Unlock the CCapIDContainer objects.
				 */
				pExpCapData->pCapID->UnLockCapabilityIdentifierData();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	GetApplicationInvokeSpecifierListPDU ()
 *
 *	Public Function Description:
 *		This routine retrieves the "PDU" form of an
 * 		ApplicationProtocolEntityList.
 */
GCCError CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierListPDU(
								PApplicationProtocolEntityList	*protocol_entity_list)
{
	GCCError								rc = GCC_NO_ERROR;
	PApplicationProtocolEntityList			new_pdu_ape_list_ptr;
	PApplicationProtocolEntityList			old_pdu_ape_list_ptr = NULL;
	
	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the input parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * input parameter.
	 */
	if (m_fValidAPEListPDU == FALSE)
	{
		INVOKE_SPECIFIER *lpInvSpecInfo;

		m_fValidAPEListPDU = TRUE;

		/*
		 * Initialize the output parameter to NULL so that the first time
		 * through the loop it will be set equal to the first new APE list
		 * created in the iterator loop.
		 */
		m_pAPEListPDU = NULL;

		/*
		 * Iterate through the list of "INVOKE_SPECIFIER" structures,
		 * converting each into "PDU" form and saving the pointers in the
		 * "ApplicationProtocolEntityList" which is a linked list of
		 * "ApplicationInvokeSpecifiers".
		 */
		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_pdu_ape_list_ptr = new ApplicationProtocolEntityList;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_pdu_ape_list_ptr == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierListPDU: can't allocate ApplicationProtocolEntityList"));
				rc = GCC_ALLOCATION_FAILURE;
				FreeApplicationInvokeSpecifierListPDU ();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first ApplicationProtocolEntityList created.  On
			 * subsequent loops, set the structure's "next" pointer equal to
			 * the new structure.
			 */
			if (m_pAPEListPDU == NULL)
			{
				m_pAPEListPDU = new_pdu_ape_list_ptr;
			}
			else
			{
				old_pdu_ape_list_ptr->next = new_pdu_ape_list_ptr;
			}

			old_pdu_ape_list_ptr = new_pdu_ape_list_ptr;

			/*
			 * Initialize the new "next" pointer to NULL.
			 */
			new_pdu_ape_list_ptr->next = NULL;

			if (ConvertInvokeSpecifierInfoToPDU (lpInvSpecInfo, new_pdu_ape_list_ptr) !=
																		GCC_NO_ERROR)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierListPDU: can't convert UserDataInfo to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * input parameter.
	 */
	*protocol_entity_list = m_pAPEListPDU;

	return rc;
}

/*
 *	FreeApplicationInvokeSpecifierListPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the invoke specifier data held internally
 *		in the "PDU" form of a "ApplicationProtocolEntityList".
 */
void CInvokeSpecifierListContainer::FreeApplicationInvokeSpecifierListPDU(void)
{
	PApplicationProtocolEntityList  pCurr, pNext;
	INVOKE_SPECIFIER                *lpInvSpecInfo;
	APP_CAP_ITEM                    *pExpCapData;

	if (m_pAPEListPDU != NULL)
	{
		m_fValidAPEListPDU = FALSE;

		/*
		 * Loop through the list, freeing the data associated with
		 * each structure contained in the list.
		 */
        for (pCurr = m_pAPEListPDU; NULL != pCurr; pCurr = pNext)
        {
            pNext = pCurr->next;
            delete pCurr;
		}
	}

	/*
	 * Iterate through the internal list, telling each data container object
	 * to free any PDU data which it has allocated.
	 */
	m_InvokeSpecifierList.Reset();
	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
	{
		if (lpInvSpecInfo->session_key != NULL)
        {
			lpInvSpecInfo->session_key->FreeSessionKeyDataPDU();
        }

		/*
		 * Iterate through the
		 * list, freeing the PDU data for the capability ID's.
		 */
		lpInvSpecInfo->ExpectedCapItemList.Reset();
		while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
		{
			pExpCapData->pCapID->FreeCapabilityIdentifierDataPDU();
		}
	}
}

/*
 *	GCCError	CInvokeSpecifierListContainer::SaveAPICapabilities (
 *						INVOKE_SPECIFIER                *invoke_specifier,
 *						UINT							number_of_capabilities,
 *						PGCCApplicationCapability	* 	capabilities_list)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 * 		This routine is used to save the list of application capabilities passed
 * 		in as "API" data in the internal list of expected capability data
 *		which is held in the internal info structure.
 *
 *	Formal Parameters:
 *		invoke_specifier		(i) Internal structure used to hold invoke data.
 *		number_of_capabilities	(i) Number of capabilities in list.
 *		capabilities_list		(i) List of API capabilities to save.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::SaveAPICapabilities(
						INVOKE_SPECIFIER                *invoke_specifier,
						UINT							number_of_capabilities,
						PGCCApplicationCapability	* 	capabilities_list)
{
	GCCError		rc = GCC_NO_ERROR;
	APP_CAP_ITEM    *pExpCapData;
	UINT			i;

	for (i = 0; i < number_of_capabilities; i++)
	{
		/*
		 * For each capability, create an APP_CAP_ITEM structure
		 * to hold all the necessary data.  This structure will be inserted into
		 * the list held by the internal info. structure.
		 */
		DBG_SAVE_FILE_LINE
		pExpCapData = new APP_CAP_ITEM((GCCCapabilityType) capabilities_list[i]->capability_class.eType);
		if (pExpCapData != NULL)
		{
			/*
			 * Create a new CCapIDContainer object to hold the
			 * identifier data.
			 */
			DBG_SAVE_FILE_LINE
			pExpCapData->pCapID = new CCapIDContainer(&capabilities_list[i]->capability_id, &rc);
			if ((pExpCapData->pCapID != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * The identifier object was successfully created so fill in the
				 * rest of the ApplicationCapabilityData structure.
				 */
                switch (pExpCapData->eCapType)
                {
                case GCC_UNSIGNED_MINIMUM_CAPABILITY:
					pExpCapData->nUnsignedMinimum = capabilities_list[i]->capability_class.nMinOrMax;
                    break;
                case GCC_UNSIGNED_MAXIMUM_CAPABILITY:
					pExpCapData->nUnsignedMaximum = capabilities_list[i]->capability_class.nMinOrMax;
                    break;
				}

				/*
				 * Add this expected capability to the list.
				 */
				invoke_specifier->ExpectedCapItemList.Append(pExpCapData);
			}
			else
            {
				delete pExpCapData;
				rc = GCC_ALLOCATION_FAILURE;
                break;
			}
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
            break;
        }
	}

	return rc;
}

/*
 *	GCCError	CInvokeSpecifierListContainer::SavePDUCapabilities (
 *						INVOKE_SPECIFIER                *invoke_specifier,
 *						PSetOfExpectedCapabilities	 	capabilities_set)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 * 		This routine is used to save the list of application capabilities passed
 * 		in as "PDU" data in the internal list of expected capability data
 *		which is held in the internal info. structure.
 *
 *	Formal Parameters:
 *		invoke_specifier		(i) Internal structure used to hold invoke data.
 *		capabilities_set		(i) List of PDU capabilities to save.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::SavePDUCapabilities(
						INVOKE_SPECIFIER                *invoke_specifier,
						PSetOfExpectedCapabilities	 	capabilities_set)
{
	GCCError		rc = GCC_NO_ERROR;
	APP_CAP_ITEM    *pExpCapData;

	while ((capabilities_set != NULL) && (rc == GCC_NO_ERROR))
	{
		/*
		 * Create and fill in the new expected capability.
		 */
		DBG_SAVE_FILE_LINE
		pExpCapData = new APP_CAP_ITEM((GCCCapabilityType) capabilities_set->value.capability_class.choice);
		if (pExpCapData != NULL)
		{
			/*
			 * Create the CCapIDContainer object used to hold the
			 * capability ID data internally.  Make sure creation is successful.
			 */
			DBG_SAVE_FILE_LINE
			pExpCapData->pCapID = new CCapIDContainer(&capabilities_set->value.capability_id, &rc);
			if	(pExpCapData->pCapID == NULL || rc != GCC_NO_ERROR)
			{
				rc = GCC_ALLOCATION_FAILURE;
				delete pExpCapData;
			}
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }

		/*
		 * The capability ID was saved successfully, so go ahead and insert
		 * the expected capability data structure into the internal list.
		 * Fill in the capability class data.
		 */
		if (rc == GCC_NO_ERROR)
		{
			invoke_specifier->ExpectedCapItemList.Append(pExpCapData);

			/*
			 * Save the capability type and value.
			 */
            switch (capabilities_set->value.capability_class.choice)
            {
            case UNSIGNED_MINIMUM_CHOSEN:
				pExpCapData->nUnsignedMinimum = capabilities_set->value.capability_class.u.unsigned_minimum;
                break;
            case UNSIGNED_MAXIMUM_CHOSEN:
				pExpCapData->nUnsignedMaximum = capabilities_set->value.capability_class.u.unsigned_maximum;
                break;
			}
		}

        capabilities_set = capabilities_set->next;
	}

	return rc;
}

/*
 *	UINT	CInvokeSpecifierListContainer::GetApplicationCapability (
 *					APP_CAP_ITEM			        *capability_info_data,
 *					PGCCApplicationCapability		api_capability,
 *					LPSTR							memory)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 * 		This routine is used to fill in an API GCCApplicationCapability
 *		structure from an internal info structure.
 *
 *	Formal Parameters:
 *		capability_info_data	(i) Internal capability data to convert into
 *										API data.
 *		api_capability			(o) Structure to hold data in API form.
 *		memory					(o) Memory used to hold bulk data referenced by
 *										the API structure.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
UINT CInvokeSpecifierListContainer::GetApplicationCapability(
					APP_CAP_ITEM                    *pExpCapData,
					PGCCApplicationCapability		api_capability,
					LPBYTE							memory)
{
	UINT		data_length = 0;

	/*
	 * Call the CapabilityID object to retrieve the capability ID data.
	 */
	data_length = pExpCapData->pCapID->GetGCCCapabilityIDData(
												&api_capability->capability_id,
												memory);

	/*
	 * Fill in the remaining fields for the GCCApplicationCapability structure.
	 */
	api_capability->capability_class.eType = pExpCapData->eCapType;
    switch (pExpCapData->eCapType)
    {
    case GCC_UNSIGNED_MINIMUM_CAPABILITY:
		api_capability->capability_class.nMinOrMax = pExpCapData->nUnsignedMinimum;
        break;
    case GCC_UNSIGNED_MAXIMUM_CAPABILITY:
		api_capability->capability_class.nMinOrMax = pExpCapData->nUnsignedMaximum;
        break;
	}

	/*
	 * Fill in the number of entities.  Note, however, that this field will not
	 * be used in this context.
	 */
	api_capability->number_of_entities = 0;

	return (data_length);
}

/*
 *	GCCError	CInvokeSpecifierListContainer::ConvertInvokeSpecifierInfoToPDU(	
 *						INVOKE_SPECIFIER                    *specifier_info_ptr,
 *						PApplicationProtocolEntityList		ape_list_ptr)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine converts the invoke specifier from the internal form which
 *		is an "INVOKE_SPECIFIER" structure into the "PDU" structure form of
 *		a "ApplicationInvokeSpecifier".
 *
 *	Formal Parameters:
 *		specifier_info_ptr	(i) Internal structure holding data to convert.
 *		ape_list_ptr		(o) PDU structure to hold converted data.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::ConvertInvokeSpecifierInfoToPDU (	
						INVOKE_SPECIFIER                    *specifier_info_ptr,
						PApplicationProtocolEntityList		ape_list_ptr)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfExpectedCapabilities		new_capability_set_ptr;
	PSetOfExpectedCapabilities		old_capability_set_ptr = NULL;

	/*
	 * Initialize the invoke specifier bit mask to zero.
	 */
	ape_list_ptr->value.bit_mask = 0;

	/*
	 * Fill in the session key PDU data using the CSessKeyContainer object.
	 */
	rc = specifier_info_ptr->session_key->GetSessionKeyDataPDU(&ape_list_ptr->value.session_key);

	/*
	 * Fill in the capabilities list if any exist.
	 */
	if ((rc == GCC_NO_ERROR) && (specifier_info_ptr->ExpectedCapItemList.GetCount() != 0))
	{
		APP_CAP_ITEM *pExpCapData;

		ape_list_ptr->value.bit_mask |= EXPECTED_CAPABILITY_SET_PRESENT;

		/*
		 * Set the pointer to the capability set to NULL so that it will be
		 * set equal to the first SetOfExpectedCapabilities created inside the
		 * iterator loop.
		 */
		ape_list_ptr->value.expected_capability_set = NULL;

		/*
		 * Iterate through the list of APP_CAP_ITEM structures,
		 * converting each into "PDU" form and saving the pointers in the
		 * "SetOfExpectedCapabilities.
		 */
		specifier_info_ptr->ExpectedCapItemList.Reset();
		while (NULL != (pExpCapData = specifier_info_ptr->ExpectedCapItemList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_capability_set_ptr = new SetOfExpectedCapabilities;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_capability_set_ptr == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::ConvertToPDU: alloc error, cleaning up"));
				rc = GCC_ALLOCATION_FAILURE;
				FreeApplicationInvokeSpecifierListPDU();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfExpectedCapabilities created.  On
			 * subsequent loops, set the structure's "next" pointer equal to
			 * the new structure.
			 */
			if (ape_list_ptr->value.expected_capability_set == NULL)
			{
				ape_list_ptr->value.expected_capability_set = new_capability_set_ptr;
			}
			else
            {
				old_capability_set_ptr->next = new_capability_set_ptr;
            }

			old_capability_set_ptr = new_capability_set_ptr;

			/*
			 * Initialize the new "next" pointer to NULL.
			 */
			new_capability_set_ptr->next = NULL;

			if (ConvertExpectedCapabilityDataToPDU(pExpCapData, new_capability_set_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::ConvertToPDU: Error converting Capability to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	/*
	 * Fill in the channel type if one is specified.
	 */
	if (specifier_info_ptr->startup_channel_type != MCS_NO_CHANNEL_TYPE_SPECIFIED)
	{
		ape_list_ptr->value.bit_mask |= INVOKE_STARTUP_CHANNEL_PRESENT;
	
        switch (specifier_info_ptr->startup_channel_type)
        {
        case MCS_STATIC_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = CHANNEL_TYPE_STATIC;
            break;
        case MCS_DYNAMIC_MULTICAST_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = DYNAMIC_MULTICAST;
            break;
        case MCS_DYNAMIC_PRIVATE_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = DYNAMIC_PRIVATE;
            break;
        case MCS_DYNAMIC_USER_ID_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = DYNAMIC_USER_ID;
            break;
		}
	}

	/*
	 * Fill in the invoke flag.
	 */
	ape_list_ptr->value.invoke_is_mandatory = (ASN1bool_t)specifier_info_ptr->must_be_invoked;

	return rc;
}

/*
 *	GCCError CInvokeSpecifierListContainer::ConvertExpectedCapabilityDataToPDU(	
 *						APP_CAP_ITEM				        *info_ptr,
 *						PSetOfExpectedCapabilities			pdu_ptr)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine converts the capability ID from the internal form which
 *		is an APP_CAP_ITEM structure into the "PDU" structure form
 *		of a "SetOfExpectedCapabilities".
 *
 *	Formal Parameters:
 *		info_ptr	(i) Internal structure holding data to convert.
 *		pdu_ptr		(o) PDU structure to hold converted data.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::ConvertExpectedCapabilityDataToPDU (	
						APP_CAP_ITEM				        *pExpCapData,
						PSetOfExpectedCapabilities			pdu_ptr)
{
	GCCError		rc = GCC_NO_ERROR;

	/*
	 * Retrieve the capability ID data from the internal
	 * CCapIDContainer object.
	 */
	rc = pExpCapData->pCapID->GetCapabilityIdentifierDataPDU(&pdu_ptr->value.capability_id);

	/*
	 * Fill in the capability class.
	 */
	if (rc == GCC_NO_ERROR)
	{
        switch (pExpCapData->eCapType)
        {
        case GCC_LOGICAL_CAPABILITY:
			pdu_ptr->value.capability_class.choice = LOGICAL_CHOSEN;
            break;
        case GCC_UNSIGNED_MINIMUM_CAPABILITY:
			pdu_ptr->value.capability_class.choice = UNSIGNED_MINIMUM_CHOSEN;
			pdu_ptr->value.capability_class.u.unsigned_minimum = pExpCapData->nUnsignedMinimum;
            break;
        case GCC_UNSIGNED_MAXIMUM_CAPABILITY:
			pdu_ptr->value.capability_class.choice = UNSIGNED_MAXIMUM_CHOSEN;
			pdu_ptr->value.capability_class.u.unsigned_maximum = pExpCapData->nUnsignedMaximum;
            break;
		}
	}

	return rc;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\mcsber.c ===
#include <windows.h>
#include <msber.h>
#include "mcspdu.h"

#ifndef ASSERT
#ifdef _DEBUG
#define ASSERT(flag) if (!(flag)) DebugBreak()
#else
#define ASSERT(flag)
#endif /* _DEBUG */
#endif /* ! ASSERT */


__inline int ASN1API ASN1BEREncSimpleOSTR(ASN1encoding_t enc, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncOctetString(enc, 0x4, len, val);
}
__inline int ASN1API ASN1BERDecSimpleOSTR(ASN1decoding_t dec, ASN1octetstring_t *val)
{
    return ASN1BERDecOctetString(dec, 0x4, val);
}

__inline int ASN1API ASN1BEREncSimpleU32(ASN1encoding_t enc, ASN1uint32_t val)
{
    return ASN1BEREncU32(enc, 0x02, val);
}
__inline int ASN1API ASN1BERDecSimpleU32Val(ASN1decoding_t dec, ASN1uint32_t *val)
{
    return ASN1BERDecU32Val(dec, 0x02, val);
}

__inline int ASN1API ASN1BEREncEnum(ASN1encoding_t enc, ASN1uint32_t val)
{
    return ASN1BEREncU32(enc, 0x0a, val);
}
__inline int ASN1API ASN1BERDecEnum(ASN1decoding_t dec, ASN1uint32_t *val)
{
    return ASN1BERDecU32Val(dec, 0x0a, val);
}


// THE FOLLOWING IS GENERATED BY THE TELES COMPILER PLUS MANUAL CHANGES

ASN1int32_t ASN1CALL ASN1Enc_PDUDomainParameters(ASN1encoding_t enc, PDUDomainParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_channel_ids))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_user_ids))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_token_ids))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->number_priorities))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->min_throughput))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_height))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_mcspdu_size))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->protocol_version))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_PDUDomainParameters(ASN1decoding_t dec, PDUDomainParameters *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x10, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_channel_ids))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_user_ids))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_token_ids))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->number_priorities))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->min_throughput))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_height))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_mcspdu_size))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->protocol_version))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectInitialPDU(ASN1encoding_t enc, ConnectInitialPDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000065, &nLenOff))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->calling_domain_selector).length, ((val)->calling_domain_selector).value))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->called_domain_selector).length, ((val)->called_domain_selector).value))
        return 0;
    if (!ASN1BEREncBool(enc, 0x01, (val)->upward_flag))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->target_parameters))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->minimum_parameters))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->maximum_parameters))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->user_data).length, ((val)->user_data).value))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectInitialPDU(ASN1decoding_t dec, ConnectInitialPDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000065, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->calling_domain_selector))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->called_domain_selector))
        return 0;
    if (!ASN1BERDecBool(dec, 0x01, &(val)->upward_flag))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->target_parameters))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->minimum_parameters))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->maximum_parameters))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->user_data))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectResponsePDU(ASN1encoding_t enc, ConnectResponsePDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000066, &nLenOff))
        return 0;
    if (!ASN1BEREncEnum(enc, (val)->result))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->called_connect_id))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->domain_parameters))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->user_data).length, ((val)->user_data).value))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectResponsePDU(ASN1decoding_t dec, ConnectResponsePDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000066, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecEnum(dec, (ASN1uint32_t *) &(val)->result))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->called_connect_id))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->domain_parameters))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->user_data))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectAdditionalPDU(ASN1encoding_t enc, ConnectAdditionalPDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000067, &nLenOff))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->called_connect_id))
        return 0;
    if (!ASN1BEREncEnum(enc, (val)->data_priority))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectAdditionalPDU(ASN1decoding_t dec, ConnectAdditionalPDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000067, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->called_connect_id))
        return 0;
    if (!ASN1BERDecEnum(dec, (ASN1uint32_t *) &(val)->data_priority))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectResultPDU(ASN1encoding_t enc, ConnectResultPDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000068, &nLenOff))
        return 0;
    if (!ASN1BEREncEnum(enc, (val)->result))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectResultPDU(ASN1decoding_t dec, ConnectResultPDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000068, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecEnum(dec, (ASN1uint32_t *) &(val)->result))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectMCSPDU(ASN1encoding_t enc, ConnectMCSPDU *val)
{
    switch ((val)->choice) {
    case 1:
        if (!ASN1Enc_ConnectInitialPDU(enc, &(val)->u.connect_initial))
            return 0;
        break;
    case 2:
        if (!ASN1Enc_ConnectResponsePDU(enc, &(val)->u.connect_response))
            return 0;
        break;
    case 3:
        if (!ASN1Enc_ConnectAdditionalPDU(enc, &(val)->u.connect_additional))
            return 0;
        break;
    case 4:
        if (!ASN1Enc_ConnectResultPDU(enc, &(val)->u.connect_result))
            return 0;
        break;
    default:
        ASSERT(0);
        return 0;
    }
    return 1;
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectMCSPDU(ASN1decoding_t dec, ConnectMCSPDU *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
        return 0;
    switch (t) {
    case 0x40000065:
        (val)->choice = 1;
        if (!ASN1Dec_ConnectInitialPDU(dec, &(val)->u.connect_initial))
            return 0;
        break;
    case 0x40000066:
        (val)->choice = 2;
        if (!ASN1Dec_ConnectResponsePDU(dec, &(val)->u.connect_response))
            return 0;
        break;
    case 0x40000067:
        (val)->choice = 3;
        if (!ASN1Dec_ConnectAdditionalPDU(dec, &(val)->u.connect_additional))
            return 0;
        break;
    case 0x40000068:
        (val)->choice = 4;
        if (!ASN1Dec_ConnectResultPDU(dec, &(val)->u.connect_result))
            return 0;
        break;
    default:
        (val)->choice = -1;
        ASSERT(0);
        return 0;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\mcslog.cpp ===
#include "precomp.h"
/**********************************************************************
 * File:     mcslog.c
 * Abstract: global function definitions for protocol logging functions 
 * added into MCSNC.DLL to read the contents of MCS PDU
 * contents sent and received from the T.123 layer.
 * Created:  2/18/96, Venkatesh Gopalakrishnan
 * Copyright (c) 1996 Microsoft Corpration
 ******************************************************************** */

 /* NOTE:  The contents of this file are only included IFF PDULOG is a
  * defined constant.  This constant will be defined in the Win32 Diagnostic
  * build configuration of MCSNC.DLL 
  */

 #ifdef PDULOG
 
 #include "mcslog.h"
 
 /* just threw these in to keep a total count of the number of bytes
  * of ASN.1 coded data sent and received.
  */
 long int recv_pdu_log = 0;
 long int sent_pdu_log = 0;

 /***********************************************************************/
 int InitializeMCSLog()
 {
    FILE *logfile;

	/* this should just reset the file pointer */    
    logfile = fopen(LOG_FILE_NAME,"w");

	// this "fake" starting PDU is put in so that the Intel Protocol Browser
	// dosen't go nuts if it is reading dynamically.
    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     MCS\n");
    pduLog(logfile,"DIRECTION: None\n");
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduLog(logfile,"PDU_TYPE:  Bogus_PDU_to_start_the_logging.\n");
	pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
	
	fclose(logfile);
    return(0);
 }

 /**************************************************************************/
 char *pszTimeStamp()
 {
    char *timestring;
    timestring = (char *) malloc (13*sizeof(char));
    _strtime(timestring);
    return(timestring);
 }

 /**************************************************************************/
 void pduFragmentation(FILE *logfile,unsigned int i)
 {
    pduLog(logfile,"  PDU Fragmentation: ");
    if(i==1) 
    {
        pduLog(logfile,"Complete PDU\n");
    }
    else
    {
        pduLog(logfile,"!!!! Icomplete PDU !!!!\n");
    }
 }

 /**************************************************************************/
 void  pduRawOutput (FILE *logfile,unsigned char *data, unsigned long length) 
 {
       unsigned int i=0,j=0;
       
       pduLog(logfile,"        ");
       for (i=0; i<length; i++) 
       {
            pduLog(logfile,"%02x ",*(data+i));
            j++;
            if (j >= 16) 
            {
                pduLog(logfile,"\n        ");
                j=0;
            }
       }
       pduLog(logfile,"\n");
 }

 /**************************************************************************/ 
 void PrintCharData(FILE *logfile, unsigned char *data, unsigned int length)
 {
	 char print_buffer[255];

	 //strncpy(print_buffer,(const char *) data, length);
	 //CopyTextToChar(print_buffer, (unsigned short *) data, length);
	 //pduLog(logfile,"\tlength = [%d] ; ",length);
	 //pduLog(logfile,"\ttext = %s\n",print_buffer);
	 pduRawOutput(logfile,data,length);
 }

 /**************************************************************************/
 void pduDirection(FILE *logfile,unsigned int direction)
 {
    switch(direction)
    {
        case SENT:
            pduLog(logfile,"DIRECTION: Sent\n");
            break;
        case RECEIVED:
            pduLog(logfile,"DIRECTION: Received\n");
            break;
        default:
            pduLog(logfile,"DIRECTION: Unknown\n");
            break;
     }
 }


/**************************************************************************/
void	pduLog (FILE *pFile, char * format,...)
 {
    char	*argument_ptr;
    
    argument_ptr = (char *) &format + sizeof (format);
    vfprintf (pFile, format, argument_ptr);
 }


 /**************************************************************************/  
 void mcsLog(PPacket packet, PDomainMCSPDU domain_pdu, unsigned int direction)
 {
    FILE *logfile;   
    logfile = fopen(LOG_FILE_NAME,"a+");
    
    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     MCS\n");
    pduDirection(logfile,direction);
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"      %d octets (hex output):\n",packet->GetEncodedDataLength());
    if(direction==RECEIVED)
        recv_pdu_log = recv_pdu_log + packet->GetEncodedDataLength();
    else
        sent_pdu_log = sent_pdu_log + packet->GetEncodedDataLength();
    pduLog(logfile,"      Total Data:  sent = %ld    recv = %ld\n",sent_pdu_log,recv_pdu_log);
    pduRawOutput(logfile,packet->GetEncodedData(1),packet->GetEncodedDataLength());
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduFragmentation(logfile,packet->IsValid());
    pduLogMCSDomainInfo(logfile,domain_pdu);
    pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
 
    fclose(logfile);
 }

 /**************************************************************************/
 void mcsConnectLog(PPacket packet, PConnectMCSPDU connect_pdu, unsigned int direction)
 {
    FILE *logfile;   
    logfile = fopen(LOG_FILE_NAME,"a+");

    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     MCS\n");
    pduDirection(logfile,direction);
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"      %d octets (hex output):\n",packet->GetEncodedDataLength());
    if(direction==RECEIVED)
        recv_pdu_log = recv_pdu_log + packet->GetEncodedDataLength();
    else
        sent_pdu_log = sent_pdu_log + packet->GetEncodedDataLength();
    pduLog(logfile,"      Total Data:  sent = %ld    recv = %ld\n",sent_pdu_log,recv_pdu_log);
    pduRawOutput(logfile,packet->GetEncodedData(1),packet->GetEncodedDataLength());
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduFragmentation(logfile,packet->IsValid());
    pduLogMCSConnectInfo(logfile,connect_pdu);
    pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
 
    fclose(logfile);
 }


 ////////////////////////////////////////////////////////////////////////////
 // Switch cases for MCS Connect PDUs
 ////////////////////////////////////////////////////////////////////////////
 /**************************************************************************/ 
 void   pduLogMCSConnectInfo(FILE *logfile, PConnectMCSPDU connect_pdu)
 {
    switch(connect_pdu->choice)
    {
		case CONNECT_INITIAL_CHOSEN:
            {
                pduLog(logfile,"PDU_TYPE: MCS_ConnectInitialPDU\n");
				pduLogConnectInitial(logfile,connect_pdu);
			}
            break;
		case CONNECT_RESPONSE_CHOSEN:
            {
                pduLog(logfile, "PDU_TYPE: MCS_ConnectResponsePDU\n");
				pduLogConnectResponse(logfile, connect_pdu);
			}
            break;
        case CONNECT_ADDITIONAL_CHOSEN:
            {
                pduLog(logfile,"PDU_TYPE: MCS_ConnectAdditionalPDU\n");
				pduLogConnectAdditional(logfile, connect_pdu);
            }
            break;
        case CONNECT_RESULT_CHOSEN:
            {
				pduLog(logfile,"PDU_TYPE: MCS_ConnectResultPDU\n");
				pduLogConnectResult(logfile, connect_pdu);
            }
            break;
        default:
            {
                pduLog(logfile,"ERROR: Unknown MCS Connect PDU !! << \n");
            }
            break;
	}
 }

 /**************************************************************************/
 void   pduLogMCSDomainInfo(FILE *logfile, PDomainMCSPDU domain_pdu)
 {
    switch(domain_pdu->choice)
    {
        case PLUMB_DOMAIN_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_PlumbDomainIndication\n");
				pduLogPlumbDomainIndication(logfile, domain_pdu);
			}
			break;
		case ERECT_DOMAIN_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ErectDomainIndication\n");
				pduLogErectDomainRequest(logfile, domain_pdu);
			}
			break;
		case MERGE_CHANNELS_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeChannelsRequest\n");
				pduLogMergeChannelsRequest(logfile, domain_pdu);
			}
			break;
		case MERGE_CHANNELS_CONFIRM_CHOSEN:	
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeChannelsConfirm\n");
				pduLogMergeChannelsConfirm(logfile,domain_pdu);
			}
			break;
		case PURGE_CHANNEL_INDICATION_CHOSEN:	
			{
				pduLog(logfile,"PDU_TYPE: MCS_PurgeChannelIndication\n");
				pduLogPurgeChannelIndication(logfile,domain_pdu);
			}
			break;
		case MERGE_TOKENS_REQUEST_CHOSEN:		
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeTokensRequest\n");
				pduLogMergeTokensRequest(logfile,domain_pdu);
			}
			break;
		case MERGE_TOKENS_CONFIRM_CHOSEN:		
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeTokensConfirm\n");
				pduLogMergeTokensConfirm(logfile,domain_pdu);
			}
			break;
		case PURGE_TOKEN_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_PurgeTokenIndication\n");
				pduLogPurgeTokenIndication(logfile,domain_pdu);
			}
			break;
		case DISCONNECT_PROVIDER_ULTIMATUM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_DisconnectProviderUltimatum\n");
				pduLogDisconnectProviderUltimatum(logfile,domain_pdu);
			}
			break;
		case REJECT_ULTIMATUM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_RejectUltimatum\n");
				pduLogRejectUltimatum(logfile,domain_pdu);
			}
			break;
		case ATTACH_USER_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_AttachUserRequest\n");
				pduLogAttachUserRequest(logfile,domain_pdu);
			}
			break;
		case ATTACH_USER_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_AttachUserConfirm\n");
				pduLogAttachUserConfirm(logfile,domain_pdu);
			}
			break;
		case DETACH_USER_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_DetachUserRequest\n");
				pduLogDetachUserRequest(logfile,domain_pdu);
			}
			break;
		case DETACH_USER_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_DetachUserIndication\n");
				pduLogDetachUserIndication(logfile,domain_pdu);
			}
			break;
		case CHANNEL_JOIN_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelJoinRequest\n");
				pduLogChannelJoinRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_JOIN_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelJoinConfirm\n");
				pduLogChannelJoinConfirm(logfile,domain_pdu);
			}
			break;
		case CHANNEL_LEAVE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelLeaveRequest\n");
				pduLogChannelLeaveRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_CONVENE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelConveneRequest\n");
				pduLogChannelConveneRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_CONVENE_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelConveneConfirm\n");
				pduLogChannelConveneConfirm(logfile,domain_pdu);
			}
			break;
		case CHANNEL_DISBAND_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelDisbandRequest\n");
				pduLogChannelDisbandRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_DISBAND_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelDisbandIndication\n");
				pduLogChannelDisbandIndication(logfile,domain_pdu);
			}
			break;
		case CHANNEL_ADMIT_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelAdmitRequest\n");
				pduLogChannelAdmitRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_ADMIT_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelAdmitIndication\n");
				pduLogChannelAdmitIndication(logfile,domain_pdu);
			}
			break;
		case CHANNEL_EXPEL_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelExpelRequest\n");
				pduLogChannelExpelRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_EXPEL_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelExpelIndication\n");
				pduLogChannelExpelIndication(logfile,domain_pdu);
			}
			break;
		case SEND_DATA_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_SendDataRequest\n");
				pduLogSendDataRequest(logfile,domain_pdu);
			}
			break;
		case SEND_DATA_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_SendDataIndication\n");
				pduLogSendDataIndication(logfile,domain_pdu);
			}
			break;
		case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_UniformSendDataRequest\n");
				pduLogUniformSendDataRequest(logfile,domain_pdu);
			}
			break;
		case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_UniformSendDataIndication\n");
				pduLogUniformSendDataIndication(logfile,domain_pdu);
			}
			break;
		case TOKEN_GRAB_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGrabRequest\n");
				pduLogTokenGrabRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_GRAB_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGrabConfirm\n");
				pduLogTokenGrabConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_INHIBIT_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenInhibitRequest\n");
				pduLogTokenInhibitRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_INHIBIT_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenInhibitConfirm\n");
				pduLogTokenInhibitConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveRequest\n");
				pduLogTokenGiveRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveIndication\n");
				pduLogTokenGiveIndication(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_RESPONSE_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveResponse\n");
				pduLogTokenGiveResponse(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveConfirm\n");
				pduLogTokenGiveConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_PLEASE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenPleaseRequest\n");
				pduLogTokenPleaseRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_PLEASE_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenPleaseIndication\n");
				pduLogTokenPleaseIndication(logfile,domain_pdu);
			}
			break;
		case TOKEN_RELEASE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenReleaseRequest\n");
				pduLogTokenReleaseRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_RELEASE_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenReleseConfirm\n");
				pduLogTokenReleaseConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_TEST_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenTestRequest\n");
				pduLogTokenTestRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_TEST_CONFIRM_CHOSEN:
            {
				pduLog(logfile,"PDU_TYPE: MCS_TokenTestConfirm\n");	   
				pduLogTokenTestConfirm(logfile,domain_pdu);
			}
            break;
        default: 
            {
                // write something, just so we know we got a PDU.
                pduLog(logfile,"ERROR: we got a MCS PDU, just don't know what it is");
			}
            break;
	}					
}



///////////////////////////////////////////////////////////////////////
// constant string returns
//////////////////////////////////////////////////////////////////////
/**************************************************************************/
void PrintPDUResult(FILE *logfile, unsigned int result)
{
	switch(result)
	{
	case RT_SUCCESSFUL:
		pduLog(logfile,"RT_SUCCESSFUL\n");	
		break;
	case RT_DOMAIN_MERGING:
		pduLog(logfile,"RT_DOMAIN_MERGING\n");
		break;
	case RT_DOMAIN_NOT_HIERARCHICAL:
		pduLog(logfile,"RT_DOMAIN_NOT_HIERARCHICAL\n");
		break;
	case RT_NO_SUCH_CHANNEL:
		pduLog(logfile,"RT_NO_SUCH_CHANNEL\n");
		break;
	case RT_NO_SUCH_DOMAIN:
		pduLog(logfile,"RT_NO_SUCH_DOMAIN\n");
		break;
	case RT_NO_SUCH_USER:	
		pduLog(logfile,"RT_NO_SUCH_USER\n");
		break;
	case RT_NOT_ADMITTED:
		pduLog(logfile,"RT_NOT_ADMITTED\n");
		break;
	case RT_OTHER_USER:
		pduLog(logfile,"RT_OTHER_USER\n");
		break;
	case RT_PARAMETERS_UNACCEPTABLE:
		pduLog(logfile,"RT_PARAMETERS_UNACCEPTABLE\n");
		break;
	case RT_TOKEN_NOT_AVAILABLE:
		pduLog(logfile,"RT_TOKEN_NOT_AVAILABLE\n");
		break;
	case RT_TOKEN_NOT_POSESSED:
		pduLog(logfile,"RT_TOKEN_NOT_POSESSED\n");
		break;
	case RT_TOO_MANY_CHANNELS:
		pduLog(logfile,"RT_TOO_MANY_CHANNELS\n");
		break;
	case RT_TOO_MANY_TOKENS:
		pduLog(logfile,"RT_TOO_MANY_TOKENS\n");
		break;
	case RT_TOO_MANY_USERS:		
		pduLog(logfile,"RT_TOO_MANY_USERS\n");
		break;
	case RT_UNSPECIFIED_FAILURE:
		pduLog(logfile,"RT_UNSPECIFIED_FAILURE\n");
		break;
	case RT_USER_REJECTED:
		pduLog(logfile,"RT_USER_REJECTED\n");
		break;
	default:
		pduLog(logfile,"ERROR: UNKOWN RETURN TYPE <<<\n");
		break;
	}
}

/**************************************************************************/
void PrintPDUPriority(FILE *logfile, unsigned int priority)
{
	switch(priority)
	{
	case TOP_PRI:	
		pduLog(logfile,TOP_STR);
		break;
	case HIGH_PRI:
		pduLog(logfile,HIGH_STR);
		break;
	case MEDIUM_PRI:
		pduLog(logfile,MEDIUM_STR);
		break;
	case LOW_PRI:
		pduLog(logfile,LOW_STR);
		break;
	default:
		pduLog(logfile," >>>> UNKNOWN PRIORITY <<<\n");
		break;
	}
}

/**************************************************************************/
void PrintPDUSegmentation(FILE *logfile, unsigned char segmentation)
{
	if(segmentation==0x80)
		pduLog(logfile,"\tSegmentation: Begin\n");
	else if (segmentation==0x40)
		pduLog(logfile,"\tSegmentation: End\n");
	else
		pduLog(logfile,"\tSegmentation: Unknown\n");
}

/**************************************************************************/
void PrintTokenStatus(FILE *logfile, unsigned int status)
{
	switch(status)
	{
	case 0:
		pduLog(logfile,"\ttoken_status = NOT_IN_USE\n");
		break;
	case 1:
		pduLog(logfile,"\ttoken_status = SELF_GRABBED\n");
		break;
	case 2:
		pduLog(logfile,"\ttoken_status = OTHER_GRABBED\n");
		break;
	case 3:
		pduLog(logfile,"\ttoken_status = SELF_INHIBITED\n");
		break;
	case 4:
		pduLog(logfile,"\ttoken_status = OTHER_INHIBITED\n");
		break;
	case 5:
		pduLog(logfile,"\ttoken_status = SELF_RECIPIENT\n");
		break;
	case 6: 
		pduLog(logfile,"\ttoken_status = SELF_GIVING\n");
		break;
	case 7: 
		pduLog(logfile,"\ttoken_status = OTHER_GIVING\n");
		break;
	default:
		pduLog(logfile,"\tERROR: unknown token status\n");
		break;
	}
}


/**************************************************************************/
void PrintPDUReason(FILE *logfile, unsigned int reason)
{
	pduLog(logfile,"\t\tReason:   ");
	switch(reason)
	{
	case 0:
		pduLog(logfile,"RN_DOMAIN_DISCONNECTED\n");
		break;
	case 1:
		pduLog(logfile,"RN_PROVIDER_INITIATED\n");
		break;
	case 2:
		pduLog(logfile,"RN_TOKEN_PURGED\n");
		break;
	case 3: 
		pduLog(logfile,"RN_USER_REQUESTED\n");
		break;
	case 4: 
		pduLog(logfile,"RN_CHANNEL_PURGED\n");
		break;
	}
}

/**************************************************************************/
void PrintDiagnostic(FILE *logfile, unsigned int diagnostic)
{
	pduLog(logfile,"\t\tDiagnostic:   ");
	switch(diagnostic)
	{
	case 0:
		pduLog(logfile,"dc_inconsistent_merge\n");
		break;
	case 1:
		pduLog(logfile,"dc_forbidden_pdu_downward\n");
		break;
	case 2:
		pduLog(logfile,"dc_forbidden_pdu_upward\n");
		break;
	case 3:
		pduLog(logfile,"dc_invalid_ber_encoding\n");
		break;
	case 4:
		pduLog(logfile,"dc_invalid_per_encoding\n");
		break;
	case 5:
		pduLog(logfile,"dc_misrouted_user\n");
		break;
	case 6:
		pduLog(logfile,"dc_unrequested_confirm\n");
		break;
	case 7:
		pduLog(logfile,"dc_wrong_transport_priority\n");
		break;
	case 8:
		pduLog(logfile,"dc_channel_id_conflict\n");
		break;
	case 9:
		pduLog(logfile,"dc_token_id_conflict\n");
		break;
	case 10:
		pduLog(logfile,"dc_not_user_id_channel\n");
		break;
	case 11:
		pduLog(logfile,"dc_too_many_channels\n");
		break;
	case 12:
		pduLog(logfile,"dc_too_many_tokens\n");
		break;
	case 13:
		pduLog(logfile,"dc_too_many_users\n");
		break;
	default:
		pduLog(logfile,"ERROR: unknown diagnostic\n");
		break;
	}
}



/*****
 ***** Logging functions for individual MCS PDU contents
 *****/
/**************************************************************************/
void pduLogConnectInitial(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile,"\tCalling Domain Selector:");
	PrintCharData(logfile,connect_pdu->u.connect_initial.calling_domain_selector.value,
						 connect_pdu->u.connect_initial.calling_domain_selector.length);
	pduLog(logfile,"\tCalled Domain Selector:");
	PrintCharData(logfile,connect_pdu->u.connect_initial.called_domain_selector.value,
						 connect_pdu->u.connect_initial.called_domain_selector.length);
	PrintT120Boolean(logfile,"\tupward_flag = ",
						 (BOOL) connect_pdu->u.connect_initial.upward_flag);
	pduLog(logfile,"\tTarget Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_initial.target_parameters);
	pduLog(logfile,"\tMinimum Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_initial.minimum_parameters);
	pduLog(logfile,"\tMaximum Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_initial.maximum_parameters);
	pduLog(logfile,"\tUser Data: \n");
	pduRawOutput(logfile,connect_pdu->u.connect_initial.user_data.value,
						 connect_pdu->u.connect_initial.user_data.length);

}

/**************************************************************************/
void pduLogConnectResponse(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile, "\tResult: ");
	PrintPDUResult(logfile, connect_pdu->u.connect_response.result);
	pduLog(logfile, "\tcalled_connect_id = %u \n",
			connect_pdu->u.connect_response.called_connect_id);
	pduLog(logfile, "\tDomain Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_response.domain_parameters);
	pduLog(logfile, "\tUser Data: \n");
	pduRawOutput(logfile,connect_pdu->u.connect_response.user_data.value,
						 connect_pdu->u.connect_response.user_data.length);
}

/**************************************************************************/
void pduLogConnectAdditional(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile, "\tcalled_connect_id = %u\n",
			connect_pdu->u.connect_additional.called_connect_id);
	pduLog(logfile, "Priority: \n");
	PrintPDUPriority(logfile, connect_pdu->u.connect_additional.data_priority);
}

/**************************************************************************/
void pduLogConnectResult(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile, "\tResult: ");
	PrintPDUResult(logfile, connect_pdu->u.connect_result.result);
}

/**************************************************************************/
void pduLogPlumbDomainIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile, "\theight_limit = %u\n",
			domain_pdu->u.plumb_domain_indication.height_limit);
}

/**************************************************************************/
void pduLogErectDomainRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile, "\tsub_height = %u\n",
			domain_pdu->u.erect_domain_request.sub_height);
	pduLog(logfile, "\tsub_interval = %u\n",
			domain_pdu->u.erect_domain_request.sub_interval);
}

/**************************************************************************/
void pduLogMergeChannelsRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	int i = 0;
	PSetOfPDUChannelAttributes  channel_attributes;
	PSetOfChannelIDs  channel_ids;

	channel_attributes = domain_pdu->u.merge_channels_request.merge_channels;
	channel_ids = domain_pdu->u.merge_channels_request.purge_channel_ids;

	pduLog(logfile, "  Merge Channels:\n");
	for(i=0; channel_attributes!=NULL; i++)
	{
		pduLog(logfile,"\t*** record [%u] ***\n",i);
		PrintChannelAttributes(logfile, channel_attributes->value);
		channel_attributes = channel_attributes->next;
	}
	pduLog(logfile, "  Purge Channel IDs:\n");
	for(i=0; channel_ids!=NULL; i++)
	{
		pduLog(logfile,"\t\trecord[%u] = %u\n",channel_ids->value);
		channel_ids = channel_ids->next;
	}
}

/**************************************************************************/
void pduLogMergeChannelsConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	unsigned int i = 0;
	PSetOfPDUChannelAttributes  channel_attributes;
	PSetOfChannelIDs  channel_ids;

	channel_attributes = domain_pdu->u.merge_channels_confirm.merge_channels;
	channel_ids = domain_pdu->u.merge_channels_confirm.purge_channel_ids;

	pduLog(logfile, "  Merge Channels:\n");
	for(i=0; channel_attributes!=NULL; i++)
	{
		pduLog(logfile,"\t*** record [%u] ***\n",i);
		PrintChannelAttributes(logfile, channel_attributes->value);
		channel_attributes = channel_attributes->next;
	}
	pduLog(logfile, "  Purge Channel IDs:\n");
	PrintSetOfChannelIDs(logfile,channel_ids);
}

/**************************************************************************/
void pduLogPurgeChannelIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfUserIDs	detach_user_ids;
	PSetOfChannelIDs	purge_channel_ids;

	detach_user_ids = domain_pdu->u.purge_channel_indication.detach_user_ids;
	purge_channel_ids = domain_pdu->u.purge_channel_indication.purge_channel_ids;

	pduLog(logfile, "  Detach User IDs: \n");
	PrintSetOfUserIDs(logfile, detach_user_ids);

	pduLog(logfile, "  Purge Channel IDs: \n");
	PrintSetOfChannelIDs(logfile, purge_channel_ids);
}

/**************************************************************************/
void pduLogMergeTokensRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfPDUTokenAttributes merge_tokens;
	PSetOfTokenIDs purge_token_ids;

	merge_tokens = domain_pdu->u.merge_tokens_request.merge_tokens;
	purge_token_ids = domain_pdu->u.merge_tokens_request.purge_token_ids;

	pduLog(logfile,"   Merge Tokens: \n");
	PrintSetOfTokenAttributes(logfile, merge_tokens);
	pduLog(logfile,"   Purge Token IDs: \n");
	PrintSetOfTokenIDs(logfile, purge_token_ids);
}

/**************************************************************************/
void pduLogMergeTokensConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfPDUTokenAttributes merge_tokens;
	PSetOfTokenIDs purge_token_ids;

	merge_tokens = domain_pdu->u.merge_tokens_request.merge_tokens;
	purge_token_ids = domain_pdu->u.merge_tokens_request.purge_token_ids;

	pduLog(logfile,"   Merge Tokens: \n");
	PrintSetOfTokenAttributes(logfile, merge_tokens);
	pduLog(logfile,"   Purge Token IDs: \n");
	PrintSetOfTokenIDs(logfile, purge_token_ids);
}

/**************************************************************************/
void pduLogPurgeTokenIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfTokenIDs purge_token_ids;

	purge_token_ids = domain_pdu->u.purge_token_indication.purge_token_ids;

	pduLog(logfile,"   Purge Token IDs: \n");
	PrintSetOfTokenIDs(logfile, purge_token_ids);
}

/**************************************************************************/
void pduLogDisconnectProviderUltimatum(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintPDUReason(logfile, domain_pdu->u.disconnect_provider_ultimatum.reason);
}

/**************************************************************************/           
void pduLogRejectUltimatum(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintDiagnostic(logfile, 
					domain_pdu->u.reject_user_ultimatum.diagnostic);
	pduLog(logfile,"\tInitial Octets: \n");
	pduRawOutput(logfile,
				 domain_pdu->u.reject_user_ultimatum.initial_octets.value,
				 domain_pdu->u.reject_user_ultimatum.initial_octets.length);
}

/**************************************************************************/
void pduLogAttachUserRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile, "placeholder = %c\n",
			domain_pdu->u.attach_user_request.placeholder);
}

/**************************************************************************/
void pduLogAttachUserConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.attach_user_confirm.result);
	pduLog(logfile,"\tinitiator = %u\n",
			domain_pdu->u.attach_user_confirm.initiator);
}

/**************************************************************************/
void pduLogDetachUserRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintPDUReason(logfile,domain_pdu->u.detach_user_request.reason);
	PrintSetOfUserIDs(logfile,
						domain_pdu->u.detach_user_request.user_ids);
}


/**************************************************************************/
void pduLogDetachUserIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintPDUReason(logfile,domain_pdu->u.detach_user_indication.reason);
	PrintSetOfUserIDs(logfile,
						domain_pdu->u.detach_user_indication.user_ids);
}

/**************************************************************************/
void pduLogChannelJoinRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\t\tuser_id = %u\n",
			domain_pdu->u.channel_join_request.initiator);
	pduLog(logfile,"\t\tchannel_id = %u\n",
			domain_pdu->u.channel_join_request.channel_id);
}

/**************************************************************************/
void pduLogChannelJoinConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult:  ");
	PrintPDUResult(logfile,domain_pdu->u.channel_join_confirm.result);
	pduLog(logfile,"\tinitiator userID = %u\n",
				domain_pdu->u.channel_join_confirm.initiator);
	pduLog(logfile,"\trequested channel ID = %u\n",
				domain_pdu->u.channel_join_confirm.requested);
	pduLog(logfile,"\tjoin channel ID = %u\n",
				domain_pdu->u.channel_join_confirm.join_channel_id);
}

/**************************************************************************/
void pduLogChannelLeaveRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tChannel IDs: \n");
	PrintSetOfChannelIDs(logfile, 
						 domain_pdu->u.channel_leave_request.channel_ids);
}

/**************************************************************************/
void pduLogChannelConveneRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator user ID = %u\n",
			domain_pdu->u.channel_convene_request.initiator);
}

/**************************************************************************/
void pduLogChannelConveneConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.channel_convene_confirm.result);
	pduLog(logfile,"\tInitiator user ID = %u\n",
			domain_pdu->u.channel_convene_confirm.initiator);
	pduLog(logfile,"\tPrivate channel ID = %u\n",
			domain_pdu->u.channel_convene_confirm.convene_channel_id);
}

/**************************************************************************/
void pduLogChannelDisbandRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_disband_request.initiator);
	pduLog(logfile,"\tPrivate channel ID = %u\n",
			domain_pdu->u.channel_disband_request.channel_id);
}

/**************************************************************************/
void pduLogChannelDisbandIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_disband_indication.channel_id);
}

/**************************************************************************/
void pduLogChannelAdmitRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_admit_request.initiator);
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_admit_request.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_admit_request.user_ids);
}

/**************************************************************************/
void pduLogChannelAdmitIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_admit_indication.initiator);
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_admit_indication.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_admit_indication.user_ids);
}

/**************************************************************************/
void pduLogChannelExpelRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_expel_request.initiator);
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_expel_request.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_expel_request.user_ids);
}

/**************************************************************************/
void pduLogChannelExpelIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_expel_indication.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_expel_indication.user_ids);
}

/**************************************************************************/
void pduLogSendDataRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.send_data_request.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.send_data_request.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.send_data_request.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.send_data_request.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.send_data_request.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.send_data_request.user_data.value,
			domain_pdu->u.send_data_request.user_data.length);
}

/**************************************************************************/
void pduLogSendDataIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.send_data_indication.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.send_data_indication.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.send_data_indication.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.send_data_indication.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.send_data_indication.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.send_data_indication.user_data.value,
			domain_pdu->u.send_data_indication.user_data.length);
}

/**************************************************************************/
void pduLogUniformSendDataRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.uniform_send_data_request.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.uniform_send_data_request.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.uniform_send_data_request.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.uniform_send_data_request.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.uniform_send_data_request.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.uniform_send_data_request.user_data.value,
			domain_pdu->u.uniform_send_data_request.user_data.length);
}

/**************************************************************************/
void pduLogUniformSendDataIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.uniform_send_data_indication.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.uniform_send_data_indication.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.uniform_send_data_indication.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.uniform_send_data_indication.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.uniform_send_data_indication.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.uniform_send_data_indication.user_data.value,
			domain_pdu->u.uniform_send_data_indication.user_data.length);
}

/**************************************************************************/
void pduLogTokenGrabRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_grab_request.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_grab_request.token_id);
}

/**************************************************************************/
void pduLogTokenGrabConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_grab_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_grab_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_grab_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_grab_confirm.token_status);
}

/**************************************************************************/
void pduLogTokenInhibitRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_inhibit_request.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_inhibit_request.token_id);
}

/**************************************************************************/
void pduLogTokenInhibitConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_inhibit_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_inhibit_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_inhibit_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_inhibit_confirm.token_status);
}

/**************************************************************************/
void pduLogTokenGiveRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_give_request.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_request.token_id);
	pduLog(logfile,"\tRecipient User ID = %u\n",
			domain_pdu->u.token_give_request.recipient);
}

/**************************************************************************/
void pduLogTokenGiveIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_give_indication.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_indication.token_id);
	pduLog(logfile,"\tRecipient User ID = %u\n",
			domain_pdu->u.token_give_indication.recipient);
}

/**************************************************************************/
void pduLogTokenGiveResponse(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_give_response.result);
	pduLog(logfile,"\tRecipient User ID = %u\n",
			domain_pdu->u.token_give_response.recipient);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_response.token_id);
}	

/**************************************************************************/
void pduLogTokenGiveConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_give_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_give_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_give_confirm.token_status);
}	

/**************************************************************************/
void pduLogTokenPleaseRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_please_request.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_please_request.token_id);
}

/**************************************************************************/
void pduLogTokenPleaseIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_please_indication.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_please_indication.token_id);
}

/**************************************************************************/
void pduLogTokenReleaseRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_release_request.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_release_request.token_id);
}

/**************************************************************************/
void pduLogTokenReleaseConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_release_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_release_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_release_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_release_confirm.token_status);
}

/**************************************************************************/
void pduLogTokenTestRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_test_request.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_test_request.token_id);
}

/**************************************************************************/
void pduLogTokenTestConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_test_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_test_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_test_confirm.token_status);
}	


//****************************************************************/
/****
 **** Service Functions for logging PDU structures.
 ****/

/**************************************************************************/
void PrintSetOfUserIDs(FILE *logfile, PSetOfUserIDs user_ids)
{
	unsigned int i = 0;
	for(i=0; user_ids!=NULL; i++)
	{
		pduLog(logfile, "\t\trecord[%u] = %u\n",i,user_ids->value);
		user_ids = user_ids->next;
	}
}

/**************************************************************************/
void PrintSetOfTokenAttributes(FILE *logfile, 
							   PSetOfPDUTokenAttributes token_attribute_obj)
{
	unsigned int i = 0;
	for(i=0; token_attribute_obj!=NULL;i++)
	{
		pduLog(logfile,"\t**** record [%u] ****\n",i);
		PrintTokenAttributes(logfile, token_attribute_obj->value);
		token_attribute_obj = token_attribute_obj->next;
	}
}

/**************************************************************************/
void PrintSetOfChannelIDs(FILE *logfile, PSetOfChannelIDs channel_ids)
{
	unsigned int i = 0;
	for(i=0; channel_ids!=NULL; i++)
	{
		pduLog(logfile, "\t\trecord[%u] = %u\n",i,channel_ids->value);
		channel_ids = channel_ids->next;
	}
}

/**************************************************************************/
void PrintSetOfTokenIDs(FILE *logfile, PSetOfTokenIDs token_ids)
{
	unsigned int i = 0;
	for(i=0; token_ids!=NULL; i++)
	{
		pduLog(logfile, "\t\trecord[%u] = %u\n",i,token_ids->value);
		token_ids = token_ids->next;
	}
}

/**************************************************************************/
void PrintChannelAttributes(FILE *logfile, PDUChannelAttributes channel_attributes)
{
	switch(channel_attributes.choice)
	{
	case CHANNEL_ATTRIBUTES_STATIC_CHOSEN:
		pduLog(logfile, "\tStatic Channel Attributes:\n");
		pduLog(logfile, "\t\tchannel_id = %u\n",
					channel_attributes.u.channel_attributes_static.channel_id);
		break;
	case CHANNEL_ATTRIBUTES_USER_ID_CHOSEN: 
		pduLog(logfile, "\tUser ID Channel Attributes:\n");
		PrintT120Boolean(logfile, "\t\tjoined",
							(BOOL) channel_attributes.u.channel_attributes_user_id.joined);
		pduLog(logfile, "\t\tuser_id = %u\n",
							channel_attributes.u.channel_attributes_user_id.user_id);
		break;
	case CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN:
		pduLog(logfile,"\tPrivate Channel Attributes:\n");
		PrintT120Boolean(logfile, "\t\tjoined",
							(BOOL) channel_attributes.u.channel_attributes_private.joined);
		pduLog(logfile,"\t\tchannel_id = %u\n",
							channel_attributes.u.channel_attributes_private.channel_id);
		pduLog(logfile,"\t\tmanager = %u\n",
							channel_attributes.u.channel_attributes_private.manager);
		PrintSetOfUserIDs(logfile, channel_attributes.u.channel_attributes_private.admitted);
		break;
	case CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN:
		pduLog(logfile,"\tAssigned Channel Attributes\n");
		pduLog(logfile,"\t\tchannel_id = %u\n",
						channel_attributes.u.channel_attributes_assigned.channel_id);
		break;
	default:
		pduLog(logfile,"\tERROR -- canot figure out channel attributes\n");
		break;
	}
}

/**************************************************************************/
void PrintTokenAttributes(FILE *logfile, PDUTokenAttributes token_attributes)
{
	switch(token_attributes.choice)
	{
	case GRABBED_CHOSEN:
		pduLog(logfile,"\tGrabbed Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.grabbed.token_id);
		pduLog(logfile,"\t\tgrabber = %u\n",
				token_attributes.u.grabbed.grabber);
		break;
	case INHIBITED_CHOSEN:
		pduLog(logfile,"\tInhibited Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.inhibited.token_id);
		pduLog(logfile,"\t\tInhibitors:\n");
		PrintSetOfUserIDs(logfile,token_attributes.u.inhibited.inhibitors);
		break;
	case GIVING_CHOSEN:
		pduLog(logfile,"\tGiving Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.giving.token_id);
		pduLog(logfile,"\t\tgrabber = %u\n",
				token_attributes.u.giving.grabber);
		pduLog(logfile,"\t\trecipient = %u\n",
				token_attributes.u.giving.recipient);
		break;
	case UNGIVABLE_CHOSEN:
		pduLog(logfile,"\tUngivable Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.ungivable.token_id);
		pduLog(logfile,"\t\tgrabber = %u\n",
				token_attributes.u.ungivable.grabber);
		break;
	case GIVEN_CHOSEN:
		pduLog(logfile,"\tGiven Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.given.token_id);
		pduLog(logfile,"\t\trecipient = %u\n",
				token_attributes.u.given.recipient);
		break;
	default:
		pduLog(logfile,"ERROR: cannot determine token attributes\n");
		break;
	}
}

/**************************************************************************/
void PrintPDUDomainParameters(FILE *logfile, PDUDomainParameters domain_params)
{
	pduLog(logfile,"\t\tmax_channel_ids = %u \n",domain_params.max_channel_ids);
	pduLog(logfile,"\t\tmax_user_ids = %u\n",domain_params.max_user_ids);
	pduLog(logfile,"\t\tmax_token_ids = %u\n",domain_params.max_token_ids);
	pduLog(logfile,"\t\tnumber_priorities = %u\n",domain_params.number_priorities);
	pduLog(logfile,"\t\tmin_throughput = %u\n",domain_params.min_throughput);
	pduLog(logfile,"\t\tmax_height = %u\n",domain_params.max_height);
	pduLog(logfile,"\t\tmax_mcspdu_size = %u\n",domain_params.max_mcspdu_size);
	pduLog(logfile,"\t\tprotocol_version = %u\n",domain_params.protocol_version);
}

/**************************************************************************/
void PrintT120Boolean(	FILE *	logfile,
						Char *	print_text,
						BOOL	T120Boolean)
{
	if( T120Boolean == FALSE )
		pduLog(	logfile, "%s = FALSE\n", print_text );
	else
		pduLog(	logfile, "%s = TRUE\n", print_text );
}

/************************************************************************/
BOOL CopyTextToChar(char * print_string,
					       unsigned short * text_string_value,
						   unsigned int text_string_length)
{
	UShort  i;
	
	if(print_string==NULL)
		return(FALSE);

	if((text_string_length <= 0)||(text_string_value == NULL))
		return( FALSE );

	if (*text_string_value == 0x0000)
		return (FALSE);

	for(i=0;i < text_string_length;i++)
	{
		//if((&text_string_value[i]==NULL) || (text_string_value[i]==0x0000))
		//	break;
		print_string[i] = (char) text_string_value[i];
	
	}
	print_string[text_string_length] = '\0';
	
	return(TRUE);
}
/********************************************************************/


#endif //// PDULOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\mcspdu.c ===
#include <windows.h>
#include "mcspdu.h"

ASN1module_t MCSPDU_Module = NULL;

static int ASN1CALL ASN1Enc_Given(ASN1encoding_t enc, Given *val);
static int ASN1CALL ASN1Enc_Ungivable(ASN1encoding_t enc, Ungivable *val);
static int ASN1CALL ASN1Enc_Giving(ASN1encoding_t enc, Giving *val);
static int ASN1CALL ASN1Enc_Inhibited(ASN1encoding_t enc, Inhibited *val);
static int ASN1CALL ASN1Enc_Grabbed(ASN1encoding_t enc, Grabbed *val);
static int ASN1CALL ASN1Enc_ChannelAttributesAssigned(ASN1encoding_t enc, ChannelAttributesAssigned *val);
static int ASN1CALL ASN1Enc_ChannelAttributesPrivate(ASN1encoding_t enc, ChannelAttributesPrivate *val);
static int ASN1CALL ASN1Enc_ChannelAttributesUserID(ASN1encoding_t enc, ChannelAttributesUserID *val);
static int ASN1CALL ASN1Enc_ChannelAttributesStatic(ASN1encoding_t enc, ChannelAttributesStatic *val);
extern int ASN1CALL ASN1Enc_PDUDomainParameters(ASN1encoding_t enc, PDUDomainParameters *val);
extern int ASN1CALL ASN1Enc_ConnectInitialPDU(ASN1encoding_t enc, ConnectInitialPDU *val);
extern int ASN1CALL ASN1Enc_ConnectResponsePDU(ASN1encoding_t enc, ConnectResponsePDU *val);
extern int ASN1CALL ASN1Enc_ConnectAdditionalPDU(ASN1encoding_t enc, ConnectAdditionalPDU *val);
extern int ASN1CALL ASN1Enc_ConnectResultPDU(ASN1encoding_t enc, ConnectResultPDU *val);
static int ASN1CALL ASN1Enc_PlumbDomainIndicationPDU(ASN1encoding_t enc, PlumbDomainIndicationPDU *val);
static int ASN1CALL ASN1Enc_ErectDomainRequestPDU(ASN1encoding_t enc, ErectDomainRequestPDU *val);
static int ASN1CALL ASN1Enc_PDUChannelAttributes(ASN1encoding_t enc, PDUChannelAttributes *val);
static int ASN1CALL ASN1Enc_MergeChannelsRequestPDU(ASN1encoding_t enc, MergeChannelsRequestPDU *val);
static int ASN1CALL ASN1Enc_MergeChannelsConfirmPDU(ASN1encoding_t enc, MergeChannelsConfirmPDU *val);
static int ASN1CALL ASN1Enc_PurgeChannelIndicationPDU(ASN1encoding_t enc, PurgeChannelIndicationPDU *val);
static int ASN1CALL ASN1Enc_PDUTokenAttributes(ASN1encoding_t enc, PDUTokenAttributes *val);
static int ASN1CALL ASN1Enc_SetOfUserIDs(ASN1encoding_t enc, PSetOfUserIDs *val);
static int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes(ASN1encoding_t enc, PSetOfPDUChannelAttributes *val);
static int ASN1CALL ASN1Enc_SetOfChannelIDs(ASN1encoding_t enc, PSetOfChannelIDs *val);
static int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes(ASN1encoding_t enc, PSetOfPDUTokenAttributes *val);
static int ASN1CALL ASN1Enc_SetOfTokenIDs(ASN1encoding_t enc, PSetOfTokenIDs *val);
static int ASN1CALL ASN1Enc_MergeTokensRequestPDU(ASN1encoding_t enc, MergeTokensRequestPDU *val);
static int ASN1CALL ASN1Enc_MergeTokensConfirmPDU(ASN1encoding_t enc, MergeTokensConfirmPDU *val);
static int ASN1CALL ASN1Enc_PurgeTokenIndicationPDU(ASN1encoding_t enc, PurgeTokenIndicationPDU *val);
static int ASN1CALL ASN1Enc_DisconnectProviderUltimatumPDU(ASN1encoding_t enc, DisconnectProviderUltimatumPDU *val);
static int ASN1CALL ASN1Enc_RejectUltimatumPDU(ASN1encoding_t enc, RejectUltimatumPDU *val);
static int ASN1CALL ASN1Enc_AttachUserConfirmPDU(ASN1encoding_t enc, AttachUserConfirmPDU *val);
static int ASN1CALL ASN1Enc_DetachUserRequestPDU(ASN1encoding_t enc, DetachUserRequestPDU *val);
static int ASN1CALL ASN1Enc_DetachUserIndicationPDU(ASN1encoding_t enc, DetachUserIndicationPDU *val);
static int ASN1CALL ASN1Enc_ChannelJoinRequestPDU(ASN1encoding_t enc, ChannelJoinRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelJoinConfirmPDU(ASN1encoding_t enc, ChannelJoinConfirmPDU *val);
static int ASN1CALL ASN1Enc_ChannelLeaveRequestPDU(ASN1encoding_t enc, ChannelLeaveRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelConveneRequestPDU(ASN1encoding_t enc, ChannelConveneRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelConveneConfirmPDU(ASN1encoding_t enc, ChannelConveneConfirmPDU *val);
static int ASN1CALL ASN1Enc_ChannelDisbandRequestPDU(ASN1encoding_t enc, ChannelDisbandRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelDisbandIndicationPDU(ASN1encoding_t enc, ChannelDisbandIndicationPDU *val);
static int ASN1CALL ASN1Enc_ChannelAdmitRequestPDU(ASN1encoding_t enc, ChannelAdmitRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelAdmitIndicationPDU(ASN1encoding_t enc, ChannelAdmitIndicationPDU *val);
static int ASN1CALL ASN1Enc_ChannelExpelRequestPDU(ASN1encoding_t enc, ChannelExpelRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelExpelIndicationPDU(ASN1encoding_t enc, ChannelExpelIndicationPDU *val);
static int ASN1CALL ASN1Enc_TokenGrabRequestPDU(ASN1encoding_t enc, TokenGrabRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenGrabConfirmPDU(ASN1encoding_t enc, TokenGrabConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenInhibitRequestPDU(ASN1encoding_t enc, TokenInhibitRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenInhibitConfirmPDU(ASN1encoding_t enc, TokenInhibitConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenGiveRequestPDU(ASN1encoding_t enc, TokenGiveRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenGiveIndicationPDU(ASN1encoding_t enc, TokenGiveIndicationPDU *val);
static int ASN1CALL ASN1Enc_TokenGiveResponsePDU(ASN1encoding_t enc, TokenGiveResponsePDU *val);
static int ASN1CALL ASN1Enc_TokenGiveConfirmPDU(ASN1encoding_t enc, TokenGiveConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenPleaseRequestPDU(ASN1encoding_t enc, TokenPleaseRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenPleaseIndicationPDU(ASN1encoding_t enc, TokenPleaseIndicationPDU *val);
static int ASN1CALL ASN1Enc_TokenReleaseRequestPDU(ASN1encoding_t enc, TokenReleaseRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenReleaseConfirmPDU(ASN1encoding_t enc, TokenReleaseConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenTestRequestPDU(ASN1encoding_t enc, TokenTestRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenTestConfirmPDU(ASN1encoding_t enc, TokenTestConfirmPDU *val);
extern int ASN1CALL ASN1Enc_ConnectMCSPDU(ASN1encoding_t enc, ConnectMCSPDU *val);
static int ASN1CALL ASN1Enc_DomainMCSPDU(ASN1encoding_t enc, DomainMCSPDU *val);
static int ASN1CALL ASN1Dec_Given(ASN1decoding_t dec, Given *val);
static int ASN1CALL ASN1Dec_Ungivable(ASN1decoding_t dec, Ungivable *val);
static int ASN1CALL ASN1Dec_Giving(ASN1decoding_t dec, Giving *val);
static int ASN1CALL ASN1Dec_Inhibited(ASN1decoding_t dec, Inhibited *val);
static int ASN1CALL ASN1Dec_Grabbed(ASN1decoding_t dec, Grabbed *val);
static int ASN1CALL ASN1Dec_ChannelAttributesAssigned(ASN1decoding_t dec, ChannelAttributesAssigned *val);
static int ASN1CALL ASN1Dec_ChannelAttributesPrivate(ASN1decoding_t dec, ChannelAttributesPrivate *val);
static int ASN1CALL ASN1Dec_ChannelAttributesUserID(ASN1decoding_t dec, ChannelAttributesUserID *val);
static int ASN1CALL ASN1Dec_ChannelAttributesStatic(ASN1decoding_t dec, ChannelAttributesStatic *val);
extern int ASN1CALL ASN1Dec_PDUDomainParameters(ASN1decoding_t dec, PDUDomainParameters *val);
extern int ASN1CALL ASN1Dec_ConnectInitialPDU(ASN1decoding_t dec, ConnectInitialPDU *val);
extern int ASN1CALL ASN1Dec_ConnectResponsePDU(ASN1decoding_t dec, ConnectResponsePDU *val);
extern int ASN1CALL ASN1Dec_ConnectAdditionalPDU(ASN1decoding_t dec, ConnectAdditionalPDU *val);
extern int ASN1CALL ASN1Dec_ConnectResultPDU(ASN1decoding_t dec, ConnectResultPDU *val);
static int ASN1CALL ASN1Dec_PlumbDomainIndicationPDU(ASN1decoding_t dec, PlumbDomainIndicationPDU *val);
static int ASN1CALL ASN1Dec_ErectDomainRequestPDU(ASN1decoding_t dec, ErectDomainRequestPDU *val);
static int ASN1CALL ASN1Dec_PDUChannelAttributes(ASN1decoding_t dec, PDUChannelAttributes *val);
static int ASN1CALL ASN1Dec_MergeChannelsRequestPDU(ASN1decoding_t dec, MergeChannelsRequestPDU *val);
static int ASN1CALL ASN1Dec_MergeChannelsConfirmPDU(ASN1decoding_t dec, MergeChannelsConfirmPDU *val);
static int ASN1CALL ASN1Dec_PurgeChannelIndicationPDU(ASN1decoding_t dec, PurgeChannelIndicationPDU *val);
static int ASN1CALL ASN1Dec_PDUTokenAttributes(ASN1decoding_t dec, PDUTokenAttributes *val);
static int ASN1CALL ASN1Dec_SetOfUserIDs(ASN1decoding_t dec, PSetOfUserIDs *val);
static int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes(ASN1decoding_t dec, PSetOfPDUChannelAttributes *val);
static int ASN1CALL ASN1Dec_SetOfChannelIDs(ASN1decoding_t dec, PSetOfChannelIDs *val);
static int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes(ASN1decoding_t dec, PSetOfPDUTokenAttributes *val);
static int ASN1CALL ASN1Dec_SetOfTokenIDs(ASN1decoding_t dec, PSetOfTokenIDs *val);
static int ASN1CALL ASN1Dec_MergeTokensRequestPDU(ASN1decoding_t dec, MergeTokensRequestPDU *val);
static int ASN1CALL ASN1Dec_MergeTokensConfirmPDU(ASN1decoding_t dec, MergeTokensConfirmPDU *val);
static int ASN1CALL ASN1Dec_PurgeTokenIndicationPDU(ASN1decoding_t dec, PurgeTokenIndicationPDU *val);
static int ASN1CALL ASN1Dec_DisconnectProviderUltimatumPDU(ASN1decoding_t dec, DisconnectProviderUltimatumPDU *val);
static int ASN1CALL ASN1Dec_RejectUltimatumPDU(ASN1decoding_t dec, RejectUltimatumPDU *val);
static int ASN1CALL ASN1Dec_AttachUserConfirmPDU(ASN1decoding_t dec, AttachUserConfirmPDU *val);
static int ASN1CALL ASN1Dec_DetachUserRequestPDU(ASN1decoding_t dec, DetachUserRequestPDU *val);
static int ASN1CALL ASN1Dec_DetachUserIndicationPDU(ASN1decoding_t dec, DetachUserIndicationPDU *val);
static int ASN1CALL ASN1Dec_ChannelJoinRequestPDU(ASN1decoding_t dec, ChannelJoinRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelJoinConfirmPDU(ASN1decoding_t dec, ChannelJoinConfirmPDU *val);
static int ASN1CALL ASN1Dec_ChannelLeaveRequestPDU(ASN1decoding_t dec, ChannelLeaveRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelConveneRequestPDU(ASN1decoding_t dec, ChannelConveneRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelConveneConfirmPDU(ASN1decoding_t dec, ChannelConveneConfirmPDU *val);
static int ASN1CALL ASN1Dec_ChannelDisbandRequestPDU(ASN1decoding_t dec, ChannelDisbandRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelDisbandIndicationPDU(ASN1decoding_t dec, ChannelDisbandIndicationPDU *val);
static int ASN1CALL ASN1Dec_ChannelAdmitRequestPDU(ASN1decoding_t dec, ChannelAdmitRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelAdmitIndicationPDU(ASN1decoding_t dec, ChannelAdmitIndicationPDU *val);
static int ASN1CALL ASN1Dec_ChannelExpelRequestPDU(ASN1decoding_t dec, ChannelExpelRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelExpelIndicationPDU(ASN1decoding_t dec, ChannelExpelIndicationPDU *val);
static int ASN1CALL ASN1Dec_TokenGrabRequestPDU(ASN1decoding_t dec, TokenGrabRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenGrabConfirmPDU(ASN1decoding_t dec, TokenGrabConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenInhibitRequestPDU(ASN1decoding_t dec, TokenInhibitRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenInhibitConfirmPDU(ASN1decoding_t dec, TokenInhibitConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenGiveRequestPDU(ASN1decoding_t dec, TokenGiveRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenGiveIndicationPDU(ASN1decoding_t dec, TokenGiveIndicationPDU *val);
static int ASN1CALL ASN1Dec_TokenGiveResponsePDU(ASN1decoding_t dec, TokenGiveResponsePDU *val);
static int ASN1CALL ASN1Dec_TokenGiveConfirmPDU(ASN1decoding_t dec, TokenGiveConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenPleaseRequestPDU(ASN1decoding_t dec, TokenPleaseRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenPleaseIndicationPDU(ASN1decoding_t dec, TokenPleaseIndicationPDU *val);
static int ASN1CALL ASN1Dec_TokenReleaseRequestPDU(ASN1decoding_t dec, TokenReleaseRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenReleaseConfirmPDU(ASN1decoding_t dec, TokenReleaseConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenTestRequestPDU(ASN1decoding_t dec, TokenTestRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenTestConfirmPDU(ASN1decoding_t dec, TokenTestConfirmPDU *val);
extern int ASN1CALL ASN1Dec_ConnectMCSPDU(ASN1decoding_t dec, ConnectMCSPDU *val);
static int ASN1CALL ASN1Dec_DomainMCSPDU(ASN1decoding_t dec, DomainMCSPDU *val);
static void ASN1CALL ASN1Free_Inhibited(Inhibited *val);
static void ASN1CALL ASN1Free_ChannelAttributesPrivate(ChannelAttributesPrivate *val);
static void ASN1CALL ASN1Free_ConnectInitialPDU(ConnectInitialPDU *val);
static void ASN1CALL ASN1Free_ConnectResponsePDU(ConnectResponsePDU *val);
static void ASN1CALL ASN1Free_PDUChannelAttributes(PDUChannelAttributes *val);
static void ASN1CALL ASN1Free_MergeChannelsRequestPDU(MergeChannelsRequestPDU *val);
static void ASN1CALL ASN1Free_MergeChannelsConfirmPDU(MergeChannelsConfirmPDU *val);
static void ASN1CALL ASN1Free_PurgeChannelIndicationPDU(PurgeChannelIndicationPDU *val);
static void ASN1CALL ASN1Free_PDUTokenAttributes(PDUTokenAttributes *val);
static void ASN1CALL ASN1Free_SetOfUserIDs(PSetOfUserIDs *val);
static void ASN1CALL ASN1Free_SetOfPDUChannelAttributes(PSetOfPDUChannelAttributes *val);
static void ASN1CALL ASN1Free_SetOfChannelIDs(PSetOfChannelIDs *val);
static void ASN1CALL ASN1Free_SetOfPDUTokenAttributes(PSetOfPDUTokenAttributes *val);
static void ASN1CALL ASN1Free_SetOfTokenIDs(PSetOfTokenIDs *val);
static void ASN1CALL ASN1Free_MergeTokensRequestPDU(MergeTokensRequestPDU *val);
static void ASN1CALL ASN1Free_MergeTokensConfirmPDU(MergeTokensConfirmPDU *val);
static void ASN1CALL ASN1Free_PurgeTokenIndicationPDU(PurgeTokenIndicationPDU *val);
static void ASN1CALL ASN1Free_RejectUltimatumPDU(RejectUltimatumPDU *val);
static void ASN1CALL ASN1Free_DetachUserRequestPDU(DetachUserRequestPDU *val);
static void ASN1CALL ASN1Free_DetachUserIndicationPDU(DetachUserIndicationPDU *val);
static void ASN1CALL ASN1Free_ChannelLeaveRequestPDU(ChannelLeaveRequestPDU *val);
static void ASN1CALL ASN1Free_ChannelAdmitRequestPDU(ChannelAdmitRequestPDU *val);
static void ASN1CALL ASN1Free_ChannelAdmitIndicationPDU(ChannelAdmitIndicationPDU *val);
static void ASN1CALL ASN1Free_ChannelExpelRequestPDU(ChannelExpelRequestPDU *val);
static void ASN1CALL ASN1Free_ChannelExpelIndicationPDU(ChannelExpelIndicationPDU *val);
static void ASN1CALL ASN1Free_ConnectMCSPDU(ConnectMCSPDU *val);
static void ASN1CALL ASN1Free_DomainMCSPDU(DomainMCSPDU *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_ConnectMCSPDU,
    (ASN1EncFun_t) ASN1Enc_DomainMCSPDU,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_ConnectMCSPDU,
    (ASN1DecFun_t) ASN1Dec_DomainMCSPDU,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_ConnectMCSPDU,
    (ASN1FreeFun_t) ASN1Free_DomainMCSPDU,
};
static const ULONG sizetab[2] = {
    SIZE_MCSPDU_Module_PDU_0,
    SIZE_MCSPDU_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
void ASN1CALL MCSPDU_Module_Startup(void)
{
    MCSPDU_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x73636d);
}
void ASN1CALL MCSPDU_Module_Cleanup(void)
{
    ASN1_CloseModule(MCSPDU_Module);
    MCSPDU_Module = NULL;
}

static int ASN1CALL ASN1Enc_Given(ASN1encoding_t enc, Given *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Given(ASN1decoding_t dec, Given *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_Ungivable(ASN1encoding_t enc, Ungivable *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->grabber - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Ungivable(ASN1decoding_t dec, Ungivable *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->grabber))
	return 0;
    (val)->grabber += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_Giving(ASN1encoding_t enc, Giving *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->grabber - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Giving(ASN1decoding_t dec, Giving *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->grabber))
	return 0;
    (val)->grabber += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_Inhibited(ASN1encoding_t enc, Inhibited *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->inhibitors))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Inhibited(ASN1decoding_t dec, Inhibited *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->inhibitors))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Inhibited(Inhibited *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->inhibitors);
    }
}

static int ASN1CALL ASN1Enc_Grabbed(ASN1encoding_t enc, Grabbed *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->grabber - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Grabbed(ASN1decoding_t dec, Grabbed *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->grabber))
	return 0;
    (val)->grabber += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAttributesAssigned(ASN1encoding_t enc, ChannelAttributesAssigned *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesAssigned(ASN1decoding_t dec, ChannelAttributesAssigned *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAttributesPrivate(ASN1encoding_t enc, ChannelAttributesPrivate *val)
{
    if (!ASN1PEREncBoolean(enc, (val)->joined))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manager - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->admitted))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesPrivate(ASN1decoding_t dec, ChannelAttributesPrivate *val)
{
    if (!ASN1PERDecBoolean(dec, &(val)->joined))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manager))
	return 0;
    (val)->manager += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->admitted))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelAttributesPrivate(ChannelAttributesPrivate *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->admitted);
    }
}

static int ASN1CALL ASN1Enc_ChannelAttributesUserID(ASN1encoding_t enc, ChannelAttributesUserID *val)
{
    if (!ASN1PEREncBoolean(enc, (val)->joined))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->user_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesUserID(ASN1decoding_t dec, ChannelAttributesUserID *val)
{
    if (!ASN1PERDecBoolean(dec, &(val)->joined))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->user_id))
	return 0;
    (val)->user_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAttributesStatic(ASN1encoding_t enc, ChannelAttributesStatic *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesStatic(ASN1decoding_t dec, ChannelAttributesStatic *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectInitialPDU(ConnectInitialPDU *val)
{
    if (val) {
        ASN1octetstring_free(&(val)->calling_domain_selector);
        ASN1octetstring_free(&(val)->called_domain_selector);
        ASN1octetstring_free(&(val)->user_data);
    }
}

static void ASN1CALL ASN1Free_ConnectResponsePDU(ConnectResponsePDU *val)
{
    if (val) {
        ASN1octetstring_free(&(val)->user_data);
    }
}

static int ASN1CALL ASN1Enc_PlumbDomainIndicationPDU(ASN1encoding_t enc, PlumbDomainIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedInteger(enc, (val)->height_limit))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PlumbDomainIndicationPDU(ASN1decoding_t dec, PlumbDomainIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedInteger(dec, &(val)->height_limit))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ErectDomainRequestPDU(ASN1encoding_t enc, ErectDomainRequestPDU *val)
{
    if (!ASN1PEREncUnsignedInteger(enc, (val)->sub_height))
	return 0;
    if (!ASN1PEREncUnsignedInteger(enc, (val)->sub_interval))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ErectDomainRequestPDU(ASN1decoding_t dec, ErectDomainRequestPDU *val)
{
    if (!ASN1PERDecUnsignedInteger(dec, &(val)->sub_height))
	return 0;
    if (!ASN1PERDecUnsignedInteger(dec, &(val)->sub_interval))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_PDUChannelAttributes(ASN1encoding_t enc, PDUChannelAttributes *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ChannelAttributesStatic(enc, &(val)->u.channel_attributes_static))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ChannelAttributesUserID(enc, &(val)->u.channel_attributes_user_id))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ChannelAttributesPrivate(enc, &(val)->u.channel_attributes_private))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ChannelAttributesAssigned(enc, &(val)->u.channel_attributes_assigned))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PDUChannelAttributes(ASN1decoding_t dec, PDUChannelAttributes *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ChannelAttributesStatic(dec, &(val)->u.channel_attributes_static))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ChannelAttributesUserID(dec, &(val)->u.channel_attributes_user_id))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ChannelAttributesPrivate(dec, &(val)->u.channel_attributes_private))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ChannelAttributesAssigned(dec, &(val)->u.channel_attributes_assigned))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PDUChannelAttributes(PDUChannelAttributes *val)
{
    if (val) {
        switch ((val)->choice) {
        case 3:
            ASN1Free_ChannelAttributesPrivate(&(val)->u.channel_attributes_private);
            break;
        }
    }
}

static int ASN1CALL ASN1Enc_MergeChannelsRequestPDU(ASN1encoding_t enc, MergeChannelsRequestPDU *val)
{
    if (!ASN1Enc_SetOfPDUChannelAttributes(enc, &(val)->merge_channels))
	return 0;
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeChannelsRequestPDU(ASN1decoding_t dec, MergeChannelsRequestPDU *val)
{
    if (!ASN1Dec_SetOfPDUChannelAttributes(dec, &(val)->merge_channels))
	return 0;
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeChannelsRequestPDU(MergeChannelsRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUChannelAttributes(&(val)->merge_channels);
        ASN1Free_SetOfChannelIDs(&(val)->purge_channel_ids);
    }
}

static int ASN1CALL ASN1Enc_MergeChannelsConfirmPDU(ASN1encoding_t enc, MergeChannelsConfirmPDU *val)
{
    if (!ASN1Enc_SetOfPDUChannelAttributes(enc, &(val)->merge_channels))
	return 0;
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeChannelsConfirmPDU(ASN1decoding_t dec, MergeChannelsConfirmPDU *val)
{
    if (!ASN1Dec_SetOfPDUChannelAttributes(dec, &(val)->merge_channels))
	return 0;
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeChannelsConfirmPDU(MergeChannelsConfirmPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUChannelAttributes(&(val)->merge_channels);
        ASN1Free_SetOfChannelIDs(&(val)->purge_channel_ids);
    }
}

static int ASN1CALL ASN1Enc_PurgeChannelIndicationPDU(ASN1encoding_t enc, PurgeChannelIndicationPDU *val)
{
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->detach_user_ids))
	return 0;
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PurgeChannelIndicationPDU(ASN1decoding_t dec, PurgeChannelIndicationPDU *val)
{
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->detach_user_ids))
	return 0;
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PurgeChannelIndicationPDU(PurgeChannelIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->detach_user_ids);
        ASN1Free_SetOfChannelIDs(&(val)->purge_channel_ids);
    }
}

static int ASN1CALL ASN1Enc_PDUTokenAttributes(ASN1encoding_t enc, PDUTokenAttributes *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Grabbed(enc, &(val)->u.grabbed))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_Inhibited(enc, &(val)->u.inhibited))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_Giving(enc, &(val)->u.giving))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_Ungivable(enc, &(val)->u.ungivable))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_Given(enc, &(val)->u.given))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PDUTokenAttributes(ASN1decoding_t dec, PDUTokenAttributes *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Grabbed(dec, &(val)->u.grabbed))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_Inhibited(dec, &(val)->u.inhibited))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_Giving(dec, &(val)->u.giving))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_Ungivable(dec, &(val)->u.ungivable))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_Given(dec, &(val)->u.given))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PDUTokenAttributes(PDUTokenAttributes *val)
{
    if (val) {
        switch ((val)->choice) {
        case 2:
            ASN1Free_Inhibited(&(val)->u.inhibited);
            break;
        }
    }
}

static int ASN1CALL ASN1Enc_SetOfUserIDs(ASN1encoding_t enc, PSetOfUserIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfUserIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfUserIDs_ElmFn(ASN1encoding_t enc, PSetOfUserIDs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfUserIDs(ASN1decoding_t dec, PSetOfUserIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfUserIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfUserIDs_ElmFn(ASN1decoding_t dec, PSetOfUserIDs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfUserIDs(PSetOfUserIDs *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfUserIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfUserIDs_ElmFn(PSetOfUserIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes(ASN1encoding_t enc, PSetOfPDUChannelAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfPDUChannelAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUChannelAttributes val)
{
    if (!ASN1Enc_PDUChannelAttributes(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes(ASN1decoding_t dec, PSetOfPDUChannelAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfPDUChannelAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUChannelAttributes val)
{
    if (!ASN1Dec_PDUChannelAttributes(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfPDUChannelAttributes(PSetOfPDUChannelAttributes *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfPDUChannelAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfPDUChannelAttributes_ElmFn(PSetOfPDUChannelAttributes val)
{
    if (val) {
        ASN1Free_PDUChannelAttributes(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfChannelIDs(ASN1encoding_t enc, PSetOfChannelIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfChannelIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfChannelIDs_ElmFn(ASN1encoding_t enc, PSetOfChannelIDs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfChannelIDs(ASN1decoding_t dec, PSetOfChannelIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfChannelIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfChannelIDs_ElmFn(ASN1decoding_t dec, PSetOfChannelIDs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfChannelIDs(PSetOfChannelIDs *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfChannelIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfChannelIDs_ElmFn(PSetOfChannelIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes(ASN1encoding_t enc, PSetOfPDUTokenAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfPDUTokenAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUTokenAttributes val)
{
    if (!ASN1Enc_PDUTokenAttributes(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes(ASN1decoding_t dec, PSetOfPDUTokenAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfPDUTokenAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUTokenAttributes val)
{
    if (!ASN1Dec_PDUTokenAttributes(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfPDUTokenAttributes(PSetOfPDUTokenAttributes *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfPDUTokenAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfPDUTokenAttributes_ElmFn(PSetOfPDUTokenAttributes val)
{
    if (val) {
        ASN1Free_PDUTokenAttributes(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfTokenIDs(ASN1encoding_t enc, PSetOfTokenIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfTokenIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfTokenIDs_ElmFn(ASN1encoding_t enc, PSetOfTokenIDs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfTokenIDs(ASN1decoding_t dec, PSetOfTokenIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfTokenIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfTokenIDs_ElmFn(ASN1decoding_t dec, PSetOfTokenIDs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfTokenIDs(PSetOfTokenIDs *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfTokenIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfTokenIDs_ElmFn(PSetOfTokenIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MergeTokensRequestPDU(ASN1encoding_t enc, MergeTokensRequestPDU *val)
{
    if (!ASN1Enc_SetOfPDUTokenAttributes(enc, &(val)->merge_tokens))
	return 0;
    if (!ASN1Enc_SetOfTokenIDs(enc, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeTokensRequestPDU(ASN1decoding_t dec, MergeTokensRequestPDU *val)
{
    if (!ASN1Dec_SetOfPDUTokenAttributes(dec, &(val)->merge_tokens))
	return 0;
    if (!ASN1Dec_SetOfTokenIDs(dec, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeTokensRequestPDU(MergeTokensRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUTokenAttributes(&(val)->merge_tokens);
        ASN1Free_SetOfTokenIDs(&(val)->purge_token_ids);
    }
}

static int ASN1CALL ASN1Enc_MergeTokensConfirmPDU(ASN1encoding_t enc, MergeTokensConfirmPDU *val)
{
    if (!ASN1Enc_SetOfPDUTokenAttributes(enc, &(val)->merge_tokens))
	return 0;
    if (!ASN1Enc_SetOfTokenIDs(enc, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeTokensConfirmPDU(ASN1decoding_t dec, MergeTokensConfirmPDU *val)
{
    if (!ASN1Dec_SetOfPDUTokenAttributes(dec, &(val)->merge_tokens))
	return 0;
    if (!ASN1Dec_SetOfTokenIDs(dec, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeTokensConfirmPDU(MergeTokensConfirmPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUTokenAttributes(&(val)->merge_tokens);
        ASN1Free_SetOfTokenIDs(&(val)->purge_token_ids);
    }
}

static int ASN1CALL ASN1Enc_PurgeTokenIndicationPDU(ASN1encoding_t enc, PurgeTokenIndicationPDU *val)
{
    if (!ASN1Enc_SetOfTokenIDs(enc, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PurgeTokenIndicationPDU(ASN1decoding_t dec, PurgeTokenIndicationPDU *val)
{
    if (!ASN1Dec_SetOfTokenIDs(dec, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PurgeTokenIndicationPDU(PurgeTokenIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfTokenIDs(&(val)->purge_token_ids);
    }
}

static int ASN1CALL ASN1Enc_DisconnectProviderUltimatumPDU(ASN1encoding_t enc, DisconnectProviderUltimatumPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 3, (val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectProviderUltimatumPDU(ASN1decoding_t dec, DisconnectProviderUltimatumPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RejectUltimatumPDU(ASN1encoding_t enc, RejectUltimatumPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->diagnostic))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->initial_octets))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RejectUltimatumPDU(ASN1decoding_t dec, RejectUltimatumPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->diagnostic))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->initial_octets))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RejectUltimatumPDU(RejectUltimatumPDU *val)
{
    if (val) {
        ASN1octetstring_free(&(val)->initial_octets);
    }
}

static int ASN1CALL ASN1Enc_AttachUserConfirmPDU(ASN1encoding_t enc, AttachUserConfirmPDU *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AttachUserConfirmPDU(ASN1decoding_t dec, AttachUserConfirmPDU *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	    return 0;
	(val)->initiator += 1001;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_DetachUserRequestPDU(ASN1encoding_t enc, DetachUserRequestPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 3, (val)->reason))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DetachUserRequestPDU(ASN1decoding_t dec, DetachUserRequestPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->reason))
	return 0;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DetachUserRequestPDU(DetachUserRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_DetachUserIndicationPDU(ASN1encoding_t enc, DetachUserIndicationPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 3, (val)->reason))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DetachUserIndicationPDU(ASN1decoding_t dec, DetachUserIndicationPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->reason))
	return 0;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DetachUserIndicationPDU(DetachUserIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelJoinRequestPDU(ASN1encoding_t enc, ChannelJoinRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelJoinRequestPDU(ASN1decoding_t dec, ChannelJoinRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelJoinConfirmPDU(ASN1encoding_t enc, ChannelJoinConfirmPDU *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requested))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->join_channel_id))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelJoinConfirmPDU(ASN1decoding_t dec, ChannelJoinConfirmPDU *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requested))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->join_channel_id))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelLeaveRequestPDU(ASN1encoding_t enc, ChannelLeaveRequestPDU *val)
{
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelLeaveRequestPDU(ASN1decoding_t dec, ChannelLeaveRequestPDU *val)
{
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelLeaveRequestPDU(ChannelLeaveRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfChannelIDs(&(val)->channel_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelConveneRequestPDU(ASN1encoding_t enc, ChannelConveneRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelConveneRequestPDU(ASN1decoding_t dec, ChannelConveneRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelConveneConfirmPDU(ASN1encoding_t enc, ChannelConveneConfirmPDU *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->convene_channel_id - 1001))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelConveneConfirmPDU(ASN1decoding_t dec, ChannelConveneConfirmPDU *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->convene_channel_id))
	    return 0;
	(val)->convene_channel_id += 1001;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelDisbandRequestPDU(ASN1encoding_t enc, ChannelDisbandRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelDisbandRequestPDU(ASN1decoding_t dec, ChannelDisbandRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelDisbandIndicationPDU(ASN1encoding_t enc, ChannelDisbandIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelDisbandIndicationPDU(ASN1decoding_t dec, ChannelDisbandIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAdmitRequestPDU(ASN1encoding_t enc, ChannelAdmitRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAdmitRequestPDU(ASN1decoding_t dec, ChannelAdmitRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelAdmitRequestPDU(ChannelAdmitRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelAdmitIndicationPDU(ASN1encoding_t enc, ChannelAdmitIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAdmitIndicationPDU(ASN1decoding_t dec, ChannelAdmitIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelAdmitIndicationPDU(ChannelAdmitIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelExpelRequestPDU(ASN1encoding_t enc, ChannelExpelRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelExpelRequestPDU(ASN1decoding_t dec, ChannelExpelRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelExpelRequestPDU(ChannelExpelRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelExpelIndicationPDU(ASN1encoding_t enc, ChannelExpelIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelExpelIndicationPDU(ASN1decoding_t dec, ChannelExpelIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelExpelIndicationPDU(ChannelExpelIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_TokenGrabRequestPDU(ASN1encoding_t enc, TokenGrabRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGrabRequestPDU(ASN1decoding_t dec, TokenGrabRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGrabConfirmPDU(ASN1encoding_t enc, TokenGrabConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGrabConfirmPDU(ASN1decoding_t dec, TokenGrabConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenInhibitRequestPDU(ASN1encoding_t enc, TokenInhibitRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenInhibitRequestPDU(ASN1decoding_t dec, TokenInhibitRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenInhibitConfirmPDU(ASN1encoding_t enc, TokenInhibitConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenInhibitConfirmPDU(ASN1decoding_t dec, TokenInhibitConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveRequestPDU(ASN1encoding_t enc, TokenGiveRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveRequestPDU(ASN1decoding_t dec, TokenGiveRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveIndicationPDU(ASN1encoding_t enc, TokenGiveIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveIndicationPDU(ASN1decoding_t dec, TokenGiveIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveResponsePDU(ASN1encoding_t enc, TokenGiveResponsePDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveResponsePDU(ASN1decoding_t dec, TokenGiveResponsePDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveConfirmPDU(ASN1encoding_t enc, TokenGiveConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveConfirmPDU(ASN1decoding_t dec, TokenGiveConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenPleaseRequestPDU(ASN1encoding_t enc, TokenPleaseRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenPleaseRequestPDU(ASN1decoding_t dec, TokenPleaseRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenPleaseIndicationPDU(ASN1encoding_t enc, TokenPleaseIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenPleaseIndicationPDU(ASN1decoding_t dec, TokenPleaseIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenReleaseRequestPDU(ASN1encoding_t enc, TokenReleaseRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenReleaseRequestPDU(ASN1decoding_t dec, TokenReleaseRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenReleaseConfirmPDU(ASN1encoding_t enc, TokenReleaseConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenReleaseConfirmPDU(ASN1decoding_t dec, TokenReleaseConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenTestRequestPDU(ASN1encoding_t enc, TokenTestRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenTestRequestPDU(ASN1decoding_t dec, TokenTestRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenTestConfirmPDU(ASN1encoding_t enc, TokenTestConfirmPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenTestConfirmPDU(ASN1decoding_t dec, TokenTestConfirmPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectMCSPDU(ConnectMCSPDU *val)
{
    if (val) {
        switch ((val)->choice) {
        case 1:
        ASN1Free_ConnectInitialPDU(&(val)->u.connect_initial);
        break;
        case 2:
        ASN1Free_ConnectResponsePDU(&(val)->u.connect_response);
        break;
        }
    }
}

static int ASN1CALL ASN1Enc_DomainMCSPDU(ASN1encoding_t enc, DomainMCSPDU *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PlumbDomainIndicationPDU(enc, &(val)->u.plumb_domain_indication))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ErectDomainRequestPDU(enc, &(val)->u.erect_domain_request))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MergeChannelsRequestPDU(enc, &(val)->u.merge_channels_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_MergeChannelsConfirmPDU(enc, &(val)->u.merge_channels_confirm))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_PurgeChannelIndicationPDU(enc, &(val)->u.purge_channel_indication))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_MergeTokensRequestPDU(enc, &(val)->u.merge_tokens_request))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MergeTokensConfirmPDU(enc, &(val)->u.merge_tokens_confirm))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_PurgeTokenIndicationPDU(enc, &(val)->u.purge_token_indication))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_DisconnectProviderUltimatumPDU(enc, &(val)->u.disconnect_provider_ultimatum))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RejectUltimatumPDU(enc, &(val)->u.reject_user_ultimatum))
	    return 0;
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Enc_AttachUserConfirmPDU(enc, &(val)->u.attach_user_confirm))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_DetachUserRequestPDU(enc, &(val)->u.detach_user_request))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_DetachUserIndicationPDU(enc, &(val)->u.detach_user_indication))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_ChannelJoinRequestPDU(enc, &(val)->u.channel_join_request))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_ChannelJoinConfirmPDU(enc, &(val)->u.channel_join_confirm))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_ChannelLeaveRequestPDU(enc, &(val)->u.channel_leave_request))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_ChannelConveneRequestPDU(enc, &(val)->u.channel_convene_request))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_ChannelConveneConfirmPDU(enc, &(val)->u.channel_convene_confirm))
	    return 0;
	break;
    case 20:
	if (!ASN1Enc_ChannelDisbandRequestPDU(enc, &(val)->u.channel_disband_request))
	    return 0;
	break;
    case 21:
	if (!ASN1Enc_ChannelDisbandIndicationPDU(enc, &(val)->u.channel_disband_indication))
	    return 0;
	break;
    case 22:
	if (!ASN1Enc_ChannelAdmitRequestPDU(enc, &(val)->u.channel_admit_request))
	    return 0;
	break;
    case 23:
	if (!ASN1Enc_ChannelAdmitIndicationPDU(enc, &(val)->u.channel_admit_indication))
	    return 0;
	break;
    case 24:
	if (!ASN1Enc_ChannelExpelRequestPDU(enc, &(val)->u.channel_expel_request))
	    return 0;
	break;
    case 25:
	if (!ASN1Enc_ChannelExpelIndicationPDU(enc, &(val)->u.channel_expel_indication))
	    return 0;
	break;
    case 26:
    case 27:
    case 28:
    case 29:
        return 0;
    case 30:
	if (!ASN1Enc_TokenGrabRequestPDU(enc, &(val)->u.token_grab_request))
	    return 0;
	break;
    case 31:
	if (!ASN1Enc_TokenGrabConfirmPDU(enc, &(val)->u.token_grab_confirm))
	    return 0;
	break;
    case 32:
	if (!ASN1Enc_TokenInhibitRequestPDU(enc, &(val)->u.token_inhibit_request))
	    return 0;
	break;
    case 33:
	if (!ASN1Enc_TokenInhibitConfirmPDU(enc, &(val)->u.token_inhibit_confirm))
	    return 0;
	break;
    case 34:
	if (!ASN1Enc_TokenGiveRequestPDU(enc, &(val)->u.token_give_request))
	    return 0;
	break;
    case 35:
	if (!ASN1Enc_TokenGiveIndicationPDU(enc, &(val)->u.token_give_indication))
	    return 0;
	break;
    case 36:
	if (!ASN1Enc_TokenGiveResponsePDU(enc, &(val)->u.token_give_response))
	    return 0;
	break;
    case 37:
	if (!ASN1Enc_TokenGiveConfirmPDU(enc, &(val)->u.token_give_confirm))
	    return 0;
	break;
    case 38:
	if (!ASN1Enc_TokenPleaseRequestPDU(enc, &(val)->u.token_please_request))
	    return 0;
	break;
    case 39:
	if (!ASN1Enc_TokenPleaseIndicationPDU(enc, &(val)->u.token_please_indication))
	    return 0;
	break;
    case 40:
	if (!ASN1Enc_TokenReleaseRequestPDU(enc, &(val)->u.token_release_request))
	    return 0;
	break;
    case 41:
	if (!ASN1Enc_TokenReleaseConfirmPDU(enc, &(val)->u.token_release_confirm))
	    return 0;
	break;
    case 42:
	if (!ASN1Enc_TokenTestRequestPDU(enc, &(val)->u.token_test_request))
	    return 0;
	break;
    case 43:
	if (!ASN1Enc_TokenTestConfirmPDU(enc, &(val)->u.token_test_confirm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DomainMCSPDU(ASN1decoding_t dec, DomainMCSPDU *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PlumbDomainIndicationPDU(dec, &(val)->u.plumb_domain_indication))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ErectDomainRequestPDU(dec, &(val)->u.erect_domain_request))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MergeChannelsRequestPDU(dec, &(val)->u.merge_channels_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_MergeChannelsConfirmPDU(dec, &(val)->u.merge_channels_confirm))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_PurgeChannelIndicationPDU(dec, &(val)->u.purge_channel_indication))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_MergeTokensRequestPDU(dec, &(val)->u.merge_tokens_request))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MergeTokensConfirmPDU(dec, &(val)->u.merge_tokens_confirm))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_PurgeTokenIndicationPDU(dec, &(val)->u.purge_token_indication))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_DisconnectProviderUltimatumPDU(dec, &(val)->u.disconnect_provider_ultimatum))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RejectUltimatumPDU(dec, &(val)->u.reject_user_ultimatum))
	    return 0;
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Dec_AttachUserConfirmPDU(dec, &(val)->u.attach_user_confirm))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_DetachUserRequestPDU(dec, &(val)->u.detach_user_request))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_DetachUserIndicationPDU(dec, &(val)->u.detach_user_indication))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_ChannelJoinRequestPDU(dec, &(val)->u.channel_join_request))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_ChannelJoinConfirmPDU(dec, &(val)->u.channel_join_confirm))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_ChannelLeaveRequestPDU(dec, &(val)->u.channel_leave_request))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_ChannelConveneRequestPDU(dec, &(val)->u.channel_convene_request))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_ChannelConveneConfirmPDU(dec, &(val)->u.channel_convene_confirm))
	    return 0;
	break;
    case 20:
	if (!ASN1Dec_ChannelDisbandRequestPDU(dec, &(val)->u.channel_disband_request))
	    return 0;
	break;
    case 21:
	if (!ASN1Dec_ChannelDisbandIndicationPDU(dec, &(val)->u.channel_disband_indication))
	    return 0;
	break;
    case 22:
	if (!ASN1Dec_ChannelAdmitRequestPDU(dec, &(val)->u.channel_admit_request))
	    return 0;
	break;
    case 23:
	if (!ASN1Dec_ChannelAdmitIndicationPDU(dec, &(val)->u.channel_admit_indication))
	    return 0;
	break;
    case 24:
	if (!ASN1Dec_ChannelExpelRequestPDU(dec, &(val)->u.channel_expel_request))
	    return 0;
	break;
    case 25:
	if (!ASN1Dec_ChannelExpelIndicationPDU(dec, &(val)->u.channel_expel_indication))
	    return 0;
	break;
    case 26:
    case 27:
    case 28:
    case 29:
        return 0;
    case 30:
	if (!ASN1Dec_TokenGrabRequestPDU(dec, &(val)->u.token_grab_request))
	    return 0;
	break;
    case 31:
	if (!ASN1Dec_TokenGrabConfirmPDU(dec, &(val)->u.token_grab_confirm))
	    return 0;
	break;
    case 32:
	if (!ASN1Dec_TokenInhibitRequestPDU(dec, &(val)->u.token_inhibit_request))
	    return 0;
	break;
    case 33:
	if (!ASN1Dec_TokenInhibitConfirmPDU(dec, &(val)->u.token_inhibit_confirm))
	    return 0;
	break;
    case 34:
	if (!ASN1Dec_TokenGiveRequestPDU(dec, &(val)->u.token_give_request))
	    return 0;
	break;
    case 35:
	if (!ASN1Dec_TokenGiveIndicationPDU(dec, &(val)->u.token_give_indication))
	    return 0;
	break;
    case 36:
	if (!ASN1Dec_TokenGiveResponsePDU(dec, &(val)->u.token_give_response))
	    return 0;
	break;
    case 37:
	if (!ASN1Dec_TokenGiveConfirmPDU(dec, &(val)->u.token_give_confirm))
	    return 0;
	break;
    case 38:
	if (!ASN1Dec_TokenPleaseRequestPDU(dec, &(val)->u.token_please_request))
	    return 0;
	break;
    case 39:
	if (!ASN1Dec_TokenPleaseIndicationPDU(dec, &(val)->u.token_please_indication))
	    return 0;
	break;
    case 40:
	if (!ASN1Dec_TokenReleaseRequestPDU(dec, &(val)->u.token_release_request))
	    return 0;
	break;
    case 41:
	if (!ASN1Dec_TokenReleaseConfirmPDU(dec, &(val)->u.token_release_confirm))
	    return 0;
	break;
    case 42:
	if (!ASN1Dec_TokenTestRequestPDU(dec, &(val)->u.token_test_request))
	    return 0;
	break;
    case 43:
	if (!ASN1Dec_TokenTestConfirmPDU(dec, &(val)->u.token_test_confirm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DomainMCSPDU(DomainMCSPDU *val)
{
    if (val) {
        switch ((val)->choice) {
        case 3:
        ASN1Free_MergeChannelsRequestPDU(&(val)->u.merge_channels_request);
        break;
        case 4:
        ASN1Free_MergeChannelsConfirmPDU(&(val)->u.merge_channels_confirm);
        break;
        case 5:
        ASN1Free_PurgeChannelIndicationPDU(&(val)->u.purge_channel_indication);
        break;
        case 6:
        ASN1Free_MergeTokensRequestPDU(&(val)->u.merge_tokens_request);
        break;
        case 7:
        ASN1Free_MergeTokensConfirmPDU(&(val)->u.merge_tokens_confirm);
        break;
        case 8:
        ASN1Free_PurgeTokenIndicationPDU(&(val)->u.purge_token_indication);
        break;
        case 10:
        ASN1Free_RejectUltimatumPDU(&(val)->u.reject_user_ultimatum);
        break;
        case 13:
        ASN1Free_DetachUserRequestPDU(&(val)->u.detach_user_request);
        break;
        case 14:
        ASN1Free_DetachUserIndicationPDU(&(val)->u.detach_user_indication);
        break;
        case 17:
        ASN1Free_ChannelLeaveRequestPDU(&(val)->u.channel_leave_request);
        break;
        case 22:
        ASN1Free_ChannelAdmitRequestPDU(&(val)->u.channel_admit_request);
        break;
        case 23:
        ASN1Free_ChannelAdmitIndicationPDU(&(val)->u.channel_admit_indication);
        break;
        case 24:
        ASN1Free_ChannelExpelRequestPDU(&(val)->u.channel_expel_request);
        break;
        case 25:
        ASN1Free_ChannelExpelIndicationPDU(&(val)->u.channel_expel_indication);
        break;
        case 26:
        case 27:
        case 28:
        case 29:
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\mcslog.h ===
/**********************************************************************
 * File:     mcslog.h
 * Abstract: Function headers for protocol logging functions added
 * into MCSNC.DLL to read the contents of MCS PDU contents
 * sent and received from the T.123 layer.
 * Created:  2/18/96, Venkatesh Gopalakrishnan
 * Copyright (c) 1996 Microsoft Corpration
 ******************************************************************** */
 
 /* NOTE:  The contents of this file are only included IFF PDULOG is a
  * defined constant.  This constant will be defined in the Win32 Diagnostic
  * build configuration of MCSNC.DLL 
  */

 #ifdef PDULOG

 #ifndef _PROTLOG_H
 #define _PROTLOG_H
 

 #include <windows.h>
 #include <time.h>
 #include <stdio.h>
 
 #include "mpdutype.h"
 #include "mcspdu.h"
 
 #define MAXIMUM_PRINT_LENGTH 256
 #define LOG_FILE_NAME "mcslog.txt"
 #define SENT 0
 #define RECEIVED 1


 /* Enumerated Data types and corresponding strings used in
  * MCS PDUs.
  */

#define NOT_IN_USE			0
#define SELF_GRABBED		1
#define OTHER_GRABBED		2
#define SELF_INHIBITED		3
#define OTHER_INHIBITED		4
#define SELF_RECIPIENT		5
#define SELF_GIVING			6
#define OTHER_GIVING		7

#define NOT_IN_USE_STR			"NOT_IN_USE"
#define SELF_GRABBED_STR		"SELF_GRABBED"
#define OTHER_GRABBED_STR		"OTHER_GRABBED"
#define SELF_INHIBITED_STR		"SELF_INHIBITED"
#define OTHER_INHIBITED_STR		"OTHER_INHIBITED"
#define SELF_RECPIENT_STR		"SELF_RECIPIENT"
#define SELF_GIVING_STR			"SELF_GIVING"
#define OTHER_GIVING_STR		"OTHER_GIVING"

#define TOP_PRI			0
#define HIGH_PRI		1
#define MEDIUM_PRI		2
#define LOW_PRI			3

#define TOP_STR					"TOP_PRIORITY\n"
#define HIGH_STR				"HIGH_PRIORITY\n"
#define MEDIUM_STR				"MEDIUM_PRIORITY\n"
#define LOW_STR					"LOW_PRIORITY\n"

#define RT_SUCCESSFUL					0
#define RT_DOMAIN_MERGING				1
#define RT_DOMAIN_NOT_HIERARCHICAL		2
#define RT_NO_SUCH_CHANNEL				3
#define	RT_NO_SUCH_DOMAIN				4
#define RT_NO_SUCH_USER					5
#define RT_NOT_ADMITTED					6
#define RT_OTHER_USER					7
#define	RT_PARAMETERS_UNACCEPTABLE		8
#define RT_TOKEN_NOT_AVAILABLE			9
#define RT_TOKEN_NOT_POSESSED			10
#define RT_TOO_MANY_CHANNELS			11
#define RT_TOO_MANY_TOKENS				12
#define RT_TOO_MANY_USERS				13
#define RT_UNSPECIFIED_FAILURE			14
#define RT_USER_REJECTED				15


/*** 
**** The following function headers are for service functions
**** for logging the value(s) of typical data types found in 
**** several MCS PDU structures.
****/ 
void PrintPDUResult(FILE *logfile, unsigned int result);
void PrintPDUPriority(FILE *logfile, unsigned int priority);
void PrintTokenStatus(FILE *logfile, unsigned int token_status);
void PrintPDUReason(FILE *logfile, unsigned int reason);
void PrintDiagnostic(FILE *logfile, unsigned int diagnostic);
void PrintPDUSegmentation(FILE *logfile, unsigned char segmentation);


void PrintSetOfChannelIDs(FILE *logfile, PSetOfChannelIDs channel_ids);
void PrintSetOfUserIDs(FILE *logfile, PSetOfUserIDs user_ids);
void PrintSetOfTokenIDs(FILE *logfile, PSetOfTokenIDs token_ids);
void PrintSetOfTokenAttributes(FILE *logfile, 
							PSetOfPDUTokenAttributes token_attribute_obj);

void PrintPDUDomainParameters(FILE *logfile, PDUDomainParameters domain_params);
void PrintT120Boolean(FILE *logfile, char * string, BOOL boolean);
void PrintCharData(FILE *logfile, unsigned char *string, unsigned int length);

void PrintChannelAttributes(FILE *logfile, PDUChannelAttributes channel_attributes);
void PrintTokenAttributes(FILE *logfile, PDUTokenAttributes token_attributes);

int InitializeMCSLog();
 /* Description:
  *         Resets the mcs protocol log file and reads any
  *         ini file parameters
  */
  

char *pszTimeStamp(); 
 /* Desicription:
  *         This function is an easy interfact to getting the time the
  *         PDU was encoded or decoded from MCS to T.123 or vice versa.
  */
  
void pduLog(FILE *file, char * format_string,...);
 /* Description:
  *         This function is used to place PDU information in a protocol
  *         log file.  There is currently no return value.  This may change.
  */       

void pduFragmentation(FILE *logfile, unsigned int i);
 /* Description:
  *         This function logs weather or not the PDU is complete
  *         or fragmented.
  */

void pduRawOutput(FILE *logfile, unsigned char * data, unsigned long length);
 /* Description:
  *         This function logs a hex dump of the raw encoded MCS PDU that
  *         is sent over the wire via MCS.
  */
  

void mcsLog(PPacket packet,  PDomainMCSPDU domain_pdu, unsigned int direction);
 /* Description:
  *         This function takes care of the log headers and footers to 
  *         attempt at compatibility with a certain third party mcs log
  *         reader.
  */
void mcsConnectLog(PPacket packet, PConnectMCSPDU connect_pdu, unsigned int direction);
 /* same as above, but for Connect PDUs */

void pduLogMCSDomainInfo(FILE *file, PDomainMCSPDU domain_pdu);
/* Description:
 *         This function takes the mcs pdu structure, and based on
 *         Which type of MCSPDU that it is, logs internal information
 *         in the PDU.
 */
void pduLogMCSConnectInfo(FILE *file, PConnectMCSPDU connect_pdu);
 /* same as above but for Connect PDUs */

void pduDirection(FILE *logfile,unsigned int direction);
 /* Description:
  *         This function logs information whether the mcs pdu was sent
  *         or received.
  */



/*****
 ***** The following headers are for functions that log the output of
 ***** each different type of MCS PDU.  Every MCS PDU is covered here.
 *****/

void pduLogConnectInitial(FILE *file, PConnectMCSPDU connect_pdu);
 /* Description:
  *         This function takes the connect_pdu and writes the component parts
  *         of the mcs ConnectInitial PDU.
  */
void pduLogConnectResponse(FILE *file, PConnectMCSPDU connect_pdu);
void pduLogConnectAdditional(FILE *file, PConnectMCSPDU connect_pdu);
void pduLogConnectResult(FILE *file, PConnectMCSPDU connect_pdu);
void pduLogPlumbDomainIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogErectDomainRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeChannelsRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeChannelsConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogPurgeChannelIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeTokensRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeTokensConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogPurgeTokenIndication(FILE *file, PDomainMCSPDU domain_pdu); 
void pduLogDisconnectProviderUltimatum(FILE *file, PDomainMCSPDU domain_pdu); 
void pduLogRejectUltimatum(FILE *logfile, PDomainMCSPDU domain_pdu);
void pduLogAttachUserRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogAttachUserConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogDetachUserRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogDetachUserIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelJoinRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelJoinConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelLeaveRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelConveneRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelConveneConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelDisbandRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelDisbandIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelAdmitRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelAdmitIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelExpelRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelExpelIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogSendDataRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogSendDataIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogUniformSendDataRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogUniformSendDataIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGrabRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGrabConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenInhibitRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenInhibitConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveResponse(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenPleaseRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenPleaseIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenReleaseRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenReleaseConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenTestRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenTestConfirm(FILE *file, PDomainMCSPDU domain_pdu);
 
 
BOOL CopyTextToChar(char * print_string, 
						   unsigned short *text_string_value, 
						   unsigned int text_string_length);

 


 #endif  // <<<<<<<<<<<< _PROTLOG_H
 #endif  // <<<<<<<<<<<< PDULOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\mcsuser.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	mcsuser.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implemntation file for the MCSUser class. It implements
 *		functions responsible for encoding out bound indirect conference
 *		join request and response PDUs, and also Send user ID Requests. All
 *		these PDUs are encapsulated in user data field of MCSSendDataRequest.
 *		Also this file implements functions that are responsible for decoding
 *		incoming indications and confirm PDUs which are encapsulated in the
 *		user data field of MCSSendDataIndication. Functions responsible for
 *		joining different channels are also implemented in this module.
 *
 *		SEE THE INTERFACE FILE FOR A MORE DETAILED DESCRIPTION OF THIS CLASS.
 *
 *	Private Instance Variables
 *		m_pMCSSap
 *			This is the MCS User handle handed back from the MCS Attache User
 *			Request.
 *		m_nidMyself
 *			The is the MCS User ID returned in the Attach User Confirm.  This
 *			is also refered to as the Node ID with in GCC.
 *		m_nidTopProvider
 *			This holds the MCS User ID (or Node ID) for the top Provider.
 *		m_nidParent
 *			This holds the MCS User ID (or Node ID) for this nodes parent node.
 *		m_fEjectionPending
 *			This flag indicates if an ejection of this node is pending.
 *		m_eEjectReason
 *			This variable holds the reason for ejection until the eject
 *			indication can be delivered after all child nodes have disconnected.
 *		m_pOwnerConf
 *			Pointer to the object that will receive all the owner callbacks
 *			from the user object (typically the conference object).
 *		m_ChannelJoinedFlags
 *			A structure of flags used to keep up with creation state machine.
 *			Basically, it keeps up with which channels have been joined and
 *			which ones have not.
 *		m_ChildUidConnHdlList2
 *			Keeps mapping of child Node IDs to child logical connection
 *			handles.
 *		m_OutgoingPDUQueue
 *			This is a rogue wave list used to queue up all outgoing PDUs.
 *		m_ConfJoinResponseList2
 *			This rogue wave list holds information needed to send back in a join
 *			response after the local node controller responds.
 *		m_EjectedNodeAlarmList2
 *			This list holds alarm objects for all the nodes that have been
 *			ejected and are directly connected to this node.  The alarm is
 *			used to disconnect any misbehaving nodes that do not disconnect
 *			after the EJECTED_NODE_TIMER_DURATION.
 *		m_EjectedNodeList
 *			This list keeps up with nodes that have been ejected but are NOT
 *			directly connected to this node.  We save these nodes so that
 *			a correct reason for disconnecting (user ejected) can be issued
 *			when the detch user indication comes in.
 * 		
 *	Author:
 *		blp
 */

#include "mcsuser.h"
#include "mcsdllif.h"
#include "ogcccode.h"
#include "conf.h"
#include "translat.h"
#include "gcontrol.h"

//	Static Channel and Token ID definitions used by the MCS user object.
#define		BROADCAST_CHANNEL_ID	1
#define		CONVENER_CHANNEL_ID 	2
#define		CONDUCTOR_TOKEN_ID		1

//	Time given to allow an ejected node to disconnect before it is disconnected
#define	EJECTED_NODE_TIMER_DURATION		10000	//	Duration in milliseconds


extern MCSDLLInterface     *g_pMCSIntf;

/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CGCCCoder	*g_GCCCoder;

/*
 *	MCSUser ()
 *
 *	Public Function Description
 *		This is the MCSUser object constructor.  It is responsible for
 *		initializing all the instance variables used by this class.  The
 *		constructor is responsible for establishing the user attachment to
 *		the MCS domain defined by the conference ID.  It also kicks off the
 *		process of joining all the appropriate channels.
 */
MCSUser::
MCSUser(CConf                   *pConf,
		GCCNodeID				nidTopProvider,
		GCCNodeID				nidParent,
		PGCCError				return_value)
:
    CRefCount(MAKE_STAMP_ID('M','U','s','r')),
	m_ChildUidConnHdlList2(),
	m_EjectedNodeAlarmList2(),
	m_EjectedNodeList(),
	m_pConf(pConf),
	m_nidTopProvider(nidTopProvider),
	m_nidParent(nidParent),
	m_nidMyself(NULL),
	m_fEjectionPending(FALSE)
{
    MCSError        mcs_rc;
    GCCConfID       nConfID = pConf->GetConfID();

	//	No channels are joined initially
	m_ChannelJoinedFlags.user_channel_joined = FALSE;
	m_ChannelJoinedFlags.broadcast_channel_joined = FALSE;
	m_ChannelJoinedFlags.convener_channel_joined = FALSE;
	m_ChannelJoinedFlags.channel_join_error = FALSE;

	mcs_rc = g_pMCSIntf->AttachUserRequest(&nConfID, &m_pMCSSap, this);
    if (MCS_NO_ERROR != mcs_rc)
	{
		WARNING_OUT(("MCSUser::MCSUser: Failure in attach user req, "));
		*return_value = GCC_FAILURE_ATTACHING_TO_MCS;
	}
	else
    {
		*return_value = GCC_NO_ERROR;
    }
 }

/*
 *	~MCSUser ()
 *
 *	Public Function Description
 *		This is the user destructor. It takes care of leaving channels
 *		joined by the user object. Also it detaches the user attachment
 *	 	with MCS by issuing a detach user request.
 */
MCSUser::~MCSUser(void)
{
	//	Clean up the Ejected Node Alarm List
	PAlarm				lpAlarm;
	while (NULL != (lpAlarm = m_EjectedNodeAlarmList2.Get()))
    {
		delete lpAlarm;
    }

	if(m_ChannelJoinedFlags.user_channel_joined)
    {
		g_pMCSIntf->ChannelLeaveRequest(m_nidMyself, m_pMCSSap);
    }

	if(m_ChannelJoinedFlags.broadcast_channel_joined)
    {
		g_pMCSIntf->ChannelLeaveRequest(BROADCAST_CHANNEL_ID, m_pMCSSap);
    }

	if(m_ChannelJoinedFlags.convener_channel_joined)
    {
		g_pMCSIntf->ChannelLeaveRequest(CONVENER_CHANNEL_ID, m_pMCSSap);
    }

    //	Empty the queue of all PDUs
	SEND_DATA_REQ_INFO *pReqInfo;
	m_OutgoingPDUQueue.Reset();
	while (NULL != (pReqInfo = m_OutgoingPDUQueue.Iterate()))
	{
		pReqInfo->packet->Unlock();
		delete pReqInfo;
	}

	g_pMCSIntf->DetachUserRequest(m_pMCSSap, this);
}

/*
 *	UINT	ProcessAttachUserConfirm ()
 *
 *	Private Function Description
 *		This function is called when the user object gets an attach user
 *		confirm from MCS in response to an attach user request made by the
 *		user object in it's constructor. The function checks the result
 *		indicated in the confirm. If the result is a successful attachment, then
 *		different channels depending upon the type of the provider, are joined.
 *		Also this function reports failures in attach user (as indicated by
 *		result in attach user confirm) and channel joins, to the conference
 *		through an owner callback.
 *
 *	Formal Parameters:
 *		result		-	(i)	Result of the attach user request.
 *		user_id		-	(i)	This nodes user or Node ID if successful result.
 *
 *	Return Value
 *		MCS_NO_ERROR	-	No error is always returned.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT MCSUser::ProcessAttachUserConfirm(Result result, UserID user_id)
{
	UINT					rc;

	if (result == RESULT_SUCCESSFUL)
	{
		m_nidMyself = user_id;

		/*
		**	After the attach confirm is received we go ahead and join the
		**	appropriate channel based on the conf node type. If this
		**	node is the yop provider we also set up the top provider user id,
		**	otherwise this gets set up in the constructor.
		*/
		switch (m_pConf->GetConfNodeType())
		{
		case TOP_PROVIDER_NODE:
            m_nidTopProvider = m_nidMyself;
			rc = JoinUserAndBroadCastChannels();
			break;

        case JOINED_CONVENER_NODE:
		case CONVENER_NODE:
			rc = JoinUserAndBroadCastChannels();
			if(rc == MCS_NO_ERROR)
            {
				rc = JoinConvenerChannel();
            }
			break;

        case TOP_PROVIDER_AND_CONVENER_NODE:
			m_nidTopProvider = m_nidMyself;
			rc = JoinUserAndBroadCastChannels();
			if(rc == MCS_NO_ERROR)
            {
				rc = JoinConvenerChannel();	
            }
			break;

        case JOINED_NODE:
		case INVITED_NODE:
			rc = JoinUserAndBroadCastChannels();
			break;

        default:
			ERROR_OUT(("User::ProcessAttachUserConfirm: Bad Node Type, %u", (UINT) m_pConf->GetConfNodeType()));
			break;
		}
		
		if (rc != MCS_NO_ERROR)
		{
			/*
			 * ChannelJoinRequestFailed at some level in MCS
			 * So this message tells the conferenceabout this
			 * failure. Conference will delete the user object
			 * as a result of this
			 */
			m_pConf->ProcessUserCreateConfirm(USER_CHANNEL_JOIN_FAILURE, m_nidMyself);
		}
	}
	else
	{
		/*
		 * Attach user request failed as indicated by the result field in the
		 * confirm message, because of any of the following causes:
		 * congested, domain disconnected, no such domain, too many channels,
		 * too many users, unspecified failure. In this case the user object
		 * just sends the conference a GCC_USER_ATTACH_FAILURE ( to be defined
		 * in command target.h) , which causes
		 * the conference object to delete the user attachment.
		 * UserCreateConfirm message is not corresponding exectly to a single
		 * primitive.
		 */
	    WARNING_OUT(("MCSUser::ProcessAttachUserConfirm: ATTACH FAILED"));
		m_pConf->ProcessUserCreateConfirm(USER_ATTACH_FAILURE, m_nidMyself);
	}

	return (MCS_NO_ERROR);
}

/*
 *	MCSError	JoinUserAndBroadCastChannels()
 *
 *	Private Function Description
 *		This function is called by user object when it gets a successful
 *		attach user confrim, to join user id and broadcast channels.
 *		If the channel join requests fail, it returns the appropriate MCS
 *		Error.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		See return values for mcs channel jon request.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

MCSError	MCSUser::JoinUserAndBroadCastChannels()
{
	MCSError		rc;

	rc = g_pMCSIntf->ChannelJoinRequest(m_nidMyself, m_pMCSSap);
	if(rc == MCS_NO_ERROR)

	{
		rc = g_pMCSIntf->ChannelJoinRequest(BROADCAST_CHANNEL_ID, m_pMCSSap);
	}

	return (rc);
}

/*
 *	MCSError	JoinUserAndBroadCastChannels()
 *
 *	Private Function Description
 *		This function is called by user object of a convener gcc provider
 *		when it gets a successful attach user confrim, to join convener
 *	 	channel. If the channel join requests fail, it returns the appropriate
 *		MCS	Error.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		See return values for mcs channel jon request.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
MCSError	MCSUser::JoinConvenerChannel()
{
	return g_pMCSIntf->ChannelJoinRequest(CONVENER_CHANNEL_ID, m_pMCSSap);
}

/*
 *	UINT	ProcessChannelJoinConfirm()
 *
 *	Private Function Description
 *		This function is called when the user object gets an channel join
 *		confirm from MCS in response to channel join requests made by the
 *		user object. If a channel is joined successfully as indicated by
 *		the result in the confirm, a channel joined flag corresponding to
 *		that channel id is set. This flag indicates as to which channels a
 *		user object is joined at any given time. Also after setting this
 *		flag the functions checks to see if all tke required channels based
 *		on the type of gcc provider, are joined. If all required channels are
 *		joined the conference object is informaed about it via an owner call-
 *		back (USER_CREATE_CONFIRM).	
 *
 *	Formal Parameters:
 *		result		-	(i)	Result of the channel join request.
 *		channel_id	-	(i)	Channel ID that this confirm pertains to.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT MCSUser::ProcessChannelJoinConfirm(Result result, ChannelID channel_id)
{
	if (m_ChannelJoinedFlags.channel_join_error == FALSE)
	{
		if (result == RESULT_SUCCESSFUL)
		{
			if( channel_id == m_nidMyself)
            {
				m_ChannelJoinedFlags.user_channel_joined = TRUE;
            }
			else
			{
				switch (channel_id)
				{	
				case CONVENER_CHANNEL_ID:
					m_ChannelJoinedFlags.convener_channel_joined = TRUE;
					break;	

                case BROADCAST_CHANNEL_ID:
					m_ChannelJoinedFlags.broadcast_channel_joined = TRUE;
					break;
				}
			}

			/*
			**	If all the channels are joined we inform the owner object that
			**	the user object was successfully created.
			*/
			if (AreAllChannelsJoined())
			{
				m_pConf->ProcessUserCreateConfirm(USER_RESULT_SUCCESSFUL, m_nidMyself);
			}
		}
		else
		{
			WARNING_OUT(("MCSUser::ProcessChannelJoinConfirm: Error joining channel, result=%u", (UINT) result));

			m_ChannelJoinedFlags.channel_join_error = TRUE ;

			m_pConf->ProcessUserCreateConfirm(USER_CHANNEL_JOIN_FAILURE, m_nidMyself);
		}
	}

	return (MCS_NO_ERROR);
}

/*
 *	BOOL	AreAllChannelsJoined()
 *
 *	Public Function Description
 *		This function is called to check if all tke required channels based
 *		on the type of gcc provider, are joined. It returns true if all
 *		required channels are joined and false otherwise. This function uses
 *		different channel joined flags to check which channels the given user
 *		object is joined to.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	If all channels are joined.
 *		FALSE	-	If all the channels are not joined.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
BOOL MCSUser::AreAllChannelsJoined(void)
{
	BOOL rc = FALSE;
	
	switch (m_pConf->GetConfNodeType())
	{
		case TOP_PROVIDER_NODE:
			if ((m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
			
		case JOINED_CONVENER_NODE:
		case CONVENER_NODE:
			if ((m_ChannelJoinedFlags.convener_channel_joined) &&
				(m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
							
		case TOP_PROVIDER_AND_CONVENER_NODE:
   			if ((m_ChannelJoinedFlags.convener_channel_joined) &&
				(m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
	
		case JOINED_NODE:
		case INVITED_NODE:
	   		if( (m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
	}

	return rc;
} 					

/*
 *	void	SendUserIDRequest()
 *
 *	Public Function Description:
 *		This request originates from the conference object. Conference object
 *		sends the sequence number obtained in the conference create confirm
 *		or conference join confirm to the parent GCC provider on the parent
 *		gcc provider's UserId channel. The pdu is encoded here and is
 *		queued to be sent during the next heartbeat.
 */
void MCSUser::SendUserIDRequest(TagNumber tag_number)
{
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the UserIDIndication pdu structure to be passed in the
	**	constructor of the packet class.
	*/

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = USER_ID_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.user_id_indication.tag = tag_number;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidParent, TOP_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
    }
}

/*
 *	GCCError	ConferenceJoinRequest()
 *
 *	Public Function Description:
 * 		This call is made by the conference object of the intermediate node
 *  	to forward the conference join request over to the top provider. This
 *		function encodes the conference join request pdu and queues it to be
 *		sent in the next heartbeat.
 *
 *	Caveats
 *		The connection handle is used here for a TAG and should be passed back
 *		to the owner object when the join response comes in.
 */
GCCError MCSUser::ConferenceJoinRequest(
									CPassword           *convener_password,
									CPassword           *password_challenge,
									LPWSTR				pwszCallerID,
									CUserDataListContainer *user_data_list,
									ConnectionHandle	connection_handle)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_JOIN_REQUEST_CHOSEN;
   	gcc_pdu.u.request.u.conference_join_request.tag = (TagNumber)connection_handle;
	gcc_pdu.u.request.u.conference_join_request.bit_mask = TAG_PRESENT;

	//	Insert the convener password into the ASN.1 structure
	if (convener_password != NULL)
	{
		rc = convener_password->GetPasswordSelectorPDU(
				&gcc_pdu.u.request.u.conference_join_request.cjrq_convener_password);
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.request.u.conference_join_request.bit_mask |= CJRQ_CONVENER_PASSWORD_PRESENT;
		}
	}

    //	Insert the password challenge into the ASN.1 structure
	if (( password_challenge != NULL ) && (rc == GCC_NO_ERROR))
	{
		rc = password_challenge->GetPasswordChallengeResponsePDU (
								&gcc_pdu.u.request.u.conference_join_request.
									cjrq_password);
									
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.request.u.conference_join_request.bit_mask |=
												CJRQ_PASSWORD_PRESENT;
		}
	}

	//	Insert the caller identifier into the ASN.1 structure
	UINT cchCallerID = ::My_strlenW(pwszCallerID);
	if ((cchCallerID != 0 ) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.request.u.conference_join_request.cjrq_caller_id.value = pwszCallerID;
		gcc_pdu.u.request.u.conference_join_request.cjrq_caller_id.length = cchCallerID;
		gcc_pdu.u.request.u.conference_join_request.bit_mask |= CJRQ_CALLER_ID_PRESENT;
	}
	
 	//	Insert the user data into the ASN.1 structure
	if (( user_data_list != NULL ) && (rc == GCC_NO_ERROR))
	{
		rc = user_data_list->GetUserDataPDU (
								&gcc_pdu.u.request.u.conference_join_request.cjrq_user_data);
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.request.u.conference_join_request.bit_mask |= CJRQ_USER_DATA_PRESENT;
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					  		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
    		AddToMCSMessageQueue(packet, m_nidTopProvider, TOP_PRIORITY, FALSE);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}
	
	//	Cleanup after any errors
	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
	
	return rc;
}

/*
 *	GCCError	SendConferenceLockRequest()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference lock
 *		request PDU to the top provider.
 */
GCCError MCSUser::SendConferenceLockRequest()
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_LOCK_REQUEST_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceLockResponse()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference lock
 *		response PDU to the requesting node.
 */
GCCError	MCSUser::SendConferenceLockResponse (
									UserID		source_node,
									GCCResult	result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_LOCK_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_lock_response.result =
							::TranslateGCCResultToLockResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, source_node, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceUnlockRequest()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference unlock
 *		request PDU to the top provider.
 */
GCCError	MCSUser::SendConferenceUnlockRequest ()
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_UNLOCK_REQUEST_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceUnlockResponse()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference unlock
 *		response PDU to the requesting node.
 */
GCCError	MCSUser::SendConferenceUnlockResponse (
									UserID		source_node,
									GCCResult	result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_UNLOCK_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_unlock_response.result =
							::TranslateGCCResultToUnlockResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, source_node, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceLockIndication()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object of the top provider
 *		to send a conference lock indication PDU to one or all other nodes
 *		that are registered in the conference.
 */
GCCError	MCSUser::SendConferenceLockIndication(
									BOOL		uniform_send,
									UserID		source_node)
{
	GCCError 				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_LOCK_INDICATION_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(
			        packet,
			        uniform_send ? BROADCAST_CHANNEL_ID : source_node,
			        HIGH_PRIORITY,
			        uniform_send);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceUnlockIndication()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object of the top provider
 *		to send a conference unlock indication PDU to one or all other nodes
 *		that are registered in the conference.
 */
GCCError MCSUser::SendConferenceUnlockIndication(
									BOOL		uniform_send,
									UserID		source_node)
{
	GCCError 				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_UNLOCK_INDICATION_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(
                    packet,
                    uniform_send ? BROADCAST_CHANNEL_ID : source_node,
                    HIGH_PRIORITY,
                    uniform_send);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/******************************* Registry Calls ******************************/

/*
 *	void	RegistryRegisterChannelRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a channel in
 *		the application registry.
 */
void	MCSUser::RegistryRegisterChannelRequest(
									CRegKeyContainer        *registry_key_data,
									ChannelID				channel_id,
									EntityID				entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN;

	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_register_channel_request.key);
							
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_register_channel_request.channel_id =
																	channel_id;
		gcc_pdu.u.request.u.registry_register_channel_request.entity_id =
																	entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					  		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			ERROR_OUT(("MCSUser::RegistryRegisterChannelRequest: Error creating packet"));
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	MCSUser::RegistryAssignTokenRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a token in
 *		the application registry.  Note that there is no token ID included in
 *		this request.  The token ID is allocated at the top provider.
 */
void	MCSUser::RegistryAssignTokenRequest (	
										CRegKeyContainer    *registry_key_data,
										EntityID			entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
		
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN;
	
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    					registry_assign_token_request.registry_key);
							
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_assign_token_request.entity_id = entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					 		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}
		
	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistrySetParameterRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a parameter in
 *		the application registry.  Note that parameter to be registered is
 *		included in this request.
 */
void	MCSUser::RegistrySetParameterRequest (
							CRegKeyContainer        *registry_key_data,
							LPOSTR			        parameter_value,
							GCCModificationRights	modification_rights,
							EntityID				entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_SET_PARAMETER_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.registry_set_parameter_request.bit_mask = 0;
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    			&gcc_pdu.u.request.u.
			    				registry_set_parameter_request.key);

	if (error_value == GCC_NO_ERROR)
	{
		if (parameter_value != NULL)
		{
			gcc_pdu.u.request.u.registry_set_parameter_request.
				registry_set_parameter.length =
					parameter_value->length;
					
			memcpy (gcc_pdu.u.request.u.registry_set_parameter_request.
						registry_set_parameter.value,
					parameter_value->value,
					parameter_value->length);
		}
		else
		{
			gcc_pdu.u.request.u.registry_set_parameter_request.
				registry_set_parameter.length = 0;
		}

		gcc_pdu.u.request.u.registry_set_parameter_request.entity_id =
																	entity_id;

		//	Set up the modification rights here if it exists
		if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
		{
			gcc_pdu.u.request.u.registry_set_parameter_request.bit_mask |=
											PARAMETER_MODIFY_RIGHTS_PRESENT;
			
			gcc_pdu.u.request.u.registry_set_parameter_request.
						parameter_modify_rights =
							(RegistryModificationRights)modification_rights;
		}

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					 		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryRetrieveEntryRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to retrieve an registry item
 *		from the registry.
 */
void	MCSUser::RegistryRetrieveEntryRequest (
										CRegKeyContainer    *registry_key_data,
										EntityID			entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN;
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_retrieve_entry_request.key);
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_retrieve_entry_request.entity_id =
																	entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					  		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	
		registry_key_data->FreeRegistryKeyDataPDU();
	}
	else
		error_value = GCC_ALLOCATION_FAILURE;

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
    }
}

/*
 *	void	RegistryDeleteEntryRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to delete a registry item
 *		from the registry.
 */
void	MCSUser::RegistryDeleteEntryRequest (	
										CRegKeyContainer    *registry_key_data,
										EntityID			entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN;

	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_delete_entry_request.key);

	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_delete_entry_request.entity_id = entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}
	
	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryMonitorRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to monitor a registry item
 *		in the registry.
 */
void		MCSUser::RegistryMonitorRequest (	
						CRegKeyContainer        *registry_key_data,
						EntityID				entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN;
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_monitor_entry_request.key);
							
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_monitor_entry_request.entity_id= entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE; 	
		    delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}
	
	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryAllocateHandleRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to allocate a number of
 *		handles from the application registry.
 */
void MCSUser::RegistryAllocateHandleRequest(
						UINT					number_of_handles,
						EntityID				entity_id )
{
	GCCError				error_value = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN;
	
	gcc_pdu.u.request.u.registry_allocate_handle_request.number_of_handles = (USHORT) number_of_handles;
	gcc_pdu.u.request.u.registry_allocate_handle_request.entity_id= entity_id;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
					   	PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryAllocateHandleResponse()
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to respond to an allocate
 *		handle request from an APE at a remote node.  The allocated handles
 *		are passed back here.
 */
void	MCSUser::RegistryAllocateHandleResponse (
						UINT					number_of_handles,
						UINT					registry_handle,
						EntityID				requester_entity_id,
						UserID					requester_node_id,
						GCCResult				result)
{
	GCCError				error_value = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN;

	gcc_pdu.u.response.u.registry_allocate_handle_response.number_of_handles = (USHORT) number_of_handles;
	gcc_pdu.u.response.u.registry_allocate_handle_response.entity_id = requester_entity_id;
	gcc_pdu.u.response.u.registry_allocate_handle_response.first_handle = (Handle) registry_handle;

	if (result == GCC_RESULT_SUCCESSFUL)
	{
		gcc_pdu.u.response.u.registry_allocate_handle_response.result = RARS_RESULT_SUCCESS;
	}
	else
	{
		gcc_pdu.u.response.u.registry_allocate_handle_response.result = NO_HANDLES_AVAILABLE;
	}

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
					   	PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, requester_node_id, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	void	RegistryResponse()
 *
 *	Public Function Description:
 *		This routine is used to respond to all the registry request except
 *		allocate handle.  It formulates the response PDU and queues it for
 *		delivery.
 */
void	MCSUser::RegistryResponse (
						RegistryResponsePrimitiveType	primitive_type,
						UserID							requester_owner_id,
						EntityID						requester_entity_id,
						CRegKeyContainer                *registry_key_data,
						CRegItem                        *registry_item_data,
						GCCModificationRights			modification_rights,
						UserID							entry_owner_id,
						EntityID						entry_entity_id,
						GCCResult						result)
{
	GCCError				error_value;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	DebugEntry(MCSUser::RegistryResponse);

	/*
	**	Encode the conference join response PDU, along with the sequence
	**	number.
	*/
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = REGISTRY_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.registry_response.bit_mask = 0;

	error_value = registry_key_data->GetRegistryKeyDataPDU(&gcc_pdu.u.response.u.registry_response.key);
	if (error_value == GCC_NO_ERROR)
	{
		if (registry_item_data != NULL)
		{
			registry_item_data->GetRegistryItemDataPDU(&gcc_pdu.u.response.u.registry_response.item);
		}
		else
        {
			gcc_pdu.u.response.u.registry_response.item.choice = VACANT_CHOSEN;
        }

		TRACE_OUT(("MCSUser: RegistryResponse: item_type=%d", (UINT) gcc_pdu.u.response.u.registry_response.item.choice));

		//	Set up the entry owner
		if (entry_owner_id != 0)
		{
			gcc_pdu.u.response.u.registry_response.owner.choice = OWNED_CHOSEN;
			gcc_pdu.u.response.u.registry_response.owner.u.owned.node_id = entry_owner_id;
			gcc_pdu.u.response.u.registry_response.owner.u.owned.entity_id = entry_entity_id;
		}
		else
		{
			gcc_pdu.u.response.u.registry_response.owner.choice = NOT_OWNED_CHOSEN;
		}

		//	Set up the requesters entity ID
		gcc_pdu.u.response.u.registry_response.entity_id = requester_entity_id;

		//	Set up the primitive type
		gcc_pdu.u.response.u.registry_response.primitive_type = primitive_type;

		gcc_pdu.u.response.u.registry_response.result =
						::TranslateGCCResultToRegistryResp(result);

		if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
		{
			gcc_pdu.u.response.u.registry_response.bit_mask |=
										RESPONSE_MODIFY_RIGHTS_PRESENT;

			gcc_pdu.u.response.u.registry_response.response_modify_rights =
						(RegistryModificationRights)modification_rights;
		}

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, requester_owner_id, HIGH_PRIORITY, FALSE);
		}
		else
        {
            ResourceFailureHandler();
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	DebugExitVOID(MCSUser::RegistryResponse);
}

/*
 *	void	RegistryMonitorEntryIndication()
 *
 *	Public Function Description:
 *		This routine is used by the top provider to issue a monitor
 *		indication anytime a registry entry that is being monitored changes.
 */
void	MCSUser::RegistryMonitorEntryIndication ( 	
						CRegKeyContainer	            *registry_key_data,
						CRegItem                        *registry_item_data,
						UserID							entry_owner_id,
						EntityID						entry_entity_id,
						GCCModificationRights			modification_rights)
{
	GCCError				error_value;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	/*
	**	Encode the conference join response PDU, along with the sequence
	**	number.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.registry_monitor_entry_indication.bit_mask = 0;
	
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    			&gcc_pdu.u.indication.u.
			    					registry_monitor_entry_indication.key);
							
	if (error_value == GCC_NO_ERROR)
	{
		registry_item_data->GetRegistryItemDataPDU(&gcc_pdu.u.indication.u.registry_monitor_entry_indication.item);

        //	Set up the entry owner
		if (entry_owner_id != 0)
		{
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.choice = OWNED_CHOSEN;
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.u.owned.node_id = entry_owner_id;
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.u.owned.entity_id = entry_entity_id;
		}
		else
		{
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.choice = NOT_OWNED_CHOSEN;
		}
		
		if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
		{
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.bit_mask |= RESPONSE_MODIFY_RIGHTS_PRESENT;
			
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.entry_modify_rights =
						(RegistryModificationRights)modification_rights;
		}

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
        {
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}


/************************************************************************/

/*
 *	GCCError	AppInvokeIndication()
 *
 *	Public Function Description:
 *		This routine is used to send an application invoke indication to
 *		every node in the conference.
 */
GCCError 	MCSUser::AppInvokeIndication(
					CInvokeSpecifierListContainer	*invoke_specifier_list,
                    GCCSimpleNodeList               *pNodeList)
{
	GCCError								rc = GCC_NO_ERROR;
	PPacket									packet;
	GCCPDU									gcc_pdu;
	PacketError								packet_error;
	PSetOfDestinationNodes					new_destination_node;
	PSetOfDestinationNodes					old_destination_node = NULL;
	PSetOfDestinationNodes					pDstNodesToFree = NULL;
	UINT									i;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = APPLICATION_INVOKE_INDICATION_CHOSEN;

	gcc_pdu.u.indication.u.application_invoke_indication.bit_mask = 0;
	gcc_pdu.u.indication.u.application_invoke_indication.destination_nodes = NULL;
	gcc_pdu.u.indication.u.application_invoke_indication.application_protocol_entity_list = NULL;

	//	First, set up the destination node list
	if (pNodeList->cNodes != 0)
	{
		gcc_pdu.u.indication.u.application_invoke_indication.bit_mask |=
													DESTINATION_NODES_PRESENT;

		for (i = 0; i < pNodeList->cNodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_destination_node = new SetOfDestinationNodes;
			if (new_destination_node != NULL)
			{
				if (gcc_pdu.u.indication.u.application_invoke_indication.
													destination_nodes == NULL)
				{
					gcc_pdu.u.indication.u.application_invoke_indication.
									destination_nodes = new_destination_node;
					pDstNodesToFree = new_destination_node;
				}
				else
				{
					old_destination_node->next = new_destination_node;
				}

				old_destination_node = new_destination_node;
				new_destination_node->next = NULL;
				new_destination_node->value = pNodeList->aNodeIDs[i];
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		rc = invoke_specifier_list->GetApplicationInvokeSpecifierListPDU(
					&gcc_pdu.u.indication.u.application_invoke_indication.
						application_protocol_entity_list);
	}

	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

    if (NULL != pDstNodesToFree)
    {
        PSetOfDestinationNodes p;
        while (NULL != (p = pDstNodesToFree))
        {
            pDstNodesToFree = pDstNodesToFree->next;
            delete p;
        }
    }

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

   return rc;
}

/*
 *	GCCError	TextMessageIndication()
 *
 *	Public Function Description:
 *		This routine is used to send a text message to either a specific node
 *		or to every node in the conference.
 */
GCCError 	MCSUser::TextMessageIndication (
						LPWSTR						pwszTextMsg,
						UserID						destination_node )
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;
	LPWSTR					pwszMsg;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = TEXT_MESSAGE_INDICATION_CHOSEN;

	if (NULL != (pwszMsg = ::My_strdupW(pwszTextMsg)))
	{
		gcc_pdu.u.indication.u.text_message_indication.message.length = ::lstrlenW(pwszMsg);
		gcc_pdu.u.indication.u.text_message_indication.message.value = pwszMsg;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(
				        packet,
				        (destination_node == 0) ? BROADCAST_CHANNEL_ID : destination_node,
				        HIGH_PRIORITY,
				        FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }

		delete pwszMsg;
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return rc;
}

/*
 *	GCCError	ConferenceAssistanceIndication()
 *
 *	Public Function Description:
 *		This routine is used to send a conference assistance indication to
 *		every node in the conference.
 */
GCCError		MCSUser::ConferenceAssistanceIndication (
						UINT						number_of_user_data_members,
						PGCCUserData		*		user_data_list)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;
	CUserDataListContainer  *user_data_record;

 	DebugEntry(MCSUser::ConferenceAssistanceIndication);

	//	Encode the PDU
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_ASSISTANCE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_assistance_indication.bit_mask = 0;

	//	Construct the user data list container
	if ((number_of_user_data_members != 0) && (rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		user_data_record = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
		if (user_data_record == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		user_data_record = NULL;
    }

	if ((user_data_record != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = user_data_record->GetUserDataPDU(
			&gcc_pdu.u.indication.u.conference_assistance_indication.
									cain_user_data);

		gcc_pdu.u.indication.u.conference_assistance_indication.bit_mask
									|= CAIN_USER_DATA_PRESENT;
	}

	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}

	// Clean up containers
	if (user_data_record != NULL)
	{
		user_data_record->Release();
	}

	return (rc);
}



/*
 *	GCCError	ConferenceTransferRequest()
 *
 *	Public Function Description:
 *		This routine is used to send a conference transfer request to the
 *		top provider in the conference.
 */
GCCError	MCSUser::ConferenceTransferRequest (
				PGCCConferenceName		destination_conference_name,
				GCCNumericString		destination_conference_modifier,
				CNetAddrListContainer   *destination_address_list,
				UINT					number_of_destination_nodes,
				PUserID					destination_node_list,
				CPassword               *password)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;
	UINT						string_length;
	PSetOfTransferringNodesRq	new_set_of_nodes;
	PSetOfTransferringNodesRq	old_set_of_nodes;
	UINT						i;

	DebugEntry(MCSUser::ConferenceTransferRequest);

	//	Encode the PDU
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_TRANSFER_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.conference_transfer_request.bit_mask = 0;
	
	//	First get the conference name (either numeric or text).
	if (destination_conference_name->numeric_string != NULL)
	{
		gcc_pdu.u.request.u.conference_transfer_request.conference_name.choice =
											NAME_SELECTOR_NUMERIC_CHOSEN;
		
		lstrcpy (gcc_pdu.u.request.u.conference_transfer_request.
					conference_name.u.name_selector_numeric,
				(LPSTR)destination_conference_name->numeric_string);
	}
	else
	{
		//	Use a unicode string to determine the length
		gcc_pdu.u.request.u.conference_transfer_request.conference_name.choice =
											NAME_SELECTOR_TEXT_CHOSEN;

		string_length = ::My_strlenW(destination_conference_name->text_string);

		gcc_pdu.u.request.u.conference_transfer_request.
					conference_name.u.name_selector_text.length = string_length;
		
		gcc_pdu.u.request.u.conference_transfer_request.
					conference_name.u.name_selector_text.value =
							destination_conference_name->text_string;
	}
	

	//	Next get the conference name modifier if it exists
	if (destination_conference_modifier != NULL)
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
											CTRQ_CONFERENCE_MODIFIER_PRESENT;
	
		lstrcpy (gcc_pdu.u.request.u.conference_transfer_request.
					ctrq_conference_modifier,
				(LPSTR)destination_conference_modifier);
	}

	//	Get the network address list if it exist
	if (destination_address_list != NULL)
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
											CTRQ_NETWORK_ADDRESS_PRESENT;
		
		rc = destination_address_list->GetNetworkAddressListPDU (
						&gcc_pdu.u.request.u.conference_transfer_request.
							ctrq_net_address);
	}

	//	Get the destination node list if it exists
	if ((number_of_destination_nodes != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
											CTRQ_TRANSFERRING_NODES_PRESENT;
											
		old_set_of_nodes = NULL;
		gcc_pdu.u.request.u.conference_transfer_request.
									ctrq_transferring_nodes = NULL;
									
		for (i = 0; i <	number_of_destination_nodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_set_of_nodes = new SetOfTransferringNodesRq;
			if (new_set_of_nodes == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;	
			}
			else
				new_set_of_nodes->next = NULL;

			if (old_set_of_nodes == NULL)
			{
				gcc_pdu.u.request.u.conference_transfer_request.
									ctrq_transferring_nodes = new_set_of_nodes;
			}
			else
				old_set_of_nodes->next = new_set_of_nodes;

			old_set_of_nodes = new_set_of_nodes;
			new_set_of_nodes->value = destination_node_list[i];
		}
	}

	//	Get the password if it exists
	if ((password != NULL) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
													CTRQ_PASSWORD_PRESENT;
		
		rc = password->GetPasswordSelectorPDU (
				&gcc_pdu.u.request.u.conference_transfer_request.ctrq_password);
	}
	
	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	// Clean up the node list if it was created
	if (gcc_pdu.u.request.u.conference_transfer_request.bit_mask &
											CTRQ_TRANSFERRING_NODES_PRESENT)
	{
		old_set_of_nodes = gcc_pdu.u.request.u.conference_transfer_request.
									ctrq_transferring_nodes;
		while (old_set_of_nodes != NULL)
		{
			new_set_of_nodes = old_set_of_nodes->next;
			delete old_set_of_nodes;
			old_set_of_nodes = new_set_of_nodes;
		}
	}

	return rc;
}


/*
 *	GCCError	ConferenceTransferIndication()
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send out the transfer
 *		indication to every node in the conference.  It is each nodes
 *		responsiblity to search the destination node list to see if
 *		it should transfer.
 */
GCCError	MCSUser::ConferenceTransferIndication (
				PGCCConferenceName		destination_conference_name,
				GCCNumericString		destination_conference_modifier,
				CNetAddrListContainer   *destination_address_list,
				UINT					number_of_destination_nodes,
				PUserID					destination_node_list,
				CPassword               *password)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;
	UINT						string_length;
	PSetOfTransferringNodesIn	new_set_of_nodes;
	PSetOfTransferringNodesIn	old_set_of_nodes;
	UINT						i;

	DebugEntry(MCSUser::ConferenceTransferIndication);

	//	Encode the PDU
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TRANSFER_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask = 0;
	
	//	First get the conference name (either numeric or text).
	if (destination_conference_name->numeric_string != NULL)
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.
									conference_name.choice =
											NAME_SELECTOR_NUMERIC_CHOSEN;
		
		lstrcpy (gcc_pdu.u.indication.u.conference_transfer_indication.
					conference_name.u.name_selector_numeric,
				(LPSTR)destination_conference_name->numeric_string);
	}
	else
	{
		//	Use a unicode string to determine the length
		gcc_pdu.u.indication.u.conference_transfer_indication.
									conference_name.choice =
											NAME_SELECTOR_TEXT_CHOSEN;

		string_length = ::My_strlenW(destination_conference_name->text_string);

		gcc_pdu.u.indication.u.conference_transfer_indication.
					conference_name.u.name_selector_text.length = string_length;
		
		gcc_pdu.u.indication.u.conference_transfer_indication.
					conference_name.u.name_selector_text.value =
							destination_conference_name->text_string;
	}
	

	//	Next get the conference name modifier if it exists
	if (destination_conference_modifier != NULL)
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
											CTIN_CONFERENCE_MODIFIER_PRESENT;
	
		lstrcpy (gcc_pdu.u.indication.u.conference_transfer_indication.
					ctin_conference_modifier,
				(LPSTR)destination_conference_modifier);
	}

	//	Get the network address list if it exist
	if (destination_address_list != NULL)
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
											CTIN_NETWORK_ADDRESS_PRESENT;
		
		rc = destination_address_list->GetNetworkAddressListPDU (
						&gcc_pdu.u.indication.u.conference_transfer_indication.
							ctin_net_address);
	}

	//	Get the destination node list if it exists
	if ((number_of_destination_nodes != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
											CTIN_TRANSFERRING_NODES_PRESENT;
											
		old_set_of_nodes = NULL;
		gcc_pdu.u.indication.u.conference_transfer_indication.
									ctin_transferring_nodes = NULL;
									
		for (i = 0; i <	number_of_destination_nodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_set_of_nodes = new SetOfTransferringNodesIn;
			if (new_set_of_nodes == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;	
			}
			else
				new_set_of_nodes->next = NULL;

			if (old_set_of_nodes == NULL)
			{
				gcc_pdu.u.indication.u.conference_transfer_indication.
									ctin_transferring_nodes = new_set_of_nodes;
			}
			else
				old_set_of_nodes->next = new_set_of_nodes;

			old_set_of_nodes = new_set_of_nodes;
			new_set_of_nodes->value = destination_node_list[i];
		}
	}

	//	Get the password if it exists
	if ((password != NULL) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
													CTIN_PASSWORD_PRESENT;
		
		rc = password->GetPasswordSelectorPDU (
						&gcc_pdu.u.indication.u.conference_transfer_indication.
							ctin_password);
	}
	
	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	// Clean up the node list if it was created
	if (gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask &
											CTIN_TRANSFERRING_NODES_PRESENT)
	{
		old_set_of_nodes = gcc_pdu.u.indication.u.
						conference_transfer_indication.ctin_transferring_nodes;
		while (old_set_of_nodes != NULL)
		{
			new_set_of_nodes = old_set_of_nodes->next;
			delete old_set_of_nodes;
			old_set_of_nodes = new_set_of_nodes;
		}
	}

	DebugExitINT(MCSUser::ConferenceTransferIndication, rc);
	return rc;
}


/*
 *	GCCError	ConferenceTransferResponse()
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send back a response to
 *		the node that made a transfer request.  The info specified in the
 *		request is included in the response to match request to response.
 */
GCCError	MCSUser::ConferenceTransferResponse (
				UserID					requesting_node_id,
				PGCCConferenceName		destination_conference_name,
				GCCNumericString		destination_conference_modifier,
				UINT					number_of_destination_nodes,
 				PUserID					destination_node_list,
				GCCResult				result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;
	UINT						string_length;
	PSetOfTransferringNodesRs	new_set_of_nodes;
	PSetOfTransferringNodesRs	old_set_of_nodes;
	UINT						i;

	DebugEntry(MCSUser::ConferenceTransferResponse);

	//	Encode the PDU
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_TRANSFER_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_transfer_response.bit_mask = 0;
	
	//	First get the conference name (either numeric or text).
	if (destination_conference_name->numeric_string != NULL)
	{
		gcc_pdu.u.response.u.conference_transfer_response.
									conference_name.choice =
											NAME_SELECTOR_NUMERIC_CHOSEN;
		
        ::lstrcpyA(gcc_pdu.u.response.u.conference_transfer_response.
					conference_name.u.name_selector_numeric,
				(LPSTR)destination_conference_name->numeric_string);
	}
	else
	{
		//	Use a unicode string to determine the length
		gcc_pdu.u.response.u.conference_transfer_response.
									conference_name.choice =
											NAME_SELECTOR_TEXT_CHOSEN;

		string_length = ::My_strlenW(destination_conference_name->text_string);

		gcc_pdu.u.response.u.conference_transfer_response.
					conference_name.u.name_selector_text.length = string_length;
		
		gcc_pdu.u.response.u.conference_transfer_response.
					conference_name.u.name_selector_text.value =
							destination_conference_name->text_string;
	}
	

	//	Next get the conference name modifier if it exists
	if (destination_conference_modifier != NULL)
	{
		gcc_pdu.u.response.u.conference_transfer_response.bit_mask |=
											CTRS_CONFERENCE_MODIFIER_PRESENT;
	
        ::lstrcpyA(gcc_pdu.u.response.u.conference_transfer_response.
					ctrs_conference_modifier,
				(LPSTR)destination_conference_modifier);
	}

	//	Get the destination node list if it exists
	if ((number_of_destination_nodes != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.response.u.conference_transfer_response.bit_mask |=
											CTRS_TRANSFERRING_NODES_PRESENT;
											
		old_set_of_nodes = NULL;
		gcc_pdu.u.response.u.conference_transfer_response.
									ctrs_transferring_nodes = NULL;
									
		for (i = 0; i <	number_of_destination_nodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_set_of_nodes = new SetOfTransferringNodesRs;
			if (new_set_of_nodes == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;	
			}
			else
				new_set_of_nodes->next = NULL;

			if (old_set_of_nodes == NULL)
			{
				gcc_pdu.u.response.u.conference_transfer_response.
									ctrs_transferring_nodes = new_set_of_nodes;
			}
			else
				old_set_of_nodes->next = new_set_of_nodes;

			old_set_of_nodes = new_set_of_nodes;
			new_set_of_nodes->value = destination_node_list[i];
		}
	}

	//	Set up the result
	if (result == GCC_RESULT_SUCCESSFUL)
	{
		gcc_pdu.u.response.u.conference_transfer_response.result =
														CTRANS_RESULT_SUCCESS;
	}
	else
	{
		gcc_pdu.u.response.u.conference_transfer_response.result =
												CTRANS_RESULT_INVALID_REQUESTER;
	}

	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, requesting_node_id, HIGH_PRIORITY, FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	// Clean up the node list if it was created
	if (gcc_pdu.u.response.u.conference_transfer_response.bit_mask &
											CTRS_TRANSFERRING_NODES_PRESENT)
	{
		old_set_of_nodes = gcc_pdu.u.response.u.
						conference_transfer_response.ctrs_transferring_nodes;
		while (old_set_of_nodes != NULL)
		{
			new_set_of_nodes = old_set_of_nodes->next;
			delete old_set_of_nodes;
			old_set_of_nodes = new_set_of_nodes;
		}
	}

	DebugExitINT(MCSUser::ConferenceTransferResponse, rc);
	return rc;
}


/*
 *	GCCError	ConferenceAddRequest()
 *
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 */
GCCError	MCSUser::ConferenceAddRequest (
						TagNumber				conference_add_tag,
						UserID					requesting_node,
						UserID					adding_node,
						UserID					target_node,
						CNetAddrListContainer   *network_address_container,
						CUserDataListContainer  *user_data_container)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	DebugEntry(MCSUser::ConferenceAddRequest);

	//	Encode the PDU
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_ADD_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.conference_add_request.bit_mask = 0;
	
	//	Get the network address list if it exist
	if (network_address_container != NULL)
	{
		//	Set up the network address portion of the pdu
		rc = network_address_container->GetNetworkAddressListPDU (
						&gcc_pdu.u.request.u.conference_add_request.
							add_request_net_address);
		
		//	Set up the user data container
		if ((rc == GCC_NO_ERROR) && (user_data_container != NULL))
		{
			rc = user_data_container->GetUserDataPDU (
				&gcc_pdu.u.request.u.conference_add_request.carq_user_data);
								
			if (rc == GCC_NO_ERROR)
			{
				gcc_pdu.u.request.u.conference_add_request.bit_mask |=
														CARQ_USER_DATA_PRESENT;
			}
		}
	
		//	Encode the PDU
		if (rc == GCC_NO_ERROR)
		{
			//	specify the requesting node					
			gcc_pdu.u.request.u.conference_add_request.requesting_node =
															requesting_node;
		
			if (adding_node != 0)
			{
				gcc_pdu.u.request.u.conference_add_request.bit_mask |=
															ADDING_MCU_PRESENT;
				gcc_pdu.u.request.u.conference_add_request.adding_mcu =
															adding_node;
			}

			gcc_pdu.u.request.u.conference_add_request.tag = conference_add_tag;

			DBG_SAVE_FILE_LINE
			packet = new Packet((PPacketCoder) g_GCCCoder,
								PACKED_ENCODING_RULES,
								&gcc_pdu,
								GCC_PDU,
								TRUE,
								&packet_error);
			if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
			{
				AddToMCSMessageQueue(packet, target_node, HIGH_PRIORITY, FALSE);
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
				delete packet;
            }
		}
	}
	else
    {
		rc = GCC_BAD_NETWORK_ADDRESS;
    }

	DebugExitINT(MCSUser::ConferenceAddRequest, rc);
	return rc;
}


/*
 *	GCCError	ConferenceAddResponse()
 *
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 */
GCCError	MCSUser::ConferenceAddResponse(
						TagNumber				add_request_tag,
						UserID					requesting_node,
						CUserDataListContainer  *user_data_container,
						GCCResult				result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	DebugEntry(MCSUser::ConferenceAddResponse);

	//	Encode the PDU
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_ADD_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_add_response.bit_mask = 0;
	
	//	Set up the user data container
	if ((rc == GCC_NO_ERROR) && (user_data_container != NULL))
	{
		rc = user_data_container->GetUserDataPDU (
			&gcc_pdu.u.response.u.conference_add_response.cars_user_data);
							
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.response.u.conference_add_response.bit_mask |=
													CARS_USER_DATA_PRESENT;
		}
	}

	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		gcc_pdu.u.response.u.conference_add_response.tag = add_request_tag;
		
		gcc_pdu.u.response.u.conference_add_response.result =
						::TranslateGCCResultToAddResult(result);

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, requesting_node, HIGH_PRIORITY, FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	DebugExitINT(MCSUser::ConferenceAddResponse, rc);
	return rc;
}


/************************* Conductorship Calls ***********************/
/*
 *	GCCError	ConductorTokenGrab()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to grab the conductor token.
 */
GCCError	MCSUser::ConductorTokenGrab()
{
	MCSError	mcs_error;
	
	mcs_error = g_pMCSIntf->TokenGrabRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);
											
	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}

/*
 *	GCCError	ConductorTokenRelease()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to release the conductor token.
 */
GCCError	MCSUser::ConductorTokenRelease()
{
	MCSError	mcs_error;
	
	mcs_error = g_pMCSIntf->TokenReleaseRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);
											
	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}
/*
 *	GCCError	ConductorTokenPlease()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to request the conductor token from
 *		the current conductor.
 */
GCCError	MCSUser::ConductorTokenPlease()
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenPleaseRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);

	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}

/*
 *	GCCError	ConductorTokenGive ()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to give the conductor token to the
 *		specified node.
 */
GCCError	MCSUser::ConductorTokenGive(UserID recipient_user_id)
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenGiveRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID,
														recipient_user_id);

	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}

/*
 *	GCCError	ConductorTokenGiveResponse ()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to respond to a conductor give
 *		request.
 */
GCCError	MCSUser::ConductorTokenGiveResponse(Result result)
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenGiveResponse(m_pMCSSap, CONDUCTOR_TOKEN_ID, result);

	return g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
}

/*
 *	GCCError	ConductorTokenTest ()
 *
 *	Public Function Description:
 *		This routine is used to test the current state of the conductor token
 *		(is it grabbed or not).
 */
GCCError	MCSUser::ConductorTokenTest()
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenTestRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);

	return g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
}


/*
 *	GCCError	SendConductorAssignIndication()
 *
 *	Public Function Description:
 *		This routine sends a conductor assign indication to all the
 *		nodes in the conference.
 */
GCCError	MCSUser::SendConductorAssignIndication(
								UserID			conductor_user_id)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConductorAssignIndication pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_ASSIGN_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_assign_indication.user_id =
															conductor_user_id;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, TOP_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConductorReleaseIndication()
 *
 *	Public Function Description:
 *		This routine sends a conductor release indication to all the
 *		nodes in the conference.
 */
GCCError	MCSUser::SendConductorReleaseIndication()
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConductorAssignIndication pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_RELEASE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_release_indication.placeholder = 0;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, TOP_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}
		
/*
 *	GCCError	SendConductorPermitAsk ()
 *
 *	Public Function Description:
 *		This routine sends a conductor permission ask request directly to the
 *		conductor node.
 */
GCCError	MCSUser::SendConductorPermitAsk (
						BOOL					grant_permission)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConductorPermissionAskIndication pdu structure to be passed
	**	in the constructor of the packet class.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_permission_ask_indication.
								permission_is_granted = (ASN1bool_t)grant_permission;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConductorPermitGrant ()
 *
 *	Public Function Description:
 *		This routine sends a conductor permission grant indication to every
 *		node in the conference.  Usually issued when permissions change.
 */
GCCError	MCSUser::SendConductorPermitGrant (
				UINT					number_granted,
				PUserID					granted_node_list,
				UINT					number_waiting,
				PUserID					waiting_node_list)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;
	PPermissionList		permission_list;
	PPermissionList		previous_permission_list;
	PWaitingList			waiting_list;
	PWaitingList			previous_waiting_list;
	UINT					i;
	
	/*
	**	Fill in the ConductorPermissionAskIndication pdu structure to be passed
	**	in the constructor of the packet class.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_permission_grant_indication.bit_mask = 0;

	//	First fill in the granted node permission list
	gcc_pdu.u.indication.u.
		conductor_permission_grant_indication.permission_list = NULL;
	previous_permission_list = NULL;
	for (i = 0; i < number_granted; i++)
	{
		DBG_SAVE_FILE_LINE
		permission_list = new PermissionList;
		if (permission_list == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
			break;
		}

		if (previous_permission_list == NULL)
		{
			gcc_pdu.u.indication.u.conductor_permission_grant_indication.
											permission_list = permission_list;
		}
		else
			previous_permission_list->next = permission_list;

		previous_permission_list = permission_list;

		permission_list->value = granted_node_list[i];
		permission_list->next = NULL;
	}

	//	If waiting list exists fill it in
	if ((number_waiting != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.indication.u.conductor_permission_grant_indication.bit_mask =
														WAITING_LIST_PRESENT;
		gcc_pdu.u.indication.u.
			conductor_permission_grant_indication.waiting_list = NULL;
		previous_waiting_list = NULL;
		for (i = 0; i < number_waiting; i++)
		{
			DBG_SAVE_FILE_LINE
			waiting_list = new WaitingList;
			if (waiting_list == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}

			if (previous_waiting_list == NULL)
			{
				gcc_pdu.u.indication.u.conductor_permission_grant_indication.
												waiting_list = waiting_list;
			}
			else
				previous_waiting_list->next = waiting_list;

			previous_waiting_list = waiting_list;

			waiting_list->value = waiting_node_list[i];
			waiting_list->next = NULL;
		}
	}

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, TOP_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/**********************************************************************/


/*****************	Miscelaneous calls ******************************/
/*
 *	GCCError	TimeRemainingRequest()
 *
 *	Public Function Description:
 *		This routine sends out an indication to every node in the
 *		conference informing how much time is remaining in the conference.
 */
GCCError	MCSUser::TimeRemainingRequest (
						UINT					time_remaining,
						UserID					node_id)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the TimeRemainingRequest pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_time_remaining_indication.bit_mask = 0;
	
	gcc_pdu.u.indication.u.conference_time_remaining_indication.time_remaining =
																time_remaining;
	
	if (node_id != 0)
	{
		gcc_pdu.u.indication.u.conference_time_remaining_indication.bit_mask |=
										TIME_REMAINING_NODE_ID_PRESENT;
		gcc_pdu.u.indication.u.conference_time_remaining_indication.
						time_remaining_node_id = node_id;
	}

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	TimeInquireRequest()
 *
 *	Public Function Description:
 *		This routine sends out a request for a time remaing update.
 */
GCCError	MCSUser::TimeInquireRequest (
						BOOL				time_is_conference_wide)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the TimeInquireRequest pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_time_inquire_indication.
							time_is_node_specific = (ASN1bool_t)time_is_conference_wide;
	
	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, CONVENER_CHANNEL_ID, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	ConferenceExtendIndication()
 *
 *	Public Function Description:
 *		This routine sends out an indication informing conference participants
 *		of an extension.
 */
GCCError	MCSUser::ConferenceExtendIndication (
						UINT						extension_time,
						BOOL				time_is_conference_wide)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConfernceExtendIndication pdu structure to be passed in the
	**	constructor of the packet class.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_time_extend_indication.
							time_to_extend = extension_time;
	gcc_pdu.u.indication.u.conference_time_extend_indication.
							time_is_node_specific = (ASN1bool_t)time_is_conference_wide;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, CONVENER_CHANNEL_ID, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	void	ConferenceJoinResponse()
 *
 *	Functional Description:
 * 		This function is called by the conference object of the
 * 		top provider when it wants to send the join response back to the gcc
 * 		provider that made the join request, through the directly connected
 * 		intermediate node. This function does the encoding of the join response
 *		PDU and also adds the sequence number sent in the request.
 */
void	MCSUser::ConferenceJoinResponse(
						UserID					receiver_id,
						BOOL					password_is_in_the_clear,
						BOOL					conference_locked,
						BOOL					conference_listed,
						GCCTerminationMethod	termination_method,
						CPassword               *password_challenge,
						CUserDataListContainer  *user_data_list,
						GCCResult				result)	
{
	GCCError				rc = GCC_NO_ERROR;	 	
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;
	TagNumber				lTagNum;

	if (0 == (lTagNum = m_ConfJoinResponseList2.Find(receiver_id)))
	{
		WARNING_OUT(("MCSUser::ConferenceJoinResponse: Unexpected Join Response"));
		return;
	}

	/*
	**	Encode the conference join response PDU, along with the sequence
	**	number.
	*/
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_JOIN_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_join_response.bit_mask = 0;

	/*
	**	Get the sequence number of the outstanding response from the
	**	list of seq # vs userID using the userID passed from above.
	*/
	gcc_pdu.u.response.u.conference_join_response.tag = lTagNum;
	
	// Remove this entry from the list.
	m_ConfJoinResponseList2.Remove(receiver_id);


	//	Get password challenge PDU
	if ((password_challenge != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = password_challenge->GetPasswordChallengeResponsePDU (
			&gcc_pdu.u.response.u.conference_join_response.cjrs_password);
			
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.response.u.conference_join_response.bit_mask |=
													CJRS_PASSWORD_PRESENT;
		}
	}
	
	//	Get user data list PDU
	if ((user_data_list != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = user_data_list->GetUserDataPDU (
			&gcc_pdu.u.response.u.conference_join_response.cjrs_user_data);
							
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.response.u.conference_join_response.bit_mask |=
													CJRS_USER_DATA_PRESENT;
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		gcc_pdu.u.response.u.conference_join_response.
												top_node_id = m_nidTopProvider;
		
		gcc_pdu.u.response.u.conference_join_response.
					clear_password_required = (ASN1bool_t)password_is_in_the_clear;

		gcc_pdu.u.response.u.conference_join_response.
					conference_is_locked = (ASN1bool_t)conference_locked;
		
		gcc_pdu.u.response.u.conference_join_response.
					conference_is_listed = (ASN1bool_t)conference_listed;

		gcc_pdu.u.response.u.conference_join_response.termination_method =
  									(TerminationMethod)termination_method;

		gcc_pdu.u.response.u.conference_join_response.result =
						::TranslateGCCResultToJoinResult(result);

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, receiver_id, TOP_PRIORITY, FALSE);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	ConferenceTerminateRequest()
 *
 *	Functional Description:
 *		This routine is used by a node subordinate to the top provider to
 *		request that the conference by terminated.
 */
void	MCSUser::ConferenceTerminateRequest(
									GCCReason				reason)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_TERMINATE_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.conference_terminate_request.reason =
				::TranslateGCCReasonToTerminateRqReason(reason);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	void	ConferenceTerminateResponse ()
 *
 *	Functional Description:
 *		This routine is used by the top provider to respond to a terminate
 *		request issued by a subordinate node.  The result indicates if the
 *		requesting node had the correct privileges.
 */
void	MCSUser::ConferenceTerminateResponse (	
						UserID					requester_id,
						GCCResult				result)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_TERMINATE_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_terminate_response.result =
					::TranslateGCCResultToTerminateResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, requester_id, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	GCCError	ConferenceTerminateIndication()
 *
 *	Functional Description:
 *		This routine is used by the top provider to send out a terminate
 *		indication to every node in the conference.
 */
void	MCSUser::ConferenceTerminateIndication (
						GCCReason				reason)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TERMINATE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_terminate_indication.reason =
					::TranslateGCCReasonToTerminateInReason(reason);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	void	EjectNodeFromConference()
 *
 *	Functional Description:
 *		This routine is used when attempting to eject a node from the
 *		conference.
 */
GCCError	MCSUser::EjectNodeFromConference (	UserID		ejected_node_id,
			  									GCCReason	reason)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;
	ChannelID				channel_id;
	BOOL					uniform_send;
	Priority				priority;
	PAlarm					alarm;
	
	if (ejected_node_id == m_nidMyself)
	{
		/*
		**	If the ejected node is this node we can immediately initiate the
		**	ejection.  There is no need to request this through the Top
		**	Provider.
		*/
		rc = InitiateEjectionFromConference (reason);
	}
	else
	{
		/*
		**	If the ejected node is a child node to this node we can directly
		**	eject it.  Otherwise the request is forwarded to the Top Provider.
		*/
		if (m_ChildUidConnHdlList2.Find(ejected_node_id) ||
			(m_nidTopProvider == m_nidMyself))
		{
			gcc_pdu.choice = INDICATION_CHOSEN;
			gcc_pdu.u.indication.choice =
										CONFERENCE_EJECT_USER_INDICATION_CHOSEN;
			gcc_pdu.u.indication.u.conference_eject_user_indication.
												node_to_eject = ejected_node_id;
			gcc_pdu.u.indication.u.conference_eject_user_indication.reason =
							::TranslateGCCReasonToEjectInd(reason);

			uniform_send = TRUE;
			channel_id = BROADCAST_CHANNEL_ID;

			//	If this is the top provider send the data at TOP priority
			if (m_nidTopProvider == m_nidMyself)
				priority = TOP_PRIORITY;
			else
				priority = HIGH_PRIORITY;
			
			/*
			**	Set up ejection alarm to automatically eject any misbehaving
			**	nodes.  Note that we only do this if we are directly connected
			**	to the node to be ejected.
			*/
			if (m_ChildUidConnHdlList2.Find(ejected_node_id))
			{
				DBG_SAVE_FILE_LINE
				alarm = new Alarm (EJECTED_NODE_TIMER_DURATION);
				if (alarm != NULL)
				{
					/*
					**	Here we save the alarm in a list of ejected nodes. This
					**	alarm is used to cleanup any misbehaving node.
					*/
					m_EjectedNodeAlarmList2.Append(ejected_node_id, alarm);
				}
				else
                {
					rc = GCC_ALLOCATION_FAILURE;
                }
			}
		}
		else
		{
			gcc_pdu.choice = REQUEST_CHOSEN;
			gcc_pdu.u.request.choice = CONFERENCE_EJECT_USER_REQUEST_CHOSEN;
			gcc_pdu.u.request.u.conference_eject_user_request.node_to_eject =
																ejected_node_id;

			//	The only valid reason is user initiated which is zero
			gcc_pdu.u.request.u.conference_eject_user_request.reason =
	      											CERQ_REASON_USER_INITIATED;
		
			uniform_send = FALSE;
			channel_id = m_nidTopProvider;
			priority = TOP_PRIORITY;
		}
		
		if (rc == GCC_NO_ERROR)
		{
			DBG_SAVE_FILE_LINE
			packet = new Packet((PPacketCoder) g_GCCCoder,
								PACKED_ENCODING_RULES,
								&gcc_pdu,
								GCC_PDU,
								TRUE,
								&packet_error);
			if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
			{
				AddToMCSMessageQueue(packet, channel_id, priority, uniform_send);
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
				delete packet;
            }
		}
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return rc;
}

/*
 *	void	SendEjectNodeResponse()
 *
 *	Functional Description:
 *		This routine is used by the top provider to respond to an eject
 *		user request.
 */
GCCError	MCSUser::SendEjectNodeResponse (	UserID		requester_id,
												UserID		node_to_eject,
												GCCResult	result)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	
	gcc_pdu.u.response.choice = CONFERENCE_EJECT_USER_RESPONSE_CHOSEN;
	
	gcc_pdu.u.response.u.conference_eject_user_response.node_to_eject =
															node_to_eject;
	
	gcc_pdu.u.response.u.conference_eject_user_response.result =
						::TranslateGCCResultToEjectResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, requester_id, HIGH_PRIORITY, FALSE);
	}
	else
    {
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
    }

	return rc;
}

/*
 *	void	RosterUpdateIndication()
 *
 *	Functional Description:
 *		This routine is used to forward a roster update indication either
 *		upward to the parent node or downward as a full refresh to all nodes
 *		in the conference.
 */
void	MCSUser::RosterUpdateIndication(PGCCPDU		gcc_pdu,
										BOOL		send_update_upward)
{
	PPacket					packet;
	PacketError				packet_error;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		if (send_update_upward)
		{
			AddToMCSMessageQueue(packet, m_nidParent, HIGH_PRIORITY, FALSE);
		}
		else
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
	}
	else
	{
        ResourceFailureHandler();
        delete packet;
	}
}

/*
 *	void	AddToMCSMessageQueue()
 *
 *	Private Function Description:
 * 		This function adds the out bound messages to a queue which is
 *		flushed in the next heartbeat when controller call FlushMessageQueue.
 *		In case memory allocation for messages holding the out bound inform-
 *		ation fails an owner call back is sent to conference object to
 *		indicate insufficient memory.
 *
 *	Formal Parameters:
 *		packet					-	(i)	Pointer to packet to queue up.
 *		send_data_request_info	-	(i)	Structure containing all the info
 *										necessary to deliver the packet.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */	
void MCSUser::
AddToMCSMessageQueue
(
	PPacket                 packet,
	ChannelID				channel_id,
	Priority				priority,
	BOOL    				uniform_send
)
{
	SEND_DATA_REQ_INFO *pReqInfo;

	DBG_SAVE_FILE_LINE
	pReqInfo = new SEND_DATA_REQ_INFO;
	if (pReqInfo != NULL)
	{
		pReqInfo->packet = packet;
		pReqInfo->channel_id = channel_id;
		pReqInfo->priority = priority;
		pReqInfo->uniform_send = uniform_send;

    	/*
    	**	This forces the packet to be encoded.  This must happen here so
    	**	that any memory used by the decoded portion of the packet can
    	**	be freed after returning.
    	*/
    	// packet->Lock();

    	m_OutgoingPDUQueue.Append(pReqInfo);

        if (m_OutgoingPDUQueue.GetCount() == 1)
        {
            if (FlushOutgoingPDU())
            {
        		//	Inform the MCS interface that there are PDUs queued
    			g_pGCCController->SetEventToFlushOutgoingPDU();
    		}
    	}
    	else
    	{
            //	Inform the MCS interface that there are PDUs queued
            g_pGCCController->SetEventToFlushOutgoingPDU();
    	}
	}
	else
    {
        ResourceFailureHandler();
        /*
		**	This just sets a flag in the packet object that allows packet
		**	to commit suicide if lock count on encoded and decoded data is
		**	zero. This will occur once the packet is sent on to MCS.
		*/
		packet->Unlock();
    }
}

/*
 *	BOOL FlushOutgoingPDU()
 *
 *	Public Function Description:
 * 		This function is called by the owner object in every heartbeat. This
 *		function iterates throught the list of pending out bound messages
 *		and sends them down to MCS. Also after a successful send it frees
 *		any resources tied up with the outbound messages. If however a message
 *		can not be sent in this heartbeat, as indicated by MCS, then it
 *		inserts the message back onto the message queue and returns.
 *
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the MCS message queue
 *		FALSE, if all the msgs in the MCS msg queue were processed.
 */	
void MCSUser::
CheckEjectedNodeAlarms ( void )
{
	/*
	**	We first check the eject user list to make sure that no alarms have
	**	expired on any of the ejected nodes.
	*/
	if (m_EjectedNodeAlarmList2.IsEmpty() == FALSE)
	{
		PAlarm				lpAlarm;
		UserID              uid;

		//	We copy the list so that we can remove entries in the iterator
		while (NULL != (lpAlarm = m_EjectedNodeAlarmList2.Get(&uid)))
		{
			//	Has the alarm expired for this node?
			if (lpAlarm->IsExpired())
			{
				ConnectionHandle hConn;

				/*
				**	Tell the owner object to disconnect the misbehaving node
				**	that exists at the connection handle accessed through
				**	the m_ChildUidConnHdlList2.
				*/
				if (NULL != (hConn = m_ChildUidConnHdlList2.Find(uid)))
				{
                    //
                    // This must generate a disconnect provider for eject node to
                    // work properly.
                    //
                    g_pMCSIntf->DisconnectProviderRequest(hConn);

                    //
                    // Since this node will not get a disconnect indication when it
                    // issues a DisconnectProviderRequest we go ahead and call it
                    // from here.
                    //
                    m_pConf->DisconnectProviderIndication(hConn);
				}
			}

    		//	Delete the alarm
			delete lpAlarm;
		}
	}
}

BOOL MCSUser::
FlushOutgoingPDU ( void )
{
	
	DWORD				mcs_message_count;
	DWORD				count;
	UINT				rc;
	SEND_DATA_REQ_INFO  *pReqInfo;

	mcs_message_count = m_OutgoingPDUQueue.GetCount();
	for (count = 0;
	     (count < mcs_message_count) && (m_OutgoingPDUQueue.IsEmpty() == FALSE);
	     count++)
	{
		/*
		**	Get the next message from the queue.
		*/
		pReqInfo = m_OutgoingPDUQueue.Get();

		/*
		 * If MCS takes the request without an error, free information
		 * structure and unlock the encoded information in the packet.
		 * Unlocking the packet before deleting the infomration	structure
		 * ensures that packet object is deleted and not left dangling.
		 * This is true because here only one lock is performed.
		 * If there is an error in the send data request, it means mcs can not
		 * take any more requests, therefore insert the information
		 * structure back in the queue and break out of this loop.
		 */
		if (pReqInfo->uniform_send)
		{
			rc = g_pMCSIntf->UniformSendDataRequest(
						pReqInfo->channel_id,
						m_pMCSSap,
						pReqInfo->priority,
						(LPBYTE) pReqInfo->packet->GetEncodedData(),
						pReqInfo->packet->GetEncodedDataLength());
		}
		else
		{
			rc = g_pMCSIntf->SendDataRequest(
						pReqInfo->channel_id,
						m_pMCSSap,
						pReqInfo->priority,
						(LPBYTE) pReqInfo->packet->GetEncodedData(),
						pReqInfo->packet->GetEncodedDataLength());
		}

		if (rc == MCS_NO_ERROR)
		{
			pReqInfo->packet->Unlock();
			delete pReqInfo;
		}
		else
		{
			TRACE_OUT(("MCSUser::FlushMessageQueue: Could not send queued packet data in this heartbeat"));
			m_OutgoingPDUQueue.Prepend(pReqInfo);
			break;	// breaking out of the for loop
		}
	}

	return (! (m_OutgoingPDUQueue.IsEmpty() && m_EjectedNodeAlarmList2.IsEmpty()));
}

/*
 *	MCSUser::SetChildUserID()
 *
 *	Public Function Description:
 * 		This function is called by the conference object to pass on the user id
 *		of the child node to the user object. The user object inserts this
 *		user id into a user id list of it's children which it maintains.
 */
void		MCSUser::SetChildUserIDAndConnection (
						UserID				child_user_id,
						ConnectionHandle	child_connection_handle)
{
	TRACE_OUT(("MCSUser::SetChildUserID: Adding Child userid=0x%04x to the list", (UINT) child_user_id));
	TRACE_OUT(("MCSUser::SetChildUserID: Adding Child Connection=%d to the list", (UINT) child_connection_handle));

	m_ChildUidConnHdlList2.Append(child_user_id, child_connection_handle);
}

/*
 *	GCCError	InitiateEjectionFromConference()
 *
 *	Private Function Description:
 *		This internal routine kicks of the process of ejecting this node
 *		from the conference.  This includes ejecting all the nodes below
 *		this node and waiting for their disconnect indications to come back
 *		in.
 *
 *	Formal Parameters:
 *		reason	-	(i)	Reason for ejection.
 *
 *	Return Value
 *		GCC_NO_ERROR		  	-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError	MCSUser::InitiateEjectionFromConference (GCCReason		reason)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;
	PAlarm					alarm = NULL;

	m_fEjectionPending = TRUE;
	m_eEjectReason = reason;

	if (m_ChildUidConnHdlList2.IsEmpty() == FALSE)
	{
	    UserID      uid;

		gcc_pdu.choice = INDICATION_CHOSEN;
		gcc_pdu.u.indication.choice = CONFERENCE_EJECT_USER_INDICATION_CHOSEN;
		
		gcc_pdu.u.indication.u.conference_eject_user_indication.reason =
				::TranslateGCCReasonToEjectInd(
					GCC_REASON_HIGHER_NODE_EJECTED);

		m_ChildUidConnHdlList2.Reset();
	 	while (m_ChildUidConnHdlList2.Iterate(&uid))
	 	{
			//	Get the Node to eject from the list of child nodes
			gcc_pdu.u.indication.u.conference_eject_user_indication.node_to_eject = uid;

			DBG_SAVE_FILE_LINE
			packet = new Packet((PPacketCoder) g_GCCCoder,
								PACKED_ENCODING_RULES,
								&gcc_pdu,
								GCC_PDU,
								TRUE,
								&packet_error);
			if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
			{
				AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);

				DBG_SAVE_FILE_LINE
				alarm = new Alarm (EJECTED_NODE_TIMER_DURATION);
				if (alarm != NULL)
				{
					/*
					**	Here we save the alarm in a list of ejected
					**	nodes. This alarm is used to cleanup any
					**	misbehaving node.
					*/
					m_EjectedNodeAlarmList2.Append(uid, alarm);
				}
				else
				{
					error_value = GCC_ALLOCATION_FAILURE;
					break;
				}
			}
			else
			{
				error_value = GCC_ALLOCATION_FAILURE;
				delete packet;
				break;
			}
		}
	}
	else
	{
		m_pConf->ProcessEjectUserIndication(m_eEjectReason);
	}

	return (error_value);
}

/*
 *	UINT	ProcessSendDataIndication()
 *
 *	Private Function Description:
 * 		This function is called when the user object gets send data indications
 *		from below. It finds out the message type and decodes the pdu in the
 *		user data field of send data indications. Based on the type of decoded
 *		pdu it take the necessary actions.
 *
 *	Formal Parameters:
 *		send_data_info	-	(i)	Send data structure to process.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned from this routine.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT	MCSUser::ProcessSendDataIndication(PSendData send_data_info)
{
	PPacket					packet;
	PacketError				packet_error;
	PGCCPDU					gcc_pdu;
	GCCError				error_value = GCC_NO_ERROR;
	UserID					initiator;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
			   			PACKED_ENCODING_RULES,
						(LPBYTE)send_data_info->user_data.value,
						send_data_info->user_data.length,
						GCC_PDU,
						TRUE,
						&packet_error);
	if(packet != NULL && packet_error == PACKET_NO_ERROR)
	{
		initiator = send_data_info->initiator;
		gcc_pdu = (PGCCPDU)packet->GetDecodedData();
		switch(gcc_pdu->choice)
		{
			case INDICATION_CHOSEN: // Data PDU
				switch(gcc_pdu->u.indication.choice)
				{
					case USER_ID_INDICATION_CHOSEN:
						{
							/*
							 * Sequence number and User Id sent by the child
							 * node after a successful conference create or
							 * join.
							 */
							m_pConf->ProcessUserIDIndication(
							        gcc_pdu->u.indication.u.user_id_indication.tag,
							        initiator);
						}
						break;

					case ROSTER_UPDATE_INDICATION_CHOSEN:
						if(send_data_info->channel_id == m_nidMyself)
						{
                            //
                            // We only process the roster update if the conference is
                            // established.
                            //
                            if (m_pConf->IsConfEstablished())
                            {
                                m_pConf->ProcessRosterUpdatePDU(gcc_pdu, initiator);
                            }
						}
    					break;

					case CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN:
                        g_pControlSap->ConfTimeInquireIndication(
                                m_pConf->GetConfID(),
                                gcc_pdu->u.indication.u.conference_time_inquire_indication.time_is_node_specific,
                                initiator);
						break;

					case CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN:
#ifdef JASPER
						ProcessConferenceExtendIndicationPDU(
									&gcc_pdu->u.indication.u.
										conference_time_extend_indication,
									initiator);
#endif // JASPER
						break;

					case APPLICATION_INVOKE_INDICATION_CHOSEN:
						ProcessApplicationInvokeIndication(
									&gcc_pdu->u.indication.u.
										application_invoke_indication,
									initiator);
						break;
							
					case TEXT_MESSAGE_INDICATION_CHOSEN:
#ifdef JASPER
						if (ProcessTextMessageIndication(
									&gcc_pdu->u.indication.u.
									text_message_indication,
									initiator) != GCC_NO_ERROR)
						{
							error_value = GCC_ALLOCATION_FAILURE;
						}
#endif // JASPER
						break;

					case CONFERENCE_LOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceLockIndication(initiator);
						break;

					case CONFERENCE_UNLOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceUnlockIndication(initiator);
    					break;

					default:
						ERROR_OUT(("User::ProcessSendDataIndication Unsupported PDU"));
    					break;
				} // switch(gcc_pdu->u.indication.choice)
                break;

			case REQUEST_CHOSEN:	// Connection(control) PDU
				switch(gcc_pdu->u.request.choice)
				{	
					case CONFERENCE_JOIN_REQUEST_CHOSEN:
						ProcessConferenceJoinRequestPDU(
								&gcc_pdu->u.request.u.conference_join_request,
								send_data_info);
						break;

					case CONFERENCE_TERMINATE_REQUEST_CHOSEN:
						ProcessConferenceTerminateRequestPDU(
								&gcc_pdu->u.request.u.
											conference_terminate_request,
								send_data_info);
						break;
						
					case CONFERENCE_EJECT_USER_REQUEST_CHOSEN:
						ProcessConferenceEjectUserRequestPDU(
								&gcc_pdu->u.request.u.
											conference_eject_user_request,
								send_data_info);
						break;

					case REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN:
						ProcessRegistryAllocateHandleRequestPDU(	
								&gcc_pdu->u.request.u.
										registry_allocate_handle_request,
								send_data_info);
						break;

					case CONFERENCE_LOCK_REQUEST_CHOSEN:
						m_pConf->ProcessConferenceLockRequest(initiator);
						break;

					case CONFERENCE_UNLOCK_REQUEST_CHOSEN:
						m_pConf->ProcessConferenceUnlockRequest(initiator);
						break;

					case CONFERENCE_TRANSFER_REQUEST_CHOSEN:
						ProcessTransferRequestPDU(
								&gcc_pdu->u.request.u.conference_transfer_request,
								send_data_info);
						break;

					case CONFERENCE_ADD_REQUEST_CHOSEN:
						ProcessAddRequestPDU (
								&gcc_pdu->u.request.u.conference_add_request,
								send_data_info);
						break;

					case REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN:
					case REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN:
					case REGISTRY_SET_PARAMETER_REQUEST_CHOSEN:
					case REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN:
					case REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN:
					case REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN:
						ProcessRegistryRequestPDU(	gcc_pdu,
														send_data_info);
						break;
	
					default:
							ERROR_OUT(("User::ProcessSendDataIndication this pdu choice is not supported"));
						break;
				} // switch(gcc_pdu->u.request.choice)
				break;

			case RESPONSE_CHOSEN:	// Connection(control) PDU
				switch(gcc_pdu->u.response.choice)
				{	
					case CONFERENCE_JOIN_RESPONSE_CHOSEN:
						/* This comes from top provider to the intermediate
						 * gcc provider which has to pass it on to the node
						 * that made a join request.
				    	 */	
						ProcessConferenceJoinResponsePDU(
								&gcc_pdu->u.response.u.
											conference_join_response);
						break;

					case CONFERENCE_TERMINATE_RESPONSE_CHOSEN:
						ProcessConferenceTerminateResponsePDU(
								&gcc_pdu->u.response.u.
											conference_terminate_response);
						break;

					case CONFERENCE_EJECT_USER_RESPONSE_CHOSEN:
						ProcessConferenceEjectUserResponsePDU(
								&gcc_pdu->u.response.u.
											conference_eject_user_response);
						break;

					case REGISTRY_RESPONSE_CHOSEN:
						ProcessRegistryResponsePDU(
								&gcc_pdu->u.response.u.registry_response);
						break;

					case REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN:
						ProcessRegistryAllocateHandleResponsePDU(
								&gcc_pdu->u.response.u.
									registry_allocate_handle_response);
						break;

					case CONFERENCE_LOCK_RESPONSE_CHOSEN:
#ifdef JASPER
						{
							GCCResult               result;
                            result = ::TranslateLockResultToGCCResult(gcc_pdu->u.response.u.conference_lock_response.result);
                    		g_pControlSap->ConfLockConfirm(result, m_pConf->GetConfID());
						}
#endif // JASPER
						break;

					case CONFERENCE_UNLOCK_RESPONSE_CHOSEN:
#ifdef JASPER
						{
							GCCResult               result;
                            result = ::TranslateUnlockResultToGCCResult(gcc_pdu->u.response.u.conference_unlock_response.result);
                    		g_pControlSap->ConfUnlockConfirm(result, m_pConf->GetConfID());
						}
#endif // JASPER
						break;

					case CONFERENCE_TRANSFER_RESPONSE_CHOSEN:
#ifdef JASPER
						ProcessTransferResponsePDU(
								&gcc_pdu->u.response.u.conference_transfer_response);
#endif // JASPER
						break;

					case CONFERENCE_ADD_RESPONSE_CHOSEN:
						ProcessAddResponsePDU(
								&gcc_pdu->u.response.u.conference_add_response);
						break;

					case FUNCTION_NOT_SUPPORTED_RESPONSE_CHOSEN:
						ProcessFunctionNotSupported (
								(UINT) gcc_pdu->u.response.u.function_not_supported_response.request.choice);
						break;

					// other cases to be added as we go along.
					default:
						ERROR_OUT(("User::ProcessSendDataIndication this pdu choice is not supported"));
						break;
				} // switch(gcc_pdu->u.response.choice)
				break;

			default:
				ERROR_OUT(("User::ProcessSendDataIndication this pdu type"));
				break;
		} // switch(gcc_pdu->choice)
		packet->Unlock();
	}
	else
	{
		delete packet;
		error_value = GCC_ALLOCATION_FAILURE;
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return(MCS_NO_ERROR);
}

/*
 *	void	ProcessConferenceJoinRequestPDU ()
 *
 *	Private Function Description:
 *		This PDU comes from below (intermediate directly connected node) to the
 *		top gcc provider. Pull out the tag number and user id from the
 *		pdu and store in a list.
 *
 *	Formal Parameters:
 *		join_request	-	(i)	Join request PDU structure to process.
 *		send_data_info	-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceJoinRequestPDU(
								PConferenceJoinRequest	join_request,
								PSendData				send_data_info)
{
	GCCError				rc = GCC_NO_ERROR;
	UserJoinRequestInfo		join_request_info;
	
	/*
	**	Build all the containers to be used in the join request info structure.
	*/
	
	//	Build the convener password container
	if ((join_request->bit_mask & CJRQ_CONVENER_PASSWORD_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_request_info.convener_password = new CPassword(
										&join_request->cjrq_convener_password,
										&rc);
												
		if (join_request_info.convener_password == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		join_request_info.convener_password = NULL;
    }

	//	Build the password challenge container
	if ((join_request->bit_mask & CJRQ_PASSWORD_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_request_info.password_challenge = new CPassword(
												&join_request->cjrq_password,
												&rc);
												
		if (join_request_info.password_challenge == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		join_request_info.password_challenge = NULL;
    }
		
	//	Build the caller identifier container
	if ((join_request->bit_mask & CJRQ_CALLER_ID_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		if (NULL == (join_request_info.pwszCallerID = ::My_strdupW2(
										join_request->cjrq_caller_id.length,
										join_request->cjrq_caller_id.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
    {
		join_request_info.pwszCallerID = NULL;
    }
	
	//	Build the password challenge container
	if ((join_request->bit_mask & CJRQ_USER_DATA_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_request_info.user_data_list = new CUserDataListContainer(join_request->cjrq_user_data, &rc);
		if (join_request_info.user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		join_request_info.user_data_list = NULL;
    }

	if (rc == GCC_NO_ERROR)
	{
		m_ConfJoinResponseList2.Append(send_data_info->initiator, join_request->tag);

		join_request_info.sender_id = send_data_info->initiator;

		g_pControlSap->ForwardedConfJoinIndication(
							join_request_info.sender_id,
							m_pConf->GetConfID(),
							join_request_info.convener_password,
							join_request_info.password_challenge,
							join_request_info.pwszCallerID,
							join_request_info.user_data_list);
	}

	//	Free up the containers allocated above
	if (join_request_info.convener_password != NULL)
	{
		join_request_info.convener_password->Release();
	}

	if (join_request_info.password_challenge != NULL)
	{
		join_request_info.password_challenge->Release();
	}

	delete join_request_info.pwszCallerID;

	if (join_request_info.user_data_list != NULL)
	{
		join_request_info.user_data_list->Release();
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	ProcessConferenceJoinResponsePDU ()
 *
 *	Private Function Description:
 *		This comes from top provider to the intermediate gcc provider which has
 *		to pass it on to the node that made a join request.
 *
 *	Formal Parameters:
 *		join_response	-	(i)	Join response PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceJoinResponsePDU(
								PConferenceJoinResponse		join_response)
{
	GCCError				rc = GCC_NO_ERROR;
	UserJoinResponseInfo	join_response_info;

	//	Store the password data in the join response info structure
	if ((join_response->bit_mask & CJRS_PASSWORD_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_response_info.password_challenge = new CPassword(
												&join_response->cjrs_password,
												&rc);
		if (join_response_info.password_challenge == NULL)
        {
			rc = GCC_NO_ERROR;
        }
	}
	else
    {
		join_response_info.password_challenge = NULL;
    }

	//	Store the user data in the join response info structure	
	if ((join_response->bit_mask & CJRS_USER_DATA_PRESENT) &&
	   	(rc == GCC_NO_ERROR))	
	{
		DBG_SAVE_FILE_LINE
		join_response_info.user_data_list = new CUserDataListContainer(join_response->cjrs_user_data, &rc);		
		if (join_response_info.user_data_list == NULL)
        {
			rc = GCC_NO_ERROR;
        }
	}
	else
    {
		join_response_info.user_data_list = NULL;
    }

	if (rc == GCC_NO_ERROR)
	{
		join_response_info.connection_handle = (ConnectionHandle)join_response->tag;
		join_response_info.result = ::TranslateJoinResultToGCCResult(join_response->result);

		m_pConf->ProcessConfJoinResponse(&join_response_info);
	}

	//	Free up the containers allocated above
	if (join_response_info.password_challenge != NULL)
		join_response_info.password_challenge->Release();

	if (join_response_info.user_data_list != NULL)
		join_response_info.user_data_list->Release();

	//	Cleanup after any allocation failures.
	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	ProcessConferenceTerminateRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Terminate Request PDU.
 *
 *	Formal Parameters:
 *		terminate_request	-	(i)	Terminate request PDU structure to process.
 *		send_data_info		-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessConferenceTerminateRequestPDU
(
    PConferenceTerminateRequest     terminate_request,
    PSendData                       send_data_info
)
{
    m_pConf->ProcessTerminateRequest(
                send_data_info->initiator,
                ::TranslateTerminateRqReasonToGCCReason(terminate_request->reason));
}

/*
 *	void	ProcessConferenceEjectUserRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		eject user request PDU.
 *
 *	Formal Parameters:
 *		eject_user_request	-	(i)	Eject user request PDU structure to process.
 *		send_data_info		-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceEjectUserRequestPDU(
							PConferenceEjectUserRequest	eject_user_request,
							PSendData					send_data_info)
{
	UserEjectNodeRequestInfo	eject_node_request;

	eject_node_request.requester_id = send_data_info->initiator;
	eject_node_request.node_to_eject = eject_user_request->node_to_eject;
	eject_node_request.reason = GCC_REASON_NODE_EJECTED;

	m_pConf->ProcessEjectUserRequest(&eject_node_request);
}

/*
 *	void	ProcessConferenceTerminateResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		terminate response PDU.
 *
 *	Formal Parameters:
 *		terminate_response	-	(i)	Terminate response PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceTerminateResponsePDU(
							PConferenceTerminateResponse	terminate_response)
{
    GCCResult               result = ::TranslateTerminateResultToGCCResult(terminate_response->result);

	//
	// If the terminate was successful, go ahead and set the
	// conference to not established.
	//
	if (result == GCC_RESULT_SUCCESSFUL)
	{
		m_pConf->ConfIsOver();
	}

	g_pControlSap->ConfTerminateConfirm(m_pConf->GetConfID(), result);
}


/*
 *	void	ProcessConferenceEjectUserResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Eject User response PDU.
 *
 *	Formal Parameters:
 *		eject_user_response	-	(i)	Eject user response PDU structure to
 *									process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceEjectUserResponsePDU(
							PConferenceEjectUserResponse	eject_user_response)
{
	UserEjectNodeResponseInfo	eject_node_response;

	eject_node_response.node_to_eject = eject_user_response->node_to_eject;

	eject_node_response.result = ::TranslateEjectResultToGCCResult(
													eject_user_response->result);

	m_pConf->ProcessEjectUserResponse(&eject_node_response);
}

/*
 *	void	ProcessRegistryRequest()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Registry
 *		request PDU.
 *
 *	Formal Parameters:
 *		gcc_pdu			-	(i)	This is the PDU structure to process.
 *		send_data_info	-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryRequestPDU
(
    PGCCPDU             gcc_pdu,
    PSendData           send_data_info
)
{
    CRegistry   *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        GCCError            rc = GCC_ALLOCATION_FAILURE;
        CRegKeyContainer    *pRegKey = NULL;

        switch (gcc_pdu->u.request.choice)
        {
        case REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_register_channel_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessRegisterChannelPDU(
                            pRegKey,
                            gcc_pdu->u.request.u.registry_register_channel_request.channel_id,
                            send_data_info->initiator, // Requester node id
                            gcc_pdu->u.request.u.registry_register_channel_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_assign_token_request.registry_key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessAssignTokenPDU(
                            pRegKey,
                            send_data_info->initiator, // Requester node id
                            gcc_pdu->u.request.u.registry_assign_token_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_SET_PARAMETER_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_set_parameter_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                OSTR                    oszParamValue;
                LPOSTR                  poszParamValue;
                GCCModificationRights   eRights;

                if (gcc_pdu->u.request.u.registry_set_parameter_request.
                                registry_set_parameter.length != 0)
                {
                    poszParamValue = &oszParamValue;
                    oszParamValue.length = gcc_pdu->u.request.u.registry_set_parameter_request.
                                                    registry_set_parameter.length;
                    oszParamValue.value = gcc_pdu->u.request.u.registry_set_parameter_request.
                                                    registry_set_parameter.value;
                }
                else
                {
                    poszParamValue = NULL;
                }

                if (gcc_pdu->u.request.u.registry_set_parameter_request.
                                bit_mask & PARAMETER_MODIFY_RIGHTS_PRESENT)
                {
                    eRights = (GCCModificationRights)gcc_pdu->u.request.u.
                                    registry_set_parameter_request.parameter_modify_rights;
                }
                else
                {
                    eRights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;
                }

                pAppReg->ProcessSetParameterPDU(
                            pRegKey,
                            poszParamValue,
                            eRights,
                            send_data_info->initiator, // Requester node id
                            gcc_pdu->u.request.u.registry_set_parameter_request.entity_id);

            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_retrieve_entry_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessRetrieveEntryPDU(
                                pRegKey,
                                send_data_info->initiator, // Requester node id
                                gcc_pdu->u.request.u.registry_retrieve_entry_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_delete_entry_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessDeleteEntryPDU (
                                pRegKey,
                                send_data_info->initiator, // Requester node id
                                gcc_pdu->u.request.u.registry_delete_entry_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_monitor_entry_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessMonitorEntryPDU(
                                pRegKey,
                                send_data_info->initiator, // Requester node id
                                gcc_pdu->u.request.u.registry_monitor_entry_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;
        }

        if (NULL != pRegKey)
        {
            pRegKey->Release();
        }

        //	Handle resource errors
        if (rc == GCC_ALLOCATION_FAILURE)
        {
            ResourceFailureHandler();
        }
    } // if pAppReg != NULL
}

/*
 *	void	ProcessRegistryAllocateHandleRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Allocate
 *		Handle request PDU.
 *
 *	Formal Parameters:
 *		allocate_handle_request	-	(i)	This is the PDU structure to process.
 *		send_data_info			-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryAllocateHandleRequestPDU
(
    PRegistryAllocateHandleRequest	allocate_handle_request,
    PSendData						send_data_info
)
{
    CRegistry *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        pAppReg->ProcessAllocateHandleRequestPDU(
                        allocate_handle_request->number_of_handles,
                        allocate_handle_request->entity_id,
                        send_data_info->initiator);
    }
}

/*
 *	void	ProcessRegistryResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Registry
 *		Response PDU.
 *
 *	Formal Parameters:
 *		registry_response	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryResponsePDU ( PRegistryResponse registry_response )
{
    CRegistry   *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        GCCError                    rc;
        UserRegistryResponseInfo    urri;

        ::ZeroMemory(&urri, sizeof(urri));
        // urri.registry_key = NULL;
        // urri.registry_item = NULL;

        DBG_SAVE_FILE_LINE
        urri.registry_key = new CRegKeyContainer(&registry_response->key, &rc);
        if ((urri.registry_key != NULL) && (rc == GCC_NO_ERROR))
        {
            DBG_SAVE_FILE_LINE
            urri.registry_item = new CRegItem(&registry_response->item, &rc);
            if ((urri.registry_item != NULL) && (rc == GCC_NO_ERROR))
            {
                //	Set up the original requester entity id
                urri.requester_entity_id = registry_response->entity_id;

                //	Set up the primitive type being responded to
                urri.primitive_type = registry_response->primitive_type;

                //	Set up the owner related variables	
                if (registry_response->owner.choice == OWNED_CHOSEN)
                {
                    urri.owner_node_id = registry_response->owner.u.owned.node_id;
                    urri.owner_entity_id = registry_response->owner.u.owned.entity_id;
                }
                else
                {
                    // urri.owner_node_id = 0;
                    // urri.owner_entity_id = 0;
                }

                //	Set up the modification rights
                if (registry_response->bit_mask & RESPONSE_MODIFY_RIGHTS_PRESENT)
                {
                    urri.modification_rights = (GCCModificationRights)registry_response->response_modify_rights;
                }
                else
                {
                    urri.modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;
                }

                //	Translate the result to a GCC result
                urri.result = ::TranslateRegistryRespToGCCResult(registry_response->result);

                pAppReg->ProcessRegistryResponsePDU(
                                urri.primitive_type,
                                urri.registry_key,
                                urri.registry_item,
                                urri.modification_rights,
                                urri.requester_entity_id,
                                urri.owner_node_id,
                                urri.owner_entity_id,
                                urri.result);
            }
            else
            {
                rc = GCC_ALLOCATION_FAILURE;
            }
        }
        else
        {
            rc = GCC_ALLOCATION_FAILURE;
        }

        if (NULL != urri.registry_key)
        {
            urri.registry_key->Release();
        }
        if (NULL != urri.registry_item)
        {
            urri.registry_item->Release();
        }

        //	Handle any resource errors	
        if (rc == GCC_ALLOCATION_FAILURE)
        {
            ResourceFailureHandler();
        }
    } // if pAppReg != NULL
}

/*
 *	void	ProcessAllocateHandleResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Allocate
 *		Handle Response PDU.
 *
 *	Formal Parameters:
 *		allocate_handle_response-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryAllocateHandleResponsePDU
(
    PRegistryAllocateHandleResponse     allocate_handle_response
)
{
    CRegistry   *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        pAppReg->ProcessAllocateHandleResponsePDU(
                    allocate_handle_response->number_of_handles,
                    allocate_handle_response->first_handle,
                    allocate_handle_response->entity_id,
                    (allocate_handle_response->result == RARS_RESULT_SUCCESS) ?
                        GCC_RESULT_SUCCESSFUL :
                        GCC_RESULT_NO_HANDLES_AVAILABLE);
    }
}

/*
 *	void	ProcessTransferRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Transfer
 *		request PDU.
 *
 *	Formal Parameters:
 *		transfer_request	-	(i)	This is the PDU structure to process.
 *		send_data_info		-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessTransferRequestPDU
(
    PConferenceTransferRequest      transfer_request,
    PSendData                       send_data_info
)
{
	GCCError					rc = GCC_NO_ERROR;
	TransferInfo				transfer_info;
	PSetOfTransferringNodesRq	set_of_nodes;
	LPBYTE						sub_node_list_memory = NULL;
	Int							i;

	//	Make sure that this node is the top provider
	if (GetMyNodeID() != GetTopNodeID())
		return;

    ::ZeroMemory(&transfer_info, sizeof(transfer_info));

	//	First set up the conference name
	if (transfer_request->conference_name.choice ==
												NAME_SELECTOR_NUMERIC_CHOSEN)
	{
		transfer_info.destination_conference_name.numeric_string =
			(LPSTR) transfer_request->conference_name.u.name_selector_numeric;
		// transfer_info.destination_conference_name.text_string = NULL;
	}
	else
	{
		// transfer_info.destination_conference_name.numeric_string = NULL;
		if (NULL == (transfer_info.destination_conference_name.text_string = ::My_strdupW2(
							transfer_request->conference_name.u.name_selector_text.length,
							transfer_request->conference_name.u.name_selector_text.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	

	//	Next set up the conference name modifier
	if (transfer_request->bit_mask & CTRQ_CONFERENCE_MODIFIER_PRESENT)
	{
		transfer_info.destination_conference_modifier =
						(LPSTR) transfer_request->ctrq_conference_modifier;
	}
	else
    {
		// transfer_info.destination_conference_modifier = NULL;
    }
	
	//	Next set up the network address
	if (transfer_request->bit_mask & CTRQ_NETWORK_ADDRESS_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.destination_address_list = new CNetAddrListContainer(
								transfer_request->ctrq_net_address,
								&rc);
		if (transfer_info.destination_address_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		// transfer_info.destination_address_list = NULL;
    }
	

	//	Set up the transferring nodes list
	if (transfer_request->bit_mask & CTRQ_TRANSFERRING_NODES_PRESENT)
	{
		//	First determine the number of nodes.
		set_of_nodes = transfer_request->ctrq_transferring_nodes;
		// transfer_info.number_of_destination_nodes = 0;
		while (set_of_nodes != NULL)
		{
			transfer_info.number_of_destination_nodes++;
			set_of_nodes = set_of_nodes->next;		
		}

		//	Next allocate the memory required to hold the sub nodes
		DBG_SAVE_FILE_LINE
		sub_node_list_memory = new BYTE[sizeof(UserID) * transfer_info.number_of_destination_nodes];

		//	Now fill in the permission list
		if (sub_node_list_memory != NULL)
		{
			transfer_info.destination_node_list = (PUserID) sub_node_list_memory;

			set_of_nodes = transfer_request->ctrq_transferring_nodes;
			for (i = 0; i < transfer_info.number_of_destination_nodes; i++)
			{
				transfer_info.destination_node_list[i] = set_of_nodes->value;
				set_of_nodes = set_of_nodes->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessTransferRequestPDU: Memory Manager Alloc Failure"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.number_of_destination_nodes = 0;
		// transfer_info.destination_node_list = NULL;
	}

	//	Set up the password
	if (transfer_request->bit_mask & CTRQ_PASSWORD_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.password = new CPassword(&transfer_request->ctrq_password, &rc);
		if (transfer_info.password == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.password = NULL;
	}

	//	Save the sender ID	
	transfer_info.requesting_node_id = send_data_info->initiator;

	if (rc == GCC_NO_ERROR)
	{
		m_pConf->ProcessConferenceTransferRequest(
						transfer_info.requesting_node_id,
						&transfer_info.destination_conference_name,
						transfer_info.destination_conference_modifier,
						transfer_info.destination_address_list,
						transfer_info.number_of_destination_nodes,
						transfer_info.destination_node_list,
						transfer_info.password);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessTransferRequestPDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	//	Now cleanup any allocated memory
	if (transfer_info.destination_address_list != NULL)
	{
		transfer_info.destination_address_list->Release();
	}

	delete sub_node_list_memory;

	if (transfer_info.password != NULL)
	{
		transfer_info.password->Release();
	}
}

/*
 *	void	ProcessAddRequestPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference Add
 *		request PDU.
 *
 *	Formal Parameters:
 *		conference_add_request	-	(i)	This is the PDU structure to process.
 *		send_data_info			-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessAddRequestPDU (
								PConferenceAddRequest	conference_add_request,
								PSendData				send_data_info)
{
	GCCError			rc = GCC_NO_ERROR;
	AddRequestInfo		add_request_info;

	/*
	**	Ignore this request if this node is NOT the Top Provider and the request
	**	did not come from the Top Provider.
	*/
	if (m_nidTopProvider != m_nidMyself)
	{
		if (m_nidTopProvider != send_data_info->initiator)
			return;	
	}

    ::ZeroMemory(&add_request_info, sizeof(add_request_info));

	DBG_SAVE_FILE_LINE
	add_request_info.network_address_list = new CNetAddrListContainer(
								conference_add_request->add_request_net_address,
								&rc);
	if (add_request_info.network_address_list == NULL)
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	if ((rc == GCC_NO_ERROR) &&
		(conference_add_request->bit_mask & CARQ_USER_DATA_PRESENT))
	{
		DBG_SAVE_FILE_LINE
		add_request_info.user_data_list = new CUserDataListContainer(conference_add_request->carq_user_data, &rc);
		if (add_request_info.user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		// add_request_info.user_data_list = NULL;
    }

	if (rc == GCC_NO_ERROR)
	{
		add_request_info.adding_node = (conference_add_request->bit_mask & ADDING_MCU_PRESENT) ?
                                            conference_add_request->adding_mcu : 0;
		add_request_info.requesting_node = conference_add_request->requesting_node;
		add_request_info.add_request_tag = (TagNumber)conference_add_request->tag;

		m_pConf->ProcessConferenceAddRequest(
    					add_request_info.network_address_list,
    					add_request_info.user_data_list,
    					add_request_info.adding_node,
    					add_request_info.add_request_tag,
    					add_request_info.requesting_node);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessAddRequestPDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	if (add_request_info.network_address_list != NULL)
	{
		add_request_info.network_address_list->Release();
	}

	if (add_request_info.user_data_list != NULL)
	{
		add_request_info.user_data_list->Release();
	}
}

/*
 *	void	ProcessTransferResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Transfer response PDU.
 *
 *	Formal Parameters:
 *		transfer_response	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void	MCSUser::ProcessTransferResponsePDU (
								PConferenceTransferResponse	transfer_response)
{
	GCCError					rc = GCC_NO_ERROR;
	TransferInfo				transfer_info;
	PSetOfTransferringNodesRs	set_of_nodes;
	LPBYTE						sub_node_list_memory = NULL;
	Int							i;

    ::ZeroMemory(&transfer_info, sizeof(transfer_info));

	//	First set up the conference name
	if (transfer_response->conference_name.choice ==
												NAME_SELECTOR_NUMERIC_CHOSEN)
	{
		transfer_info.destination_conference_name.numeric_string =
			(LPSTR) transfer_response->conference_name.u.name_selector_numeric;
		// transfer_info.destination_conference_name.text_string = NULL;
	}
	else
	{
		// transfer_info.destination_conference_name.numeric_string = NULL;
		if (NULL == (transfer_info.destination_conference_name.text_string = ::My_strdupW2(
							transfer_response->conference_name.u.name_selector_text.length,
							transfer_response->conference_name.u.name_selector_text.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Next set up the conference name modifier
	if (transfer_response->bit_mask & CTRS_CONFERENCE_MODIFIER_PRESENT)
	{
		transfer_info.destination_conference_modifier =
						(LPSTR) transfer_response->ctrs_conference_modifier;
	}
	else
	{
		// transfer_info.destination_conference_modifier = NULL;
	}

	//	Set up the transferring nodes list
	if (transfer_response->bit_mask & CTRS_TRANSFERRING_NODES_PRESENT)
	{
		//	First determine the number of nodes.
		set_of_nodes = transfer_response->ctrs_transferring_nodes;
		// transfer_info.number_of_destination_nodes = 0;
		while (set_of_nodes != NULL)
		{
			transfer_info.number_of_destination_nodes++;
			set_of_nodes = set_of_nodes->next;		
		}

		//	Next allocate the memory required to hold the sub nodes
		DBG_SAVE_FILE_LINE
		sub_node_list_memory = new BYTE[sizeof(UserID) * transfer_info.number_of_destination_nodes];

		//	Now fill in the permission list
		if (sub_node_list_memory != NULL)
		{
			transfer_info.destination_node_list = (PUserID) sub_node_list_memory;

			set_of_nodes = transfer_response->ctrs_transferring_nodes;
			for (i = 0; i < transfer_info.number_of_destination_nodes; i++)
			{
				transfer_info.destination_node_list[i] = set_of_nodes->value;
				set_of_nodes = set_of_nodes->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessTransferResponsePDU: Memory Manager Alloc Failure"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.number_of_destination_nodes = 0;
		// transfer_info.destination_node_list = NULL;
	}
	

	//	Save the result	
	transfer_info.result = (transfer_response->result == CTRANS_RESULT_SUCCESS) ?
                            GCC_RESULT_SUCCESSFUL :
                            GCC_RESULT_INVALID_REQUESTER;

	if (rc == GCC_NO_ERROR)
	{
		g_pControlSap->ConfTransferConfirm(
    							m_pConf->GetConfID(),
    							&transfer_info.destination_conference_name,
    							transfer_info.destination_conference_modifier,
    							transfer_info.number_of_destination_nodes,
    							transfer_info.destination_node_list,
    							transfer_info.result);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessTransferResponsePDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	//	Now cleanup any allocated memory
	delete sub_node_list_memory;
}
#endif // JASPER


/*
 *	void	ProcessAddResponsePDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Add response PDU.
 *
 *	Formal Parameters:
 *		conference_add_response	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessAddResponsePDU (
						PConferenceAddResponse		conference_add_response)
{
	GCCError				error_value = GCC_NO_ERROR;
	AddResponseInfo			add_response_info;

	if (conference_add_response->bit_mask &	CARS_USER_DATA_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		add_response_info.user_data_list = new CUserDataListContainer(conference_add_response->cars_user_data, &error_value);
		if (add_response_info.user_data_list == NULL)
        {
			error_value = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		add_response_info.user_data_list = NULL;
    }
	
	if (error_value == GCC_NO_ERROR)
	{
		add_response_info.add_request_tag = (TagNumber)conference_add_response->tag;
		add_response_info.result = ::TranslateAddResultToGCCResult(conference_add_response->result);

        m_pConf->ProcessConfAddResponse(&add_response_info);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessAddResponsePDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == error_value)
		{
            ResourceFailureHandler();
        }
	}

	if (add_response_info.user_data_list != NULL)
	{
		add_response_info.user_data_list->Release();
	}
}

/*
 *	void	ProcessFunctionNotSupported ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing responses for request that
 *		are not supported at the node that the request was directed toward.
 *
 *	Formal Parameters:
 *		request_choice	-	(i)	This is the request that is not supported.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The existance of this routine does not mean that this provider does
 *		not support it.  It only means that the node which received the
 *		request does not support it.
 */
void MCSUser::
ProcessFunctionNotSupported ( UINT request_choice )
{
	switch (request_choice)
	{
	case CONFERENCE_LOCK_REQUEST_CHOSEN:
#ifdef JASPER
		g_pControlSap->ConfLockConfirm(GCC_RESULT_LOCKED_NOT_SUPPORTED, m_pConf->GetConfID());
#endif // JASPER
		break;

	case CONFERENCE_UNLOCK_REQUEST_CHOSEN:
#ifdef JASPER
		g_pControlSap->ConfUnlockConfirm(GCC_RESULT_UNLOCK_NOT_SUPPORTED, m_pConf->GetConfID());
#endif // JASPER
		break;

	default:
		ERROR_OUT(("MCSUser: ProcessFunctionNotSupported: "
					"Error: Illegal request is unsupported"));
		break;
	}
}

/*
 *	UINT	ProcessUniformSendDataIndication ()
 *
 *	Private Function Description:
 * 		This function is called when the user object gets send data indications
 *		from below. It finds out the message type and decodes the pdu in the
 *		user data field of send data indications. Based on the type of decoded
 *		pdu it take the necessary actions.
 *		This routine is responsible for processing responses for request that
 *		are not supported at the node that the request was directed toward.
 *
 *	Formal Parameters:
 *		send_data_info	-	(i)	This is the MCS data structure to process.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT	MCSUser::ProcessUniformSendDataIndication(	
						PSendData		send_data_info)
{
	PPacket					packet;
	PacketError				packet_error;
	PGCCPDU					gcc_pdu;
	GCCError				error_value = GCC_NO_ERROR;
	UserID					initiator;
	
	TRACE_OUT(("User: UniformSendDataInd: length = %d",
				send_data_info->user_data.length));

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPBYTE)send_data_info->user_data.value,
						send_data_info->user_data.length,
						GCC_PDU,
						TRUE,
						&packet_error);
	if((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		initiator = send_data_info->initiator;
		gcc_pdu = (PGCCPDU)packet->GetDecodedData();
		switch (gcc_pdu->choice)
		{
			case INDICATION_CHOSEN: // Data PDU
				switch(gcc_pdu->u.indication.choice)
				{
					case CONFERENCE_TERMINATE_INDICATION_CHOSEN:
						/*
						**	Note that we allow the top provider to process
						**	this message so that it can set up its own
						**	node for termination in a generic way.
						*/
						ProcessConferenceTerminateIndicationPDU (
									&gcc_pdu->u.indication.u.
										conference_terminate_indication,
									initiator);
    					break;

					case CONFERENCE_EJECT_USER_INDICATION_CHOSEN:
						/*
						**	Do not decode a packet that was sent uniformly
						**	from this node.
						*/
						if (initiator != m_nidMyself)
						{
							ProcessConferenceEjectUserIndicationPDU (
									&gcc_pdu->u.indication.u.
										conference_eject_user_indication,
									initiator);
						}
						break;

					case ROSTER_UPDATE_INDICATION_CHOSEN:
						/*
						**	Do not decode a packet that was sent uniformly
						**	from this node.
						*/
						if ((initiator != m_nidMyself) &&
							(send_data_info->channel_id ==
													BROADCAST_CHANNEL_ID))
						{
                            //
                            // We only process the roster update if the conference is
                            // established.
                            //
                            if (m_pConf->IsConfEstablished())
                            {
                                m_pConf->ProcessRosterUpdatePDU(gcc_pdu, initiator);
                            }
						}
						break;

					case CONFERENCE_LOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceLockIndication(initiator);
						break;

					case CONFERENCE_UNLOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceUnlockIndication(initiator);
						break;

					case CONDUCTOR_ASSIGN_INDICATION_CHOSEN:
                        m_pConf->ProcessConductorAssignIndication(
                                    gcc_pdu->u.indication.u.conductor_assign_indication.user_id,
                                    initiator);
                        break;

					case CONDUCTOR_RELEASE_INDICATION_CHOSEN:
						if (initiator != m_nidMyself)
						{
							m_pConf->ProcessConductorReleaseIndication(initiator);
						}
						break;

					case CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN:
#ifdef JASPER
						/*
						**	Do not decode a packet that was sent uniformly
						**	from this node.
						*/
						if (initiator != m_nidMyself)
						{
							PermitAskIndicationInfo		indication_info;

							indication_info.sender_id = initiator;
							
							indication_info.permission_is_granted =
										gcc_pdu->u.indication.u.
											conductor_permission_ask_indication.
												permission_is_granted;

							m_pConf->ProcessConductorPermitAskIndication(&indication_info);
						}
#endif // JASPER
						break;

					case CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN:
						ProcessPermissionGrantIndication(
									&(gcc_pdu->u.indication.u.
										conductor_permission_grant_indication),
									initiator);
						break;

					case CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN:
#ifdef JASPER
						ProcessTimeRemainingIndicationPDU (
									&gcc_pdu->u.indication.u.
										conference_time_remaining_indication,
									initiator);
#endif // JASPER
						break;
						
					case APPLICATION_INVOKE_INDICATION_CHOSEN:
						ProcessApplicationInvokeIndication(
									&gcc_pdu->u.indication.u.
										application_invoke_indication,
									initiator);
						break;
					
					case TEXT_MESSAGE_INDICATION_CHOSEN:
#ifdef JASPER
						if (ProcessTextMessageIndication(
									&gcc_pdu->u.indication.u.
										text_message_indication,
									initiator) != GCC_NO_ERROR)
						{
							error_value = GCC_ALLOCATION_FAILURE;
						}
#endif // JASPER
						break;

					case CONFERENCE_ASSISTANCE_INDICATION_CHOSEN:
#ifdef JASPER
						ProcessConferenceAssistanceIndicationPDU(
									&gcc_pdu->u.indication.u.
										conference_assistance_indication,
									initiator);
#endif // JASPER
						break;

					case REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN:
						/*
						**	Do not decode this packet if it was sent
						**	uniformly from this node.
						*/
						if (initiator != m_nidMyself)
						{
							ProcessRegistryMonitorIndicationPDU (
								&gcc_pdu->u.indication.u.
									registry_monitor_entry_indication,
								initiator);
						}
						break;

					case CONFERENCE_TRANSFER_INDICATION_CHOSEN:
#ifdef JASPER
						/*
						**	Do not decode this packet if it was not sent
						**	from the top provider.
						*/
						if (initiator == m_nidTopProvider)
						{
							ProcessTransferIndicationPDU (
								&gcc_pdu->u.indication.u.
									conference_transfer_indication);
						}
#endif // JASPER
						break;

					default:
						ERROR_OUT(("MCSUser::ProcessSendDataIndication"
										"Unsupported PDU"));
						break;
				} // switch(gcc_pdu->u.indication.choice)
	            break;

			default:
				ERROR_OUT(("MCSUser::ProcessUniformSendDataIndication. wrong pdu type "));
				break;
		}
		packet->Unlock();
	}
	else
	{
		delete packet;
		error_value = GCC_ALLOCATION_FAILURE;
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return (MCS_NO_ERROR);
}

/*
 *	void	ProcessTransferIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Transfer indication PDU.
 *
 *	Formal Parameters:
 *		transfer_indication	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessTransferIndicationPDU
(
    PConferenceTransferIndication       transfer_indication
)
{
	GCCError					rc = GCC_NO_ERROR;
	TransferInfo				transfer_info;
	PSetOfTransferringNodesIn	set_of_nodes;
	LPBYTE						sub_node_list_memory = NULL;
	Int							i;
	BOOL						process_pdu = FALSE;

    ::ZeroMemory(&transfer_info, sizeof(transfer_info));

	/*
	**	If there is a transferring node list we must determine if this node
	**	is in the list.  If it isn't then the request is ignored.
	*/
	if (transfer_indication->bit_mask & CTIN_TRANSFERRING_NODES_PRESENT)
	{
		set_of_nodes = transfer_indication->ctin_transferring_nodes;
		while (set_of_nodes != NULL)
		{
			if (set_of_nodes->value == GetMyNodeID())
			{
				process_pdu = TRUE;
				break;
			}

			set_of_nodes = set_of_nodes->next;
		}

		if (process_pdu == FALSE)
		{
			return;
		}
	}

	//	First set up the conference name
	if (transfer_indication->conference_name.choice == NAME_SELECTOR_NUMERIC_CHOSEN)
	{
		transfer_info.destination_conference_name.numeric_string =
                (LPSTR) transfer_indication->conference_name.u.name_selector_numeric;
		// transfer_info.destination_conference_name.text_string = NULL;
	}
	else
	{
		// transfer_info.destination_conference_name.numeric_string = NULL;
		if (NULL == (transfer_info.destination_conference_name.text_string = ::My_strdupW2(
							transfer_indication->conference_name.u.name_selector_text.length,
							transfer_indication->conference_name.u.name_selector_text.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Next set up the conference name modifier
	if (transfer_indication->bit_mask & CTIN_CONFERENCE_MODIFIER_PRESENT)
	{
		transfer_info.destination_conference_modifier =
						(LPSTR) transfer_indication->ctin_conference_modifier;
	}
	else
    {
		// transfer_info.destination_conference_modifier = NULL;
    }

	//	Next set up the network address
	if (transfer_indication->bit_mask & CTIN_NETWORK_ADDRESS_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.destination_address_list = new CNetAddrListContainer(
								transfer_indication->ctin_net_address,
								&rc);
		if (transfer_info.destination_address_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		// transfer_info.destination_address_list = NULL;
    }

	//	Set up the transferring nodes list
	if (transfer_indication->bit_mask & CTIN_TRANSFERRING_NODES_PRESENT)
	{
		//	First determine the number of nodes.
		set_of_nodes = transfer_indication->ctin_transferring_nodes;
		// transfer_info.number_of_destination_nodes = 0;
		while (set_of_nodes != NULL)
		{
			transfer_info.number_of_destination_nodes++;
			set_of_nodes = set_of_nodes->next;
		}

		//	Next allocate the memory required to hold the sub nodes
		DBG_SAVE_FILE_LINE
		sub_node_list_memory = new BYTE[sizeof(UserID) * transfer_info.number_of_destination_nodes];

		//	Now fill in the permission list
		if (sub_node_list_memory != NULL)
		{
			transfer_info.destination_node_list = (PUserID) sub_node_list_memory;

			set_of_nodes = transfer_indication->ctin_transferring_nodes;
			for (i = 0; i < transfer_info.number_of_destination_nodes; i++)
			{
				transfer_info.destination_node_list[i] = set_of_nodes->value;
				set_of_nodes = set_of_nodes->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessTransferIndicationPDU: Memory Manager Alloc Failure"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.number_of_destination_nodes = 0;
		// transfer_info.destination_node_list = NULL;
	}
	

	//	Set up the password
	if (transfer_indication->bit_mask & CTIN_PASSWORD_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.password = new CPassword(&transfer_indication->ctin_password, &rc);
		if (transfer_info.password == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.password = NULL;
	}

	if (rc == GCC_NO_ERROR)
	{
		g_pControlSap->ConfTransferIndication(
							m_pConf->GetConfID(),
							&transfer_info.destination_conference_name,
							transfer_info.destination_conference_modifier,
							transfer_info.destination_address_list,
							transfer_info.password);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessTransferIndicationPDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	//	Now cleanup any allocated memory
	if (NULL != transfer_info.destination_address_list)
	{
	    transfer_info.destination_address_list->Release();
	}

	delete sub_node_list_memory;

	if (NULL != transfer_info.password)
	{
	    transfer_info.password->Release();
	}
}
#endif // JASPER

/*
 *	void	ProcessConferenceTerminateIndicationPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Terminate indication PDU.
 *
 *	Formal Parameters:
 *		terminate_indication	-	(i)	This is the PDU structure to process.
 *		sender_id				-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceTerminateIndicationPDU (
						PConferenceTerminateIndication	terminate_indication,
						UserID							sender_id)
{
	if (sender_id == m_nidTopProvider)
	{
		m_pConf->ProcessTerminateIndication(
			::TranslateTerminateInReasonToGCCReason(terminate_indication->reason));
	}
}

/*
 *	void	ProcessTimeRemainingIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Time remaining indication PDU.
 *
 *	Formal Parameters:
 *		time_remaining_indication	-	(i)	This is the PDU structure to process
 *		sender_id					-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessTimeRemainingIndicationPDU
(
    PConferenceTimeRemainingIndication      time_remaining_indication,
    UserID                                  sender_id
)
{
    g_pControlSap->ConfTimeRemainingIndication(
                        m_pConf->GetConfID(),
                        sender_id,
                        (time_remaining_indication->bit_mask & TIME_REMAINING_NODE_ID_PRESENT) ?
                            time_remaining_indication->time_remaining_node_id : 0,
                        time_remaining_indication->time_remaining);
}
#endif // JASPER

/*
 *	void	ProcessConferenceAssistanceIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		assistance indication PDU.
 *
 *	Formal Parameters:
 *		conf_assistance_indication	-	(i)	This is the PDU structure to process
 *		sender_id					-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessConferenceAssistanceIndicationPDU
(
    PConferenceAssistanceIndication     conf_assistance_indication,
    UserID                              sender_id
)
{
	GCCError				rc = GCC_NO_ERROR;
	CUserDataListContainer  *user_data_list = NULL;

	DebugEntry(MCSUser::ProcessConferenceAssistanceIndication);

	//	Unpack the user data list if it exists
	if (conf_assistance_indication->bit_mask & CAIN_USER_DATA_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		user_data_list = new CUserDataListContainer(conf_assistance_indication->cain_user_data, &rc);
		if (user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}

	if (rc == GCC_NO_ERROR)
	{
        g_pControlSap->ConfAssistanceIndication(
                            m_pConf->GetConfID(),
                            user_data_list,
                            sender_id);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessConferenceAssistanceIndication: can't create CUserDataListContainer"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}
}
#endif // JASPER


/*
 *	void	ProcessConferenceExtendIndicationPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		extend indication PDU.
 *
 *	Formal Parameters:
 *		conf_time_extend_indication	-	(i)	This is the PDU structure to process
 *		sender_id					-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessConferenceExtendIndicationPDU
(
    PConferenceTimeExtendIndication     conf_time_extend_indication,
    UserID                              sender_id
)
{
    g_pControlSap->ConfExtendIndication(
                        m_pConf->GetConfID(),
                        conf_time_extend_indication->time_to_extend,
                        conf_time_extend_indication->time_is_node_specific,
                        sender_id);
}
#endif // JASPER

/*
 *	void	ProcessConferenceEjectUserIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		eject user indication PDU.
 *
 *	Formal Parameters:
 *		eject_user_indication	-	(i)	This is the PDU structure to process
 *		sender_id			 	-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceEjectUserIndicationPDU (
						PConferenceEjectUserIndication	eject_user_indication,
						UserID							sender_id)
{
	GCCError				error_value = GCC_NO_ERROR;
	PAlarm					alarm = NULL;

	//	First check to make sure that this is the node being ejected
	if (eject_user_indication->node_to_eject == m_nidMyself)
	{
		/*
		**	Next make sure the ejection came from either the Top Provider or
		**	the Parent Node.
		*/
		if ((sender_id == m_nidParent) || (sender_id == m_nidTopProvider))
		{
			TRACE_OUT(("MCSUser:ProcessEjectUserIndication: This node is ejected"));
			error_value = InitiateEjectionFromConference (
							::TranslateEjectIndReasonToGCCReason(
										eject_user_indication->reason));
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessEjectUserIndication: Received eject from illegal node"));
		}
	}
	else
	{
		TRACE_OUT(("MCSUser: ProcessEjectUserIndication: Received eject for node other than mine"));

		/*
		**	If this node is a directly connected child node we insert an
		**	alarm in the list m_EjectedNodeAlarmList2 to disconnect it if
		**	it misbehaves and does not disconnect itself.  Otherwise,  we save
		**	the ejected user id in the m_EjectedNodeList to inform the local
		**	node of the correct reason for disconnecting (user ejected) when the
		**	detch user indication comes in.
		*/
		if (m_ChildUidConnHdlList2.Find(eject_user_indication->node_to_eject))
		{
			DBG_SAVE_FILE_LINE
			alarm = new Alarm (EJECTED_NODE_TIMER_DURATION);
			if (alarm != NULL)
			{
				m_EjectedNodeAlarmList2.Append(eject_user_indication->node_to_eject, alarm);
			}
			else
				error_value = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			/*
			**	Here we save the alarm in a list of ejected nodes. This
			**	alarm is used to cleanup any misbehaving node.  Note that
			**	if the ejected node is not a child of this node then no
			**	alarm is set up to monitor the ejection.
			*/
			m_EjectedNodeList.Append(eject_user_indication->node_to_eject);
		}
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
		ERROR_OUT(("MCSUser::ProcessEjectUserIndication: Allocation Failure"));
        ResourceFailureHandler();
	}
}

/*
 *	void	ProcessPermissionGrantIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Permission
 *		grant indication PDU.
 *
 *	Formal Parameters:
 *		permission_grant_indication	-	(i)	This is the PDU structure to process
 *		sender_id			 		-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessPermissionGrantIndication(
			PConductorPermissionGrantIndication	permission_grant_indication,
			UserID								sender_id)
{
	GCCError									error_value = GCC_NO_ERROR;
	UserPermissionGrantIndicationInfo			grant_indication_info;
	PPermissionList								permission_list;
	LPBYTE										permission_list_memory = NULL;
	PWaitingList								waiting_list;
	LPBYTE										waiting_list_memory = NULL;
	UINT										i;

	//	First count the number of entries in the permission list
	grant_indication_info.number_granted = 0;
	permission_list = permission_grant_indication->permission_list;
	while (permission_list != NULL)
	{
		permission_list = permission_list->next;
		grant_indication_info.number_granted++;
	}
	
	TRACE_OUT(("MCSUser: ProcessPermissionGrantIndication: number_granted=%d", (UINT) grant_indication_info.number_granted));

	//	If a list exist allocate memory for it and copy it over.
	if (grant_indication_info.number_granted != 0)
	{
		// allocating space to hold permission list.
		DBG_SAVE_FILE_LINE
		permission_list_memory = new BYTE[sizeof(UserID) * grant_indication_info.number_granted];

		//	Now fill in the permission list
		if (permission_list_memory != NULL)
		{
			grant_indication_info.granted_node_list = (PUserID) permission_list_memory;

			permission_list = permission_grant_indication->permission_list;
			for (i = 0; i < grant_indication_info.number_granted; i++)
			{
				grant_indication_info.granted_node_list[i] = permission_list->value;
				permission_list = permission_list->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessPermissionGrantIndication: Memory Manager Alloc Failure"));
			error_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		grant_indication_info.granted_node_list = NULL;
	}

	//	Now extract the waiting list information if any exist
	if ((error_value == GCC_NO_ERROR) &&
		(permission_grant_indication->bit_mask & WAITING_LIST_PRESENT))
	{
		//	First count the number of entries in the waiting list
		grant_indication_info.number_waiting = 0;
		waiting_list = permission_grant_indication->waiting_list;
		while (waiting_list != NULL)
		{
			waiting_list = waiting_list->next;
			grant_indication_info.number_waiting++;
		}

		TRACE_OUT(("MCSUser: ProcessPermissionGrantIndication: number_waiting=%d", (UINT) grant_indication_info.number_waiting));

		// allocating space to hold waiting list.
		DBG_SAVE_FILE_LINE
		waiting_list_memory = new BYTE[sizeof(UserID) * grant_indication_info.number_waiting];

		//	Now fill in the permission list
		if (waiting_list_memory != NULL)
		{
			grant_indication_info.waiting_node_list = (PUserID) waiting_list_memory;

			waiting_list = permission_grant_indication->waiting_list;
			for (i = 0; i < grant_indication_info.number_waiting; i++)
			{
				grant_indication_info.waiting_node_list[i] = waiting_list->value;
				waiting_list = waiting_list->next;
			}
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		grant_indication_info.number_waiting = 0;
		grant_indication_info.waiting_node_list = NULL;
	}

	/*
	**	If there were no memory errors, send the indication back to the
	**	owner object.
	*/
	if (error_value == GCC_NO_ERROR)
	{
		m_pConf->ProcessConductorPermitGrantInd(&grant_indication_info, sender_id);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessPermissionGrantIndication: Alloc Failed"));
		if (GCC_ALLOCATION_FAILURE == error_value)
		{
            ResourceFailureHandler();
        }
	}

	//	Free up any memory used in this call
	delete permission_list_memory;
	delete waiting_list_memory;
}

/*
 *	MCSUser::GetUserIDFromConnection()
 *
 *	Public Function Description:
 *		This function returns the Node ID associated with the specified
 *		connection handle.  It returns zero if the connection handle is
 *		not a child connection of this node.
 */
UserID MCSUser::GetUserIDFromConnection(ConnectionHandle connection_handle)
{
	ConnectionHandle        hConn;
	UserID                  uid;

	m_ChildUidConnHdlList2.Reset();
	while (NULL != (hConn = m_ChildUidConnHdlList2.Iterate(&uid)))
	{
		if (hConn == connection_handle)
		{
			return uid;
		}
	}
	return 0;
}



/*
 *	MCSUser::UserDisconnectIndication()
 *
 *	Public Function Description:
 *		This function informs the user object when a Node disconnects from
 *		the conference.  This gives the user object a chance to clean up
 *		its internal information base.
 */
void MCSUser::UserDisconnectIndication(UserID disconnected_user)
{
	PAlarm			lpAlarm;

	/*
	**	If this node has a pending ejection we will go ahead and remove the
	**	ejected node from the list.  Once all child nodes have disconnected
	**	we will inform the owner object of the ejection.
	*/	
	if (m_fEjectionPending)
	{
		// Delete the Alarm if it exists
		if (NULL != (lpAlarm = m_EjectedNodeAlarmList2.Remove(disconnected_user)))
		{
			delete lpAlarm;
			/*
			**	Here we must check to see if there are anymore active alarms
			**	in the list.  If so we wait until that node disconnects before
			**	informing the owner object that this node has been ejected.
			**	Otherwise, we complete the ejection process.
			*/
			if (m_EjectedNodeAlarmList2.IsEmpty())
			{
				m_pConf->ProcessEjectUserIndication(m_eEjectReason);
			}
		}
	}
	// If we are the top provider, just clean the eject alarm list.
	else if (TOP_PROVIDER_AND_CONVENER_NODE == m_pConf->GetConfNodeType() &&
			 NULL != (lpAlarm = m_EjectedNodeAlarmList2.Remove(disconnected_user)))
	{
			delete lpAlarm;
	}
	
	/*
	**	Here we remove the entry from the list of child connections if
	**	it is included in this list.
	*/
	m_ChildUidConnHdlList2.Remove(disconnected_user);
}

/*
 *	void	ProcessApplicationInvokeIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Invoke
 *		indication PDU.
 *
 *	Formal Parameters:
 *		invoke_indication	-	(i)	This is the PDU structure to process
 *		sender_id		 	-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessApplicationInvokeIndication(
							PApplicationInvokeIndication	invoke_indication,
							UserID							sender_id)
{
	GCCError							error_value = GCC_NO_ERROR;
	BOOL								process_pdu = FALSE;
	CInvokeSpecifierListContainer		*invoke_list;
	PSetOfDestinationNodes				set_of_destination_nodes;
	
	if (invoke_indication->bit_mask & DESTINATION_NODES_PRESENT)
	{
		set_of_destination_nodes = invoke_indication->destination_nodes;
		while (set_of_destination_nodes != NULL)
		{
			if (set_of_destination_nodes->value == m_nidMyself)
			{
				process_pdu = TRUE;
				break;
			}
			else
			{
				set_of_destination_nodes = set_of_destination_nodes->next;
			}
		}
	}
	else
	{
		process_pdu = TRUE;
	}

	if (process_pdu)
	{
		TRACE_OUT(("MCSUser: ProcessApplicationInvokeIndication: Process PDU"));
		DBG_SAVE_FILE_LINE
		invoke_list = new CInvokeSpecifierListContainer(
							invoke_indication->application_protocol_entity_list,
							&error_value);
		if ((invoke_list != NULL) && (error_value == GCC_NO_ERROR))
		{
			m_pConf->ProcessAppInvokeIndication(invoke_list, sender_id);
			invoke_list->Release();
		}
		else if (invoke_list == NULL)
		{
			error_value = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			invoke_list->Release();
		}

		if (error_value == GCC_ALLOCATION_FAILURE)
		{
			ERROR_OUT(("MCSUser::ProcessApplicationInvokeIndication: Allocation Failure"));
            ResourceFailureHandler();
		}
	}
	else
	{
		WARNING_OUT(("MCSUser:ProcessApplicationInvokeIndication: Don't Process PDU"));
	}
}

/*
 *	GCCError	ProcessTextMessageIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Text
 *		message indication PDU.
 *
 *	Formal Parameters:
 *		text_message_indication	-	(i)	This is the PDU structure to process
 *		sender_id		 		-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
GCCError	MCSUser::ProcessTextMessageIndication(
							PTextMessageIndication	text_message_indication,
							UserID					sender_id)
{
	LPWSTR					gcc_unicode_string;
	GCCError				rc;

	if (NULL != (gcc_unicode_string = ::My_strdupW2(
					text_message_indication->message.length,
					text_message_indication->message.value)))
	{
		rc = g_pControlSap->TextMessageIndication(
                                    m_pConf->GetConfID(),
                                    gcc_unicode_string,
                                    sender_id);
	}
	else
    {
		rc = GCC_ALLOCATION_FAILURE;
    }

	return rc;
}
#endif // JASPER

/*
 *	void	ProcessRegistryMonitorIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Registry
 *		monitor indication PDU.
 *
 *	Formal Parameters:
 *		monitor_indication	-	(i)	This is the PDU structure to process
 *		sender_id		  	-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryMonitorIndicationPDU
(
    PRegistryMonitorEntryIndication     monitor_indication,
    UserID                              sender_id
)
{
    if (sender_id == m_nidTopProvider)
    {
        CRegistry   *pAppReg = m_pConf->GetRegistry();
        if (NULL != pAppReg)
        {
            GCCError                    rc;
            UserRegistryMonitorInfo     urmi;

            ::ZeroMemory(&urmi, sizeof(urmi));
            // urmi.registry_key = NULL;
            // urmi.registry_item = NULL;

            DBG_SAVE_FILE_LINE
            urmi.registry_key = new CRegKeyContainer(&monitor_indication->key, &rc);
            if ((urmi.registry_key != NULL) && (rc == GCC_NO_ERROR))
            {
                DBG_SAVE_FILE_LINE
                urmi.registry_item = new CRegItem(&monitor_indication->item, &rc);
                if ((urmi.registry_item != NULL) && (rc == GCC_NO_ERROR))
                {
                    //	Set up the owner related variables	
                    if (monitor_indication->owner.choice == OWNED_CHOSEN)
                    {
                        urmi.owner_node_id = monitor_indication->owner.u.owned.node_id;
                        urmi.owner_entity_id = monitor_indication->owner.u.owned.entity_id;
                    }
                    else
                    {
                        // urmi.owner_node_id = 0;
                        // urmi.owner_entity_id = 0;
                    }

                    //	Set up the modification rights
                    if (monitor_indication->bit_mask & RESPONSE_MODIFY_RIGHTS_PRESENT)
                    {
                        urmi.modification_rights = (GCCModificationRights)monitor_indication->entry_modify_rights;
                    }
                    else
                    {
                        urmi.modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;
                    }

                    pAppReg->ProcessMonitorIndicationPDU(
                                        urmi.registry_key,
                                        urmi.registry_item,
                                        urmi.modification_rights,
                                        urmi.owner_node_id,
                                        urmi.owner_entity_id);
                }
                else
                {
                    rc = GCC_ALLOCATION_FAILURE;
                }
            }
            else
            {
                rc = GCC_ALLOCATION_FAILURE;
            }

            if (NULL != urmi.registry_key)
            {
                urmi.registry_key->Release();
            }
            if (NULL != urmi.registry_item)
            {
                urmi.registry_item->Release();
            }

            //	Handle any resource errors	
            if (rc == GCC_ALLOCATION_FAILURE)
            {
                ResourceFailureHandler();
            }
        }
        else
        {
            WARNING_OUT(("MCSUser:ProcessRegistryMonitorIndication: invalid app registry"));
        }
    }
    else
    {
        WARNING_OUT(("MCSUser:ProcessRegistryMonitorIndication:"
                        "Monitor Indication received from NON Top Provider"));
    }
}

/*
 *	UINT	ProcessDetachUserIndication()
 *
 *	Private Function Description:
 * 		This function is called when the user object gets detach user
 *		indications from nodes in it's subtree or it's parent node.
 *		Depending upon the reason of the indication it sends to the
 *		conference object the appropriate owner callback.
 * 		If the reason contained in the indication is UserInitiated or
 *		provider initiated a DETACH USER INDICATION is sent to the con-
 *		ference. The MCS reason is converted to GCC reason. If MCS
 *		reason in indication is neither user initiated nor provider initiated
 *		then the above owner callback carries a GCC reason ERROR_TERMINATION
 *		else it carries a GCC reason USER_INITIATED.
 *		If the detach user indication reveals the user id of the sendar as
 *		the parent user id of this node a CONFERENCE_TERMINATE_INDICATION
 *		is sent to the conference object.
 *
 *	Formal Parameters:
 *		mcs_reason	-	(i)	MCS reason for being detached.
 *		sender_id	-	(i)	User ID of user being detached.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned fro this routine.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT	MCSUser::ProcessDetachUserIndication(	Reason		mcs_reason,
												UserID		detached_user)
{
	GCCReason				gcc_reason;

	if (detached_user == m_nidParent)
	{
		WARNING_OUT(("MCSUser: Fatal Error: Parent User Detached"));
		m_pConf->ProcessTerminateIndication(GCC_REASON_PARENT_DISCONNECTED);
	}
    else
    {
		TRACE_OUT(("MCSUser: User Detached: uid=0x%04x", (UINT) detached_user));

		/*
		**	First, we check to see if the detching node was ejected.
		**	If not, translate the mcs reason to a gcc reason.
		*/
		if (m_EjectedNodeList.Find(detached_user))
		{
			gcc_reason = GCC_REASON_NODE_EJECTED;
			
			//	Remove this entry from the ejected node list.
			m_EjectedNodeList.Remove(detached_user);
		}
		else if (m_EjectedNodeAlarmList2.Find(detached_user))
		{
			//	Here we wait for the disconnect before removing the entry.
			gcc_reason = GCC_REASON_NODE_EJECTED;
		}
		else if ((mcs_reason == REASON_USER_REQUESTED) ||
			(mcs_reason == REASON_PROVIDER_INITIATED))
        {
	    	gcc_reason = GCC_REASON_USER_INITIATED;
		}
        else
        {
			gcc_reason = GCC_REASON_ERROR_TERMINATION;
        }

        m_pConf->ProcessDetachUserIndication(detached_user, gcc_reason);
	}
	return (MCS_NO_ERROR);
}


void MCSUser::
ProcessTokenGrabConfirm
(
    TokenID         tidConductor,
    Result          result
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorGrabConfirm(::TranslateMCSResultToGCCResult(result));
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Grab Confirm"));
    }
}


void MCSUser::
ProcessTokenGiveIndication
(
    TokenID         tidConductor,
    UserID          uidRecipient
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorGiveIndication(uidRecipient);
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Please Ind"));
    }
}


void MCSUser::
ProcessTokenGiveConfirm
(
    TokenID         tidConductor,
    Result          result
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorGiveConfirm(::TranslateMCSResultToGCCResult(result));
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Grab Confirm"));
    }
}


#ifdef JASPER
void MCSUser::
ProcessTokenPleaseIndication
(
    TokenID         tidConductor,
    UserID          uidRequester
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        if (m_pConf->IsConfConductible())
        {
            //	Inform the control SAP.
            g_pControlSap->ConductorPleaseIndication(
                                        m_pConf->GetConfID(),
                                        uidRequester);
        }
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Please Ind"));
    }
}
#endif // JASPER


#ifdef JASPER
void MCSUser::
ProcessTokenReleaseConfirm
(
    TokenID         tidConductor,
    Result          result
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        g_pControlSap->ConductorReleaseConfirm(::TranslateMCSResultToGCCResult(result),
                                               m_pConf->GetConfID());
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Release Cfrm"));
    }
}
#endif // JASPER


void MCSUser::
ProcessTokenTestConfirm
(
    TokenID         tidConductor,
    TokenStatus     eStatus
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorTestConfirm((eStatus == TOKEN_NOT_IN_USE) ?
                                                GCC_RESULT_NOT_IN_CONDUCTED_MODE :
                                                GCC_RESULT_SUCCESSFUL);
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Release Cfrm"));
    }
}



void MCSUser::ResourceFailureHandler(void)
{
    ERROR_OUT(("MCSUser::ResourceFailureHandler: terminating the conference"));
    m_pConf->InitiateTermination(GCC_REASON_ERROR_LOW_RESOURCES, 0);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\mcsdllif.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	mcsdllif.cpp
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the MCAT MCS DLL interface class.
 *		This class is designed to work with Microsoft's implementation of the
 *		MCS DLL. All access by GCC to and from this DLL should pass through
 *		this class.
 *
 *		MCS interface objects represent the Service Access Point (SAP)
 *		between GCC and MCS.  Exactly how the interface works is an
 *		implementation matter for those classes that inherit from this one.
 *		This class defines the public member functions that GCC expects to be
 *		able to call upon to utilize MCS.
 *
 *		The public member functions defined here can be broken into two
 *		categories: those that are part of T.122; and those that are not.
 *		The T.122 functions include connect provider request, connect
 *		provider response, disconnect provider request, create domain, delete
 *		domain, send data request, etc.  All other member functions are
 *		considered a local matter from a standards point-of-view.  These
 *		functions include support for initialization and setup, as well as
 *		functions allowing GCC to poll MCS for activity.
 *
 *		This class contains a number of virtual functions which GCC needs to
 *		operate.  Making these functions virtual in the base class allows the
 *		MCS interface to be portable to most any platform.  All the platform
 *		specific code required to access MCS is contained in classes that will
 *		inherit from this one.
 *
 *		Note that this class also handles the connect provider confirms by
 *		keeping a list of all the objects with outstanding connect provider
 *		request.  These are held in the ConfirmObjectList.
 *
 *	Portable
 *		No
 *
 *	Author:
 *		Christos Tsollis
 */

#include "mcsdllif.h"
#include "mcsuser.h"
#include "gcontrol.h"


extern CRITICAL_SECTION g_csGCCProvider;

/*
 *	g_pMCSController
 *		This is a pointer to the one-and-only controller created within the
 *		MCS system.  This object is created during MCSInitialize by the process
 *		that is taking on the responsibilities of the node controller.
 */
extern PController		g_pMCSController;

void CALLBACK	MCSCallBackProcedure (UINT, LPARAM, PVoid);


//	MACROS used with the packet rebuilder
#define		SEND_DATA_PACKET			0
#define		UNIFORM_SEND_DATA_PACKET	1


extern MCSDLLInterface      *g_pMCSIntf;

/*
 *	MCSDLLInterface ( )
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the MCS Interface class. It is responsible
 *		for initializing the MCAT MCS DLL.  Any errors that occur during
 *		initialization are returned in the error_value provided.
 */
MCSDLLInterface::MCSDLLInterface(PMCSError	error_value)
:
	m_ConfirmConnHdlConfList2(),
	m_MCSUserList()
{	
	/*
	**	Create/initialize the MCS Controller object.
	*/
	DBG_SAVE_FILE_LINE
	g_pMCSController = new Controller (error_value);
	
	if (g_pMCSController == NULL) {
		/*
		 *	The allocation of the controller failed.  Report and return
		 *	the appropriate error.
		 */
		WARNING_OUT (("MCSDLLInterface::MCSDLLInterface: controller creation failed"));
		*error_value = MCS_ALLOCATION_FAILURE;
	}
#ifdef _DEBUG
	else if (*error_value != MCS_NO_ERROR) {
		WARNING_OUT (("MCSDLLInterface::MCSDLLInterface: MCS controller is faulty."));
	}
#endif // _DEBUG
}


/*
 *	~MCSDLLInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the MCS Interface class. It is responsible
 *		for cleaning up both itself and the MCAT MCS DLL.
 */
MCSDLLInterface::~MCSDLLInterface ()
{
	/*
	 *	Destroy the controller, which will clean up all resources
	 *	in use at this time.  Then reset the flag indicating that
	 *	MCS is initialized (since it no longer is).
	 */
	TRACE_OUT (("MCSDLLInterface::~MCSDLLInterface: deleting controller"));
	if (NULL != g_pMCSController) {
		g_pMCSController->Release();
	}
 }

/*
 *	MCSError	ConnectProviderRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This T.122 primitive is used to connect two domains. This request
 *		should always be followed by a connect provider confirm.  The
 *		confirm will be sent to be object specified by the confirm object
 *		the is passed into this routine.
 */
MCSError	MCSDLLInterface::ConnectProviderRequest (
							GCCConfID          *calling_domain,
							GCCConfID          *called_domain,
							TransportAddress	calling_address,
							TransportAddress	called_address,
							BOOL				fSecure,
							DBBoolean			upward_connection,
							PUChar				user_data,
							ULong				user_data_length,
							PConnectionHandle	connection_handle,
							PDomainParameters	domain_parameters,
							CConf		        *confirm_object)
{
	MCSError			mcs_error;
	ConnectRequestInfo	connect_request_info;

	/*
	 *	Pack all necessary information into a structure, since it will not
	 *	all fit into the 4 byte parameter that is sent with the message.
	 */
	connect_request_info.calling_domain = calling_domain;
	connect_request_info.called_domain = called_domain;
	connect_request_info.calling_address = calling_address;
	connect_request_info.called_address = called_address;
	connect_request_info.fSecure = fSecure;
	connect_request_info.upward_connection = upward_connection;
	connect_request_info.domain_parameters = domain_parameters;
	connect_request_info.user_data = user_data;
	connect_request_info.user_data_length = user_data_length;
	connect_request_info.connection_handle = connection_handle;

	/*
	 *	Send a connect provider request message to the controller through its
	 *	owner callback function.
	 */
	ASSERT (g_pMCSController);
	mcs_error = g_pMCSController->HandleAppletConnectProviderRequest(&connect_request_info);

	if (mcs_error == MCS_NO_ERROR)
	{
		/*
		**	The confirm object list maintains a list of object
		**	pointers that have outstanding request. When the confirms
		**	come back in, they will be routed to the appropriate object
		**	based on the connection handle.
		*/
		mcs_error = AddObjectToConfirmList (confirm_object,
											*connection_handle);
	}
	else
	{
		WARNING_OUT(("MCSDLLInterface::ConnectProviderRequest: error = %d", mcs_error));
	}

	return (mcs_error);
}

MCSError MCSDLLInterface::ConnectProviderResponse (
					ConnectionHandle	connection_handle,
					GCCConfID          *domain_selector,
					PDomainParameters	domain_parameters,
					Result				result,
					PUChar				user_data,
					ULong				user_data_length)
{
	ConnectResponseInfo		connect_response_info;

	/*
	 *	Pack all necessary information into a structure, since it will not
	 *	all fit into the 4 byte parameter that is sent with the message.
	 */
	connect_response_info.connection_handle = connection_handle;
	connect_response_info.domain_selector = domain_selector;
	connect_response_info.domain_parameters = domain_parameters;
	connect_response_info.result = result;
	connect_response_info.user_data = user_data;
	connect_response_info.user_data_length = user_data_length;

	ASSERT (g_pMCSController);
	/*
	 *	Send a connect provider response message to the controller through its
	 *	owner callback function.
	 */
	return g_pMCSController->HandleAppletConnectProviderResponse(&connect_response_info);
}

/*
 *	MCSError	DisconnectProviderRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to disconnect a node from a particular connection.
 *		This can be either an upward or downward connection
 */
MCSError	MCSDLLInterface::DisconnectProviderRequest (
							ConnectionHandle	connection_handle)
{
	ASSERT (g_pMCSController);
	m_ConfirmConnHdlConfList2.Remove(connection_handle);
	return g_pMCSController->HandleAppletDisconnectProviderRequest(connection_handle);
}

/*
 *	MCSError	AttachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to create a user attachment to MCS. It will result
 *		in an attach user confirm.
 */
MCSError	MCSDLLInterface::AttachUserRequest
(
    GCCConfID          *domain_selector,
    PIMCSSap           *ppMCSSap,
    MCSUser            *user_object
)
{
	MCSError	mcs_error;

	mcs_error = MCS_AttachRequest (ppMCSSap,
									(DomainSelector) domain_selector,
									sizeof(GCCConfID),
									MCSCallBackProcedure,
									(PVoid) user_object,
									ATTACHMENT_DISCONNECT_IN_DATA_LOSS |
									ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);

	if (mcs_error == MCS_NO_ERROR)
		m_MCSUserList.Append(user_object);
	
	return (mcs_error);
}

/*
 *	MCSError	DetachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used when a user of MCS whishes to detach itself from
 *		a domain.
 */
MCSError	MCSDLLInterface::DetachUserRequest (PIMCSSap pMCSSap,
												PMCSUser pMCSUser)
{
	MCSError	mcs_error;
#ifdef DEBUG
	UINT_PTR	storing = (UINT_PTR) this;
#endif // DEBUG
	
	mcs_error = pMCSSap->ReleaseInterface();
	ASSERT ((UINT_PTR) this == storing);
	m_MCSUserList.Remove(pMCSUser);

	return (mcs_error);
}

/*
 *	void	ProcessCallback ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called whenever a callback message is received by
 *		the "C" callback routine. It is responsible for both processing
 *		callback messages and forwarding callback messages on to the
 *		appropriate object.
 */
void	MCSDLLInterface::ProcessCallback (unsigned int	message,
												LPARAM	parameter,
												PVoid	object_ptr)
{
	ConnectionHandle		connection_handle;
	CConf					*pConf;

	/*
	**	Before processing any callbacks from MCS we must enter a critical
	**	section to gaurantee that we do not attempt to process a message
	**	in GCC while its own thread is running.
	*/
	EnterCriticalSection (&g_csGCCProvider);

    if (MCS_SEND_DATA_INDICATION         == message ||
        MCS_UNIFORM_SEND_DATA_INDICATION == message) {

        /*
        **	First check the segmentation flag to make sure we have the
        **	entire packet.  If not we must give the partial packet to
        **	the packet rebuilder and wait for the remainder of the data.
        */
        ASSERT(((PSendData)parameter)->segmentation == (SEGMENTATION_BEGIN | SEGMENTATION_END));

    	if (IsUserAttachmentVaid ((PMCSUser)object_ptr)) {
    		//	Process the entire packet
    		if (message == MCS_SEND_DATA_INDICATION)
    		{
    		    ((PMCSUser)object_ptr)->ProcessSendDataIndication((PSendData) parameter);
    		}
    		else
    		{
    		    ((PMCSUser)object_ptr)->ProcessUniformSendDataIndication((PSendData) parameter);
    		}
    	}
    }
    else {
        //
        // Non-Send-Data callbacks.
        //
        WORD    wHiWordParam = HIWORD(parameter);
        WORD    wLoWordParam = LOWORD(parameter);

        switch (message)
        {
            /*
            **	These messages are handled by the object passed in through
            **	the user data field.
            */
            case MCS_DETACH_USER_INDICATION:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->ProcessDetachUserIndication(
            	                                (Reason) wHiWordParam,
            	                                (UserID) wLoWordParam);
            	}
            	break;

            case MCS_ATTACH_USER_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->ProcessAttachUserConfirm(
            	                                (Result) wHiWordParam,
            	                                (UserID) wLoWordParam);
            	}
            	break;

            case MCS_CHANNEL_JOIN_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->ProcessChannelJoinConfirm(
            	                                (Result) wHiWordParam,
            	                                (ChannelID) wLoWordParam);
            	}
            	break;

            case MCS_CHANNEL_LEAVE_INDICATION:
#if 0 // LONCHANC: MCSUser does not handle this message.
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->OwnerCallback(CHANNEL_LEAVE_INDICATION,
            											 NULL,
            											 parameter);
            	}
#endif // 0
            	break;

            case MCS_TOKEN_GRAB_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenGrabConfirm(
                                                (TokenID) wLoWordParam,
                                                (Result) wHiWordParam);
            	}
            	break;

            case MCS_TOKEN_GIVE_INDICATION:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenGiveIndication(
                                                (TokenID) wLoWordParam,
                                                (UserID) wHiWordParam);
            	}
            	break;

            case MCS_TOKEN_GIVE_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenGiveConfirm(
                                                (TokenID) wLoWordParam,
                                                (Result) wHiWordParam);
            	}
            	break;

            case MCS_TOKEN_PLEASE_INDICATION:
#ifdef JASPER
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenPleaseIndication(
                                                (TokenID) wLoWordParam,
                                                (UserID) wHiWordParam);
            	}
#endif // JASPER
            	break;

            case MCS_TOKEN_RELEASE_CONFIRM:
#ifdef JASPER
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenReleaseConfirm(
                                                (TokenID) wLoWordParam,
                                                (Result) wHiWordParam);
            	}
#endif // JASPER
            	break;

            case MCS_TOKEN_TEST_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenTestConfirm(
                                                (TokenID) wLoWordParam,
                                                (TokenStatus) wHiWordParam);
            	}
            	break;

            /*
            **	These messages are handled by the object that created the
            **	MCS DLL interface.
            */
#ifdef TSTATUS_INDICATION
            case MCS_TRANSPORT_STATUS_INDICATION:
            	if (g_pControlSap != NULL)
            	{
            		g_pControlSap->TransportStatusIndication((PTransportStatus) parameter);
            	}
            	break;
#endif

            case MCS_CONNECT_PROVIDER_INDICATION:
            	g_pGCCController->ProcessConnectProviderIndication((PConnectProviderIndication) parameter);
            	// Cleanup the controller message.
            	delete (PConnectProviderIndication) parameter;
            	break;


            case MCS_DISCONNECT_PROVIDER_INDICATION:
            	connection_handle = (ConnectionHandle) parameter;

                g_pGCCController->ProcessDisconnectProviderIndication(connection_handle);

            	/*
            	**	If no entry exists in the confirm object list, there
            	**	is a problem. All confirms must have an associated
            	**	response.
            	*/
            	if (m_ConfirmConnHdlConfList2.Remove(connection_handle))
            	{
            		DisconnectProviderRequest(connection_handle);
            	}
            	break;

            /*
            **	All connect provider confirms must be matched up with the
            **	connect provider request to determine where to route the
            **	message.
            */
            case MCS_CONNECT_PROVIDER_CONFIRM:
            	connection_handle = ((PConnectProviderConfirm)parameter)->connection_handle;

            	/*
            	**	If no entry exists in the confirm object list, there
            	**	is a problem. All confirms must have an associated
            	**	response.
            	*/
            	if (NULL != (pConf = m_ConfirmConnHdlConfList2.Remove(connection_handle)))
            	{
            		//	Send the confirm to the appropriate object
            		if ((LPVOID) pConf != (LPVOID) LPVOID_NULL)
            		{
            			// confirm_object is a CConf.
            			pConf->ProcessConnectProviderConfirm((PConnectProviderConfirm) parameter);
            		}
            		else
            		{
            			// confirm_object is the GCC Controller.
            			g_pGCCController->ProcessConnectProviderConfirm((PConnectProviderConfirm)parameter);
            		}
            	}
            	else
            	{
            		WARNING_OUT(("MCSDLLInterface: ProcessCallback: Bad Connect"
            					" Provider Confirm received"));
            	}
            	
            	// Cleanup the controller message.
                CoTaskMemFree( ((PConnectProviderConfirm) parameter)->pb_cred );
            	delete (PConnectProviderConfirm) parameter;
            	break;
            	
            default:
            	WARNING_OUT(("MCSDLLInterface: ProcessCallback: Unsupported message"
            				" received from MCS = %d",message));
            	break;
    	}
    }

	//	Leave the critical section after the callback is processed.
	LeaveCriticalSection (&g_csGCCProvider);
}

/*
 *	void CALLBACK	MCSCallBackProcedure (	unsigned int message,
 *												LPARAM		 parameter,
 *												PVoid		 user_defined)
 *
 *	Functional Description:
 *		This routine receives callback messages directly from the MCAT MCS
 *		DLL.
 *
 *	Formal Parameters:
 *		message	(i)
 *			This is the mcs message to be processed
 *		parameter (i)
 *			Varies according to the message. See the MCAT programmers manual
 *		object_ptr (i)
 *			This is the user defined field that was passed to MCS on
 *			initialization.
 *
 *	Return Value:
 *		See ProcessCallback
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CALLBACK	MCSCallBackProcedure (unsigned int message,
										LPARAM		 parameter,
										PVoid		 user_defined)
{
	if (g_pMCSIntf != NULL)
		g_pMCSIntf->ProcessCallback (message, parameter, user_defined);
}


/*
 *	TranslateMCSResultToGCCResult ()
 *
 *	Public Function Description
 *		This routine translate a standard MCS result to a GCC result.
 */
GCCResult
TranslateMCSResultToGCCResult ( Result mcs_result )
{
	GCCResult	gcc_result;

    switch (mcs_result)
    {
    	case RESULT_SUCCESSFUL:
        	gcc_result = GCC_RESULT_SUCCESSFUL;
            break;

        case RESULT_PARAMETERS_UNACCEPTABLE:
        	gcc_result = GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE;
            break;

        case RESULT_USER_REJECTED:
        	gcc_result = GCC_RESULT_USER_REJECTED;
        	break;

		/*
		**	Note that we are making the assumption here that the only token
		**	that GCC deals with is a conductor token.
		*/
	    case RESULT_TOKEN_NOT_AVAILABLE:
			gcc_result = GCC_RESULT_IN_CONDUCTED_MODE;
			break;
			
	    case RESULT_TOKEN_NOT_POSSESSED:
			gcc_result = GCC_RESULT_NOT_THE_CONDUCTOR;
			break;
	
		/****************************************************************/
			
        case RESULT_UNSPECIFIED_FAILURE:
        default:
        	gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
        	break;
    }

    return (gcc_result);
}

/*
 *	MCSError	AddObjectToConfirmList ()
 *
 *	Functional Description:
 *		This function is used to add information about an object to the list
 *		which holds all information required to send connect provider confirms.
 *
 *	Formal Parameters:
 *		confirm_object (i)
 *			This is a pointer to the object the made the connect provider
 *			request.
 *		connection_handle (i)
 *			This is the connection handle returned from the connect provider
 *			request.
 *
 *	Return Value:
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
MCSError	MCSDLLInterface::AddObjectToConfirmList (
									CConf		        *pConf,
									ConnectionHandle	connection_handle)
{
	MCSError			return_value;

	/*
	**	First check to make sure that the list doesn't already contain the
	**	connection.
	*/
	if (m_ConfirmConnHdlConfList2.Find(connection_handle) == FALSE)
	{
		//	Add it to the list
		m_ConfirmConnHdlConfList2.Append(connection_handle, pConf ? pConf : (CConf *) LPVOID_NULL);
		return_value = MCS_NO_ERROR;
	}
	else
		return_value = MCS_INVALID_PARAMETER;

	return (return_value);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\nccglbl.hpp ===
/****************************************************************************/
/*                                                                          */
/* NCCGLBL.HPP                                                              */
/*                                                                          */
/* Global header for NCC.                                                   */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  11Sep95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __NCCGLBL_H_
#define __NCCGLBL_H_

#include "sap.h" // for NCUIMSG_BASE

enum
{
    NCMSG_QUERY_REMOTE_FAILURE  = NCMSG_BASE + 0,
    NCMSG_FIRST_ROSTER_RECVD    = NCMSG_BASE + 1,
};


#ifdef _DEBUG
extern BOOL    g_fInterfaceBreak;
__inline void InterfaceEntry(void) { if (g_fInterfaceBreak) DebugBreak(); }
#else
#define InterfaceEntry()    
#endif // _DEBUG


HRESULT GetGCCRCDetails(GCCError gccRC);

HRESULT GetGCCResultDetails(GCCResult gccRC);

GCCResult MapRCToGCCResult(HRESULT rc);

#endif /* __NCCGLBL_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\netaddr.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	netaddr.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CNetAddrListContainer Class.  This
 *		class manages the data associated with a network address.  Network
 *		addresses can be one of three types: aggregated channel, transport
 *		connection, or non-standard.  A variety of structures, objects, and
 *		Rogue Wave containers are used to buffer the network address data
 *		internally.
 *
 *	Protected Instance Variables:
 *		m_NetAddrItemList
 *			List of structures used to hold the network address data internally.
 *		m_pSetOfNetAddrPDU
 *			Storage for the "PDU" form of the network address list.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" network address structures.
 *		m_fValidNetAddrPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" network address list.
 *
 *	Private Member Functions:
 *		StoreNetworkAddressList
 *			This routine is used to store the network address data passed in as
 *			"API" data in the internal structures.
 *		ConvertPDUDataToInternal	
 *			This routine is used to store the network address data passed in as
 *			"PDU" data in the internal structures.
 * 		ConvertNetworkAddressInfoToPDU
 *			This routine is used to convert the network address info structures
 *			maintained internally into the "PDU" form which is a 
 *			SetOfNetworkAddresses.
 *		ConvertTransferModesToInternal
 *			This routine is used to convert the PDU network address transfer 
 *			modes structure into the internal form where the structure is saved
 *			as a GCCTranferModes structure.
 *		ConvertHighLayerCompatibilityToInternal
 *			This routine is used to convert the PDU network address high layer
 *			compatibility structure into the internal form where the structure
 *			is saved as a GCCHighLayerCompatibility structure.
 *		ConvertTransferModesToPDU
 *			This routine is used to convert the API network address transfer
 *			modes structure into the PDU form which is a TranferModes structure.
 *		ConvertHighLayerCompatibilityToPDU
 *			This routine is used to convert the API network address high layer
 *			compatibility structure into the PDU form which is a 
 *			HighLayerCompatibility structure.
 *		IsDialingStringValid
 *			This routine is used to ensure that the values held within a
 *			dialing string do not violate the imposed ASN.1 constraints.
 *		IsCharacterStringValid
 *			This routine is used to ensure that the values held within a
 *			character string do not violate the imposed ASN.1 constraints.
 *		IsExtraDialingStringValid
 *			This routine is used to ensure that the values held within an
 *			extra dialing string do not violate the imposed ASN.1 constraints.
 *
 *	Caveats:
 *		This container stores much of the network address information internally
 *		using an "API" GCCNetworkAddress structure.  Any data referenced by
 *		pointers in this structure is stored in some other container.
 *		Therefore, the pointers held within the internal "API" structure are
 *		not valid and must not be accessed.
 *
 *	Author:
 *		blp/jbo
 */
#include <stdio.h>

#include "ms_util.h"
#include "netaddr.h"

/*
 * These macros are used to define the size constraints of an "nsap" address.
 */
#define		MINIMUM_NSAP_ADDRESS_SIZE		1
#define		MAXIMUM_NSAP_ADDRESS_SIZE		20

/*
 * These macros are used to verify that a network address has a valid number
 * of network address entities.
 */
#define		MINIMUM_NUMBER_OF_ADDRESSES		1
#define		MAXIMUM_NUMBER_OF_ADDRESSES		64

/*
 * These macros are used to define the size constraints of an extra dialing
 * string.
 */
#define		MINIMUM_EXTRA_DIALING_STRING_SIZE		1
#define		MAXIMUM_EXTRA_DIALING_STRING_SIZE		255



NET_ADDR::NET_ADDR(void)
:
    pszSubAddress(NULL),
    pwszExtraDialing(NULL),
    high_layer_compatibility(NULL),
    poszTransportSelector(NULL),
    poszNonStandardParam(NULL),
	object_key(NULL)
{
}


NET_ADDR::~NET_ADDR(void)
{
    switch (network_address.network_address_type)
    {
    case GCC_AGGREGATED_CHANNEL_ADDRESS:
		delete pszSubAddress;
		delete pwszExtraDialing;
		delete high_layer_compatibility;
        break;
    case GCC_TRANSPORT_CONNECTION_ADDRESS:
		delete poszTransportSelector;
        break;
    case GCC_NONSTANDARD_NETWORK_ADDRESS:
		delete poszNonStandardParam;
		if (NULL != object_key)
        {
            object_key->Release();
        }
        break;
    default:
        ERROR_OUT(("NET_ADDR::~NET_ADDR: unknown addr type=%u", (UINT) network_address.network_address_type));
        break;
	}
}


/*
 *	CNetAddrListContainer()
 *
 *	Public Function Description:
 * 		This constructor is used when creating a CNetAddrListContainer object with
 *		the "API" form of network address, GCCNetworkAddress.
 */
CNetAddrListContainer::
CNetAddrListContainer(UINT                 number_of_network_addresses,
                      PGCCNetworkAddress    *network_address_list,
                      PGCCError             return_value )  
:
    CRefCount(MAKE_STAMP_ID('N','t','A','L')),
    m_pSetOfNetAddrPDU(NULL),
    m_fValidNetAddrPDU(FALSE),
    m_cbDataSize(0)
{
	/*
	 * Initialize the instance variables.  The m_NetAddrItemList which
	 * will hold the network address data internally will be filled in by the
	 * call to StoreNetworkAddressList.
	 */

	/*
	 * Check to make sure a valid number of network addresses exist.
	 */
	if ((number_of_network_addresses < MINIMUM_NUMBER_OF_ADDRESSES)
			|| (number_of_network_addresses > MAXIMUM_NUMBER_OF_ADDRESSES))
	{
		ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: ERROR Invalid number of network addresses, %u", (UINT) number_of_network_addresses));
		*return_value = GCC_BAD_NETWORK_ADDRESS;
	}
	/*
	 * Check to make sure that the list pointer is valid.
	 */
	else if (network_address_list == NULL)
	{
		ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: ERROR NULL address list"));
		*return_value = GCC_BAD_NETWORK_ADDRESS;
	}
	/*
	 * Save the network address(es) in the internal structures.
	 */
	else
	{
		*return_value = StoreNetworkAddressList(number_of_network_addresses,
												network_address_list);
	}
}

/*
 *	CNetAddrListContainer()
 *
 *	Public Function Description:
 * 		This constructor is used when creating a CNetAddrListContainer object with
 *		the "PDU" form of network address, SetOfNetworkAddresses.
 */
CNetAddrListContainer::
CNetAddrListContainer(PSetOfNetworkAddresses    network_address_list, 
                      PGCCError                 return_value )
:
    CRefCount(MAKE_STAMP_ID('N','t','A','L')),
    m_pSetOfNetAddrPDU(NULL),
    m_fValidNetAddrPDU(FALSE),
    m_cbDataSize(0)
{
	PSetOfNetworkAddresses		network_address_ptr;

	/*
	 * Initialize the instance variables.  The m_NetAddrItemList which
	 * will hold the network address data internally will be filled in by the
	 * calls to ConvertPDUDataToInternal.
	 */

	*return_value = GCC_NO_ERROR;
	network_address_ptr = network_address_list;

	/*
	 * Loop through the set of network addresses, saving each in an internal
	 * NET_ADDR structure and saving those structures in the internal
	 * list.
	 */
	if (network_address_list != NULL)
	{
		while (1)
		{
			/*
			 * Convert each "PDU" network address into the internal form.  Note
			 * that object ID validation is not performed on data received as
			 * a PDU.  If a bad object ID comes in on the wire, this will be
			 * flagged as an allocation failure.
			 */
			if (ConvertPDUDataToInternal (network_address_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Error converting PDU data to internal"));
				*return_value = GCC_ALLOCATION_FAILURE;
				break;
			}
			else
            {
				network_address_ptr = network_address_ptr->next;
            }

			if (network_address_ptr == NULL)
				break;
		}
	}
}

/*
 *	CNetAddrListContainer()
 *
 *	Public Function Description:
 *		This is the copy constructor used to create a new CNetAddrListContainer
 *		object from an existing CNetAddrListContainer object. 
 */
CNetAddrListContainer::
CNetAddrListContainer(CNetAddrListContainer *address_list,
                      PGCCError		        pRetCode)
:
    CRefCount(MAKE_STAMP_ID('N','t','A','L')),
    m_pSetOfNetAddrPDU(NULL),
    m_fValidNetAddrPDU(FALSE),
    m_cbDataSize(0)
{
	NET_ADDR    				    *network_address_info;
	NET_ADDR	    			    *lpNetAddrInfo;
	GCCNetworkAddressType			network_address_type;
	GCCError						rc;

	/*
	 * Set up an iterator for the internal list of network addresses.
	 */
	address_list->m_NetAddrItemList.Reset();

    /*
	 * Copy each NET_ADDR structure contained in the 
	 * CNetAddrListContainer object to	be copied.
	 */
	while (NULL != (lpNetAddrInfo = address_list->m_NetAddrItemList.Iterate()))
	{
		/*
		 * Create a new NET_ADDR structure to hold each element of the
		 * new CNetAddrListContainer object.  Report an error if creation of this 
		 * structure fails.
		 */
		DBG_SAVE_FILE_LINE
		if (NULL == (network_address_info = new NET_ADDR))
		{
			ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create NET_ADDR"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

        /*
		 * First copy the GCCNetworkAddress structure contained in the
		 * internal NET_ADDR structure.  This copies all data
		 * except that referenced by pointers in the structure.
		 */
		network_address_info->network_address = lpNetAddrInfo->network_address;

		/*
		 * Next copy any data embedded in the network address that would 
		 * not have been copied in the above operation (typically pointers 
		 * to strings).
		 */

		/*
		 * This variable is used for abbreviation.
		 */
		network_address_type = lpNetAddrInfo->network_address.network_address_type;

		/*
		 * The network address is the "Aggregated" type.
		 */
        switch (network_address_type)
        {
        case GCC_AGGREGATED_CHANNEL_ADDRESS:
			/*
			 * If a sub-address string exists, store it in a Rogue Wave
			 * container.  Set the  structure pointer to NULL if one does 
			 * not exist.
			 */
			if (lpNetAddrInfo->pszSubAddress != NULL)
			{
				if (NULL == (network_address_info->pszSubAddress =
									::My_strdupA(lpNetAddrInfo->pszSubAddress)))
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create sub address"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->pszSubAddress = NULL;
            }
					
			/*
			 * If an extra dialing string exists, store it in a Unicode
			 * String object.  Set the  structure pointer to NULL if one 
			 * does not exist.
			 */
			if (lpNetAddrInfo->pwszExtraDialing != NULL)
			{
				if (NULL == (network_address_info->pwszExtraDialing =
									::My_strdupW(lpNetAddrInfo->pwszExtraDialing)))
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't creating extra dialing string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->pwszExtraDialing = NULL;
            }

			/*
			 * If a higher layer compatibility structure exists, store it 
			 * in a GCCHighLayerCompatibility structure.  Set the structure
			 * pointer to NULL if one does not exist.
			 */
			if (lpNetAddrInfo->high_layer_compatibility != NULL)
			{
				DBG_SAVE_FILE_LINE
				network_address_info->high_layer_compatibility = new GCCHighLayerCompatibility;
				if (network_address_info->high_layer_compatibility != NULL)
				{
					/*
					 * Copy the high layer compatibility data to the
					 * new structure.
					 */
					*network_address_info->high_layer_compatibility =  
							*(lpNetAddrInfo->high_layer_compatibility);
				}
				else
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Error creating new GCCHighLayerCompat"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->high_layer_compatibility = NULL;
            }
            break;

		/*
		 * The network address is the "Transport Connection" type.
		 */
        case GCC_TRANSPORT_CONNECTION_ADDRESS:
			/*
			 * If a transport selector exists, store it in a Rogue Wave 
			 * container.  Otherwise, set the structure pointer to NULL.
			 */
			if (lpNetAddrInfo->poszTransportSelector != NULL)
			{
				if (NULL == (network_address_info->poszTransportSelector =
									::My_strdupO(lpNetAddrInfo->poszTransportSelector)))
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create transport selector"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->poszTransportSelector = NULL;
            }
            break;

		/*
		 * The network address is the "Non-Standard" type.
		 */
        case GCC_NONSTANDARD_NETWORK_ADDRESS:
			/*
			 * First store the non-standard parameter data in a Rogue Wave
			 * container.
			 */
			if (NULL == (network_address_info->poszNonStandardParam =
								::My_strdupO(lpNetAddrInfo->poszNonStandardParam)))
			{
				ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create non-standard param"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}

			/*
			 * Next store the object key internally in an CObjectKeyContainer
			 * object.  Note that there is no need to report the error
			 * "BAD_NETWORK_ADDRESS" here since the object key data 
			 * would have been validated when the original network address
			 * was created.
			 */
			DBG_SAVE_FILE_LINE
			network_address_info->object_key = new CObjectKeyContainer(lpNetAddrInfo->object_key, &rc);
			if ((network_address_info->object_key == NULL) || (rc != GCC_NO_ERROR))
			{
				ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Error creating new CObjectKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
            break;

		/*
		 * The network address is of unknown type.  This should never be
		 * encountered so flag it as an allocation failure.
		 */
        default:
			ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Invalid type received as PDU"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		/*
		 * Go ahead and insert the pointer to the NET_ADDR
		 * structure into the internal Rogue Wave list.
		 */
		m_NetAddrItemList.Append(network_address_info);
	}

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete network_address_info;
    }

    *pRetCode = rc;
}


/*
 *	~CNetAddrListContainer()
 *
 *	Public Function Description:
 *		The destructor is used to free up any memory allocated during the life
 * 		of the object.
 */
CNetAddrListContainer::
~CNetAddrListContainer(void)
{
	
	/*
	 * Free any data allocated to hold "PDU" information.
	 */
	if (m_fValidNetAddrPDU)
    {
		FreeNetworkAddressListPDU();
    }

	/*
	 * Free any data allocated for the internal list of "info" structures.
	 */
	NET_ADDR *pNetAddrInfo;
	m_NetAddrItemList.Reset();
	while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
	{
		delete pNetAddrInfo;
	}
}


/*
 *	LockNetworkAddressList ()
 *
 *	Public Function Description:
 *		This routine is called to "Lock" the network address data in "API" form.
 *		The amount of memory required to hold the "API" data which is referenced
 *		by, but not included in the GCCNetworkAddress structure, will be
 *		returned. 
 *
 */
UINT CNetAddrListContainer::
LockNetworkAddressList(void)
{  
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data.  Otherwise, just increment the 
	 * lock count.
	 */
	if (Lock() == 1)
	{
    	PGCCNetworkAddress		network_address;
	    NET_ADDR    		    *lpNetAddrInfo;

		/*
		 * Set aside memory to hold the pointers to the GCCNetworkAddress
		 * structures as well as the structures themselves.  The "sizeof" the 
		 * structure must be rounded to an even four-byte boundary.
		 */
		m_cbDataSize = m_NetAddrItemList.GetCount() * 
				( sizeof(PGCCNetworkAddress) + ROUNDTOBOUNDARY(sizeof(GCCNetworkAddress)) );

		/*
		 * Loop through the list of network addresses, adding up the space
		 * requirements of each address.
		 */
		m_NetAddrItemList.Reset();
	 	while (NULL != (lpNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			/*
			 * Use a local variable to keep from having to access the Rogue Wave
			 * iterator repeatedly.
			 */
			network_address = &lpNetAddrInfo->network_address;

			/*
			 * Check to see what type of network address exists.
			 */
			switch (network_address->network_address_type)
            {
            case GCC_AGGREGATED_CHANNEL_ADDRESS:
				/*
				 * Add the length of the sub address string if it exists.
				 */
				if (lpNetAddrInfo->pszSubAddress != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(::lstrlenA(lpNetAddrInfo->pszSubAddress) + 1);
				}

				/*
				 * Add the size of the GCCExtraDialingString structure as well
				 * as the length of the extra dialing string if it exists.
				 */
				if (lpNetAddrInfo->pwszExtraDialing != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(sizeof(GCCExtraDialingString)) +
                                    ROUNDTOBOUNDARY((::lstrlenW(lpNetAddrInfo->pwszExtraDialing) + 1) * sizeof(WCHAR));
				}

				/*
				 * Add the size of the high layer compatibility structure if
				 * it exists.
				 */
				if (lpNetAddrInfo->high_layer_compatibility != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(sizeof(GCCHighLayerCompatibility));
				}
                break;

            case GCC_TRANSPORT_CONNECTION_ADDRESS:
				/*
				 * Add the size of the OSTR structure as well as the
				 * length of the octet string if it exists.
				 */
				if (lpNetAddrInfo->poszTransportSelector != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(sizeof(OSTR)) +
					                ROUNDTOBOUNDARY(lpNetAddrInfo->poszTransportSelector->length); 
				}
                break;

            case GCC_NONSTANDARD_NETWORK_ADDRESS:
				/*
				 * Lock the object key in the non-standard parameter in order to
				 * determine the amount of memory needed to hold its data.
				 */
				m_cbDataSize += lpNetAddrInfo->object_key->LockObjectKeyData ();

				/*
				 * Add the space needed to hold the octet string data for the 
				 * non-standard parameter.
				 */
				m_cbDataSize += ROUNDTOBOUNDARY(lpNetAddrInfo->poszNonStandardParam->length);
                break;
			}
		}
	}

	return m_cbDataSize;
} 


/*
 *	GetNetworkAddressListAPI ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the list of network addresses in "API"
 *		form.
 */
UINT CNetAddrListContainer::
GetNetworkAddressListAPI(UINT				*	number_of_network_addresses,
                         PGCCNetworkAddress	**	network_address_list,
                         LPBYTE					memory)
{
	UINT					cbDataSizeToRet = 0;
	UINT					data_length = 0;
	UINT					network_address_counter = 0;
	PGCCNetworkAddress		network_address_ptr;
	NET_ADDR    		    *address_info;
	PGCCNetworkAddress		*address_array;

	/*
	 * If the user data has been locked, fill in the output parameters and
	 * the data referenced by the pointers.  Otherwise, report that the object
	 * has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		// NET_ADDR	*lpNetAddrInfo;

		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the number of network address entities and save a pointer to 
		 * the memory location passed in.  This is where the pointers to the 
		 * GCCNetworkAddress structures will be written.  The actual structures 
		 * will be written into memory immediately following the list of 
		 * pointers.
		 */
		*number_of_network_addresses = (UINT) m_NetAddrItemList.GetCount();

		*network_address_list = (PGCCNetworkAddress *)memory;
		address_array = *network_address_list;

		/*
		 * Save the amount of memory needed to hold the list of pointers as
		 * well as the actual network address structures.
		 */
		data_length = m_NetAddrItemList.GetCount() * sizeof(PGCCNetworkAddress);

		/*
		 * Move the memory pointer past the list of network address pointers.  
		 * This is where the first network address structure will be written.
		 */
		memory += data_length;

		/*
		 * Iterate through the internal list of NET_ADDR structures,
		 * building "API" GCCNetworkAddress structures in memory.
		 */
		m_NetAddrItemList.Reset();
		while (NULL != (address_info = m_NetAddrItemList.Iterate()))
		{
			/*
			 * Save the pointer to the network address structure in the list 
			 * of pointers.
			 */
			network_address_ptr = (PGCCNetworkAddress)memory;
			address_array[network_address_counter++] = network_address_ptr;

			/*
			 * Move the memory pointer past the network address structure.  
			 * This is where the network address data will be written.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCNetworkAddress));

			/*
			 * Check to see what type of network address this is and fill in 
			 * the user data structure.  Here the address is the aggregated
			 * channel type.
			 */
			switch (address_info->network_address.network_address_type)
            {
            case GCC_AGGREGATED_CHANNEL_ADDRESS:
				network_address_ptr->network_address_type =	GCC_AGGREGATED_CHANNEL_ADDRESS;

				/*
				 * Copy the transfer modes.
				 */
				network_address_ptr->u.aggregated_channel_address.transfer_modes = 
					address_info->network_address.u.aggregated_channel_address.transfer_modes;

				/*
				 * Copy the international number.
				 */
                ::lstrcpyA(network_address_ptr->u.aggregated_channel_address.international_number,
						   address_info->network_address.u.aggregated_channel_address.international_number);

				/*
				 * If the sub address string exists, set the sub address string
				 * pointer and write the data into memory.  Otherwise, set the
				 * "API" pointer to NULL.
				 */
				if (address_info->pszSubAddress != NULL)
				{
					network_address_ptr->u.aggregated_channel_address.sub_address_string = 
																(GCCCharacterString)memory;

					/*
					 * Now copy the sub-address string data from the internal 
					 * Rogue Wave string into memory.
					 */		
                    ::lstrcpyA((LPSTR) memory, address_info->pszSubAddress);

					/*
					 * Move the memory pointer past the sub-address string data.
					 * This is where the GCCExtraDialingString structure will be
					 * written.
					 */
					memory += ROUNDTOBOUNDARY(::lstrlenA(address_info->pszSubAddress) + 1);
				}
				else
				{
					/*
					 * No sub-address was present so set the pointer to NULL.
					 */
					network_address_ptr->u.aggregated_channel_address.sub_address_string = NULL;
				}

				/*
				 * If the extra dialing string exists, set the extra dialing
				 * string pointer and write the data into memory.  Otherwise,
				 * set the "API" pointer to NULL.
				 */
				if (address_info->pwszExtraDialing != NULL)
				{
					network_address_ptr->u.aggregated_channel_address.extra_dialing_string = 
							(PGCCExtraDialingString)memory;

					/*
					 * Move the memory pointer past the GCCExtraDialingString
					 * structure.  This is where the extra dialing string data 
					 * will	be written.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(GCCExtraDialingString));

					UINT cchExtraDialing = ::lstrlenW(address_info->pwszExtraDialing);
					network_address_ptr->u.aggregated_channel_address.extra_dialing_string->length = 
							(USHORT) cchExtraDialing;

					network_address_ptr->u.aggregated_channel_address.extra_dialing_string->value = 
																		(LPWSTR)memory;

					/*
					 * Now copy the hex string data from the internal Unicode 
					 * String into the allocated memory.
					 */
					//
					// LONCHANC: The size does not include null terminator in the original code.
					// could this be a bug???
					//
					::CopyMemory(memory, address_info->pwszExtraDialing, cchExtraDialing * sizeof(WCHAR));

					/*
					 * Move the memory pointer past the extra dialing string 
					 * data.  This is where the high layer compatibility 
					 * structure will be written.
					 */
					memory += ROUNDTOBOUNDARY(cchExtraDialing * sizeof(WCHAR));
				}
				else
				{
					/*
					 * No extra dialing string was present so set the pointer
					 * to NULL.
					 */
					network_address_ptr->u.aggregated_channel_address.extra_dialing_string = NULL;
				}

				/*
				 * If the high layer compatibility structure exists, set the 
				 * pointer and write the data into memory.  Otherwise, set
				 * the "API" pointer to NULL.
				 */
				if (address_info->high_layer_compatibility != NULL)
				{
					network_address_ptr->u.aggregated_channel_address.high_layer_compatibility = 
							(PGCCHighLayerCompatibility)memory;

					*network_address_ptr->u.aggregated_channel_address.high_layer_compatibility =
                            *(address_info->high_layer_compatibility);

					/*
					 * Move the memory pointer past the high layer 
					 * compatibility structure.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(GCCHighLayerCompatibility));
				}
				else
				{
					/*
					 * No high layer compatibility structure was present so 
					 * set the pointer to NULL.
					 */
					network_address_ptr->u.aggregated_channel_address.
							high_layer_compatibility = NULL;
				}
                break;

			/*
			 * The network address is a transport connection type.
			 */
            case GCC_TRANSPORT_CONNECTION_ADDRESS:
				network_address_ptr->network_address_type = GCC_TRANSPORT_CONNECTION_ADDRESS;

				/*
				 * Now copy the nsap address.
				 */		
                ::CopyMemory(network_address_ptr->u.transport_connection_address.nsap_address.value, 
							address_info->network_address.u.transport_connection_address.nsap_address.value, 
							address_info->network_address.u.transport_connection_address.nsap_address.length);

                network_address_ptr->u.transport_connection_address.nsap_address.length =
                            address_info->network_address.u.transport_connection_address.nsap_address.length; 

				/*
				 * If a transport selector exists, set the transport selector 
				 * pointer and write the data into memory.  Otherwise, set the
				 * "API" pointer to NULL.
				 */
				if (address_info->poszTransportSelector != NULL)
				{
					network_address_ptr->u.transport_connection_address.transport_selector = (LPOSTR) memory;

					/*
					 * Move the memory pointer past the OSTR 
					 * structure.  This is where the actual string data will 
					 * be written.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(OSTR));

					network_address_ptr->u.transport_connection_address.
							transport_selector->value = (LPBYTE)memory;

					network_address_ptr->u.transport_connection_address.
							transport_selector->length =
								address_info->poszTransportSelector->length;

					/*
					 * Now copy the transport selector string data from the 
					 * internal Rogue Wave string into memory.
					 */		
					::CopyMemory(memory, address_info->poszTransportSelector->value,
								address_info->poszTransportSelector->length);

					/*
					 * Move the memory pointer past the transport selector
					 * string data.
					 */
					memory += ROUNDTOBOUNDARY(address_info->poszTransportSelector->length);
				}
				else
				{
					network_address_ptr->u.transport_connection_address.transport_selector = NULL;
				}
                break;

			/*
			 * The network address is a non-standard type.
			 */
            case GCC_NONSTANDARD_NETWORK_ADDRESS:
				network_address_ptr->network_address_type = GCC_NONSTANDARD_NETWORK_ADDRESS;

				/*
				 * Check to make sure both elements of the non-standard address
				 * exist in the internal structure.
				 */
				if ((address_info->poszNonStandardParam == NULL) ||
						(address_info->object_key == NULL))
				{
					ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListAPI: Bad internal pointer"));
					cbDataSizeToRet = 0;
				}
				else
				{
					data_length = address_info->object_key->
							GetGCCObjectKeyData( &network_address_ptr->u.
							non_standard_network_address.object_key, 
							memory);

					/*
					 * Move the memory pointer past the object key data.  This 
					 * is where the octet string data will be written.
					 */
					memory += data_length;

					network_address_ptr->u.non_standard_network_address.parameter_data.value = 
							memory;

					/*
					 * Write the octet string data into memory and set the octet 
					 * string structure pointer and length.
					 */
					network_address_ptr->u.non_standard_network_address.parameter_data.length = 
								(USHORT) address_info->poszNonStandardParam->length;

					/*
					 * Now copy the octet string data from the internal Rogue 
					 * Wave string into the object key structure held in memory.
					 */		
					::CopyMemory(memory, address_info->poszNonStandardParam->value,
								address_info->poszNonStandardParam->length);

					/*
					 * Move the memory pointer past the octet string data.
					 */
					memory += ROUNDTOBOUNDARY(address_info->poszNonStandardParam->length);
				}
                break;

            default:
                ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListAPI: Error Bad type."));
                break;
            } // switch
        } // while
	}
	else
	{
    	*network_address_list = NULL;
		*number_of_network_addresses = 0;
		ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListAPI: Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnLockNetworkAddressList ()
 *
 *	Public Function Description:
 *		This routine unlocks any memory which has been locked for the "API" 
 *		form of the network address list.  If the "Free" flag has been set then
 * 		the CNetAddrListContainer object will be destroyed.
 *
 */
void CNetAddrListContainer::
UnLockNetworkAddressList(void)
{
	/*
	 * If the lock count has reached zero, this object is "unlocked" so do
	 * some cleanup.
	 */
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock any memory locked for the CObjectKeyContainer objects in the
		 * internal NET_ADDR structures.
		 */
		NET_ADDR *pNetAddrInfo;
		m_NetAddrItemList.Reset();
		while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			if (pNetAddrInfo->object_key != NULL)
			{
				pNetAddrInfo->object_key->UnLockObjectKeyData();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}
   

/*
 *	GetNetworkAddressListPDU ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the network address list in "PDU" form.
 */
GCCError CNetAddrListContainer::
GetNetworkAddressListPDU(PSetOfNetworkAddresses *set_of_network_addresses)
{
	GCCError					rc = GCC_NO_ERROR;
	PSetOfNetworkAddresses		new_pdu_network_address_ptr;
	PSetOfNetworkAddresses		old_pdu_network_address_ptr = NULL;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidNetAddrPDU == FALSE)
	{
		m_fValidNetAddrPDU = TRUE;

		/*
		 * Initialize the output parameter to NULL so that the first time
		 * through it will be set equal to the first new set of network address
		 * data created in the iterator loop.
		 */
		m_pSetOfNetAddrPDU = NULL;
		
		/*
		 * Iterate through the list of NET_ADDR structures, 
		 * converting each into "PDU" form and saving the pointers in the 
		 * linked list of "SetsOfNetworkAddresses".
		 */
		NET_ADDR *pNetAddrInfo;
		m_NetAddrItemList.Reset();
		while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			DBG_SAVE_FILE_LINE
			new_pdu_network_address_ptr = new SetOfNetworkAddresses;
			if (new_pdu_network_address_ptr == NULL)
			{
				ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListPDU: Allocation error, cleaning up"));
				rc = GCC_ALLOCATION_FAILURE;
				FreeNetworkAddressListPDU ();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfNetworkAddresses created.  On subsequent loops,
			 * set the structure's "next" pointer equal to the new structure.
			 */
			if (m_pSetOfNetAddrPDU == NULL)
            {
				m_pSetOfNetAddrPDU = new_pdu_network_address_ptr;
            }
			else
            {
				old_pdu_network_address_ptr->next = new_pdu_network_address_ptr;
            }

			old_pdu_network_address_ptr = new_pdu_network_address_ptr;

			/*
			 * Initialize the new "next" pointer to NULL.
			 */
			new_pdu_network_address_ptr->next = NULL;

			/*
			 * Call the routine to actually convert the network address.
			 */
			if (ConvertNetworkAddressInfoToPDU(pNetAddrInfo, new_pdu_network_address_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListPDU: can't create NET_ADDR to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*set_of_network_addresses = m_pSetOfNetAddrPDU;

	return rc;
}


/*
 *	FreeNetworkAddressListPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the memory allocated for the "PDU" form
 *		of the network address list.
 */
GCCError CNetAddrListContainer::
FreeNetworkAddressListPDU(void)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfNetworkAddresses			pdu_network_address_set;
	PSetOfNetworkAddresses			next_pdu_network_address_set;

	if (m_fValidNetAddrPDU)
	{
		m_fValidNetAddrPDU = FALSE;

		pdu_network_address_set = m_pSetOfNetAddrPDU;

		/*
		 * Loop through the list, freeing the network address data associated 
		 * with each structure contained in the list. The only data allocated
		 * for the PDU which is not held in the internal info structure list
		 * is done by the CObjectKeyContainer object.  Those objects are told to free
		 * that data in the iterator loop below.
		 */
		while (pdu_network_address_set != NULL)
		{
			next_pdu_network_address_set = pdu_network_address_set->next;
			delete pdu_network_address_set;
			pdu_network_address_set = next_pdu_network_address_set;
		}

		/*
		 * Free any PDU memory allocated by the internal CObjectKeyContainer object.
		 */
		NET_ADDR *pNetAddrInfo;
		m_NetAddrItemList.Reset();
		while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			if (pNetAddrInfo->object_key != NULL)
            {
				pNetAddrInfo->object_key->FreeObjectKeyDataPDU();
            }
		}
	}
	else
	{
		ERROR_OUT(("NetAddressList::FreeUserDataListPDU: PDU Data not allocated"));
		rc = GCC_BAD_NETWORK_ADDRESS;
	}

	return (rc);
}

/*
 *	GCCError	StoreNetworkAddressList (	
 *						UINT					number_of_network_addresses,
 *						PGCCNetworkAddress 	*	local_network_address_list);
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to store the network address data passed in as
 *		"API" data in the internal structures.
 *
 *	Formal Parameters:
 *		number_of_network_addresses	(i)	Number of addresses in "API" list.
 *		local_network_address_list	(i) List of "API" addresses.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CNetAddrListContainer::
StoreNetworkAddressList(UINT					number_of_network_addresses,
						PGCCNetworkAddress 	*	local_network_address_list)
{
	GCCError						rc;
	NET_ADDR				        *network_address_info;
	PGCCNetworkAddress				network_address;
	UINT							i;
	
	/*
	 * For each network address in the list, create a new "info" structure to 
	 * buffer the data internally.  Fill in the structure and save it in the
	 * Rogue Wave list.
	 */
	for (i = 0; i < number_of_network_addresses; i++)
	{
		DBG_SAVE_FILE_LINE
		if (NULL == (network_address_info = new NET_ADDR))
		{
            ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't create NET_ADDR"));
			rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

		/*
		 * This variable is used for abbreviation.
		 */
		network_address = &network_address_info->network_address;
		
		/*
		 * Copy all the network address data into the network address
		 * structure that is part of the network address info structure.
		 */									
		*network_address = *local_network_address_list[i];
		
		/*
		 * This section of the code deals with any data embedded in the
		 * network address that would not have been copied in the above
		 * operation (typically pointers to strings).
		 */
		switch (network_address->network_address_type)
        {
        case GCC_AGGREGATED_CHANNEL_ADDRESS:
			/*
			 * Check to make sure the international number dialing string
			 * does not violate the imposed ASN.1 constraints.
			 */
			if (! IsDialingStringValid(local_network_address_list[i]->u.aggregated_channel_address.international_number))
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid international number"));
				rc = GCC_BAD_NETWORK_ADDRESS;
				goto MyExit;
			}

			/*
			 * If a sub-address string exists, store it in a Rogue Wave
			 * container.  Set the  structure pointer to NULL if one does 
			 * not exist.
			 */
			if (local_network_address_list[i]->u.aggregated_channel_address.sub_address_string != NULL)
			{
				/*
				 * Check to make sure the sub address string does not 
				 * violate the imposed ASN.1 constraints.
				 */
				if (! IsCharacterStringValid(local_network_address_list[i]->u.aggregated_channel_address.sub_address_string))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid sub address string"));
					rc = GCC_BAD_NETWORK_ADDRESS;
					goto MyExit;
				}

				/*			
				 * Create a  string to hold the sub address.
				 */
				if (NULL == (network_address_info->pszSubAddress = ::My_strdupA(
								(LPSTR) local_network_address_list[i]->u.aggregated_channel_address.sub_address_string)))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't creating new sub address string"));
					rc = GCC_ALLOCATION_FAILURE;
                    goto MyExit;
				}
			}
			else
            {
				network_address_info->pszSubAddress = NULL;
            }

            /*
			 * If an extra dialing string exists, store it in a Unicode
			 * String object.  Set the  structure pointer to NULL if one 
			 * does not exist.
			 */
			if (local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string != NULL)
			{
				/*
				 * Check to make sure the extra dialing string does not 
				 * violate the imposed ASN.1 constraints.
				 */
				if (! IsExtraDialingStringValid(local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid extra dialing string"));
					rc = GCC_BAD_NETWORK_ADDRESS;
					goto MyExit;
				}

				if (NULL == (network_address_info->pwszExtraDialing = ::My_strdupW2(
								local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string->length,
								local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string->value)))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Error creating extra dialing string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->pwszExtraDialing = NULL;
            }

			/*
			 * If a higher layer compatibility structure exists, store it 
			 * in a GCCHighLayerCompatibility structure.  Set the structure
			 * pointer to NULL if one does not exist.
			 */
			if (local_network_address_list[i]->u.aggregated_channel_address.high_layer_compatibility != NULL)
			{
				DBG_SAVE_FILE_LINE
				network_address_info->high_layer_compatibility = new GCCHighLayerCompatibility;
				if (network_address_info->high_layer_compatibility != NULL)
				{
					/*
					 * Copy the high layer compatibility data to the
					 * new structure.
					 */
					*network_address_info->high_layer_compatibility =  
							*(local_network_address_list[i]->u.aggregated_channel_address.high_layer_compatibility);
				}
				else
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Error creating new GCCHighLayerCompatibility"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->high_layer_compatibility = NULL;
            }
            break;

        case GCC_TRANSPORT_CONNECTION_ADDRESS:
			/*
			 * Check to make sure the length of the nsap address is within
			 * the allowable range.
			 */
			if ((local_network_address_list[i]->u.transport_connection_address.nsap_address.length < MINIMUM_NSAP_ADDRESS_SIZE)
                ||
				(local_network_address_list[i]->u.transport_connection_address.nsap_address.length > MAXIMUM_NSAP_ADDRESS_SIZE))
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid nsap address"));
				rc = GCC_BAD_NETWORK_ADDRESS;
				goto MyExit;
			}

			/*
			 * If a transport selector exists, store it in a Rogue Wave 
			 * string.  Otherwise, set the structure pointer to NULL.
			 */
			if (local_network_address_list[i]->u.transport_connection_address.transport_selector != NULL)
			{
				/*			
				 * Create a Rogue Wave string to hold the transport
				 * selector string.
				 */
				if (NULL == (network_address_info->poszTransportSelector = ::My_strdupO2(
								local_network_address_list[i]->u.transport_connection_address.transport_selector->value,
						 		local_network_address_list[i]->u.transport_connection_address.transport_selector->length)))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't create transport selector"));
					rc = GCC_ALLOCATION_FAILURE;
                    goto MyExit;
				}
			}
			else
            {
				network_address_info->poszTransportSelector = NULL;
            }
            break;

        case GCC_NONSTANDARD_NETWORK_ADDRESS:
			/*			
			 * Create a Rogue Wave string to hold the non-standard
			 * parameter octet string.
			 */
			if (NULL == (network_address_info->poszNonStandardParam = ::My_strdupO2(
								local_network_address_list[i]->u.non_standard_network_address.parameter_data.value,
					 			local_network_address_list[i]->u.non_standard_network_address.parameter_data.length)))
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't create non-standard param"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		
			/*
			 * Next store the object key internally in an CObjectKeyContainer
			 * object.
			 */
			DBG_SAVE_FILE_LINE
			network_address_info->object_key = new CObjectKeyContainer(
					&local_network_address_list[i]->u.non_standard_network_address.object_key,
					&rc);
			if (network_address_info->object_key == NULL || rc != GCC_NO_ERROR)
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetAddrList: Error creating new CObjectKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
            break;

        default:
			ERROR_OUT(("CNetAddrListContainer::StoreNetAddrList: bad network address type=%u", (UINT) network_address->network_address_type));
			rc = GCC_BAD_NETWORK_ADDRESS_TYPE;
			goto MyExit;
		}

		/*
		 * If all data was properly saved, insert the "info" structure
		 * pointer into the Rogue Wave list.
		 */
		m_NetAddrItemList.Append(network_address_info);
	} // for

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete network_address_info;
    }

    return rc;
}

/*
 *	GCCError	ConvertPDUDataToInternal (	
 *						PSetOfNetworkAddresses			network_address_ptr)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to store the network address data passed in as
 *		"PDU" data in the internal structures.
 *
 *	Formal Parameters:
 *		network_address_ptr	(i) 	"PDU" address list structure.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CNetAddrListContainer::
ConvertPDUDataToInternal(PSetOfNetworkAddresses network_address_ptr)
{
	GCCError					rc;
	GCCError					error_value;
	NET_ADDR    			    *network_address_info_ptr;
	PGCCNetworkAddress			copy_network_address;
	PNetworkAddress				pdu_network_address;

	/*
	 * Create a new info structure to hold the data internally.
	 */
	DBG_SAVE_FILE_LINE
	if (NULL == (network_address_info_ptr = new NET_ADDR))
	{
		ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create NET_ADDR"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

    /*
	 * Use these variables for clarity and brevity.
	 */
	copy_network_address = &network_address_info_ptr->network_address;
	pdu_network_address = &network_address_ptr->value; 

	/*
	 * Check to see what type of network address exists and save the data
	 * in the internal structures.
	 */
	switch (pdu_network_address->choice)
    {
    case AGGREGATED_CHANNEL_CHOSEN:
		copy_network_address->network_address_type = GCC_AGGREGATED_CHANNEL_ADDRESS;

		/*
		 * Save the tranfer modes structure.
		 */
		ConvertTransferModesToInternal(
				&pdu_network_address->u.aggregated_channel.transfer_modes,
				&copy_network_address->u.aggregated_channel_address.transfer_modes);
						
		/*
		 * Save the international number.
		 */
        ::lstrcpyA(copy_network_address->u.aggregated_channel_address.international_number,
					pdu_network_address->u.aggregated_channel.international_number);
						
		/*
		 * Save the sub address string (if it exists) in the Rogue Wave
		 * buffer contained in the network info structure.  Otherwise, set
		 * the structure pointer to NULL.
		 */
		if (pdu_network_address->u.aggregated_channel.bit_mask & SUB_ADDRESS_PRESENT)
		{
			/*			
			 * Create a Rogue Wave string to hold the sub address string.
			 */
			if (NULL == (network_address_info_ptr->pszSubAddress = ::My_strdupA(
								pdu_network_address->u.aggregated_channel.sub_address)))
			{
				ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create sub address string"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		}
		else
		{
			/*
			 * The sub address string is not present so set the internal
			 * info structure pointer to NULL.
			 */
			network_address_info_ptr->pszSubAddress = NULL;
		}

		/*
		 * Next save the extra dialing string if one exists.
		 */
		if (pdu_network_address->u.aggregated_channel.bit_mask & EXTRA_DIALING_STRING_PRESENT)
		{
			if (NULL == (network_address_info_ptr->pwszExtraDialing = ::My_strdupW2(
							pdu_network_address->u.aggregated_channel.extra_dialing_string.length,
							pdu_network_address->u.aggregated_channel.extra_dialing_string.value)))
			{
				ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error creating extra dialing string"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		}
		else
		{
			/*
			 * The extra dialing string is not present so set the internal
			 * info structure pointer to NULL.
			 */
			network_address_info_ptr->pwszExtraDialing = NULL;
		}

		/*
		 * Save the high layer compatibility structure if it is present.
		 */
		if (pdu_network_address->u.aggregated_channel.bit_mask & HIGH_LAYER_COMPATIBILITY_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			network_address_info_ptr->high_layer_compatibility = new GCCHighLayerCompatibility;
			if (network_address_info_ptr->high_layer_compatibility != NULL)
			{
				/*
				 * Copy the high layer compatibility data to the
				 * new structure.
				 */
				ConvertHighLayerCompatibilityToInternal(
						&pdu_network_address->u.aggregated_channel.high_layer_compatibility,
						network_address_info_ptr->high_layer_compatibility);
			}
			else
			{
				ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error creating new GCCHighLayerCompatibility"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		}
		else
		{
			/*
			 * The high layer compatibility structure is not present so set
			 * the internal	info structure pointer to NULL.
			 */
			network_address_info_ptr->high_layer_compatibility = NULL;
		}
        break;

    /*
     * Save the transport connection address.
     */
    case TRANSPORT_CONNECTION_CHOSEN:
	    copy_network_address->network_address_type = GCC_TRANSPORT_CONNECTION_ADDRESS;

	    /*
	     * Save the nsap address by copying the length and then the string.
	     */
	    copy_network_address->u.transport_connection_address.nsap_address.length =
                pdu_network_address->u.transport_connection.nsap_address.length;

        ::lstrcpyA((LPSTR)copy_network_address->u.transport_connection_address.nsap_address.value,
				    (LPSTR)pdu_network_address->u.transport_connection.nsap_address.value);
	    /*
	     * Save the transport selector if one exists.
	     */
	    if (pdu_network_address->u.transport_connection.bit_mask & TRANSPORT_SELECTOR_PRESENT)
	    {
		    /*			
		     * Create a Rogue Wave string to hold the transport
		     * selector string.
		     */
		    if (NULL == (network_address_info_ptr->poszTransportSelector = ::My_strdupO2(
						    pdu_network_address->u.transport_connection.transport_selector.value,
					 	    pdu_network_address->u.transport_connection.transport_selector.length)))
		    {
			    ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create transport selector"));
			    rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
		    }
	    }
	    else
	    {
		    /*
		     * The transport selector is not present so set the internal
		     * info structure pointer to NULL.
		     */
		    network_address_info_ptr->poszTransportSelector = NULL;
	    }
        break;

    /*
     * Save the non standard address.
     */
    case ADDRESS_NON_STANDARD_CHOSEN:
	    copy_network_address->network_address_type = GCC_NONSTANDARD_NETWORK_ADDRESS;

	    /*			
	     * Create a Rogue Wave string to hold the non-standard
	     * parameter octet string.
	     */
	    if (NULL == (network_address_info_ptr->poszNonStandardParam = ::My_strdupO2(
						    pdu_network_address->u.address_non_standard.data.value,
				 		    pdu_network_address->u.address_non_standard.data.length)))
	    {
		    ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create non-standard param"));
		    rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
	    }

	    /*
	     * Next store the object key internally in an CObjectKeyContainer
	     * object.
	     */
	    DBG_SAVE_FILE_LINE
	    network_address_info_ptr->object_key = new CObjectKeyContainer(
			    &pdu_network_address->u.address_non_standard.key,
			    &error_value);
	    if ((network_address_info_ptr->object_key == NULL) ||
			    (error_value != GCC_NO_ERROR))
	    {
		    ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error creating new CObjectKeyContainer"));
		    rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
	    }
        break;

    default:
        ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error bad network address type"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    } // switch

    /*
	 * Go ahead and save the pointer to the info structure in the 
	 * internal Rogue Wave list.
	 */
	m_NetAddrItemList.Append(network_address_info_ptr);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete network_address_info_ptr;
    }

	return rc;
}

/*
 * GCCError		ConvertNetworkAddressInfoToPDU (
 *						NET_ADDR    			    *network_address_info_ptr,
 *						PSetOfNetworkAddresses		network_address_pdu_ptr)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the network address info structures
 *		maintained internally into the "PDU" form which is a 
 *		SetOfNetworkAddresses.
 *
 *	Formal Parameters:
 *		network_address_info_ptr	(i) Internal network address structure.
 *		network_address_pdu_ptr		(o) PDU network address structure to fill in
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error converting the network address
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CNetAddrListContainer::
ConvertNetworkAddressInfoToPDU(NET_ADDR    			    *network_address_info_ptr,
                               PSetOfNetworkAddresses   network_address_pdu_ptr)
{
	GCCError				rc = GCC_NO_ERROR;
	PGCCNetworkAddress		api_ptr;
	PNetworkAddress			pdu_ptr;

	/*
	 * This variable will point to the "API" network address structure held in 
	 * the internal info structure.  It is used for brevity.
	 */
	api_ptr = &network_address_info_ptr->network_address;

	/*
	 * This variable will point to the "PDU" network address structure held in 
	 * the "SetOfNetworkAddresses" structure.  It is used for brevity.
	 */
	pdu_ptr = &network_address_pdu_ptr->value;

	/*
	 * Check to see what type of network address exists.  Fill in the
	 * appropriate form of the network address PDU structure.
	 */
	switch (api_ptr->network_address_type)
    {
    case GCC_AGGREGATED_CHANNEL_ADDRESS:
		/*
		 * Fill in the aggregated channel address PDU structure.
		 */
		pdu_ptr->choice = AGGREGATED_CHANNEL_CHOSEN;

		pdu_ptr->u.aggregated_channel.bit_mask = 0;

		/*
		 * Convert the structure holding the transfer modes into PDU form.
		 */
		ConvertTransferModesToPDU(&api_ptr->u.aggregated_channel_address.transfer_modes,
								  &pdu_ptr->u.aggregated_channel.transfer_modes);
		/*
		 * Copy the international number string.
		 */
        ::lstrcpyA(pdu_ptr->u.aggregated_channel.international_number,
				   api_ptr->u.aggregated_channel_address.international_number);

		/*
		 * Copy the sub-address string if it is present.  Set the bit mask in
		 * the PDU structure indicating that a sub-address string is present.
		 */
		if (network_address_info_ptr->pszSubAddress != NULL)
		{
			pdu_ptr->u.aggregated_channel.bit_mask |= SUB_ADDRESS_PRESENT;
            ::lstrcpyA((LPSTR) pdu_ptr->u.aggregated_channel.sub_address, 
					   network_address_info_ptr->pszSubAddress);
		}

		/* 
		 * Copy the extra dialing string if it is present.  Set the bit mask in
		 * the PDU structure indicating that an extra dialing string is present.
		 */
		if (network_address_info_ptr->pwszExtraDialing != NULL)
		{
			pdu_ptr->u.aggregated_channel.bit_mask |= EXTRA_DIALING_STRING_PRESENT;

			pdu_ptr->u.aggregated_channel.extra_dialing_string.value = 
					network_address_info_ptr->pwszExtraDialing;

			pdu_ptr->u.aggregated_channel.extra_dialing_string.length = 
					::lstrlenW(network_address_info_ptr->pwszExtraDialing);
		}

		/*
		 * Convert the structure holding the high layer compatibilities into 
		 * PDU form, if it is present.  Set the bit mask in	the PDU structure 
		 * indicating that a high layer compatibility structure is present.
		 */
		if (network_address_info_ptr->high_layer_compatibility != NULL)
		{
			pdu_ptr->u.aggregated_channel.bit_mask |= HIGH_LAYER_COMPATIBILITY_PRESENT;

			ConvertHighLayerCompatibilityToPDU(
					network_address_info_ptr->high_layer_compatibility,
					&pdu_ptr->u.aggregated_channel.high_layer_compatibility);
		}
        break;

    case GCC_TRANSPORT_CONNECTION_ADDRESS:
		/*
		 * Fill in the transport connection address PDU structure.
		 */
		pdu_ptr->choice = TRANSPORT_CONNECTION_CHOSEN;

		/*
		 * Copy the nsap_address.
		 */
		pdu_ptr->u.transport_connection.nsap_address.length = 
				api_ptr->u.transport_connection_address.nsap_address.length;
				
        ::lstrcpyA((LPSTR)pdu_ptr->u.transport_connection.nsap_address.value,
				   (LPSTR)api_ptr->u.transport_connection_address.nsap_address.value);
				
		/*
		 * Copy the transport selector if it is present.  Set the bit mask in
		 * the PDU structure indicating that a transport selector is present.
		 */
		if (network_address_info_ptr->poszTransportSelector != NULL)
		{
			pdu_ptr->u.transport_connection.bit_mask |= TRANSPORT_SELECTOR_PRESENT;

			pdu_ptr->u.transport_connection.transport_selector.length =
					network_address_info_ptr->poszTransportSelector->length;

			pdu_ptr->u.transport_connection.transport_selector.value = 
					(LPBYTE) network_address_info_ptr->poszTransportSelector->value;
		}
        break;

    case GCC_NONSTANDARD_NETWORK_ADDRESS:
		/*
		 * Fill in the non-standard network address PDU structure.
		 */
		pdu_ptr->choice = ADDRESS_NON_STANDARD_CHOSEN;

		/*
		 * Fill in the data portion of the non-standard parameter.
		 */
		pdu_ptr->u.address_non_standard.data.length = 
				network_address_info_ptr->poszNonStandardParam->length;

        pdu_ptr->u.address_non_standard.data.value = 
				network_address_info_ptr->poszNonStandardParam->value;

		/*
		 * Now fill in the object key portion of the non-standard parameter
		 * using the CObjectKeyContainer object stored internally in the network
		 * address info structure.
		 */
		rc = network_address_info_ptr->object_key->GetObjectKeyDataPDU(&pdu_ptr->u.address_non_standard.key);
		if (rc != GCC_NO_ERROR)
		{
			ERROR_OUT(("CNetAddrListContainer::ConvertNetworkAddressInfoToPDU: Error getting object key data PDU"));
		}
        break;

    default:
        /*
		 * The constructors will check to make sure a valid network address
		 * type exists so this should never be encountered.
		 */
		ERROR_OUT(("CNetAddrListContainer::ConvertNetworkAddressInfoToPDU: Error bad network address type"));
		rc = GCC_ALLOCATION_FAILURE;
	}

	return rc;
}

/*
 *	void		ConvertTransferModesToInternal (
 *						PTransferModes				source_transfer_modes,
 *						PGCCTransferModes			copy_transfer_modes)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the PDU network address transfer modes
 *		structure into the internal form where the structure is saved as a
 *		GCCTranferModes structure.
 *
 *	Formal Parameters:
 *		source_transfer_modes	(i)	Structure holding "PDU" transfer modes.
 *		copy_transfer_modes		(o) Structure to hold "API" transfer modes.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertTransferModesToInternal(PTransferModes       source_transfer_modes,
                               PGCCTransferModes    copy_transfer_modes)
{
	copy_transfer_modes->speech = (BOOL) source_transfer_modes->speech;
	copy_transfer_modes->voice_band = (BOOL) source_transfer_modes->voice_band;
	copy_transfer_modes->digital_56k = (BOOL) source_transfer_modes->digital_56k;
	copy_transfer_modes->digital_64k = (BOOL) source_transfer_modes->digital_64k;
	copy_transfer_modes->digital_128k = (BOOL) source_transfer_modes->digital_128k;
	copy_transfer_modes->digital_192k = (BOOL) source_transfer_modes->digital_192k;
	copy_transfer_modes->digital_256k = (BOOL) source_transfer_modes->digital_256k;
	copy_transfer_modes->digital_320k = (BOOL) source_transfer_modes->digital_320k;
	copy_transfer_modes->digital_384k = (BOOL) source_transfer_modes->digital_384k;
	copy_transfer_modes->digital_512k = (BOOL) source_transfer_modes->digital_512k;
	copy_transfer_modes->digital_768k = (BOOL) source_transfer_modes->digital_768k;
	copy_transfer_modes->digital_1152k = (BOOL) source_transfer_modes->digital_1152k;
	copy_transfer_modes->digital_1472k = (BOOL) source_transfer_modes->digital_1472k;
	copy_transfer_modes->digital_1536k = (BOOL) source_transfer_modes->digital_1536k;
	copy_transfer_modes->digital_1920k = (BOOL) source_transfer_modes->digital_1920k;
	copy_transfer_modes->packet_mode = (BOOL) source_transfer_modes->packet_mode;
	copy_transfer_modes->frame_mode = (BOOL) source_transfer_modes->frame_mode;
	copy_transfer_modes->atm = (BOOL) source_transfer_modes->atm;
}

/*
 *	void		ConvertHighLayerCompatibilityToInternal (
 *					PHighLayerCompatibility				source_structure,
 *					PGCCHighLayerCompatibility			copy_structure)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the PDU network address high layer
 *		compatibility structure into the internal form where the structure is 
 *		saved as a GCCHighLayerCompatibility structure.
 *
 *	Formal Parameters:
 *		source_structure		(i)	Structure holding "PDU" high layer 
 *										compatibilities.
 *		copy_structure			(o) Structure to hold "API" high layer 
 *										compatibilities.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertHighLayerCompatibilityToInternal(PHighLayerCompatibility     source_structure,
                                        PGCCHighLayerCompatibility  copy_structure)
{
	copy_structure->telephony3kHz = (BOOL) source_structure->telephony3kHz;
	copy_structure->telephony7kHz = (BOOL) source_structure->telephony7kHz;
	copy_structure->videotelephony = (BOOL) source_structure->videotelephony;
	copy_structure->videoconference = (BOOL) source_structure->videoconference;
	copy_structure->audiographic = (BOOL) source_structure->audiographic;
	copy_structure->audiovisual = (BOOL) source_structure->audiovisual;
	copy_structure->multimedia = (BOOL) source_structure->multimedia;
}

/*
 *	void		ConvertTransferModesToPDU (
 *					PGCCTransferModes					source_transfer_modes,
 *					PTransferModes						copy_transfer_modes)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the API network address transfer modes
 *		structure into the PDU form which is a TranferModes structure.
 *
 *	Formal Parameters:
 *		source_transfer_modes	(i)	Structure holding "API" transfer modes.
 *		copy_transfer_modes		(i) Structure holding "PDU" transfer modes.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertTransferModesToPDU(PGCCTransferModes     source_transfer_modes,
                          PTransferModes        copy_transfer_modes)
{
	copy_transfer_modes->speech = (ASN1bool_t) source_transfer_modes->speech;
	copy_transfer_modes->voice_band = (ASN1bool_t) source_transfer_modes->voice_band;
	copy_transfer_modes->digital_56k = (ASN1bool_t) source_transfer_modes->digital_56k;
	copy_transfer_modes->digital_64k = (ASN1bool_t) source_transfer_modes->digital_64k;
	copy_transfer_modes->digital_128k = (ASN1bool_t) source_transfer_modes->digital_128k;
	copy_transfer_modes->digital_192k = (ASN1bool_t) source_transfer_modes->digital_192k;
	copy_transfer_modes->digital_256k = (ASN1bool_t) source_transfer_modes->digital_256k;
	copy_transfer_modes->digital_320k = (ASN1bool_t) source_transfer_modes->digital_320k;
	copy_transfer_modes->digital_384k = (ASN1bool_t) source_transfer_modes->digital_384k;
	copy_transfer_modes->digital_512k = (ASN1bool_t) source_transfer_modes->digital_512k;
	copy_transfer_modes->digital_768k = (ASN1bool_t) source_transfer_modes->digital_768k;
	copy_transfer_modes->digital_1152k = (ASN1bool_t) source_transfer_modes->digital_1152k;
	copy_transfer_modes->digital_1472k = (ASN1bool_t) source_transfer_modes->digital_1472k;
	copy_transfer_modes->digital_1536k = (ASN1bool_t) source_transfer_modes->digital_1536k;
	copy_transfer_modes->digital_1920k = (ASN1bool_t) source_transfer_modes->digital_1920k;
	copy_transfer_modes->packet_mode = (ASN1bool_t) source_transfer_modes->packet_mode;
	copy_transfer_modes->frame_mode = (ASN1bool_t) source_transfer_modes->frame_mode;
	copy_transfer_modes->atm = (ASN1bool_t) source_transfer_modes->atm;
}

/*
 *	void		ConvertHighLayerCompatibilityToPDU (
 *					PGCCHighLayerCompatibility				source_structure,
 *					PHighLayerCompatibility					copy_structure)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the API network address high layer
 *		compatibility structure into the PDU form which is a 
 *		HighLayerCompatibility structure.
 *
 *	Formal Parameters:
 *		source_structure		(i)	Structure holding "API" high layer 
 *										compatibilities.
 *		copy_structure			(o) Structure to hold "PDU" high layer 
 *										compatibilities.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertHighLayerCompatibilityToPDU(PGCCHighLayerCompatibility   source_structure,
                                   PHighLayerCompatibility      copy_structure)
{
	copy_structure->telephony3kHz = (ASN1bool_t) source_structure->telephony3kHz;
	copy_structure->telephony7kHz = (ASN1bool_t) source_structure->telephony7kHz;
	copy_structure->videotelephony = (ASN1bool_t) source_structure->videotelephony;
	copy_structure->videoconference = (ASN1bool_t) source_structure->videoconference;
	copy_structure->audiographic = (ASN1bool_t) source_structure->audiographic;
	copy_structure->audiovisual = (ASN1bool_t) source_structure->audiovisual;
	copy_structure->multimedia = (ASN1bool_t) source_structure->multimedia;
}

/*
 *	BOOL    	IsDialingStringValid ( GCCDialingString		dialing_string)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to ensure that the values held within a
 *		dialing string do not violate the imposed ASN.1 constraints.  The
 *		dialing string is constrained to be digits between 0 and 9, inclusive.
 *
 *	Formal Parameters:
 *		dialing_string		(i)	Dialing string to validate. 
 *
 *	Return Value:
 *		TRUE				- The string is valid.
 *		FALSE				- The string violates the ASN.1 constraints.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CNetAddrListContainer::
IsDialingStringValid(GCCDialingString dialing_string)
{
	BOOL fRet = TRUE;
	
	while (*dialing_string != 0)
	{
		if ((*dialing_string < '0') || (*dialing_string > '9'))
		{
			fRet = FALSE;
			break;
		}
		dialing_string++;
	}

	return fRet;
}

/*
 *	BOOL    	IsCharacterStringValid (
 *								GCCCharacterString			character_string)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to ensure that the values held within a
 *		character string do not violate the imposed ASN.1 constraints.  The
 *		character string is constrained to be digits between 0 and 9, inclusive.
 *
 *	Formal Parameters:
 *		character_string		(i)	Character string to validate. 
 *
 *	Return Value:
 *		TRUE				- The string is valid.
 *		FALSE				- The string violates the ASN.1 constraints.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CNetAddrListContainer::
IsCharacterStringValid(GCCCharacterString character_string)
{
	BOOL fRet = TRUE;
	
	while (*character_string != 0)
	{
		if ((*character_string < '0') || (*character_string > '9'))
		{
			fRet = FALSE;
			break;
		}
	
		character_string++;
	}
	
	return fRet;
}

/*
 *	BOOL    	IsExtraDialingStringValid (
 *							PGCCExtraDialingString		extra_dialing_string)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to ensure that the values held within an
 *		extra dialing string do not violate the imposed ASN.1 constraints.
 *
 *	Formal Parameters:
 *		extra_dialing_string		(i)	Dialing string to validate. 
 *
 *	Return Value:
 *		TRUE				- The string is valid.
 *		FALSE				- The string violates the ASN.1 constraints.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CNetAddrListContainer::
IsExtraDialingStringValid(PGCCExtraDialingString extra_dialing_string)
{
	BOOL fRet = TRUE;

	/*
	 * Check to make sure the length of the string is within the
	 * allowable range.
	 */
	if ((extra_dialing_string->length < MINIMUM_EXTRA_DIALING_STRING_SIZE) || 
		(extra_dialing_string->length > MAXIMUM_EXTRA_DIALING_STRING_SIZE))
	{
		fRet = FALSE;
	}
    else
    {
	    /*
	     * If the length is valid, check the string values.
	     */
    	LPWSTR pwsz = extra_dialing_string->value;
		for (USHORT i = 0; i < extra_dialing_string->length; i++)
		{
			if ((*pwsz != '#') && (*pwsz != '*') && (*pwsz != ','))
			{
				if ((*pwsz < '0') || (*pwsz > '9'))
				{
					fRet = FALSE;
					break;
				}
			}
		
			pwsz++;
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\memmgr.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MEMORY);
/*
 *	memmgr.cpp
 *
 *	Copyright (c) 1998 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the implementation file for the T.120 memory allocation mechanism.  This
 *		file contains the code necessary to allocate and distribute memory
 *		in the form of Memory objects.
 *
 *	This implementation defines priorities of memory allocations.  A lower
 *	priority number implies higher priority.  Priority-0 allocations will be
 *	satisfied, unless the system is out of memory.  Priorities 1 and 2
 *	limit the amount of total memory that can be allocated, but priority 1 (recv priority)
 *	has higher water mark limits than priority 2 (send priority).
 *
 *	Protected Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Christos Tsollis
 */
static int						s_anCurrentSize[MEMORY_PRIORITIES] = { 0, 0, 0 };
static const int				sc_iLimit[MEMORY_PRIORITIES] = {
										0x7FFFFFFF,
										0x100000,
										0xE0000
								};

#ifdef DEBUG
static int						s_TotalSize = 0;
#endif // DEBUG

/*
 *	PMemory		AllocateMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to allocate a buffer together with a
 *		Memory (buffer header) object
 */
PMemory	AllocateMemory (
					PUChar				reference_ptr,
					UINT				length,
					MemoryPriority		priority)
{

	PUChar				copy_ptr;
	PMemory				memory;
						
	ASSERT (length > 0);

	if (s_anCurrentSize[priority] < sc_iLimit[priority]) {
		/*
		 *	We attempt to allocate enough space for the buffer and the
		 *	Memory object.
		 */
#ifdef DEBUG
		memory = (PMemory) new BYTE[length + sizeof (Memory)];
#else // DEBUG
		memory = (PMemory) LocalAlloc (LMEM_FIXED, length + sizeof (Memory));
#endif // DEBUG
	}
	else {
		/*
		 *	The application has attempted to allocate past its limit
		 *	It is necessary to fail the request.
		 */
		memory = NULL;
		WARNING_OUT (("AllocateMemory: attempt to allocate past the allowable limit. "
					  "Request: %d. Currently allocated: %d. Priority: %d",
					  length, s_anCurrentSize[priority], priority));
	}

	/*
	 *	Check to see whether the allocation was successful.
	 */
	if (memory != NULL) {
#ifdef DEBUG
		s_TotalSize += (int) length;
#endif // DEBUG
		/*
		 * Update the currently allocated size. Notice that we only
		 * do this for buffers used in the send/recv code path in
		 * MCS.  Since this is only one thread, we do not have to
		 * use a critical section to protect the size variable.
		 */
		ASSERT (s_anCurrentSize[priority] >= 0);
		s_anCurrentSize[priority] += (int) length;

		copy_ptr = (PUChar) memory + sizeof(Memory);
		memory->Init (reference_ptr, length, priority, copy_ptr);

		TRACE_OUT (("Allocate: successful request. "
						"Request: %d. Currently allocated: %d. Total: %d. Priority: %d",
					  	length, s_anCurrentSize[priority], s_TotalSize, priority));
		TRACE_OUT (("AllocateMemory: buffer at address %p; memory segment at address %p",
					copy_ptr, memory));
	}
	else {
		/*
		 *	We failed to allocate the requested size
		 *	It is necessary to fail the request.
		 */
		WARNING_OUT (("AllocateMemory: failed to allocated buffer.  We are out of system memory. "
					 "Request: %d. Last error: %d",
					 length, GetLastError()));
	}
	return (memory);
}

/*
 *	PUChar		ReAllocate ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to re-allocate a buffer with a Memory
 *		(buffer header) object. The buffer must have been allocated by
 *		a call to AllocateMemory.  This call assumes RECV_PRIORITY.  However,
 *		it's not restricted in allocations, because, if it did, this might
 *		cause deadlocks (some memory has already been allocated for the
 *		new arriving data).
 */
BOOL ReAllocateMemory (PMemory		*pmemory,
						UINT		length)
{

	PUChar				copy_ptr = NULL;
	UINT				new_length;
	MemoryPriority		priority;
						
	ASSERT (length > 0);
	ASSERT (pmemory != NULL);
	ASSERT (*pmemory != NULL);
	ASSERT ((*pmemory)->GetPointer());

	new_length = length + (*pmemory)->GetLength();
	priority = (*pmemory)->GetMemoryPriority();

	ASSERT (priority == RECV_PRIORITY);
	
	// We attempt to allocate enough space for the buffer.
#ifdef DEBUG
	copy_ptr = (PUChar) new BYTE[new_length + sizeof(Memory)];
	if (copy_ptr != NULL) {
		memcpy (copy_ptr, *pmemory, (*pmemory)->GetLength() + sizeof(Memory));
		delete [] (BYTE *) *pmemory;
	}
#else // DEBUG
	copy_ptr = (PUChar) LocalReAlloc ((HLOCAL) *pmemory,
										new_length + sizeof(Memory),
										LMEM_MOVEABLE);
#endif // DEBUG

	/*
	 *	Check to see whether the allocation was successful.
	 */
	if (copy_ptr != NULL) {

#ifdef DEBUG
		s_TotalSize += (int) length;
#endif // DEBUG
		/*
		 * Update the currently allocated size.
		 */
		ASSERT (s_anCurrentSize[priority] >= 0);
		s_anCurrentSize[priority] += (int) length;
		*pmemory = (PMemory) copy_ptr;
		copy_ptr += sizeof (Memory);
		(*pmemory)->Init (NULL, new_length, priority, copy_ptr);

		TRACE_OUT (("ReAllocate: successful request. "
					"Request: %d. Currently allocated: %d. Total: %d",
				  	length, s_anCurrentSize[priority], s_TotalSize));
		TRACE_OUT (("ReAllocate: buffer at address %p; memory segment at address %p",
					copy_ptr, *pmemory));
	}
	else {
		/*
		 *	We failed to allocate the requested size
		 *	It is necessary to fail the request.
		 */
		WARNING_OUT (("ReAllocate: failed to allocated buffer.  We are out of system memory. "
					 "Request: %d. Currently allocated: %d. Last error: %d",
					 length, s_anCurrentSize[priority], GetLastError()));
	}

	return (copy_ptr != NULL);
}

/*
 *	Void	FreeMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to release a previously allocated Memory object.
 */
void FreeMemory (PMemory	memory)
{
	if (memory != NULL) {

		ASSERT (SIGNATURE_MATCH(memory, MemorySignature));
		ASSERT (memory->GetPointer() == (PUChar) memory + sizeof(Memory));
		
		if (memory->Unlock() == 0) {

    	    MemoryPriority		priority = memory->GetMemoryPriority();

			TRACE_OUT (("FreeMemory: buffer at address %p (memory segment at address %p) freed. Size: %d. ",
						memory->GetPointer(), memory, memory->GetLength()));

			// We may need to adjust the variable tracking the allocated amount of mem.
			ASSERT (s_anCurrentSize[priority] >= (int) memory->GetLength());
			s_anCurrentSize[priority] -= memory->GetLength();
			ASSERT(s_anCurrentSize[priority] >= 0);
#ifdef DEBUG
			s_TotalSize -= memory->GetLength();
#endif // DEBUG
			TRACE_OUT(("FreeMemory: Currently allocated: %d. Total: %d.",
						s_anCurrentSize[priority], s_TotalSize));
			
			// free the buffer, and the memory
#ifdef DEBUG
			delete [] (BYTE *) memory;
#else // DEBUG
			LocalFree ((HLOCAL) memory);
#endif // DEBUG
		}
	}
}

#ifdef DEBUG
/*
 *	PUChar		Allocate ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to allocate a buffer without a Memory
 *		(buffer header) object.
 */
PUChar	Allocate (UINT	length)
{

	PUChar		copy_ptr;
						
	ASSERT (length > 0);

	// We attempt to allocate enough space for the buffer.
	copy_ptr = (PUChar) new BYTE[length];

	/*
	 *	Check to see whether the allocation was successful.
	 */
	if (copy_ptr == NULL) {
		/*
		 *	We failed to allocate the requested size
		 *	It is necessary to fail the request.
		 */
		ERROR_OUT (("Allocate: failed to allocated buffer.  We are out of system memory. "
					 "Request: %d. Last error: %d",
					 length, GetLastError()));
	}
		
	return (copy_ptr);
}
#endif // DEBUG

/*
 *	UINT	GetFreeMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns the amount of space that can still be
 *		allocated at the given priority level.  The function should be
 *		called only when send/recv space is allocated.
 */

UINT GetFreeMemory (MemoryPriority		priority)
{
		int		idiff;
	
	ASSERT (priority != HIGHEST_PRIORITY);

	idiff = sc_iLimit[priority] - s_anCurrentSize[priority];
	return ((idiff > 0) ? (UINT) idiff : 0);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\nmenum.h ===
#ifndef _NMENUM_H_
#define _NMENUM_H_

#include "oblist.h"
// IEnumNmX
//
template <class IEnumNmX, const IID* piidEnumNmX, class INmX, class CNmX>
class CEnumNmX : public IEnumNmX
{
private:
	INmX	**m_pList;		   // The list
	int 	  m_iCurr;		   // Current index number
	int 	  m_iMax;		   // Maximum index
	ULONG	  m_cRef;

public:
	CEnumNmX(COBLIST * pList, int cItems) :
		m_iCurr(0),
		m_iMax(0),
		m_pList(NULL),
		m_cRef(1)
	{
		if ((NULL != pList) && (0 != cItems))
		{
			m_pList = new INmX* [cItems];
			if (NULL != m_pList)
			{
				POSITION pos = pList->GetHeadPosition();
				while ((NULL != pos) && (m_iMax < cItems))
				{
					INmX *pINmX = (INmX *) (CNmX *) pList->GetNext(pos);
					ASSERT(NULL != pINmX);
					pINmX->AddRef();
					m_pList[m_iMax] = pINmX;
					m_iMax++;
				}
			}
		}
//		ApiDebugMsg(("CEnumNmX - Constructed(%08X)", this));
	}

	CEnumNmX(COBLIST * pList)
	{
		int cItems = 0;
		if (NULL != pList)
		{
			POSITION pos = pList->GetHeadPosition();
			while (NULL != pos)
			{
				pList->GetNext(pos);
				cItems++;
			}
		}
		CEnumNmX(pList, cItems);
	}


	CEnumNmX(CNmX **rgpNmX, ULONG cItems) :
		m_iCurr(0),
		m_iMax(0),
		m_pList(NULL),
		m_cRef(1)
	{
		if (NULL != rgpNmX)
		{
			m_pList = new INmX* [cItems];
			if (NULL != m_pList)
			{
				m_iMax = cItems;

				for (int i = 0; i < m_iMax; ++i)
				{
					ASSERT(NULL != rgpNmX[i]);
					rgpNmX[i]->AddRef();
					m_pList[i] = rgpNmX[i];
				}
			}
		}
//		ApiDebugMsg(("CEnumNmX - Constructed(%08X)", this));
	}

	~CEnumNmX(void)
	{
		for (int i = 0; i < m_iMax; ++i)
		{
			ASSERT(NULL != m_pList[i]);
			m_pList[i]->Release();
		}
		delete m_pList;

//		ApiDebugMsg(("CEnumNmX - Destructed (%08X)", this));
	}

	STDMETHODIMP_(ULONG) AddRef(void)
	{
		return ++m_cRef;
	}
		
	STDMETHODIMP_(ULONG) Release(void)
	{
		ASSERT(m_cRef > 0);

		if (m_cRef > 0)
		{
			m_cRef--;
		}

		ULONG cRef = m_cRef;

		if (0 == cRef)
		{
			delete this;
		}

		return cRef;
	}

	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv)
	{
		HRESULT hr = S_OK;

		if ((riid == *piidEnumNmX) || (riid == IID_IUnknown))
		{
			*ppv = (IEnumNmX *)this;
//			ApiDebugMsg(("CEnumNmX::QueryInterface(): Returning IEnumNmX."));
		}
		else
		{
			hr = E_NOINTERFACE;
			*ppv = NULL;
//			ApiDebugMsg(("CEnumNmX::QueryInterface(): Called on unknown interface."));
		}

		if (S_OK == hr)
		{
			AddRef();
		}

		return hr;
	}

	STDMETHODIMP Next(ULONG cItem, INmX **rgpNmX, ULONG *pcFetched)
	{
		ULONG cCopied = 0;

		if ((0 == cItem) && (NULL == rgpNmX) && (NULL != pcFetched))
		{
			// Return the number of remaining elements
			*pcFetched = m_iMax - m_iCurr;
			return S_OK;
		}
		
		if ((NULL == rgpNmX) || ((NULL == pcFetched) && (cItem != 1)))
			return E_POINTER;

		if (NULL != m_pList)
		{
			while ((cCopied < cItem) && (m_iCurr < m_iMax))
			{
				*rgpNmX = m_pList[m_iCurr];
				ASSERT(NULL != *rgpNmX);
				(*rgpNmX)->AddRef();
				rgpNmX++;
				cCopied++;
				m_iCurr++;
			}
		}

		if (pcFetched != NULL)
			*pcFetched = cCopied;

		return ((cItem == cCopied) ? S_OK : S_FALSE);
	}

	STDMETHODIMP Skip(ULONG cItem)
	{
		m_iCurr += cItem;
		if (m_iCurr >= m_iMax)
		{
			// Past the end of the list
			m_iCurr = m_iMax;
			return S_FALSE;
		}

		return S_OK;
	}

	STDMETHODIMP Reset()
	{
		m_iCurr = 0;
		return S_OK;
	}

	STDMETHODIMP Clone(IEnumNmX **ppEnum)
	{
		if (NULL == ppEnum)
			return E_POINTER;

		HRESULT hr = S_OK;
		CEnumNmX * pEnum = new CEnumNmX(NULL, 0);
		if (NULL == pEnum)
		{
			hr = E_OUTOFMEMORY;
		}
		else if (NULL != m_pList)
		{
			pEnum->m_pList = new INmX*[m_iMax];
			if (NULL == pEnum->m_pList)
			{
				delete pEnum;
				pEnum = NULL;
				hr = E_OUTOFMEMORY;
			}
			else
			{
				pEnum->m_iCurr = m_iCurr;
				pEnum->m_iMax = m_iMax;

				for (int i = 0; i < m_iMax; ++i)
				{
					ASSERT(NULL != m_pList[i]);
					m_pList[i]->AddRef();
					pEnum->m_pList[i] = m_pList[i];
				}
			}
		}

		*ppEnum = pEnum;
		return hr;
	}
};

#endif	// _NMENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\ogcccode.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	ogcccode.cpp
 *	
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CGCCCoder class.  This class
 *		is responsible for encoding and decoding GCC (T.124) PDU's using ASN.1 
 *		encoding rules via the ASN.1 toolkit.  This class is also capable
 *		of determining the size of both the encoded and decoded PDU's. 
 *
 *	Static Variables:
 *
 *	Caveats:
 *		Only one instance of this class should be in existance at any one time
 *		due to the static variable.
 *
 *	Author:
 *		John B. O'Nan
 */

/*
 *	External Interfaces
 */
#include <string.h>
#include "ogcccode.h"

/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
CGCCCoder	*g_GCCCoder;

/*
 *	CGCCCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the CGCCCoder class.  It initializes
 *		the ASN.1 encoder/decoder and sets the encoding rules to the
 *		Packed-Aligned variant.
 */
CGCCCoder::CGCCCoder ()
:m_pEncInfo(NULL),
 m_pDecInfo(NULL)
{
// lonchanc: We should move Init out of constructor. However,
// to minimize the changes in the GCC/MCS code, we put it here for now.
// Otherwise, we need to change MCS and Packet interfaces.
// We will move it out and call Init() separately.
	Init();
}

BOOL CGCCCoder::Init ( void )
{
	BOOL fRet = FALSE;
	GCCPDU_Module_Startup();
	if (GCCPDU_Module != NULL)
	{
		if (ASN1_CreateEncoder(
                            GCCPDU_Module,	// ptr to mdule
                            &m_pEncInfo,	// ptr to encoder info
                            NULL,			// buffer ptr
                            0,				// buffer size
                            NULL)			// parent ptr
			== ASN1_SUCCESS)
		{
			ASSERT(m_pEncInfo != NULL);
			fRet = (ASN1_CreateDecoder(
                                GCCPDU_Module,	// ptr to mdule
                                &m_pDecInfo,	// ptr to decoder info
                                NULL,			// buffer ptr
                                0,				// buffer size
                                NULL)			// parent ptr
					== ASN1_SUCCESS);
			ASSERT(fRet && m_pDecInfo != NULL);
		}
	}
	ASSERT(fRet);
	return fRet;
}

/*
 *	~CGCCCoder ()
 *
 *	Public Functional Description:
 *		This is a virtual destructor.  It is used to clean up after ASN.1.
 */
CGCCCoder::~CGCCCoder ()
{
	if (GCCPDU_Module != NULL)
	{
	    ASN1_CloseEncoder(m_pEncInfo);
	    ASN1_CloseDecoder(m_pDecInfo);
	    GCCPDU_Module_Cleanup();
	}
}

/*
 *	Encode ()
 *
 *	Public Functional Description:
 *		This function encodes GCC Protocol Data Units (PDU's) into ASN.1 
 *		compliant byte streams using the ASN.1 toolkit.
 *		The coder allocates the buffer space for the encoded data.
 */
BOOL	CGCCCoder::Encode(LPVOID		pdu_structure,
							int			pdu_type,
							UINT		nEncodingRule_not_used,
							LPBYTE		*encoding_buffer,
							UINT		*encoding_buffer_length)
{
	BOOL			fRet = FALSE;
	int				return_value;
	ConnectData		connect_data_structure;

	// clean up local buffer pointer
	connect_data_structure.connect_pdu.value = NULL;

	/*
	 * If the PDU to be encoded is a "ConnectGCC" PDU we must first encode the
	 * "ConnectGCC" PDU.  A "ConnectData" PDU structure is then built which 
	 * contains the encoded "ConnectGCC" PDU along with object identifier key.  
	 * The "ConnectData" PDU is then encoded into the provided buffer.
	 */ 
	if (pdu_type == CONNECT_GCC_PDU)
	{
		return_value = ASN1_Encode(m_pEncInfo,	// ptr to encoder info
									 pdu_structure,	// pdu data structure
									 pdu_type,		// pdu id
									 ASN1ENCODE_ALLOCATEBUFFER, // flags
									 NULL,			// do not provide buffer
									 0);			// buffer size if provided
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CGCCCoder::Encode: ASN1_Encode failed, err=%d in CONNECT_GCC_PDU.",
						return_value));
			ASSERT(FALSE);
			goto MyExit;
		}
		ASSERT(return_value == ASN1_SUCCESS);
		/*
		 * Fill in the "ConnectData" PDU structure and encode it.
		 */
		connect_data_structure.t124_identifier = t124identifier;

		connect_data_structure.connect_pdu.length = m_pEncInfo->len; // len of encoded data in buffer
		connect_data_structure.connect_pdu.value = m_pEncInfo->buf;  // buffer to encode into

		// Prepare for the encode call
		pdu_structure = (LPVOID) &connect_data_structure;
		pdu_type = CONNECT_DATA_PDU;
	}

	/* 
	 * Encode the Non-Connect PDU into the buffer provided.
	 */
	return_value = ASN1_Encode(m_pEncInfo,		// ptr to encoder info
								pdu_structure,	// pdu data structure
								pdu_type,		// pdu id
								ASN1ENCODE_ALLOCATEBUFFER, // flags
								NULL,			// do not provide buffer
								0);				// buffer size if provided
	if (ASN1_FAILED(return_value))
	{
		ERROR_OUT(("CGCCCoder::Encode: ASN1_Encode failed, err=%d", return_value));
		ASSERT(FALSE);
		goto MyExit;
	}
	ASSERT(return_value == ASN1_SUCCESS);
	*encoding_buffer_length = m_pEncInfo->len;	// len of encoded data in buffer
	*encoding_buffer = m_pEncInfo->buf;			// buffer to encode into
	fRet = TRUE;

MyExit:

	/*
	 *	If this was a CONNECT_DATA_PDU we need to free the buffer that
	 *	was allocated by ASN.1.
	 */
	if (CONNECT_DATA_PDU == pdu_type && connect_data_structure.connect_pdu.value != NULL)
	{
		ASN1_FreeEncoded(m_pEncInfo, connect_data_structure.connect_pdu.value);
	}

	return fRet;
}

/*
 *	Decode ()
 *
 *	Public Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate GCC PDU structures using the ASN.1 toolkit.
 */
BOOL	CGCCCoder::Decode(LPBYTE		encoded_buffer,
							UINT		encoded_buffer_length,
							int			pdu_type,
							UINT		nEncodingRule_not_used,
							LPVOID		*pdecoding_buffer,
							UINT		*pdecoding_buffer_length)
{
	BOOL	fRet = FALSE;
	int		return_value;
	LPVOID	connect_data_decoding_buffer = NULL;
	ASN1optionparam_s OptParam;

	/*
	 * If the PDU is a "ConnectGCC" PDU then after it is decoded we must decode
	 * the "ConnectGCC" PDU which is actually contained within a "ConnectData"
	 * PDU.
	 */
	if (pdu_type == CONNECT_GCC_PDU)
	{
		return_value = ASN1_Decode(m_pDecInfo,		// ptr to decoder info
								&connect_data_decoding_buffer,	// destination buffer
								CONNECT_DATA_PDU,				// pdu type
								ASN1DECODE_SETBUFFER,			// flags
								encoded_buffer,					// source buffer
								encoded_buffer_length);			// source buffer size
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CGCCCoder::Decode: ASN1_Decode failed, err=%d", return_value));
			ASSERT(FALSE);
			goto MyExit;
		}
		ASSERT(return_value == ASN1_SUCCESS);

		/*
		 * If the decoded PDU is a "ConnectData" PDU, then we first must check
		 * to make sure this PDU originated from a T.124-compliant source.
		 * If so we then decode the "ConnectGCC" PDU which is held in the 
		 * "connect_pdu" field.  If the PDU is not T.124-compliant, we will
		 * report an error which will cause the PDU to be rejected.
		 */
		if (IsObjectIDCompliant(&(((PConnectData) connect_data_decoding_buffer)->t124_identifier)) 
																				== FALSE)
		{
			ERROR_OUT(("CGCCCoder::Decode: Non-T.124 objectID"));
			ASSERT (FALSE);
			goto MyExit;
		}
		ASSERT(connect_data_decoding_buffer != NULL);
		encoded_buffer = (PUChar)((PConnectData) connect_data_decoding_buffer)->
							connect_pdu.value;
		encoded_buffer_length = (UINT)((PConnectData) connect_data_decoding_buffer)->
								connect_pdu.length;
	}

	/* 
	 * Decode the Non-Connect PDU into the buffer provided.
	 */
	return_value = ASN1_Decode(m_pDecInfo,	// ptr to decoder info
							pdecoding_buffer,			// destination buffer
							pdu_type,					// pdu type
							ASN1DECODE_SETBUFFER,		// flags
							encoded_buffer,				// source buffer
							encoded_buffer_length);		// source buffer size
	if (ASN1_FAILED(return_value))
	{
		ERROR_OUT(("CCCCoder::Decode: ASN1_Decode failed, err=%d", return_value));
		ASSERT(FALSE);
		goto MyExit;
	}
	ASSERT(return_value == ASN1_SUCCESS);

    OptParam.eOption = ASN1OPT_GET_DECODED_BUFFER_SIZE;
	return_value = ASN1_GetDecoderOption(m_pDecInfo, &OptParam);
	if (ASN1_FAILED(return_value))
	{
		ERROR_OUT(("CGCCCoder::Decode: ASN1_GetDecoderOption failed, err=%d", return_value));
		ASSERT(FALSE);
		goto MyExit;
	}
    *pdecoding_buffer_length = OptParam.cbRequiredDecodedBufSize;

	ASSERT(return_value == ASN1_SUCCESS);
	ASSERT(*pdecoding_buffer_length > 0);

	fRet = TRUE;

MyExit:

	/*
	 * Free the PDU structure allocated by decoder for the Connect-Data PDU.
	 */
	if (connect_data_decoding_buffer != NULL)
	{
		ASSERT (pdu_type == CONNECT_GCC_PDU);
		ASN1_FreeDecoded(m_pDecInfo, connect_data_decoding_buffer, CONNECT_DATA_PDU);
	}

	return fRet;
}

/*
 *	IsObjectIDCompliant ()
 *
 *	Private Functional Description:
 *		This function is used to verify that the object identifier contained
 * 		in a "Connect" PDU is compliant with this version of GCC.
 */
BOOL	CGCCCoder::IsObjectIDCompliant (PKey	t124_identifier)
{
	BOOL				return_value = TRUE;
	PSetOfObjectID		test_object_id_set;
	PSetOfObjectID		valid_object_id_set;

	/*
	 * First check to make sure that the identifier is a standard Object 
	 * Identifier type.
	 */
	if (t124_identifier->choice == OBJECT_CHOSEN)
	{
		/*
		 * Retrieve the object identifier to test and the valid	T.124 
		 * identifier ("t124identifier) to use as a comparison.
		 */
		test_object_id_set = t124_identifier->u.object;
		valid_object_id_set = t124identifier.u.object;

		while ((valid_object_id_set != NULL) && (test_object_id_set != NULL)) 
		{
			if (test_object_id_set->value != valid_object_id_set->value)
			{
				return_value = FALSE;
				break;
			}

			test_object_id_set = test_object_id_set->next;
			valid_object_id_set = valid_object_id_set->next;
		}
	}
	else
		return_value = FALSE;

	return (return_value);
}


void CGCCCoder::FreeEncoded (PUChar encoded_buffer)
{
    ASN1_FreeEncoded(m_pEncInfo, encoded_buffer);
}

void CGCCCoder::FreeDecoded (int pdu_type, LPVOID decoded_buffer)
{
    ASN1_FreeDecoded(m_pDecInfo, decoded_buffer, pdu_type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\packet.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC | ZONE_T120_GCCNC);
/*
 * packet.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 * Abstract:
 *		This is the implementation file for the MCS packet class.  The packet
 *		class is responsible for encoding and decoding the PDUs, as well as
 *		maintaining the necessary pointers to the encoded and decoded data.
 *		Instances of this class will be created both by User and Connection
 *		objects as PDUs flow through MCS.
 *
 * Private Instance Variables:
 *		Packet_Coder
 *			A pointer to the packet coder object.  
 *		Encoded_Lock_Count
 *			A counter indicating the number of locks currently existing on the
 *			encoded data.
 *		Decoded_Lock_Count
 *			A counter indicating the number of locks currently existing on the
 *			decoded data.
 *		Free_State
 *			A boolean value indicating whether the object can be freed when all
 *			lock counts fall to zero.
 *		m_EncodedPDU
 *			This is a pointer to the encoded PDU contained in the internal
 *			buffer.  Note that the reason for keeping this separate is that
 *			the encoded PDU may not start at the beginning of the encoded data
 *			memory block identified above.  Some encoders actually encode the
 *			PDUs backward, or back justified.
 *		Encoded_Data_Length
 *			Indicates the length of the encoded data.  If zero, the packet coder
 *			must be consulted to obtain the length which is subsequently saved.
 *		Decoded_Data_Length     
 *			Indicates the length of the decoded data.  If zero, the packet coder
 *			must be consulted to obtain the length which is subsequently saved.
 *		PDU_Type
 *			Indicates the type of PDU contained in the packet.  Valid values
 *			are DOMAIN_MCS_PDU or CONNECT_MCS_PDU.
 *		Packet_Direction_Up
 *			A boolean indicating whether the direction of travel for the PDU
 *			is upward.
 *
 * Private Member Functions:
 *		PacketSuicideCheck
 *			This function is called by Unlock() as well as any Unlock call
 *			(ie. UnlockUncoded()) when it's associated lock	count falls to
 *			zero.
 *
 * Caveats:
 *		None.
 *
 * Author:
 *		James J. Johnstone IV
 */ 

/*
 *	Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for outgoing PDUs when the packet is to be created from a structure
 *		containing the PDU data to be encoded.
 */
// outgoing packets
Packet::Packet(PPacketCoder	pPacketCoder,
				UINT			nEncodingRules,
				LPVOID			pInputPduStructure,
				int				nPduType,
				BOOL			fPacketDirectionUp,
				PPacketError	pePktErr,
				BOOL			fLockEncodedData)
:
	SimplePacket(fPacketDirectionUp),
	Packet_Coder(pPacketCoder),
	PDU_Type(nPduType),
	m_Decoded_Data (NULL),
	Decoded_Data_Length (0)
{
	/*
	 *	Encode the PDU using the externally provided decoded data. The encoded
	 *	buffer will be allocated by the encoder. The buffer needs to be freed later.
	 */
	if (Packet_Coder->Encode (pInputPduStructure, PDU_Type, nEncodingRules, 
							&m_EncodedPDU, &Encoded_Data_Length))
	{
		ASSERT (m_EncodedPDU);
		/*
		 *	Encoding was successful.
		 */
		*pePktErr = PACKET_NO_ERROR;

		// should we lock encoded data?
		if (fLockEncodedData)
			lLock = 2;
	}
	else
	{
		/*
		 *	Encoding failed.
		 */
		m_EncodedPDU = NULL;
		ERROR_OUT(("Packet::Packet: encoding failed"));
		*pePktErr = PACKET_MALLOC_FAILURE;
	}
}  

/*
 *	Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 */
// incoming packets
Packet::Packet(PPacketCoder		pPacketCoder,
				UINT			nEncodingRules,
				LPBYTE			pEncodedData,
				UINT			cbEncodedDataSize,
				int				nPduType,
				BOOL			fPacketDirectionUp,
				PPacketError	pePktErr)
:
	SimplePacket(fPacketDirectionUp),
	Packet_Coder(pPacketCoder),
	PDU_Type(nPduType)
{
		//PacketCoderError		coder_error;

	m_EncodedPDU = NULL;
	
	/*
	 *	Decode the provided encoded buffer.  Note that the decoder will
	 *	allocate the space needed.  The buffer needs to be freed later.
	 */
	if (Packet_Coder->Decode (pEncodedData, cbEncodedDataSize, PDU_Type,
								nEncodingRules, &m_Decoded_Data, 
								&Decoded_Data_Length) == FALSE)
	{
		ERROR_OUT(("Packet::Packet: Decode call failed."));
		m_Decoded_Data = NULL;
		*pePktErr = PACKET_INCOMPATIBLE_PROTOCOL;
	}
	else
	{ 
		ASSERT (m_Decoded_Data != NULL);
		/*
		 * The decode was successful.
		 */
		*pePktErr = PACKET_NO_ERROR;
	}
}                                             

/*
 *	~Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		Destructor for the Packet class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 */
Packet::~Packet(void)
{
	/*
	 *	If there is memory allocated for encoded data, then free it.
	 */
	if (m_EncodedPDU != NULL) {
		// the encoded memory was allocated by the ASN.1 coder.
		Packet_Coder->FreeEncoded (m_EncodedPDU);
	}

	/*
	 *	If there is memory allocated for decoded data, then free it.
	 */
	if (m_Decoded_Data != NULL) {
		// the decoded memory was allocated by the ASN.1 decoder
		Packet_Coder->FreeDecoded (PDU_Type, m_Decoded_Data);
	}
		
}

/*
 *	IsDataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns whether this is a data packet (it's not).
 */
BOOL Packet::IsDataPacket(void)
{
	return (FALSE);
}                        

/*
 *	GetDecodedData ()
 *
 *	Public
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  If the packet does not have decoded data the Decode method is
 *		called.  If decode is unable to provide decoded data then NULL is
 *		returned.
 */
PVoid	Packet::GetDecodedData ()
{		
	ASSERT (m_Decoded_Data != NULL);
	return (m_Decoded_Data);
}                          

/*
 *	GetPDUType ()
 *
 *	Public
 *
 *	Functional Description:
 *		The GetPDUType method returns the PDU type for the packet.
 */
int	Packet::GetPDUType ()
{		
	return (PDU_Type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\password.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/* 
 *	password.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CPassword.  This class
 *		manages the data associated with a Password.  Passwords are used to 
 *		restrict access to conferences.  A password can be one of two basic
 *		types.  The simple type consists of either a simple numeric password or
 *		a simple textual password, or both.  The "PDU" type "Password" is a
 *		structure which must contain the numeric form of the password and may
 *		optionally contain the textual part as well.  The "PDU" type
 *		"PasswordSelector" is a union of the numeric and textual forms of a
 *		password and is therefore always one or the other but not both.  When
 *		the password is not the simple type it assumes the form of a
 *		"PasswordChallengeRequestResponse".  This complex structure allows a
 *		challenge-response scheme to be used to control access to conferences.
 *
 *	Protected Instance Variables:
 *		m_fSimplePassword
 *			Flag indicating this password does not contain "challenge" data.
 *		m_fClearPassword
 *			Flag used when the password assumes the "challenge" form indicating
 *			that this password is "in the clear" meaning no true challenge
 *			data is present.
 *		m_pszNumeric
 *			String holding the numeric portion of the simple password.
 *		Text_String_Ptr
 *			String holding the textual portion of the simple password.
 *		m_pInternalRequest
 *			Structure holding the data associated with a password challenge
 *			request.
 *		m_pInternalResponse
 *			Structure holding the data associated with a password challenge
 *			response.
 *		m_pChallengeResponse
 *			Structure holding the "API" form of a challenge password.
 *		m_pPassword
 *			Structure holding the "API" form of a simple password.
 *		m_pUserDataMemory
 *			Memory container holding the user data associated with a
 *			challenge password.
 *		m_pChallengeItemListMemory
 *			Memory container holding the list of pointers to challenge items
 *			associated with a password challenge request.
 *		m_pObjectKeyMemory
 *			Memory container holding the object key data associated with the
 *			non-standard challenge response algorithm.
 *		m_ChallengeItemMemoryList 
 *			Memory container holding the data for the challenge items
 *			associated with a password challenge request.
 *		m_ChallengeResponsePDU
 *			Storage for the "PDU" form of the challenge password.
 *		m_fValidChallengeResponsePDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" password.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */

#include "password.h"
#include "userdata.h"

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor for the CPassword class is used when creating a 
 *		CPassword object with an "API" GCCPassword structure.  It saves the
 *		password data in the internal structures.
 */
CPassword::CPassword(PGCCPassword			password,
					PGCCError				return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is a "simple" password, without the 
	 * challenge request-response information.  The "clear" flag is also 
	 * initialized here but should only be needed when the password is not
	 * "simple".
	 */
	m_fSimplePassword = TRUE;
	m_fClearPassword = TRUE;

	/*
	 * Save the numeric part of the password in the internal numeric string.
	 */
	if (password->numeric_string != NULL)
	{
		if (NULL == (m_pszNumeric = ::My_strdupA(password->numeric_string)))
		{
			ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::CPassword: No valid numeric password"));
		*return_value = GCC_INVALID_PASSWORD;
	}

	/*
	 * Check to see if the textual part of the password is present.  If so,
	 * save it in the internal UnicodeString.  If not, set the text pointer
	 * to NULL.
	 */
	if ((password->text_string != NULL) && (*return_value == GCC_NO_ERROR))
	{
		if (NULL == (m_pwszText = ::My_strdupW(password->text_string)))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating text string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pwszText = NULL;
}

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor is used when a CPassword object is being created
 *		with a "ChallengeRequestResponse" "API" structure.  The password data 
 *		is saved in the internal structures.
 */
CPassword::CPassword(PGCCChallengeRequestResponse		challenge_response_data,
					PGCCError							return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is not a "simple" password, meaning 
	 * that it contains challenge request-response information.  If the password
	 * is "clear" there is no need to create the internal "Challenge" structure
	 * used to hold the challenge request-response information.
	 */
	m_fSimplePassword = FALSE;
	
	/*
	 * Check to see if a "clear" challenge password exists or if this is a 
	 * true challenge request-response password.
	 */
	if (challenge_response_data->password_challenge_type == 
													GCC_PASSWORD_IN_THE_CLEAR)
	{
		/*
		 * A "clear" password is being sent so set the flag indicating so.  
		 * Also set the password type and save the numeric part of the password,
		 * if it exists.  Note that since the "clear" password contained in the
		 * challenge is a PasswordSelector type, either the numeric or the text
		 * form of the password should exist, but not both.
		 */
		m_fClearPassword = TRUE;

		if (challenge_response_data->u.password_in_the_clear.
				numeric_string != NULL)
		{
			if (NULL == (m_pszNumeric = ::My_strdupA(
							challenge_response_data->u.password_in_the_clear.numeric_string)))
			{
				ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pszNumeric = NULL;
		}

		/*
		 * Check to see if the textual part of the password is present.  If it
		 * is, save it in the internal UnicodeString.
		 */
		if ((challenge_response_data->u.password_in_the_clear.
				text_string != NULL) && (*return_value == GCC_NO_ERROR))
		{
			if (NULL == (m_pwszText = ::My_strdupW(
							challenge_response_data->u.password_in_the_clear.text_string)))
			{
				ERROR_OUT(("CPassword::CPassword: Error creating text string"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pwszText = NULL;
		}

		/*
		 * Check to make sure at least one form (text or numeric) of the 
		 * "clear" password was saved.  Report an error if neither was created.
		 */
		if ((*return_value == GCC_NO_ERROR) && (m_pszNumeric == NULL) 
				&& (m_pwszText == NULL))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password"));
			*return_value = GCC_INVALID_PASSWORD;
		}
	}
	else
	{
		/*
		 * This is a true challenge request-response password.  Set the flag
		 * indicating that the password is not "clear" and create the 
		 * "challenge" data structures to hold the password data internally.
		 */
		m_fClearPassword = FALSE;

		/*
		 * Check to see if a challenge request is present.
		 */
		if (challenge_response_data->u.challenge_request_response.
				challenge_request != NULL)
		{
			/*
			 * Create a RequestInfo stucture to hold the request data
			 * and copy the challenge request structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalRequest = new RequestInfo;
			if (m_pInternalRequest != NULL)
			{
				*return_value = ConvertAPIChallengeRequest (
						challenge_response_data->u.
						challenge_request_response.challenge_request);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new RequestInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}

		/*
		 * Check to see if a challenge response is present.
		 */
		if ((challenge_response_data->u.challenge_request_response.
				challenge_response != NULL) && 
				(*return_value == GCC_NO_ERROR))
		{
			/*
			 * Create a ResponseInfo stucture to hold the response data
			 * and copy the challenge response structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalResponse = new ResponseInfo;
			if (m_pInternalResponse != NULL)
			{
				*return_value = ConvertAPIChallengeResponse (
						challenge_response_data->u.
						challenge_request_response.challenge_response);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new ResponseInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
	} 
}

/*
 *	CPassword()
 *
 *	Public Function Description
 *		This constructor for the CPassword class is used when creating a 
 *		CPassword object with a "PDU" Password structure.  It saves the
 *		password data in the internal structures.
 */
CPassword::CPassword(PPassword				password_pdu,
					PGCCError				return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is a "simple" password, without the 
	 * challenge request-response information.  The "clear" flag is also 
	 * initialized here but should only be needed when the password is not
	 * "simple".
	 */
	m_fSimplePassword = TRUE;
	m_fClearPassword = TRUE;
	
	/*
	 * Save the numeric part of the password. The numeric portion of the
	 * password is required to be present so report an error if it is not.
	 */
	if (password_pdu->numeric != NULL)
	{
		if (NULL == (m_pszNumeric = ::My_strdupA(password_pdu->numeric)))
		{
			ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::CPassword: Error no valid numeric password in PDU"));
		*return_value = GCC_INVALID_PASSWORD;
		m_pszNumeric = NULL;
	}

	/*
	 * Check to see if the textual part of the password is present.
	 */
	if ((password_pdu->bit_mask & PASSWORD_TEXT_PRESENT) &&
			(*return_value == GCC_NO_ERROR))
	{
		if (NULL == (m_pwszText = ::My_strdupW2(
							password_pdu->password_text.length,
							password_pdu->password_text.value)))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password text"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pwszText = NULL;
}

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor for the CPassword class is used when creating a 
 *		CPassword object with a "PDU" PasswordSelector structure.  It saves
 *		the password data in it's internal structures but does not require
 *		saving any "challenge request-response" data.
 */
CPassword::CPassword(PPasswordSelector			password_selector_pdu,
					PGCCError					return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is a "simple" password, without the 
	 * challenge request-response information.
	 */
	m_fSimplePassword = TRUE;
	m_fClearPassword = TRUE;
	
	/*
	 * The password selector contains either the numeric password or the 
	 * textual password but not both.  Check to see if the textual password 
	 * is chosen.
	 */
	if (password_selector_pdu->choice == PASSWORD_SELECTOR_TEXT_CHOSEN)
	{
		if (NULL == (m_pwszText = ::My_strdupW2(
							password_selector_pdu->u.password_selector_text.length,
							password_selector_pdu->u.password_selector_text.value)))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password selector text"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pwszText = NULL;

	/*
	 * Check to see if the numeric password is chosen.
	 */
	if (password_selector_pdu->choice == PASSWORD_SELECTOR_NUMERIC_CHOSEN)
	{
		if (NULL == (m_pszNumeric = ::My_strdupA(
							password_selector_pdu->u.password_selector_numeric)))
		{
			ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pszNumeric = NULL;

	/*
	 * Check to make sure at least one form (text or numeric) of the 
	 * password was saved.  Report an error if neither was created.
	 */
	if ((*return_value == GCC_NO_ERROR) && (m_pszNumeric == NULL) 
			&& (m_pwszText == NULL))
	{
		ERROR_OUT(("CPassword::CPassword: Error creating password selector"));
		*return_value = GCC_INVALID_PASSWORD;
	}
}

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor for the CPassword class is used when creating a
 *		CPassword object with a "PDU" Challenge Request-Response structure.
 *		The password data is saved in the internal structures.
 */
CPassword::CPassword(PPasswordChallengeRequestResponse	pdu_challenge_data,
					PGCCError							return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is not "simple" password, meaning that 
	 * it contains challenge request-response information.  If the password is
	 * "clear" there is no need to create the internal "Challenge" structure
	 * used to hold the challenge request-response information.
	 */
	m_fSimplePassword = FALSE;
	
	/*
	 * Check to see if a "clear" challenge password exists or if this is a 
	 * true challenge request-response password.
	 */
	if (pdu_challenge_data->choice == CHALLENGE_CLEAR_PASSWORD_CHOSEN)
	{
		/*
		 * A "clear" password is being sent so set the flag indicating so.  
		 * Also set the password type and save the numeric part of the password,
		 * if it is present.
		 */
		m_fClearPassword = TRUE;

		if (pdu_challenge_data->u.challenge_clear_password.choice ==
											PASSWORD_SELECTOR_NUMERIC_CHOSEN)
		{
			if (NULL == (m_pszNumeric = ::My_strdupA(
							pdu_challenge_data->u.challenge_clear_password.u.password_selector_numeric)))
			{
				ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pszNumeric = NULL;
		}

		/*
		 * Check to see if the textual part of the password is present.  If it
		 * is, save it in the internal structure.
		 */
		if (pdu_challenge_data->u.challenge_clear_password.choice ==
											PASSWORD_SELECTOR_TEXT_CHOSEN)
		{
			if (NULL == (m_pwszText = ::My_strdupW2(
								pdu_challenge_data->u.challenge_clear_password.
										u.password_selector_text.length,
								pdu_challenge_data->u.challenge_clear_password.
										u.password_selector_text.value)))
			{
				ERROR_OUT(("CPassword::CPassword: Error creating password selector text"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pwszText = NULL;
		}

		/*
		 * Check to make sure at least one form (text or numeric) of the 
		 * "clear" password was saved.  Report an error if neither was created.
		 */
		if ((*return_value == GCC_NO_ERROR) && (m_pszNumeric == NULL) 
				&& (m_pwszText == NULL))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password"));
			*return_value = GCC_INVALID_PASSWORD;
		}
	}
	else
	{
		/*
		 * This is a true challenge request-response password.  Set the flag
		 * indicating that the password is not "clear" and create a 
		 * "challenge data" structure to hold the password data internally.
		 */
		m_fClearPassword = FALSE;

		/*
		 * Check to see if a challenge request is present.
		 */
		if (pdu_challenge_data->u.challenge_request_response.
				bit_mask & CHALLENGE_REQUEST_PRESENT)
		{
			/*
			 * Create a RequestInfo stucture to hold the request data
			 * and copy the challenge request structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalRequest = new RequestInfo;
			if (m_pInternalRequest != NULL)
			{
				*return_value = ConvertPDUChallengeRequest (
						&pdu_challenge_data->u.challenge_request_response.
						challenge_request);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new RequestInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}

		/*
		 * Check to see if a challenge response is present.
		 */
		if ((pdu_challenge_data->u.challenge_request_response.
				bit_mask & CHALLENGE_RESPONSE_PRESENT) &&
				(*return_value == GCC_NO_ERROR))
		{
			/*
			 * Create a ResponseInfo stucture to hold the response data
			 * and copy the challenge response structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalResponse = new ResponseInfo;
			if (m_pInternalResponse != NULL)
			{
				*return_value = ConvertPDUChallengeResponse (
						&pdu_challenge_data->u.challenge_request_response.
						challenge_response);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new ResponseInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		} 
	}
}

/*
 *	~CPassword()
 *
 *	Public Function Description:
 *		This is the destructor for the CPassword class.  It will free up
 *		any memory allocated during the life of this object.
 */
CPassword::~CPassword(void)
{
	PChallengeItemInfo			challenge_item_info_ptr;

	delete m_pszNumeric;
	delete m_pwszText;

	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidChallengeResponsePDU)
	{
		FreePasswordChallengeResponsePDU();
	}

	/*
	 * Delete the memory associated with the "API" "simple" password 
	 * data structure.
	 */
	delete m_pPassword;

	/*
	 * Free any data allocated for the "API" challenge password.  This would be
	 * left around if "UnLock" was not called.  Note that if the "challenge" 
	 * password is "clear", the numeric and text pointers above would contain
	 *  the "API" data so now we just need to delete the "challenge" password 
	 * structure.
	 */
	if (m_pChallengeResponse != NULL)
	{
		if (m_fClearPassword == FALSE)
		{
			FreeAPIPasswordData();
		}
		else
		{
			delete m_pChallengeResponse;
		}
	}

	/*
	 * Free any internal memory allocated for the challenge request information.
	 * Iterate through the list of challenge items associated with the 
	 * challenge request, if it exists.
	 */
	if (m_pInternalRequest != NULL)
	{
		m_pInternalRequest->ChallengeItemList.Reset();
		while (NULL != (challenge_item_info_ptr = m_pInternalRequest->ChallengeItemList.Iterate()))
		{
			/*
			 * Delete any memory being referenced in the ChallengeItemInfo 
			 * structure.
			 */
			if (NULL != challenge_item_info_ptr->algorithm.object_key)
			{
			    challenge_item_info_ptr->algorithm.object_key->Release();
			}
			delete challenge_item_info_ptr->algorithm.poszOctetString;
			if (NULL!= challenge_item_info_ptr->challenge_data_list)
			{
			    challenge_item_info_ptr->challenge_data_list->Release();
			}

			/*
			 * Delete the challenge item contained in the list.
			 */
			delete challenge_item_info_ptr;
		}
		
		/*
		 * Delete the request structure.
		 */
		delete m_pInternalRequest;
	}

	/*
	 * Delete any memory allocated for the challenge response information.
	 */
	if (m_pInternalResponse != NULL)
	{
		if (NULL != m_pInternalResponse->algorithm.object_key)
		{
		    m_pInternalResponse->algorithm.object_key->Release();
		}
		delete m_pInternalResponse->algorithm.poszOctetString;
		if (NULL != m_pInternalResponse->challenge_response_item.password)
		{
		    m_pInternalResponse->challenge_response_item.password->Release();
		}
		if (NULL != m_pInternalResponse->challenge_response_item.response_data_list)
		{
		    m_pInternalResponse->challenge_response_item.response_data_list->Release();
		}
		delete m_pInternalResponse;
	}
}


/*
 *	LockPasswordData ()
 *
 *	Public Function Description:
 *		This routine is called to "Lock" the password data.  The first time this
 *		routine is called, the lock count will be zero and this will result
 *		in the password data being copied from the internal structures into an 
 *		"API" structure of the proper form.  Subsequent calls to this routine 
 *		will result in the lock count being incremented. 
 */
GCCError CPassword::LockPasswordData(void)
{
	GCCError rc;

	if (Lock() == 1)
	{
	    rc = GCC_ALLOCATION_FAILURE;
		/*
		 * Check to see whether or not the password contains "challenge"
		 * information.  Fill in the appropriate internal structure.
		 */
		if (m_fSimplePassword)
		{
			if (m_pszNumeric == NULL)
			{
				ERROR_OUT(("CPassword::LockPasswordData: No valid numeric password data exists"));
				goto MyExit;
			}

			DBG_SAVE_FILE_LINE
			if (NULL == (m_pPassword = new GCCPassword))
			{
				ERROR_OUT(("CPassword::LockPasswordData: can't create GCCPassword"));
				goto MyExit;
			}

    		/*
    		 * Fill in the numeric password string which must exist.
    		 */
			m_pPassword->numeric_string = (GCCNumericString) m_pszNumeric;

			/*
			 * Fill in the textual password string.
			 */
			m_pPassword->text_string = m_pwszText;
		}
		else
		{
			/*
			 * The password contains challenge information so create the 
			 * structure to pass back the necessary information.
			 */
			DBG_SAVE_FILE_LINE
			m_pChallengeResponse = new GCCChallengeRequestResponse;
			if (m_pChallengeResponse == NULL)
			{
				ERROR_OUT(("CPassword::LockPasswordData: can't create GCCChallengeRequestResponse"));
				goto MyExit;
			}
			::ZeroMemory(m_pChallengeResponse, sizeof(GCCChallengeRequestResponse));

			/*
			 * Fill in the "API" password challenge structure after 
			 * determining what type exists.
			 */
			if (m_fClearPassword)
			{
				/*
				 * This password contains no "challenge" information.
				 */
				m_pChallengeResponse->password_challenge_type = GCC_PASSWORD_IN_THE_CLEAR;

				/*
				 * This "clear" part of the	password is a "selector" which 
				 * means the form is either	numeric or text.  The check to
				 * verify that at least one form exists was done on
				 * construction.
				 */
				m_pChallengeResponse->u.password_in_the_clear.numeric_string = m_pszNumeric;
				m_pChallengeResponse->u.password_in_the_clear.text_string = m_pwszText;
			}
			else
			{
				/*
				 * This password contains real "challenge" information.
				 */
				m_pChallengeResponse->password_challenge_type = GCC_PASSWORD_CHALLENGE;

				/*
				 * Check to see if a challenge request exists.  If so,
				 * create a GCCChallengeRequest to hold the "API" data and 
				 * fill in that structure.
				 */
				if (m_pInternalRequest != NULL)
				{
					DBG_SAVE_FILE_LINE
					m_pChallengeResponse->u.challenge_request_response.
							challenge_request = new GCCChallengeRequest;
					if (m_pChallengeResponse->u.challenge_request_response.
							challenge_request == NULL)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't create GCCChallengeRequest"));
						goto MyExit;
					}

					if (GetGCCChallengeRequest(m_pChallengeResponse->u.
							challenge_request_response.challenge_request) != GCC_NO_ERROR)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't gett GCCChallengeRequest"));
						goto MyExit;
					}
				}
				else
				{
					m_pChallengeResponse->u.challenge_request_response.challenge_request = NULL;
				}

				/*
				 * Check to see if a challenge response exists.  If so,
				 * create a GCCChallengeResponse to hold the "API" data and 
				 * fill in that structure.
				 */
				if (m_pInternalResponse != NULL)
				{
					DBG_SAVE_FILE_LINE
					m_pChallengeResponse->u.challenge_request_response.
							challenge_response = new GCCChallengeResponse;
					if (m_pChallengeResponse->u.challenge_request_response.
							challenge_response == NULL)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't create new GCCChallengeResponse"));
						goto MyExit;
					}

					if (GetGCCChallengeResponse(m_pChallengeResponse->u.
					        challenge_request_response.challenge_response) != GCC_NO_ERROR)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't get GCCChallengeResponse"));
						goto MyExit;
					}
				}
				else
				{
					m_pChallengeResponse->u.challenge_request_response.
							challenge_response = NULL;
				}
			}
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (! m_fSimplePassword)
        {
            if (NULL != m_pChallengeResponse)
            {
                delete m_pChallengeResponse->u.challenge_request_response.challenge_request;
                delete m_pChallengeResponse->u.challenge_request_response.challenge_response;
                delete m_pChallengeResponse;
                m_pChallengeResponse = NULL;
            }
        }
    }

	return rc;
}


/*
 *	GetPasswordData ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the form of 
 *		the "API" structure "GCCPassword".  No "challenge" information is
 *		returned.
 */
GCCError CPassword::GetPasswordData(PGCCPassword *gcc_password)
{
	GCCError	return_value = GCC_NO_ERROR;
	
	/*
	 * If the pointer to the "API" password data is valid, set the output
	 * parameter to return a pointer to the "API" password data.  Otherwise, 
	 * report that the password data has yet to be locked into the "API" form.
	 */ 
	if (m_pPassword != NULL)
	{
		*gcc_password = m_pPassword;
	}
	else
	{
    	*gcc_password = NULL;
		return_value = GCC_ALLOCATION_FAILURE;
		ERROR_OUT(("CPassword::GetPasswordData: Error Data Not Locked"));
	}
	
	return (return_value);
}

/*
 *	GetPasswordChallengeData ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the form of 
 *		the "API" structure "GCCChallengeRequestResponse".
 */
GCCError CPassword::GetPasswordChallengeData(PGCCChallengeRequestResponse *gcc_challenge_password)
{
	GCCError	return_value = GCC_NO_ERROR;

	/*
	 * If the pointer to the "API" password challenge data is valid, set the
	 * output parameter to return a pointer to the "API" password challenge
	 * data.  Otherwise, report that the password data has yet to be locked 
	 * into the "API" form.
	 */ 
	if (m_pChallengeResponse != NULL)
	{
		*gcc_challenge_password = m_pChallengeResponse;
	}
	else
	{
    	*gcc_challenge_password = NULL;
		return_value = GCC_ALLOCATION_FAILURE;
		ERROR_OUT(("CPassword::GetPasswordData: Error Data Not Locked"));
	}
	
	return (return_value);
}

/*
 *	UnLockPasswordData ()
 *
 *	Public Function Description
 *		This routine decrements the lock count and frees the memory associated 
 *		with "API" password data when the lock count reaches zero.
 */
void CPassword::UnLockPasswordData(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Delete the memory associated with the "API" "simple" password 
		 * data structure.
		 */
		delete m_pPassword;
		m_pPassword = NULL;

		/*
		 * Delete the memory associated with the "API" "challenge" password 
		 * data structure.
		 */
		if (m_pChallengeResponse != NULL)
		{
			if (m_fClearPassword == FALSE)
			{
				FreeAPIPasswordData();
			}
			else
			{
				delete m_pChallengeResponse;
				m_pChallengeResponse = NULL;
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetPasswordPDU ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the "PDU" form
 *		of a "Password" structure.
 */
GCCError CPassword::GetPasswordPDU(PPassword pdu_password)
{
	GCCError			return_value = GCC_NO_ERROR;
	
	pdu_password->bit_mask = 0;

	/*
	 * Fill in the numeric portion of the password which must always exist.
	 */	
	if (m_pszNumeric != NULL)
	{
		::lstrcpyA(pdu_password->numeric, m_pszNumeric);
	}
	else
		return_value = GCC_ALLOCATION_FAILURE;
	
	/*
	 * Fill in the optional textual portion of the password if it is present.
	 * Set the bitmask in the PDU structure to indicate that the text exists.
	 */		
	if (m_pwszText != NULL)
	{
		pdu_password->bit_mask |= PASSWORD_TEXT_PRESENT;
		
		pdu_password->password_text.value = m_pwszText; 
		pdu_password->password_text.length= ::lstrlenW(m_pwszText);
	}
	
	return (return_value);
}

/*
 *	GetPasswordSelectorPDU ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the "PDU" form
 *		of a "PasswordSelector" structure.  In a "PasswordSelector" either the
 *		numeric or the text version of the password exists, but not both.
 */
GCCError CPassword::GetPasswordSelectorPDU(PPasswordSelector password_selector_pdu)
{
	GCCError		return_value = GCC_NO_ERROR;
	
	/*
	 * Fill in the version of the password which exists and set
	 * the "choice" to indicate what type of password this is.
	 */
	if (m_pszNumeric != NULL)
	{
		password_selector_pdu->choice = PASSWORD_SELECTOR_NUMERIC_CHOSEN;
		
		::lstrcpyA(password_selector_pdu->u.password_selector_numeric, m_pszNumeric);
	}
	else if (m_pwszText != NULL)
	{
		password_selector_pdu->choice = PASSWORD_SELECTOR_TEXT_CHOSEN;
		password_selector_pdu->u.password_selector_text.value = m_pwszText; 
		password_selector_pdu->u.password_selector_text.length = ::lstrlenW(m_pwszText);
	}
	else
	{
		ERROR_OUT(("CPassword::GetPasswordSelectorPDU: No valid data"));
		return_value = GCC_INVALID_PASSWORD;
	}
	
   return (return_value);
}

/*
 *	GetPasswordChallengeResponsePDU	()
 *
 *	Public Function Description:
 *		This routine fills in a password challenge request-response "PDU"
 *		structure with the password data.
 */
GCCError CPassword::GetPasswordChallengeResponsePDU(PPasswordChallengeRequestResponse challenge_pdu)
{
	GCCError			return_value = GCC_NO_ERROR;
	
	/*
	 * Check to see if this is a "simple" password.  If it is, then this routine
	 * has been called in error.
	 */
	if ((challenge_pdu == NULL) || m_fSimplePassword)
	{
		ERROR_OUT(("CPassword::GetPasswordChallengeResponsePDU: no challenge data"));
		return (GCC_INVALID_PARAMETER);
	}

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidChallengeResponsePDU == FALSE)
	{
		m_fValidChallengeResponsePDU = TRUE;

		/*
		 * Fill in the password challenge PDU structure.
		 */
		if (m_fClearPassword)
		{
			/*
			 * If this is a clear password then fill in the text or
			 * numeric string as well as the choice.  Only one form of the
			 * password exists for PasswordSelectors such as this.
			 */
			m_ChallengeResponsePDU.choice = CHALLENGE_CLEAR_PASSWORD_CHOSEN;

			if (m_pszNumeric != NULL)
			{
				m_ChallengeResponsePDU.u.challenge_clear_password.choice =
											PASSWORD_SELECTOR_NUMERIC_CHOSEN;
				
				::lstrcpyA(m_ChallengeResponsePDU.u.challenge_clear_password.u.password_selector_numeric,
						m_pszNumeric);
			}
			else if (m_pwszText != NULL)
			{
				m_ChallengeResponsePDU.u.challenge_clear_password.choice =
												PASSWORD_SELECTOR_TEXT_CHOSEN;

				m_ChallengeResponsePDU.u.challenge_clear_password.u.
						password_selector_text.value = m_pwszText;
 
				m_ChallengeResponsePDU.u.challenge_clear_password.u.
						password_selector_text.length = ::lstrlenW(m_pwszText);
			}
			else
			{
				ERROR_OUT(("CPassword::GetPwordChallengeResPDU: No valid data"));
				return_value = GCC_INVALID_PASSWORD;
			}
		}
		else
		{
			/*
			 * The challenge password contains challenge information.  Fill in
			 * the request and response structures if they exist.
			 */
			m_ChallengeResponsePDU.choice = CHALLENGE_REQUEST_RESPONSE_CHOSEN; 
			m_ChallengeResponsePDU.u.challenge_request_response.bit_mask = 0;

			/*
			 * Check to see if a "request" exists.
			 */
			if (m_pInternalRequest != NULL)
			{
				m_ChallengeResponsePDU.u.challenge_request_response.bit_mask |=
												CHALLENGE_REQUEST_PRESENT;

				/*
				 * Call the routine which fills in the PDU form of the
				 * request structure.
				 */
				return_value = GetChallengeRequestPDU (&m_ChallengeResponsePDU.
						u.challenge_request_response.challenge_request);
			}

			/*
			 * Check to see if a "response" exists.
			 */
			if ((m_pInternalResponse != NULL) && (return_value == GCC_NO_ERROR))
			{
				m_ChallengeResponsePDU.u.challenge_request_response.bit_mask |=
												CHALLENGE_RESPONSE_PRESENT;

				/*
				 * Call the routine which fills in the PDU form of the
				 * response structure.
				 */
				return_value = GetChallengeResponsePDU (&m_ChallengeResponsePDU.
						u.challenge_request_response.challenge_response);
			}
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*challenge_pdu = m_ChallengeResponsePDU;
		
	return (return_value);
}
									

/*
 *	FreePasswordChallengeResponsePDU ()
 *
 *	Public Function Description:
 *		This routine is used to free any memory allocated to hold "PDU" data
 * 		associated with the PasswordChallengeRequestResponse.
 */
void CPassword::FreePasswordChallengeResponsePDU(void)
{
	/*
	 * Check to see if there has been any "PDU" memory allocated which now
	 * needs to be freed.
	 */
	if (m_fValidChallengeResponsePDU)
	{
		/*
		 * Set the flag indicating that PDU password data is no longer
		 * allocated.
		 */
		m_fValidChallengeResponsePDU = FALSE;

		/*
		 * Check to see what type of password PDU is to be freed.  If this is a
		 * clear password then no data was allocated which now must be freed.
		 */
		if (m_ChallengeResponsePDU.choice == CHALLENGE_REQUEST_RESPONSE_CHOSEN)
		{
			/*
			 * This is a challenge password so free any data which was allocated
			 * to hold the challenge information.  Check the PDU structure 
			 * bitmask which indicates what form of challenge exists.
			 */
			if (m_ChallengeResponsePDU.u.challenge_request_response.bit_mask & 
													CHALLENGE_REQUEST_PRESENT)
			{
				FreeChallengeRequestPDU ();
			}
			
			if (m_ChallengeResponsePDU.u.challenge_request_response.
					bit_mask & CHALLENGE_RESPONSE_PRESENT)
			{
				FreeChallengeResponsePDU ();
			}
		}
	}
}
									

/*
 *	GCCError	ConvertAPIChallengeRequest(
 *							PGCCChallengeRequest		challenge_request)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy an "API" challenge request structure into
 *		the internal structure.
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertAPIChallengeRequest(PGCCChallengeRequest challenge_request)
{
	GCCError				return_value = GCC_NO_ERROR;
	GCCError				error_value;
	Int						i;
	PGCCChallengeItem		challenge_item_ptr;
	PChallengeItemInfo		challenge_item_info_ptr;

	/*
	 * Save the challenge tag and number of challenge items in the internal
	 * structure.
	 */
	m_pInternalRequest->challenge_tag = challenge_request->challenge_tag;

	/*
	 * Save the list of challenge items in the internal Rogue Wave List.
	 */
	for (i = 0; i < challenge_request->number_of_challenge_items; i++)
	{
		DBG_SAVE_FILE_LINE
		challenge_item_info_ptr = new ChallengeItemInfo;
		if (challenge_item_info_ptr != NULL)
		{
			/*
			 * Initialize the pointers in the challenge item info structure
			 * to NULL.
			 */
			challenge_item_info_ptr->algorithm.object_key = NULL;
			challenge_item_info_ptr->algorithm.poszOctetString = NULL;
			challenge_item_info_ptr->challenge_data_list = NULL;

			/*
			 * Insert the pointer to the new challenge item structure into the 
			 * internal list.
			 */
			m_pInternalRequest->ChallengeItemList.Append(challenge_item_info_ptr);

			/*
			 * Retrieve the pointer to the challenge item from the input list.
			 */
			challenge_item_ptr = challenge_request->challenge_item_list[i];

			/*
			 * Copy the challenge response algorithm to the internal structure.
			 */
			return_value = CopyResponseAlgorithm (
					&(challenge_item_ptr->response_algorithm),
					&(challenge_item_info_ptr->algorithm));

			if (return_value != GCC_NO_ERROR)
			{
				ERROR_OUT(("Password::ConvertAPIChallengeRequest: Error copying Response Algorithm."));
				break;
			}

			/*
			 * Copy the challenge data.
			 */
			if ((challenge_item_ptr->number_of_challenge_data_members != 0) && 
					(challenge_item_ptr->challenge_data_list != NULL))
			{
				DBG_SAVE_FILE_LINE
				challenge_item_info_ptr->challenge_data_list = new CUserDataListContainer(
						challenge_item_ptr->number_of_challenge_data_members,
						challenge_item_ptr->challenge_data_list,
						&error_value);
				if ((challenge_item_info_ptr == NULL) || 
						(error_value != GCC_NO_ERROR))
				{
					ERROR_OUT(("Password::ConvertAPIChallengeRequest: can't create CUserDataListContainer."));
					return_value = GCC_ALLOCATION_FAILURE;
					break;
				}
			}
			else
			{
				challenge_item_info_ptr->challenge_data_list = NULL;
				ERROR_OUT(("Password::ConvertAPIChallengeRequest: Error no valid user data."));
				return_value = GCC_INVALID_PASSWORD;
				break;
			}
		}
		else
		{
			ERROR_OUT(("Password::ConvertAPIChallengeRequest: Error creating "
					"new ChallengeItemInfo."));
			return_value = GCC_ALLOCATION_FAILURE;
			break;
		}
	}
	
	return (return_value);
}

/*
 *	GCCError	ConvertAPIChallengeResponse(
 *							PGCCChallengeResponse		challenge_response)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy an "API" challenge response structure into
 *		the internal structure.
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertAPIChallengeResponse(PGCCChallengeResponse challenge_response)
{
	GCCError			return_value = GCC_NO_ERROR;
	GCCError			error_value;
			
	/*
	 * Initialize the challenge response info structure pointers to NULL.
	 */
	m_pInternalResponse->challenge_response_item.password = NULL;
	m_pInternalResponse->challenge_response_item.response_data_list = NULL;

	/*
	 * Save the challenge tag in the internal structure.
	 */
	m_pInternalResponse->challenge_tag = challenge_response->challenge_tag;

	/*
	 * Copy the challenge response algorithm to the internal structure.
	 */
	return_value = CopyResponseAlgorithm (
			&(challenge_response->response_algorithm),
			&(m_pInternalResponse->algorithm));
	if (return_value != GCC_NO_ERROR)
	{
		ERROR_OUT(("Password::ConvertAPIChallengeResponse: Error copying Response Algorithm."));
	}

	/*
	 * Copy the challenge response item into the internal info structure.
	 * The challenge response item will consist of either a password string
	 * or else a response user data list.
	 */
	if (return_value == GCC_NO_ERROR)
	{
		if (challenge_response->response_algorithm.password_algorithm_type ==
												GCC_IN_THE_CLEAR_ALGORITHM)
		{
			if (challenge_response->response_item.password_string != NULL)
			{
				DBG_SAVE_FILE_LINE
				m_pInternalResponse->challenge_response_item.password = new 
						CPassword(challenge_response->response_item.password_string, &error_value);
				if ((m_pInternalResponse->challenge_response_item.password == 
						NULL)||	(error_value != GCC_NO_ERROR))
				{
					ERROR_OUT(("Password::ConvertAPIChallengeResp: Error creating new CPassword."));
					return_value = GCC_ALLOCATION_FAILURE;
				}
			}
			else
				return_value = GCC_INVALID_PASSWORD;
		}
		else
		{
			if ((challenge_response->response_item.
				number_of_response_data_members != 0) && 
				(challenge_response->response_item.response_data_list != NULL))
			{
				/* 
				 * Save the response data list in a CUserDataListContainer object.
				 */
				DBG_SAVE_FILE_LINE
				m_pInternalResponse->challenge_response_item.response_data_list = 
					new CUserDataListContainer(challenge_response->response_item.number_of_response_data_members,
						        challenge_response->response_item.response_data_list,
						        &error_value);
				if ((m_pInternalResponse->challenge_response_item.response_data_list == NULL) || 
					(error_value != GCC_NO_ERROR))
				{
					ERROR_OUT(("Password::ConvertAPIChallengeResponse: can't create CUserDataListContainer."));
					return_value = GCC_ALLOCATION_FAILURE;
				}
			}
			else
				return_value = GCC_INVALID_PASSWORD;
		}
	}

	/*
	 * Check to make sure one type of response item was saved.
	 */
	if ((return_value == GCC_NO_ERROR) && 
			(m_pInternalResponse->challenge_response_item.password == NULL) && 
			(m_pInternalResponse->challenge_response_item.response_data_list == 
			NULL))
	{
		ERROR_OUT(("Password::ConvertAPIChallengeResponse: Error no valid response item saved."));
		return_value = GCC_ALLOCATION_FAILURE;
	}

	return (return_value);
}

/*
 *	GCCError	CopyResponseAlgorithm(
 *					PGCCChallengeResponseAlgorithm		source_algorithm,
 *					PResponseAlgorithmInfo				destination_algorithm)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy an "API" response algorithm into the
 *		internal storage structure.
 *
 *	Formal Parameters:
 *		source_algorithm		(i)	The API algorithm structure to copy 
 *										internally.
 *		destination_algorithm	(o)	Pointer to the internal algorithm structure
 *										which will hold the converted item.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::CopyResponseAlgorithm(
					PGCCChallengeResponseAlgorithm		source_algorithm,
					PResponseAlgorithmInfo				destination_algorithm)
{
	GCCError			return_value = GCC_NO_ERROR;
	GCCError			error_value;

	/*
	 * Copy the challenge response algorithm.
	 */
	destination_algorithm->algorithm_type = source_algorithm->
													password_algorithm_type;

	if (destination_algorithm->algorithm_type == GCC_NON_STANDARD_ALGORITHM)
	{
		/* 
		 * Create a new CObjectKeyContainer object to hold the algorithm's object key
		 * internally.
		 */
		DBG_SAVE_FILE_LINE
		destination_algorithm->object_key = new CObjectKeyContainer(
							&source_algorithm->non_standard_algorithm->object_key,
							&error_value);
		if (destination_algorithm->object_key == NULL)
		{
			ERROR_OUT(("CPassword::CopyResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
		else if (error_value != GCC_NO_ERROR)
		{
			ERROR_OUT(("CPassword::CopyResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_INVALID_PASSWORD;
		}

		if (return_value == GCC_NO_ERROR)
		{
			/* 
			 * Create a new Rogue Wave string to hold the algorithm's octet 
			 * string internally.
			 */
			if (NULL == (destination_algorithm->poszOctetString = ::My_strdupO2(
						source_algorithm->non_standard_algorithm->parameter_data.value,
						source_algorithm->non_standard_algorithm->parameter_data.length)))
			{	
				ERROR_OUT(("CPassword::CopyResponseAlgorithm: can't create octet string in algorithm"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
			destination_algorithm->poszOctetString = NULL;
	}
	else
	{
		/*
		 * The algorithm is a standard type so initialize to NULL the pointers
		 * used to hold the data associated with a non-standard algorithm.
		 */
		destination_algorithm->object_key = NULL;
		destination_algorithm->poszOctetString = NULL;
	}

	return (return_value);
}

/*
 *	GCCError	ConvertPDUChallengeRequest (
 *					PChallengeRequest					challenge_request);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy a "PDU" challenge request structure into
 *		the internal storage structure.
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUChallengeRequest(PChallengeRequest challenge_request)
{
	GCCError				return_value = GCC_NO_ERROR;
	PSetOfChallengeItems	current_challenge_item_set;
	PSetOfChallengeItems	next_challenge_item_set;

	/*
	 * Save the challenge tag in the internal structure.
	 */
	m_pInternalRequest->challenge_tag = challenge_request->challenge_tag;

	if (challenge_request->set_of_challenge_items != NULL)
	{
		/*
		 * Loop through the PDU set of challenge items, converting each into
		 * the internal form.
		 */
		current_challenge_item_set = challenge_request->set_of_challenge_items;
		while (1)
		{
			next_challenge_item_set = current_challenge_item_set->next;

			/*
			 * The routine which converts the challenge items saves the internal
			 * form in a Rogue Wave list.
			 */
			if (ConvertPDUChallengeItem (&current_challenge_item_set->value) !=
					GCC_NO_ERROR)
			{
				return_value = GCC_ALLOCATION_FAILURE;
				break;
			}

			if (next_challenge_item_set != NULL)
				current_challenge_item_set = next_challenge_item_set;
			else
				break;	
		}
	}

	return (return_value);
}


/*
 *	GCCError	ConvertPDUChallengeItem (
 *					PChallengeItem						challenge_item_ptr);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy a "PDU" ChallengeItem structure into
 *		the internal ChallengeItemInfo storage structure.
 *
 *	Formal Parameters:
 *		challenge_item_ptr		(i)	The PDU structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUChallengeItem(PChallengeItem challenge_item_ptr)
{
	PChallengeItemInfo		challenge_item_info_ptr;
	GCCError				return_value = GCC_NO_ERROR;
	GCCError				error_value = GCC_NO_ERROR;

	/*
	 * Create a new challenge item and save it in the internal Rogue Wave List.
	 */
	DBG_SAVE_FILE_LINE
	challenge_item_info_ptr = new ChallengeItemInfo;
	if (challenge_item_info_ptr != NULL)
	{
		/*
		 * Insert the pointer to the new challenge item structure into the 
		 * internal Rogue Wave list.
		 */
		challenge_item_info_ptr->challenge_data_list = NULL;
	
		m_pInternalRequest->ChallengeItemList.Append(challenge_item_info_ptr);

		/*
		 * Convert the challenge response algorithm to the internal structure.
		 */
		if (ConvertPDUResponseAlgorithm(
				&(challenge_item_ptr->response_algorithm),
				&(challenge_item_info_ptr->algorithm)) != GCC_NO_ERROR)
		{
			ERROR_OUT(("Password::ConvertAPIChallengeItem: Error converting Response Algorithm."));
			return_value = GCC_ALLOCATION_FAILURE;
		}

		/*
		 * Convert the challenge data to internal form.
		 */
		if ((return_value == GCC_NO_ERROR) &&
				(challenge_item_ptr->set_of_challenge_data != NULL))
		{
			DBG_SAVE_FILE_LINE
			challenge_item_info_ptr->challenge_data_list = new CUserDataListContainer(
					challenge_item_ptr->set_of_challenge_data,
					&error_value);
			if ((challenge_item_info_ptr->challenge_data_list == NULL) || 
					(error_value != GCC_NO_ERROR))
			{
				ERROR_OUT(("Password::ConvertAPIChallengeItem: can't create CUserDataListContainer."));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("Password::ConvertAPIChallengeItem: Error no valid user data"));
			return_value = GCC_INVALID_PASSWORD;
		}
	}
	else
	{
		ERROR_OUT(("Password::ConvertAPIChallengeItem: Error creating "
				"new ChallengeItemInfo."));
		return_value = GCC_ALLOCATION_FAILURE;
	}
	
	return (return_value);
}

/*
 *	GCCError	ConvertPDUChallengeResponse (
 *							PChallengeResponse			challenge_response)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy a "PDU" challenge response structure into
 *		the internal structure.
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUChallengeResponse(PChallengeResponse challenge_response)
{
	GCCError				return_value = GCC_NO_ERROR;
	GCCError				error_value = GCC_NO_ERROR;

	/*
	 * Save the challenge tag in the internal structure.
	 */
	m_pInternalResponse->challenge_tag = challenge_response->challenge_tag;

	/*
	 * Convert the challenge response algorithm to the internal structure.
	 */
	if (ConvertPDUResponseAlgorithm(
			&(challenge_response->response_algorithm),
			&(m_pInternalResponse->algorithm)) != GCC_NO_ERROR)
	{
		ERROR_OUT(("Password::ConvertPDUChallengeResponse: Error converting Response Algorithm."));
		return_value = GCC_ALLOCATION_FAILURE;
	}

	/*
	 * Check to see what form the challenge response item has taken.  Create
	 * the necessary object to hold the item internally.
	 */
	if ((challenge_response->response_item.choice == PASSWORD_STRING_CHOSEN) &&
			(return_value == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		m_pInternalResponse->challenge_response_item.password = new CPassword(
			&challenge_response->response_item.u.password_string,
			&error_value);
		if ((m_pInternalResponse->challenge_response_item.password == NULL) || 
				(error_value != GCC_NO_ERROR))
		{
			ERROR_OUT(("Password::ConvertPDUChallengeResponse: Error creating new CPassword."));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pInternalResponse->challenge_response_item.password = NULL;

	if ((challenge_response->response_item.choice == 
			SET_OF_RESPONSE_DATA_CHOSEN) && (return_value == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		m_pInternalResponse->challenge_response_item.response_data_list = 
				new CUserDataListContainer(challenge_response->response_item.u.set_of_response_data,
				            &error_value);
		if ((m_pInternalResponse->challenge_response_item.
				response_data_list == NULL) || (error_value != GCC_NO_ERROR))
		{
			ERROR_OUT(("Password::ConvertPDUChallengeResponse: can't create CUserDataListContainer."));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
    {
		m_pInternalResponse->challenge_response_item.response_data_list = NULL;
    }

	return (return_value);
}

/*
 *	GCCError	ConvertPDUResponseAlgorithm (
 *					PChallengeResponseAlgorithm			source_algorithm,
 *					PResponseAlgorithmInfo				destination_algorithm);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to convert a "PDU" response algorithm 
 * 		structure into the internal form.
 *
 *	Formal Parameters:
 *		source_algorithm		(i)	The PDU algorithm structure to copy 
 *										internally.
 *		destination_algorithm	(o) Pointer to the internal structure which will
 *										hold the converted item.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	A NULL pointer was passed in or
 *												the algorithm has invalid type.
 *		GCC_INVALID_PASSWORD			-	An invalid password was passed in. 
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUResponseAlgorithm(
					PChallengeResponseAlgorithm			source_algorithm,
					PResponseAlgorithmInfo				destination_algorithm)
{
	GCCError			return_value = GCC_NO_ERROR;
	GCCError			error_value;;

	if (source_algorithm != NULL)
	{
		/*
		 * Convert the challenge response algorithm type.
		 */
		if (source_algorithm->choice == ALGORITHM_CLEAR_PASSWORD_CHOSEN)
			destination_algorithm->algorithm_type = GCC_IN_THE_CLEAR_ALGORITHM;
		else if (source_algorithm->choice == NON_STANDARD_ALGORITHM_CHOSEN)
			destination_algorithm->algorithm_type = GCC_NON_STANDARD_ALGORITHM;
		else
		{
			ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error: invalid password type"));
			return_value = GCC_INVALID_PARAMETER;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error: NULL source pointer."));
		return_value = GCC_INVALID_PARAMETER;
	}
	
	if ((return_value == GCC_NO_ERROR) && 
			(source_algorithm->choice == NON_STANDARD_ALGORITHM_CHOSEN))
	{
		/* 
		 * Create a new CObjectKeyContainer object to hold the algorithm's object key
		 * internally.
		 */
		DBG_SAVE_FILE_LINE
		destination_algorithm->object_key = new CObjectKeyContainer(
							&source_algorithm->u.non_standard_algorithm.key,
							&error_value);
		if (destination_algorithm->object_key == NULL)
		{
			ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
		else if (error_value != GCC_NO_ERROR)
		{
			ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_INVALID_PASSWORD;
		}
		else
		{
			/* 
			 * Create a new Rogue Wave string to hold the algorithm's octet
			 * string internally.
			 */
			if (NULL == (destination_algorithm->poszOctetString = ::My_strdupO2(
					source_algorithm->u.non_standard_algorithm.data.value,
					source_algorithm->u.non_standard_algorithm.data.length)))
			{	
				ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: can't create octet string in algorithm"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
	}
	else
	{
		/*
		 * The algorithm is a standard type so initialize to NULL the pointers
		 * used to hold the data associated with a non-standard algorithm.
		 */
		destination_algorithm->poszOctetString = NULL;
		destination_algorithm->object_key = NULL;
	}

	return (return_value);
}


/*
 *	GCCError	GetGCCChallengeRequest (
 *					PGCCChallengeRequest				challenge_request)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to fill in the internal "API" challenge request
 *		structure from the internal storage structures.  This is done on a 
 *		"lock" in order to make data available which is suitable for being
 *		passed back up through the API.  
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The API structure to fill in with the "API"
 *										challenge request data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetGCCChallengeRequest(PGCCChallengeRequest challenge_request)
{
	GCCError					return_value = GCC_NO_ERROR;
	UInt						i = 0;
	Int							j = 0;
	PGCCChallengeItem			api_challenge_item_ptr;
	PChallengeItemInfo			internal_challenge_item_ptr;
	PChallengeItemMemoryInfo	internal_challenge_item_memory_ptr;		
	UINT						object_key_length;
	UINT						user_data_length;

	/*
	 * Save the challenge tag and retrieve the number of challenge items.
	 */
	challenge_request->challenge_tag = m_pInternalRequest->challenge_tag;

	challenge_request->number_of_challenge_items = 
							(USHORT) m_pInternalRequest->ChallengeItemList.GetCount();

	if (m_pInternalRequest->ChallengeItemList.GetCount() != 0)
	{
		/*
		 * Allocate the space needed for the list of pointers to GCC challenge 
		 * items.
		 */
		DBG_SAVE_FILE_LINE
		m_pChallengeItemListMemory = new BYTE[sizeof(PGCCChallengeItem) * m_pInternalRequest->ChallengeItemList.GetCount()];
		if (m_pChallengeItemListMemory != NULL)
		{
			PChallengeItemInfo lpChItmInfo;

			/*
			 * Retrieve the actual pointer to memory from the Memory object
			 * and save it in the internal API Challenge Item list.
			 */
			challenge_request->challenge_item_list = (GCCChallengeItem **)
										m_pChallengeItemListMemory;

			/*
			 * Initialize the pointers in the list to NULL.
			 */						
			for (i=0; i < m_pInternalRequest->ChallengeItemList.GetCount(); i++)
				challenge_request->challenge_item_list[i] = NULL;
			
			/*
			 * Copy the data from the internal list of "ChallengeItemInfo" 
			 * structures into the "API" form which is a list of pointers
			 * to GCCChallengeItem structures.
			 */
			m_pInternalRequest->ChallengeItemList.Reset();
			while (NULL != (lpChItmInfo = m_pInternalRequest->ChallengeItemList.Iterate()))
			{
				/* 
				 * Get a pointer to a new GCCChallengeItem structure.
				 */
				DBG_SAVE_FILE_LINE
				api_challenge_item_ptr = new GCCChallengeItem;
				if (api_challenge_item_ptr != NULL)
				{
					/*
					 * Go ahead and put the pointer in the list and 
					 * post-increment the loop counter.
					 */
					challenge_request->challenge_item_list[j++] =
							api_challenge_item_ptr;
			
					/*
					 * Retrieve the ChallengeItemInfo structure from the Rogue 
					 * Wave list.
					 */
					internal_challenge_item_ptr = lpChItmInfo;

					/*
					 * Fill in the algorithm type for the challenge response
					 * algorithm.
					 */
					api_challenge_item_ptr->response_algorithm.
							password_algorithm_type = 
							internal_challenge_item_ptr->
									algorithm.algorithm_type;

					/*
					 * The memory for the response algorithm's object key data 
					 * and the challenge item's used data are stored in
					 * a ChallengeItemMemoryInfo structure so create one
					 * here.  If the response algorithm is "clear" then the
					 * object key data element will not be used.  The challenge
					 * item user data should always exist.
					 */
					DBG_SAVE_FILE_LINE
					internal_challenge_item_memory_ptr = new ChallengeItemMemoryInfo;
					if (internal_challenge_item_memory_ptr != NULL)
					{
						/*
						 * Initialize the pointers in the challenge item 
						 * memory info structure to NULL.
						 */
						internal_challenge_item_memory_ptr->user_data_list_memory = NULL;
						internal_challenge_item_memory_ptr->object_key_memory = NULL;

						/*
						 * Insert the pointer to the new challenge item 
						 * memory structure into the internal Rogue Wave 
						 * list.
						 */
						m_ChallengeItemMemoryList.Append(internal_challenge_item_memory_ptr);
					}
					else
					{
						ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error creating new ChallengeItemMemoryInfo"));
						return_value = GCC_ALLOCATION_FAILURE;
						break;
					}

					if (api_challenge_item_ptr->response_algorithm.password_algorithm_type == 
							GCC_NON_STANDARD_ALGORITHM)
					{
						/*
						 * Create a new GCCNonStandardParameter to put in the
						 * ResponseAlgorithm structure.
						 */
						DBG_SAVE_FILE_LINE
						api_challenge_item_ptr->response_algorithm.non_standard_algorithm = 
								new GCCNonStandardParameter;

						if (api_challenge_item_ptr->response_algorithm.non_standard_algorithm	== NULL)
						{
							ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error creating new GCCNonStdParameter"));
							return_value = GCC_ALLOCATION_FAILURE;
							break;
						}

						/*
						 * Retrieve the API object key from the CObjectKeyContainer
						 * object in the ResponseAlgorithmInfo structure and
						 * fill in the GCCObjectKey in the non-standard 
						 * algorithm.  The CObjectKeyContainer object must be locked 
						 * before getting the data.
						 */
						object_key_length = internal_challenge_item_ptr->
								algorithm.object_key->LockObjectKeyData ();

						DBG_SAVE_FILE_LINE
						internal_challenge_item_memory_ptr->object_key_memory =
						        new BYTE[object_key_length];
						if (internal_challenge_item_memory_ptr->object_key_memory != NULL)
						{
							internal_challenge_item_ptr->algorithm.object_key->GetGCCObjectKeyData(
									&(api_challenge_item_ptr->response_algorithm.non_standard_algorithm->object_key),
									internal_challenge_item_memory_ptr->object_key_memory);
						}
						else
						{
							ERROR_OUT(("CPassword::GetGCCChallengeReq: Error Allocating Memory"));
							return_value = GCC_ALLOCATION_FAILURE;
						 	break;
						}

						/*
						 * Fill in the parameter data for the non-standard
						 * algorithm.  This includes the octet string pointer 
						 * and length.
						 */
						api_challenge_item_ptr->response_algorithm.non_standard_algorithm->
								parameter_data.value = 
								internal_challenge_item_ptr->algorithm.poszOctetString->value;

						api_challenge_item_ptr->response_algorithm.non_standard_algorithm->
								parameter_data.length =
								internal_challenge_item_ptr->algorithm.poszOctetString->length;
					}
					else
					{
						/*
						 * The algorithm is not a non-standard type so set the 
						 * non-standard pointer to NULL.
						 */
						api_challenge_item_ptr->response_algorithm.non_standard_algorithm = NULL;
					}

					/*
					 * Retrieve the API challenge data from the CUserDataListContainer 
					 * object.  The	call to GetUserDataList also returns the 
					 * number of user data members.  The CUserDataListContainer object
					 * must be locked before getting the data in order to 
					 * determine how much memory to allocate to hold the data.
					 */
					if (internal_challenge_item_ptr->challenge_data_list != NULL)
					{
						user_data_length = internal_challenge_item_ptr->
								challenge_data_list->LockUserDataList ();

						/*
						 * The memory for the user data is stored in the
						 * ChallengeItemMemoryInfo structure created above.
						 */
						DBG_SAVE_FILE_LINE
						internal_challenge_item_memory_ptr->user_data_list_memory =
						        new BYTE[user_data_length];
						if (internal_challenge_item_memory_ptr->user_data_list_memory != NULL)
						{
							/*
							 * Retrieve the actual pointer to memory from the 
							 * Memory object and save it in the internal user 
							 * data memory.
							 */
							internal_challenge_item_ptr->challenge_data_list->GetUserDataList(
										&api_challenge_item_ptr->number_of_challenge_data_members,
										&api_challenge_item_ptr->challenge_data_list,
										internal_challenge_item_memory_ptr->user_data_list_memory);
						}
						else
						{
							ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error Allocating Memory"));
							return_value = GCC_ALLOCATION_FAILURE;
						 	break;
						}
					}
					else
					{
						ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error no valid user data"));
						return_value = GCC_ALLOCATION_FAILURE;
					 	break;
					}
				}
				else
				{
					ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error creating new GCCChallengeItem"));
					return_value = GCC_ALLOCATION_FAILURE;
				 	break;
				}
			/*
			 * This is the end of the challenge item iterator loop.
			 */
			}
		}
		else
		{
			ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error Allocating Memory"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 * There are no challenge items in the list so set the list pointer
		 * to NULL.
		 */
		challenge_request->challenge_item_list = NULL;
	}

	return (return_value);
}

/*
 *	GCCError	GetGCCChallengeResponse (
 *					PGCCChallengeResponse				challenge_response);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to fill in the internal "API" challenge response
 *		structure from the internal storage structures.  This is done on a 
 *		"lock" in order to make data available which is suitable for being
 *		passed back up through the API.  
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The API structure to fill in with the "API"
 *										challenge response data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetGCCChallengeResponse(PGCCChallengeResponse challenge_response)
{
	GCCError		return_value = GCC_NO_ERROR;
	UINT			object_key_length;
	UINT			user_data_length;

	challenge_response->challenge_tag = m_pInternalResponse->challenge_tag;

	/*
	 * Fill in the algorithm type for the challenge response algorithm.
	 */
	challenge_response->response_algorithm.password_algorithm_type = 
			m_pInternalResponse->algorithm.algorithm_type;

	/*
	 * If the response algorithm is of non-standard type, create a new 
	 * GCCNonStandardParameter to put in the ResponseAlgorithm structure.
	 */
	if (challenge_response->response_algorithm.password_algorithm_type ==
			GCC_NON_STANDARD_ALGORITHM)
	{
		DBG_SAVE_FILE_LINE
		challenge_response->response_algorithm.non_standard_algorithm =
				new GCCNonStandardParameter;
		if (challenge_response->response_algorithm.non_standard_algorithm == 
				NULL)
		{
			ERROR_OUT(("CPassword::GetGCCChallengeResponse: Error creating new GCCNonStandardParameter"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			/*
			 * Retrieve the API object key from the CObjectKeyContainer object in the 
			 * ResponseAlgorithmInfo structure and fill	in the GCCObjectKey in  
			 * the non-standard algorithm.  The CObjectKeyContainer object must be 
			 * locked before getting the data.
			 */
			object_key_length = m_pInternalResponse->algorithm.object_key->
					LockObjectKeyData ();

    		DBG_SAVE_FILE_LINE
			m_pObjectKeyMemory = new BYTE[object_key_length];
			if (m_pObjectKeyMemory != NULL)
			{
				m_pInternalResponse->algorithm.object_key->
						GetGCCObjectKeyData (&(challenge_response->
								response_algorithm.non_standard_algorithm->
										object_key),
								m_pObjectKeyMemory);
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeResponse: Error Allocating Memory"));
				return_value = GCC_ALLOCATION_FAILURE;
			}

			/*
			 * Fill in the parameter data for the non-standard algorithm.
			 */
			if (return_value == GCC_NO_ERROR)
			{
				/*
				 * Fill in the octet string pointer and length.
				 */
				challenge_response->response_algorithm.non_standard_algorithm->
						parameter_data.value = 
						m_pInternalResponse->algorithm.poszOctetString->value;

				challenge_response->response_algorithm.non_standard_algorithm->
						parameter_data.length = 
						m_pInternalResponse->algorithm.poszOctetString->length;
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error getting GCCObjectKeyData"));
				return_value = GCC_ALLOCATION_FAILURE;
			} 
		}
	}
	else
	{
		/*
		 * The algorithm in not non-standard so set the non-standard algorithm
		 * pointer to NULL.
		 */
		challenge_response->response_algorithm.non_standard_algorithm = NULL;
	}
	
	/*
	 * Now fill in the challenge response item in the challenge response
	 * structure.
	 */
	if (return_value == GCC_NO_ERROR)
	{
		/*
		 * Check to see whether the challenge response item consists of a 
		 * password string or a set of user data.  Fill in the appropriate
		 * part.
		 */
		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			/*
			 * Set the number of user data members to zero to avoid any 
			 * confusion at the application.  This should match up with the 
			 * algorithm being set to "in the clear".
			 */
			challenge_response->response_item.
							number_of_response_data_members = 0;
			challenge_response->response_item.
							response_data_list = NULL;
		
			/* 
			 * Retrieve the API GCCPassword from the CPassword object.  The
			 * CPassword object must be locked before getting the data.
			 */
			if (m_pInternalResponse->challenge_response_item.
					password->LockPasswordData () == GCC_NO_ERROR)
			{
				return_value = m_pInternalResponse->challenge_response_item.
						password->GetPasswordData (&(challenge_response->
						response_item.password_string));
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error locking CPassword"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else if (m_pInternalResponse->challenge_response_item.response_data_list != NULL)
		{
			/*
			 * Set the password string to NULL to avoid any confusion at the 
			 * application.  This should match up with the algorithm set to
			 * non-standard.
			 */
			challenge_response->response_item.password_string = NULL;
			
			/*
			 * Retrieve the API challenge data from the CUserDataListContainer 
			 * object.  The	call to GetUserDataList also returns the 
			 * number of user data members.  The CUserDataListContainer object
			 * must be locked before getting the data in order to 
			 * determine how much memory to allocate to hold the data.
			 */
			user_data_length = m_pInternalResponse->challenge_response_item.
					response_data_list->LockUserDataList ();

    		DBG_SAVE_FILE_LINE
			m_pUserDataMemory = new BYTE[user_data_length];
			if (m_pUserDataMemory != NULL)
			{
				/*
				 * Retrieve the actual pointer to memory from the Memory
				 * object and save it in the internal user data memory.
				 */
				m_pInternalResponse->challenge_response_item.response_data_list->
						GetUserDataList (
								&challenge_response->response_item.
										number_of_response_data_members,
								&challenge_response->response_item.
										response_data_list,
								m_pUserDataMemory);
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error allocating memory"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error saving response item"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}

	return (return_value);
}

/*
 *	GCCError	GetChallengeRequestPDU (
 *					PChallengeRequest					challenge_request);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine converts internal challenge request data to "PDU" form.
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The PDU structure to fill in with the
 *										challenge request data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	The algorithm type was not set
 *												properly.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetChallengeRequestPDU(PChallengeRequest challenge_request)
{
	GCCError					return_value = GCC_NO_ERROR;
	PSetOfChallengeItems		new_set_of_challenge_items;
	PSetOfChallengeItems		old_set_of_challenge_items;
	DWORD						number_of_items;
	PChallengeItemInfo			internal_challenge_item_ptr;

	/*
	 * Fill in the challenge tag.
	 */
	challenge_request->challenge_tag = m_pInternalRequest->challenge_tag;

	/*
	 * Initialize the set pointers to NULL in order to detect the first time
	 * through the iterator loop.
	 */
	challenge_request->set_of_challenge_items = NULL;
    old_set_of_challenge_items = NULL;

	/*
	 * Retrieve the number of challenge items in the internal list.
	 */
	number_of_items = m_pInternalRequest->ChallengeItemList.GetCount();

	if (number_of_items > 0)
	{
		PChallengeItemInfo		lpChItmInfo;
		/*
		 * Iterate through the internal list of challenge items, creating a
		 * new "PDU" SetOfChallengeItems for each and filling it in.
		 */
		m_pInternalRequest->ChallengeItemList.Reset();
		while (NULL != (lpChItmInfo = m_pInternalRequest->ChallengeItemList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_set_of_challenge_items = new SetOfChallengeItems;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_set_of_challenge_items == NULL)
			{
				ERROR_OUT(("CPassword::GetChallengeRequestPDU: Allocation error, cleaning up"));
				return_value = GCC_ALLOCATION_FAILURE;
				FreeChallengeRequestPDU ();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfChallengeItems created.  On subsequent loops,
			 * set the structure's "next" pointer equal to the new structure.
			 */
			if (challenge_request->set_of_challenge_items == NULL)
			{
				challenge_request->set_of_challenge_items = 
						new_set_of_challenge_items;
			}
			else
				old_set_of_challenge_items->next = new_set_of_challenge_items;
	
			/*
			 * Save the newly created set and initialize the new "next" 
			 * pointer to NULL in case this is the last time through the loop.
			 */
			old_set_of_challenge_items = new_set_of_challenge_items;
			new_set_of_challenge_items->next = NULL;

			/*
			 * Retrieve the ChallengeItemInfo structure from the Rogue 
			 * Wave list and fill in the "PDU" challenge item structure from 
			 * the internal	challenge item structure.
			 */
			internal_challenge_item_ptr = lpChItmInfo;

			return_value = ConvertInternalChallengeItemToPDU (
										internal_challenge_item_ptr,
										&new_set_of_challenge_items->value);
			 
			/*
			 * Cleanup if an error has occurred.
			 */
			if (return_value != GCC_NO_ERROR)
			{
				FreeChallengeRequestPDU ();
			}
		}
	}
	else
	{
		ERROR_OUT(("CPassword::GetChallengeRequestPDU: Error no items"));
	}
		
	return (return_value);
}

/*
 *	GCCError	ConvertInternalChallengeItemToPDU(
 *					PChallengeItemInfo				internal_challenge_item,
 *					PChallengeItem					pdu_challenge_item)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine converts an internal ChallengeItemInfo structure into
 *		the "PDU" form of a ChallengeItem structure.
 *
 *	Formal Parameters:
 *		internal_challenge_item		(i)	The internal challenge item to convert.
 *		pdu_challenge_item			(o) The	output PDU form of the challenge
 *											item.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	The algorithm type was not set
 *												properly.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertInternalChallengeItemToPDU(
					PChallengeItemInfo				internal_challenge_item,
					PChallengeItem					pdu_challenge_item)
{
	GCCError		return_value = GCC_NO_ERROR;

	/*
	 * First convert the algorithm.
	 */
	if (internal_challenge_item->algorithm.algorithm_type == 
												GCC_IN_THE_CLEAR_ALGORITHM)
	{
		pdu_challenge_item->response_algorithm.choice = 
				ALGORITHM_CLEAR_PASSWORD_CHOSEN;
	}
	else if (internal_challenge_item->algorithm.algorithm_type == 
												GCC_NON_STANDARD_ALGORITHM)
	{
		pdu_challenge_item->response_algorithm.choice = 
				NON_STANDARD_ALGORITHM_CHOSEN;

		/*
		 * Retrieve the "PDU" object key data from the internal CObjectKeyContainer
		 * object.
		 */
		if (internal_challenge_item->algorithm.object_key->
				GetObjectKeyDataPDU (
						&pdu_challenge_item->response_algorithm.u.
						non_standard_algorithm.key) == GCC_NO_ERROR)
		{
			/*
			 * Retrieve the non-standard parameter data from the internal
			 * algorithm octet string.
			 */
			pdu_challenge_item->response_algorithm.u.non_standard_algorithm.data.value = 
						internal_challenge_item->algorithm.poszOctetString->value;

			pdu_challenge_item->response_algorithm.u.non_standard_algorithm.data.length = 
						internal_challenge_item->algorithm.poszOctetString->length;
		}
		else
		{
			ERROR_OUT(("CPassword::ConvertInternalChallengeItemToPDU: Error getting ObjKeyData"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::ConvertInternalChallengeItemToPDU: Error bad algorithm type"));
		return_value = GCC_INVALID_PARAMETER;
	}

	/*
	 * Now retrieve the set of user data.
	 */
	if (return_value == GCC_NO_ERROR)
	{
		return_value = internal_challenge_item->challenge_data_list->
				GetUserDataPDU (&pdu_challenge_item->set_of_challenge_data);
	}
		
	return (return_value);
}

/*
 *	GCCError	GetChallengeResponsePDU (
 *					PChallengeResponse					challenge_response);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine converts internal challenge response data to "PDU" form.
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The PDU structure to fill in with the
 *										challenge response data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			- 	The form of the password is not 
 *												valid.
 *		GCC_INVALID_PARAMETER			-	The algorithm type was not set
 *												properly.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetChallengeResponsePDU(PChallengeResponse challenge_response)
{
	GCCError	return_value = GCC_NO_ERROR;

	/*
	 * Fill in the challenge tag.
	 */
	challenge_response->challenge_tag = m_pInternalResponse->challenge_tag;

	/*
	 * Fill in the response algorithm.
	 */
	if (m_pInternalResponse->algorithm.algorithm_type ==
													GCC_IN_THE_CLEAR_ALGORITHM)
	{
		challenge_response->response_algorithm.choice = 
				ALGORITHM_CLEAR_PASSWORD_CHOSEN;
	
		/*
		 * Now convert the challenge response item.  The challenge response item
		 * will consist of either a password string or a set of user data.
		 */
		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			/*
			 * If the password string exists, set the "PDU" choice and retrieve
			 * the password selector data from the internal CPassword object.
			 */
			challenge_response->response_item.choice = PASSWORD_STRING_CHOSEN;

			return_value= m_pInternalResponse->challenge_response_item.password->
					GetPasswordSelectorPDU (&challenge_response->response_item.
					u.password_string);
		}
		else
			return_value = GCC_INVALID_PASSWORD;
	}
	else if (m_pInternalResponse->algorithm.algorithm_type ==
													GCC_NON_STANDARD_ALGORITHM)
	{
		challenge_response->response_algorithm.choice = 
				NON_STANDARD_ALGORITHM_CHOSEN;
		
		/*
		 * Retrieve the "PDU" object key data from the internal CObjectKeyContainer
		 * object.
		 */
		if (m_pInternalResponse->algorithm.object_key->
				GetObjectKeyDataPDU (
						&challenge_response->response_algorithm.u.
						non_standard_algorithm.key) == GCC_NO_ERROR)
		{
			/*
			 * Retrieve the non-standard parameter data from the internal
			 * algorithm octet string.
			 */
			challenge_response->response_algorithm.u.non_standard_algorithm.data.value = 
						m_pInternalResponse->algorithm.poszOctetString->value;

			challenge_response->response_algorithm.u.non_standard_algorithm.data.length = 
						m_pInternalResponse->algorithm.poszOctetString->length;

			if (m_pInternalResponse->challenge_response_item.response_data_list != NULL)
			{
				/*
				 * If the response data list exists, set the "PDU" choice and
				 * retrieve the response data from the internal 
				 * CUserDataListContainer object.
				 */
				challenge_response->response_item.choice = 
						SET_OF_RESPONSE_DATA_CHOSEN;

				return_value = m_pInternalResponse->challenge_response_item.
						response_data_list->GetUserDataPDU (
								&challenge_response->response_item.u.
								set_of_response_data);
			}
			else
				return_value = GCC_INVALID_PASSWORD;
		}
		else
		{
			return_value = GCC_ALLOCATION_FAILURE;
			ERROR_OUT(("CPassword::GetChallengeResponsePDU: Error getting ObjKeyData"));
		}
	}
	else
	{
		ERROR_OUT(("CPassword::GetChallengeResponsePDU: Error bad algorithm type"));
		return_value = GCC_INVALID_PARAMETER;
	}

	return (return_value);
}

/*
 *	void	FreeChallengeRequestPDU ();
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to free any "PDU" data allocated for the
 *		challenge request structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CPassword::FreeChallengeRequestPDU(void)
{
	PSetOfChallengeItems	set_of_challenge_items;
	PSetOfChallengeItems	next_set_of_challenge_items;
	PChallengeItemInfo		challenge_item_ptr;
	PChallengeRequest		challenge_request;

	/*
	 * Retrieve the challenge request pointer from the internally maintained
	 * PasswordChallengeRequestResponse structure and delete each set of
	 * challenge items which was created.
	 */
	challenge_request = &m_ChallengeResponsePDU.u.challenge_request_response.
			challenge_request;

	if (challenge_request != NULL)
	{
		if (challenge_request->set_of_challenge_items == NULL)
		{
			ERROR_OUT(("CPassword::FreeChallengeRequestPDU: NULL ptr passed"));
		}
		else
		{
			set_of_challenge_items = challenge_request->set_of_challenge_items;

			while (1)
			{
				if (set_of_challenge_items == NULL)
					break;

				next_set_of_challenge_items = set_of_challenge_items->next;

				delete set_of_challenge_items;

				set_of_challenge_items = next_set_of_challenge_items;
			}
		}
	}
	else
	{
		WARNING_OUT(("CPassword::FreeChallengeRequestPDU: NULL pointer passed"));
	}

	/*
	 * Loop through the internal list of challenge items, freeing the data 
	 * associated with each challenge item structure contained in the list.
	 */
	m_pInternalRequest->ChallengeItemList.Reset();
	while (NULL != (challenge_item_ptr = m_pInternalRequest->ChallengeItemList.Iterate()))
	{
		/*
		 * Retrieve the ChallengeItemInfo structure from the Rogue 
		 * Wave list and use the CUserDataListContainer object contained in the
		 * structure to free the PDU user data.  Also use the CObjectKeyContainer
		 * object contained in the algorithm structure to free the PDU
		 * data associated with the object key.
		 */
		if (challenge_item_ptr != NULL)
		{
			if (challenge_item_ptr->algorithm.object_key != NULL)
			{
				challenge_item_ptr->algorithm.object_key->FreeObjectKeyDataPDU();
			}
			if (challenge_item_ptr->challenge_data_list != NULL)
			{
				challenge_item_ptr->challenge_data_list->FreeUserDataListPDU();
			}
		}
	}
}

/*
 *	void	FreeChallengeResponsePDU ();
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to free any "PDU" data allocated for the
 *		challenge response structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CPassword::FreeChallengeResponsePDU(void)
{
	PChallengeResponse		challenge_response;

	/*
	 * Retrieve the challenge response pointer from the internally maintained
	 * PasswordChallengeRequestResponse structure.  If it is not equal to NULL
	 * then we know PDU response data has been allocated which must be freed.
	 */
	challenge_response = &m_ChallengeResponsePDU.u.challenge_request_response.
			challenge_response;

	if ((challenge_response != NULL) && (m_pInternalResponse != NULL))
	{
		if (m_pInternalResponse->algorithm.object_key != NULL)
			m_pInternalResponse->algorithm.object_key->FreeObjectKeyDataPDU ();

		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			m_pInternalResponse->challenge_response_item.
					password->FreePasswordChallengeResponsePDU ();
		}
			
		if (m_pInternalResponse->challenge_response_item.
				response_data_list != NULL)
		{
			m_pInternalResponse->challenge_response_item.
					response_data_list->FreeUserDataListPDU ();
		}	
	}
}

/*
 *	void	FreeAPIPasswordData ();
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to free any data allocated by this container to
 * 		hold "API" data.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CPassword::FreeAPIPasswordData(void)
{
	PGCCChallengeItem			challenge_item_ptr;
	PChallengeItemInfo			challenge_item_info_ptr;
	PChallengeItemMemoryInfo	challenge_item_memory_info;
	USHORT						i;

	/*
	 * Delete any "API" memory associated with the challenge request if
	 * it exists.
	 */
	if (m_pChallengeResponse->u.challenge_request_response.
			challenge_request != NULL)
	{
		for (i=0; i<m_pChallengeResponse->u.
				challenge_request_response.challenge_request->
				number_of_challenge_items; i++)
		{
			challenge_item_ptr = m_pChallengeResponse->u.
					challenge_request_response.challenge_request->
					challenge_item_list[i];

			if (challenge_item_ptr != NULL)
			{
				/*
				 * Delete the non-standard algorithm memory.
				 */
				delete challenge_item_ptr->response_algorithm.non_standard_algorithm;
				delete challenge_item_ptr;
			}	
		}

		delete m_pChallengeResponse->u.challenge_request_response.
				challenge_request;
	}
		
	/*
	 * Unlock any memory locked for the challenge request information.
	 */
	if (m_pInternalRequest != NULL)
	{
		/*
		 * Set up an iterator in order to loop through the list of challenge
		 * items, freeing up any allocated memory.
		 */
		m_pInternalRequest->ChallengeItemList.Reset();
		while (NULL != (challenge_item_info_ptr = m_pInternalRequest->ChallengeItemList.Iterate()))
		{
			/*
			 * Unlock any memory being referenced in the ChallengeItemInfo 
			 * structure.
			 */
			if (challenge_item_info_ptr->algorithm.object_key != NULL)
			{
				challenge_item_info_ptr->algorithm.object_key->
						UnLockObjectKeyData ();
			}

			if (challenge_item_info_ptr->challenge_data_list != NULL)
			{
				challenge_item_info_ptr->challenge_data_list->
						UnLockUserDataList ();
			}
		}
	}

	/*
	 * Call the Memory Manager to free the memory allocated to hold the 
	 * challenge request data.
	 */
	while (NULL != (challenge_item_memory_info = m_ChallengeItemMemoryList.Get()))
	{
		delete challenge_item_memory_info->user_data_list_memory;
		delete challenge_item_memory_info->object_key_memory;
		delete challenge_item_memory_info;
	}

	/*
	 * Delete any memory associated with the challenge response if
	 * it exists.
	 */
	if (m_pChallengeResponse->u.challenge_request_response.
			challenge_response != NULL)
	{
		/*
		 * Delete any memory associated with the non-standard algorithm and
		 * then delete the challenge response structure.
		 */
		delete m_pChallengeResponse->u.challenge_request_response.
					challenge_response->response_algorithm.non_standard_algorithm;

		delete m_pChallengeResponse->u.challenge_request_response.
				challenge_response;	
	}

	/*
	 * Unlock any memory allocated for the challenge response information.
	 */
	if (m_pInternalResponse != NULL)
	{
		if (m_pInternalResponse->algorithm.object_key != NULL)
		{
			m_pInternalResponse->algorithm.object_key->UnLockObjectKeyData();
		}

		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			m_pInternalResponse->challenge_response_item.password->
					UnLockPasswordData ();
		}

		if (m_pInternalResponse->challenge_response_item.
				response_data_list != NULL)
		{
			m_pInternalResponse->challenge_response_item.response_data_list->
					UnLockUserDataList ();
		}
	}

	/*
	 * Call the Memory Manager to free the memory allocated to hold the 
	 * challenge response data.
	 */
	delete m_pUserDataMemory;
	m_pUserDataMemory = NULL;

	delete m_pObjectKeyMemory;
	m_pObjectKeyMemory = NULL;

	/*
	 * Call the Memory Manager to free the memory allocated to hold the 
	 * challenge request challenge item pointers.
	 */
	delete m_pChallengeItemListMemory;
	m_pChallengeItemListMemory = NULL;

	/*
	 * Delete the challenge password structure and set the pointer to NULL.
	 */
	delete m_pChallengeResponse;
	m_pChallengeResponse = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\omcscode.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	omcscode.cpp
 *	
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CMCSCoder class.  This class
 *		is responsible for encoding and decoding T.125 PDU's using ASN.1 
 *		encoding rules via the ASN.1 toolkit.  This class is also capable
 *		of determining the size of both the encoded and decoded PDU's and is 
 *		capable of making copies of each of the PDU's. 
 *
 *	Private Instance Variables:
 *		Encoding_Rules_Type
 *			This variable holds the type of encoding rules which are currently
 *			being utilized.
 *
 *	Private Member Functions:
 *
 *		Copy***
 *			Private member functions exist which are capable of making complete
 *			copies of the decoded "Send Data" PDU data structures.  These 
 *			routines copy not only the data contained within the structure but 
 *			also any data which is referenced by the pointers held within the 
 *			structure.
 *
 *		SetEncodingRules
 *			This routine is used to switch between using Basic Encoding Rules
 *			(BER) and Packed Encoding Rules (PER).  This routine also updates
 *			the private instance variables used to hold values for the minimum
 *			and maximum amount of overhead associated with the "send data" PDUs.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 */

#include "omcscode.h"

/*
 * Macros.
 */
#define		BOOLEAN_TAG						0x01
#define		INTEGER_TAG						0x02
#define		BIT_STRING_TAG	   				0x03
#define		OCTET_STRING_TAG	   			0x04
#define		ENUMERATED_TAG	   				0x0a

#define		SEQUENCE						0x30
#define		SETOF							0x31
#define		INDEFINITE_LENGTH				0x80
#define		ONE_BYTE_LENGTH					0x81
#define		TWO_BYTE_LENGTH					0x82
#define		THREE_BYTE_LENGTH				0x83
#define		FOUR_BYTE_LENGTH				0x84
#define		END_OF_CONTENTS					0x00

#define		CONSTRUCTED_TAG_ZERO			0xa0	
#define		CONSTRUCTED_TAG_ONE				0xa1	
#define		CONSTRUCTED_TAG_TWO				0xa2	
#define		CONSTRUCTED_TAG_THREE			0xa3	
#define		CONSTRUCTED_TAG_FOUR			0xa4

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
CMCSCoder	*g_MCSCoder;

/*
 *	The following array contains a template for the X.224 data header.
 *	The 5 of the 7 bytes that it initializes are actually sent to the
 *	wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *	The array is only used when we encode a data PDU.
 */
UChar g_X224Header[] = { 3, 0, 0, 0, 2, DATA_PACKET, EOT_BIT };

/*
 *	CMCSCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the CMCSCoder class.  It initializes
 *		the ASN.1 encoder/decoder, saves the current encoding rules type,
 *		and sets values for the highest and lowest overhead in the "send data"
 *		PDU's.
 */
CMCSCoder::CMCSCoder ()
:m_pEncInfo(NULL),
 m_pDecInfo(NULL)
{
	Encoding_Rules_Type = BASIC_ENCODING_RULES;
// lonchanc: We should move Init out of constructor. However,
// to minimize the changes in the GCC/MCS code, we put it here for now.
// Otherwise, we need to change MCS and Packet interfaces.
// We will move it out and call Init() separately.
	Init();
}

BOOL CMCSCoder::Init ( void )
{
	BOOL fRet = FALSE;
	MCSPDU_Module_Startup();
	if (MCSPDU_Module != NULL)
	{
		if (ASN1_CreateEncoder(
                            MCSPDU_Module,	// ptr to mdule
                            &m_pEncInfo,	// ptr to encoder info
                            NULL,			// buffer ptr
                            0,				// buffer size
                            NULL)			// parent ptr
			== ASN1_SUCCESS)
		{
			ASSERT(m_pEncInfo != NULL);
			m_pEncInfo->cbExtraHeader = PROTOCOL_OVERHEAD_X224;
			fRet = (ASN1_CreateDecoder(
                                MCSPDU_Module,	// ptr to mdule
                                &m_pDecInfo,	// ptr to decoder info
                                NULL,			// buffer ptr
                                0,				// buffer size
                                NULL)			// parent ptr
					== ASN1_SUCCESS);
			ASSERT(fRet && m_pDecInfo != NULL);
		}
	}
	ASSERT(fRet);
	return fRet;
}

/*
 *	~CMCSCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a virtual destructor.  It is used to clean up after ASN.1.
 */
CMCSCoder::~CMCSCoder ()
{
	if (MCSPDU_Module != NULL)
	{
		ASN1_CloseEncoder(m_pEncInfo);
		ASN1_CloseDecoder(m_pDecInfo);
	    MCSPDU_Module_Cleanup();
	}
}

/*
 *	void	Encode ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function encodes MCS protocol data units (PDU's) into ASN.1 
 *		compliant byte streams using the ASN.1 toolkit.
 *		The encode happens in a coder-allocated buffer.
 */
BOOL	CMCSCoder::Encode(LPVOID			pdu_structure,
							int				pdu_type,
							UINT			rules_type,
							LPBYTE			*encoding_buffer,
							UINT			*encoding_buffer_length)
{
	BOOL					fRet = TRUE;
	BOOL					send_data_pdu = FALSE;
	int						return_value;

	//UINT					encoding_length;
	UShort					initiator;
	LPBYTE					buffer_pointer;
	PSendDataRequestPDU		send_data;
	UINT					PDUChoice;
	BOOL					bBufferAllocated;
	PMemory					memory;

	/*
	 * Check to make sure the encoding rules type is properly set.
	 */
	ASSERT(rules_type == PACKED_ENCODING_RULES || pdu_type == CONNECT_MCS_PDU);
	if (pdu_type == DOMAIN_MCS_PDU)
	{
		/*
		 *	Set PDUChoice to the type of MCS PDU we need to encode.
		 *	Also, determine if this is a data PDU.
		 */
		PDUChoice = (unsigned int) ((PDomainMCSPDU) pdu_structure)->choice;
		if ((PDUChoice == SEND_DATA_REQUEST_CHOSEN) ||
			(PDUChoice == SEND_DATA_INDICATION_CHOSEN) ||
			(PDUChoice == UNIFORM_SEND_DATA_REQUEST_CHOSEN) ||
			(PDUChoice == UNIFORM_SEND_DATA_INDICATION_CHOSEN)) {
			send_data_pdu = TRUE;
			send_data = &((PDomainMCSPDU) pdu_structure)->u.send_data_request;
			bBufferAllocated = (*encoding_buffer == NULL);
			if (bBufferAllocated) {
				// We have to allocate the encoded buffer.
				DBG_SAVE_FILE_LINE
				memory = AllocateMemory (NULL,
								send_data->user_data.length + MAXIMUM_PROTOCOL_OVERHEAD,
								SEND_PRIORITY);
				if (memory != NULL) {
					buffer_pointer = *encoding_buffer = (LPBYTE) memory->GetPointer();
				}
				else {
					WARNING_OUT (("CMCSCoder::Encode: Failed to allocate space for "
								"encoded data PDU for send."));
					fRet = FALSE;
					ASSERT (*encoding_buffer == NULL);
					goto MyExit;
				}
			}
			else {
				// All the space needed here has been pre-allocated
				buffer_pointer = *encoding_buffer;
			}
		}

		/*
		 *	Check if this is a data PDU
		 */
		if (send_data_pdu)
		{
#ifdef ENABLE_BER
			
			/*
			 * If we are currently using Basic Encoding Rules.
			 */
			if (Encoding_Rules_Type == BASIC_ENCODING_RULES)
			{
				/*
				 * The long variant of length must be used if the octet string
				 * is longer than 127 bytes.  The upper bit of the length byte
				 * is set and the lower bits indicate the number of length bytes 
				 * which will follow.
				 */
				*(buffer_pointer--) = (UChar)send_data->user_data.length;
				if (send_data->user_data.length > 127)
				{
					*(buffer_pointer--) = (UChar)(send_data->user_data.length >> 8);
					*(buffer_pointer--) = TWO_BYTE_LENGTH;
					encoding_length = 3;
				}
				else 
				{
					encoding_length = 1;
				}

				/*
				 * Encode the "user data" octet string.
				 */										
				*(buffer_pointer--) = OCTET_STRING_TAG;

				/*
				 * Encode the "segmentation" bit string field.  The identifier
				 * is followed by a length of 2 and a byte indicating that 6
				 * bits are unused in the actual bit string byte.
				 */
				*(buffer_pointer--) = (UChar) send_data->segmentation;
				*(buffer_pointer--) = 0x06;
				*(buffer_pointer--) = 0x02;
				*(buffer_pointer--) = BIT_STRING_TAG;

				/* 
				 * Encode the enumerated "data priority" field.
				 */
				*(buffer_pointer--) = (UChar)send_data->data_priority;
				*(buffer_pointer--) = 0x01;
				*(buffer_pointer--) = ENUMERATED_TAG;

				/*
				 * Encode the integer "channel ID" field.
				 */
				*(buffer_pointer--) = (UChar)send_data->channel_id;
				if (send_data->channel_id < 128)
				{
					*(buffer_pointer--) = 0x01;
					encoding_length += 10;
				}
				else if (send_data->channel_id < 32768L)
				{
					*(buffer_pointer--) = (UChar)(send_data->channel_id >> 8);
					*(buffer_pointer--) = 0x02;
					encoding_length += 11;
				}
				else
				{
					*(buffer_pointer--) = (UChar)(send_data->channel_id >> 8);
					*(buffer_pointer--) = (UChar)(send_data->channel_id >> 16);
					*(buffer_pointer--) = 0x03;
					encoding_length += 12;
				}
				*(buffer_pointer--) = INTEGER_TAG;

				/*
				 * Encode the integer "initiator" field.
				 */
				*(buffer_pointer--) = (UChar)send_data->initiator;
				*(buffer_pointer--) = (UChar)(send_data->initiator >> 8);
				if (send_data->initiator < 32768L)
				{
					*(buffer_pointer--) = 0x02;
					encoding_length += 4;
				}
				else
				{
					*(buffer_pointer--) = (UChar)(send_data->initiator >> 16);
					*(buffer_pointer--) = 0x03;
					encoding_length += 5;
				}
				*(buffer_pointer--) = INTEGER_TAG;

				*(buffer_pointer--) = INDEFINITE_LENGTH; 
				
				switch (PDUChoice)
				{	
					case SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = SEND_DATA_REQUEST;
						break;
					case SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = SEND_DATA_INDICATION;
						break;
					case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = UNIFORM_SEND_DATA_REQUEST;
						break;
					case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = UNIFORM_SEND_DATA_INDICATION;
						break;
				}

				// Set the returned pointer to the beginning of the encoded packet
				PUChar	temp = *encoding_buffer;
				*encoding_buffer = buffer_pointer;

				/*
				 * Encode the end-of-contents marker for the "Send Data" PDU.
				 * This goes after the data, at the end of the PDU.
				 */
				buffer_pointer = temp + (send_data->user_data.length + 
								(MAXIMUM_PROTOCOL_OVERHEAD_FRONT + 1));
				*(buffer_pointer++) = END_OF_CONTENTS;
				*buffer_pointer = END_OF_CONTENTS;

				// Set the returned length of the encoded packet
				*encoding_buffer_length = 
							encoding_length + send_data->user_data.length + 5;
			}
			/*
			 * If we are currently using Packed Encoding Rules.
			 */
			else
#endif // ENABLE_BER
			{	
				// Move the ptr past the X.224 header.
				buffer_pointer += sizeof(X224_DATA_PACKET);
				
				switch (PDUChoice)
				{
					case SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = PER_SEND_DATA_REQUEST;
						break;
					case SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = PER_SEND_DATA_INDICATION;
						break;
					case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = PER_UNIFORM_SEND_DATA_REQUEST;
						break;
					case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = PER_UNIFORM_SEND_DATA_INDICATION;
						break;
				}
				buffer_pointer++;

				/*
				 * Encode the integer "initiator" field.  The lower bound must
				 * first be subtracted from the value to encode.
				 */
				initiator = send_data->initiator - INITIATOR_LOWER_BOUND;
				*(buffer_pointer++) = (UChar) (initiator >> 8);
				*(buffer_pointer++) = (UChar) initiator;

				/*
				 * Encode the integer "channel ID" field.
				 */
				*(buffer_pointer++) = (UChar)(send_data->channel_id >> 8);
				*(buffer_pointer++) = (UChar)(send_data->channel_id);

				/*
				 * Encode the "priority" and "segmentation" fields.
				 */
				*(buffer_pointer++) = (UChar)((send_data->data_priority << 6) |
										(send_data->segmentation >> 2));
				
				/* 
				 * Encode the "user data" octet string.  The octet strings are
				 * encoded differently depending upon their length.
				 */
				ASSERT (send_data->user_data.length < 16384);

				if (send_data->user_data.length <= 127)
				{
					*encoding_buffer_length = MAXIMUM_PROTOCOL_OVERHEAD - 1;
				}
				else
				{
					*(buffer_pointer++) = (UChar)(send_data->user_data.length >> 8) | 
											INDEFINITE_LENGTH;
					*encoding_buffer_length = MAXIMUM_PROTOCOL_OVERHEAD;
				}
				*buffer_pointer++ = (UChar)send_data->user_data.length;

				initiator = (UShort) (*encoding_buffer_length + send_data->user_data.length);
				
				// Set the returned length of the encoded PDU.
				if (bBufferAllocated || (send_data->segmentation & SEGMENTATION_BEGIN)) {
					/*
					 *	If the Encode operation allocates the space needed, or the space
					 *	was allocated by MCSGetBufferRequest (by a client) and this is
					 *	the 1st segment of the data in the buffer, the whole encoded PDU
					 *	is in contiguous space.  The total PDU size is returned in this
					 *	case.
					 *	However, in the case where the space was allocated by MCSGetBufferRequest,
					 *	the PDUs after the 1st one, will put the X.224 and MCS headers in 
					 *	a separate piece of memory (whose length is returned here), and the
					 *	data is still in the pre-allocated space.
					 */
					*encoding_buffer_length = (UINT) initiator;
				}

				/*
				 *	If the space was not preallocated, we need to copy the data
				 *	into the space allocated by the encoder.
				 */
				if (bBufferAllocated) {
					// We now need to copy the data into the encoded data PDU.
					memcpy (buffer_pointer, send_data->user_data.value,
							send_data->user_data.length);
					// Update the data ptr in the data packet
					send_data->user_data.value = (ASN1octet_t *) buffer_pointer;
				}
			}
		}
	}

	if (send_data_pdu == FALSE)
	{
		SetEncodingRules (rules_type);
		return_value = ASN1_Encode(m_pEncInfo,	// ptr to encoder info
									 pdu_structure,	// pdu data structure
									 pdu_type,		// pdu id
									 ASN1ENCODE_ALLOCATEBUFFER, // flags
									 NULL,			// do not provide buffer
									 0);			// buffer size if provided
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CMCSCoder::Encode: ASN1_Encode failed, err=%d", return_value));
			ASSERT(FALSE);
			fRet = FALSE;
			goto MyExit;
		}
		ASSERT(return_value == ASN1_SUCCESS);
		/*
		 *	The encoded buffers returned by ASN.1 have preallocated the space
		 *	needed for the X.224 header.
		 */
		// len of encoded data in buffer
		*encoding_buffer_length = m_pEncInfo->len;
		initiator = (UShort) *encoding_buffer_length;
		// buffer to encode into
		*encoding_buffer = m_pEncInfo->buf;
	}

	// Now, add the X.224 header
	buffer_pointer = *encoding_buffer;
	memcpy (buffer_pointer, g_X224Header, PROTOCOL_OVERHEAD_X224);
	AddRFCSize (buffer_pointer, initiator);

MyExit:

	return fRet;
}

/*
 *	void 	Decode ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate MCS PDU structures using the ASN.1 toolkit.
 *
 *	NOTE: For data PDUs, do NOT access pdecoding_buffer_length. It's set
 *			to NULL.
 */
BOOL	CMCSCoder::Decode(LPBYTE			encoded_buffer,
							UINT			encoded_buffer_length,
							int				pdu_type,
							UINT			rules_type,
							LPVOID			*pdecoding_buffer,
							UINT			*pdecoding_buffer_length)
{
	BOOL				fRet = TRUE;
	BOOL				send_data_pdu = FALSE;
    ASN1optionparam_s   OptParam;

	/*
	 * Check to make sure the encoding rules type is properly set.
	 */
	ASSERT(rules_type == PACKED_ENCODING_RULES || pdu_type == CONNECT_MCS_PDU);

	if (pdu_type == DOMAIN_MCS_PDU)
	{
			UChar					length;
			unsigned int			short_data;
			PUChar					buffer_pointer;
			PSendDataRequestPDU		send_data;
			PDomainMCSPDU			decoding_pdu;
			ASN1choice_t			choice;
			
		buffer_pointer = encoded_buffer;
		
#ifdef ENABLE_BER
		/*
		 * If we are currently using Basic Encoding Rules.
		 */
		if (Encoding_Rules_Type == BASIC_ENCODING_RULES)
		{
			switch (*(buffer_pointer++))
			{
				case SEND_DATA_REQUEST:
					((PDomainMCSPDU) decoding_buffer)->choice =
							SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case SEND_DATA_INDICATION:
					((PDomainMCSPDU) decoding_buffer)->choice =
							SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case UNIFORM_SEND_DATA_REQUEST:
					((PDomainMCSPDU) decoding_buffer)->choice =
							UNIFORM_SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case UNIFORM_SEND_DATA_INDICATION:
					((PDomainMCSPDU) decoding_buffer)->choice =
							UNIFORM_SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;
			}

			if (send_data_pdu )
			{
				/*
				 * Get the pointer to the "Send Data" PDU.
				 */
				send_data = &((PDomainMCSPDU) decoding_buffer)->
												u.send_data_request;

				/*
				 * Retrieve one byte for the length and check to see which 
				 * length variant is being used.  If the long variant is being 
				 * used, move the buffer pointer past the length and set the 
				 * flag indicating that the indefinite length is not being used.
				 */
				length = *buffer_pointer;

				switch (length)
				{
					case ONE_BYTE_LENGTH: 
							buffer_pointer += 3;
							break;
					case TWO_BYTE_LENGTH: 
							buffer_pointer += 4;
							break;		
					case THREE_BYTE_LENGTH:
							buffer_pointer += 5;
							break;
					case FOUR_BYTE_LENGTH:
							buffer_pointer += 6;
							break;
					default:
							buffer_pointer += 2;
				}

				/*
				 * Decode the integer "initiator" field.  Increment the data 
				 * pointer past the integer identifier and retrieve the length 
				 * of the integer.
				 */
				length = *(buffer_pointer++);

				ASSERT ((length == 1) || (length == 2));
				if (length == 1)
					send_data->initiator = (UserID) *(buffer_pointer++);
				else if (length == 2)
				{
					send_data->initiator = ((UserID) *(buffer_pointer++)) << 8;
					send_data->initiator |= (UserID) *(buffer_pointer++);
				}
				else 
				{
					TRACE_OUT(("CMCSCoder::Decode: initiator field is longer than 2 bytes (%d bytes) in MCS Data packet.",  (UINT) length));
				}

				/*
				 * Decode the integer "channel ID" field.  Increment the data 
				 * pointer past the integer identifier and retrieve the length 
				 * of the integer.
				 */
				buffer_pointer++;
				length = *(buffer_pointer++);

				ASSERT ((length == 1) || (length == 2));
				if (length == 1)
					send_data->channel_id = (ChannelID) *(buffer_pointer++);
				else if (length == 2)
				{
					send_data->channel_id = ((ChannelID) *buffer_pointer++) << 8;
					send_data->channel_id |= (ChannelID) *(buffer_pointer++);
				}
				else 
				{
					TRACE_OUT(("CMCSCoder::Decode: channel_id field is longer than 2 bytes (%d bytes) in MCS Data packet.", (UINT) length));
				}

				/*
				 * Decode the enumerated "data priority" field.  Increment the
				 * data pointer past the identifier and length.
				 */
				buffer_pointer+=2;
				send_data->data_priority =(PDUPriority)*buffer_pointer;

				/*
				 * Decode the bit string "segmentation" field.  Increment the 
				 * data pointer past the bit string identifier, length, and the 
				 * "unused bits" byte and retrieve the "segmentation" flag.
				 */
				buffer_pointer += 4;
				send_data->segmentation = *buffer_pointer;

				/*
				 * Decode the "user data" octet string.	 Increment the data 
				 * pointer past the identifier.
				 */
				buffer_pointer += 2;

				/*
				 * Check to see which variant of the length is being used and
				 * then retrieve the length.
				 */
				length = *(buffer_pointer++);

				if (length & INDEFINITE_LENGTH)
				{
					if (length == ONE_BYTE_LENGTH)
						send_data->user_data.length = (unsigned int) *(buffer_pointer++);
					/*
					 * A length identifier of 0x82 indicates that two bytes are
					 * being used to hold the actual length so retrieve the two
					 * bytes to form the length.
					 */
					else if (length == TWO_BYTE_LENGTH)
					{
						send_data->user_data.length = 
								((unsigned int) *(buffer_pointer++)) << 8;
						send_data->user_data.length |= 
								(unsigned int) *(buffer_pointer++);
					}
				}
				else
					send_data->user_data.length = (unsigned int) length;

				// buffer_pointer now points to the 1st data byte
				send_data->user_data.value = buffer_pointer;
				*pulDataOffset = buffer_pointer - encoded_buffer;
			}
		}
		/*
		 * If we are currently using Packed Encoding Rules.
		 */
		else
#endif // ENABLE_BER
		{
			switch (*(buffer_pointer++))
			{
				case PER_SEND_DATA_REQUEST:
					choice = SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case PER_SEND_DATA_INDICATION:
					choice = SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case PER_UNIFORM_SEND_DATA_REQUEST:
					choice = UNIFORM_SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case PER_UNIFORM_SEND_DATA_INDICATION:
					choice = UNIFORM_SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;
			}

			if (send_data_pdu)
			{
				decoding_pdu = (PDomainMCSPDU) pdecoding_buffer; 

				// Store the choice field
				decoding_pdu->choice = choice;
				/*
				 * Get the pointer to the "Send Data" PDU.
				 */
				send_data = &decoding_pdu->u.send_data_request;

				/*
				 * Decode the integer "initiator" field.
				 */
				short_data = ((unsigned int) *(buffer_pointer++)) << 8;
				short_data |= (unsigned int) *(buffer_pointer++);
				send_data->initiator = (UserID) short_data + INITIATOR_LOWER_BOUND;

				/*
				 * Decode the integer "channel ID" field. 
				 */
				send_data->channel_id = ((ChannelID) *(buffer_pointer++)) << 8;
				send_data->channel_id |= (ChannelID) *(buffer_pointer++);

				/*
				 * Decode the enumerated "data priority" field and the
				 * "segmentation" field.
				 */
				send_data->data_priority = 
						(PDUPriority)((*buffer_pointer >> 6) & 0x03);
				send_data->segmentation = (*(buffer_pointer++) << 2) & 0xc0; 

				/*
				 * Decode the "user data" octet string.	 Check to see which 
				 * variant of the length is being used and then retrieve the 
				 * length.
				 */
				length = *(buffer_pointer++);

				if (length & INDEFINITE_LENGTH)
				{
					ASSERT ((length & 0x40) == 0);
					
					/*
					 * If bit 7 is set the length is greater than 127 but
					 * less than 16K.
					 *
					 *	ChristTs: We no longer handle the case where the data length
					 *	was higher than 16K. Our Max PDU size is 4K.
					 */
					short_data = (unsigned int) ((length & 0x3f) << 8);
					send_data->user_data.length = 
								short_data | ((unsigned int) *(buffer_pointer++));
				}
				/*
				 * If bit 7 is not set then the length is less than 128 and is
				 * contained in the retrieved byte.
				 */
				else
				{
					send_data->user_data.length = (UShort) length;
				}

				// buffer_pointer now points to the 1st data byte
				send_data->user_data.value = buffer_pointer;
			}
		}
	}
	
	if (send_data_pdu == FALSE)
	{
		int 	return_value;
		//void	*pDecodedData;

		SetEncodingRules (rules_type);

		return_value = ASN1_Decode(m_pDecInfo,// ptr to decoder info
							pdecoding_buffer,		// destination buffer
							pdu_type,				// pdu type
							ASN1DECODE_SETBUFFER,	// flags
							encoded_buffer,			// source buffer
							encoded_buffer_length);	// source buffer size
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CMCSCoder::Decode: ASN1_Decode failed, err=%d", return_value));
			ASSERT(FALSE);
			fRet = FALSE;
			goto MyExit;
		}

        OptParam.eOption = ASN1OPT_GET_DECODED_BUFFER_SIZE;
		return_value = ASN1_GetDecoderOption(m_pDecInfo, &OptParam);
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CMCSCoder::Decode: ASN1_GetDecoderOption failed, err=%d", return_value));
			ASSERT(FALSE);
			fRet = FALSE;
			goto MyExit;
		}
        *pdecoding_buffer_length = OptParam.cbRequiredDecodedBufSize;

		ASSERT((return_value == ASN1_SUCCESS) && (*pdecoding_buffer_length > 0));
	}

MyExit:

	return fRet;
}

/*
 *	PacketCoderError	ReverseDirection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is used to convert data request PDU's into data indication
 *		PDU's and vice versa.
 */
Void CMCSCoder::ReverseDirection (LPBYTE	encoded_buffer)
{
	encoded_buffer += PROTOCOL_OVERHEAD_X224;
	switch (*encoded_buffer)
	{
		case PER_SEND_DATA_REQUEST:
			*encoded_buffer = PER_SEND_DATA_INDICATION;
			break;

		case PER_SEND_DATA_INDICATION:
			*encoded_buffer = PER_SEND_DATA_REQUEST;
			break;

		case PER_UNIFORM_SEND_DATA_REQUEST:
			*encoded_buffer = PER_UNIFORM_SEND_DATA_INDICATION;
			break;

		case PER_UNIFORM_SEND_DATA_INDICATION:
			*encoded_buffer = PER_UNIFORM_SEND_DATA_REQUEST;
			break;
		default:
			ASSERT (FALSE);
			break;
	}
}

/*
 *	void	SetEncodingRules ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to set the type (basic or packed) of encoding
 *		rules to be used.
 */
void CMCSCoder::SetEncodingRules (UINT	rules_type)
{
	/*
	 * If the rules type is changing, set our rules instance variable and reset
	 * the variables which hold the amount of overhead associated with the
	 * "SendData" PDU's.
	 */
	Encoding_Rules_Type = rules_type;
}

/*
 *	BOOL	IsMCSDataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Return value:
 *		TRUE, if the packet is an MCS Data packet. FALSE, otherwise.
 */
BOOL CMCSCoder::IsMCSDataPacket(LPBYTE encoded_buffer, UINT rules_type)
{
	UChar		identifier;

	/*
	 * Retrieve the identifier from the encoded data.
	 */
	identifier = *encoded_buffer;

	if (rules_type == BASIC_ENCODING_RULES)
	{
		if (	(identifier == SEND_DATA_REQUEST) || 
				(identifier == SEND_DATA_INDICATION) || 
				(identifier == UNIFORM_SEND_DATA_REQUEST) || 
				(identifier == UNIFORM_SEND_DATA_INDICATION))
		{
			return TRUE;
		}
	}
	else
	{
		if (	(identifier == PER_SEND_DATA_REQUEST) || 
				(identifier == PER_SEND_DATA_INDICATION) || 
				(identifier == PER_UNIFORM_SEND_DATA_REQUEST) || 
				(identifier == PER_UNIFORM_SEND_DATA_INDICATION))
		{
			return TRUE;
		}
	}

	return FALSE;
}


void CMCSCoder::FreeEncoded(LPBYTE encoded_buffer)
{
    ASN1_FreeEncoded(m_pEncInfo, encoded_buffer);
}

void CMCSCoder::FreeDecoded (int pdu_type, LPVOID decoded_buffer)
{
    ASN1_FreeDecoded(m_pDecInfo, decoded_buffer, pdu_type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\pktcoder.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC | ZONE_T120_GCCNC);
/*
 *	pktcoder.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the PacketCoder class.
 *
 *	Private Instance Variables:
 *		None.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 */

/*
 *	External Interfaces
 */

#include "pktcoder.h"


/*
 *	~PacketCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is virtual destructor that does not do anything at this time.
 */
PacketCoder::~PacketCoder ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\precomp.h ===
#define INC_OLE2
#define IDS_NULL_STRING			(0)
#include <windows.h>
#include <tchar.h>
#include <ocidl.h>
#include <time.h>

// MCSNC includes
#include <databeam.h>

#include <confdbg.h>
#include <debspew.h>
#include <oblist.h>
#include <memtrack.h>
#include <strutil.h>
#include <cstring.hpp>

// end MCSNC includes

extern "C"
{
#include <t120.h>
}
#include <memmgr.h>
#include <mcattprt.h>
#include <ncmcs.h>
#include <debspew.h>
#include <it120nc.h>

#include "fclasses.h"

#include "cntlist.h"
#include "clists.h"
#include "ms_util.h"
#include <fsdiag.h>

#include <spacket.h>
#include <packet.h>
#include <datapkt.h>
#include <cmdtar.h>
#include <attmnt.h>
#include <channel.h>
#include <tptif.h>
#include <domain.h>
#include <connect.h>
#include <tprtctrl.h>
#include <user.h>
#include <control.h>

#include "pdutypes.h"

#include "imsconf3.h"
#include "global.h"
#include "refcount.h"
#include "connpnts.h"
#include "imember.h"
#include "iconf.h"
#include "ichnldat.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\privchnl.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	privchnl.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the PrivateChannel class.  It
 *		contains the code that distinguishes this class from that of its parent,
 *		Channel.
 *
 *		This class maintains an authorized user list, and includes the code
 *		necessary to use that list.  No user will be allowed to join or send
 *		data on a private channel unless they are either the channel manager
 *		or an admitted user.
 *
 *	Private Instance Variables:
 *		m_uidChannelManager
 *			This is the User ID of the user that convened the private channel.
 *			Only this user is allowed to manipulate the authorized user list.
 *			When a private channel becomes invalid (as the result of a channel
 *			disband request or indication), this value will be set to 0.
 *		m_AuthorizedUserList
 *			This is a collection containing the user IDs of those users that
 *			have been admitted to the private channel by the channel manager.
 *			Other than the manager, these are the only users that are allowed
 *			to join or send data on the channel.  When a private channel becomes
 *			invalid (as the result of a channel disband request or indication),
 *			this list will be cleared.
 *		m_fDisbandRequestPending
 *			This is a boolean flag that gets set when a disband request is
 *			forwarded upward to the top provider.  This prevents this channel
 *			from issuing a disband indication to the channel manager when it
 *			comes back down the tree from the top provider.
 *
 *	Private Member Functions:
 *		ValidateUserID
 *			This member function is called to verify that a specified user ID
 *			corresponds to a valid user in the sub-tree of the local provider.
 *		BuildAttachmentLists
 *			This member function is called to build two lists of attachments
 *			from a master user ID list.  The first list contains all local
 *			attachments whose user ID is in the specified list.  The second
 *			list contains all remote attachments whose user ID is in the
 *			specified list.  These lists are used to issue various indications
 *			to specified users without sending any to the same attachment.
 *		BuildUserIDList
 *			This member function is called to build a list of users that lie
 *			in the direction of a specified attachment.  These lists are
 *			sent along with PDUs that require them.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include "privchnl.h"


/*
 *	PrivateChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the primary constructor for PrivateChannel objects.  It creates
 *		an object with all instance variable initialized, but with no
 *		attachments (i.e. no users are joined to the channel automatically).
 *
 *		Note that most instance variable initialization is done by invoking the
 *		equivalent constructor in the base class.
 *
 *		Upon successful completion, a  channel convene confirm is automatically
 *		issued to the channel manager, if the channel manager is in the sub-tree
 *		of this provider.  Note that if the channel manager is NOT in this
 *		sub-tree, then this private channel object was probably created as the
 *		result of a channel admit indication, and no channel convene confirm
 *		will be issued.
 */
PrivateChannel::PrivateChannel (
		ChannelID			channel_id,
		UserID				channel_manager,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list)
:
	Channel(channel_id, local_provider, top_provider, channel_list, attachment_list),
	m_AuthorizedUserList(),
	m_uidChannelManager(channel_manager),
	m_fDisbandRequestPending(FALSE)
{
	/*
	 *	Check to see if the channel manager lies in the sub-tree of this
	 *	provider.  If so, then this object was created as the result of a
	 *	channel convene request or confirm, and it is necessary to issue the
	 *	confirm toward that user.  If not, then this object was created as the
	 *	result of a channel admit indication, and it is not necessary to send
	 *	the channel convene confirm.
	 */
	if (ValidateUserID(m_uidChannelManager))
	{
		PChannel	lpChannel;
		/*
		 *	Determine which attachment leads to the channel manager by asking
		 *	the channel object corresponding to it.  Then issue the confirm
		 *	to that attachment.
		 */
		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
		{
		    CAttachment *pAtt = lpChannel->GetAttachment();
		    if (pAtt)
		    {
    		    pAtt->ChannelConveneConfirm(RESULT_SUCCESSFUL,
    		                                m_uidChannelManager, channel_id);
            }
            else
            {
                ERROR_OUT(("PrivateChannel::PrivateChannel: null attachment"));
            }
		}
	}
}

/*
 *	PrivateChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a secondary constructor that is only used during merge
 *		operations.  The intent of this constructor is to create an equivalent
 *		object without issuing any of the confirms.
 *
 *		Note that the additional constructor allows for the creator to specify
 *		that there is an attachment already joined to the channel upon creation.
 */
PrivateChannel::PrivateChannel (
		ChannelID			channel_id,
		UserID				channel_manager,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list,
		CUidList           *admitted_list,
		PConnection         pConn)
:
	Channel(channel_id, local_provider, top_provider, channel_list, attachment_list, pConn),
	m_AuthorizedUserList(),
	m_uidChannelManager(channel_manager),
	m_fDisbandRequestPending(FALSE)
{
	UserID		uid;

	/*
	 *	Copy the initial contents of the admitted list into the authorized
	 *	user list.
	 */
	admitted_list->Reset();
	while (NULL != (uid = admitted_list->Iterate()))
	{
		m_AuthorizedUserList.Append(uid);
	}
}

/*
 *	~PrivateChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This destructor walks through the admitted list, sending expel
 *		indications to any admitted users that are locally attached.  If the
 *		channel manager is locally attached, and this channel is being deleted
 *		a reason other than a previous disband request, then a disband
 *		indication will be sent to the channel manager.
 */
PrivateChannel::~PrivateChannel ()
{
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList                user_id_list;

	/*
	 *	Assemble lists of the attachments that lead to authorized users in
	 *	the sub-tree of this provider.
	 */
	BuildAttachmentLists (&m_AuthorizedUserList, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	For each local attachment, issue a channel expel indication letting the
	 *	user know that the channel is no longer valid.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of the users
		 *	that lie in the direction of that attachment.
		 */
		BuildUserIDList(&m_AuthorizedUserList, pAtt, &user_id_list);

		/*
		 *	Send the indication.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_list);
	}

	/*
	 *	If the channel manager is a locally attached user, then send it a
	 *	ChannelDisbandIndication informing it that the channel is no longer
	 *	valid.
	 */
	if ((m_fDisbandRequestPending == FALSE) && ValidateUserID(m_uidChannelManager))
	{
		PChannel		lpChannel;

		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
		{
    		CAttachment *pAtt = lpChannel->GetAttachment();
    		if (m_pAttachmentList->Find(pAtt) && pAtt->IsUserAttachment())
    		{
    		    PUser pUser = (PUser) pAtt;
    			pUser->ChannelDisbandIndication(Channel_ID);
    	    }
    	}
	}

	/*
	 *	Clear the lists associated with this object.  Note that this also
	 *	prevents the base class destructor from issuing ChannelLeaveIndications
	 *	to any local attachments in the joined attachment list (which would be
	 *	inappropriate).
	 */
	m_AuthorizedUserList.Clear();
	m_JoinedAttachmentList.Clear();
}

/*
 *	Channel_Type		GetChannelType ()
 *
 *	Public
 *
 *	Functional Description:
 *		Objects of this class are always private channels, so simply return
 *		PRIVATE_CHANNEL.
 */
Channel_Type		PrivateChannel::GetChannelType ()
{
	return (PRIVATE_CHANNEL);
}

/*
 *	BOOL    IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		By convention, if the m_uidChannelManager is in the sub-tree of this
 *		provider OR if there are any users in the authorized user list, then
 *		the private channel is valid.  Otherwise it is not, and can be deleted
 *		by the domain object.
 */
BOOL    PrivateChannel::IsValid ()
{
	UserID			uid;
	CUidList		deletion_list;

	/*
	 *	Loop through the authorized user list making a list of those entries
	 *	that are no longer valid.
	 */
	m_AuthorizedUserList.Reset();
	while (NULL != (uid = m_AuthorizedUserList.Iterate()))
	{
		if (ValidateUserID(uid) == FALSE)
			deletion_list.Append(uid);
	}

	/*
	 *	Loop through the deletion list created above, deleting those user IDs
	 *	that are no longer valid.
	 */
	deletion_list.Reset();
	while (NULL != (uid = deletion_list.Iterate()))
	{
		m_AuthorizedUserList.Remove(uid);
	}

	/*
	 *	If this is the Top Provider, then the channel manager should ALWAYS be
	 *	in the sub-tree.  If it is not, then this indicates that the channel
	 *	manager has detached (willingly or otherwise).  When this happens it
	 *	is necessary to simulate a channel disband request (only if there are
	 *	other admitted users who need to receive a channel expel indication).
	 */
	if ((m_pConnToTopProvider == NULL) &&
			(ValidateUserID(m_uidChannelManager) == FALSE) &&
			(m_AuthorizedUserList.IsEmpty() == FALSE))
	{
		TRACE_OUT (("PrivateChannel::IsValid: "
				"simulating ChannelDisbandRequest"));
		ChannelDisbandRequest(NULL, m_uidChannelManager, Channel_ID);
	}

	/*
	 *	Check to see if the channel manager is in the sub-tree of this provider
	 *	or if the authorized user list is not empty.  If either is TRUE, then
	 *	then the channel is still valid.
	 */
	return (ValidateUserID(m_uidChannelManager) || (m_AuthorizedUserList.IsEmpty() == FALSE));
}

/*
 *	CAttachment *GetAttachment ()
 *
 *	Public
 *
 *	Functional Description:
 *		Return a pointer to the attachment leading to the channel manager.
 */
CAttachment *PrivateChannel::GetAttachment(void)
{
	if (ValidateUserID(m_uidChannelManager))
    {
		PChannel	lpChannel;
		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
		{
            return lpChannel->GetAttachment();
        }
	}
	return NULL;
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		Issue a merge request for the information contained in this
 *		PrivateChannel object.
 */
Void	PrivateChannel::IssueMergeRequest ()
{
	ChannelAttributes		channel_attributes;
	CChannelAttributesList	merge_channel_list;
	CChannelIDList			purge_channel_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Fill in the fields of the channel attributes structure so that it
		 *	accurately describes this channel.  Then put the structure into the
		 *	merge channel list.
		 */
		channel_attributes.channel_type = PRIVATE_CHANNEL;
		if (m_JoinedAttachmentList.IsEmpty() )
			channel_attributes.u.private_channel_attributes.joined = FALSE;
		else
			channel_attributes.u.private_channel_attributes.joined = TRUE;
		channel_attributes.u.private_channel_attributes.channel_id = Channel_ID;
		channel_attributes.u.private_channel_attributes.channel_manager = m_uidChannelManager;
		channel_attributes.u.private_channel_attributes.admitted_list =	&m_AuthorizedUserList;

		merge_channel_list.Append(&channel_attributes);

		/*
		 *	Send the merge request to the indicated provider.
		 */
		m_pConnToTopProvider->MergeChannelsRequest(&merge_channel_list, &purge_channel_list);
	}
}

/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function overrides the base class implementation.  The main
 *		difference is that this implementation only allows a user to join
 *		the private channel if it is either the channel manager or in the
 *		authorized user list.
 */
Void	PrivateChannel::ChannelJoinRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	/*
	 *	See if the requesting user is either the channel manager or in the
	 *	authorized user list.
	 */
	if ((uidInitiator == m_uidChannelManager) || m_AuthorizedUserList.Find(uidInitiator))
	{
		/*
		 *	See if anyone is currently joined to the channel in this sub-tree
		 */
		if (m_JoinedAttachmentList.IsEmpty())
		{
			/*
			 *	If this is the Top Provider, then this request can be handled
			 *	locally.
			 */
			if (IsTopProvider())
			{
				/*
				 *	There is no one in this sub-tree joined to the channel.  It
				 *	will therefore be necessary to add the originator to the
				 *	attachment list.
				 */
				TRACE_OUT (("PrivateChannel::ChannelJoinRequest: "
						"user %04X joining private channel = %04X",
						(UINT) uidInitiator, (UINT) Channel_ID));
				m_JoinedAttachmentList.Append(pOrigAtt);

				/*
				 *	Send a ChannelJoinConfirm downward to the originator.
				 */
				pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the join request
				 *	upward to the Top Provider.
				 */
				TRACE_OUT (("PrivateChannel::ChannelJoinRequest: "
						"forwarding join request to Top Provider"));
				m_pConnToTopProvider->ChannelJoinRequest(uidInitiator, Channel_ID);
			}
		}

		/*
		 *	There is at least one attachment joined to the channel, which means
		 *	that we do not have to forward the join request upward (even if
		 *	this is not the Top Provider).  Now check to see if the requesting
		 *	originator is already joined to the channel.
		 */
		else if (m_JoinedAttachmentList.Find(pOrigAtt) == FALSE)
		{
			/*
			 *	The originator is not yet joined to the channel, so add it to
			 *	the channel.
			 */
			TRACE_OUT (("PrivateChannel::ChannelJoinRequest: "
					"user %04X joining private channel = %04X",
					(UINT) uidInitiator, (UINT) Channel_ID));
			m_JoinedAttachmentList.Append(pOrigAtt);

			/*
			 *	Send a ChannelJoinConfirm downward to the originator.
			 */
			pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
		}

		else
		{
			/*
			 *	The originator is already joined to the channel.  Go ahead and
			 *	issue a successful channel join confirm.
			 */
			WARNING_OUT (("PrivateChannel::ChannelJoinRequest: "
					"already joined to channel"));
			pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
		}
	}
	else
	{
		/*
		 *	Someone is trying to join a private channel that they are not
		 *	admitted to.  Reject the request without further processing.
		 */
		WARNING_OUT (("PrivateChannel::ChannelJoinRequest: "
				"rejecting attempt to join private channel"));
		pOrigAtt->ChannelJoinConfirm(RESULT_NOT_ADMITTED, uidInitiator, channel_id, 0);
	}
}

/*
 *	Void	ChannelDisbandRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user that wishes to disband a
 *		private channel that it previously created.  If the requesting user is
 *		the private channel manager, then the request will be processed.  If
 *		this is not the Top Provider, the request will be forwarded upward.
 */
Void	PrivateChannel::ChannelDisbandRequest (
				CAttachment *,
				UserID				uidInitiator,
				ChannelID)
{
	CUidList				user_id_list;

	/*
	 *	Check to see if the requesting user is the channel manager.  Only
	 *	process the request if it is.
	 */
	if (uidInitiator == m_uidChannelManager)
	{
		/*
		 *	See if this is the Top Provider.  If it is, then the request can
		 *	be processed locally.  Otherwise, pass the request upward toward
		 *	the Top Provider.
		 */
		if (IsTopProvider())
		{
        	CAttachmentList     local_attachment_list;
        	CAttachmentList     remote_attachment_list;
        	CAttachment        *pAtt;

			TRACE_OUT (("PrivateChannel::ChannelDisbandRequest: "
					"disbanding channel = %04X", Channel_ID));

			/*
			 *	Go construct lists of the current unique local and remote
			 *	attachments.  These lists will be used to transmit the proper
			 *	channel expel and channel disband indications.
			 */
			BuildAttachmentLists (&m_AuthorizedUserList, &local_attachment_list,
					&remote_attachment_list);

			/*
			 *	It is also necessary to send the disband indication to the
			 *	channel manager, if it is valid and in the sub-tree of this
			 *	provider.  Determine what attachment leads to the channel
			 *	manager, and make sure that attachment is in the remote
			 *	attachment list, if valid.
			 */
			if (ValidateUserID(m_uidChannelManager))
			{
				PChannel		lpChannel;
				if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
                {
				    pAtt = lpChannel->GetAttachment();
				    if (m_pAttachmentList->Find(pAtt) && pAtt->IsConnAttachment())
				    {
					    if (remote_attachment_list.Find(pAtt) == FALSE)
					    {
						    remote_attachment_list.Append(pAtt);
						}
				    }
                }
                else
                {
                    ERROR_OUT(("PrivateChannel::ChannelDisbandRequest: can't locate channel"));
                }
			}

			/*
			 *	Loop through the local attachment list sending channel expel
			 *	indications to each attachment contained therein.
			 */
			local_attachment_list.Reset();
			while (NULL != (pAtt = local_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&m_AuthorizedUserList, pAtt, &user_id_list);

				/*
				 *	Send the expel indication to the locally attached user.
				 */
				pAtt->ChannelExpelIndication(Channel_ID, &user_id_list);
			}

			/*
			 *	Loop through the remote attachment list sending channel disband
			 *	indications to each attachment contained therein.
			 */
			remote_attachment_list.Reset();
			while (NULL != (pAtt = remote_attachment_list.Iterate()))
			{
				/*
				 *	Send the disband indication to the remotely attached
				 *	provider.
				 */
				pAtt->ChannelDisbandIndication(Channel_ID);
			}

			/*
			 *	Set m_uidChannelManager to 0 and clear the authorized user list as
			 *	an indicator that this private channel object is no longer
			 *	valid, and cannot be used.  The next time the domain object
			 *	calls IsValid, it will return FALSE allowing the domain object
			 *	to delete this object.
			 */
			m_uidChannelManager = 0;
			m_AuthorizedUserList.Clear();
		}
		else
		{
			/*
			 *	Set a flag indicating that a disband request has been sent
			 *	upward.  This flag will be used to prevent a disband indication
			 *	from being sent to the channel manager as it flows back down
			 *	the domain tree.
			 */
			m_fDisbandRequestPending = TRUE;

			/*
			 *	This is not the Top Provider, so forward the request toward
			 *	the Top Provider.  This will result in a channel disband
			 *	indication at a future time.
			 */
			TRACE_OUT (("PrivateChannel::ChannelDisbandRequest: "
					"forwarding request to Top Provider"));
			m_pConnToTopProvider->ChannelDisbandRequest(uidInitiator, Channel_ID);
		}
	}
	else
	{
		/*
		 *	Someone is trying to disband a private channel that they are not
		 *	the channel manager for.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::ChannelDisbandRequest: "
				"ignoring request from non-channel manager"));
	}
}

/*
 *	Void	ChannelDisbandIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it decides
 *		to delete a private channel from the domain.  It travels downward to
 *		all attachments and connections that contain an admitted user or the
 *		channel manager in their sub-tree.
 */
Void	PrivateChannel::ChannelDisbandIndication (
				ChannelID)
{
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList				user_id_list;

	TRACE_OUT (("PrivateChannel::ChannelDisbandIndication: "
			"disbanding channel = %04X", Channel_ID));

	/*
	 *	Build the lists of unique local and remote attachments.  These lists
	 *	will be used to issue the appropriate indications.
	 */
	BuildAttachmentLists (&m_AuthorizedUserList, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	It is also necessary to send the disband indication to the channel
	 *	manager, if it is valid and in the sub-tree of this provider.
	 *	Determine what attachment leads to the channel manager, and make sure
	 *	that attachment is in the remote attachment list, if valid.
	 */
	if (ValidateUserID(m_uidChannelManager))
	{
		PChannel		lpChannel;
		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
        {
		    pAtt = lpChannel->GetAttachment();
		    if ((m_fDisbandRequestPending == FALSE) ||
			    (m_pAttachmentList->Find(pAtt) && pAtt->IsConnAttachment()))
			{
			    if (remote_attachment_list.Find(pAtt) == FALSE)
			    {
				    remote_attachment_list.Append(pAtt);
				}
		    }
        }
        else
        {
            ERROR_OUT(("PrivateChannel::ChannelDisbandIndication: can't locate channel"));
        }
    }

	/*
	 *	Loop through the local attachment list sending channel expel indications
	 *	to each attachment contained therein.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&m_AuthorizedUserList, pAtt, &user_id_list);

		/*
		 *	Send the expel indication to the locally attached user.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_list);
	}

	/*
	 *	Loop through the remote attachment list sending channel disband
	 *	indications to each attachment contained therein.
	 */
	remote_attachment_list.Reset();
	while (NULL != (pAtt = remote_attachment_list.Iterate()))
	{
		/*
		 *	Send the disband indication to the remotely attached provider.
		 */
		pAtt->ChannelDisbandIndication(Channel_ID);
	}

	/*
	 *	Set m_uidChannelManager to 0 and clear the authorized user list as an
	 *	indicator that this private channel object is no longer valid, and
	 *	cannot be used.  The next time the domain object calls IsValid, it will
	 *	return FALSE allowing the domain object to delete this object.
	 */
	m_uidChannelManager = 0;
	m_AuthorizedUserList.Clear();
}

/*
 *	Void	ChannelAdmitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the manager of a private channel
 *		when it wishes to expand the authorized user list of that channel.  If
 *		this is the Top Provider, then the request can be handled locally.
 *		Otherwise, it must be forwarded upward to the Top Provider.
 */
Void	PrivateChannel::ChannelAdmitRequest (
				CAttachment *,
				UserID				uidInitiator,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID					uid;
	CUidList				admitted_id_list;
	CUidList				user_id_subset;

	/*
	 *	Check to see if the requesting user is the channel manager.  Only
	 *	process the request if it is.
	 */
	if (uidInitiator == m_uidChannelManager)
	{
		/*
		 *	See if this is the Top Provider.  If it is, then the request can
		 *	be processed locally.  Otherwise, pass the request upward toward
		 *	the Top Provider.
		 */
		if (IsTopProvider())
		{
        	CAttachmentList     local_attachment_list;
        	CAttachmentList     remote_attachment_list;
        	CAttachment        *pAtt;

			TRACE_OUT (("PrivateChannel::ChannelAdmitRequest: "
					"admitting users to channel = %04X", Channel_ID));

			/*
			 *	Iterate through the list of users to be admitted, adding all
			 *	valid users to the local authorized user list.
			 */
			user_id_list->Reset();
			while (NULL != (uid = user_id_list->Iterate()))
			{
				/*
				 *	Make sure that the user ID corresponds to a valid user in
				 *	the domain.
				 */
				if (ValidateUserID(uid))
				{
					/*
					 *	If the user is not already in the authorized user list,
					 *	then add it.
					 */
					if (m_AuthorizedUserList.Find(uid) == FALSE)
					{
						m_AuthorizedUserList.Append(uid);
						admitted_id_list.Append(uid);
					}
				}
			}

			/*
			 *	Build lists of unique attachments which can then be used to
			 *	issue the appropriate admit indications.  This prevents the
			 *	transmission of an admit indication to the same attachment more
			 *	than once.
			 */
			BuildAttachmentLists (&admitted_id_list, &local_attachment_list,
					&remote_attachment_list);

			/*
			 *	Iterate through the local attachment list issuing an admit
			 *	indication to each attachment contained therein.
			 */
			local_attachment_list.Reset();
			while (NULL != (pAtt = local_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the admit indication to the named attachment.
				 */
				pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
			}

			/*
			 *	Iterate through the remote attachment list issuing an admit
			 *	indication to each attachment contained therein.
			 */
			remote_attachment_list.Reset();
			while (NULL != (pAtt = remote_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the admit indication to the named attachment.
				 */
				pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
			}
		}
		else
		{
			/*
			 *	This is not the Top Provider, so forward the request toward
			 *	the Top Provider.  This will result in a channel admit
			 *	indication at a future time.
			 */
			TRACE_OUT (("PrivateChannel::ChannelAdmitRequest: "
					"forwarding request to Top Provider"));
			m_pConnToTopProvider->ChannelAdmitRequest(uidInitiator, Channel_ID, user_id_list);
		}
	}
	else
	{
		/*
		 *	Someone is trying to admit users to a private channel that they are
		 *	not the channel manager for.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::ChannelAdmitRequest: "
				"ignoring request from non-channel manager"));
	}
}

/*
 *	Void	ChannelAdmitIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it receives
 *		a channel admit indication from the manager of a private channel.  This
 *		indication is broadcast downward to all providers that contain an
 *		admitted user somewhere in their sub-tree.  A side-effect of this
 *		indication is that a private channel will be created in the information
 *		base if one does not already exist.
 */
Void	PrivateChannel::ChannelAdmitIndication (
				PConnection,
				UserID				uidInitiator,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID					uid;
	CUidList				admitted_id_list;
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList				user_id_subset;

	TRACE_OUT (("PrivateChannel::ChannelAdmitIndication: "
			"admitting users to channel = %04X", (UINT) Channel_ID));

	/*
	 *	Iterate through the list of users to be admitted, adding all
	 *	valid users to the local authorized user list.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Make sure that the user ID corresponds to a valid user in
		 *	the domain.
		 */
		if (ValidateUserID(uid))
		{
			/*
			 *	If the user is not already in the authorized user list,
			 *	then add it.
			 */
			if (m_AuthorizedUserList.Find(uid) == FALSE)
			{
				m_AuthorizedUserList.Append(uid);
				admitted_id_list.Append(uid);
			}
		}
	}

	/*
	 *	Build lists of unique attachments which can then be used to
	 *	issue the appropriate admit indications.  This prevents the
	 *	transmission of an admit indication to the same attachment more
	 *	than once.
	 */
	BuildAttachmentLists (&admitted_id_list, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	Iterate through the local attachment list issuing an admit
	 *	indication to each attachment contained therein.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the admit indication to the named attachment.
		 */
		pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
	}

	/*
	 *	Iterate through the remote attachment list issuing an admit
	 *	indication to each attachment contained therein.
	 */
	remote_attachment_list.Reset();
	while (NULL != (pAtt = remote_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the admit indication to the named attachment.
		 */
		pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
	}
}

/*
 *	Void	ChannelExpelRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the manager of a private channel
 *		when it wishes to shrink the authorized user list of that channel.  If
 *		the channel is in the local information base, the request is sent to it.
 *		Otherwise, the request is ignored.
 */
Void	PrivateChannel::ChannelExpelRequest (
				CAttachment *,
				UserID				uidInitiator,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID  				uid;
	CUidList				expelled_id_list;
	CUidList				user_id_subset;

	/*
	 *	Check to see if the requesting user is the channel manager.  Only
	 *	process the request if it is.
	 */
	if (uidInitiator == m_uidChannelManager)
	{
		/*
		 *	See if this is the Top Provider.  If it is, then the request can
		 *	be processed locally.  Otherwise, pass the request upward toward
		 *	the Top Provider.
		 */
		if (m_pConnToTopProvider == NULL)
		{
        	CAttachmentList         local_attachment_list;
        	CAttachmentList         remote_attachment_list;
        	CAttachment            *pAtt;

			TRACE_OUT (("PrivateChannel::ChannelExpelRequest: "
					"expelling users from channel = %04X", Channel_ID));

			/*
			 *	Iterate through the list of users to be expelled, removing all
			 *	valid users from the local authorized user list.
			 */
			user_id_list->Reset();
			while (NULL != (uid = user_id_list->Iterate()))
			{
				/*
				 *	If the user is in the authorized user list, then remove it.
				 */
				if (m_AuthorizedUserList.Find(uid))
				{
					m_AuthorizedUserList.Remove(uid);
					expelled_id_list.Append(uid);
				}
			}

			/*
			 *	Build lists of unique attachments which can then be used to
			 *	issue the appropriate expel indications.  This prevents the
			 *	transmission of an expel indication to the same attachment more
			 *	than once.
			 */
			BuildAttachmentLists (&expelled_id_list, &local_attachment_list,
					&remote_attachment_list);

			/*
			 *	Iterate through the local attachment list issuing an expel
			 *	indication to each attachment contained therein.
			 */
			local_attachment_list.Reset();
			while (NULL != (pAtt = local_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the expel indication to the named attachment.
				 */
				pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);

				/*
				 *	Since this is a locally attached user, it is necessary to
				 *	simulate a channel leave request from the user, indicating
				 *	the fact that it can no longer use the channel.
				 */
				ChannelLeaveRequest(pAtt, (CChannelIDList *) &user_id_subset);
			}

			/*
			 *	Iterate through the remote attachment list issuing an expel
			 *	indication to each attachment contained therein.
			 */
			remote_attachment_list.Reset();
			while (NULL != (pAtt = remote_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the expel indication to the named attachment.
				 */
				pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);
			}
		}
		else
		{
			/*
			 *	This is not the Top Provider, so forward the request toward
			 *	the Top Provider.  This will result in a channel expel
			 *	indication at a future time.
			 */
			TRACE_OUT (("PrivateChannel::ChannelExpelRequest: "
					"forwarding request to Top Provider"));
			m_pConnToTopProvider->ChannelExpelRequest(uidInitiator, Channel_ID, user_id_list);
		}
	}
	else
	{
		/*
		 *	Someone is trying to admit users to a private channel that they are
		 *	not the channel manager for.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::ChannelExpelRequest: "
				"ignoring request from non-channel manager"));
	}
}

/*
 *	Void	ChannelExpelIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it receives
 *		a request from the manager of a private channel to reduce the
 *		authorized user list.  It travels downward to all attachments and
 *		connections that contain an admitted user or the channel manager in
 *		their sub-tree.
 */
Void	PrivateChannel::ChannelExpelIndication (
				PConnection,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID					uid;
	CUidList				expelled_id_list;
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList				user_id_subset;

	TRACE_OUT (("PrivateChannel::ChannelExpelIndication: "
			"expelling users from channel = %04X", Channel_ID));

	/*
	 *	Iterate through the list of users to be expelled, removing all
	 *	valid users from the local authorized user list.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	If the user is in the authorized user list, then remove it.
		 */
		if (m_AuthorizedUserList.Find(uid))
		{
			m_AuthorizedUserList.Remove(uid);
			expelled_id_list.Append(uid);
		}
	}

	/*
	 *	Build lists of unique attachments which can then be used to
	 *	issue the appropriate expel indications.  This prevents the
	 *	transmission of an expel indication to the same attachment more
	 *	than once.
	 */
	BuildAttachmentLists (&expelled_id_list, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	Iterate through the local attachment list issuing an expel
	 *	indication to each attachment contained therein.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the expel indication to the named attachment.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);

		/*
		 *	Since this is a locally attached user, it is necessary to
		 *	simulate a channel leave request from the user, indicating
		 *	the fact that it can no longer use the channel.
		 */
		ChannelLeaveRequest(pAtt, (CChannelIDList *) &user_id_subset);
	}

	/*
	 *	Iterate through the remote attachment list issuing an expel
	 *	indication to each attachment contained therein.
	 */
	remote_attachment_list.Reset();
	while (NULL != (pAtt = remote_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the expel indication to the named attachment.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);
	}
}

/*
 *	Void	SendDataRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user that wishes to send data
 *		to other users who are joined to a specified channel.  This routine
 *		is executed in the case that it is a private channel.  It verifies
 *		that the user is authorized to use the channel before allowing the data
 *		to be sent.
 */
Void	PrivateChannel::SendDataRequest (
				CAttachment        *pOrigAtt,
				UINT				type,
				PDataPacket			data_packet)
{
	UserID  uidInitiator;

	uidInitiator = data_packet->GetInitiator();
	if ((uidInitiator == m_uidChannelManager) || m_AuthorizedUserList.Find(uidInitiator))
	{
		/*
		 *	The channel usage is authorized, so forward the request to the
		 *	base class implementation for processing.
		 */
		Channel::SendDataRequest(pOrigAtt, type, data_packet);
	}
	else
	{
		/*
		 *	Someone is trying to send data on a private channel that they are
		 *	not authorized to use.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::SendDataRequest: "
				"ignoring request from non-authorized user"));
	}
}

/*
 *	BOOL    ValidateUserID ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called whenever another member function of this class
 *		wants to check and see if a specified user is still valid in the
 *		domain channel list.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user being checked out.
 *
 *	Return Value:
 *		TRUE if the user is valid.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 */
BOOL    PrivateChannel::ValidateUserID (
					UserID			user_id)
{
	PChannel	channel;

	/*
	 *	First check to see if the user ID is in the channel list at all.  This
	 *	prevents an attempt to read an invalid entry from the dictionary.
	 */
	if (NULL != (channel = m_pChannelList2->Find(user_id)))
	{
		/*
		 *	We know that the ID is in the dictionary, but we don't know for sure
		 *	whether or not it is a user ID channel.  So check this.  If it is a
		 *	user channel, then set the valid flag to TRUE.
		 */
		if (channel->GetChannelType () == USER_CHANNEL)
			return TRUE;
	}

	return FALSE;
}

/*
 *	Void	BuildAttachmentLists ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called upon to build a list of unique attachments that
 *		lead to the users in the specified list.  It builds two attachment
 *		lists.  The first has an entry for each unique local attachment.  The
 *		second for each remote attachment.  The key to each list is the
 *		attachment.
 *
 *	Formal Parameters:
 *		user_id_list (i)
 *			This is the list of users for which the list is to be built.
 *		local_attachment_list (i)
 *			This is the dictionary that is to contain the list of unique
 *			local attachments.
 *		remote_attachment_list (i)
 *			This is the dictionary that is to contain the list of unique
 *			remote attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	PrivateChannel::BuildAttachmentLists (
				CUidList                *user_id_list,
				CAttachmentList         *local_attachment_list,
				CAttachmentList         *remote_attachment_list)
{
	UserID				uid;

	/*
	 *	Loop through the passed in user ID list building a dictionary of local
	 *	attachments (those leading to locally attached users) and a dictionary
	 *	of remote attachments (those leading to remotely connected providers).
	 *	These dictionaries will be used by this provider to issue various
	 *	indications downward, without sending multiple indications to the same
	 *	attachment.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Check to see if the user ID refers to a valid user in the sub-tree
		 *	of this provider.
		 */
		if (ValidateUserID(uid))
		{
			PChannel		lpChannel;
			/*
			 *	Determine which attachment leads to the user in question.
			 */
			if (NULL != (lpChannel = m_pChannelList2->Find(uid)))
            {
			    CAttachment *pAtt = lpChannel->GetAttachment();
			    /*
			     *	This module builds separate lists for those users that are
			     *	attached locally and those attached remotely.
			     */
                if (m_pAttachmentList->Find(pAtt))
                {
			        if (pAtt->IsUserAttachment())
			        {
				        /*
				         *	This attachment is a local one (meaning that it leads to a
				         *	locally attached user, rather than another MCS provider).
				         *	Check to see if this attachment has already been put into
				         *	the dictionary while processing a previous user ID.
				         */
				        if (local_attachment_list->Find(pAtt) == FALSE)
					        local_attachment_list->Append(pAtt);
			        }
			        else
			        {
				        /*
				         *	This attachment is a remote one (meaning that it leads to
				         *	another MCS provider, rather than a locally attached user).
				         *	Check to see if this attachment has already been put into
				         *	the dictionary while processing a previous user ID.
				         */
				        if (remote_attachment_list->Find(pAtt) == FALSE)
					        remote_attachment_list->Append(pAtt);
			        }
                }
                else
                {
                    ERROR_OUT(("PrivateChannel::BuildAttachmentLists: can't find this attachment=0x%p", pAtt));
                }
            }
            else
            {
                ERROR_OUT(("PrivateChannel::BuildAttachmentLists: can't locate channel"));
            }
        }
		else
		{
			/*
			 *	This user ID does not correspond to a valid user in the sub-tree
			 *	of this provider.  Therefore, discard the ID.
			 */
			ERROR_OUT (("PrivateChannel::BuildAttachmentLists: "
					"ERROR - user ID not valid"));
		}
	}
}

/*
 *	Void	BuildUserIDList ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called upon to build a list of all users in the
 *		specified list that are in the direction of the specified attachment.
 *
 *	Formal Parameters:
 *		user_id_list (i)
 *			This is the list of users for which the list is to be built.
 *		attachment (i)
 *			This is the attachment that the caller wishes to have a list of
 *			user IDs for.
 *		user_id_subset (o)
 *			This is the subset of the passed in user IDs that are in the
 *			direction of the specified attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	PrivateChannel::BuildUserIDList (
				CUidList               *user_id_list,
				CAttachment            *pAtt,
				CUidList               *user_id_subset)
{
	UserID				uid;

	/*
	 *	Clear out the subset list, so that we start fresh.
	 */
	user_id_subset->Clear();

	/*
	 *	Loop through the specified user list, checking to see which users
	 *	lie in the direction of the specified attachment.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Check to see if the user ID refers to a valid user in the sub-tree
		 *	of this provider.
		 */
		if (ValidateUserID(uid))
		{
			PChannel	lpChannel;
			/*
			 *	Check to see if this user is the direction of the specified
			 *	attachment.  If it is, then put it into the user ID subset that
			 *	we are building.
			 */
			if (NULL != (lpChannel = m_pChannelList2->Find(uid)))
            {
			    if (lpChannel->GetAttachment () == pAtt)
				    user_id_subset->Append(uid);
            }
            else
            {
                ERROR_OUT(("PrivateChannel::BuildUserIDList: can't locate channel"));
            }
		}
		else
		{
			/*
			 *	This user ID does not correspond to a valid user in the sub-tree
			 *	of this provider.  Therefore, discard the ID.
			 */
			ERROR_OUT (("PrivateChannel::BuildUserIDList: "
					"ERROR - user ID not valid"));
		}
	}
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\plgxprt.h ===
#ifndef _T120_TRANSPORT_H_
#define _T120_TRANSPORT_H_

#include "iplgxprt.h"
#include "it120xprt.h"
#include "socket.h"
#include "mcattprt.h"
#include "imst123.h"

#define MAX_PLUGGABLE_OUT_BUF_SIZE        32

#define MAX_PLUGXPRT_CONNECTIONS          16
#define MAX_PLUGXPRT_EVENTS               5 // read, write, close, pending read, and pending write

#define MAKE_PLUGXPRT_WPARAM(id,type)     (MAKELONG(id,type))
#define PLUGXPRT_WPARAM_TO_ID(wParam)     (LOWORD(wParam))
#define PLUGXPRT_WPARAM_TO_TYPE(wParam)   (HIWORD(wParam))

#define MAKE_PLUGXPRT_LPARAM(evt,err)     (MAKELONG(evt,err))
#define PLUGXPRT_LPARAM_TO_EVENT(lParam)  (LOWORD(lParam))
#define PLUGXPRT_LPARAM_TO_ERROR(lParam)  (HIWORD(lParam))


enum
{
    PLUGXPRT_PENDING_EVENT          = 0,
    PLUGXPRT_EVENT_READ             = 1,
    PLUGXPRT_EVENT_WRITE            = 2,
    PLUGXPRT_EVENT_CLOSE            = 3,
    PLUGXPRT_EVENT_ACCEPT           = 4,
    PLUGXPRT_EVENT_CONNECT          = 5,
    PLUGXPRT_HIGH_LEVEL_READ        = 6,
    PLUGXPRT_HIGH_LEVEL_WRITE       = 7,
};


class CPluggableOutBufQueue2 : public CQueue2
{
    DEFINE_CQUEUE2(CPluggableOutBufQueue2, LPBYTE, int)
};


class CPluggableConnection : public CRefCount
{
public:

    CPluggableConnection(PLUGXPRT_CALL_TYPE eCaller, HANDLE hCommLink,
                        HANDLE hevtRead, HANDLE hevtWrite, HANDLE hevtClose,
                        PLUGXPRT_FRAMING eFraming, PLUGXPRT_PARAMETERS *pParams,
                        T120Error *);
    ~CPluggableConnection(void);

    LPSTR   GetConnString(void) { return &m_szConnID[0]; }
    UINT    GetConnID(void) { return m_nConnID; }
    HANDLE  GetCommLink(void) { return m_hCommLink; }
    HANDLE  GetReadEvent(void) { return m_hevtRead; }
    HANDLE  GetWriteEvent(void) { return m_hevtWrite; }
    HANDLE  GetCloseEvent(void) { return m_hevtClose; }

    void SetSocket(PSocket pSocket) { m_pSocket = pSocket; }
    PSocket GetSocket(void) { return m_pSocket; }

    TransportType GetType(void) { return m_eType; }

    BOOL IsCaller(void) { return (PLUGXPRT_CALLER == m_eCaller); }
    BOOL IsCallee(void) { return (PLUGXPRT_CALLEE == m_eCaller); }

    HANDLE  GetPendingReadEvent(void) { return m_hevtPendingRead; }
    HANDLE  GetPendingWriteEvent(void) { return m_hevtPendingWrite; }

    T120Error UpdateCommLink(HANDLE hCommLink);


    int Read(LPBYTE buffer, int length, PLUGXPRT_RESULT *);
    BOOL OnPendingRead(void);

    int Write(LPBYTE buffer, int length, PLUGXPRT_RESULT *);
    BOOL OnPendingWrite(void);
    void WriteTheFirst(void);

    void NotifyHighLevelRead(void);
    void NotifyReadFailure(void);

    void NotifyHighLevelWrite(void);
    void NotifyWriteFailure(void);
    void NotifyWriteEvent(void);

    BOOL SetupReadState(int length);
    void CleanupReadState(void);
    void CleanupWriteState(void);

    void Shutdown(void);


    //
    // Legacy PSTN transport
    //
    LEGACY_HANDLE GetLegacyHandle(void) { return m_nLegacyLogicalHandle; }
    void SetLegacyHandle(LEGACY_HANDLE logical_handle) { m_nLegacyLogicalHandle = logical_handle; }
    TransportError TConnectRequest(void);
    TransportError TDisconnectRequest(void);
    int TDataRequest(LPBYTE pbData, ULONG cbDataSize, PLUGXPRT_RESULT *);
    TransportError TPurgeRequest(void);

private:

    PLUGXPRT_STATE      m_eState;
    PLUGXPRT_CALL_TYPE  m_eCaller;

    HANDLE              m_hCommLink;
    HANDLE              m_hevtRead;
    HANDLE              m_hevtWrite;
    HANDLE              m_hevtClose;
    TransportType       m_eType;

    PSocket             m_pSocket;

    UINT                m_nConnID;
    char                m_szConnID[T120_CONNECTION_ID_LENGTH];

    //
    // Legacy PSTN transport
    //
    LEGACY_HANDLE           m_nLegacyLogicalHandle;

    //
    // X.224 framing
    //
    HANDLE              m_hevtPendingRead;  // for asynchronous ReadFile()
    HANDLE              m_hevtPendingWrite; // for asynchronous WriteFile()
    // IO queue management for X.224
    BOOL                    m_fPendingReadDone;
    int                     m_cbPendingRead;
    LPBYTE                  m_pbPendingRead;
    OVERLAPPED              m_OverlappedRead;
    int                     m_cbPendingWrite;
    LPBYTE                  m_pbPendingWrite;
    OVERLAPPED              m_OverlappedWrite;
    CPluggableOutBufQueue2  m_OutBufQueue2;
};




class CPluggableConnectionList : public CList
{
    DEFINE_CLIST(CPluggableConnectionList, CPluggableConnection *)
};


class CPluggableTransport : public IT120PluggableTransport,
                            public CRefCount
{
public:

    CPluggableTransport(void);
    ~CPluggableTransport(void);

    STDMETHOD_(void, ReleaseInterface) (THIS);

    STDMETHOD_(T120Error, CreateConnection) (THIS_
                    char                szConnID[],
                    PLUGXPRT_CALL_TYPE  eCaller,
                    HANDLE              hCommLink,
                    HANDLE              hevtRead,
                    HANDLE              hevtWrite,
                    HANDLE              hevtClose,
                    PLUGXPRT_FRAMING    eFraming,
                    PLUGXPRT_PARAMETERS *pParams);

    STDMETHOD_(T120Error, UpdateConnection) (THIS_
                    LPSTR               pszConnID,
                    HANDLE              hCommLink);

    STDMETHOD_(T120Error, CloseConnection) (THIS_ LPSTR pszConnID);

    STDMETHOD_(T120Error, EnableWinsock) (THIS);

    STDMETHOD_(T120Error, DisableWinsock) (THIS);

    STDMETHOD_(void, Advise) (THIS_ LPFN_PLUGXPRT_CB, LPVOID pContext);

    STDMETHOD_(void, UnAdvise) (THIS);

    STDMETHOD_(void, ResetConnCounter) (THIS);

    void OnProtocolControl(TransportConnection, PLUGXPRT_STATE, PLUGXPRT_RESULT);

    ULONG UpdateEvents(HANDLE *aHandles);
    void OnEventSignaled(HANDLE hevtSignaled);
    void OnEventAbandoned(HANDLE hevtSignaled);

    CPluggableConnection * GetPluggableConnection(PSocket pSocket);
    CPluggableConnection * GetPluggableConnection(UINT_PTR nConnID);
    CPluggableConnection * GetPluggableConnection(HANDLE hCommLink);
    CPluggableConnection * GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE);

    //
    // legacy tranport
    //
    BOOL EnsureLegacyTransportLoaded(void);

private:

    LPFN_PLUGXPRT_CB            m_pfnNotify;
    LPVOID                      m_pContext;
    CPluggableConnectionList    m_PluggableConnectionList;
};

void OnProtocolControl(TransportConnection, PLUGXPRT_STATE,
                       PLUGXPRT_RESULT eResult = PLUGXPRT_RESULT_SUCCESSFUL);

ULONG CreateConnString(int nConnID, char szConnID[]);
BOOL IsValidPluggableTransportName(LPCSTR pcszNodeAddress);
UINT GetPluggableTransportConnID(LPCSTR pcszNodeAddress);
CPluggableConnection * GetPluggableConnection(PSocket pSocket);
CPluggableConnection * GetPluggableConnection(UINT_PTR nConnID);
CPluggableConnection * GetPluggableConnection(HANDLE hCommLink);
CPluggableConnection * GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE);

int SubmitPluggableRead(PSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *);
int SubmitPluggableWrite(PSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *);
void PluggableWriteTheFirst(TransportConnection);
void PluggableShutdown(TransportConnection);


//
// PSTN framing
//
TransportError TReceiveBufferAvailable(void);
extern ILegacyTransport *g_pLegacyTransport;


extern BOOL g_fWinsockDisabled;
extern CRITICAL_SECTION g_csTransport;

#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
LPCSTR FakeNodeAddress(LPCSTR pcszNodeAddress);
#endif

#endif // _T120_TRANSPORT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\plgxprt.cpp ===
#include "precomp.h"
#include "plgxprt.h"

// #undef TRACE_OUT
// #define TRACE_OUT   WARNING_OUT

#define XPRT_CONN_ID_PREFIX         "XPRT"
#define XPRT_CONN_ID_PREFIX_LEN     4

static UINT s_nConnID = 0;

CPluggableTransport *g_pPluggableTransport = NULL;
BOOL                g_fWinsockDisabled = FALSE;
BOOL                g_fPluggableTransportInitialized = FALSE;
DWORD               g_dwPluggableTransportThreadID = 0;
HANDLE              g_hevtUpdatePluggableTransport = FALSE;
CRITICAL_SECTION    g_csTransport;
ILegacyTransport   *g_pLegacyTransport = NULL;
HINSTANCE           g_hlibMST123 = NULL;

BOOL EnsurePluggableTransportThread(void);


extern HWND     TCP_Window_Handle;
extern SOCKET   Listen_Socket;
extern SOCKET   Listen_Socket_Secure;
extern PTransportInterface	g_Transport;
extern UChar g_X224Header[];

extern void CloseListenSocket(void);


T120Error WINAPI T120_CreatePluggableTransport(IT120PluggableTransport **ppTransport)
{
    if (NULL != ppTransport)
    {
        *ppTransport = NULL;
        if (NULL == g_pPluggableTransport)
        {
            if (g_fPluggableTransportInitialized)
            {
                DBG_SAVE_FILE_LINE
                *ppTransport = (CPluggableTransport *) new CPluggableTransport;
                if (NULL != *ppTransport)
                {
                    if (EnsurePluggableTransportThread())
                    {
                        return T120_NO_ERROR;
                    }
                    else
                    {
                        (*ppTransport)->ReleaseInterface();
                        *ppTransport = NULL;
                    }
                }

                return T120_ALLOCATION_FAILURE;
            }

            return T120_NOT_INITIALIZED;
        }

        return T120_ALREADY_INITIALIZED;
    }

    return T120_INVALID_PARAMETER;
}



CPluggableConnection::CPluggableConnection
(
    PLUGXPRT_CALL_TYPE  eCaller,
    HANDLE              hCommLink,
    HANDLE              hevtRead,
    HANDLE              hevtWrite,
    HANDLE              hevtClose,
    PLUGXPRT_FRAMING    eFraming,
    PLUGXPRT_PARAMETERS *pParams,
    T120Error          *pRC
)
:
    CRefCount(MAKE_STAMP_ID('P','X','P','C')),
    m_eState(PLUGXPRT_UNKNOWN_STATE),
    m_eCaller(eCaller),
    m_hCommLink(hCommLink),
    m_hevtRead(hevtRead),
    m_hevtWrite(hevtWrite),
    m_hevtClose(hevtClose),
    m_eType(TRANSPORT_TYPE_PLUGGABLE_X224),
    m_pSocket(NULL),
    // Legacy tranport
    m_nLegacyLogicalHandle(0),
    // IO queue management for X.224 framing
    m_hevtPendingRead(NULL),
    m_hevtPendingWrite(NULL),
    m_fPendingReadDone(FALSE),
    m_cbPendingRead(0),
    m_pbPendingRead(NULL),
    m_cbPendingWrite(0),
    m_pbPendingWrite(NULL),
    m_OutBufQueue2(MAX_PLUGGABLE_OUT_BUF_SIZE)
{
    TransportError err;
    BOOL fCaller = (PLUGXPRT_CALLER == eCaller);

    // X.224 only
    ::ZeroMemory(&m_OverlappedRead, sizeof(m_OverlappedRead));
    ::ZeroMemory(&m_OverlappedWrite, sizeof(m_OverlappedWrite));

    // assign connection ID
    ::EnterCriticalSection(&g_csTransport);
    if (s_nConnID > 0x7FFF)
    {
        s_nConnID = 0;
    }
    m_nConnID = ++s_nConnID;
    ::LeaveCriticalSection(&g_csTransport);

    // create connection ID string
    ::CreateConnString(GetConnID(), m_szConnID);

    // do framing specific initialization
    switch (eFraming)
    {
    case FRAMING_X224:
        m_eType = TRANSPORT_TYPE_PLUGGABLE_X224;

        m_hevtPendingRead  = ::CreateEvent(NULL, TRUE, FALSE, NULL); /* manual reset */
        m_hevtPendingWrite = ::CreateEvent(NULL, TRUE, FALSE, NULL); /* manual reset */
        ASSERT(NULL != m_hevtPendingRead && NULL != m_hevtPendingWrite);
        *pRC = (NULL != m_hevtPendingRead && NULL != m_hevtPendingWrite)
                ? T120_NO_ERROR : T120_ALLOCATION_FAILURE;
        break;

    case FRAMING_LEGACY_PSTN:
        m_eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
        ASSERT(NULL != g_pLegacyTransport);

        err = g_pLegacyTransport->TCreateTransportStack(fCaller, m_hCommLink, m_hevtClose, pParams);
        ASSERT(TRANSPORT_NO_ERROR == err);

        *pRC = (TRANSPORT_NO_ERROR == err) ? T120_NO_ERROR : T120_NO_TRANSPORT_STACKS;
        break;

    default:
        ERROR_OUT(("CPluggableConnection: unknown framing %d", eFraming));
        *pRC = T120_INVALID_PARAMETER;
        break;
    }
}


CPluggableConnection::~CPluggableConnection(void)
{
    if (NULL != m_pSocket)
    {
        ::freePluggableSocket(m_pSocket);
        m_pSocket = NULL;
    }

    Shutdown();

    if (TRANSPORT_TYPE_PLUGGABLE_PSTN == m_eType)
    {
        if (NULL != g_pLegacyTransport && NULL != m_hCommLink)
        {
            g_pLegacyTransport->TCloseTransportStack(m_hCommLink);
        }
    }

    if (NULL != m_hCommLink)
    {
        ::CloseHandle(m_hCommLink);
    }

    if (NULL != m_hevtRead)
    {
        ::CloseHandle(m_hevtRead);
    }

    if (NULL != m_hevtWrite)
    {
        ::CloseHandle(m_hevtWrite);
    }

    if (NULL != m_hevtClose)
    {
        ::CloseHandle(m_hevtClose);
    }

    if (NULL != m_hevtPendingRead)
    {
        ::CloseHandle(m_hevtPendingRead);
    }

    if (NULL != m_hevtPendingWrite)
    {
        ::CloseHandle(m_hevtPendingWrite);
    }
}


ULONG CreateConnString(int nConnID, char szConnID[])
{
    return ::wsprintfA(szConnID, "%s: %u", XPRT_CONN_ID_PREFIX, nConnID);
}


UINT GetPluggableTransportConnID(LPCSTR pcszNodeAddress)
{
    UINT nConnID = 0;
    char szName[T120_CONNECTION_ID_LENGTH];

    // make sure we have a clean buffer to start with
    ::ZeroMemory(szName, sizeof(szName));

    // copy the address string
    ::lstrcpynA(szName, pcszNodeAddress, T120_CONNECTION_ID_LENGTH);

    // make sure we have the semi-colon in place
    if (':' == szName[XPRT_CONN_ID_PREFIX_LEN])
    {
        // compare the prefix string
        szName[XPRT_CONN_ID_PREFIX_LEN] = '\0';
        if (! lstrcmpA(szName, XPRT_CONN_ID_PREFIX))
        {
            LPSTR psz = &szName[XPRT_CONN_ID_PREFIX_LEN+1];

            // get a space?
            if (' ' == *psz++)
            {
                // now, have a number
                if ('0' <= *psz && *psz <= '9')
                {
                    while ('0' <= *psz && *psz <= '9')
                    {
                        nConnID = nConnID * 10 + (*psz++ - '0');
                    }
                }
            }
        }
    }

    return nConnID;
}


BOOL IsValidPluggableTransportName(LPCSTR pcszNodeAddress)
{
    return GetPluggableTransportConnID(pcszNodeAddress);
}


typedef BOOL (WINAPI *LPFN_CANCEL_IO) (HANDLE);
void CPluggableConnection::Shutdown(void)
{
    TRACE_OUT(("CPluggableConnection::Shutdown"));

    if (NULL != m_OverlappedRead.hEvent || NULL != m_OverlappedWrite.hEvent)
    {
        HINSTANCE hLib = ::LoadLibrary("kernel32.dll");
        if (NULL != hLib)
        {
            LPFN_CANCEL_IO pfnCancelIo = (LPFN_CANCEL_IO) ::GetProcAddress(hLib, "CancelIo");
            if (NULL != pfnCancelIo)
            {
                (*pfnCancelIo)(m_hCommLink);
            }
            ::FreeLibrary(hLib);
        }

        m_OverlappedRead.hEvent = NULL;
        m_OverlappedWrite.hEvent = NULL;
    }

    delete [] m_pbPendingRead;
    m_pbPendingRead = NULL;

    LPBYTE buffer;
    while (NULL != (buffer = m_OutBufQueue2.Get()))
    {
        delete [] buffer;
    }
}


T120Error CPluggableConnection::UpdateCommLink(HANDLE hCommLink)
{
    T120Error rc;

    ::EnterCriticalSection(&g_csTransport);

    switch (m_eState)
    {
    case PLUGXPRT_UNKNOWN_STATE:
    case PLUGXPRT_DISCONNECTED:
        Shutdown();
        m_hCommLink = hCommLink;
        rc = T120_NO_ERROR;
        break;

    default:
        rc = T120_TRANSPORT_NOT_READY;
        break;
    }

    ::LeaveCriticalSection(&g_csTransport);

    return rc;
}


CPluggableTransport::CPluggableTransport(void)
:
    CRefCount(MAKE_STAMP_ID('X','P','R','T')),
    m_pfnNotify(NULL),
    m_pContext(NULL)
{
    g_pPluggableTransport = this;
    g_pLegacyTransport = NULL;
}


CPluggableTransport::~CPluggableTransport(void)
{
    ::PostThreadMessage(g_dwPluggableTransportThreadID, WM_QUIT, 0, 0);

    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    while (NULL != (p = m_PluggableConnectionList.Get()))
    {
        p->Release();
    }
    ::LeaveCriticalSection(&g_csTransport);

    if (NULL != g_pLegacyTransport)
    {
        g_pLegacyTransport->TCleanup();
        g_pLegacyTransport->ReleaseInterface();
        g_pLegacyTransport = NULL;
    }

    if (NULL != g_hlibMST123)
    {
        ::FreeLibrary(g_hlibMST123);
        g_hlibMST123 = NULL;
    }

    g_pPluggableTransport = NULL;
}


void CPluggableTransport::ReleaseInterface(void)
{
    UnAdvise();
    CRefCount::Release();
}


T120Error CPluggableTransport::CreateConnection
(
    char                szConnID[], /* out */
    PLUGXPRT_CALL_TYPE  eCaller,
    HANDLE              hCommLink,
    HANDLE              hevtRead,
    HANDLE              hevtWrite,
    HANDLE              hevtClose,
    PLUGXPRT_FRAMING    eFraming,
    PLUGXPRT_PARAMETERS *pParams
)
{
    T120Error rc;

    if (FRAMING_LEGACY_PSTN == eFraming)
    {
        if (! EnsureLegacyTransportLoaded())
        {
            return T120_NO_TRANSPORT_STACKS;
        }
    }

    if (NULL != pParams)
    {
        if (sizeof(PLUGXPRT_PARAMETERS) != pParams->cbStructSize)
        {
            return T120_INVALID_PARAMETER;
        }
    }

    DBG_SAVE_FILE_LINE
    CPluggableConnection *p;
    p = new CPluggableConnection(eCaller, hCommLink, hevtRead, hevtWrite, hevtClose,
                                 eFraming, pParams, &rc);
    if (NULL != p && T120_NO_ERROR == rc)
    {
        ::lstrcpyA(szConnID, p->GetConnString());

        ::EnterCriticalSection(&g_csTransport);
        m_PluggableConnectionList.Append(p);
        ::LeaveCriticalSection(&g_csTransport);

        TransportConnection XprtConn;
        XprtConn.eType = p->GetType();
        XprtConn.nLogicalHandle = p->GetConnID();
        PSocket pSocket = ::newPluggableSocket(XprtConn);
        p->SetSocket(pSocket);
        ASSERT(NULL != pSocket);

        // update the events list to wait for in the plugable transport thread
        ::SetEvent(g_hevtUpdatePluggableTransport);

        return T120_NO_ERROR;
    }

    if (NULL != p)
    {
        p->Release();
    }
    else
    {
        rc = T120_ALLOCATION_FAILURE;
    }

    return rc;
}


T120Error CPluggableTransport::UpdateConnection
(
    LPSTR       pszConnID,
    HANDLE      hCommLink
)
{
    BOOL fFound = FALSE;
    CPluggableConnection *p;
    T120Error rc = GCC_INVALID_TRANSPORT;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (! ::lstrcmpA(p->GetConnString(), pszConnID))
        {
            rc = p->UpdateCommLink(hCommLink);
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    // update the events list to wait for in the plugable transport thread
    ::SetEvent(g_hevtUpdatePluggableTransport);

    return rc;
}


T120Error CPluggableTransport::CloseConnection
(
    LPSTR       pszConnID
)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (! ::lstrcmpA(p->GetConnString(), pszConnID))
        {
            m_PluggableConnectionList.Remove(p);
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    // update the events list to wait for in the plugable transport thread
    ::SetEvent(g_hevtUpdatePluggableTransport);

    if (NULL != p)
    {
        //
        // do real work here
        //
        p->Release();

        return T120_NO_ERROR;
    }

    return GCC_INVALID_TRANSPORT;
}


T120Error CPluggableTransport::EnableWinsock(void)
{
    if (g_fWinsockDisabled)
    {
        g_fWinsockDisabled = FALSE;

        //
        // LONCHANC: create Listen_Socket if not done so...
        //
        if (INVALID_SOCKET == Listen_Socket)
        {
            Listen_Socket = ::CreateAndConfigureListenSocket();
        }
    }

    return T120_NO_ERROR;
}


T120Error CPluggableTransport::DisableWinsock(void)
{
    if (! g_fWinsockDisabled)
    {
        g_fWinsockDisabled = TRUE;

        // close Listen_Socket...
        ::CloseListenSocket();
    }

    return T120_NO_ERROR;
}


void CPluggableTransport::Advise(LPFN_PLUGXPRT_CB pNotify, LPVOID pContext)
{
    m_pfnNotify = pNotify;
    m_pContext = pContext;
}


void CPluggableTransport::UnAdvise(void)
{
    m_pfnNotify = NULL;
    m_pContext = NULL;
}


void CPluggableTransport::ResetConnCounter(void)
{
    s_nConnID = 0;
}


void CPluggableTransport::OnProtocolControl
(
    TransportConnection     XprtConn,
    PLUGXPRT_STATE          eState,
    PLUGXPRT_RESULT         eResult
)
{
    if (IS_PLUGGABLE(XprtConn))
    {
        WARNING_OUT(("CPluggableTransport::OnProtocolControl: socket (%d, %d) is doing %d with result %d",
                        XprtConn.eType, XprtConn.nLogicalHandle, eState, eResult));

        if (NULL != m_pfnNotify)
        {
            CPluggableConnection *p = GetPluggableConnection(XprtConn.nLogicalHandle);
            if (NULL != p)
            {
                PLUGXPRT_MESSAGE Msg;
                Msg.eState = eState;
                Msg.pContext = m_pContext;
                Msg.pszConnID = p->GetConnString();
                // we only support X.224 level notifications
                Msg.eProtocol = PLUGXPRT_PROTOCOL_X224;
                Msg.eResult = eResult;

                (*m_pfnNotify)(&Msg);
            }
        }
    }
}


void OnProtocolControl
(
    TransportConnection     XprtConn,
    PLUGXPRT_STATE          eState,
    PLUGXPRT_RESULT         eResult
)
{
    if (NULL != g_pPluggableTransport)
    {
        g_pPluggableTransport->OnProtocolControl(XprtConn, eState, eResult);
    }
}


// called only in the plugable transport thread
// already in the critical section
ULONG CPluggableTransport::UpdateEvents(HANDLE *aHandles)
{
    ULONG cHandles = 0;
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (TRANSPORT_TYPE_PLUGGABLE_X224 == p->GetType())
        {
            aHandles[cHandles++] = p->GetReadEvent();
            aHandles[cHandles++] = p->GetWriteEvent();
            aHandles[cHandles++] = p->GetCloseEvent();
            aHandles[cHandles++] = p->GetPendingReadEvent();
            aHandles[cHandles++] = p->GetPendingWriteEvent();
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return cHandles;
}


// called only in the plugable transport thread
// already in the critical section
void CPluggableTransport::OnEventSignaled(HANDLE hevtSignaled)
{
    CPluggableConnection *p;
    BOOL fPostMessage, fFound;
    WPARAM wParam;
    LPARAM lParam;

    ::EnterCriticalSection(&g_csTransport);

    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        fFound = TRUE;
        fPostMessage = FALSE;
        wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), p->GetType());
        if (hevtSignaled == p->GetReadEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_READ, PLUGXPRT_RESULT_SUCCESSFUL);
            fPostMessage = TRUE;
        }
        else
        if (hevtSignaled == p->GetWriteEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
            fPostMessage = TRUE;
        }
        else
        if (hevtSignaled == p->GetCloseEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_CLOSE, PLUGXPRT_RESULT_SUCCESSFUL);
            fPostMessage = TRUE;
        }
        else
        {
            TransportConnection XprtConn;
            XprtConn.eType = p->GetType();
            XprtConn.nLogicalHandle = p->GetConnID();
            if (hevtSignaled == p->GetPendingReadEvent())
            {
                TRACE_OUT(("OnEventSignaled: PendingREAD(%d, %d)", p->GetType(), p->GetConnID()));
                if (p->OnPendingRead())
                {
                    ::ResetEvent(hevtSignaled);
                    // start next high-level read
                    p->NotifyHighLevelRead();
                }
            }
            else
            if (hevtSignaled == p->GetPendingWriteEvent())
            {
                TRACE_OUT(("OnEventSignaled: PendingWRITE(%d, %d)", p->GetType(), p->GetConnID()));
                if (p->OnPendingWrite())
                {
                    ::ResetEvent(hevtSignaled);
                    // start next low-level write
                    p->NotifyWriteEvent();
                }
            }
            else
            {
                fFound = FALSE;
            }
        }

        if (fPostMessage)
        {
            BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
            ASSERT(fRet);
        }

        if (fFound)
        {
            break;
        }
    } // while

    ::LeaveCriticalSection(&g_csTransport);

    ASSERT(NULL != p);
}


// called only in the plugable transport thread
// already in the critical section
void CPluggableTransport::OnEventAbandoned(HANDLE hevtSignaled)
{
    CPluggableConnection *p;
    BOOL fFound;
    WPARAM wParam;
    LPARAM lParam;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        fFound = TRUE;
        wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), p->GetType());
        if (hevtSignaled == p->GetReadEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_READ, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetWriteEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetCloseEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_CLOSE, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetPendingReadEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_PENDING_EVENT, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetPendingWriteEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_PENDING_EVENT, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        {
            fFound = FALSE;
        }

        if (fFound)
        {
            m_PluggableConnectionList.Remove(p);

            // update the events list to wait for in the plugable transport thread
            ::SetEvent(g_hevtUpdatePluggableTransport);

            BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
            ASSERT(fRet);
            break;
        }
    } // while
    ::LeaveCriticalSection(&g_csTransport);

    ASSERT(NULL != p);
}


CPluggableConnection * CPluggableTransport::GetPluggableConnection(PSocket pSocket)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetType()   == pSocket->XprtConn.eType &&
            p->GetConnID() == pSocket->XprtConn.nLogicalHandle)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnection(PSocket pSocket)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnection(pSocket) :
        NULL;
}


CPluggableConnection * CPluggableTransport::GetPluggableConnection(UINT_PTR nConnID)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetConnID() == nConnID)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnection(UINT_PTR nConnID)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnection(nConnID) :
        NULL;
}


CPluggableConnection * CPluggableTransport::GetPluggableConnection(HANDLE hCommLink)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetCommLink() == hCommLink)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnection(HANDLE hCommLink)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnection(hCommLink) :
        NULL;
}


CPluggableConnection * CPluggableTransport::GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE logical_handle)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetLegacyHandle() == logical_handle)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE logical_handle)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnectionByLegacyHandle(logical_handle) :
        NULL;
}


// called in ERNC ConfMgr's constructor
BOOL InitializePluggableTransport(void)
{
    if (! g_fPluggableTransportInitialized)
    {
        g_fWinsockDisabled = FALSE;
        g_hevtUpdatePluggableTransport = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != g_hevtUpdatePluggableTransport)
        {
            g_fPluggableTransportInitialized = TRUE;
        }
    }
    return g_fPluggableTransportInitialized;
}


// called in ERNC ConfMgr's destructor
void CleanupPluggableTransport(void)
{
    if (g_fPluggableTransportInitialized)
    {
        g_fPluggableTransportInitialized = FALSE;

        if (g_dwPluggableTransportThreadID)
        {
            ::PostThreadMessage(g_dwPluggableTransportThreadID, WM_QUIT, 0, 0);
        }

        ::EnterCriticalSection(&g_csTransport);
        if (NULL != g_hevtUpdatePluggableTransport)
        {
            ::CloseHandle(g_hevtUpdatePluggableTransport);
        }
        ::LeaveCriticalSection(&g_csTransport);
    }
}




DWORD __stdcall PluggableTransportThreadProc(LPVOID lpv)
{
    MSG msg;
    BOOL fContinueMainLoop = TRUE;
    DWORD nEventSignaled;
    ULONG cEvents;
    HANDLE aEvents[MAX_PLUGXPRT_CONNECTIONS * MAX_PLUGXPRT_EVENTS + 1];

    // signaling that the work hread has been started.
    ::SetEvent((HANDLE) lpv);

    // set up initial event list, the first entry always for update event
    cEvents = 1;
    aEvents[0] = g_hevtUpdatePluggableTransport;
    ::SetEvent(g_hevtUpdatePluggableTransport);

    // main loop
	while (fContinueMainLoop)
	{
		// process any possible window and thread messages
		while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (WM_QUIT != msg.message)
            {
			    ::DispatchMessage(&msg);
            }
            else
            {
                fContinueMainLoop = FALSE;
                break;
            }
		}

        if (fContinueMainLoop)
        {
		    nEventSignaled = ::MsgWaitForMultipleObjects(cEvents, aEvents, FALSE, INFINITE, QS_ALLINPUT);
            ::EnterCriticalSection(&g_csTransport);
            if (NULL != g_pPluggableTransport)
            {
                switch (nEventSignaled)
                {
		        case WAIT_OBJECT_0:
                    // update the event list
                    cEvents = 1 + g_pPluggableTransport->UpdateEvents(&aEvents[1]);
                    break;
                case WAIT_TIMEOUT:
                    // impossible, do nothing
                    break;
                default:
                    if (WAIT_OBJECT_0 + 1 <= nEventSignaled && nEventSignaled < WAIT_OBJECT_0 + cEvents)
                    {
                        g_pPluggableTransport->OnEventSignaled(aEvents[nEventSignaled - WAIT_OBJECT_0]);
                    }
                    else
                    if (WAIT_ABANDONED_0 + 1 <= nEventSignaled && nEventSignaled < WAIT_ABANDONED_0 + cEvents)
                    {
                        g_pPluggableTransport->OnEventAbandoned(aEvents[nEventSignaled - WAIT_OBJECT_0]);
                    }
                    break;
                }
            }
            else
            {
                fContinueMainLoop = FALSE;
            }
            ::LeaveCriticalSection(&g_csTransport);
        }
    } // while

    g_dwPluggableTransportThreadID = 0;

    return 0;
}

BOOL EnsurePluggableTransportThread(void)
{
    BOOL fRet = TRUE;
    if (! g_dwPluggableTransportThreadID)
    {
        fRet = FALSE;
        HANDLE hSync = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hSync)
        {
            HANDLE hThread = ::CreateThread(NULL, 0, PluggableTransportThreadProc, hSync, 0,
                                            &g_dwPluggableTransportThreadID);
            if (NULL != hThread)
            {
                ::WaitForSingleObject(hSync, 5000); // 5 second
                ::CloseHandle(hThread);
                fRet = TRUE;
            }
            ::CloseHandle(hSync);
        }
    }
    return fRet;
}


#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
LPCSTR FakeNodeAddress(LPCSTR pcszNodeAddress)
{
    char szAddr[64];
    ::lstrcpyA(szAddr, pcszNodeAddress);
    for (LPSTR psz = &szAddr[0]; *psz; psz++)
    {
        if (*psz == ':')
        {
            *psz = '\0';
            break;
        }
    }
    if (! ::lstrcmp(szAddr, "157.59.12.93"))
    {
        pcszNodeAddress = "XPRT: 1";
    }
    else
    if (! ::lstrcmp(szAddr, "157.59.13.194"))
    {
        pcszNodeAddress = "XPRT: 2";
    }
    else
    if (! ::lstrcmp(szAddr, "157.59.10.198"))
    {
        pcszNodeAddress = "XPRT: 1";
    }
    else
    {
        ASSERT(0);
    }
    return pcszNodeAddress;
}
#endif


int SubmitPluggableRead(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("SubmitPluggableRead"));

    int nRet = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    CPluggableConnection *p = ::GetPluggableConnection(pSocket);
    if (NULL != p)
    {
        nRet = p->Read(buffer, length, plug_rc);
    }
    else
    {
        WARNING_OUT(("SubmitPluggableRead: no such conn ID=%d", pSocket->XprtConn.nLogicalHandle));
    }
    return nRet;
}


int CPluggableConnection::Read(LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    int cbRecv = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    ::EnterCriticalSection(&g_csTransport);

    if (NULL != m_OverlappedRead.hEvent)
    {
        // handle low-level pending read first
        if (m_fPendingReadDone)
        {
            // copy the data from internal buffer to external buffer
            if (length <= m_cbPendingRead)
            {
                // get as requested
                cbRecv = length;
                ::CopyMemory(buffer, m_pbPendingRead, length);
                m_cbPendingRead -= length;
                if (m_cbPendingRead <= 0)
                {
                    CleanupReadState();
                }
                else
                {
                    // move the memory, do not use copymemory due to overlap
                    int cb = m_cbPendingRead;
                    LPBYTE pbDst = m_pbPendingRead;
                    LPBYTE pbSrc = &m_pbPendingRead[length];
                    while (cb--)
                    {
                        *pbDst++ = *pbSrc++;
                    }
                }
            }
            else
            {
                // only get partial data
                cbRecv = m_cbPendingRead;
                ::CopyMemory(buffer, m_pbPendingRead, m_cbPendingRead);
                CleanupReadState();
            }

            // start next high-level read
            NotifyHighLevelRead();
        }
    }
    else
    {
        if (SetupReadState(length))
        {
            TRACE_OUT(("CPluggableConnection::Read: ReadFile(%d)", m_cbPendingRead));

            DWORD dwRead = 0;
            if (! ::ReadFile(m_hCommLink,
                             m_pbPendingRead,
                             m_cbPendingRead,
                             &dwRead,
                             &m_OverlappedRead))
            {
                DWORD dwErr = ::GetLastError();
                if (ERROR_HANDLE_EOF != dwErr && ERROR_IO_PENDING != dwErr)
                {
                    WARNING_OUT(("CPluggableConnection::Read: ReadFile failed, err=%d", dwErr));

                    CleanupReadState();

                    // disconnect at next tick
                    NotifyReadFailure();
                    *plug_rc = PLUGXPRT_RESULT_READ_FAILED;
                }
            }
            else
            {
                // do nothing, treat it as WSAEWOULDBLOCK
            }
        }
        else
        {
            ERROR_OUT(("CPluggableConnection::Read: failed to allocate memory (%d)", length));
            // out of memory, try later
            // do nothing, treat it as WSAEWOULDBLOCK
        }
    }

    ::LeaveCriticalSection(&g_csTransport);

    return cbRecv;
}


BOOL CPluggableConnection::OnPendingRead(void)
{
    TRACE_OUT(("CPluggableConnection::OnPendingRead"));

    BOOL fRet = FALSE;

    ::EnterCriticalSection(&g_csTransport);

    if (NULL != m_OverlappedRead.hEvent)
    {
        DWORD cbRead = 0;

        if (::GetOverlappedResult(m_hCommLink, &m_OverlappedRead, &cbRead, FALSE))
        {
            if ((int) cbRead == m_cbPendingRead)
            {
                TRACE_OUT(("CPluggableConnection::OnPendingRead: Received %d bytes (required %d bytes) on socket (%d, %d).",
                            cbRead, m_cbPendingRead, m_eType, m_nConnID));
            }
            else
            {
                WARNING_OUT(("CPluggableConnection::OnPendingRead: Received %d bytes (required %d bytes) on socket (%d, %d).",
                            cbRead, m_cbPendingRead, m_eType, m_nConnID));
            }
            m_cbPendingRead = cbRead; // in case cbRead is smaller
            m_fPendingReadDone = TRUE;
            fRet = TRUE; // turn off event
        }
        else
        {
            DWORD dwErr = ::GetLastError();
            if (ERROR_IO_INCOMPLETE == dwErr)
            {
                ASSERT(! cbRead);
            }
            else
            {
                TRACE_OUT(("CPluggableConnection::OnPendingRead: read failed %d", dwErr));
                fRet = TRUE; // turn off event

                // disconnect at next tick
                NotifyReadFailure();
            }
        }
    }
    else
    {
        ERROR_OUT(("CPluggableConnection::OnPendingRead: no pending read event handle."));
        fRet = TRUE; // turn off event
    }

    ::LeaveCriticalSection(&g_csTransport);

    return fRet;
}


void CPluggableConnection::NotifyHighLevelRead(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_HIGH_LEVEL_READ, PLUGXPRT_RESULT_SUCCESSFUL);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyReadFailure(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_READ, PLUGXPRT_RESULT_READ_FAILED);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyWriteEvent(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyHighLevelWrite(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_HIGH_LEVEL_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyWriteFailure(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_WRITE_FAILED);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}




LPBYTE DuplicateBuffer(LPBYTE buffer, UINT length)
{
    // DBG_SAVE_FILE_LINE
    LPBYTE new_buffer = new BYTE[length];
    if (NULL != new_buffer)
    {
        ::CopyMemory(new_buffer, buffer, length);
    }
    return new_buffer;
}


int SubmitPluggableWrite(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("SubmitPluggableWrite"));

    int nRet = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    CPluggableConnection *p = ::GetPluggableConnection(pSocket);
    if (NULL != p)
    {
        nRet = p->Write(buffer, length, plug_rc);
    }
    else
    {
        WARNING_OUT(("SubmitPluggableWrite: no such conn ID=%d", pSocket->XprtConn.nLogicalHandle));
    }
    return nRet;
}


int CPluggableConnection::Write(LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("CPluggableConnection::Write"));

    int cbSent = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    ::EnterCriticalSection(&g_csTransport);

    if (m_OutBufQueue2.GetCount() < MAX_PLUGGABLE_OUT_BUF_SIZE) // x4K
    {
        DBG_SAVE_FILE_LINE
        buffer = ::DuplicateBuffer(buffer, length);
        if (NULL != buffer)
        {
            cbSent = length;
            m_OutBufQueue2.Append(length, buffer);
            if (1 == m_OutBufQueue2.GetCount())
            {
                TRACE_OUT(("CPluggableConnection::Write: the only item in the queue"));
                WriteTheFirst();
                #if 0 // avoid another tick
                // start next low-level write
                WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
                LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
                BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
                ASSERT(fRet);
                #endif
            }
            else
            {
                TRACE_OUT(("CPluggableConnection::Write: more items in the queue"));
            }
        }
        else
        {
            ERROR_OUT(("CPluggableConnection::Write: failed to allocate memory (%d)", length));
            // out of memory, try later
            // do nothing, treat it as WSAEWOULDBLOCK
        }
    }

    ::LeaveCriticalSection(&g_csTransport);

    return cbSent;
}


void CPluggableConnection::WriteTheFirst(void)
{
    int length;
    LPBYTE buffer;

    TRACE_OUT(("CPluggableConnection::WriteTheFirst"));

    ::EnterCriticalSection(&g_csTransport);

    if (NULL == m_OverlappedWrite.hEvent)
    {
        length = 0;
        buffer = m_OutBufQueue2.PeekHead(&length);
        if (NULL != buffer)
        {
            ::ZeroMemory(&m_OverlappedWrite, sizeof(m_OverlappedWrite));
            m_OverlappedWrite.hEvent = m_hevtPendingWrite;

            m_pbPendingWrite = buffer;
            m_cbPendingWrite = length;

            TRACE_OUT(("CPluggableConnection::WriteTheFirst: WriteFile(%d)", length));

            DWORD cbWritten = 0;
            if (! ::WriteFile(m_hCommLink, buffer, length, &cbWritten, &m_OverlappedWrite))
            {
                DWORD dwErr = ::GetLastError();
                if (ERROR_IO_PENDING != dwErr)
                {
                    ERROR_OUT(("CPluggableConnection::WriteTheFirst: WriteFile failed, err=%d", dwErr));
                    CleanupWriteState();
                    m_OutBufQueue2.Get(); // dequeue the buffer which cannot be sent

                    NotifyWriteFailure();
                }
                else
                {
                    // we are still in pending
                    // repeat the write event
                    NotifyWriteEvent();
                }
            }
        }
        else
        {
            TRACE_OUT(("CPluggableConnection::WriteTheFirst: queue is empty"));

            // no more low-level write
            m_pbPendingWrite = NULL;
            CleanupWriteState();

            // start next high-level write
            NotifyHighLevelWrite();
        }
    }
    else
    {
        TRACE_OUT(("CPluggableConnection::WriteTheFirst: still pending"));
        // we are still in write pending, wake up the pending write
        OnPendingWrite(); // check for pending write result
        NotifyWriteEvent();
    }

    ::LeaveCriticalSection(&g_csTransport);
}


void PluggableWriteTheFirst(TransportConnection XprtConn)
{
    if (IS_PLUGGABLE(XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
        if (NULL != p)
        {
            p->WriteTheFirst();
        }
        else
        {
            ERROR_OUT(("PluggableWriteTheFirst: no such conn ID=%d", XprtConn.nLogicalHandle));
        }
    }
    else
    {
        ERROR_OUT(("PluggableWriteTheFirst: not plugable connection"));
    }
}


void PluggableShutdown(TransportConnection XprtConn)
{
    if (IS_PLUGGABLE(XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
        if (NULL != p)
        {
            p->Shutdown();
        }
        else
        {
            ERROR_OUT(("PluggableShutdown: no such conn ID=%d", XprtConn.nLogicalHandle));
        }
    }
    else
    {
        ERROR_OUT(("PluggableShutdown: not plugable connection"));
    }
}


BOOL CPluggableConnection::OnPendingWrite(void)
{
    TRACE_OUT(("CPluggableConnection::OnPendingWrite"));

    BOOL fRet = FALSE;
	BOOL fStartNextWrite = FALSE;

    ::EnterCriticalSection(&g_csTransport);

    if (NULL != m_OverlappedWrite.hEvent)
    {
        DWORD cbWritten = 0;
        if (::GetOverlappedResult(m_hCommLink, &m_OverlappedWrite, &cbWritten, FALSE))
        {
            TRACE_OUT(("CPluggableConnection::OnPendingWrite: Sent %d bytes (required %d bytes) on socket (%d, %d).",
                            cbWritten, m_cbPendingWrite, m_eType, m_nConnID));
            if (cbWritten >= (DWORD) m_cbPendingWrite)
            {
                ASSERT(cbWritten == (DWORD) m_cbPendingWrite);

                // remove the item from the queue
                int length = 0;
                LPBYTE buffer = m_OutBufQueue2.Get(&length);
                ASSERT(length == m_cbPendingWrite);
                ASSERT(buffer == m_pbPendingWrite);

                CleanupWriteState();

                fRet = TRUE; // turn off event
            }
            else
            {
                ERROR_OUT(("CPluggableConnection::OnPendingWrite: unexpected error, less data written %d (required %d)",
                            cbWritten, m_cbPendingWrite));
                NotifyWriteFailure();
                fRet = TRUE; // turn off event
            }
        }
        else
        {
            DWORD dwErr = ::GetLastError();
            if (ERROR_IO_INCOMPLETE == dwErr)
            {
                ASSERT(! cbWritten);
            }
            else
            {
                ERROR_OUT(("CPluggableConnection::OnPendingWrite: failed to write, err=%d", dwErr));
                NotifyWriteFailure();
                fRet = TRUE; // turn off event
            }
        }
    }
    else
    {
        // it is very possible that we hit this many times
        fRet = TRUE;
    }

    ::LeaveCriticalSection(&g_csTransport);

    return fRet;
}



BOOL CPluggableConnection::SetupReadState(int length)
{
    DBG_SAVE_FILE_LINE
    LPBYTE buffer = new BYTE[length];
    if (NULL != buffer)
    {
        m_pbPendingRead = buffer;
        m_cbPendingRead = length;
        m_fPendingReadDone = FALSE;

        ::ZeroMemory(&m_OverlappedRead, sizeof(m_OverlappedRead));
        m_OverlappedRead.hEvent = m_hevtPendingRead;
    }
    else
    {
        CleanupReadState();
    }
    return (NULL != buffer);
}


void CPluggableConnection::CleanupReadState(void)
{
    delete [] m_pbPendingRead;
    m_pbPendingRead = NULL;
    m_cbPendingRead = 0;
    m_fPendingReadDone = FALSE;

    ::ZeroMemory(&m_OverlappedRead, sizeof(m_OverlappedRead));
}


void CPluggableConnection::CleanupWriteState(void)
{
    delete [] m_pbPendingWrite;
    m_pbPendingWrite = NULL;
    m_cbPendingWrite = 0;

    ::ZeroMemory(&m_OverlappedWrite, sizeof(m_OverlappedWrite));
}



TransportError CALLBACK LegacyTransportCallback(ULONG nMsg, void *Param1, void *Param2)
{
    if (Param2 == g_pPluggableTransport)
    {
        BOOL fPostMsg = FALSE;
        WPARAM wParam = 0;
        CPluggableConnection *p;

        switch (nMsg)
        {
        case TRANSPORT_CONNECT_INDICATION:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_CONNECT_INDICATION"));
            {
                LegacyTransportID *pID = (LegacyTransportID *) Param1;
                p = ::GetPluggableConnection(pID->hCommLink);
                if (NULL != p)
                {
                    p->SetLegacyHandle(pID->logical_handle);

                    {
                        PSocket pSocket = p->GetSocket();
                        ASSERT(NULL != pSocket);
                        if (NULL != pSocket)
                        {
                            pSocket->State = SOCKET_CONNECTED;
                            wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), TRANSPORT_TYPE_PLUGGABLE_PSTN);
                            fPostMsg = TRUE;
                        }
                    }
                }
            }
            break;

        case TRANSPORT_CONNECT_CONFIRM:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_CONNECT_CONFIRM"));
            {
                LegacyTransportID *pID = (LegacyTransportID *) Param1;
                p = ::GetPluggableConnection(pID->hCommLink);
                if (NULL != p)
                {
                    ASSERT(p->GetLegacyHandle() == pID->logical_handle);

                    {
                        PSocket pSocket = p->GetSocket();
                        ASSERT(NULL != pSocket);
                        if (NULL != pSocket)
                        {
                            pSocket->State = X224_CONNECTED;
                            wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), TRANSPORT_TYPE_PLUGGABLE_PSTN);
                            fPostMsg = TRUE;
                        }
                    }
                }
            }
            break;

        case TRANSPORT_DISCONNECT_INDICATION:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_DISCONNECT_INDICATION"));
            {
                LegacyTransportID *pID = (LegacyTransportID *) Param1;
                TransportConnection XprtConn;
                XprtConn.eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
                p = ::GetPluggableConnectionByLegacyHandle(pID->logical_handle);
                if (NULL != p)
                {
                    XprtConn.nLogicalHandle = p->GetConnID();
                }
                ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTED);
                fPostMsg = FALSE;
            }
            break;

        case TRANSPORT_DATA_INDICATION:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_DATA_INDICATION"));
            {
                //
                // This piece of data does not have X.224 framing
                //
                LegacyTransportData *pData = (LegacyTransportData *) Param1;
                TRACE_OUT(("LegacyTransportCallback::pbData=0x%x, cbDataSize=%d", pData->pbData, pData->cbDataSize));

                if (NULL != g_Transport)
                {
                    DBG_SAVE_FILE_LINE
                    TransportData *td = new TransportData;
                    if (NULL != td)
                    {
                        td->transport_connection.eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
                        p = ::GetPluggableConnectionByLegacyHandle(pData->logical_handle);
                        if (NULL != p)
                        {
                            ULONG cbTotalSize = PROTOCOL_OVERHEAD_X224 + pData->cbDataSize;
                            td->transport_connection.nLogicalHandle = p->GetConnID();
                            DBG_SAVE_FILE_LINE
                            td->memory = ::AllocateMemory(NULL, cbTotalSize, RECV_PRIORITY);
                            if (NULL != td->memory)
                            {
                                td->user_data = td->memory->GetPointer();
                                td->user_data_length = cbTotalSize;

                                // take care of the X.224 header
                                ::CopyMemory(td->user_data, g_X224Header, PROTOCOL_OVERHEAD_X224);
                                AddRFCSize(td->user_data, cbTotalSize);
                                // take care of the data
                                ::CopyMemory(td->user_data + PROTOCOL_OVERHEAD_X224, pData->pbData, pData->cbDataSize);

                                wParam = (WPARAM) td;
                                fPostMsg = TRUE;
                            }
                            else
                            {
                                ERROR_OUT(("LegacyTransportCallback: failed to allocate memory, size=%d", cbTotalSize));
                            }
                        }
                    }
                    else
                    {
                        ERROR_OUT(("LegacyTransportCallback: failed to allocate TransportData"));
                    }
                }
            }
            break;

        default:
            wParam = (WPARAM) Param1;
            fPostMsg = TRUE;
            break;
        }

        if (fPostMsg)
        {
            BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_PSTN, wParam, nMsg);
            ASSERT(fRet);
        }
    }

    return TRANSPORT_NO_ERROR;
}


void HandlePSTNCallback(WPARAM wParam, LPARAM lParam)
{
    if (NULL != g_pPluggableTransport)
    {
        CPluggableConnection *p;

        switch (lParam)
        {
        case TRANSPORT_CONNECT_INDICATION:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_CONNECT_INDICATION"));
            if (NULL != g_Transport)
            {
                TransportConnection XprtConn;
                XprtConn.nLogicalHandle = PLUGXPRT_WPARAM_TO_ID(wParam);
                XprtConn.eType = (TransportType) PLUGXPRT_WPARAM_TO_TYPE(wParam);
                ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                g_Transport->ConnectIndication(XprtConn);
            }
            break;

        case TRANSPORT_CONNECT_CONFIRM:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_CONNECT_CONFIRM"));
            if (NULL != g_Transport)
            {
                TransportConnection XprtConn;
                XprtConn.nLogicalHandle = PLUGXPRT_WPARAM_TO_ID(wParam);
                XprtConn.eType = (TransportType) PLUGXPRT_WPARAM_TO_TYPE(wParam);
                ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                g_Transport->ConnectConfirm(XprtConn);
            }
            break;

        case TRANSPORT_DATA_INDICATION:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_DATA_INDICATION"));
            {
                TransportData *td = (TransportData *) wParam;
                if (NULL != g_Transport)
                {
                    g_Transport->DataIndication(td);
                }
                delete td;
            }
            break;

        case TRANSPORT_BUFFER_EMPTY_INDICATION:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_BUFFER_EMPTY_INDICATION"));
            {
                LEGACY_HANDLE logical_handle = (LEGACY_HANDLE) wParam;
                TransportConnection XprtConn;
                XprtConn.eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
                p = ::GetPluggableConnectionByLegacyHandle(logical_handle);
                if (NULL != p)
                {
                    XprtConn.nLogicalHandle = p->GetConnID();
                    g_Transport->BufferEmptyIndication(XprtConn);
                }
            }
            break;

        default:
            ERROR_OUT(("HandlePSTNCallback: unknown message=%d", lParam));
            break;
        }
    }
}


BOOL CPluggableTransport::EnsureLegacyTransportLoaded(void)
{
    if (NULL == g_pLegacyTransport)
    {
        g_hlibMST123 = ::LoadLibrary("MST123.DLL");
        if (NULL != g_hlibMST123)
        {
            LPFN_T123_CreateTransportInterface pfn = (LPFN_T123_CreateTransportInterface)
                    ::GetProcAddress(g_hlibMST123, LPSTR_T123_CreateTransportInterface);
            if (NULL != pfn)
            {
                TransportError rc = (*pfn)(&g_pLegacyTransport);
                if (TRANSPORT_NO_ERROR == rc)
                {
                    ASSERT(NULL != g_pLegacyTransport);

                    // start to call initialize
                    rc = g_pLegacyTransport->TInitialize(LegacyTransportCallback, this);
                    ASSERT(TRANSPORT_NO_ERROR == rc);

                    if (TRANSPORT_NO_ERROR == rc)
                    {
                        return TRUE;
                    }

                    g_pLegacyTransport->TCleanup();
                    g_pLegacyTransport->ReleaseInterface();
                    g_pLegacyTransport = NULL;
                }
            }

            ::FreeLibrary(g_hlibMST123);
            g_hlibMST123 = NULL;
        }

        return FALSE;
    }

    return TRUE;
}


TransportError CPluggableConnection::TConnectRequest(void)
{
    TRACE_OUT(("CPluggableConnection::TConnectRequest"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        TransportConnection XprtConn;
        XprtConn.eType = m_eType;
        XprtConn.nLogicalHandle = m_nConnID;
        ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTING);

        rc = g_pLegacyTransport->TConnectRequest(&m_nLegacyLogicalHandle, m_hCommLink);
    }
    return rc;
}


TransportError CPluggableConnection::TDisconnectRequest(void)
{
    TRACE_OUT(("CPluggableConnection::TDisconnectRequest"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        TransportConnection XprtConn;
        XprtConn.eType = m_eType;
        XprtConn.nLogicalHandle = m_nConnID;
        ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTING);

        ::Sleep(600);
        rc = g_pLegacyTransport->TDisconnectRequest(m_nLegacyLogicalHandle, TRUE);
    }
    return rc;
}


int CPluggableConnection::TDataRequest(LPBYTE pbData, ULONG cbDataSize, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("CPluggableConnection::TDataRequest, pbData=0x%x, cbDataSize=%d", pbData, cbDataSize));
    if (NULL != g_pLegacyTransport)
    {
        *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

        // skip X.224 framing
        ASSERT(cbDataSize > PROTOCOL_OVERHEAD_X224);

        TransportError rc;
        rc = g_pLegacyTransport->TDataRequest(m_nLegacyLogicalHandle,
                                              pbData + PROTOCOL_OVERHEAD_X224,
                                              cbDataSize - PROTOCOL_OVERHEAD_X224);
        if (TRANSPORT_NO_ERROR == rc)
        {
            TRACE_OUT(("CPluggableConnection::TDataRequest: sent data size=%d", cbDataSize));
            return cbDataSize;
        }
    }
    else
    {
        *plug_rc = PLUGXPRT_RESULT_WRITE_FAILED;
    }
    return SOCKET_ERROR;
}


TransportError TReceiveBufferAvailable(void)
{
    TRACE_OUT(("CPluggableConnection::TReceiveBufferAvailable"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        rc = g_pLegacyTransport->TReceiveBufferAvailable();
    }
    return rc;
}


TransportError CPluggableConnection::TPurgeRequest(void)
{
    TRACE_OUT(("CPluggableConnection::TPurgeRequest"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        rc = g_pLegacyTransport->TPurgeRequest(m_nLegacyLogicalHandle);
    }
    return rc;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\refcount.h ===
// File: refcount.h

#ifndef _REFCOUNT_H_
#define _REFCOUNT_H_


//////////////////////////////////////////////////////////////////////////


class RefCount
{
protected:
	ULONG m_ulcRef;

#ifdef DEBUG
	BOOL m_fTrack;
#endif

public:
	RefCount(void);
	// Virtual destructor defers to destructor of derived class.
	virtual ~RefCount(void);

	// IUnknown
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);

#ifdef DEBUG
	VOID SetTrack(BOOL fTrack)  {m_fTrack = fTrack;}
#endif
};


#endif /* _REFCOUNT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\refcount.cpp ===
// File: refcount.cpp
//
// RefCount class

#include "precomp.h"


/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(void)
{
	m_ulcRef = 1;
	TRACE_OUT(("Ref: %08X c=%d (created)", this, m_ulcRef));

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
#ifdef DEBUG
	m_fTrack = FALSE;
#endif
}


RefCount::~RefCount(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	// m_ulcRef may be any value.
	TRACE_OUT(("Ref: %08X c=%d (destroyed)", this, m_ulcRef));

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	ASSERT(m_ulcRef < ULONG_MAX);
	m_ulcRef++;
	TRACE_OUT(("Ref: %08X c=%d (AddRef)", this, m_ulcRef));

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

#ifdef DEBUG
	if (m_fTrack)
	{
		TRACE_OUT(("Obj: %08X c=%d (AddRef)  *** Tracking", this, m_ulcRef));
	}
#endif
	return m_ulcRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	if (m_ulcRef > 0)
	{
		m_ulcRef--;
	}

#ifdef DEBUG
	if (m_fTrack)
	{
		TRACE_OUT(("Obj: %08X c=%d (Release) *** Tracking", this, m_ulcRef));
	}
#endif

	ULONG ulcRef = m_ulcRef;
	TRACE_OUT(("Ref: %08X c=%d (Release)", this, m_ulcRef));

	if (! ulcRef)
	{
		delete this;
	}

	return ulcRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\randchnl.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	randchnl.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the RandomChannelGenerator class,
 *		which inherits from the RandomNumberGenerator class.  On instantiation,
 *		instances of this class will internally generate a random number which
 *		falls within the allowable range of dynamic channels values.  Channel
 *		assignments are then generated by incrementing this value each time a
 *		new assignment is requested.  Once the maximum allowable value has been
 *		assigned, the next value to be generated "wraps around" to the minimum
 *		allowable value.
 *
 *		Obviously, this class does not generate completely random channel
 *		values for each request.  With a completely random generator, it is
 *		possible to delete a channel in MCS, and then have the random number
 *		generator assign the same value as the deleted channel before all
 *		components of the system even know that the channel was deleted to
 *		start with, thus causing erratic behavior in the system.  In this
 *		class, no channel can be reassigned until all other possible channels
 *		have been assigned.
 *
 *		This class can be modifed in the future to incorporate additional
 *		"randomness" into the algorithm and still not reassign any channel
 *		numbers before all other possible values are used.  This, however,
 *		would be at the expense of performance and/or memory resources.
 *                  
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Alan D. May
 */
#include "randchnl.h"

/*
 *	These macros define the mimimum and maximum allowable dynamic channel
 *	values.
 */
#define MINIMUM_DYNAMIC_CHANNEL		1001
#define MAXIMUM_DYNAMIC_CHANNEL		65535

/*
 *	RandomChannelGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random channel
 *		generator object that has been automatically seeded with the current
 *		time.
 */
RandomChannelGenerator::RandomChannelGenerator()
{
	Current_Channel = (GetTickCount() % (MAXIMUM_DYNAMIC_CHANNEL + 1 - MINIMUM_DYNAMIC_CHANNEL)) + MINIMUM_DYNAMIC_CHANNEL;
}

/*
 *	~RandomChannelGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the RandomChannelGenerator class.
 */
RandomChannelGenerator::~RandomChannelGenerator ()
{
}

/*
 *	GetRandomChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method returns a valid dynamic channel number.
 */
RandomValue		RandomChannelGenerator::GetRandomChannel (Void)
{
	/*
	 *	Increment the current channel value.
	 */
	++Current_Channel;

	/*
	 *	Determine if the current channel value needs to wrap around.
	 */	if (Current_Channel > MAXIMUM_DYNAMIC_CHANNEL)
	{
		Current_Channel = MINIMUM_DYNAMIC_CHANNEL;
	}

	/*
	 *	Return the current channel value.
	 */
	return (Current_Channel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\privlist.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/* 
 *	privlist.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the imlpementation file for the class PrivilegeListData. 
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */


#include "privlist.h"



/*
 *	PrivilegeListData ()
 *
 *	Public Function Description
 */
PrivilegeListData::PrivilegeListData(	
								PGCCConferencePrivileges	privilege_list)
{
	Privilege_List = *privilege_list;
}


/*
 *	GetPrivilegeListPDU ()
 *
 *	Public Function Description
 */
PrivilegeListData::PrivilegeListData(	PSetOfPrivileges	set_of_privileges)
{
	PSetOfPrivileges 	privilege_set;
	Privilege			privilege_value;

	Privilege_List.terminate_is_allowed = FALSE;
	Privilege_List.eject_user_is_allowed = FALSE;
	Privilege_List.add_is_allowed = FALSE;
	Privilege_List.lock_unlock_is_allowed = FALSE;
	Privilege_List.transfer_is_allowed = FALSE;

	privilege_set = set_of_privileges;

	while (privilege_set != NULL)
	{
		privilege_value = privilege_set->value;
			
		switch (privilege_value)
		{
			case TERMINATE:
				Privilege_List.terminate_is_allowed = TRUE;
				break;
	
			case EJECT_USER:
				Privilege_List.eject_user_is_allowed = TRUE;
				break;
	
			case ADD:
				Privilege_List.add_is_allowed = TRUE;
				break;
	
			case LOCK_UNLOCK:
				Privilege_List.lock_unlock_is_allowed = TRUE;
				break;
	
			case TRANSFER:
				Privilege_List.transfer_is_allowed = TRUE;
				break;

			default:
				ERROR_OUT(("PrivilegeListData::PrivilegeListData: Bad privilege value=%d", (UINT) privilege_value));
				break;
		}

		privilege_set = privilege_set->next;
	}
}


/*
 *	~PrivilegeListData	()
 *
 *	Public Function Description
 */
PrivilegeListData::~PrivilegeListData()
{
}


/*
 *	GetPrivilegeListData ()
 *
 *	Public Function Description
 */


/*
 *	GetPrivilegeListPDU ()
 *
 *	Public Function Description
 */
GCCError	PrivilegeListData::GetPrivilegeListPDU(
						PSetOfPrivileges		*	set_of_privileges)
{
	GCCError			return_value = GCC_NO_ERROR;
	PSetOfPrivileges	current_privilege = NULL;
	PSetOfPrivileges	next_privilege = NULL;
	Privilege			privilege_value;
	Int					i;
	
	*set_of_privileges = NULL;
	
	for (i = 0; i < NUMBER_OF_PRIVILEGES; i++)
	{
		privilege_value = (Privilege)NUMBER_OF_PRIVILEGES;
	
		switch (i)
		{
			case TERMINATE_IS_ALLOWED:
				if (Privilege_List.terminate_is_allowed )
					privilege_value = TERMINATE;
				break;
	
			case EJECT_USER_IS_ALLOWED:
				if (Privilege_List.eject_user_is_allowed )
					privilege_value = EJECT_USER;
				break;
	
			case ADD_IS_ALLOWED:
				if (Privilege_List.add_is_allowed )
					privilege_value = ADD;
				break;
	
			case LOCK_UNLOCK_IS_ALLOWED:
				if (Privilege_List.lock_unlock_is_allowed )
					privilege_value = LOCK_UNLOCK;
				break;
	
			case TRANSFER_IS_ALLOWED:
				if (Privilege_List.transfer_is_allowed )
					privilege_value = TRANSFER;
				break;

			default:
				ERROR_OUT(("PrivilegeListData::GetPrivilegeListPDU: Bad value"));
				break;
		}
		
		if (privilege_value != NUMBER_OF_PRIVILEGES)
		{
    		DBG_SAVE_FILE_LINE
			next_privilege = new SetOfPrivileges;

			if (next_privilege != NULL)
			{
				next_privilege->value = privilege_value; 
				next_privilege->next = NULL;

				if (*set_of_privileges == NULL)
				{
					*set_of_privileges = next_privilege;
					current_privilege = next_privilege;
				}
				else
				{
					current_privilege->next = next_privilege;
					current_privilege = next_privilege;
				}
					 
			}
			else
			{
				return_value = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	return (return_value);
}


/*
 *	FreePrivilegeListPDU ()
 *
 *	Public Function Description
 */
Void	PrivilegeListData::FreePrivilegeListPDU(
						PSetOfPrivileges			set_of_privileges)
{
	PSetOfPrivileges	current_privilege = NULL;
	PSetOfPrivileges	next_privilege = NULL;
	
	current_privilege = set_of_privileges;
	while (current_privilege != NULL)
	{
		next_privilege = current_privilege->next;
		
		delete current_privilege;
		current_privilege = next_privilege;	
	}
}


/*
 *	IsPrivilegeAvailable ()
 *
 *	Public Function Description
 */
BOOL    PrivilegeListData::IsPrivilegeAvailable (
							ConferencePrivilegeType			privilege_type)
{
	BOOL    return_value = FALSE;
	
	switch (privilege_type)
	{
		case TERMINATE_PRIVILEGE:
			if (Privilege_List.terminate_is_allowed )
				return_value = TRUE;
			break;
			
		case EJECT_USER_PRIVILEGE:
			if (Privilege_List.eject_user_is_allowed )
				return_value = TRUE;
			break;
			
		case ADD_PRIVILEGE:
			if (Privilege_List.add_is_allowed )
				return_value = TRUE;
			break;
			
		case LOCK_UNLOCK_PRIVILEGE:
			if (Privilege_List.lock_unlock_is_allowed )
				return_value = TRUE;
			break;
			
		case TRANSFER_PRIVILEGE:
			if (Privilege_List.transfer_is_allowed )
				return_value = TRUE;
			break;
	}
	
	return (return_value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\registry.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	registry.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the registry class implementation file. All registry operations
 *		at both the Top Provider and subordinate nodes.  It is responsible for
 *		queing registry request, maintaining the registry, sending confirms to
 *		the application SAP, etc.  Registry objects at sub-ordinate nodes are
 *		responsible for queuing up the registry request to be sent on to the
 *		Top Provider.  On of these classes should be created per node.  This
 *		class handles request from all existing application SAPs.
 *
 *		FOR A MORE DETAILED EXPLANATION OF THIS CLASS SEE THE INTERFACE FILE
 *
 *	Private Instance Variables:
 *  	m_pMCSUserObject
 *			Pointer to the User Attachment object used to deliver all registry
 *			request and responses to remote nodes.
 *		m_RegEntryList
 *			This is the list that holds all the registry entries associated 
 *			with this conference.
 *	 	m_fTopProvider
 *			This flag specifies if this is the top provider node (TRUE means
 *			this is the top provider node). 
 *		m_nCurrentTokenID
 *			This is a counter that is used to generate the token IDs by the 
 *			registry object at the top provider.
 *		m_nConfID
 *			Conference ID assocaited with this conference.
 *		m_pEmptyRegItem
 *			This is a pointer to an empty registry item that is used to generate
 *			empty items for PDUs that don't contain a registry item.
 *		m_AppSapEidList2
 *			This list contains pointers to the command target objects associated
 *			with each of the enrolled APEs
 *		m_nRegHandle
 *			This is a counter that is used to generate the handles allocated
 *			by the registry object at the top provider.
 *		m_pAppRosterMgrList
 *			This list hold all the current application roster managers and
 *			is used to verify that a requesting APE is actually enrolled with
 *			the conference.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "registry.h"
#include "appsap.h"

#define		FIRST_DYNAMIC_TOKEN_ID				16384
#define		MAXIMUM_ALLOWABLE_ALLOCATED_HANDLES	(16 * 1024) // for T.126


/*
 *	CRegistry()
 *
 *	Public Function Description
 *		This is the registry constructor.  It is responsible for initializing
 *		instance variables.
 *
 */
CRegistry::CRegistry(PMCSUser						user_object,
					BOOL    						top_provider,
					GCCConfID   					conference_id,
					CAppRosterMgrList				*app_roster_manager_list,
					PGCCError						pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','R','e','g')),
	m_AppSapEidList2(DESIRED_MAX_APP_SAP_ITEMS),
	m_pMCSUserObject(user_object),
	m_fTopProvider(top_provider),
	m_nCurrentTokenID(FIRST_DYNAMIC_TOKEN_ID),
	m_nConfID(conference_id),
	m_nRegHandle(0),
	m_pAppRosterMgrList(app_roster_manager_list)
{
	GCCRegistryItem		registry_item;

	*pRetCode = GCC_NO_ERROR;

	/*
	**	If this is the Top Provider we now build a vacant registry item to
	**	be used when an entry in the registry is being accessed that does not
	**	exists.
	*/
	if (m_fTopProvider)
	{
		registry_item.item_type = GCC_REGISTRY_NONE;
		DBG_SAVE_FILE_LINE
		m_pEmptyRegItem = new CRegItem(&registry_item, pRetCode);
		if (m_pEmptyRegItem == NULL || GCC_NO_ERROR != *pRetCode)
        {
			*pRetCode = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		m_pEmptyRegItem = NULL;
    }
}
        
/*
 *	~CRegistry()
 *
 *	Public Function Description
 *		This is the registry destructor. It is responsible for freeing any
 *		outstanding memory associated with the application registry.
 */
CRegistry::~CRegistry(void)
{
	REG_ENTRY *pRegEntry;

	m_RegEntryList.Reset();

	//	Free up any registry entries
	while (NULL != (pRegEntry = m_RegEntryList.Iterate()))
	{
		if (NULL != pRegEntry->registry_key)
		{
		    pRegEntry->registry_key->Release();
		}
		if (NULL != pRegEntry->entry_item)
		{
		    pRegEntry->entry_item->Release();
		}
		delete pRegEntry;
	}

	if (NULL != m_pEmptyRegItem)
	{
        m_pEmptyRegItem->Release();
	}
}

/*
 *	void	EnrollAPE ()
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of a newly
 *		enrolling APE and its corresponding command target interface.
 */
void CRegistry::EnrollAPE(EntityID eid, CAppSap *pAppSap)
{
    m_AppSapEidList2.Append(eid, pAppSap);
}

/*
 *	void	UnEnrollApplicationSAP ()
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of an 
 *		APE that is unerolling from the conference.
 *
 *	Caveats
 *		This routine removes ownership from all the entries currently owned by 
 *		the passed in application entity.  It will also remove any outstanding
 *		request for the SAP that unenrolled.
 */
void	CRegistry::UnEnrollAPE (	EntityID	entity_id )
{
	REG_ENTRY       *lpRegEntry;
	UserID			my_user_id = m_pMCSUserObject->GetMyNodeID();

	m_RegEntryList.Reset();
	while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
	{
		/*
		**	First we remove this APE from the list of nodes that are
		**	monitoring this entry.
		*/
		lpRegEntry->monitoring_list.Remove(entity_id);

		/*
		**	Next, if this is the top provider, we clean up the the 
		**	ownership properties of this entry and issue any PDUs and/or
		**	messages that are necessary.
		*/
		if (m_fTopProvider)
		{
			if ((lpRegEntry->owner_id == my_user_id) &&
				(lpRegEntry->entity_id == entity_id))
			{
				/*
				**	Ownership is removed from any registry entries this 
				**	entity owned.
				*/
				lpRegEntry->owner_id = 0;
				lpRegEntry->entity_id = 0;
		
				//	Send Monitor Indication if necessary
				if (lpRegEntry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage (lpRegEntry);
				
					m_pMCSUserObject->RegistryMonitorEntryIndication(
							lpRegEntry->registry_key,
							lpRegEntry->entry_item,
							lpRegEntry->owner_id,
							lpRegEntry->entity_id,
							lpRegEntry->modification_rights);
				}
			}
		}
	}

	//	Remove this enity from the command target list if it exists.	
	m_AppSapEidList2.Remove(entity_id);
}

/*
 *	GCCError	RegisterChannel ()
 *
 *	Public Function Description
 *		This routine is responsible for registering a specified channel.
 *		It has two different paths of execution based on whether this is
 *		a Top Provider registry or a subordinate node registry object.
 */
GCCError	CRegistry::RegisterChannel (
										PGCCRegistryKey		registry_key,
										ChannelID			channel_id,
										EntityID			entity_id)
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry; // a must
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CRegItem            *registry_item_data = NULL; // a must
	GCCRegistryItem		registry_item;
	CAppSap	            *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
		return (GCC_APP_NOT_ENROLLED);

	/*
	**	Next set up the Registry Key and Registry Item. Return immediately if
	**	a resource failure occurs.
	*/
	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if (NULL == registry_key_data || GCC_NO_ERROR != rc)
	{
	    ERROR_OUT(("CRegistry::RegisterChannel: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryRegisterChannelRequest(registry_key_data, channel_id, entity_id);

		//	The registry key data object is no longer needed here
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	/*
	**	First check to see if the registry entry exists and if it 
	**	does check the ownership to make sure this node has 
	**	permission to change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		//	Entry already exists, send back negative result
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_REGISTER_CHANNEL_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								GCC_RESULT_ENTRY_ALREADY_EXISTS);

		//	The registry key data object is no longer needed
		registry_key_data->Release();
		rc = GCC_NO_ERROR;
		goto MyExit;
	}

	//	Set up the registry item here
	registry_item.item_type = GCC_REGISTRY_CHANNEL_ID;
	registry_item.channel_id = channel_id;

	DBG_SAVE_FILE_LINE
	registry_item_data = new CRegItem(&registry_item, &rc);
	if (registry_item_data == NULL || GCC_NO_ERROR != rc)
	{
	    ERROR_OUT(("CRegistry::RegisterChannel: can't create regitry item"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Since entry does not exists create it here
	DBG_SAVE_FILE_LINE
	registry_entry = new REG_ENTRY;
	if (registry_entry == NULL)
	{
	    ERROR_OUT(("CRegistry::RegisterChannel: can't create regitry entry"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Fill in the new entry
	registry_entry->registry_key = registry_key_data;
	registry_entry->entry_item = registry_item_data;
	registry_entry->monitoring_state = OFF;
	registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
	registry_entry->entity_id = entity_id;

	/*
	**	Initialize to public incase entry is switched to
	**	a parameter.  Note that as long as the entry is
	**	not a PARAMETER modification rights will not be
	**	used.
	*/
	registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;

	//	Add registry entry to registry list
	m_RegEntryList.Append(registry_entry);

	//	Send success for the result
	requester_sap->RegistryConfirm (
						m_nConfID,
						GCC_REGISTER_CHANNEL_CONFIRM,
						registry_entry->registry_key,
						registry_entry->entry_item,
						registry_entry->modification_rights,
						registry_entry->owner_id,
						registry_entry->entity_id,
						FALSE,
						GCC_RESULT_SUCCESSFUL);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (NULL != registry_key_data)
        {
            registry_key_data->Release();
        }
        if (NULL != registry_item_data)
        {
            registry_item_data->Release();
        }
        delete registry_entry;
    }

	return (rc);
}

/*
 *	GCCError	AssignToken ()
 *
 *	Public Function Description
 *		This routine is responsible for generating and registering a new token.
 *		It has two different paths of execution based on whether this is
 *		a Top Provider registry or a subordinate node registry object.
 */
GCCError	CRegistry::AssignToken (
										PGCCRegistryKey		registry_key,
										EntityID			entity_id )
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry = NULL; // a must
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CRegItem            *registry_item_data = NULL; // a must
	GCCRegistryItem		registry_item;
	CAppSap              *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
		return (GCC_APP_NOT_ENROLLED);

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::AssignToken: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryAssignTokenRequest(registry_key_data, entity_id);

		//	The registry key data object is no longer needed here
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	/*
	**	First check to see if the registry entry exists and if it 
	**	does check the ownership to make sure this node has 
	**	permission to change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		//	Entry already exists, send back negative result
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_ASSIGN_TOKEN_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								GCC_RESULT_ENTRY_ALREADY_EXISTS);

		//	The registry key data object is no longer needed
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

	//	Set up the registry item here
	registry_item.item_type = GCC_REGISTRY_TOKEN_ID;
	registry_item.token_id = GetUnusedToken();

	DBG_SAVE_FILE_LINE
	registry_item_data = new CRegItem(&registry_item, &rc);
	if ((registry_item_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::AssignToken: can't create regitry item"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	DBG_SAVE_FILE_LINE
	registry_entry = new REG_ENTRY;
	if (registry_entry == NULL)
	{
	    ERROR_OUT(("CRegistry::AssignToken: can't create regitry entry"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Fill in the new entry
	registry_entry->registry_key = registry_key_data;
	registry_entry->entry_item = registry_item_data;
	registry_entry->monitoring_state = OFF;
	registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
	registry_entry->entity_id = entity_id;

	/*
	**	Initialize to public incase entry is switched to
	**	a parameter.  Note that as long as the entry is
	**	not a PARAMETER modification rights will not be
	**	used.
	*/
	registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;

	//	Add registry entry to registry list
	m_RegEntryList.Append(registry_entry);

	//	Send success for the result
	requester_sap->RegistryConfirm (
						m_nConfID,
						GCC_ASSIGN_TOKEN_CONFIRM,
						registry_entry->registry_key,
						registry_entry->entry_item,
             			registry_entry->modification_rights,
						registry_entry->owner_id,
						registry_entry->entity_id,
						FALSE,
						GCC_RESULT_SUCCESSFUL);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (NULL != registry_key_data)
        {
            registry_key_data->Release();
        }
        if (NULL != registry_item_data)
        {
            registry_item_data->Release();
        }
        delete registry_entry;
    }

	return (rc);
}

/*
 *	GCCError	SetParameter ()
 *
 *	Public Function Description
 *		This routine is responsible for generating and registering a new token.
 *		It has two different paths of execution based on whether this is
 *		a Top Provider registry or a subordinate node registry object.
 */
GCCError	CRegistry::SetParameter (
								PGCCRegistryKey			registry_key,
								LPOSTR			        parameter_value,
								GCCModificationRights	modification_rights,
								EntityID				entity_id )
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry = NULL; // a must
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CRegItem            *registry_item_data = NULL; // a must
	GCCResult			result;
	GCCRegistryItem		registry_item;
	BOOL    			application_is_enrolled = FALSE;
	CAppSap              *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
		return (GCC_APP_NOT_ENROLLED);

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::SetParameter: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistrySetParameterRequest(registry_key_data,
												parameter_value,
												modification_rights,
												entity_id);

		//	The registry key data object is no longer needed here
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	//	Set up the registry item here
	if (parameter_value != NULL)
	{
		registry_item.item_type = GCC_REGISTRY_PARAMETER;
		registry_item.parameter = *parameter_value;
	}
	else
	{
		registry_item.item_type = GCC_REGISTRY_NONE;
	}

	DBG_SAVE_FILE_LINE
	registry_item_data = new CRegItem(&registry_item, &rc);
	if ((registry_item_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::SetParameter: can't create regitry item"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	/*
	**	First check to see if the registry entry exists and if it 
	**	does check the ownership and modification rights to make 
	**	sure this node has permission to change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		/*
		**	Here we make sure that this request is comming from an 
		**	APE that previously enrolled.  
		*/
		CAppRosterMgr				*lpAppRosterMgr;

		m_pAppRosterMgrList->Reset();
		while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
		{
			if (lpAppRosterMgr->IsAPEEnrolled(registry_key_data->GetSessionKey(),
								            m_pMCSUserObject->GetMyNodeID(),
								            entity_id))
			{
				application_is_enrolled = TRUE;
				break;
			}
		}

		/*
		**	Check ownership rights here: First check is to make
		**	sure that this is the owner if Owner rights is 
		**	specified.  Next check is to make sure that
		*/ 
		if (((registry_entry->modification_rights == GCC_OWNER_RIGHTS) && 
			(registry_entry->owner_id == m_pMCSUserObject->GetMyNodeID()) &&
			 (registry_entry->entity_id == entity_id)) ||
			((registry_entry->modification_rights == GCC_SESSION_RIGHTS) && 
			(application_is_enrolled)) ||
			(registry_entry->modification_rights == GCC_PUBLIC_RIGHTS) ||
			(registry_entry->owner_id == 0))
		{
			/*
			**	Monitoring state should not be affected by 
			**	this request.
			*/
			*registry_entry->entry_item = *registry_item_data;
			
			/*
			**	Only the owner is allowed to change the modification
			**	rights of a registry entry (unless the entry is
			**	unowned). Also if there is no owner, we set up the
			**	new owner here.
			*/
			if (((registry_entry->owner_id == m_pMCSUserObject->GetMyNodeID()) &&
				(registry_entry->entity_id == entity_id)) ||
				(registry_entry->owner_id == 0))
			{
				registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
				registry_entry->entity_id = entity_id;
				/*
				**	If no modification rights are specified we must
				**	set the modification rights to be public.
				*/
				if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
				{
					registry_entry->modification_rights = modification_rights;
				}
			}

			//	Send Monitor Indication if necessary
			if (registry_entry->monitoring_state == ON)
			{
				/*
				**	Deliver the monitor indication to the Top
				**	Provider's Node Controller if necessary.
				*/
				SendMonitorEntryIndicationMessage(registry_entry);

				/*
				**	Broadcast a monitor entry indication to all
				**	nodes in the conference.
				*/
				m_pMCSUserObject->RegistryMonitorEntryIndication(
						registry_entry->registry_key,
						registry_entry->entry_item,
						registry_entry->owner_id,
						registry_entry->entity_id,
						registry_entry->modification_rights);
			}

			//	Send success for the result
			result = GCC_RESULT_SUCCESSFUL;
		}
		else
		{
			result = GCC_RESULT_INDEX_ALREADY_OWNED;
		}

		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_SET_PARAMETER_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
                     			registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								result);

		//	The registry key data object is no longer needed
		registry_key_data->Release();

		//	The registry item data object is no longer needed
		registry_item_data->Release();

		rc = GCC_NO_ERROR;
		goto MyExit;
	}

    // registry entry does not exist, create one.
	DBG_SAVE_FILE_LINE
	registry_entry = new REG_ENTRY;
	if (registry_entry == NULL)
	{
	    ERROR_OUT(("CRegistry::SetParameter: can't create regitry entry"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Fill in the new entry
	registry_entry->registry_key = registry_key_data;
	registry_entry->entry_item = registry_item_data;
	registry_entry->monitoring_state = OFF;
	registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
	registry_entry->entity_id = entity_id;

	/*
	**	If no modification rights are specified we must
	**	initialize the modification rights to be public.
	**	Note that modification rights are only specified
	**	for the SetParameter call.
	*/
	registry_entry->modification_rights =
	        (modification_rights == GCC_NO_MODIFICATION_RIGHTS_SPECIFIED) ?
                GCC_PUBLIC_RIGHTS :
				modification_rights;

	//	Add registry entry to registry list
	m_RegEntryList.Append(registry_entry);

	//	Send success for the result
	requester_sap->RegistryConfirm(
						m_nConfID,
						GCC_SET_PARAMETER_CONFIRM,
						registry_entry->registry_key,
						registry_entry->entry_item,
             			registry_entry->modification_rights,
						registry_entry->owner_id,
						registry_entry->entity_id,
						FALSE,
						GCC_RESULT_SUCCESSFUL);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (NULL != registry_key_data)
        {
            registry_key_data->Release();
        }
        if (NULL != registry_item_data)
        {
            registry_item_data->Release();
        }
        delete registry_entry;
    }

	return (rc);
}

/*
 *	GCCError	RetrieveEntry ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to obtain an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError	CRegistry::RetrieveEntry (
										PGCCRegistryKey		registry_key,
										EntityID			entity_id )
{
	GCCError					rc;
	REG_ENTRY                   *registry_entry;
	CRegKeyContainer       		*registry_key_data = NULL; // a must
	CAppSap                     *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
	}

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::RetrieveEntry: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryRetrieveEntryRequest(registry_key_data, entity_id);
		rc = GCC_NO_ERROR;
		goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		//	Send back a positive result with the entry item
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_RETRIEVE_ENTRY_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								GCC_RESULT_SUCCESSFUL);
	}
	else
	{
		//	Send back a negative result
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_RETRIEVE_ENTRY_CONFIRM,
								registry_key_data,
								m_pEmptyRegItem,
								GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,	//	No owner id
								0,	//	No entity id
								FALSE,
								GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}

    rc = GCC_NO_ERROR;

MyExit:

    if (NULL != registry_key_data)
    {
        registry_key_data->Release();
    }

	return (rc);
}

/*
 *	GCCError	DeleteEntry ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to delete an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError	CRegistry::DeleteEntry (
										PGCCRegistryKey		registry_key,
										EntityID			entity_id )
{
	GCCError			rc;
	REG_ENTRY           *registry_entry;
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CAppSap             *requester_sap;

	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
	}

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::DeleteEntry: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryDeleteEntryRequest(registry_key_data, entity_id);
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	/*
	**	First check to see if the registry entry exists and if it does
	**	check the ownership to make sure this node has permission to
	**	change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		if (((registry_entry->owner_id == m_pMCSUserObject->GetMyNodeID()) &&
			 (registry_entry->entity_id == entity_id)) ||
			(registry_entry->owner_id == 0))
		{
			/*
			**	First convert this to a non-entry incase it needs to
			**	be included in a monitor indication. We first delete
			**	the old entry item and replace it with an Emtpy item.
			*/
			registry_entry->entry_item->Release();
			registry_entry->entry_item = m_pEmptyRegItem;

			registry_entry->owner_id = 0;
			registry_entry->entity_id = 0;
			registry_entry->modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;

			//	Send Monitor Indication if necessary
			if (registry_entry->monitoring_state == ON)
			{
				/*
				**	Deliver the monitor indication to the Top
				**	Provider's Node Controller if necessary.
				*/
				SendMonitorEntryIndicationMessage(registry_entry);

				/*
				**	Broadcast a monitor entry indication to all
				**	nodes in the conference.
				*/
				m_pMCSUserObject->RegistryMonitorEntryIndication(
							registry_entry->registry_key,
							registry_entry->entry_item,
							registry_entry->owner_id,
							registry_entry->entity_id,
							registry_entry->modification_rights);
			}

			m_RegEntryList.Remove(registry_entry);

			if (NULL != registry_entry->registry_key)
			{
			    registry_entry->registry_key->Release();
			}
			delete registry_entry;

			//	Send success for the result
			requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_DELETE_ENTRY_CONFIRM,
								registry_key_data,
								NULL,
								GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
								FALSE,
								GCC_RESULT_SUCCESSFUL);
		}
		else
		{
			//	No ownership rights send back negative result
			requester_sap->RegistryConfirm (
									m_nConfID,
									GCC_DELETE_ENTRY_CONFIRM,
									registry_entry->registry_key,
									registry_entry->entry_item,
									registry_entry->modification_rights,
									registry_entry->owner_id,
									registry_entry->entity_id,
									FALSE,
									GCC_RESULT_INDEX_ALREADY_OWNED);
		}
	}
	else
	{
		//	Send failure for the result. Entry does not exist
		requester_sap->RegistryConfirm (
								m_nConfID,
								GCC_DELETE_ENTRY_CONFIRM,
								registry_key_data,
								NULL,
								GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
								FALSE,
								GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}

    rc = GCC_NO_ERROR;

MyExit:

	//	The registry key data object is no longer needed here
	if (NULL != registry_key_data)
	{
	    registry_key_data->Release();
	}

	return (rc);
}

/*
 *	GCCError	MonitorRequest ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to monitor an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError	CRegistry::MonitorRequest (
							PGCCRegistryKey			registry_key,
							BOOL    				enable_delivery,
							EntityID				entity_id )
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry;
	CRegKeyContainer    *registry_key_data;
	GCCResult			result = GCC_RESULT_SUCCESSFUL;
	CAppSap	            *requester_sap;
    BOOL                fToConfirm = FALSE;

	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
    }

	/*
	**	First set up the Registry Key. Return immediately if a resource 
	**	failure occurs.
	*/
	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data != NULL) && (rc == GCC_NO_ERROR))
	{
		/*
		**	If the request is recieved at a node that is not the top 
		**	provider we must send the request on to the top provider.
		*/
		if (m_fTopProvider == FALSE)
		{
			if (enable_delivery)
			{
				/*
				**	Here we first go ahead and add the requesting APE to the
				**	list of applications wishing to monitor this particular 
				**	entry.  Note that if this entry does not exists at the top 
				**	provider, this entry will be removed during the confirm.
				*/
				rc = AddAPEToMonitoringList(registry_key_data, entity_id, requester_sap);
				if (rc == GCC_NO_ERROR)
				{
					/*
					**	Wait for the response before sending the confirm
					**	if we get this far.
					*/
					m_pMCSUserObject->RegistryMonitorRequest(registry_key_data, entity_id);
				}
				else
				{
					result = GCC_RESULT_RESOURCES_UNAVAILABLE;
					fToConfirm = TRUE;
				}
			}
			else
			{
				RemoveAPEFromMonitoringList(registry_key_data, entity_id);
                result = GCC_RESULT_SUCCESSFUL;
				fToConfirm = TRUE;
			}
		}
		else	//	No PDU is sent when request occurs at the top provider
		{
			if (enable_delivery)
			{
				/*
				**	First check to see if the registry entry exists.  If it does
				**	not we go ahead and create an empty entry so that we can
				**	add the monitoring APE to that entries list of monitoring 
				**	APEs.
				*/
				registry_entry = GetRegistryEntry(registry_key_data);
				if (registry_entry != NULL)
				{
					/*
					**	Here we go ahead and add the requesting APE to the
					**	list of applications wishing to monitor this entry.
					*/
					rc = AddAPEToMonitoringList(registry_key_data, entity_id, requester_sap);
					if (rc == GCC_NO_ERROR)
					{
						//	Set the monitoring state to ON
						registry_entry->monitoring_state = ON;
					}
					else
                    {
						result = GCC_RESULT_RESOURCES_UNAVAILABLE;
                    }
				}
				else
                {
					result = GCC_RESULT_ENTRY_DOES_NOT_EXIST;
                }
			}
			else
			{
				RemoveAPEFromMonitoringList(registry_key_data, entity_id);
			}
			fToConfirm = TRUE;
		}
	}
	else
    {
        ERROR_OUT(("CRegistry::MonitorRequest: can't create registry key"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    if (fToConfirm)
    {
        ASSERT(NULL != registry_key_data);
        requester_sap->RegistryConfirm(
                            m_nConfID,
                            GCC_MONITOR_CONFIRM,
                            registry_key_data,
                            NULL,
                            GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
                            0,
                            0,
                            enable_delivery,
                            result);
    }

	//	The registry key data object is no longer needed
    if (NULL != registry_key_data)
    {
        registry_key_data->Release();
    }

    return (rc);
}

/*
 *	GCCError	AllocateHandleRequest ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to allocate a specified number of
 *		handles from the application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError CRegistry::AllocateHandleRequest(
							UINT					number_of_handles,
							EntityID				entity_id )
{
	UINT				temp_registry_handle;
	CAppSap              *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryAllocateHandleRequest(number_of_handles, entity_id);
	}
	else	//	No PDU is sent when request occurs at the top provider
	{
	    UINT nFirstHandle = 0;
	    GCCResult nResult;
		if ((number_of_handles > 0) &&
			(number_of_handles <= MAXIMUM_ALLOWABLE_ALLOCATED_HANDLES))
		{
			temp_registry_handle = m_nRegHandle + number_of_handles;
			if (temp_registry_handle > m_nRegHandle)
			{
			    nFirstHandle = m_nRegHandle;
			    nResult = GCC_RESULT_SUCCESSFUL;

				m_nRegHandle = temp_registry_handle;
			}
			else
			{
			    ASSERT(0 == nFirstHandle);
			    nResult = GCC_RESULT_NO_HANDLES_AVAILABLE;
			}
		}
		else
		{
		    ASSERT(0 == nFirstHandle);
		    nResult = GCC_RESULT_INVALID_NUMBER_OF_HANDLES;
		}

		requester_sap->RegistryAllocateHandleConfirm (
								m_nConfID,
								number_of_handles,
								nFirstHandle,
								nResult);
	}

	return (GCC_NO_ERROR);
}

/*
 *	GCCError	ProcessRegisterChannelPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register channel PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 */
GCCError	CRegistry::ProcessRegisterChannelPDU (
									CRegKeyContainer    *registry_key_data,
									ChannelID			channel_id,
									UserID				requester_node_id,
									EntityID			requester_entity_id )
{
	GCCError					rc = GCC_NO_ERROR;
	REG_ENTRY                   *registry_entry;
	CRegItem                    *registry_item_data;
	GCCRegistryItem				registry_item;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;
	
	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}

	if (application_is_enrolled)
	{
		/*
		**	Next check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		if (registry_entry != NULL)
		{
			//	Entry already exists, send back negative result
			m_pMCSUserObject->RegistryResponse(
								  	REGISTER_CHANNEL,	
									requester_node_id,
									requester_entity_id,
								   	registry_key_data,
								   	registry_entry->entry_item,
								   	registry_entry->modification_rights,
									registry_entry->owner_id,
									registry_entry->entity_id,
							    	GCC_RESULT_ENTRY_ALREADY_EXISTS);
		}
		else
		{
			registry_item.item_type = GCC_REGISTRY_CHANNEL_ID;
			registry_item.channel_id = channel_id;

			DBG_SAVE_FILE_LINE
			registry_item_data = new CRegItem(&registry_item, &rc);
			if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
			{
				DBG_SAVE_FILE_LINE
				registry_entry = new REG_ENTRY;
				if (registry_entry != NULL)
				{
					//	Fill in the new entry
					DBG_SAVE_FILE_LINE
					registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
					if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
					{
						registry_entry->entry_item = registry_item_data;
						registry_entry->monitoring_state = OFF;
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;
					
						/*
						**	Initialize to public incase entry is switched to
						**	a parameter.  Note that as long as the entry is
						**	not a PARAMETER modification rights will not be
						**	used.
						*/
						registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;
					
						m_RegEntryList.Append(registry_entry);
					
						//	Send success for the result
						m_pMCSUserObject->RegistryResponse(
											REGISTER_CHANNEL,	
											requester_node_id,
											requester_entity_id,
										   	registry_entry->registry_key,
										   	registry_entry->entry_item,
										   	registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									    	GCC_RESULT_SUCCESSFUL);
					}
					else if (registry_entry->registry_key == NULL)
					{
						delete registry_entry;
						registry_item_data->Release();
						rc = GCC_ALLOCATION_FAILURE;
					}
					else
					{
						registry_entry->registry_key->Release();
						delete registry_entry;
						registry_item_data->Release();
					}
				}
				else
                {
					rc = GCC_ALLOCATION_FAILURE;
                }
			}
			else if (registry_item_data == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
			else
            {
				registry_item_data->Release();
            }
		}
	}
	else
	{
		//	Send back negative result stating invalid requester
		m_pMCSUserObject->RegistryResponse(
								REGISTER_CHANNEL,	
								requester_node_id,
								requester_entity_id,
						   		registry_key_data,
						   		NULL,
						   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
					    		GCC_RESULT_INVALID_REQUESTER);
	}

	return (rc);
}

/*
 *	GCCError	ProcessAssignTokenPDU ()			    
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register token PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 */
GCCError	CRegistry::ProcessAssignTokenPDU (
									CRegKeyContainer    *registry_key_data,
									UserID				requester_node_id,
									EntityID			requester_entity_id )
{
	GCCError					rc = GCC_NO_ERROR;
	REG_ENTRY                   *registry_entry;
	CRegItem                    *registry_item_data;
	GCCRegistryItem				registry_item;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;

	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}
	
	if (application_is_enrolled)
	{
		/*
		**	First check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		if (registry_entry != NULL)
		{
			//	Entry already exists, send back negative result
			m_pMCSUserObject->RegistryResponse(ASSIGN_TOKEN,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
											registry_entry->entry_item,
									   		registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									  		GCC_RESULT_ENTRY_ALREADY_EXISTS);
		}
		else
		{
			DBG_SAVE_FILE_LINE
			registry_entry = new REG_ENTRY;
			if (registry_entry != NULL)
			{
				registry_item.item_type = GCC_REGISTRY_TOKEN_ID;
				registry_item.token_id = GetUnusedToken();

				DBG_SAVE_FILE_LINE
				registry_item_data = new CRegItem(&registry_item, &rc);
				if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
				{
					//	Fill in the new entry
					DBG_SAVE_FILE_LINE
					registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
					if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
					{
						registry_entry->entry_item = registry_item_data;
						registry_entry->monitoring_state = OFF;
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;
					
						/*
						**	Initialize to public incase entry is switched to
						**	a parameter.  Note that as long as the entry is
						**	not a PARAMETER modification rights will not be
						**	used.
						*/
						registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;
					
						//	Add registry entry to registry list
						m_RegEntryList.Append(registry_entry);
						
						//	Send success for the result
						m_pMCSUserObject->RegistryResponse(
											ASSIGN_TOKEN,
											requester_node_id,
											requester_entity_id,
									   		registry_key_data,
									   		registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
								    		GCC_RESULT_SUCCESSFUL);
					}
					else  if (registry_entry->registry_key == NULL)
					{
						registry_item_data->Release();
						delete registry_entry;
						rc = GCC_ALLOCATION_FAILURE;
					}
					else
					{
						registry_entry->registry_key->Release();
						registry_item_data->Release();
						delete registry_entry;
					}
				}
				else
				{
					if (registry_item_data == NULL)
                    {
						rc = GCC_ALLOCATION_FAILURE;
                    }
					else
                    {
						registry_item_data->Release();
                    }
						
					delete registry_entry;
				}
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}
	}
	else
	{
		m_pMCSUserObject->RegistryResponse(
								ASSIGN_TOKEN,	
								requester_node_id,
								requester_entity_id,
						   		registry_key_data,
						   		NULL,
						   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
					    		GCC_RESULT_INVALID_REQUESTER);
	}
	
	return (rc);
}

/*
 *	GCCError	ProcessSetParameterPDU ()			    
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register parameter PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 */
GCCError	CRegistry::ProcessSetParameterPDU (
								CRegKeyContainer        *registry_key_data,
								LPOSTR                  parameter_value,
								GCCModificationRights	modification_rights,
								UserID					requester_node_id,
								EntityID				requester_entity_id )
{
	GCCError					rc = GCC_NO_ERROR;
	REG_ENTRY                   *registry_entry;
	CRegItem                    *registry_item_data;
	GCCResult					result;
	GCCRegistryItem				registry_item;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;
	
	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}
	
	if (application_is_enrolled)
	{
		//	Set up the registry item 
		if (parameter_value != NULL)
		{
			registry_item.item_type = GCC_REGISTRY_PARAMETER;
			registry_item.parameter = *parameter_value;
		}
		else
			registry_item.item_type = GCC_REGISTRY_NONE;
			
		/*
		**	Check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		
		if (registry_entry != NULL)
		{
			/*
			**	Here we make sure that this request is comming from an 
			**	APE that previously enrolled in the appropriate session.  
			*/
			m_pAppRosterMgrList->Reset();
			while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
			{
				if (lpAppRosterMgr->IsAPEEnrolled (registry_key_data->GetSessionKey (),
													requester_node_id,
													requester_entity_id))
				{
					application_is_enrolled = TRUE;
					break;
				}
			}

			/*
			**	Check ownership rights here: First check is to make
			**	sure that this is the owner if Owner rights is 
			**	specified.  Next check is to make sure that
			*/ 
			if (((registry_entry->modification_rights == GCC_OWNER_RIGHTS) && 
					(registry_entry->owner_id == requester_node_id) &&
				 	(registry_entry->entity_id == requester_entity_id)) ||
				((registry_entry->modification_rights == GCC_SESSION_RIGHTS) && 
					(application_is_enrolled)) ||
				(registry_entry->modification_rights == GCC_PUBLIC_RIGHTS) ||
				(registry_entry->owner_id == 0))
			{
				DBG_SAVE_FILE_LINE
				registry_item_data = new CRegItem(&registry_item, &rc);
				if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
				{
					//	Monitoring state should not be affected by this request
					*registry_entry->entry_item = *registry_item_data;

					/*
					**	Only the owner is allowed to change the modification
					**	rights of a registry entry (unless the entry is
					**	unowned). Also if there is no owner, we set up the
					**	new owner here.
					*/
					if (((registry_entry->owner_id == requester_node_id) &&
						(registry_entry->entity_id == requester_entity_id)) ||
						(registry_entry->owner_id == 0))
					{
						/*
						**	This will take care of setting up the new owner if 
						**	one exists.
						*/
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;

						/*
						**	If no modification rights are specified we must
						**	set the modification rights to be public.
						*/
						if (modification_rights != 
									GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
						{
							registry_entry->modification_rights = modification_rights;
						}
					}

					//	Send Monitor Indication if necessary
					if (registry_entry->monitoring_state == ON)
					{
						/*
						**	Deliver the monitor indication to the Top
						**	Provider's Node Controller if necessary.
						*/
						SendMonitorEntryIndicationMessage(registry_entry);
						
						/*
						**	Broadcast a monitor entry indication to all
						**	nodes in the conference.
						*/
						m_pMCSUserObject->RegistryMonitorEntryIndication(
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->owner_id,
								registry_entry->entity_id,
								registry_entry->modification_rights);
					}

    			    registry_item_data->Release();

					//	Send success for the result
					result = GCC_RESULT_SUCCESSFUL;
				}
				else if (registry_item_data == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
					result = GCC_RESULT_RESOURCES_UNAVAILABLE;
				}
				else
				{
					registry_item_data->Release();
					result = GCC_RESULT_RESOURCES_UNAVAILABLE;
				}
			}
			else
				result = GCC_RESULT_INDEX_ALREADY_OWNED;

			//	No ownership rights send back negative result
			m_pMCSUserObject->RegistryResponse(SET_PARAMETER,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
											registry_entry->entry_item,
									   		registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									  		result);
		}
		else
		{
			DBG_SAVE_FILE_LINE
			registry_entry = new REG_ENTRY;
			if (registry_entry != NULL)
			{
				DBG_SAVE_FILE_LINE
				registry_item_data = new CRegItem(&registry_item, &rc);
				if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
				{
					//	Fill in the new entry
					DBG_SAVE_FILE_LINE
					registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
					if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
					{
						registry_entry->entry_item = registry_item_data;
						registry_entry->monitoring_state = OFF;
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;

						/*
						**	If no modification rights are specified we must
						**	initialize the modification rights to be public.
						**	Note that modification rights are only specified
						**	for the SetParameter call.
						*/
						if (modification_rights == GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
						{
							registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;
						}
						else
						{
							registry_entry->modification_rights = modification_rights;
						}

						//	Add registry entry to registry list
						m_RegEntryList.Append(registry_entry);

						//	Send success for the result
						m_pMCSUserObject->RegistryResponse(
											SET_PARAMETER,
											requester_node_id,
											requester_entity_id,
									   		registry_key_data,
									   		registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
								    		GCC_RESULT_SUCCESSFUL);
					}
					else  if (registry_entry->registry_key == NULL)
					{
						registry_item_data->Release();
						delete registry_entry;
						rc = GCC_ALLOCATION_FAILURE;
					}
					else
					{
						registry_entry->registry_key->Release();
						registry_item_data->Release();
						delete registry_entry;
					}
				}
				else if (registry_item_data == NULL)
				{
					delete registry_entry;
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}
	}
	else
	{
		m_pMCSUserObject->RegistryResponse(
								SET_PARAMETER,	
								requester_node_id,
								requester_entity_id,
						   		registry_key_data,
						   		NULL,
						   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
					    		GCC_RESULT_INVALID_REQUESTER);
	}
	
	return (rc);
}

/*
 *	void	ProcessRetrieveEntryPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to retrieve a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 */
void	CRegistry::ProcessRetrieveEntryPDU (
										CRegKeyContainer    *registry_key_data,
										UserID				requester_node_id,
										EntityID			requester_entity_id)
{
	REG_ENTRY   *registry_entry;

	registry_entry = GetRegistryEntry (	registry_key_data );

	if (registry_entry != NULL)
	{
		//	Send back a positive result with the entry item
		m_pMCSUserObject->RegistryResponse(RETRIEVE_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
									   	registry_entry->entry_item,
					   					registry_entry->modification_rights,
										registry_entry->owner_id,
										registry_entry->entity_id,
								    	GCC_RESULT_SUCCESSFUL);
	}
	else
	{
		//	Send back a negative result
		m_pMCSUserObject->RegistryResponse(RETRIEVE_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
										m_pEmptyRegItem,
										GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
										0,
										0,
										GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}
}

/*
 *	void	ProcessDeleteEntryPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to delete a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 */
void	CRegistry::ProcessDeleteEntryPDU (
										CRegKeyContainer    *registry_key_data,
										UserID				requester_node_id,
										EntityID			requester_entity_id)
{
	REG_ENTRY                   *registry_entry;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;

	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}

	if (application_is_enrolled)
	{
		/*
		**	First check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		if (registry_entry != NULL)
		{
			if (((registry_entry->owner_id == requester_node_id) &&
				 (registry_entry->entity_id == requester_entity_id)) ||
				(registry_entry->owner_id == NULL))
			{
				m_pMCSUserObject->RegistryResponse(
											DELETE_ENTRY,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
										   	registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									    	GCC_RESULT_SUCCESSFUL);

				/*
				**	First convert this to a non-entry incase it needs to
				**	be included in a monitor indication. We first delete
				**	the old entry item and replace it with an Emtpy item.
				*/
				if (NULL != registry_entry->entry_item)
				{
				    registry_entry->entry_item->Release();
				}
				registry_entry->entry_item = m_pEmptyRegItem;

				registry_entry->owner_id = 0;
				registry_entry->entity_id = 0;
				registry_entry->modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;

				//	Send Monitor Indication if necessary
				if (registry_entry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage(registry_entry);
					
					/*
					**	Broadcast a monitor entry indication to all
					**	nodes in the conference.
					*/
					m_pMCSUserObject->RegistryMonitorEntryIndication(
									registry_entry->registry_key,
									registry_entry->entry_item,
									registry_entry->owner_id,
									registry_entry->entity_id,
									registry_entry->modification_rights);
				}
			
				//	Remove the entry from the list
				m_RegEntryList.Remove(registry_entry);

				if (NULL != registry_entry->registry_key)
				{
				    registry_entry->registry_key->Release();
				}
				delete registry_entry;
			}
			else
			{
				//	No ownership rights send back negative result
				m_pMCSUserObject->RegistryResponse(
											DELETE_ENTRY,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
										   	registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									    	GCC_RESULT_INDEX_ALREADY_OWNED);
			}
		}
		else
		{
			//	Send failure for the result. Entry does not exist
			m_pMCSUserObject->RegistryResponse(
										DELETE_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
										m_pEmptyRegItem,
										GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
										0,
										0,
										GCC_RESULT_ENTRY_DOES_NOT_EXIST);
		}
	}
	else
	{
		m_pMCSUserObject->RegistryResponse(
									DELETE_ENTRY,	
									requester_node_id,
									requester_entity_id,
							   		registry_key_data,
							   		NULL,
							   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
									0,
									0,
						    		GCC_RESULT_INVALID_REQUESTER);
	}
}

/*
 *	void	ProcessMonitorEntryPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to monitor a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 */
void	CRegistry::ProcessMonitorEntryPDU (
							CRegKeyContainer        *registry_key_data,
							UserID					requester_node_id,
							EntityID				requester_entity_id )
{
	REG_ENTRY   *registry_entry;

	/*
	**	First check to see if the registry entry exists and if it does
	**	check the ownership to make sure this node has permission to
	**	change the entry.
	*/
	registry_entry = GetRegistryEntry (	registry_key_data );
	
	if (registry_entry != NULL)
	{
		//	Set the monitoring state to on for the life of this entry.
		registry_entry->monitoring_state = ON;
	
		//	No ownership rights send back negative result
		m_pMCSUserObject->RegistryResponse(MONITOR_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
									   	registry_entry->entry_item,
					   					registry_entry->modification_rights,
										registry_entry->owner_id,
										registry_entry->entity_id,
								    	GCC_RESULT_SUCCESSFUL);
	}
	else
	{
		//	Send failure for the result. Entry does not exist
		m_pMCSUserObject->RegistryResponse(MONITOR_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
										m_pEmptyRegItem,
										GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
										0,
										0,
										GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}
}

/*
 *	void	ProcessRegistryResponsePDU ()
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry responses from the top provider.  It is responsible for 
 *		generating any local messages associated with this response.
 */
void	CRegistry::ProcessRegistryResponsePDU (
							RegistryResponsePrimitiveType	primitive_type,
							CRegKeyContainer                *registry_key_data,
							CRegItem                        *registry_item_data,
							GCCModificationRights			modification_rights,
							EntityID						requester_entity_id,
							UserID							owner_node_id,
							EntityID						owner_entity_id,
							GCCResult						result)
{
	GCCError			error_value = GCC_NO_ERROR;
	GCCMessageType  	message_type;
	CAppSap             *pAppSap;

	//	Pop the next outstanding request off the queue
	if (NULL != (pAppSap = m_AppSapEidList2.Find(requester_entity_id)))
	{
		switch (primitive_type)
		{
			case REGISTER_CHANNEL:
				message_type = GCC_REGISTER_CHANNEL_CONFIRM;
				break;
				
			case ASSIGN_TOKEN:
				message_type = GCC_ASSIGN_TOKEN_CONFIRM;
				break;
				
			case SET_PARAMETER:
				message_type = GCC_SET_PARAMETER_CONFIRM;
				break;
		
			case RETRIEVE_ENTRY:
				message_type = GCC_RETRIEVE_ENTRY_CONFIRM;
				break;
				
			case DELETE_ENTRY:
				message_type = GCC_DELETE_ENTRY_CONFIRM;
				break;
				
			case MONITOR_ENTRY:
				message_type = GCC_MONITOR_CONFIRM;

				/*
				**	Here we must check the result.  If the result failed
				**	we pull the monitoring SAP from the monitor list.
				*/
				if (result != GCC_RESULT_SUCCESSFUL)
				{
					RemoveAPEFromMonitoringList (	registry_key_data,
													requester_entity_id);
				}
				break;

			default:
				error_value = GCC_INVALID_PARAMETER;
				ERROR_OUT(("CRegistry::ProcessRegistryResponsePDU: Bad request type, primitive_type=%d", (UINT) primitive_type));
				break;
		}
		
		if (error_value == GCC_NO_ERROR)
		{
			/*
			**	Note the the monitor enable variable is always set to TRUE
			**	when a monitor response is received from the Top Provider.
			**	Otherwise, this is not even used.
			*/
			pAppSap->RegistryConfirm(m_nConfID,
									message_type,
									registry_key_data,
									registry_item_data,
									modification_rights,
									owner_node_id,
									owner_entity_id,
									TRUE,
									result);
		}
	}
	else
	{
		WARNING_OUT(("CRegistry::ProcessRegistryResponsePDU: no such app sap"));
	}
}

/*
 *	void	ProcessMonitorIndicationPDU ()
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry monitor indications from the top provider.  It is 
 *		responsible for generating any local messages associated with this 
 *		response.
 */
void	CRegistry::ProcessMonitorIndicationPDU (
								CRegKeyContainer        *registry_key_data,
								CRegItem                *registry_item_data,
								GCCModificationRights	modification_rights,
								UserID					owner_node_id,
								EntityID				owner_entity_id)
{
	REG_ENTRY           *lpRegEntry;
	EntityID			eid;
	CAppSap             *pAppSap;

	m_RegEntryList.Reset();
	while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
	{
		if (*registry_key_data == *lpRegEntry->registry_key)
		{
			lpRegEntry->monitoring_list.Reset();
			while (GCC_INVALID_EID != (eid = lpRegEntry->monitoring_list.Iterate()))
			{
				if (NULL != (pAppSap = m_AppSapEidList2.Find(eid)))
				{
					pAppSap->RegistryMonitorIndication(m_nConfID,
														registry_key_data,
														registry_item_data,
														modification_rights,
														owner_node_id,
														owner_entity_id);
				}
			}
		}
	}
}

/*
 *	void	ProcessAllocateHandleRequestPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to allocate a number of handles.  It is responsible for 
 *		returning any necessary responses that must be sent back to the 
 *		requesting node.
 */
void	CRegistry::ProcessAllocateHandleRequestPDU (
							UINT					number_of_handles,
							EntityID				requester_entity_id,
							UserID					requester_node_id)
{
	UINT		temp_registry_handle;

	if (m_fTopProvider)
	{
		if ((number_of_handles > 0) &&
			(number_of_handles <= MAXIMUM_ALLOWABLE_ALLOCATED_HANDLES))
		{
			temp_registry_handle = m_nRegHandle + number_of_handles;
			
			if (temp_registry_handle > m_nRegHandle)
			{
				m_pMCSUserObject->RegistryAllocateHandleResponse(
										number_of_handles,
										m_nRegHandle,
										requester_entity_id,
										requester_node_id,
										GCC_RESULT_SUCCESSFUL);
										
				m_nRegHandle = temp_registry_handle;
			}
			else
			{
				m_pMCSUserObject->RegistryAllocateHandleResponse(
										number_of_handles,
										0,
										requester_entity_id,
										requester_node_id,
										GCC_RESULT_NO_HANDLES_AVAILABLE);
			}
		}
		else
		{
			m_pMCSUserObject->RegistryAllocateHandleResponse(
										number_of_handles,
										0,
										requester_entity_id,
										requester_node_id,
										GCC_RESULT_INVALID_NUMBER_OF_HANDLES);
		}
	}
}

/*
 *	void	ProcessAllocateHandleResponsePDU ()
 *
 *	Public Function Description
 *		This routine is used by a node other than the top provider node to 
 *		process an allocate handle response.  It is responsible for generating 
 *		any local messages associated with this response.
 */
void	CRegistry::ProcessAllocateHandleResponsePDU (
							UINT					number_of_handles,
							UINT					first_handle,
							EntityID				eidRequester,
							GCCResult				result)
{
	CAppSap *pAppSap;

	if (NULL != (pAppSap = m_AppSapEidList2.Find(eidRequester)))
	{
		pAppSap->RegistryAllocateHandleConfirm(m_nConfID,
												number_of_handles,
												first_handle,
												result);
	}
}

/*
 *	void	RemoveNodeOwnership ()
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified node ID.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 */
void	CRegistry::RemoveNodeOwnership (
										UserID				node_id )
{
	if (m_fTopProvider)
	{
		REG_ENTRY   *lpRegEntry;

		m_RegEntryList.Reset();
		while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
		{
			if (lpRegEntry->owner_id == node_id)
			{
				lpRegEntry->owner_id = 0;
				lpRegEntry->entity_id = 0;
			
				//	Send Monitor Indication if necessary
				if (lpRegEntry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage (lpRegEntry);
				
					m_pMCSUserObject->RegistryMonitorEntryIndication(
							lpRegEntry->registry_key,
							lpRegEntry->entry_item,
							lpRegEntry->owner_id,
							lpRegEntry->entity_id,
							lpRegEntry->modification_rights);
				}
			}
		}
	}
}

/*
 *	void	RemoveEntityOwnership ()
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified APE.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 */
void	CRegistry::RemoveEntityOwnership (
										UserID				node_id,
										EntityID			entity_id )
{
	if (m_fTopProvider)
	{
		REG_ENTRY   *lpRegEntry;

		m_RegEntryList.Reset();
		while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
		{
			if ((lpRegEntry->owner_id == node_id) &&
				(lpRegEntry->entity_id == entity_id))
			{
				lpRegEntry->owner_id = 0;
				lpRegEntry->entity_id = 0;
			
				//	Send Monitor Indication if necessary
				if (lpRegEntry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage(lpRegEntry);
				
					m_pMCSUserObject->RegistryMonitorEntryIndication(
							lpRegEntry->registry_key,
							lpRegEntry->entry_item,
							lpRegEntry->owner_id,
							lpRegEntry->entity_id,
							lpRegEntry->modification_rights);
				}
			}
		}
	}
}

/*
 *	void	RemoveSessionKeyReference ()
 *
 *	Public Function Description
 *		This routine removes all registry entries associated with the
 *		specified session.  This is a local operation.
 */
void	CRegistry::RemoveSessionKeyReference(CSessKeyContainer *session_key)
{
	BOOL    		keys_match;
    CRegKeyContainer *registry_key_data;
	
	if (m_fTopProvider)
	{
		/*
		**	This outer loop is to handle resetting the rogue wave iterator.
		**	You can not delete a list entry while in the iterator with out
		**	resetting it.
		*/
		while (1)
		{
			REG_ENTRY   *lpRegEntry;

			keys_match = FALSE;
			m_RegEntryList.Reset();
			while (NULL != (lpRegEntry= m_RegEntryList.Iterate()))
			{
				registry_key_data = lpRegEntry->registry_key;

				if (registry_key_data->IsThisYourSessionKey (session_key))
					keys_match = TRUE;

				if (keys_match)
				{
					/*
					**	First convert this to a non-entry incase it needs to
					**	be included in a monitor indication. We first delete
					**	the old entry item and replace it with an Emtpy item.
					*/
					if (NULL != lpRegEntry->entry_item)
					{
					    lpRegEntry->entry_item->Release();
					}
					lpRegEntry->entry_item = m_pEmptyRegItem;
					lpRegEntry->owner_id = 0;
					lpRegEntry->entity_id = 0;
					lpRegEntry->modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;

					//	Send Monitor Indication if necessary
					if (lpRegEntry->monitoring_state == ON)
					{
						/*
						**	Deliver the monitor indication to the Top
						**	Provider's Node Controller if necessary.
						*/
						SendMonitorEntryIndicationMessage(lpRegEntry);
						
						/*
						**	Broadcast a monitor entry indication to all
						**	nodes in the conference.
						*/
						m_pMCSUserObject->RegistryMonitorEntryIndication(
									lpRegEntry->registry_key,
									lpRegEntry->entry_item,
									lpRegEntry->owner_id,
									lpRegEntry->entity_id,
									lpRegEntry->modification_rights);
					}
		
					if (NULL != lpRegEntry->registry_key)
					{
					    lpRegEntry->registry_key->Release();
					}
					m_RegEntryList.Remove(lpRegEntry);
					delete lpRegEntry;
					break;
				}
			}
			
			if (keys_match == FALSE)
				break;
		}
	}
}

/*
 *	REG_ENTRY *GetRegistryEntry ()
 *
 *	Private Function Description
 *		This routine is responsible for searching the registry list for
 *		the registry entry specified by the passed in registry key.  NULL
 *		is returned if the entry can not be found.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i) Registry key associated with entry to get.
 *
 *	Return Value
 *		Pointer to the registry item assoicated with the specified registry
 *		key.  NULL if it does not exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
REG_ENTRY *CRegistry::GetRegistryEntry(CRegKeyContainer *registry_key_data)
{
	REG_ENTRY           *registry_entry = NULL;
	REG_ENTRY           *lpRegEntry;

	m_RegEntryList.Reset();
	while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
	{
		if (*lpRegEntry->registry_key == *registry_key_data)
		{
			registry_entry = lpRegEntry;
			break;
		}
	}

	return (registry_entry);
}

/*
 *	TokenID GetUnusedToken ()
 *
 *	Private Function Description
 *		This routine is responsible for generating an unused token.  The routine
 *		will return a token ID of zero if all are used up (this is very
 *		unlikely).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The generated token ID.  Zero if no token IDs are available.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
TokenID		CRegistry::GetUnusedToken ()
{
	TokenID				token_id = 0;
	CRegItem            *registry_item_data;
	REG_ENTRY           *lpRegEntry;
	
	while (token_id == 0)
	{
		token_id = m_nCurrentTokenID;
		m_nCurrentTokenID++;
		
		if (m_nCurrentTokenID == (TokenID)0xffff)
        {
			m_nCurrentTokenID = (TokenID)16384;
        }

		m_RegEntryList.Reset();
		while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
		{
			registry_item_data = lpRegEntry->entry_item;
		
			if (registry_item_data->IsThisYourTokenID(token_id))	
			{
				token_id = 0;
				break;
			}
		}
	}
	
	return (token_id);
}

/*
 *	GCCError	AddAPEToMonitoringList ()
 *
 *	Private Function Description
 *		This routine is used to add a new APE to the monitoring list.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with entry being
 *									monitored.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									doing the monitoring.
 *		requester_sap		-	(i)	Pointer to the command target associated 
 *									with APE making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError	CRegistry::AddAPEToMonitoringList(	
									CRegKeyContainer *registry_key_data,
									EntityID		entity_id,
									CAppSap         *requester_sap)
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry;
	BOOL    			entry_does_exists;
	GCCRegistryItem		registry_item;
	
	registry_entry = GetRegistryEntry (registry_key_data);
	
	/*
	**	If the registry does not exists we go ahead and create an empty
	**	entry here.
	*/
	if (registry_entry == NULL)
	{
		DBG_SAVE_FILE_LINE
		registry_entry = new REG_ENTRY;
		if (registry_entry != NULL)
		{
			//	First allocate an empty registry item
			registry_item.item_type = GCC_REGISTRY_NONE;
			DBG_SAVE_FILE_LINE
			registry_entry->entry_item = new CRegItem(&registry_item, &rc);
			if ((registry_entry->entry_item != NULL) && (rc == GCC_NO_ERROR))
			{
				//	Next allocate the registry key
				DBG_SAVE_FILE_LINE
				registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
				if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
				{
					/*
					**	If everything is OK up to here we go ahead and add the
					**	registry entry to the local entry list.
					*/
					m_RegEntryList.Append(registry_entry);
				}
				else if (registry_entry->registry_key == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
					registry_entry->entry_item->Release();
				}
				else
				{
					registry_entry->registry_key->Release();
					registry_entry->entry_item->Release();
				}
			}
			else if (registry_entry->entry_item == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
			else
            {
				registry_entry->entry_item->Release();
            }
			
			if (rc != GCC_NO_ERROR)
            {
				delete registry_entry;
            }
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	
	if (rc == GCC_NO_ERROR)
	{
		m_AppSapEidList2.Append(entity_id, requester_sap);

		/*
		**	Make sure that this entry does not already exists in the
		**	monitoring list.
		*/
		EntityID eid;
		registry_entry->monitoring_list.Reset();
		entry_does_exists = FALSE;
		while (GCC_INVALID_EID != (eid = registry_entry->monitoring_list.Iterate()))
		{
			if (eid == entity_id)
			{
				entry_does_exists = TRUE;
				break;
			}
		}
		
		if (entry_does_exists == FALSE)
		{
			registry_entry->monitoring_list.Append(entity_id);
		}
	}

	return rc;
}

/*
 *	void	RemoveAPEFromMonitoringList ()
 *
 *	Private Function Description
 *		This routine is used to remove an APE from the monitoring list.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with entry being
 *									monitored.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									being removed from the monitoring list.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CRegistry::RemoveAPEFromMonitoringList(	
									CRegKeyContainer        *registry_key_data,
									EntityID				entity_id)
{
	REG_ENTRY   *registry_entry;

	registry_entry = GetRegistryEntry (registry_key_data);
	if (registry_entry != NULL)
	{
		/*
		**	Make sure that this entry does not already exists in the
		**	monitoring list.
		*/
		registry_entry->monitoring_list.Remove(entity_id);
	}
}

/*
 *	void	SendMonitorEntryIndicationMessage ()
 *
 *	Private Function Description
 *		This routine is used to generate a monitor indication to all the
 *		APEs that are currently monitoring the specified registry entry.
 *
 *	Formal Parameters:
 *		registry_entry	-	(i)	Pointer to the registry entry being monitored.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CRegistry::SendMonitorEntryIndicationMessage(REG_ENTRY *registry_entry)
{
    EntityID    eid;
    CAppSap      *pAppSap;

	registry_entry->monitoring_list.Reset();
	while (GCC_INVALID_EID != (eid = registry_entry->monitoring_list.Iterate()))
	{
		if (NULL != (pAppSap = m_AppSapEidList2.Find(eid)))
		{
			pAppSap->RegistryMonitorIndication(
									m_nConfID,
									registry_entry->registry_key,
									registry_entry->entry_item,
									registry_entry->modification_rights,
									registry_entry->owner_id,
									registry_entry->entity_id);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\sap.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);
/*
 *	sap.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CBaseSap.  This class is an
 *		abstract base class for objects that act as Service Access Points (SAPs)
 *		to external applications or the node controller.
 *
 *		This class has two main responsibilities. First, it handles many of the
 *		administrative tasks that are common to all types of SAPs.  These
 *		include handling command target registration responsibilities and
 *		managing the message queue.  It	also handles all of the primitives that
 *		are common between the Control SAP (CControlSAP class) and Application
 *		SAPs (CAppSap class).
 *
 *	Protected Member Functions:
 *		AddToMessageQueue
 *			This routine is used to place messages into the queue of messages
 *			to be sent to applications or the node controller.
 *		CreateDataToBeDeleted
 *			This routine is used to create a structure which holds message data
 *			to be delivered to applications or the node controller.
 *		CopyDataToGCCMessage
 *			This routine is	used to fill in the messages to be delivered to
 *			applications or the node controller with the necessary data.
 *		FreeCallbackMessage
 *			This is a virtual function which is used to free up any data which
 *			was allocated in order to send a callback message.  This function
 *			is overloaded in CControlSAP to free messages which were sent to the
 *			node controller.  It is overloaded in CAppSap to free messages sent
 *			to applications.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */


#include "ms_util.h"
#include "sap.h"
#include "conf.h"
#include "gcontrol.h"
#include "ernccm.hpp"


/*
 *	The node controller SAP handle is always 0.
 */
#define NODE_CONTROLLER_SAP_HANDLE						0

LRESULT CALLBACK SapNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern HINSTANCE g_hDllInst;
extern char g_szGCCWndClassName[24];


/*
 *	CBaseSap::CBaseSap()
 *
 *	Public Function Description
 *		This is the CBaseSap constructor.  The hash list used to hold command
 *		target objects is initialized by this constructor.
 */
#ifdef SHIP_BUILD
CBaseSap::CBaseSap(void)
:
    CRefCount(),
#else
CBaseSap::CBaseSap(DWORD dwStampID)
:
    CRefCount(dwStampID),
#endif
    m_nReqTag(GCC_INVALID_TAG)
{
    //
    // LONCHANC: We have to create the hidden window first
    // because we may need to post PermissionToEnrollIndication
    // to this window for Chat and File Transfer.
    //

    ASSERT(g_szGCCWndClassName[0] == 'G' &&
           g_szGCCWndClassName[1] == 'C' &&
           g_szGCCWndClassName[2] == 'C');
    //
    // Create a hidden window for confirm and indication.
    // CAppSap or CControlSAP should check for the value of m_hwndNotify.
    //
    m_hwndNotify = CreateWindowA(g_szGCCWndClassName, NULL, WS_POPUP,
                        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                        NULL, NULL, g_hDllInst, NULL);

    ASSERT(NULL != m_hwndNotify);
}

CBaseSap::~CBaseSap(void)
{
    //
    // Destroy window and unregister window class
    //
    if (NULL != m_hwndNotify)
    {
        ::DestroyWindow(m_hwndNotify);
    }
}


BOOL CBaseSap::IsThisNodeTopProvider(GCCConfID nConfID)
{
    BOOL   fRet;
    CConf  *pConf;
    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        fRet = pConf->IsConfTopProvider();
    }
    else
    {
        fRet = FALSE;
    }
    return fRet;
}


GCCNodeID CBaseSap::GetTopProvider(GCCConfID nConfID)
{
    GCCNodeID uRet;
    CConf     *pConf;
    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        uRet = pConf->GetTopProvider();
    }
    else
    {
        uRet = 0;
    }
    return uRet;
}


/*
 *	ConfRosterInquire()
 *
 *	Public Function Description
 *		This routine is used to retrieve the conference roster.  This function
 *		just passes this request to the controller via an owner callback.  The
 *		conference roster is delivered to the requesting command target object
 *		in a Conference Roster inquire confirm.
 */
GCCError CBaseSap::
ConfRosterInquire(GCCConfID nConfID, GCCAppSapMsgEx **ppMsgEx)
{
	GCCError  rc;
    CConf     *pConf;

    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
		rc = pConf->ConfRosterInquireRequest(this, ppMsgEx);
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CBaseSap::ConfRosterInquire: can't inquire app roster, rc=%u", (UINT) rc));
            // goto MyExit;
        }
	}
	else
    {
        WARNING_OUT(("CBaseSap::ConfRosterInquire: invalid conf ID=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
    }

	return rc;
}

/*
 *	GCCError   AppRosterInquire()
 *
 *	Public Function Description
 *		This routine is used to retrieve a list of application rosters.  This
 *		function just passes this request to the controller via an owner
 *		callback.  This	list is delivered to the requesting SAP through an
 *		Application Roster inquire confirm message.
 */
GCCError CBaseSap::
AppRosterInquire(GCCConfID          nConfID,
                 GCCSessionKey      *pSessionKey,
                 GCCAppSapMsgEx     **ppMsgEx) // nonzero for sync operation

{
	GCCError  rc;
    CConf     *pConf;

    if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        WARNING_OUT(("CBaseSap::AppRosterInquire: invalid conf ID=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
    }
	else
	{
        CAppRosterMsg  *pAppRosterMsg;
		rc = pConf->AppRosterInquireRequest(pSessionKey, &pAppRosterMsg);
        if (GCC_NO_ERROR == rc)
        {
            AppRosterInquireConfirm(nConfID, pAppRosterMsg, GCC_RESULT_SUCCESSFUL, ppMsgEx);
            pAppRosterMsg->Release();
        }
        else
        {
            ERROR_OUT(("CBaseSap::AppRosterInquire: can't inquire app roster, rc=%u", (UINT) rc));
        }
	}

	return rc;
}

/*
 *	ConductorInquire()
 *
 *	Public Function Description
 *		This routine is called in order to retrieve conductorship information.
 *		The conductorship information is returned in the confirm.
 *
 */
GCCError CBaseSap::ConductorInquire(GCCConfID nConfID)
{
    GCCError    rc;
    CConf       *pConf;

	/*
	**	Make sure the conference exists in the internal list before forwarding
	**	the call on to the conference object.
	*/
	if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
		rc = pConf->ConductorInquireRequest(this);
	}
	else
	{
		rc = GCC_INVALID_CONFERENCE;
	}

	return rc;
}

/*
 *	AppInvoke()
 *
 *	Public Function Description
 *		This routine is called in order to invoke other applications at remote
 *		nodes.  The request is passed on to the appropriate Conference objects.
 */
GCCError CBaseSap::
AppInvoke(GCCConfID             nConfID,
          GCCAppProtEntityList  *pApeList,
          GCCSimpleNodeList     *pNodeList,
          GCCRequestTag         *pnReqTag)
{
	GCCError							rc = GCC_NO_ERROR;
	CInvokeSpecifierListContainer		*invoke_list;
	UINT								i;
	CConf       *pConf;

    DebugEntry(CBaseSap::AppInvoke);

    if (NULL == pApeList || NULL == pNodeList || NULL == pnReqTag)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

    *pnReqTag = GenerateRequestTag();

	if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
		if (pApeList->cApes != 0)
		{
			/*
			**	Create an object which is used to hold the list of application
			**	invoke specifiers.
			*/
			DBG_SAVE_FILE_LINE
			invoke_list = new CInvokeSpecifierListContainer(
									pApeList->cApes,
									pApeList->apApes,
									&rc);
			if ((invoke_list != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				**	Here we must check the destination node list for invalid
				**	node IDs.
				*/
				for (i = 0; i < pNodeList->cNodes; i++)
				{
					if (pNodeList->aNodeIDs[i] < MINIMUM_USER_ID_VALUE)
					{
						rc = GCC_INVALID_MCS_USER_ID;
						goto MyExit;
					}
				}

				/*
				**	If no error has occurred, send the request on to the
				**	command target (conference) object.
				*/
				rc = pConf->AppInvokeRequest(invoke_list, pNodeList, this, *pnReqTag);

				/*
				**	Free here instead of delete in case the object
				**	must persist.
				*/
				invoke_list->Release();
			}
			else if (invoke_list == NULL)
			{
				ERROR_OUT(("CBaseSap::AppInvoke: Error creating new AppInvokeSpecList"));
				rc = GCC_ALLOCATION_FAILURE;
				// goto MyExit;
			}
			else
			{
				invoke_list->Release();
			}
		}
		else
		{
			rc = GCC_BAD_NUMBER_OF_APES;
			// goto MyExit;
		}
	}
	else
	{
		rc = GCC_INVALID_CONFERENCE;
		// goto MyExit;
	}

MyExit:

    DebugExitINT(CBaseSap::AppInvoke, rc);
	return rc;
}


GCCRequestTag CBaseSap::GenerateRequestTag(void)
{
    GCCRequestTag nNewReqTag;

    ASSERT(sizeof(GCCRequestTag) == sizeof(LONG));

    nNewReqTag = ++m_nReqTag;
    if (GCC_INVALID_TAG == nNewReqTag)
    {
        nNewReqTag = ++m_nReqTag;
    }

    // we only take the lower word
    return (nNewReqTag & 0x0000FFFFL);
}




//
// SapNotifyWndProc() is used to notify the sap clients (app in app sap,
// node controller in control sap) in their respective thread.
// The window handle is in CSap::m_hwndNotify.
//
LRESULT CALLBACK
SapNotifyWndProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    LRESULT wnd_rc = 0;

    if (CSAPMSG_BASE <= uMsg && uMsg < CSAPCONFIRM_BASE + MSG_RANGE)
    {
        ASSERT(CSAPMSG_BASE + MSG_RANGE == CSAPCONFIRM_BASE);
        if (uMsg < CSAPMSG_BASE + MSG_RANGE)
        {
            if (((CControlSAP *) lParam) == g_pControlSap)
            {
                g_pControlSap->NotifyProc((GCCCtrlSapMsgEx *) wParam);
            }
            else
            {
                WARNING_OUT(("SapNotifyWndProc: invalid control sap, uMsg=%u, lParam=0x%p, g_pControlSap=0x%p",
                            uMsg, lParam, g_pControlSap));
            }
        }
        else
        {
            ASSERT(CSAPCONFIRM_BASE <= uMsg && uMsg < CSAPCONFIRM_BASE + MSG_RANGE);
            if (NULL != g_pControlSap)
            {
                g_pControlSap->WndMsgHandler(uMsg, wParam, lParam);
            }
            else
            {
                WARNING_OUT(("SapNotifyWndProc: invalid control sap, uMsg=%u, wParam=0x%x, lParam=0x%x",
                            uMsg, (UINT) wParam, (UINT) lParam));
            }
        }
    }
    else
    if (ASAPMSG_BASE <= uMsg && uMsg < ASAPMSG_BASE + MSG_RANGE)
    {
        ASSERT(uMsg == ASAPMSG_BASE + (UINT) ((GCCAppSapMsgEx *) wParam)->Msg.eMsgType);
        ((CAppSap *) lParam)->NotifyProc((GCCAppSapMsgEx *) wParam);
    }
    else
    if (CONFMSG_BASE <= uMsg && uMsg < CONFMSG_BASE + MSG_RANGE)
    {
        ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != ((CConf *) lParam))
        {
            ((CConf *) lParam)->WndMsgHandler(uMsg);
        }
        else
        {
            ERROR_OUT(("SapNotifyWndProc: invalid conf object, uMsg=%u, lParam=0x%x",
                        uMsg, (UINT) lParam));
        }
        ::LeaveCriticalSection(&g_csGCCProvider);
    }
    else
    if (GCTRLMSG_BASE <= uMsg && uMsg < GCTRLMSG_BASE + MSG_RANGE)
    {
        ::EnterCriticalSection(&g_csGCCProvider);
        if (((GCCController *) lParam) == g_pGCCController)
        {
            g_pGCCController->WndMsgHandler(uMsg);
        }
        else
        {
            WARNING_OUT(("SapNotifyWndProc: invalid gcc controller, uMsg=%u, lParam=0x%p, g_pGCCController=0x%p",
                        uMsg, lParam, g_pGCCController));
        }
        ::LeaveCriticalSection(&g_csGCCProvider);
    }
    else
    if (MCTRLMSG_BASE <= uMsg && uMsg < MCTRLMSG_BASE + MSG_RANGE)
    {	
    	void CALLBACK MCSCallBackProcedure (UINT, LPARAM, PVoid);
    	MCSCallBackProcedure (uMsg - MCTRLMSG_BASE, lParam, NULL);
    	/*
    	 *	If the msg contains user data, we need to unlock the
    	 *	memory with it.
    	 */
    	UnlockMemory ((PMemory) wParam);
    }
    else
    if (NCMSG_BASE <= uMsg && uMsg < NCMSG_BASE + MSG_RANGE)
    {
        if (((DCRNCConferenceManager *) wParam) == g_pNCConfMgr)
        {
            g_pNCConfMgr->WndMsgHandler(uMsg, lParam);
        }
        else
        {
            WARNING_OUT(("SapNotifyWndProc: invalid NC ConfMgr, uMsg=%u, lParam=0x%p, g_pNCConfMgr=0x%p",
                        uMsg, lParam, g_pNCConfMgr));
        }
    }
    else
    {
        switch (uMsg)
        {
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
    }

    return wnd_rc;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\regitem.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);

/* 
 *	regitem.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CRegItem.  This 
 *		class manages the data associated with a Registry Item.  Registry Items
 *		are	used to identify a particular entry in the application registry and
 *		may exist in the form of a Channel ID, a Token ID, or an octet string 
 *		parameter.  A CRegItem object holds the data for the first two 
 *		forms in a ChannelID and a TokeID, respectively.  When the registry item
 *		assumes the octet string parameter form, the data is held internally in
 *		a Rogue Wave string object.  
 *
 *	Protected Instance Variables:
 *		m_eItemType
 *			Variable used to indicate whether this registry item is a Channel,
 *			Token, Parameter, or none of these.
 *		m_nChannelID
 *			Variable used to hold the value for the registry item when it
 *			assumes the form of a Channel ID.
 *		m_nTokenID
 *			Variable used to hold the value for the registry item when it
 *			assumes the form of a Token ID.
 *		m_poszParameter
 *			Variable used to hold the value for the registry item when it
 *			assumes the form of a Parameter.
 *		m_RegItemPDU
 *			Storage for the "PDU" form of the registry item.
 *		m_fValidRegItemPDU
 *			Flag indicating that the internal "PDU" registry item has been
 *			filled in.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCRegistryItem structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "ms_util.h"
#include "regitem.h"

/*
 * This macro is used to ensure that the Parameter contained in the Registry
 * Item does not violate the imposed ASN.1 constraint.
 */
#define		MAXIMUM_PARAMETER_LENGTH		64

/*
 *	CRegItem()
 *
 *	Public Function Description:
 *		This constructor is used to create a CRegItem object from
 *		an "API" GCCRegistryItem.
 */
CRegItem::
CRegItem(PGCCRegistryItem registry_item, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','I')),
    m_fValidRegItemPDU(FALSE),
    m_cbDataSize(0),
    m_poszParameter(NULL)
{
	*pRetCode = GCC_NO_ERROR;

	/*
	 * Check to see what type of registry item exists.  Save the registry item
	 * in the internal structure.
	 */
    switch (registry_item->item_type)
    {
    case GCC_REGISTRY_CHANNEL_ID:
		m_eItemType = GCC_REGISTRY_CHANNEL_ID;
		m_nChannelID = registry_item->channel_id;
        break;
    case GCC_REGISTRY_TOKEN_ID:
		m_eItemType = GCC_REGISTRY_TOKEN_ID;
		m_nTokenID = registry_item->token_id;
        break;
    case GCC_REGISTRY_PARAMETER:
		/*
		 * Check to make sure the parameter string does not violate the imposed
		 * ASN.1 constraint.
		 */
		if (registry_item->parameter.length > MAXIMUM_PARAMETER_LENGTH)
		{
			ERROR_OUT(("CRegItem::CRegItem: Error: parameter exceeds allowable length"));
			*pRetCode = GCC_INVALID_REGISTRY_ITEM;
		}
		else
		{
			m_eItemType = GCC_REGISTRY_PARAMETER;
			if (NULL == (m_poszParameter = ::My_strdupO2(
								registry_item->parameter.value,
								registry_item->parameter.length)))
			{
				*pRetCode = GCC_ALLOCATION_FAILURE;
			}
		}
        break;
    default:
		m_eItemType = GCC_REGISTRY_NONE;
        break;
	}
}

/*
 *	CRegItem()
 *
 *	Public Function Description:
 *		This constructor is used to create an CRegItem object from
 *		a "PDU" RegistryItem.
 */
CRegItem::
CRegItem(PRegistryItem registry_item, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','I')),
    m_fValidRegItemPDU(FALSE),
    m_cbDataSize(0),
    m_poszParameter(NULL)
{
	*pRetCode = GCC_NO_ERROR;

	/*
	 * Check to see what type of registry item exists.  Save the registry item
	 * in the internal structure.
	 */
    switch (registry_item->choice)
    {
    case CHANNEL_ID_CHOSEN:
		m_eItemType = GCC_REGISTRY_CHANNEL_ID;
		m_nChannelID = registry_item->u.channel_id;
        break;
    case TOKEN_ID_CHOSEN:
		m_eItemType = GCC_REGISTRY_TOKEN_ID;
		m_nTokenID = registry_item->u.token_id;
        break;
    case PARAMETER_CHOSEN:
		m_eItemType = GCC_REGISTRY_PARAMETER;
		if (NULL == (m_poszParameter = ::My_strdupO2(
							registry_item->u.parameter.value,
							registry_item->u.parameter.length)))
		{
			*pRetCode = GCC_ALLOCATION_FAILURE;
		}
        break;
    default:
		m_eItemType = GCC_REGISTRY_NONE;
        break;
	}
}

/*
 *	CRegItem()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CRegItem object
 *		from another CRegItem object.
 */
CRegItem::
CRegItem(CRegItem *registry_item, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','I')),
    m_fValidRegItemPDU(FALSE),
    m_cbDataSize(0),
    m_poszParameter(NULL)
{
	*pRetCode = GCC_NO_ERROR;

	/*
	 *	Copy pertinent information from the source object's instance variables.
	 */
	m_eItemType = registry_item->m_eItemType;
	m_nChannelID = registry_item->m_nChannelID;
	m_nTokenID = registry_item->m_nTokenID;
	if (NULL != registry_item->m_poszParameter)
	{
		if (NULL == (m_poszParameter = ::My_strdupO(registry_item->m_poszParameter)))
		{
			*pRetCode = GCC_ALLOCATION_FAILURE;
		}
	}
}

/*
 *	~CRegItem()
 *
 *	Public Function Description
 *		The CRegItem destructor has no cleanup responsibilities since
 *		no memory is explicitly allocated by this class.
 *
 */
CRegItem::
~CRegItem(void)
{
	delete m_poszParameter;
}

/*
 *	LockRegistryItemData ()
 *
 *	Public Function Description:
 *		This routine locks the registry item data and determines the amount of
 *		memory referenced by the "API" registry item data structure.
 */
UINT CRegItem::
LockRegistryItemData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the registry item
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Determine the amount of space required to hold the data referenced
		 * by the "API" RegistryItem structure.  Force the size to be on an 
		 * even four-byte boundary.
		 */
		m_cbDataSize = 0;

		if (m_eItemType == GCC_REGISTRY_PARAMETER)
        {
			m_cbDataSize = m_poszParameter->length;
        }

		m_cbDataSize = ROUNDTOBOUNDARY(m_cbDataSize);
	}

	return m_cbDataSize;
}

/*
 *	GetGCCRegistryItemData ()
 *
 *	Public Function Description:
 *		This routine retrieves registry item data in the form of an "API" 
 *		GCCRegistryItem.  This routine is called after "locking" the registry 
 *		item data.
 */
UINT CRegItem::
GetGCCRegistryItemData(PGCCRegistryItem registry_item, LPBYTE memory)
{
	UINT cbDataSizeToRet = 0;
	
	/*
	 * If the registry item data has been locked, fill in the output structure
	 * and the data referenced by the structure.  Otherwise, report that the 
	 * registry item has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written into the memory
		 * provided.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the "API" registry item structure and copy any octet string
		 * data into the output memory block if the registry item is of type
		 * "parameter".
		 */ 
        switch (m_eItemType)
        {
        case GCC_REGISTRY_CHANNEL_ID:
			registry_item->item_type = GCC_REGISTRY_CHANNEL_ID;
			registry_item->channel_id = m_nChannelID;
            break;
        case GCC_REGISTRY_TOKEN_ID:
			registry_item->item_type = GCC_REGISTRY_TOKEN_ID;
			registry_item->token_id = m_nTokenID;
            break;
        case GCC_REGISTRY_PARAMETER:
			registry_item->item_type = GCC_REGISTRY_PARAMETER;
			/*
			 * Fill in the length and pointer of the parameter octet string.
			 */
			registry_item->parameter.length = m_poszParameter->length;
			registry_item->parameter.value = memory;
			/*
			 * Now copy the octet string data from the internal Rogue Wave
			 * string into the allocated memory.
			 */		
			::CopyMemory(memory, m_poszParameter->value, m_poszParameter->length);
		    break;
        default:
			registry_item->item_type = GCC_REGISTRY_NONE;
            break;
		}
	}
	else
	{
		ERROR_OUT(("CRegItem::GetGCCRegistryItemData Error Data Not Locked"));
	}
	
	return cbDataSizeToRet;
}

/*
 *	UnlockRegistryItemData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" registry item once the lock count reaches zero.
 */
void CRegItem::
UnLockRegistryItemData(void)
{
    Unlock();
}

/*
 *	GetRegistryItemDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the registry key from it's internal form of a
 *		"RegistryItemInfo" structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "RegistryItem" structure is 
 *		returned.
 */
void CRegItem::
GetRegistryItemDataPDU(PRegistryItem registry_item)
{
	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidRegItemPDU == FALSE)
	{
		m_fValidRegItemPDU = TRUE;

        switch (m_eItemType)
        {
        case GCC_REGISTRY_CHANNEL_ID:
			m_RegItemPDU.choice = CHANNEL_ID_CHOSEN;
			m_RegItemPDU.u.channel_id = m_nChannelID;
            break;
        case GCC_REGISTRY_TOKEN_ID:
			m_RegItemPDU.choice = TOKEN_ID_CHOSEN;
			m_RegItemPDU.u.token_id = m_nTokenID;
            break;
        case GCC_REGISTRY_PARAMETER:
			m_RegItemPDU.choice = PARAMETER_CHOSEN;
			/*
			 * Fill in the "PDU" parameter string.
			 */
			m_RegItemPDU.u.parameter.length = m_poszParameter->length;
			::CopyMemory(m_RegItemPDU.u.parameter.value, m_poszParameter->value, m_RegItemPDU.u.parameter.length);
            break;
        default:
			m_RegItemPDU.choice = VACANT_CHOSEN;
            break;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*registry_item = m_RegItemPDU;
}

/*
 *	FreeRegistryItemDataPDU ();
 *
 *	Public Function Description:
 *		This routine is used to "free" the "PDU" data for this object.  For
 *		this object, this means setting a flag to indicate that the "PDU" data
 *		for this object is no longer valid.
 */
void CRegItem::
FreeRegistryItemDataPDU(void)
{
	if (m_fValidRegItemPDU)
	{
		/*
		 * No memory is specifically allocated to hold "PDU" data so just set
		 * the flag indicating that PDU registry key data is no longer
		 * allocated.
		 */
		m_fValidRegItemPDU = FALSE;
	}
}


GCCError CRegItem::
CreateRegistryItemData(PGCCRegistryItem *ppRegItem)
{
    GCCError rc;

    DebugEntry(CRegItem::CreateRegistryItemData);

    /*
    **	Here we calculate the length of the bulk data.  This
    **	includes the registry key and registry item.  These objects are
    **	"locked" in order to determine how much bulk memory they will
    **	occupy.
    */
    UINT cbItemSize = ROUNDTOBOUNDARY(sizeof(GCCRegistryItem));
    UINT cbDataSize = LockRegistryItemData() + cbItemSize;
    LPBYTE pData;

    DBG_SAVE_FILE_LINE
    if (NULL != (pData = new BYTE[cbDataSize]))
    {
        *ppRegItem = (PGCCRegistryItem) pData;
        ::ZeroMemory(pData, cbItemSize);

        pData += cbItemSize;
        GetGCCRegistryItemData(*ppRegItem, pData);

        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CRegItem::CreateRegistryItemData: can't create GCCRegistryKey"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    //	UnLock the registry key since it is no longer needed
    UnLockRegistryItemData();

    DebugExitINT(CRegItem::CreateRegistryItemData, rc);
    return rc;
}


/*
 *	IsThisYourTokenID ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified token ID is
 *		held within this registry item object.
 */


/*
 *	operator= ()
 *
 *	Public Function Description:
 *		This routine is used to assign the value of one CRegItem object
 * 		to another.
 */
void CRegItem::operator= (const CRegItem& registry_item_data)	
{
	/*
	 * Free any PDU allocated data so that any subsequent calls to retrieve the
	 * PDU data will cause the PDU structure to be rebuilt.
	 */
	if (m_fValidRegItemPDU)
    {
		FreeRegistryItemDataPDU();
    }

	m_eItemType = registry_item_data.m_eItemType;
	m_nChannelID = registry_item_data.m_nChannelID;
	m_nTokenID = registry_item_data.m_nTokenID;
	if (NULL != registry_item_data.m_poszParameter)
	{
		m_poszParameter = ::My_strdupO(registry_item_data.m_poszParameter);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\t120app.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);

#include "appsap.h"
#include "conf.h"
#include "gcontrol.h"


void CALLBACK MCS_SapCallback(UINT, LPARAM, LPVOID);
void CALLBACK GCC_SapCallback(GCCAppSapMsg *);


T120Error WINAPI T120_CreateAppletSAP
(
    IT120Applet **ppApplet
)
{
    if (NULL != ppApplet)
    {
        *ppApplet = NULL;
        if (NULL != g_pGCCController)
        {
            T120Error rc;
            DBG_SAVE_FILE_LINE
            CApplet *pApplet = new CApplet(&rc);
            if (NULL != pApplet)
            {
                if (T120_NO_ERROR == rc)
                {
                    *ppApplet = (IT120Applet *) pApplet;
                    return T120_NO_ERROR;
                }

                ERROR_OUT(("T120_CreateAppletSAP: CApplet failed, rc=%u", rc));
                pApplet->Release();
                return rc;
            }

            ERROR_OUT(("T120_CreateAppletSAP: cannot create CApplet"));
            return T120_ALLOCATION_FAILURE;
        }

        WARNING_OUT(("T120_CreateAppletSAP: GCC Provider is not initialized."));
        return T120_NOT_INITIALIZED;
    }

    ERROR_OUT(("T120_CreateAppletSAP: callback pfn null"));
    return T120_INVALID_PARAMETER;
}


/* ------ interface methods for applet session ------ */


CAppletSession::CAppletSession
(
    CApplet        *pApplet,
    T120ConfID      nConfID
)
:
    CRefCount(MAKE_STAMP_ID('A','p','p','S')),
    m_pApplet(pApplet),
    m_pAppletContext(NULL),
    m_pSessionContext(NULL),
    m_pfnCallback(NULL),
    m_pMCSAppletSAP(NULL),
    m_nConfID(nConfID),
    m_uidMyself(0),
    m_sidMyself(0),
    m_eidMyself(0),
    m_nidMyself(0),
    m_eState(APPSESS_INITIALIZED),
    m_nArrayIndex(0),
    m_eErrorType(NONE_CHOSEN),
    m_eDynamicChannelJoinState(DCJS_INITIALIZED),
    m_fMCSFreeDataIndBuffer(0),
    m_fFirstRoster(FALSE),
    m_pTempMsg(NULL)
{
    ASSERT(0 != m_nConfID);
    ::ZeroMemory(&m_JoinRequest, sizeof(m_JoinRequest));
    m_pApplet->RegisterSession(this);
}


CAppletSession::~CAppletSession(void)
{
    m_pApplet->UnregisterSession(this);

    FreeJoinRequest(FALSE);

    ASSERT(NULL == m_pfnCallback);
    ASSERT(NULL == m_pAppletContext);
    ASSERT(NULL == m_pSessionContext);
}


void CAppletSession::FreeJoinRequest(BOOL fZeroOut)
{
    delete [] m_JoinRequest.aResourceReqs;

    if (fZeroOut)
    {
        ::ZeroMemory(&m_JoinRequest, sizeof(m_JoinRequest));
    }
}


void CAppletSession::ReleaseInterface(void)
{
    ASSERT(NULL != g_pGCCController);

    Leave();

    m_pfnCallback = NULL;
    m_pAppletContext = NULL;
    m_pSessionContext = NULL;

    Release();
}


void CAppletSession::Advise
(
    LPFN_APPLET_SESSION_CB  pfnCallback,
    LPVOID                  pAppletContext,
    LPVOID                  pSessionContext
)
{
    m_pfnCallback = pfnCallback;
    m_pAppletContext = pAppletContext;
    m_pSessionContext = pSessionContext;
}


void CAppletSession::Unadvise(void)
{
    m_pfnCallback = NULL;
    m_pAppletContext = NULL;
    m_pSessionContext = NULL;
}


BOOL CAppletSession::IsThisNodeTopProvider(void)
{
    return m_pApplet->GetAppSap()->IsThisNodeTopProvider(m_nConfID);
}


T120NodeID CAppletSession::GetTopProvider(void)
{
    return m_pApplet->GetAppSap()->GetTopProvider(m_nConfID);
}


T120Error CAppletSession::Join
(
    T120JoinSessionRequest    *pReq
)
{
    ASSERT(0 != m_nConfID);
    if (NULL != g_pGCCController->GetConfObject(m_nConfID))
    {
        T120Error rc = T120_NO_ERROR;

		// remember the join request, shallow structure copy
		m_JoinRequest = *pReq;

        // we need to duplicate the resource requests because we put the results in place.
        // we have to do this in order to support multiple conferences simultaneously
		if (NULL != pReq->aResourceReqs && 0 != pReq->cResourceReqs)
		{
		    DBG_SAVE_FILE_LINE
		    m_JoinRequest.aResourceReqs = new T120ResourceRequest[m_JoinRequest.cResourceReqs];
		    if (NULL != m_JoinRequest.aResourceReqs)
		    {
		        ::CopyMemory(m_JoinRequest.aResourceReqs, pReq->aResourceReqs,
							sizeof(T120ResourceRequest) * m_JoinRequest.cResourceReqs);
		    }
		    else
		    {
		        ERROR_OUT(("CAppletSession::Join: can't create resource requests"));
		        rc = T120_ALLOCATION_FAILURE;
		    }
		}

        // attach user now
        if (T120_NO_ERROR == rc)
        {
            m_fFirstRoster = FALSE;
            m_fMCSFreeDataIndBuffer = (pReq->dwAttachmentFlags & ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);

            SetState(APPSESS_ATTACH_USER_REQ);
            rc = ::MCS_AttachRequest(&m_pMCSAppletSAP,
                                     (LPBYTE) &m_nConfID, sizeof(m_nConfID),
                                     MCS_SapCallback,
                                     this,
                                     pReq->dwAttachmentFlags);
            ASSERT(T120_NO_ERROR == rc);
        }

        if (T120_NO_ERROR == rc)
        {
            return T120_NO_ERROR;
        }

        FreeJoinRequest(TRUE);
        return rc;
    }

    return GCC_INVALID_CONFERENCE;
}


void CAppletSession::Leave(void)
{
    if (APPSESS_LEAVING != m_eState && APPSESS_LEFT != m_eState)
    {
        APPLET_SESSION_STATE eOldState = m_eState;
        m_eState = APPSESS_LEAVING;

        switch (eOldState)
        {
        case APPSESS_INACTIVELY_ENROLL_REQ:
        case APPSESS_INACTIVELY_ENROLL_CON:
        case APPSESS_RESOURCE_REQ:
        case APPSESS_RESOURCE_CON:
        case APPSESS_ACTIVELY_ENROLL_REQ:
        case APPSESS_ACTIVELY_ENROLL_CON:
        case APPSESS_JOINED:
        default:

            // un-enroll
            DoEnroll(FALSE);
            // fall through

        case APPSESS_ATTACH_USER_REQ:
        case APPSESS_ATTACH_USER_CON:
        case APPSESS_JOIN_MY_CHANNEL_REQ:
        case APPSESS_JOIN_MY_CHANNEL_CON:
        case APPSESS_JOIN_STATIC_CHANNEL_REQ:
        case APPSESS_JOIN_STATIC_CHANNEL_CON:

            if (NULL != m_pMCSAppletSAP)
            {
                m_pMCSAppletSAP->ReleaseInterface();
                m_pMCSAppletSAP = NULL;
            }

            // fall through

        case APPSESS_INITIALIZED:
            m_fMCSFreeDataIndBuffer = 0;
            break;
        }

        m_eState = APPSESS_LEFT;
        m_fFirstRoster = FALSE;
    }

    FreeJoinRequest(TRUE);
}


T120Error CAppletSession::AllocateSendDataBuffer
(
    ULONG       cbBufSize,
    void      **ppBuf
)
{
    if (NULL != m_pMCSAppletSAP)
    {
        return m_pMCSAppletSAP->GetBuffer(cbBufSize, ppBuf);
    }
    return T120_NOT_INITIALIZED;
}


void CAppletSession::FreeSendDataBuffer
(
    void       *pBuf
)
{
    if (NULL != m_pMCSAppletSAP && (! m_fMCSFreeDataIndBuffer))
    {
        m_pMCSAppletSAP->FreeBuffer(pBuf);
    }
    else
    {
        ASSERT(0);
    }
}


T120Error CAppletSession::SendData
(
    DataRequestType             eReqType,
    T120ChannelID               nChannelID,
    T120Priority                ePriority,
    LPBYTE                      pbBuf,
    ULONG                       cbBufSize,
    SendDataFlags               eBufSource
)
{
    if (NULL != m_pMCSAppletSAP)
    {
        return m_pMCSAppletSAP->SendData(eReqType,
                                        nChannelID,
                                        (Priority) ePriority,
                                        pbBuf,
                                        cbBufSize,
                                        eBufSource);
    }
    return T120_NOT_INITIALIZED;
}


T120Error CAppletSession::InvokeApplet
(
    GCCAppProtEntityList   *pApeList,
    GCCSimpleNodeList      *pNodeList,
    T120RequestTag         *pnReqTag
)
{
    return m_pApplet->GetAppSap()->AppInvoke(m_nConfID, pApeList, pNodeList, pnReqTag);
}


T120Error CAppletSession::InquireRoster
(
    GCCSessionKey         *pSessionKey
)
{
    return m_pApplet->GetAppSap()->AppRosterInquire(m_nConfID, pSessionKey, NULL);
}


T120Error CAppletSession::RegistryRequest
(
    T120RegistryRequest     *pReq
)
{
    T120Error rc;
    if (NULL != pReq)
    {
        IGCCAppSap *pAppSap = m_pApplet->GetAppSap();
        ASSERT(NULL != pAppSap);
        GCCRegistryKey *pKey = pReq->pRegistryKey;
        switch (pReq->eCommand)
        {
        case APPLET_REGISTER_CHANNEL:
            rc = pAppSap->RegisterChannel(m_nConfID, pKey, pReq->nChannelID);
            break;
        case APPLET_ASSIGN_TOKEN:
            rc = pAppSap->RegistryAssignToken(m_nConfID, pKey);
            break;
        case APPLET_SET_PARAMETER:
            rc = pAppSap->RegistrySetParameter(m_nConfID, pKey,
                                    pReq->Param.postrValue, pReq->Param.eModifyRights);
            break;
        case APPLET_RETRIEVE_ENTRY:
            rc = pAppSap->RegistryRetrieveEntry(m_nConfID, pKey);
            break;
        case APPLET_DELETE_ENTRY:
            rc = pAppSap->RegistryDeleteEntry(m_nConfID, pKey);
            break;
        case APPLET_ALLOCATE_HANDLE:
            rc = pAppSap->RegistryAllocateHandle(m_nConfID, pReq->cHandles);
            break;
        case APPLET_MONITOR:
            rc = pAppSap->RegistryMonitor(m_nConfID, pReq->fEnableDelivery, pKey);
            break;
        default:
            ERROR_OUT(("CAppletSession::RegistryRequest: invalid command=%u", (UINT) pReq->eCommand));
            rc = T120_INVALID_PARAMETER;
            break;
        }
    }
    else
    {
        rc = T120_INVALID_PARAMETER;
    }
    return rc;
}


T120Error CAppletSession::ChannelRequest
(
    T120ChannelRequest      *pReq
)
{
    T120Error rc;
    if (NULL != pReq)
    {
        T120ChannelID chid = pReq->nChannelID;
        switch (pReq->eCommand)
        {
        case APPLET_JOIN_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelJoin(chid);
            break;
        case APPLET_LEAVE_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelLeave(chid);
            break;
        case APPLET_CONVENE_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelConvene();
            break;
        case APPLET_DISBAND_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelDisband(chid);
            break;
        case APPLET_ADMIT_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelAdmit(chid, pReq->aUsers, pReq->cUsers);
            break;
        default:
            ERROR_OUT(("CAppletSession::ChannelRequest: invalid command=%u", (UINT) pReq->eCommand));
            rc = T120_INVALID_PARAMETER;
            break;
        }
    }
    else
    {
        rc = T120_INVALID_PARAMETER;
    }
    return rc;
}


T120Error CAppletSession::TokenRequest
(
    T120TokenRequest        *pReq
)
{
    //T120TokenID             nTokenID;
    //T120UserID              uidGiveTo;

    T120Error rc;
    if (NULL != pReq)
    {
        T120TokenID tid = pReq->nTokenID;
        switch (pReq->eCommand)
        {
        case APPLET_GRAB_TOKEN:
            rc = m_pMCSAppletSAP->TokenGrab(tid);
            break;
        case APPLET_INHIBIT_TOKEN:
            rc = m_pMCSAppletSAP->TokenInhibit(tid);
            break;
        case APPLET_GIVE_TOKEN:
            rc = m_pMCSAppletSAP->TokenGive(tid, pReq->uidGiveTo);
            break;
        case APPLET_GIVE_TOKEN_RESPONSE:
            rc = m_pMCSAppletSAP->TokenGiveResponse(tid, pReq->eGiveResponse);
            break;
        case APPLET_PLEASE_TOKEN:
            rc = m_pMCSAppletSAP->TokenPlease(tid);
            break;
        case APPLET_RELEASE_TOKEN:
            rc = m_pMCSAppletSAP->TokenRelease(tid);
            break;
        case APPLET_TEST_TOKEN:
            rc = m_pMCSAppletSAP->TokenTest(tid);
            break;
        default:
            ERROR_OUT(("CAppletSession::TokenRequest: invalid command=%u", (UINT) pReq->eCommand));
            rc = T120_INVALID_PARAMETER;
            break;
        }
    }
    else
    {
        rc = T120_INVALID_PARAMETER;
    }
    return rc;
}


/* ------ private methods ------ */


void CAppletSession::SendCallbackMessage
(
    T120AppletSessionMsg          *pMsg
)
{
    ASSERT(NULL != pMsg);
    if (NULL != m_pfnCallback)
    {
        pMsg->pAppletContext = m_pAppletContext;
        pMsg->pSessionContext = m_pSessionContext;
        (*m_pfnCallback)(pMsg);
    }
}


void CAppletSession::SendMCSMessage
(
    T120AppletSessionMsg    *pMsg
)
{
    ASSERT(NULL != pMsg);
    if (NULL != m_pfnCallback)
    {
        pMsg->nConfID = m_nConfID;
        pMsg->pAppletContext = m_pAppletContext;
        pMsg->pSessionContext = m_pSessionContext;
        (*m_pfnCallback)(pMsg);
    }
    else
    {
        if (pMsg->eMsgType == MCS_UNIFORM_SEND_DATA_INDICATION ||
            pMsg->eMsgType == MCS_SEND_DATA_INDICATION)
        {
            if (! m_fMCSFreeDataIndBuffer)
            {
                WARNING_OUT(("CAppletSession::SendMCSMessage: send data ind, free ptr=0x%x, len=%d", pMsg->SendDataInd.user_data.value, pMsg->SendDataInd.user_data.length));
                FreeSendDataBuffer(pMsg->SendDataInd.user_data.value);
            }
        }
    }
}


void CAppletSession::MCSCallback
(
    T120AppletSessionMsg   *pMsg
)
{
    // dispatch the message depeneding on whether we are still in the join process or not
    if (IsJoining())
    {
        SetTempMsg(pMsg);

        switch (pMsg->eMsgType)
        {
        case MCS_ATTACH_USER_CONFIRM:
            HandleAttachUserConfirm();
            break;

        case MCS_CHANNEL_JOIN_CONFIRM:
            HandleJoinChannelConfirm();
            break;

        case MCS_TOKEN_GRAB_CONFIRM:
        	HandleTokenGrabConfirm();
            break;

        }
    }
    else
    {
        SendMCSMessage(pMsg);
    }
}


void CAppletSession::GCCCallback
(
    T120AppletSessionMsg   *pMsg
)
{
    if (IsJoining())
    {
        // remember the current GCC applet SAP message
        SetTempMsg(pMsg);

        switch (pMsg->eMsgType)
        {
        case GCC_ENROLL_CONFIRM:
            HandleEnrollConfirm();
            break;

        case GCC_APP_ROSTER_REPORT_INDICATION:
            if (! m_fFirstRoster)
            {
                if (APPSESS_INACTIVELY_ENROLL_CON == m_eState)
                {
                    DoResourceRequests();
                }
                m_fFirstRoster = TRUE;
            }
            break;

        case GCC_REGISTER_CHANNEL_CONFIRM:
            HandleRegisterChannelConfirm();
            break;

        case GCC_RETRIEVE_ENTRY_CONFIRM:
            HandleRetrieveEntryConfirm();
            break;
        }
    }
    else
    {
        SendCallbackMessage(pMsg);
    }
}


void CAppletSession::SetState(APPLET_SESSION_STATE eNewState)
{
#ifdef _DEBUG
    if (APPSESS_LEAVING != eNewState)
    {
        switch (m_eState)
        {
        case APPSESS_INITIALIZED:
            ASSERT(APPSESS_ATTACH_USER_REQ == eNewState);
            break;
        // attach user
        case APPSESS_ATTACH_USER_REQ:
            ASSERT(APPSESS_ATTACH_USER_CON == eNewState);
            break;
        case APPSESS_ATTACH_USER_CON:
            ASSERT(APPSESS_JOIN_MY_CHANNEL_REQ == eNewState);
            break;
        // join my channel
        case APPSESS_JOIN_MY_CHANNEL_REQ:
            ASSERT(APPSESS_JOIN_MY_CHANNEL_CON == eNewState);
            break;
        case APPSESS_JOIN_MY_CHANNEL_CON:
            ASSERT(APPSESS_JOIN_STATIC_CHANNEL_REQ == eNewState ||
                   APPSESS_INACTIVELY_ENROLL_REQ == eNewState ||
                   APPSESS_ACTIVELY_ENROLL_REQ == eNewState);
            break;
        // join static channels
        case APPSESS_JOIN_STATIC_CHANNEL_REQ:
            ASSERT(APPSESS_JOIN_STATIC_CHANNEL_CON == eNewState);
            break;
        case APPSESS_JOIN_STATIC_CHANNEL_CON:
            ASSERT(APPSESS_JOIN_STATIC_CHANNEL_REQ == eNewState ||
                   APPSESS_INACTIVELY_ENROLL_REQ == eNewState ||
                   APPSESS_ACTIVELY_ENROLL_REQ == eNewState);
            break;
        // enroll applet in order to do resource requests
        case APPSESS_INACTIVELY_ENROLL_REQ:
            ASSERT(APPSESS_INACTIVELY_ENROLL_CON == eNewState);
            break;
        case APPSESS_INACTIVELY_ENROLL_CON:
            ASSERT(APPSESS_RESOURCE_REQ == eNewState);
            break;
        // do resource requests
        case APPSESS_RESOURCE_REQ:
            ASSERT(APPSESS_RESOURCE_CON == eNewState ||
                   APPSESS_ACTIVELY_ENROLL_REQ == eNewState);
            break;
        case APPSESS_RESOURCE_CON:
            ASSERT(APPSESS_RESOURCE_REQ == eNewState);
            break;
        // enroll applet in order to do resource requests
        case APPSESS_ACTIVELY_ENROLL_REQ:
            ASSERT(APPSESS_ACTIVELY_ENROLL_CON == eNewState);
            break;
        case APPSESS_ACTIVELY_ENROLL_CON:
            ASSERT(APPSESS_JOINED == eNewState);
            break;
        // done with the join process
        case APPSESS_JOINED:
            ASSERT(APPSESS_LEAVING == eNewState);
            break; 
        case APPSESS_LEAVING:
            ASSERT(APPSESS_LEFT == eNewState);
            break; 
        default:
            ASSERT(0);
            break;
        } // switch
    } // if
#endif

    m_eState = eNewState;
}


BOOL CAppletSession::IsJoining(void)
{
    return (APPSESS_INITIALIZED < m_eState && m_eState < APPSESS_JOINED);
}


void CAppletSession::HandleAttachUserConfirm(void)
{
    if (MCS_ATTACH_USER_CONFIRM == m_pTempMsg->eMsgType)
    {
        ASSERT(IsJoining());
        SetState(APPSESS_ATTACH_USER_CON);
        if (RESULT_SUCCESSFUL == m_pTempMsg->AttachUserConfirm.eResult)
        {
            m_uidMyself = m_pTempMsg->AttachUserConfirm.nUserID;

            // join my channel
            SetState(APPSESS_JOIN_MY_CHANNEL_REQ);
            T120Error rc = m_pMCSAppletSAP->ChannelJoin(m_uidMyself);
            if (T120_NO_ERROR == rc)
            {
                return;
            }
            SetError(rc);
            AbortJoin();
        }
        else
        {
            SetError(m_pTempMsg->AttachUserConfirm.eResult);
            AbortJoin();
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleAttachUserConfirm: expecting attach user confirm, invalid msg type=%u",
                    m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleTokenGrabConfirm(void)
{
    if (MCS_TOKEN_GRAB_CONFIRM == m_pTempMsg->eMsgType)
    {
        BOOL fImmediateNotification = m_JoinRequest.aResourceReqs[m_nArrayIndex].fImmediateNotification;
        ASSERT(IsJoining());
        switch (GetState())
        {
        case APPSESS_RESOURCE_REQ:
        	ASSERT(APPLET_GRAB_TOKEN_REQUEST == m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand);
            // remember the notification message if needed
            if (fImmediateNotification)
            {
                AddRef();
                SendMCSMessage(m_pTempMsg);
                if (0 == Release())
                {
                    WARNING_OUT(("CAppletSession::HandleTokenGrabConfirm: involuntary exit"));
                    return;
                }
            }

        	SetState(APPSESS_RESOURCE_CON);
            if (RESULT_SUCCESSFUL != m_pTempMsg->TokenConfirm.eResult)
            {
        	    m_JoinRequest.aResourceReqs[m_nArrayIndex].nTokenID = 0; // do not grab it
            }
            DoResourceRequests();
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleTokenGrabConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
}


void CAppletSession::HandleJoinChannelConfirm(void)
{
    if (MCS_CHANNEL_JOIN_CONFIRM == m_pTempMsg->eMsgType)
    {
        ASSERT(IsJoining());
        if (RESULT_SUCCESSFUL == m_pTempMsg->ChannelConfirm.eResult)
        {
            T120ChannelID nChannelID = m_pTempMsg->ChannelConfirm.nChannelID;

            switch (GetState())
            {
            case APPSESS_JOIN_MY_CHANNEL_REQ:
                if (nChannelID == m_uidMyself)
                {
                    SetState(APPSESS_JOIN_MY_CHANNEL_CON);
                    DoJoinStaticChannels();
                }
                else
                {
                    ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: unknown channel join confirm, chid=%x", (UINT) nChannelID));
                }
                break;

            case APPSESS_JOIN_STATIC_CHANNEL_REQ:
                if (nChannelID == m_JoinRequest.aStaticChannels[m_nArrayIndex])
                {
                    SetState(APPSESS_JOIN_STATIC_CHANNEL_CON);
                    DoJoinStaticChannels();
                }
                else
                {
                    ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: unknown channel join confirm, chid=%x", (UINT) nChannelID));
                }
                break;

            case APPSESS_RESOURCE_REQ:
            	// SetState(APPSESS_RESOURCE_CON);
                DoResourceRequests();
                break;

            default:
                ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: unknown state=%u", (UINT) GetState()));
                break;
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: mcs_result=%u", (UINT) m_pTempMsg->ChannelConfirm.eResult));
            SetError(m_pTempMsg->ChannelConfirm.eResult);
            AbortJoin();
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: invalid msg type=%u", (UINT) m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleEnrollConfirm(void)
{
    if (GCC_ENROLL_CONFIRM == m_pTempMsg->eMsgType)
    {
        m_sidMyself = m_pTempMsg->AppEnrollConfirm.sidMyself;
        m_eidMyself = m_pTempMsg->AppEnrollConfirm.eidMyself;
        m_nidMyself = m_pTempMsg->AppEnrollConfirm.nidMyself;

        switch (GetState())
        {
        case APPSESS_ACTIVELY_ENROLL_REQ:
            ASSERT(m_pTempMsg->AppEnrollConfirm.nConfID == m_nConfID);
            SetState(APPSESS_ACTIVELY_ENROLL_CON);
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->AppEnrollConfirm.nResult)
            {
                SetState(APPSESS_JOINED);
                SendJoinResult(GCC_RESULT_SUCCESSFUL);
            }
            else
            {
                ERROR_OUT(("CAppletSession::HandleEnrollConfirm: gcc_result=%u", (UINT) m_pTempMsg->AppEnrollConfirm.nResult));
                SetError(m_pTempMsg->AppEnrollConfirm.nResult);
                AbortJoin();
            }
            break;

        case APPSESS_INACTIVELY_ENROLL_REQ:
            ASSERT(m_pTempMsg->AppEnrollConfirm.nConfID == m_nConfID);
            SetState(APPSESS_INACTIVELY_ENROLL_CON);
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->AppEnrollConfirm.nResult)
            {
                // DoResourceRequests();
            }
            else
            {
                ERROR_OUT(("CAppletSession::HandleEnrollConfirm: gcc_result=%u", (UINT) m_pTempMsg->AppEnrollConfirm.nResult));
                SetError(m_pTempMsg->AppEnrollConfirm.nResult);
                AbortJoin();
            }
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleEnrollConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleEnrollConfirm: expecting enroll confirm, invalid msg type=%u",
                (UINT) m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleRegisterChannelConfirm(void)
{
    if (GCC_REGISTER_CHANNEL_CONFIRM == m_pTempMsg->eMsgType)
    {
        switch (GetState())
        {
        case APPSESS_RESOURCE_REQ:
            DoResourceRequests();
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleRegisterChannelConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleEnrollConfirm: expecting channel register confirm, invalid msg type=%u",
                (UINT) m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleRetrieveEntryConfirm(void)
{
    if (GCC_RETRIEVE_ENTRY_CONFIRM == m_pTempMsg->eMsgType)
    {
        switch (GetState())
        {
        case APPSESS_RESOURCE_REQ:
            DoResourceRequests();
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleRetrieveEntryConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleEnrollConfirm: expecting entry retrieve confirm, invalid msg type=%u",
                (UINT) m_pTempMsg->eMsgType));
    }
}




T120Error CAppletSession::DoEnroll
(
    BOOL        fEnroll,
    BOOL        fEnrollActively
)
{
    T120Error rc;
    T120RequestTag tag;
    GCCEnrollRequest Req;

    Req.pSessionKey = &m_JoinRequest.SessionKey;
    Req.fEnrollActively = fEnrollActively;
    Req.nUserID = m_uidMyself;
    Req.fConductingCapable = m_JoinRequest.fConductingCapable;
    Req.nStartupChannelType = m_JoinRequest.nStartupChannelType;
    Req.cNonCollapsedCaps = m_JoinRequest.cNonCollapsedCaps;
    Req.apNonCollapsedCaps = m_JoinRequest.apNonCollapsedCaps;
    Req.cCollapsedCaps = m_JoinRequest.cCollapsedCaps;
    Req.apCollapsedCaps = m_JoinRequest.apCollapsedCaps;
    Req.fEnroll = fEnroll;

    rc = m_pApplet->GetAppSap()->AppEnroll(m_nConfID, &Req, &tag);
    if (GCC_NO_ERROR == rc)
	{
		return GCC_NO_ERROR;
	}

	if (fEnroll)
	{
	    WARNING_OUT(("CAppletSession::DoEnroll: AppEnroll failed, rc=%u", (UINT) rc));
	    ASSERT(GCC_CONFERENCE_NOT_ESTABLISHED == rc);
		SetError(rc);
		AbortJoin();
	}
	else
	{
		// doing nothing because we don't care we fail to unenroll...
	}
    return rc;
}


void CAppletSession::DoJoinStaticChannels(void)
{
    T120Error rc;
    ASSERT(IsJoining());

    // set up array index
    switch (GetState())
    {
    case APPSESS_JOIN_MY_CHANNEL_CON:
        m_nArrayIndex = 0;
        break;
    case APPSESS_JOIN_STATIC_CHANNEL_CON:
        m_nArrayIndex++;
        break;
    default:
        ERROR_OUT(("CAppletSession::DoJoinStaticChannels: invalid state=%u", (UINT) GetState()));
        break;
    }

    if (m_nArrayIndex < m_JoinRequest.cStaticChannels &&
        NULL != m_JoinRequest.aStaticChannels)
    {
        SetState(APPSESS_JOIN_STATIC_CHANNEL_REQ);
        rc = m_pMCSAppletSAP->ChannelJoin(m_JoinRequest.aStaticChannels[m_nArrayIndex]);
        if (T120_NO_ERROR == rc)
		{
			return;
		}

		ERROR_OUT(("CAppletSession::DoJoinStaticChannels: ChannelJoin failed, rc=%u", (UINT) rc));
        SetError(rc);
        AbortJoin();
    }
    else
    {
		m_nArrayIndex = 0;
        if (m_JoinRequest.cResourceReqs == 0)
        {
            SetState(APPSESS_ACTIVELY_ENROLL_REQ);
            DoEnroll(TRUE, TRUE);
        }
        else
        {
            SetState(APPSESS_INACTIVELY_ENROLL_REQ);
            DoEnroll(TRUE, FALSE);
        }
    }
}


void CAppletSession::DoResourceRequests(void)
{
    //T120Error rc;
    BOOL fInitResourceState = FALSE;
    //ULONG i;

    ASSERT(IsJoining());

    // set up array index
    switch (GetState())
    {
    case APPSESS_INACTIVELY_ENROLL_CON:
        m_nArrayIndex = 0;
        fInitResourceState = TRUE;
        SetState(APPSESS_RESOURCE_REQ);
        break;
    case APPSESS_RESOURCE_REQ:
        // do nothing
        break;
    case APPSESS_RESOURCE_CON:
        m_nArrayIndex++;
        fInitResourceState = TRUE;
        SetState(APPSESS_RESOURCE_REQ);
        break;
    default:
        ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: invalid state=%u", (UINT) GetState()));
        break;
    }

    if (m_nArrayIndex < m_JoinRequest.cResourceReqs)
    {
        ASSERT(NULL != m_JoinRequest.aResourceReqs);
        switch (m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand)
        {
		case APPLET_GRAB_TOKEN_REQUEST:
			DoGrabTokenRequest();
			break;
        case APPLET_JOIN_DYNAMIC_CHANNEL:
            DoJoinDynamicChannels(fInitResourceState);
            break;
        default:
            ERROR_OUT(("CAppletSession::DoResourceRequests: should not get here, state=%u",
                        (UINT) m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand));
            break;
        }
    }
    else
    {
        SetState(APPSESS_ACTIVELY_ENROLL_REQ);
        DoEnroll(TRUE, TRUE);
    }
}

void CAppletSession::DoGrabTokenRequest(void)
{
    T120TokenRequest        Req;

    Req.eCommand = APPLET_GRAB_TOKEN;
    Req.nTokenID = m_JoinRequest.aResourceReqs[m_nArrayIndex].nTokenID;
	TokenRequest(&Req);
}

void CAppletSession::DoJoinDynamicChannels(BOOL fInitState)
{
    T120Error rc;
    //ULONG i;

    ASSERT(IsJoining());
    ASSERT(APPLET_JOIN_DYNAMIC_CHANNEL == m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand);

    if (fInitState)
    {
        m_eDynamicChannelJoinState = DCJS_INITIALIZED;
    }

    switch (m_eDynamicChannelJoinState)
    {
    case DCJS_INITIALIZED:
        // clean up all the dynamic channel id
        m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = 0;

        // start the first dynamic channel negotiation process
        // SetState(APPSESS_JOIN_DYNAMIC_CHANNEL_REQ);
        m_eDynamicChannelJoinState = DCJS_RETRIEVE_ENTRY_REQ;
        rc = m_pApplet->GetAppSap()->RegistryRetrieveEntry(m_nConfID,
                        &m_JoinRequest.aResourceReqs[m_nArrayIndex].RegKey);
        if (T120_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: RegistryRetrieveEntry failed, rc=%u", (UINT) rc));
            SetError(rc);
            AbortJoin();
        }
        break;

    case DCJS_EXISTING_CHANNEL_JOIN_REQ:
        if (MCS_CHANNEL_JOIN_CONFIRM == m_pTempMsg->eMsgType)
        {
            if (m_pTempMsg->ChannelConfirm.nChannelID == m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID)
            {
                m_eDynamicChannelJoinState = DCJS_EXISTING_CHANNEL_JOIN_CON;
                SetState(APPSESS_RESOURCE_CON);
                DoResourceRequests();
            }
            else
            {
                ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: unknown channel join confirm, chid=%x",
                            (UINT) m_pTempMsg->ChannelConfirm.nChannelID));
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting channel join confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

    case DCJS_NEW_CHANNEL_JOIN_REQ:
        if (MCS_CHANNEL_JOIN_CONFIRM == m_pTempMsg->eMsgType)
        {
            ASSERT(0 == m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
            m_eDynamicChannelJoinState = DCJS_NEW_CHANNEL_JOIN_CON;
            // remember the channel id
            m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = m_pTempMsg->ChannelConfirm.nChannelID;
            // try to register this channel
            m_eDynamicChannelJoinState = DCJS_REGISTER_CHANNEL_REQ;
            rc = m_pApplet->GetAppSap()->RegisterChannel(m_nConfID,
                        &m_JoinRequest.aResourceReqs[m_nArrayIndex].RegKey,
                        m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
            if (T120_NO_ERROR != rc)
            {
                ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: RegistryRetrieveEntry failed, rc=%u", (UINT) rc));
                SetError(rc);
                AbortJoin();
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting channel join confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

   case DCJS_RETRIEVE_ENTRY_REQ:
        if (GCC_RETRIEVE_ENTRY_CONFIRM == m_pTempMsg->eMsgType)
        {
            m_eDynamicChannelJoinState = DCJS_RETRIEVE_ENTRY_CON;
            ASSERT(m_nConfID == m_pTempMsg->RegistryConfirm.nConfID);
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->RegistryConfirm.nResult)
            {
                ASSERT(GCC_REGISTRY_CHANNEL_ID == m_pTempMsg->RegistryConfirm.pRegItem->item_type);
                ASSERT(0 != m_pTempMsg->RegistryConfirm.pRegItem->channel_id);
                // remember the existing channel ID
                m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = m_pTempMsg->RegistryConfirm.pRegItem->channel_id;
                // join this channel
                m_eDynamicChannelJoinState = DCJS_EXISTING_CHANNEL_JOIN_REQ;
                rc = m_pMCSAppletSAP->ChannelJoin(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                if (T120_NO_ERROR != rc)
                {
                    ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(%u) failed, rc=%u",
                        (UINT) m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID, (UINT) rc));
                    SetError(rc);
                    AbortJoin();
                }
            }
            else
            {
                ASSERT(GCC_RESULT_ENTRY_DOES_NOT_EXIST == m_pTempMsg->RegistryConfirm.nResult);
                ASSERT(0 == m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                // allocate a new channel
                m_eDynamicChannelJoinState = DCJS_NEW_CHANNEL_JOIN_REQ;
                rc = m_pMCSAppletSAP->ChannelJoin(0);
                if (T120_NO_ERROR != rc)
                {
                    ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(0) failed, rc=%u", (UINT) rc));
                    SetError(rc);
                    AbortJoin();
                }
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting entry retrieve confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

    case DCJS_REGISTER_CHANNEL_REQ:
        if (GCC_REGISTER_CHANNEL_CONFIRM == m_pTempMsg->eMsgType)
        {
            ASSERT(0 != m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
            m_eDynamicChannelJoinState = DCJS_REGISTER_CHANNEL_CON;
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->RegistryConfirm.nResult)
            {
                ASSERT(GCC_REGISTRY_CHANNEL_ID == m_pTempMsg->RegistryConfirm.pRegItem->item_type);
                ASSERT(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID == m_pTempMsg->RegistryConfirm.pRegItem->channel_id);
                SetState(APPSESS_RESOURCE_CON);
                DoResourceRequests();
            }
            else
            if (GCC_RESULT_ENTRY_ALREADY_EXISTS == m_pTempMsg->RegistryConfirm.nResult)
            {
                ASSERT(GCC_REGISTRY_CHANNEL_ID == m_pTempMsg->RegistryConfirm.pRegItem->item_type);
                // leave the old channel (DON'T CARE ABOUT THE CONFIRM)
                rc = m_pMCSAppletSAP->ChannelLeave(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                ASSERT(T120_NO_ERROR == rc);
                // remember the new channel id
                m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = m_pTempMsg->RegistryConfirm.pRegItem->channel_id;
                // join the new channel
                m_eDynamicChannelJoinState = DCJS_EXISTING_CHANNEL_JOIN_REQ;
                rc = m_pMCSAppletSAP->ChannelJoin(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                if (T120_NO_ERROR != rc)
                {
                    ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(0) failed, rc=%u", (UINT) rc));
                    SetError(rc);
                    AbortJoin();
                }
            }
            else
            {
                ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(0) failed, result=%u",
                            (UINT) m_pTempMsg->RegistryConfirm.nResult));
                SetError(m_pTempMsg->RegistryConfirm.nResult);
                AbortJoin();
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting channel register confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

    default:
        ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: should not get here, state=%u", (UINT) m_eDynamicChannelJoinState));
        break;
    }
}


void CAppletSession::AbortJoin(void)
{
    T120Result eResult = T120_RESULT_CHECK_T120_ERROR;
    T120Error eError = T12_ERROR_CHECK_T120_RESULT;

    switch (m_eErrorType)
    {
    case NONE_CHOSEN:
        ERROR_OUT(("CAppletSession::AbortJoin: NON_CHOSEN, impossible"));
        break;
    case ERROR_CHOSEN:
        eError = m_Error.eError;
        break;
    case RESULT_CHOSEN:
        eResult = m_Error.eResult;
        break;
    default:
        ERROR_OUT(("CAppletSession::AbortJoin: invalid err type=%u", (UINT) m_eErrorType));
        break;
    }

    // let's debug why the join process is aborted.
    WARNING_OUT(("CAppletSession::AbortJoin: eResult=%u, eError=%u", eResult, eError));
    ASSERT(GCC_CONFERENCE_NOT_ESTABLISHED == eError ||
           T12_ERROR_CHECK_T120_RESULT == eError);

    SendJoinResult(eResult, eError);
}


void CAppletSession::SendJoinResult(T120Result eResult, T120Error eError)
{
    T120AppletSessionMsg Msg;
    ::ZeroMemory(&Msg, sizeof(Msg));

    Msg.eMsgType = T120_JOIN_SESSION_CONFIRM;
    Msg.nConfID = m_nConfID;
    Msg.JoinSessionConfirm.eResult = eResult;
    Msg.JoinSessionConfirm.eError = eError;
    Msg.JoinSessionConfirm.pIAppletSession = (IT120AppletSession *) this;

    if (T120_RESULT_SUCCESSFUL == eResult)
    {
        Msg.JoinSessionConfirm.uidMyself = m_uidMyself;
        Msg.JoinSessionConfirm.sidMyself = m_sidMyself;
        Msg.JoinSessionConfirm.eidMyself = m_eidMyself;
        Msg.JoinSessionConfirm.nidMyself = m_nidMyself;
        Msg.JoinSessionConfirm.cResourceReqs = m_JoinRequest.cResourceReqs;
        Msg.JoinSessionConfirm.aResourceReqs = m_JoinRequest.aResourceReqs;
    }

    SendCallbackMessage(&Msg);
}



CApplet::CApplet
(
    T120Error   *pRetCode
)
:
    CRefCount(MAKE_STAMP_ID('C','A','p','l')),
    m_pfnCallback(NULL),
    m_pAppletContext(NULL),
    m_pAppSap(NULL),
    m_pAutoJoinReq(NULL),
    m_pAutoAppletSession(NULL)
{
    *pRetCode = ::GCC_CreateAppSap(&m_pAppSap, this, GCC_SapCallback);
}


CApplet::~CApplet(void)
{
    ASSERT(NULL == m_pfnCallback);
    ASSERT(NULL == m_pAppletContext);
    ASSERT(NULL == m_pAppSap);
}


void CApplet::ReleaseInterface(void)
{
	Unadvise();

    if (NULL != m_pAppSap)
    {
        m_pAppSap->ReleaseInterface();
        m_pAppSap = NULL;
    }

    Release();
}


void CApplet::Advise
(
    LPFN_APPLET_CB      pfnCallback,
    LPVOID              pAppletContext
)
{
    ASSERT(NULL == m_pfnCallback);
    ASSERT(NULL == m_pAppletContext);
    m_pfnCallback = pfnCallback;
    m_pAppletContext = pAppletContext;

	// this may incur permit to enroll indication
	g_pGCCController->RegisterApplet(this);
}


void CApplet::Unadvise(void)
{
    m_pfnCallback = NULL;
    m_pAppletContext = NULL;

    if (g_pGCCController)
    {
        g_pGCCController->UnregisterApplet(this);
    }
}


T120Error CApplet::RegisterAutoJoin
(
    T120JoinSessionRequest *pReq
)
{
    m_pAutoJoinReq = pReq;
    return T120_NO_ERROR;
}


void CApplet::UnregisterAutoJoin(void)
{
    m_pAutoJoinReq = NULL;
}


T120Error CApplet::CreateSession
(
    IT120AppletSession    **ppSession,
    T120ConfID              nConfID
)
{
    if (NULL != ppSession)
    {
        if (NULL != g_pGCCController->GetConfObject(nConfID))
        {
            if (! FindSessionByConfID(nConfID))
            {
                DBG_SAVE_FILE_LINE
                *ppSession = (IT120AppletSession *) new CAppletSession(this, nConfID);
                if (NULL != *ppSession)
                {
                    return T120_NO_ERROR;
                }

                ERROR_OUT(("CApplet::CreateSession: cannot create CAppletSession"));
                return T120_ALLOCATION_FAILURE;
            }

            WARNING_OUT(("CApplet::CreateSession: session already exists for nConfID=%u", (UINT) nConfID));
            return GCC_CONFERENCE_ALREADY_EXISTS;
        }

        WARNING_OUT(("CApplet::CreateSession: invalid conf, nConfID=%u", (UINT) nConfID));
        return GCC_INVALID_CONFERENCE;
    }

    ERROR_OUT(("CApplet::CreateSession: ppSession is null"));
    return T120_INVALID_PARAMETER;
}


void CApplet::SendCallbackMessage(T120AppletMsg *pMsg)
{
    if (NULL != m_pfnCallback)
    {
        pMsg->pAppletContext = m_pAppletContext;
        (*m_pfnCallback)(pMsg);
    }
}


void CApplet::GCCCallback
(
    T120AppletSessionMsg    *pMsg
)
{
    T120ConfID nConfID = pMsg->nConfID;
    ASSERT(0 != nConfID);

    if (GCC_PERMIT_TO_ENROLL_INDICATION == pMsg->eMsgType)
    {
        T120AppletMsg *p = (T120AppletMsg *) pMsg;
        if (p->PermitToEnrollInd.fPermissionGranted && NULL != m_pAutoJoinReq)
        {
            HandleAutoJoin(nConfID);
        }
        else
        {
            if (! p->PermitToEnrollInd.fPermissionGranted)
            {
                CAppletSession *pAppletSession = FindSessionByConfID(nConfID);
                if (NULL != pAppletSession)
                {
                    if (pAppletSession->IsJoining())
                    {
                        pAppletSession->SetError(GCC_CONFERENCE_NOT_ESTABLISHED);
                        pAppletSession->AbortJoin();
                    }
                }
            }
            SendCallbackMessage(p);
        }
    }
    else
    {
        CAppletSession *pAppletSession = FindSessionByConfID(nConfID);
        if (NULL != pAppletSession)
        {
            pAppletSession->GCCCallback(pMsg);
        }
        else
        {
            WARNING_OUT(("GCC_SapCallback: cannot find a session (%u) for this gcc message (%u)",
                        (UINT) nConfID, (UINT) pMsg->eMsgType));
        }
    }
}


void CALLBACK AutoJoinCallbackProc
(
    T120AppletSessionMsg *pMsg
)
{
    switch (pMsg->eMsgType)
    {
    case T120_JOIN_SESSION_CONFIRM:
        if (NULL != pMsg->pAppletContext)
        {
            pMsg->pSessionContext = NULL;
            ((CApplet *) pMsg->pAppletContext)->SendCallbackMessage((T120AppletMsg *) pMsg);
        }
        break;

    default:
        ERROR_OUT(("AutoJoinCallbackProc: invalid msg type=%u", pMsg->eMsgType));
        break;
    }
}


void CApplet::HandleAutoJoin
(
    T120ConfID      nConfID
)
{
    DBG_SAVE_FILE_LINE
    CAppletSession *pSession = new CAppletSession(this, nConfID);
    if (NULL != pSession)
    {
        T120Error rc;
        pSession->Advise(AutoJoinCallbackProc, this, pSession);
        rc = pSession->Join(m_pAutoJoinReq);
        if (rc != T120_NO_ERROR)
        {
            delete pSession;
        }
    }
}




CAppletSession * CSessionList::FindByConfID
(
    T120ConfID      nConfID
)
{
    CAppletSession *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (p->GetConfID() == nConfID)
        {
            return p;
        }
    }
    return NULL;
}



void CALLBACK GCC_SapCallback
(
    GCCAppSapMsg   *_pMsg
)
{
    T120AppletSessionMsg *pMsg = (T120AppletSessionMsg *) _pMsg;
    CApplet *pApplet = (CApplet *) pMsg->pAppletContext;
    ASSERT(NULL != pApplet);

    pApplet->GCCCallback(pMsg);
}


void CALLBACK MCS_SapCallback
(
    UINT            nMsg,
    LPARAM          Param1,
    LPVOID          Param2
)
{
    CAppletSession *pAppletSession = (CAppletSession *) Param2;
    ASSERT(NULL != pAppletSession);

    T120AppletSessionMsg Msg;
    ::ZeroMemory(&Msg, sizeof(Msg));
    Msg.eMsgType = (T120MessageType) nMsg;
    // Msg.pAppletContext = NULL;
    // Msg.pSessionContext = NULL;
    // Msg.nConfID = 0;

    // construct MCS message
    switch (Msg.eMsgType)
    {
    // send data
    case MCS_SEND_DATA_INDICATION:
    case MCS_UNIFORM_SEND_DATA_INDICATION:
        Msg.SendDataInd = * (SendDataIndicationPDU *) Param1;
        break;

   // channel confirm
    case MCS_CHANNEL_JOIN_CONFIRM:
    case MCS_CHANNEL_CONVENE_CONFIRM:
        Msg.ChannelConfirm.eResult = (T120Result) HIWORD(Param1);
        Msg.ChannelConfirm.nChannelID = LOWORD(Param1);
        break;
    // channel indication
    case MCS_CHANNEL_LEAVE_INDICATION:
    case MCS_CHANNEL_DISBAND_INDICATION:
    case MCS_CHANNEL_ADMIT_INDICATION:
    case MCS_CHANNEL_EXPEL_INDICATION:
        Msg.ChannelInd.nChannelID = LOWORD(Param1);
        Msg.ChannelInd.eReason = (T120Reason) HIWORD(Param1);
        break;
    // token confirm
    case MCS_TOKEN_GRAB_CONFIRM:
    case MCS_TOKEN_INHIBIT_CONFIRM:
    case MCS_TOKEN_GIVE_CONFIRM:
    case MCS_TOKEN_RELEASE_CONFIRM:
    case MCS_TOKEN_TEST_CONFIRM:
        Msg.TokenConfirm.nTokenID = LOWORD(Param1);
        Msg.TokenConfirm.eResult = (T120Result) HIWORD(Param1);
        break;
    // token indication
    case MCS_TOKEN_GIVE_INDICATION:
    case MCS_TOKEN_PLEASE_INDICATION:
    case MCS_TOKEN_RELEASE_INDICATION:
        Msg.TokenInd.nTokenID = LOWORD(Param1);
        Msg.TokenInd.eReason = (T120Reason) HIWORD(Param1);
        break;
    // user
    case MCS_ATTACH_USER_CONFIRM:
        Msg.AttachUserConfirm.nUserID = LOWORD(Param1);
        Msg.AttachUserConfirm.eResult = (T120Result) HIWORD(Param1);
        break;
    case MCS_DETACH_USER_INDICATION:
        Msg.DetachUserInd.nUserID = LOWORD(Param1);
        Msg.DetachUserInd.eReason = (T120Reason) HIWORD(Param1);
        break;
    default:
        WARNING_OUT(("MCS_SapCallback: Ignore MCS message, type=%u", Msg.eMsgType));
        break;
    }

    pAppletSession->MCSCallback(&Msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\t120app.h ===
#ifndef _T120_APPLET_SAP_
#define _T120_APPLET_SAP_

/*
 * include files 
 */
#include "it120app.h"
#include "appsap.h"

class CApplet;

typedef enum
{
    APPSESS_INITIALIZED,
    APPSESS_ATTACH_USER_REQ,
    APPSESS_ATTACH_USER_CON,
    APPSESS_JOIN_MY_CHANNEL_REQ,
    APPSESS_JOIN_MY_CHANNEL_CON,
    APPSESS_JOIN_STATIC_CHANNEL_REQ,
    APPSESS_JOIN_STATIC_CHANNEL_CON, // may go back to APPSESS_JOIN_STATIC_CHANNEL_REQ
    APPSESS_INACTIVELY_ENROLL_REQ,
    APPSESS_INACTIVELY_ENROLL_CON,
    APPSESS_RESOURCE_REQ,
    APPSESS_RESOURCE_CON, // may go back to APPSESS_RESOURCE_REQ
    APPSESS_ACTIVELY_ENROLL_REQ,
    APPSESS_ACTIVELY_ENROLL_CON,
    APPSESS_JOINED,
    APPSESS_LEAVING,
    APPSESS_LEFT,
}
    APPLET_SESSION_STATE;


typedef enum
{
    NONE_CHOSEN,
    ERROR_CHOSEN,
    RESULT_CHOSEN,
}
    SESSION_ERROR_TYPE;


typedef enum
{
    DCJS_INITIALIZED,
    DCJS_RETRIEVE_ENTRY_REQ,
    DCJS_RETRIEVE_ENTRY_CON,
    DCJS_EXISTING_CHANNEL_JOIN_REQ,
    DCJS_EXISTING_CHANNEL_JOIN_CON,
    DCJS_NEW_CHANNEL_JOIN_REQ,
    DCJS_NEW_CHANNEL_JOIN_CON,
    DCJS_REGISTER_CHANNEL_REQ,
    DCJS_REGISTER_CHANNEL_CON,
}
    DYNCHNL_JOIN_STATE;


class CAppletSession : public IT120AppletSession, public CRefCount
{
    friend class CApplet;
    friend void CALLBACK MCS_SapCallback(UINT, LPARAM, LPVOID);
    friend void CALLBACK GCC_SapCallback(GCCAppSapMsg *);

public:

    CAppletSession(CApplet *, T120ConfID);
    ~CAppletSession(void);

    /* exit the conference */

    STDMETHOD_(void, ReleaseInterface) (THIS);

    STDMETHOD_(void, Advise) (THIS_
                    IN      LPFN_APPLET_SESSION_CB pfnCallback,
                    IN      LPVOID  pAppletContext,
                    IN      LPVOID  pSessionContext);

    STDMETHOD_(void, Unadvise) (THIS);

    /* basic info */

    STDMETHOD_(T120ConfID, GetConfID) (THIS) { return m_nConfID; }

    STDMETHOD_(BOOL, IsThisNodeTopProvider) (THIS);

    STDMETHOD_(T120NodeID, GetTopProvider) (THIS);

    /* join/leave */

    STDMETHOD_(T120Error, Join) (THIS_
                    IN      T120JoinSessionRequest *);

    STDMETHOD_(void, Leave) (THIS);

    /* send data */

    STDMETHOD_(T120Error, AllocateSendDataBuffer) (THIS_
                IN      ULONG,
                OUT     void **);

    STDMETHOD_(void, FreeSendDataBuffer) (THIS_
                IN      void *);

    STDMETHOD_(T120Error, SendData) (THIS_
                IN      DataRequestType,
                IN      T120ChannelID,
                IN      T120Priority,
                IN		LPBYTE,
                IN		ULONG,
                IN		SendDataFlags);

    /* ------ ADVANCED METHODS ---- */

    STDMETHOD_(T120Error, InvokeApplet) (THIS_
                IN      GCCAppProtEntityList *,
                IN      GCCSimpleNodeList *,
                OUT     T120RequestTag *);

    STDMETHOD_(T120Error, InquireRoster) (THIS_
                IN      GCCSessionKey *);

    /* ------ registry services ------ */

    STDMETHOD_(T120Error, RegistryRequest) (THIS_
                IN      T120RegistryRequest *);

    /* ------ channel services ------ */

    STDMETHOD_(T120Error, ChannelRequest) (THIS_
                IN      T120ChannelRequest *);

    /* ------ token services ------ */

    STDMETHOD_(T120Error, TokenRequest) (THIS_
                IN      T120TokenRequest *);

protected:

    void GCCCallback(T120AppletSessionMsg *);
    void MCSCallback(T120AppletSessionMsg *);

    BOOL IsJoining(void);

    //
    // handy functions for the join process
    //
    void SetTempMsg(T120AppletSessionMsg *pMsg) { m_pTempMsg = pMsg; }
    void ClearTempMsg(void) { m_pTempMsg = NULL; }
    void HandleAttachUserConfirm(void);
    void HandleJoinChannelConfirm(void);
    void HandleEnrollConfirm(void);
    void HandleRegisterChannelConfirm(void);
    void HandleRetrieveEntryConfirm(void);
	void HandleTokenGrabConfirm(void);

private:

    void ClearError(void) { m_eErrorType = NONE_CHOSEN; }
    void SetError(T120Error err) { m_eErrorType = ERROR_CHOSEN; m_Error.eError = err; }
    void SetError(T120Result res) { m_eErrorType = RESULT_CHOSEN; m_Error.eResult = res; }

    void SetState(APPLET_SESSION_STATE eState);
    APPLET_SESSION_STATE GetState(void) { return m_eState; }

    void SendMCSMessage(T120AppletSessionMsg *);
    void SendCallbackMessage(T120AppletSessionMsg *);

    T120Error DoEnroll(BOOL fEnroll, BOOL fEnrollActively = FALSE);
    void DoJoinStaticChannels(void);
    void DoResourceRequests(void);
    void DoJoinDynamicChannels(BOOL fInitState);
    void DoJoined(void);
	void DoGrabTokenRequest(void);

    void AbortJoin(void);
    void SendJoinResult(T120Result eResult = T120_RESULT_SUCCESSFUL, T120Error eErrorCode = T120_NO_ERROR);

    void FreeJoinRequest(BOOL fZeroOut);

private:

    // remmember the context
    LPVOID                  m_pAppletContext; 
    LPVOID                  m_pSessionContext; 
    LPFN_APPLET_SESSION_CB  m_pfnCallback;

    // parent applet object
    CApplet                *m_pApplet;

    // tentative sap pointers
    IMCSSap                *m_pMCSAppletSAP;

    // information about myself
    T120ConfID              m_nConfID;
    T120UserID              m_uidMyself;
    T120SessionID           m_sidMyself;
    T120EntityID            m_eidMyself;
    T120NodeID              m_nidMyself;

    // join state
    APPLET_SESSION_STATE    m_eState;
    ULONG                   m_nArrayIndex;

    // error handling
    SESSION_ERROR_TYPE      m_eErrorType;
    union
    {
        T120Error   eError;
        T120Result  eResult;
    }                       m_Error;

    // join conference request copy
    T120JoinSessionRequest  m_JoinRequest; // valid during join session
    BOOL                    m_fMCSFreeDataIndBuffer;

    // dynamic channels join state
    BOOL                    m_fFirstRoster;
    DYNCHNL_JOIN_STATE      m_eDynamicChannelJoinState;
    T120AppletSessionMsg   *m_pTempMsg;
};


class CSessionList : public CList
{
    DEFINE_CLIST(CSessionList, CAppletSession*)
    CAppletSession *FindByConfID(T120ConfID);
};


class CApplet : public IT120Applet, public CRefCount
{
    friend void CALLBACK GCC_SapCallback(GCCAppSapMsg *);

public:

    CApplet(T120Error *);
    ~CApplet(void);

    STDMETHOD_(void, ReleaseInterface) (THIS);

    STDMETHOD_(void, Advise) (THIS_
                    IN      LPFN_APPLET_CB  pfnCallback,
                    IN      LPVOID          pAppletContext);

    STDMETHOD_(void, Unadvise) (THIS);

    /* ------ Auto Join ------ */

    STDMETHOD_(T120Error, RegisterAutoJoin) (THIS_
                    IN      T120JoinSessionRequest *);

    STDMETHOD_(void, UnregisterAutoJoin) (THIS);

    /* ------ Session ------ */

    STDMETHOD_(T120Error, CreateSession) (THIS_
                    OUT     IT120AppletSession **,
                    IN      T120ConfID);


    void SendCallbackMessage(T120AppletMsg *pMsg);

    IGCCAppSap *GetAppSap(void) { return m_pAppSap; }

    void RegisterSession(CAppletSession *p) { m_SessionList.Append(p); }
    void UnregisterSession(CAppletSession *p) { m_SessionList.Remove(p); }

    CAppletSession *FindSessionByConfID(T120ConfID nConfID) { return m_SessionList.FindByConfID(nConfID); }

protected:

    void GCCCallback(T120AppletSessionMsg *);
    void HandleAutoJoin(T120ConfID);

private:

    LPFN_APPLET_CB          m_pfnCallback;
    LPVOID                  m_pAppletContext;
    IGCCAppSap             *m_pAppSap;
    CSessionList            m_SessionList;

    // for auto join
    T120JoinSessionRequest *m_pAutoJoinReq;
    CAppletSession         *m_pAutoAppletSession;
};


#endif // _T120_APPLET_SAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\token.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	token.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Token class.  It contains all
 *		code necessary to implement tokens as defined in the MCS specification.
 *
 *		Whenever a user allocates a token (by grabbing or inhibiting it), one
 *		of these objects is created (if domain parameters allow it).  This
 *		object then handles all requests related to that token ID.  It also
 *		issues confirms back to the originators of those requests.
 *
 *		This class includes code to maintain a list of user IDs that
 *		correspond to the current "owners" of the token.  A user is said to
 *		own a token if it has it grabbed or inhibited.  This code implements
 *		the rules concerning who can grab or inhibit tokens at any given
 *		time (which is affected by current state).
 *
 *		This class also contains the code that allows a current grabber of
 *		the token to give it away to another user in the domain.
 *
 *		This class also includes code to merge itself upward during a domain
 *		merge operation.
 *
 *	Private Instance Variables:
 *		Token_ID
 *			This is the token ID for the token that this object represents.
 *		m_pDomain
 *			This is a pointer to the local provider (the domain that owns this
 *			token).  This field is used when a command is issued on behalf of
 *			this provider.
 *		m_pConnToTopProvider
 *			This is the top provider of the current domain.
 *		m_pChannelList2
 *			This is the channel list that is maintained by the domain.  It is
 *			used by this class to perform validation of user IDs.
 *		m_pAttachmentList
 *			This is the attachment list that is maintained by the domain.  It is
 *			used by this class to determine what users are locally attached,
 *			when it becomes necessary to send certain indications.
 *		Token_State
 *			This contains the current state of the token, which will be one of
 *			the following: available; grabbed; inhibited; giving; or given.
 *		m_uidGrabber
 *			This is the user that current has the token grabbed.  This variable
 *			is only valid in the grabbed and giving states.
 *		m_InhibitorList
 *			This is a list of users that have the token inhibited.  This
 *			list is only valid when the token is in the inhibited state.
 *		m_uidRecipient
 *			This is the user to whom the token is being given.  This variable
 *			is only valid in the giving or given states.
 *
 *	Private Member Functions:
 *		ValidateUserID
 *			This function is used to verify that a specified user is valid in
 *			the sub-tree of the local provider.
 *		GetUserAttachment
 *			This function is used to determine which attachment leads to a
 *			particular attachment.
 *		IssueTokenReleaseIndication
 *			This function is used to issue a token release indication to a
 *			specified user.  It first checks to see if the user is locally
 *			attached, and if so, it sends the indication.
 *		BuildAttachmentList
 *			This function is used to build a list of unique attachments to
 *			send please indications to.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include "token.h"


/*
 *	Token ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the token class.  It does nothing more than
 *		set the initial states of instance variables.
 */
Token::Token (
		TokenID				token_id,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list)
:
	m_InhibitorList(),
	Token_ID(token_id),
	m_pDomain(local_provider),
	m_pConnToTopProvider(top_provider),
	m_pChannelList2(channel_list),
	m_pAttachmentList(attachment_list),
	Token_State(TOKEN_AVAILABLE)
{
	/*
	 *	Save all parameters in their associated instance variables for later
	 *	use.
	 */

	/*
	 *	Mark the token as available for use.
	 */
}

/*
 *	Token ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is an alternate constructor for the token class.  It is used when
 *		creating a token during a merge operation.  It accepts a current state
 *		as well as a list of current owners  as parameters.
 */
Token::Token (
		TokenID				token_id,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list,
		TokenState			token_state,
		UserID				grabber,
		CUidList           *inhibitor_list,
		UserID				recipient)
:
	m_InhibitorList(),
	Token_ID(token_id),
	m_pDomain(local_provider),
	m_pConnToTopProvider(top_provider),
	m_pChannelList2(channel_list),
	m_pAttachmentList(attachment_list),
	Token_State(token_state)
{
	UserID		uid;

	/*
	 *	Save all parameters in their associated instance variables for later
	 *	use.
	 */

	/*
	 *	Indicate the current state of the token (as passed in).
	 */

	/*
	 *	Depending on token state, copy the pertinent information into local
	 *	instance variables.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			m_uidGrabber = grabber;
			break;

		case TOKEN_INHIBITED:
			{
				/*
				 *	Add all user IDs in the inhibitor list to the local
				 *	inhibitor list.
				 */
				inhibitor_list->Reset();
				while (NULL != (uid = inhibitor_list->Iterate()))
				{
					m_InhibitorList.Append(uid);
				}
			}
			break;

		case TOKEN_GIVING:
			m_uidGrabber = grabber;
			m_uidRecipient = recipient;
			break;

		case TOKEN_GIVEN:
			m_uidRecipient = recipient;
			break;
	}
}

/*
 *	~Token ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the token destructor.  It iterates through its current owner
 *		list, issuing TokenReleaseIndications to any owners that correspond
 *		to locally attached users.
 */
Token::~Token ()
{
	/*
	 *	Depending on the current state of the token, release resources and
	 *	issue release indications to all owners.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			/*
			 *	Send a release indication to the grabber, if it is locally
			 *	attached.
			 */
			IssueTokenReleaseIndication (m_uidGrabber);
			break;

		case TOKEN_INHIBITED:
			{
				UserID	uid;
				/*
				 *	Iterate through the current inhibitor list, to make sure
				 *	that everyone is properly informed of the demise of this
				 *	token.
				 */
				m_InhibitorList.Reset();
				while (NULL != (uid = m_InhibitorList.Iterate()))
				{
					IssueTokenReleaseIndication(uid);
				}
			}
			break;

		case TOKEN_GIVING:
			/*
			 *	Send a release indication to the grabber, if it is locally
			 *	attached.
			 */
			IssueTokenReleaseIndication (m_uidGrabber);

			/*
			 *	Send a release indication to the recipient, if it is locally
			 *	attached.  Note that this will not be sent in the case where
			 *	the grabber and the recipient are one and the same.  This
			 *	prevents the sending of two release indications to the same
			 *	user for the same token.
			 */
			if (m_uidGrabber != m_uidRecipient)
				IssueTokenReleaseIndication (m_uidRecipient);
			break;

		case TOKEN_GIVEN:
			/*
			 *	Send a release indication to the recipient, if it is locally
			 *	attached.
			 */
			IssueTokenReleaseIndication (m_uidRecipient);
			break;
	}
}


/*
 *	BOOL    IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function checks the validity of each of its owners.  It then
 *		returns TRUE if there are any valid owners left.  FALSE otherwise.
 */
BOOL    Token::IsValid ()
{
	BOOL    		valid;

	/*
	 *	We must check for the validity of this token.  How this is checked for
	 *	is a function of token state.  So switch on the state.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			/*
			 *	When a token is grabbed, the grabber must be in the sub-tree
			 *	of the current provider.  If this is not true, then mark the
			 *	token as available (which will cause it to be deleted).
			 */
			if (ValidateUserID (m_uidGrabber) == FALSE)
				Token_State = TOKEN_AVAILABLE;
			break;

		case TOKEN_INHIBITED:
			{
				UserID			uid;
				CUidList		deletion_list;
				/*
				 *	Iterate through the current inhibitor list of this token,
				 *	checking to make sure that each user is still valid.  Each
				 *	one that is not will be put into a deletion list (it is
				 *	invalid to remove items from a list while using an iterator
				 *	on the list).
				 */
				m_InhibitorList.Reset();
				while (NULL != (uid = m_InhibitorList.Iterate()))
				{
					if (ValidateUserID(uid) == FALSE)
						deletion_list.Append(uid);
				}

				/*
				 *	Iterate through the deletion list that was built above,
				 *	removing each contained user from the token's inhibitor
				 *	list.  These correspond to users that have detached from the
				 *	domain for one reason or another.
				 */
				deletion_list.Reset();
				while (NULL != (uid = deletion_list.Iterate()))
				{
					m_InhibitorList.Remove(uid);
				}
			}

			/*
			 *	Check to see if there are any inhibitors left.  If not, then
			 *	we must change the state of the token to available (which will
			 *	cause it to be deleted).
			 */
			if (m_InhibitorList.IsEmpty())
				Token_State = TOKEN_AVAILABLE;
			break;

		case TOKEN_GIVING:
			/*
			 *	When a token is in the giving state, the recipient must be in
			 *	the sub-tree of the current provider.  If it is not, then the
			 *	token MUST change state.  The state it changes to depends on
			 *	whether or not the grabber is in the sub-tree of the current
			 *	provider.
			 */
			if (ValidateUserID (m_uidRecipient) == FALSE)
			{
				/*
				 *	The recipient of the token is gone.  Check to see if the
				 *	grabber is in the sub-tree of this provider.
				 */
				if (ValidateUserID (m_uidGrabber) == FALSE)
				{
					/*
					 *	The grabber is not in the sub-tree of this provider,
					 *	meaning that the token is no longer valid.
					 */
					Token_State = TOKEN_AVAILABLE;
				}
				else
				{
					/*
					 *	The grabber is in the sub-tree of this provider, so the
					 *	token state will transition back to grabbed.
					 */
					Token_State = TOKEN_GRABBED;

					/*
					 *	If this is the top provider, it is necessary to issue a
					 *	give confirm to the grabber telling it that the give
					 *	failed.
					 */
					if (m_pConnToTopProvider == NULL)
					{
						/*
						 *	Find out what attachment leads to the current
						 *	grabber of the token, and issue the appropriate
						 *	token give confirm.
						 */
						CAttachment *pAtt = GetUserAttachment(m_uidGrabber);
						if (pAtt)
						{
						    pAtt->TokenGiveConfirm(RESULT_NO_SUCH_USER, m_uidGrabber, Token_ID,
						                           TOKEN_SELF_GRABBED);
						}
					}
				}
			}
			break;

		case TOKEN_GIVEN:
			/*
			 *	When a token is in the given state, the recipient must be in
			 *	the sub-tree of the current provider.  If it is not, then the
			 *	token is no longer valid, and should transition to the
			 *	available state.
			 */
			if (ValidateUserID (m_uidRecipient) == FALSE)
				Token_State = TOKEN_AVAILABLE;
			break;
	}

	/*
	 *	Check to see if the token is still in use.  If it is marked as
	 *	available, then it is not, and we will return FALSE.
	 */
	if (Token_State != TOKEN_AVAILABLE)
		valid = TRUE;
	else
		valid = FALSE;

	return (valid);
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function tells the token object to pack its state into a merge
 *		request and send it to the specified provider.
 */
Void	Token::IssueMergeRequest ()
{
	TokenAttributes			merge_token;
	CTokenAttributesList	merge_token_list;
	CTokenIDList			purge_token_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Check the state to make sure that the token really is in use.  If
		 *	the state is set to available, then do not issue a merge request.
		 */
		if (Token_State != TOKEN_AVAILABLE)
		{
			/*
			 *	Fill in a token attributes structure to represent the state of
			 *	this token.  Then put it into the merge token list in
			 *	preparation for issuing the merge request.
			 */
			merge_token.token_state = Token_State;
			switch (Token_State)
			{
				case TOKEN_GRABBED:
					merge_token.u.grabbed_token_attributes.token_id = Token_ID;
					merge_token.u.grabbed_token_attributes.grabber = m_uidGrabber;
					break;

				case TOKEN_INHIBITED:
					merge_token.u.inhibited_token_attributes.token_id =
							Token_ID;
					merge_token.u.inhibited_token_attributes.inhibitors =
							&m_InhibitorList;
					break;

				case TOKEN_GIVING:
					merge_token.u.giving_token_attributes.token_id = Token_ID;
					merge_token.u.giving_token_attributes.grabber = m_uidGrabber;
					merge_token.u.giving_token_attributes.recipient = m_uidRecipient;
					break;

				case TOKEN_GIVEN:
					merge_token.u.given_token_attributes.token_id = Token_ID;
					merge_token.u.given_token_attributes.recipient = m_uidRecipient;
					break;
			}
			merge_token_list.Append(&merge_token);

			/*
			 *	Send the resulting merge request to the indicated provider.
			 */
			m_pConnToTopProvider->MergeTokensRequest(&merge_token_list, &purge_token_list);
		}
		else
		{
			/*
			 *	Report that the token is not in use, but do NOT send a merge
			 *	request.
			 */
			TRACE_OUT(("Token::IssueMergeRequest: token not in use"));
		}
	}
}

/*
 *	Void	TokenGrabRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user tries to grab a token.  The request
 *		will either succeed or fail depending on the current state of the token.
 *		Either way, a confirm will be sent to the user originating the request.
 */
Void	Token::TokenGrabRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this provider is the Top Provider.  If so, then process
	 *	this request here.  Otherwise, forward the request upward.
	 */
	if (IsTopProvider())
	{
		/*
		 *	Determine what state we are, which greatly affects how we process
		 *	the request.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	Since the token is available, the request automatically
				 *	succeeds.  Change the state to grabbed, and mark the
				 *	initiator as the grabber.
				 */
				Token_State = TOKEN_GRABBED;
				m_uidGrabber = uidInitiator;

				result = RESULT_SUCCESSFUL;
				token_status = TOKEN_SELF_GRABBED;
				break;

			case TOKEN_GRABBED:
				/*
				 *	If the token is already grabbed, then we must fail the
				 *	request.  However, we need to determine if the token is
				 *	grabbed by the same user who is currently requesting it, or
				 *	another user.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GRABBED;
				else
					token_status = TOKEN_OTHER_GRABBED;
				break;

			case TOKEN_INHIBITED:
				/*
				 *	If the token is inhibited, this request can still succeed if
				 *	the only inhibitor is the user that is attempting to grab
				 *	the token.  Check to see if this is the case.
				 */
				if (m_InhibitorList.Find(uidInitiator))
				{
					if (m_InhibitorList.GetCount() == 1)
					{
						/*
						 *	The user attempting to grab the token is the only
						 *	inhibitor, so convert the state to grabbed.
						 */
						Token_State = TOKEN_GRABBED;
						m_uidGrabber = uidInitiator;
						m_InhibitorList.Clear();

						result = RESULT_SUCCESSFUL;
						token_status = TOKEN_SELF_GRABBED;
					}
					else
					{
						/*
						 *	The token is inhibited by at least one other user,
						 *	so the grab request must fail.
						 */
						result = RESULT_TOKEN_NOT_AVAILABLE;
						token_status = TOKEN_SELF_INHIBITED;
					}
				}
				else
				{
					/*
					 *	The token is not inhibited by the requestor, so it must
					 *	be inhibited by someone else.
					 */
					result = RESULT_TOKEN_NOT_AVAILABLE;
					token_status = TOKEN_OTHER_INHIBITED;
				}
				break;

			case TOKEN_GIVING:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then a grab request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then a grab request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	Issue the token grab confirm to the initiating user.
		 */
		pOrigAtt->TokenGrabConfirm(result, uidInitiator, Token_ID, token_status);
	}
	else
	{
		/*
		 *	Forward this request upward towards the Top Provider.
		 */
		TRACE_OUT(("Token::TokenGrabRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenGrabRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenGrabConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenGrabConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID(uidInitiator))
	{
		/*
		 *	Check to see if this request was successful.
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Force this token to conform to the results of this confirm.
			 */
			Token_State = TOKEN_GRABBED;
			m_uidGrabber = uidInitiator;
			m_InhibitorList.Clear();
		}

		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenGrabConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenGrabConfirm: invalid initiator ID"));
	}
}

/*
 *	Void	TokenInhibitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user tries to inhibit a token.  The
 *		request will either succeed or fail depending on the current state of
 *		the token.  Either way, a confirm will be sent to the user originating
 *		the request.
 */
Void	Token::TokenInhibitRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (IsTopProvider())
	{
		/*
		 *	Determine what state we are, which greatly affects how we process
		 *	the request.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	Since the token is available, the request automatically
				 *	succeeds.  Set the token state to inhibited, and add the
				 *	initiator to the list of inhibitors.
				 */
				Token_State = TOKEN_INHIBITED;
				m_InhibitorList.Append(uidInitiator);

				result = RESULT_SUCCESSFUL;
				token_status = TOKEN_SELF_INHIBITED;
				break;

			case TOKEN_GRABBED:
				/*
				 *	If the token is grabbed, this request can still succeed if
				 *	the grabber is the user that is attempting to inhibit the
				 *	token.  Check to see if this is the case.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	The current grabber is attempting to convert the state
					 *	of the token to inhibited.  This is valid, so set the
					 *	state appropriately.
					 */
					Token_State = TOKEN_INHIBITED;
					m_InhibitorList.Append(uidInitiator);

					result = RESULT_SUCCESSFUL;
					token_status = TOKEN_SELF_INHIBITED;
				}
				else
				{
					/*
					 *	The token is grabbed by someone else, so the inhibit
					 *	request must fail.
					 */
					result = RESULT_TOKEN_NOT_AVAILABLE;
					token_status = TOKEN_OTHER_GRABBED;
				}
				break;

			case TOKEN_INHIBITED:
				/*
				 *	The token is already inhibited, but this is okay.  Add this
				 *	user to the list of inhibitors (if it is not already there).
				 */
				if (m_InhibitorList.Find(uidInitiator) == FALSE)
					m_InhibitorList.Append(uidInitiator);

				result = RESULT_SUCCESSFUL;
				token_status = TOKEN_SELF_INHIBITED;
				break;

			case TOKEN_GIVING:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then an inhibit request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then an inhibit request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	If the originator is NULL, then this inhibit request is happening as
		 *	part of a merge operation, in which case we do NOT want to send a
		 *	token inhibit confirm.  Otherwise we do send one.
		 */
		if (pOrigAtt != NULL)
		{
			pOrigAtt->TokenInhibitConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenInhibitRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenInhibitRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenInhibitConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenInhibitConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID (uidInitiator) )
	{
		/*
		 *	Check to see if this request was successful.
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Force this token to conform to the results of this confirm.
			 */
			Token_State = TOKEN_INHIBITED;
			if (m_InhibitorList.Find(uidInitiator) == FALSE)
				m_InhibitorList.Append(uidInitiator);
		}

		/*
		 *	Determine what attachment leads to the initiator, and issue the
		 *	token confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenInhibitConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenInhibitConfirm: invalid initiator ID"));
	}
}

/*
 *	Void	TokenGiveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when one user asks to give a token to another
 *		user.
 */
Void	Token::TokenGiveRequest (
				CAttachment        *pOrigAtt,
				PTokenGiveRecord	pTokenGiveRec)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this provider is the Top Provider.  If so, then process
	 *	this request here.  Otherwise, forward the request upward.
	 */
	if (m_pConnToTopProvider == NULL)
	{
		UserID		uidInitiator = pTokenGiveRec->uidInitiator;
		UserID		receiver_id = pTokenGiveRec->receiver_id;
		/*
		 *	Determine what state we are, which greatly affects how we process
		 *	the request.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	The token is not in use, and therefore cannot be given by
				 *	anyone to anyone.  So fail this request.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				token_status = TOKEN_NOT_IN_USE;
				break;

			case TOKEN_GRABBED:
				/*
				 *	Check to see if the requestor really is the grabber of this
				 *	token.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	Check to see if the intended recipient is a valid user
					 *	in the domain.
					 */
					if (ValidateUserID (receiver_id) )
					{
						/*
						 *	Everything checks out.  Set the result to success
						 *	to disable transmission of the give confirm below.
						 *	Change the state of the token to giving, and
						 *	save the ID of the intended recipient.  Then issue
						 *	the give indication toward the recipient.
						 */
						result = RESULT_SUCCESSFUL;
						Token_State = TOKEN_GIVING;
						m_uidRecipient = receiver_id;

						CAttachment *pAtt = GetUserAttachment(receiver_id);
						ASSERT (Token_ID == pTokenGiveRec->token_id);
						if (pAtt)
						{
						    pAtt->TokenGiveIndication(pTokenGiveRec);
						}
					}
					else
					{
						/*
						 *	The recipient does not exist in the domain, so
						 *	fail the request.
						 */
						result = RESULT_NO_SUCH_USER;
						token_status = TOKEN_SELF_GRABBED;
					}
				}
				else
				{
					/*
					 *	The requestor does not own the token, so the request
					 *	must fail.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					token_status = TOKEN_OTHER_GRABBED;
				}
				break;

			case TOKEN_INHIBITED:
				/*
				 *	Inhibited tokens cannot be given by anyone to anyone.  So
				 *	fail this request with the proper status.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (m_InhibitorList.Find(uidInitiator) )
					token_status = TOKEN_SELF_INHIBITED;
				else
					token_status = TOKEN_OTHER_INHIBITED;
				break;

			case TOKEN_GIVING:
				/*
				 *	This token is already in the process of being given.  So
				 *	this request must fail.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	This token is already in the process of being given.  So
				 *	this request must fail.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	If necessary, issue a token give confirm to the initiating user.
		 */
		if (result != RESULT_SUCCESSFUL)
		{
			pOrigAtt->TokenGiveConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	Forward this request upward towards the Top Provider.
		 */
		TRACE_OUT(("Token::TokenGiveRequest: forwarding request to Top Provider"));
		ASSERT (Token_ID == pTokenGiveRec->token_id);
		m_pConnToTopProvider->TokenGiveRequest(pTokenGiveRec);
	}
}

/*
 *	Void	TokenGiveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called in order to deliver a message to a user that
 *		another user is trying to give them a token.
 */
Void	Token::TokenGiveIndication (
				PTokenGiveRecord	pTokenGiveRec)
{
	UserID				receiver_id;

	receiver_id = pTokenGiveRec->receiver_id;
	/*
	 *	Make sure that the receiver ID is valid, since we must forward this
	 *	indication in the direction of that user.  If it is not valid, ignore
	 *	this indication.
	 */
	if (ValidateUserID (receiver_id) )
	{
		/*
		 *	Force this token to conform to the state implied by this indication.
		 */
		Token_State = TOKEN_GIVING;
		m_uidGrabber = pTokenGiveRec->uidInitiator;
		m_InhibitorList.Clear();
		m_uidRecipient = receiver_id;

		/*
		 *	Determine what attachment leads to the recipient, and forward the
		 *	indication in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(receiver_id);
		ASSERT (Token_ID == pTokenGiveRec->token_id);
		if (pAtt)
		{
		    pAtt->TokenGiveIndication(pTokenGiveRec);
		}
	}
	else
	{
		/*
		 *	The recipient is not in the sub-tree of this provider.  So ignore
		 *	this indication.
		 */
		ERROR_OUT(("Token::TokenGiveIndication: invalid receiver ID"));
	}
}

/*
 *	Void	TokenGiveResponse ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a potential recipient decides whether or
 *		not to accept an offered token.
 */
Void	Token::TokenGiveResponse (
				Result				result,
				UserID				receiver_id,
				TokenID)
{
	UserID			uidInitiator;
	TokenStatus		token_status;

	/*
	 *	Process the response according to the current state of this token.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
		case TOKEN_GRABBED:
		case TOKEN_INHIBITED:
			/*
			 *	The token is not in the process of being given to anyone, so
			 *	this response must be ignored.
			 */
			break;

		case TOKEN_GIVING:
			/*
			 *	The token is being given to someone.  Check to see if this is
			 *	the proper recipient.  If not, don't do anything.
			 */
			if (receiver_id == m_uidRecipient)
			{
				/*
				 *	Save the ID of the initiator, for use in issuing a give
				 *	confirm (if necessary).
				 */
				uidInitiator = m_uidGrabber;

				/*
				 *	Check to see if the token was accepted.  A result of
				 *	anything but successful would indicate that it was not.
				 */
				if (result == RESULT_SUCCESSFUL)
				{
					/*
					 *	The token was accepted by the intended recipient.
					 *	Change the state of the token to being grabbed by the
					 *	receiver.
					 */
					Token_State = TOKEN_GRABBED;
					m_uidGrabber = receiver_id;
				}
				else
				{
					/*
					 *	The token was not accepted.  It must either revert to
					 *	being grabbed by the donor, or deleted, depending on
					 *	whether or not the donor is in the sub-tree of this
					 *	provider.
					 */
					if (ValidateUserID(uidInitiator))
					{
						/*
						 *	The donor is in the sub-tree of this provider, so
						 *	change the state of the token back to grabbed.
						 */
						Token_State = TOKEN_GRABBED;
					}
					else
					{
						/*
						 *	The donor is not in the sub-tree of this provider,
						 *	so the token will be marked as available (which
						 *	will cause it to be deleted).
						 */
						Token_State = TOKEN_AVAILABLE;
					}
				}

				/*
				 *	Check to see if this is the Top Provider.
				 */
				if (m_pConnToTopProvider == NULL)
				{
					/*
					 *	If the donor is still a valid user in the domain, a
					 *	token give confirm must be issued in its direction.
					 */
					if (ValidateUserID(uidInitiator))
					{
						/*
						 *	Determine which attachment leads to the donor, and
						 *	issue the token give confirm.
						 */
						if (uidInitiator == m_uidGrabber)
							token_status = TOKEN_SELF_GRABBED;
						else
							token_status = TOKEN_OTHER_GRABBED;

						CAttachment *pAtt = GetUserAttachment(uidInitiator);
						if (pAtt)
						{
						    pAtt->TokenGiveConfirm(result, uidInitiator, Token_ID, token_status);
						}
					}
				}
				else
				{
					/*
					 *	If this is not the Top Provider, then the valid give
					 *	response must be forwarded to the Top Provider.
					 */
					m_pConnToTopProvider->TokenGiveResponse(result, receiver_id, Token_ID);
				}
			}
			break;

		case TOKEN_GIVEN:
			/*
			 *	The token is being given to someone.  Check to see if this is
			 *	the proper recipient.  If not, don't do anything.
			 */
			if (receiver_id == m_uidRecipient)
			{
				/*
				 *	Check to see if the token was accepted.  A result of
				 *	anything but successful would indicate that it was not.
				 */
				if (result == RESULT_SUCCESSFUL)
				{
					/*
					 *	The token was accepted by the intended recipient.
					 *	Change the state of the token to being grabbed by the
					 *	receiver.
					 */
					Token_State = TOKEN_GRABBED;
					m_uidGrabber = receiver_id;
				}
				else
				{
					/*
					 *	The token was not accepted.  Since the donor has
					 *	already relinquished control of the token, the token
					 *	will marked as available (which will cause it to be
					 *	deleted).
					 */
					Token_State = TOKEN_AVAILABLE;
				}

				/*
				 *	Check to see if this is the Top Provider.
				 */
				if (m_pConnToTopProvider != NULL)
				{
					/*
					 *	If this is not the Top Provider, then the valid give
					 *	response must be forwarded to the Top Provider.
					 */
					m_pConnToTopProvider->TokenGiveResponse(result, receiver_id, Token_ID);
				}
			}
			break;
	}
}

/*
 *	Void	TokenGiveConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a potential giver of a token is told whether
 *		or not the token was successfully given to the intended recipient.
 */
Void	Token::TokenGiveConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID(uidInitiator))
	{
		/*
		 *	The token should be in the grabbed state, or else this confirm
		 *	was generated in error.
		 */
		if (Token_State == TOKEN_GRABBED)
		{
			/*
			 *	Check to see if this request was successful.
			 */
			if (result == RESULT_SUCCESSFUL)
			{
				/*
				 *	If this token is marked as being owned by the initiator of
				 *	the give, but the status indicates that the token is now
				 *	owned by someone else (as a result of the successful give),
				 *	then release the token.*
				 */
				if ((uidInitiator == m_uidGrabber) &&
						(token_status == TOKEN_OTHER_GRABBED))
					Token_State = TOKEN_AVAILABLE;
			}
		}
		else
		{
			/*
			 *	The token is in an invalid state.  Report the error, but do
			 *	not change the state of the token.
			 */
			ERROR_OUT(("Token::TokenGiveConfirm: invalid token state"));
		}

		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenGiveConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenGiveConfirm: invalid initiator ID"));
	}
}

/*
 *	Void		TokenPleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wishes to ask all current owners
 *		of a token to relinquish their ownership.
 */
Void	Token::TokenPleaseRequest (
				UserID				uidInitiator,
				TokenID)
{
	CUidList				please_indication_list;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (IsTopProvider())
	{
        CAttachmentList         attachment_list;
        CAttachment            *pAtt;
		/*
		 *	Determine the state of the token, to determine who to send the
		 *	please indication to.  Each state will place the appropriate user
		 *	IDs in the please indication list.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				break;

			case TOKEN_GRABBED:
				/*
				 *	Put the grabber into the list.
				 */
				please_indication_list.Append(m_uidGrabber);
				break;

			case TOKEN_INHIBITED:
				{
					UserID		uid;
					/*
					 *	Put all current inhibitors into the list.
					 */
					m_InhibitorList.Reset();
					while (NULL != (uid = m_InhibitorList.Iterate()))
					{
						please_indication_list.Append(uid);
					}
				}
				break;

			case TOKEN_GIVING:
				/*
				 *	Put the grabber into the list.  And if the recipient is
				 *	different from the grabber, put it in as well.  Remember
				 *	that it is valid for someone to give a token to themselves.
				 */
				please_indication_list.Append(m_uidGrabber);
				if (m_uidGrabber != m_uidRecipient)
					please_indication_list.Append(m_uidRecipient);
				break;

			case TOKEN_GIVEN:
				/*
				 *	Put the recipient into the list.
				 */
				please_indication_list.Append(m_uidRecipient);
				break;
		}

		/*
		 *	Build lists of unique attachments that lead to the users in the
		 *	please indication list (built above).
		 */
		BuildAttachmentList (&please_indication_list, &attachment_list);

		/*
		 *	Iterate through the newly created attachment list, issuing token
		 *	please indications to all attachments contained therein.
		 */
		attachment_list.Reset();
		while (NULL != (pAtt = attachment_list.Iterate()))
		{
			pAtt->TokenPleaseIndication(uidInitiator, Token_ID);
		}
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenPleaseRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenPleaseRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void		TokenPleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called in order to deliver a message to all current
 *		owners of a token that someone else wishes to own the token.
 */
Void	Token::TokenPleaseIndication (
				UserID				uidInitiator,
				TokenID)
{
	CUidList				please_indication_list;
	CAttachmentList         attachment_list;
    CAttachment            *pAtt;

	/*
	 *	Determine the state of the token, to determine who to forward the
	 *	please indication to.  Each state will place the appropriate user
	 *	IDs in the please indication list.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			/*
			 *	Put the grabber into the list.
			 */
			please_indication_list.Append(m_uidGrabber);
			break;

		case TOKEN_INHIBITED:
			{
				UserID		uid;
				/*
				 *	Put all current inhibitors into the list.
				 */
				m_InhibitorList.Reset();
				while (NULL != (uid = m_InhibitorList.Iterate()))
				{
					please_indication_list.Append(uid);
				}
			}
			break;

		case TOKEN_GIVING:
			/*
			 *	Put the grabber into the list.  And if the recipient is
			 *	different from the grabber, put it in as well.  Remember
			 *	that it is valid for someone to give a token to themselves.
			 */
			please_indication_list.Append(m_uidGrabber);
			if (m_uidGrabber != m_uidRecipient)
				please_indication_list.Append(m_uidRecipient);
			break;

		case TOKEN_GIVEN:
			/*
			 *	Put the recipient into the list.
			 */
			please_indication_list.Append(m_uidRecipient);
			break;
	}

	/*
	 *	Build lists of unique attachments that lead to the users in the
	 *	please indication list (built above).
	 */
	BuildAttachmentList (&please_indication_list, &attachment_list);

	/*
	 *	Iterate through the newly created attachment list, issuing token
	 *	please indications to all attachments contained therein.
	 */
	attachment_list.Reset();
	while (NULL != (pAtt = attachment_list.Iterate()))
	{
		pAtt->TokenPleaseIndication(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenReleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wished to release a token.  If the
 *		requesting user really is an owner of the token, the request will
 *		succeed.  Otherwise it will fail.  Either way, an appropriate token
 *		release confirm will be issued.
 */
Void	Token::TokenReleaseRequest (
				CAttachment        *pAtt,
				UserID				uidInitiator,
				TokenID)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (IsTopProvider())
	{
		/*
		 *	Determine the current state of the token before proceeding.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	If the token is available, then the requestor cannot be an
				 *	owner.  This means that the request must fail.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				token_status = TOKEN_NOT_IN_USE;
				break;

			case TOKEN_GRABBED:
				/*
				 *	The token is in the grabbed state.  See if the requesting
				 *	user is the one who has it grabbed.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	The current grabber of the token wishes to release it.
					 *	Set the state back to available, and send the
					 *	appropriate token release confirm.
					 */
					Token_State = TOKEN_AVAILABLE;

					result = RESULT_SUCCESSFUL;
					token_status = TOKEN_NOT_IN_USE;
				}
				else
				{
					/*
					 *	Someone is trying to release someone elses token.  This
					 *	request must fail.  Send the appropriate token release
					 *	confirm.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					token_status = TOKEN_OTHER_GRABBED;
				}
				break;

			case TOKEN_INHIBITED:
				/*
				 *	The token is in the inhibited state.  See if the requesting
				 *	user is one of the inhibitors.
				 */
				if (m_InhibitorList.Remove(uidInitiator))
				{
					/*
					 *	The user is an inhibitor.  Remove the user from the
					 *	list.  Then check to see if this has resulted in an
					 *	"ownerless" token.
					 */
					if (m_InhibitorList.IsEmpty())
					{
						/*
						 *	The token has no other inhibitors.  Return the token
						 *	to the available state, and issue the appropriate
						 *	token release confirm.
						 */
						Token_State = TOKEN_AVAILABLE;

						result = RESULT_SUCCESSFUL;
						token_status = TOKEN_NOT_IN_USE;
					}
					else
					{
						/*
						 *	There are still other inhibitors of the token.
						 *	Simply issue the appropriate token release confirm.
						 */
						result = RESULT_SUCCESSFUL;
						token_status = TOKEN_OTHER_INHIBITED;
					}
				}
				else
				{
					/*
					 *	The user attempting to release the token is not one of
					 *	the inhibitors.  Therefore the request must fail.  Issue
					 *	the appropriate token release indication.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					token_status = TOKEN_OTHER_INHIBITED;
				}
				break;

			case TOKEN_GIVING:
				/*
				 *	See if the requestor is the current owner of the token.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	The token must transition to the given state.  This
					 *	state indicates that if the recipient rejects the offer
					 *	or detaches, the token will be freed instead of
					 *	returning to the grabbed state.  Issue the appropriate
					 *	release confirm.
					 */
					Token_State = TOKEN_GIVEN;

					result = RESULT_SUCCESSFUL;
					token_status = TOKEN_OTHER_GIVING;
				}
				else
				{
					/*
					 *	If the requestor is not the current owner, then this
					 *	request must fail.  We first need to determine the
					 *	proper token status, and then issue the confirm.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					if (uidInitiator == m_uidRecipient)
						token_status = TOKEN_SELF_RECIPIENT;
					else
						token_status = TOKEN_OTHER_GIVING;
				}
				break;

			case TOKEN_GIVEN:
				/*
				 *	When the token is in the given state, there is no true
				 *	owner (only a pending owner).  This request must therefore
				 *	fail.  We first need to determine the proper token status,
				 *	and then issue the confirm.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	Issue the token release confirm to the initiator.
		 */
		pAtt->TokenReleaseConfirm(result, uidInitiator, Token_ID, token_status);
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenReleaseRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenReleaseRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenReleaseConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenReleaseConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID (uidInitiator) )
	{
		/*
		 *	Check to see if this request was successful.
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Process the confirm according to current state.
			 */
			switch (Token_State)
			{
				case TOKEN_AVAILABLE:
					break;

				case TOKEN_GRABBED:
					/*
					 *	If the grabber has released the token, then is becomes
					 *	available.
					 */
					if (uidInitiator == m_uidGrabber)
						Token_State = TOKEN_AVAILABLE;
					break;

				case TOKEN_INHIBITED:
					/*
					 *	If an inhibitor releases the token, then remove it from
					 *	the list.  If there are no more entries in the list,
					 *	then the token becomes available.
					 */
					if (m_InhibitorList.Remove(uidInitiator))
					{
						if (m_InhibitorList.IsEmpty())
							Token_State = TOKEN_AVAILABLE;
					}
					break;

				case TOKEN_GIVING:
					/*
					 *	If the grabber releases the token, then it transitions
					 *	to an intermediate state.  This state indicates that
					 *	if the recipient rejects the token, it will be freed
					 *	instead of returning to the grabbed state.
					 */
					if (uidInitiator == m_uidGrabber)
						Token_State = TOKEN_GIVEN;
					break;

				case TOKEN_GIVEN:
					break;
			}
		}

		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenReleaseConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenReleaseConfirm: invalid initiator ID"));
	}
}

/*
 *	Void	TokenTestRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wishes to test the current state
 *		of a token.  The only action is to issue a token test confirm containing
 *		the state information.
 */
Void	Token::TokenTestRequest (
				CAttachment        *pAtt,
				UserID				uidInitiator,
				TokenID)
{
	TokenStatus		token_status;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (m_pConnToTopProvider == NULL)
	{
		/*
		 *	Determine the state of the token before proceeding.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	The token is not in use.
				 */
				token_status = TOKEN_NOT_IN_USE;
				break;

			case TOKEN_GRABBED:
				/*
				 *	The token is grabbed.  See if the originating user is the
				 *	grabber.  If so, return the state as self grabbed.  If not,
				 *	return the state as other grabbed.
				 */
				if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GRABBED;
				else
					token_status = TOKEN_OTHER_GRABBED;
				break;

			case TOKEN_INHIBITED:
				/*
				 *	The token is inhibited.  See if the originating user is one
				 *	of the inhibitors.  If so, return the state as self
				 *	inhibited.  If not, return the state as other inhibited.
				 */
				if (m_InhibitorList.Find(uidInitiator))
					token_status = TOKEN_SELF_INHIBITED;
				else
					token_status = TOKEN_OTHER_INHIBITED;
				break;

			case TOKEN_GIVING:
				/*
				 *	The token is being given from one user to another.  See if
				 *	the requestor is one of the users involved.
				 */
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	The token has been given from one user to another.  See if
				 *	the requestor is the receiver.
				 */
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	Issue the test confirm with the appropriate status information.
		 */
		pAtt->TokenTestConfirm(uidInitiator, Token_ID, token_status);
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenTestRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenTestRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenTestConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenTestConfirm (
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID(uidInitiator))
	{
		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenTestConfirm(uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenReleaseConfirm: invalid initiator ID"));
	}
}

/*
 *	BOOL    ValidateUserID ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to verify the existence of the specified user
 *		in the sub-tree of this provider.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user the caller wishes to validate.
 *
 *	Return Value:
 *		TRUE if the user is valid.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 */
BOOL    Token::ValidateUserID (
					UserID			user_id)
{
	/*
	 *	Initialize the return value to FALSE, indicating that if any of the
	 *	following checks fail, the ID does NOT refer to a valid user ID.
	 */
	BOOL    	valid=FALSE;
	PChannel	channel;

	/*
	 *	First check to see if the user ID is in the channel list at all.  This
	 *	prevents an attempt to read an invalid entry from the dictionary.
	 */
	if (NULL != (channel = m_pChannelList2->Find(user_id)))
	{
		/*
		 *	We know that the ID is in the dictionary, but we don't know for sure
		 *	whether or not it is a user ID channel.  So check this.  If it is a
		 *	user channel, then set the valid flag to TRUE.
		 */
		if (channel->GetChannelType () == USER_CHANNEL)
			valid = TRUE;
	}

	return (valid);
}

/*
 *	PCommandTarget	GetUserAttachment ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function returns the attachment which leads to the specified
 *		user.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user the caller wishes to find the attachment
 *			for.
 *
 *	Return Value:
 *		A pointer to the attachment that leads to the user.
 *
 *	Side Effects:
 *		None.
 */
CAttachment *Token::GetUserAttachment (
						UserID				user_id)
{
	PChannel		lpChannel;
	/*
	 *	Read and return a pointer to the attachment that leads to the
	 *	specified user.  Note that this routine does NOT check to see if the
	 *	user is in the channel list.  It assumes that the user is known to
	 *	be valid BEFORE this routine is called.
	 */
	return ((NULL != (lpChannel = m_pChannelList2->Find(user_id))) ?
            lpChannel->GetAttachment() :
            NULL);
}

/*
 *	Void	IssueTokenReleaseIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to issue a token release indication to a
 *		particular user.  It first check to make sure that the user id valid,
 *		and that it is a local user.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user the caller wishes to send a token
 *			release indication to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Token::IssueTokenReleaseIndication (
				UserID			user_id)
{
	/*
	 *	Make sure that the specified user exists in the sub-tree of this
	 *	provider.
	 */
	if (ValidateUserID (user_id) )
	{
		/*
		 *	Determine which attachment leads to the grabber.
		 */
		CAttachment *pAtt = GetUserAttachment(user_id);

		/*
		 *	Is this attachment a local one?  If so, then issue a token
		 *	release indication to let the user know that the token has
		 *	been taken away.
		 */
		if (m_pAttachmentList->Find(pAtt) && pAtt->IsUserAttachment())
		{
		    PUser pUser = (PUser) pAtt;
			pUser->TokenReleaseIndication(REASON_TOKEN_PURGED, Token_ID);
		}
	}
}

/*
 *	Void	BuildAttachmentList ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function builds a list of unique attachments out of the list of
 *		user IDs that is poassed in.  This is done to insure that no given
 *		attachment receives more than one indication, even when there are more
 *		than one user in the same direction.
 *
 *	Formal Parameters:
 *		user_id_list (i)
 *			This is a list of user IDs that the caller wishes to send a token
 *			please indication to.
 *		attachment_list (i)
 *			This is the list that all unique attachments will be added to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Token::BuildAttachmentList (
				CUidList                *user_id_list,
				CAttachmentList         *attachment_list)
{
	UserID				uid;

	/*
	 *	Loop through the passed in user ID list building a list of unique
	 *	attachments.  This will be used to send indications downward without
	 *	sending one twice over the same attachment.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Check to see if the user ID refers to a valid user in the sub-tree
		 *	of this provider.
		 */
		if (ValidateUserID(uid))
		{
			/*
			 *	Determine which attachment leads to the user in question.  Then
			 *	check to see if it is already in the attachment list.  If not,
			 *	then put it there.
			 */
			CAttachment *pAtt = GetUserAttachment(uid);
			if (attachment_list->Find(pAtt) == FALSE)
				attachment_list->Append(pAtt);
		}
		else
		{
			/*
			 *	This user ID does not correspond to a valid user in the sub-tree
			 *	of this provider.  Therefore, discard the ID.
			 */
			ERROR_OUT(("Token::BuildAttachmentList: user ID not valid"));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\spacket.cpp ===
/*
 *	spacket.h
 *
 *	Copyright (c) 1997-98 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the implementation file for the SimplePacket class.  Instances of this
 *		class represent Protocol Data Units (PDUs) as they flow through the
 *		system.  Objects of this class can not be instantiated, because it's a 
 *		pure virtual class.  It exists only to be inherited from.  The Packet
 *		and DataPacket classes inherit from this one.  
 *
 *		A packet object can be created in 2 different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will calculate how much memory it will need to
 *		hold both the encoded and decoded data, and attempts to allocate that
 *		memory.  If it cannot, then it will report an error, and the newly
 *		created object should be immediately destroyed.  If the allocations are
 *		successful, then the packet will report success, but WILL NOT yet put
 *		any data into those allocated buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the pre-allocated encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *
 *		When Unlock messages are received, the lock count is decremented.  When
 *		the lock count is 0, the packet deletes itself (it commits
 *		suicide).  Note that for this reason, no other object should explicitly
 *		delete a packet object.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Christos Tsollis
 */

#include "precomp.h"

// Constructor for the SimplePacket class.

SimplePacket::SimplePacket(BOOL fPacketDirectionUp)
: 
	lLock (1),
	Packet_Direction_Up (fPacketDirectionUp)
{
}

// Destructor for the SimplePacket class
SimplePacket::~SimplePacket (void)
{
}

/*
 *	Unlock ()
 *
 *	Public
 *
 */
Void SimplePacket::Unlock ()
{
	/*
	 * Check to make sure that the packet is locked before allowing it to
	 * be unlocked.
	 */
	ASSERT (lLock > 0);

	/*
	 * If the lock count has reached zero, it is necessary to perform
	 * a suicide check.  This method will determine if there is any need
	 * to continue to exist.
	 */
	if (InterlockedDecrement(&lLock) == 0)
		delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\socket.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);
/*	Socket.cpp
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the implementation of our socket constructor/destructor functions.
 *
 */
#include "socket.h"
#include "plgxprt.h"

/* Size of listen queue */
#define	LISTEN_QUEUE_SIZE	3

/* External definitions */
extern HWND					TCP_Window_Handle;
extern PTransportInterface	g_Transport;

/*	
 *	void CreateAndConfigureListenSocket (VOID)
 *	
 *	Functional Description
 *		This function sets up a listening socket.
 *	returns INVALID_SOCKET if there is any error.
 */
SOCKET CreateAndConfigureListenSocket (VOID)
{
	SOCKADDR_IN		socket_control;
	SOCKET Socket;

	// Create the listening socket.
	Socket = socket (AF_INET, SOCK_STREAM, 0);

	if (Socket == INVALID_SOCKET) {
		WARNING_OUT (("Socket: error creating listening socket (errno = %d)", WSAGetLastError()));
		goto Error;
	}

	// The listen socket only waits for FD_ACCEPT msgs.
	ASSERT(TCP_Window_Handle);
	if (WSAAsyncSelect (Socket,
						TCP_Window_Handle,
						WM_SOCKET_NOTIFICATION,
						FD_ACCEPT) != 0)	{

		WARNING_OUT (("CreateAndConfigureListenSocket: Error on WSAAsyncSelect = %d", WSAGetLastError()));
		goto Error;
	}
	
	/*
	 * Load the socket control structure with the parameters necessary.
	 *	- Internet socket
	 *	- Let it assign any address to this socket
	 *	- Assign our port number
	 */
	socket_control.sin_family = AF_INET;
	socket_control.sin_addr.s_addr = INADDR_ANY;
	socket_control.sin_port = htons ( DEFAULT_LISTEN_PORT );

	/* Issue the bind call */
	if (bind (Socket, (LPSOCKADDR) &socket_control, sizeof(SOCKADDR_IN)) != 0) {
		WARNING_OUT (("Socket::Listen: bind failed:  Unable to use WinSock"));
		goto Error;
	}

	/*
	 * Issue a listen to WinSock to tell it we are willing to accept calls.
	 * This is a non-blocking listen, therefore we will receive FD_ACCEPT
	 * if someone is trying to call us.
	 */
	if (listen (Socket, LISTEN_QUEUE_SIZE) != 0) {
		WARNING_OUT (("Socket::Listen: listen failed:  Unable to use WinSock"));
		goto Error;
	}
	ASSERT(Socket != INVALID_SOCKET);

	return Socket;

Error:

    if (INVALID_SOCKET != Socket)
    {
        ::closesocket(Socket);
    }

	return INVALID_SOCKET;
}


/*
 *	PSocket	newSocket (SOCKET socket_number)
 *
 *	Functional Description:
 *		This is a constructor for the Socket object.  It allocates the
 *		send and receive buffers and sets up internal variables.
 */
PSocket	newSocket(TransportConnection XprtConn, PSecurityContext pSC)
{
    if (IS_SOCKET(XprtConn))
    {
        return ::newSocketEx(XprtConn, pSC);
    }
    return g_pSocketList->FindByTransportConnection(XprtConn, TRUE);
}


PSocket	newPluggableSocket(TransportConnection XprtConn)
{
    PSocket pSocket = ::newSocketEx(XprtConn, NULL);
    if (NULL != pSocket)
    {
    	g_pSocketList->SafeAppend(pSocket);
    }
    return pSocket;
}


PSocket	newSocketEx(TransportConnection XprtConn, PSecurityContext pSC)
{
    BOOL fRet;
	DBG_SAVE_FILE_LINE
	PSocket pSocket = new CSocket(&fRet, XprtConn, pSC);
	if (NULL != pSocket)
	{
	    if (fRet)
	    {
	        return pSocket;
	    }
	    pSocket->Release();
	}
	ERROR_OUT(("newSocket: Unable to allocate memory for Socket struct, pSocket=0x%x", pSocket));
	return NULL;
}


CSocket::CSocket(BOOL *_pfRet, TransportConnection _XprtConn, PSecurityContext _pSC)
:
    CRefCount(MAKE_STAMP_ID('S','o','c','k')),
    State(IS_SOCKET(_XprtConn) ? NOT_CONNECTED : SOCKET_CONNECTED),
    SecState((NULL == _pSC) ? SC_UNDETERMINED : SC_SECURE),
    pSC(_pSC),
    Max_Packet_Length(DEFAULT_MAX_X224_SIZE),
    Current_Length(0),
    Data_Indication_Buffer(NULL),
    Data_Indication_Length(0),
    Read_State(READ_HEADER),
    X224_Length(0),
    bSpaceAllocated(FALSE),
    Data_Memory(NULL),
    fExtendedX224(FALSE),
    fIncomingSecure(FALSE),
    XprtConn(_XprtConn)
{
    // assume failure
    *_pfRet = FALSE;

    // zero out sub structures
    ::ZeroMemory(&X224_Header, sizeof(X224_Header));
    ::ZeroMemory(&Retry_Info, sizeof(Retry_Info));
	Remote_Address[0] = '\0';

    if (IS_SOCKET(XprtConn))
    {
    	if (INVALID_SOCKET == XprtConn.nLogicalHandle)
    	{
    		/* Create a STREAM socket (fully reliable, full duplex, and sequenced) */
    		if ((XprtConn.nLogicalHandle = ::socket(AF_INET, SOCK_STREAM, 0))
    		    == INVALID_SOCKET)
    		{
    			ERROR_OUT (("CSocket: error acquiring INET socket # (errno = %d)", WSAGetLastError()));
    			return;
    		}
    	}

    	/* Enable Tx and Rx messages to the window */
    	ASSERT(TCP_Window_Handle);
    	if (::WSAAsyncSelect(XprtConn.nLogicalHandle, TCP_Window_Handle,
    	        WM_SOCKET_NOTIFICATION, 
    			FD_READ | FD_WRITE | FD_CLOSE | FD_CONNECT) != 0)
        {
    		WARNING_OUT (("CSocket: Error on WSAAsyncSelect = %d", WSAGetLastError()));
    	}
	}
    else
    {
        ASSERT(IS_PLUGGABLE(XprtConn));
        CPluggableConnection *p = ::GetPluggableConnection(this);
        if (NULL == p)
        {
    		ERROR_OUT(("newSocket: Unable to find plugable transport (%d, %d)",
    		        XprtConn.eType, XprtConn.nLogicalHandle));
    		return;
        }
    }

    // success
    *_pfRet = TRUE;
}


/*
 *	void freeSocket (PSocket, TransportConnection)
 *
 *	Functional Description:
 *		This is a destructor for the Socket object.  It frees the send
 *		and receive buffers and connection structure.
 *		It will also cleanup the listening socket. In this case, 
 *		"pSocket" is set to NULL and "trash_packets" should be set to TRUE.
 */
void freeSocket(PSocket pSocket, TransportConnection XprtConn)
{
    if (IS_SOCKET(XprtConn))
    {
        if (NULL != g_pSocketList)
        {
            g_pSocketList->SafeRemove(pSocket);
        }
        freeSocketEx(pSocket, XprtConn);
    }
}


void freeListenSocket(TransportConnection XprtConn)
{
    ASSERT(IS_SOCKET(XprtConn));
    freeSocketEx(NULL, XprtConn);
}


void freePluggableSocket(PSocket pSocket)
{
    freeSocketEx(pSocket, pSocket->XprtConn);
    if (NULL != g_pSocketList)
    {
        g_pSocketList->SafeRemove(pSocket);
    }
}


void freeSocketEx(PSocket pSocket, TransportConnection XprtConn)
{
	// Either "pSocket" is NULL, or the socket is not invalid.
    #ifdef _DEBUG
    if (IS_SOCKET(XprtConn))
    {
        if (NULL != pSocket)
        {
	        ASSERT(INVALID_SOCKET != pSocket->XprtConn.nLogicalHandle);
	    }
	    else
	    {
	        // it is a listen socket
	        ASSERT(INVALID_SOCKET != XprtConn.nLogicalHandle);
	    }
	}
	#endif

	// Determine the socket number to use... Either the socket is the
	// socket indicated in the PSocket structure, or it is a structure-less
	// listen socket. Note: both cannot be valid!

    if (IS_SOCKET(XprtConn))
    {
    	SOCKET socket = (pSocket) ? pSocket->XprtConn.nLogicalHandle : XprtConn.nLogicalHandle;
        XprtConn.nLogicalHandle = socket;

    	/* Disable notifications to our window */
    	if (::IsWindow(TCP_Window_Handle))
    	{
    	    ::WSAAsyncSelect(socket, TCP_Window_Handle, 0, 0);
    	}
    }

	if (pSocket != NULL)
	{
	    pSocket->Release();
	}
	else
	{
		// This is the listening socket
		::ShutdownAndClose (XprtConn, FALSE, 0);
	}
}


CSocket::~CSocket(void)
{
	switch (State)
	{
	case SOCKET_CONNECTED:
	// case WAITING_FOR_DISCONNECT:
		/* All physically connected states issue a shutdown() first */
		::ShutdownAndClose(XprtConn, TRUE, SD_BOTH);
		break;

	case X224_CONNECTED:
		// Shutdown disable reception only.
		::ShutdownAndClose(XprtConn, TRUE, SD_RECEIVE);
		break;

	default:
		::ShutdownAndClose(XprtConn, FALSE, 0);
		break;
	}

	/* Free the structures */
	FreeTransportBuffer();
	delete pSC;
}


void CSocket::FreeTransportBuffer(void)
{
    if (NULL != Data_Memory)
    {
        ::FreeMemory(Data_Memory);
        Data_Memory = NULL;
        Data_Indication_Buffer = NULL;
    }
}



void CSocketList::SafeAppend(PSocket pSocket)
{
    ::EnterCriticalSection(&g_csTransport);
    if (! Find(pSocket))
    {
        Append(pSocket);
    }
    ::LeaveCriticalSection(&g_csTransport);
}


BOOL CSocketList::SafeRemove(PSocket pSocket)
{
    ::EnterCriticalSection(&g_csTransport);
    BOOL fRet = Remove(pSocket);
    ::LeaveCriticalSection(&g_csTransport);
    return fRet;
}


PSocket CSocketList::FindByTransportConnection(TransportConnection XprtConn, BOOL fNoAddRef)
{
    PSocket pSocket;
    ::EnterCriticalSection(&g_csTransport);
    Reset();
    while (NULL != (pSocket = Iterate()))
    {
        if (IS_SAME_TRANSPORT_CONNECTION(pSocket->XprtConn, XprtConn))
        {
            if (! fNoAddRef)
            {
                pSocket->AddRef();
            }
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);
    return pSocket;
}


PSocket CSocketList::RemoveByTransportConnection(TransportConnection XprtConn)
{
    PSocket pSocket;
    ::EnterCriticalSection(&g_csTransport);
    Reset();
    while (NULL != (pSocket = Iterate()))
    {
        if (IS_SAME_TRANSPORT_CONNECTION(pSocket->XprtConn, XprtConn))
        {
            Remove(pSocket);
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);
    return pSocket;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\tprtctrl.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);

#include "tprtsec.h"
#include <tprtntfy.h>
#include "cnpcoder.h"
#include "plgxprt.h"

// #undef TRACE_OUT
// #define TRACE_OUT   WARNING_OUT


/*    Tprtctrl.cpp
 *
 *    Copyright (c) 1996 by Microsoft Corporation
 *
 *    Abstract:
 *        This module maintains the TCP transport and all connections.
 *
 */

/* External definitions */
extern HINSTANCE            g_hDllInst;
extern PTransportInterface    g_Transport;
extern SOCKET                Listen_Socket;
extern SOCKET                Listen_Socket_Secure;
extern CPluggableTransport *g_pPluggableTransport;

extern PController            g_pMCSController;
extern CCNPCoder            *g_CNPCoder;
extern HWND                 TCP_Window_Handle;
extern BOOL                 g_bRDS;

BOOL FindSocketNumber(DWORD dwGCCID, SOCKET * socket_number);

/*
 *    The following array contains a template for the X.224 data header.
 *    The 5 of the 7 bytes that it initializes are actually sent to the
 *    wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *    The array is only used when we encode a data PDU.
 */
extern UChar g_X224Header[];

// The external MCS Controller object
extern PController    g_pMCSController;

// plugable transport prototypes
int X224Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *pnLastError);
int Q922Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *pnLastError);


/*
 *    TransportError    ConnectRequest (    TransportAddress    transport_address,
 *                                        BOOL                fSecure
 *                                        PTransportConnection         pXprtConn)
 *
 *    Functional Description:
 *        This function initiates a connection.  It passes the transport address
 *        to the TCP transport.  It will either deny the request or accept the
 *        request and call us back when the physical connection is established.
 *
 *        We return the transport connection handle in the transport_connection
 *        address.  Although we return this transport number to the user, it
 *        is not ready for data transfer until the user receives the
 *        TRANSPORT_CONNECT_INDICATION and responds with a ConnectResponse() call.
 *        At that point, the transport connection is up and running.
 */
TransportError    ConnectRequest (TransportAddress    transport_address,
                                BOOL                fSecure,
                 /* out */       PTransportConnection         pXprtConn)
{
    TransportError rc = TRANSPORT_NO_ERROR;
    PSocket        pSocket;
    PSecurityContext pSC = NULL;
    ULong        address;
    SOCKADDR_IN    sin;
    CPluggableConnection *p = NULL;

    // initialize transport connection
    UINT nPluggableConnID = ::GetPluggableTransportConnID(transport_address);
    if (nPluggableConnID)
    {
        p = ::GetPluggableConnection(nPluggableConnID);
        if (NULL != p)
        {
            pXprtConn->eType = p->GetType();
            pXprtConn->nLogicalHandle = nPluggableConnID;
            ASSERT(IS_PLUGGABLE(*pXprtConn));
        }
        else
        {
            return TRANSPORT_NO_SUCH_CONNECTION;
        }
    }
    else
    {
        pXprtConn->eType = TRANSPORT_TYPE_WINSOCK;
        pXprtConn->nLogicalHandle = INVALID_SOCKET;
    }

    // we are connecting X224...
    ::OnProtocolControl(*pXprtConn, PLUGXPRT_CONNECTING);

    // Try to prepare a security context object if we're told to do so.
    if ( fSecure )
    {
        // If we're trying to connect securely but can't, fail
        if ( NULL == g_Transport->pSecurityInterface )
        {
            WARNING_OUT(("Placing secure call failed: no valid security interface"));
            return TRANSPORT_SECURITY_FAILED;
        }

        DBG_SAVE_FILE_LINE
        if (NULL != (pSC = new SecurityContext(g_Transport->pSecurityInterface,
                                                transport_address)))
        {
            if ( TPRTSEC_NOERROR != pSC->Initialize(NULL,0))
            {
                // If we can't init a security context, fail
                delete pSC;
                pSC = NULL;
                WARNING_OUT(("Placing secure call failed: could not initialize security context"));
                return TRANSPORT_SECURITY_FAILED;
            }
        }
    }

    /* Create and Initialize the Socket object */
    pSocket = newSocket(*pXprtConn, pSC);
    if( pSocket == NULL )
        return (TRANSPORT_MEMORY_FAILURE);

    pSocket->SecState = ( NULL == pSC ) ? SC_NONSECURE : SC_SECURE;

    if (IS_SOCKET(*pXprtConn))
    {
        //
        // LAURABU SALEM BUGBUG
        // Change this to allow initializer to pass in the outbound
        // port!
        //

        u_short uPort = DEFAULT_LISTEN_PORT;
        TCHAR szAddress[MAXIMUM_IP_ADDRESS_SIZE];
        lstrcpyn(szAddress, transport_address, MAXIMUM_IP_ADDRESS_SIZE);
        LPTSTR pszSeparator = (LPTSTR)_StrChr(szAddress, _T(':'));
        if (NULL != pszSeparator)
        {
            uPort = (u_short)DecimalStringToUINT(CharNext(pszSeparator));
            *pszSeparator = _T('\0');
        }

        /* Convert the ascii string into an Internet Address */
        if ((address = inet_addr(szAddress)) == INADDR_NONE)
        {
            WARNING_OUT (("ConnectRequest: %s is an invalid host addr", szAddress));
            rc = TRANSPORT_CONNECT_REQUEST_FAILED;
            goto Bail;
        }

        lstrcpyn (pSocket->Remote_Address, transport_address, MAXIMUM_IP_ADDRESS_SIZE);

        /*
         * Load the socket control structure with the parameters necessary.
         *
         *    - Internet socket
         *    - Let it assign any address to this socket
         *    - Assign our port number (depending on secure/nonsecure call!)
         */
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = address;
        sin.sin_port = htons (uPort);

        /* Attempt a connection to the remote site */
        TRACE_OUT (("ConnectRequest: Issuing connect: address = %s", transport_address));
        if (::connect(pSocket->XprtConn.nLogicalHandle, (const struct sockaddr *) &sin, sizeof(sin)) == 0)
        {
            TRACE_OUT (("ConnectRequest:   State = SOCKET_CONNECTED..."));
            /* Add socket to connection list */
            // bugbug: we may fail to insert.
            g_pSocketList->SafeAppend(pSocket);
            ::SendX224ConnectRequest(pSocket->XprtConn);
        }
        else
        if (WSAGetLastError() == WSAEWOULDBLOCK)
        {
            /* If the error message is WSAEWOULDBLOCK, we must wait for the FD_CONNECT. */
            TRACE_OUT (("ConnectRequest:   State = WAITING_FOR_CONNECTION..."));
            pSocket -> State = WAITING_FOR_CONNECTION;
            /* Add socket to connection list */
            // bugbug: we may fail to insert.
            g_pSocketList->SafeAppend(pSocket);
            // SendStatusMessage(pSocket -> Remote_Address, TSTATE_CONNECT_PENDING, IDS_NULL_STRING);
        }
        else
        {
            WARNING_OUT (("ConnectRequest: Connect Failed error = %d",WSAGetLastError()));

            /* The connect() call failed, close the socket and notify the owner    */
            // SendStatusMessage (pSocket -> Remote_Address, TSTATE_NOT_READY, IDS_NULL_STRING);
            ::ShutdownAndClose(pSocket->XprtConn, FALSE, 2);
            rc = TRANSPORT_CONNECT_REQUEST_FAILED;
            goto Bail;
        }
    }
    else
    {
        ASSERT(IS_PLUGGABLE(*pXprtConn));
        g_pSocketList->SafeAppend(pSocket);
        if (IS_PLUGGABLE_X224(*pXprtConn))
        {
           ::SendX224ConnectRequest(pSocket->XprtConn);
        }
        else
        if (IS_PLUGGABLE_PSTN(*pXprtConn))
        {
            rc = p->TConnectRequest();
            ASSERT(TRANSPORT_NO_ERROR == rc);
        }
    }

Bail:

    ASSERT(NULL != pSocket);
    if (TRANSPORT_NO_ERROR == rc)
    {
        *pXprtConn = pSocket->XprtConn;
    }
    else
    {
        ::freeSocket(pSocket, *pXprtConn);
    }

    return rc;
}


/*
 *    BOOL ConnectResponse (TransportConnection    XprtConn)
 *
 *    Functional Description:
 *        This function is called by the user in response to a
 *        TRANSPORT_CONNECT_INDICATION callback from us.  By making this call the
 *        user is accepting the call.  If the user does not want to accept the
 *        call, he should call DisconnectRequest();
 */
BOOL ConnectResponse (TransportConnection XprtConn)
{
    PSocket    pSocket;

    TRACE_OUT (("ConnectResponse(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));

    /* If this is an invalid handle, return error */
    if(NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        BOOL fRet;
        if (pSocket->State == SOCKET_CONNECTED)
        {
            /* We do not change this state in ANY other place BECAUSE  it breaks the connect request*/
            pSocket->State = X224_CONNECTED;
            fRet = TRUE;
        }
        else
        {
            ERROR_OUT(("ConnectResponse: Illegal ConnectResponse packet"));
            fRet = FALSE;
        }
        pSocket->Release();
        return fRet;
    }
    return FALSE;
}

#ifdef TSTATUS_INDICATION
/*
 *    Void    SendStatusMessage (    PChar RemoteAddress,
 *                                TransportState State,
 *                                 UInt message_id)
 *
 *    Functional Description:
 *        This function is called to send a status indication to the user. The
 *        specific text of the message is contained in a string resource.
 */
Void SendStatusMessage(    PChar RemoteAddress,
                          TransportState    state,
                          UInt                message_id)
{
    TransportStatus transport_status;
    char            sTransport[80] = "";
    char            message[80] = "";

    if( message_id == IDS_NULL_STRING )
        message[0] = '\000';
    else
        LoadString(
                (HINSTANCE) g_hDllInst,
                (UINT) message_id,
                (LPSTR) message,
                (int) sizeof(message) );

     /*
     **    We issue a callback to the user to notify him of the message
     */
    transport_status.device_identifier = "";
    transport_status.remote_address = RemoteAddress;
    transport_status.message = message;
    transport_status.state = state;

    g_pMCSController->HandleTransportStatusIndication(&transport_status);
}
#endif


/*
 *    Void    SendX224ConnectRequest(TransportConnection XprtConn)
 *
 *    Functional Description:
 *        This function is called upon receipt of the FD_CONNECT from Winsock.
 *        It indicates that the physical connection is established, and sends
 *        the X224 connection request packet.
 */
void SendX224ConnectRequest(TransportConnection XprtConn)
{
    PSocket            pSocket;

    static X224_CR_FIXED cr_fixed =
    {
        { 3, 0, 0, UNK },
        UNK,
        { CONNECTION_REQUEST_PACKET, UNK, UNK, UNK, UNK, 0 } // common info
    };

    TRACE_OUT(("SendX224ConnectRequest"));

    CNPPDU                  cnp_pdu;
    ConnectRequestPDU_reliableSecurityProtocols_Element cnp_cr_rsp_element;
    LPBYTE                  pbToSendBuf = NULL;
    UINT                    cbToSendBuf = 0;
    LPBYTE                  encoded_pdu;
    UINT                    encoded_pdu_length;

    TransportError          error;

    cnp_pdu.choice = connectRequest_chosen;
    cnp_pdu.u.connectRequest.bit_mask = 0;
    cnp_pdu.u.connectRequest.protocolIdentifier = t123AnnexBProtocolId;
    cnp_pdu.u.connectRequest.reconnectRequested = FALSE;

    // Sanity check field sizes... these need to conform to protocol
    ASSERT (sizeof(RFC_HEADER) == 4);
    ASSERT (sizeof(X224_DATA_PACKET) == 7);
    ASSERT (sizeof(X224_CONNECT_COMMON) == 6);
    ASSERT (sizeof(X224_TPDU_INFO) == 3);

    /* If this is an invalid handle, return */
    if (NULL == (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
        return;

    if (IS_SOCKET(pSocket->XprtConn))
    {
        if (pSocket -> State != WAITING_FOR_CONNECTION)
        {
            ERROR_OUT (("SendX224ConnectRequest: Illegal Socket State"));
            goto MyExit;
        }
    }
    else
    {
        ASSERT(IS_PLUGGABLE(pSocket->XprtConn));
        if (X224_CONNECTED == pSocket->State)
        {
            // after query remote, we need to reset the state back to socket connected
            pSocket->State = SOCKET_CONNECTED;
        }
        if (SOCKET_CONNECTED != pSocket->State)
        {
            ERROR_OUT (("SendX224ConnectRequest: Illegal Socket State"));
            goto MyExit;
        }
    }

    // If there is a security context associated with this socket, we
    // are settting up for a secure call and will indicate that in the CNP
    // portion of the packet
    if (NULL != pSocket->pSC)
    {
        TRACE_OUT(("SendX224ConnectRequest: requesting secure connection"));

        cnp_pdu.u.connectRequest.bit_mask |= reliableSecurityProtocols_present;
        cnp_cr_rsp_element.next = NULL;
        cnp_cr_rsp_element.value.choice = gssApiX224_chosen;
        cnp_pdu.u.connectRequest.reliableSecurityProtocols = &cnp_cr_rsp_element;
    }
    else
    {
        TRACE_OUT(("SendX224ConnectRequest: requesting NON-secure connection"));
    }

    if (! g_CNPCoder->Encode((LPVOID) &cnp_pdu,
                             CNPPDU_PDU,
                             PACKED_ENCODING_RULES,
                             &encoded_pdu,
                             &encoded_pdu_length))
    {
        ERROR_OUT(("SendX224ConnectRequest: Can't encode cnp pdu"));
        goto MyExit;
    }

    pSocket -> State = SOCKET_CONNECTED;

    /* X224 header */
    cr_fixed.conn.msbSrc = (UChar) (XprtConn.nLogicalHandle >> 8);
    cr_fixed.conn.lsbSrc = (UChar) XprtConn.nLogicalHandle;

    cbToSendBuf = sizeof(X224_CR_FIXED)+sizeof(X224_TPDU_INFO)+sizeof(X224_VARIABLE_INFO)+encoded_pdu_length;
    cr_fixed.rfc.lsbPacketSize = (UChar)cbToSendBuf;
    cr_fixed.HeaderSize = (UChar)(sizeof(X224_CONNECT_COMMON)+sizeof(X224_TPDU_INFO)+sizeof(X224_VARIABLE_INFO)+encoded_pdu_length);
    ASSERT ( cbToSendBuf <= 128);
    DBG_SAVE_FILE_LINE
    pbToSendBuf = new BYTE[cbToSendBuf];
    if (NULL == pbToSendBuf)
    {
        ERROR_OUT(("SendX224ConnectRequest: failed to allocate memory"));
        goto MyExit;
    }

    {
        LPBYTE pbTemp = pbToSendBuf;
        memcpy(pbTemp, (LPBYTE) &cr_fixed, sizeof(cr_fixed));
        pbTemp += sizeof(cr_fixed);

        {
            X224_TPDU_INFO x224_tpdu_info = { TPDU_SIZE, 1, DEFAULT_TPDU_SIZE };
            memcpy(pbTemp, (LPBYTE) &x224_tpdu_info, sizeof(x224_tpdu_info));
            pbTemp += sizeof(x224_tpdu_info);
        }

        {
            X224_VARIABLE_INFO x224_var_info = { T_SELECTOR, (UChar)encoded_pdu_length };
            memcpy(pbTemp, (LPBYTE) &x224_var_info, sizeof(x224_var_info));   // bug: error handling
            pbTemp += sizeof(x224_var_info);
            memcpy(pbTemp, encoded_pdu, encoded_pdu_length);
        }
    }

    g_CNPCoder->FreeEncoded(encoded_pdu);

    /* Attempt to send data out the socket */
    error = FlushSendBuffer(pSocket, pbToSendBuf, cbToSendBuf);
    ASSERT (TRANSPORT_NO_ERROR == error);

    delete [] pbToSendBuf;

MyExit:

    pSocket->Release();
}



/*
 *    Void    SendX224ConnectConfirm (PSocket pSocket, unsigned int remote)
 *
 *    Functional Description:
 *        This function is called upon receipt of the X224 connection request
 *        packet. It indicates that the remote side wants to establish a
 *        logical connection, and sends the X224 connection response packet.
 *
 *    Return value:
 *        TRUE, if everything went ok.
 *        FALSE, otherwise (this implies a Disconnect will be issued for the socket).
 */
// LONCHANC: "remote" is from the X.224 ConnectRequest
BOOL SendX224ConnectConfirm (PSocket pSocket, unsigned int remote)
{
    //PUChar            ptr;
    LPBYTE                  pbToSendBuf = NULL;
    UINT            cbToSendBuf = 0;
    LPBYTE                  encoded_pdu = NULL;
    UINT                    encoded_pdu_length = 0;
    CNPPDU                  cnp_pdu;
    BOOL            fAcceptSecure = FALSE;
    BOOL            fRequireSecure = FALSE;

    TRACE_OUT(("SendX224ConnectConfirm"));

    fAcceptSecure = TRUE;

        static X224_CC_FIXED cc_fixed =
        {
            { 3, 0, 0, UNK },    // RFC1006 header
            UNK,
            { CONNECTION_CONFIRM_PACKET, UNK, UNK, UNK, UNK, 0 } // common info
        };

    // Sanity check field sizes... these need to conform to protocol
    ASSERT (sizeof(RFC_HEADER) == 4);
    ASSERT (sizeof(X224_DATA_PACKET) == 7);
    ASSERT (sizeof(X224_CONNECT_COMMON) == 6);
    ASSERT (sizeof(X224_TPDU_INFO) == 3);

    /* X224 header */
    cc_fixed.conn.msbDest = (UChar) (remote >> 8);
    cc_fixed.conn.lsbDest = (UChar) remote;
    cc_fixed.conn.msbSrc = (UChar) (pSocket->XprtConn.nLogicalHandle >> 8);
    cc_fixed.conn.lsbSrc = (UChar) pSocket->XprtConn.nLogicalHandle;

    cnp_pdu.choice = connectConfirm_chosen;
    cnp_pdu.u.connectConfirm.bit_mask = 0;
    cnp_pdu.u.connectConfirm.protocolIdentifier = t123AnnexBProtocolId;

    if ( pSocket->fExtendedX224 )
    {
        TRACE_OUT(("SendX224ConnectConfirm reply using extended X224"));

        if ( pSocket->fIncomingSecure )
        {
            TRACE_OUT(("SendX224ConnectConfirm: reply to secure call request"));

            // Security not even initialized?
            if ( NULL == g_Transport->pSecurityInterface )
            {
                WARNING_OUT(("Can't accept secure call: no sec interface"));
            }
            // Registry indicates no secure calls? If we're in the service
            // then security is always 'on'.
            else if    ( !g_bRDS && !fAcceptSecure)
            {
                WARNING_OUT(("Can't accept secure call: security disabled"));
            }
            else    // OK to take secure call
            {
                TRACE_OUT(("Creating security context for incoming call on socket (%d, %d).", pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle ));
                if ( NULL != (pSocket->pSC =
                    new SecurityContext(g_Transport->pSecurityInterface, "")))
                {
                    // Indicate we're ready for a secure call in the CC packet
                    cnp_pdu.u.connectConfirm.bit_mask |=
                        ConnectConfirmPDU_reliableSecurityProtocol_present;
                    cnp_pdu.u.connectConfirm.reliableSecurityProtocol.choice =
                        gssApiX224_chosen;
                    pSocket->SecState = SC_SECURE;
                }
                else
                {
                    ERROR_OUT(("Error creating sec context on received call"));
                    // We will report no-support for security in our CC
                    pSocket->SecState = SC_NONSECURE;
                }
            }
        }
        else if (    // Incoming call is not secure, but not downlevel

                // Running as a service?
                g_bRDS ||
                fRequireSecure)
        {
            if (g_bRDS)
            {
                WARNING_OUT(("Can't accept non-secure call in SERVICE"));
            }
            else
            {
                WARNING_OUT(("Can't accept non-secure call -- we require security"));
            }
            return FALSE;
        }
        else
        {
            pSocket->SecState = SC_NONSECURE;
        }

                if (! g_CNPCoder->Encode((LPVOID) &cnp_pdu,
                                         CNPPDU_PDU,
                                         PACKED_ENCODING_RULES,
                                         &encoded_pdu,
                                         &encoded_pdu_length))
                {
                    ERROR_OUT(("SendX224ConnectRequest: Can't encode cnp pdu"));
                    return FALSE;
                }

                cbToSendBuf = sizeof(X224_CC_FIXED)+sizeof(X224_VARIABLE_INFO)+encoded_pdu_length;
                cc_fixed.rfc.lsbPacketSize = (UChar)cbToSendBuf;
                cc_fixed.HeaderSize = (UChar)(sizeof(X224_CONNECT_COMMON) + sizeof(X224_VARIABLE_INFO) + encoded_pdu_length);
                ASSERT( cbToSendBuf <= 128 );
                pbToSendBuf = new BYTE[cbToSendBuf];
                if (NULL == pbToSendBuf)
                {
                    ERROR_OUT(("SendX224ConnectConfirm: failed to allocate memory"));
                    return FALSE;
                }

                PBYTE pbTemp = pbToSendBuf;
                memcpy(pbTemp, (LPBYTE) &cc_fixed, sizeof(cc_fixed));
                pbTemp += sizeof(cc_fixed);

                X224_VARIABLE_INFO x224_var_info = { T_SELECTOR_2 /*0xc2*/, (UChar)encoded_pdu_length };
                memcpy(pbTemp, (LPBYTE) &x224_var_info, sizeof(x224_var_info));
                pbTemp += sizeof(x224_var_info);

                memcpy(pbTemp, encoded_pdu, encoded_pdu_length);

                g_CNPCoder->FreeEncoded(encoded_pdu);
    }
    else    // Incoming call is downlevel
    {
        if ( g_bRDS || fRequireSecure)
        {
            WARNING_OUT(("Can't accept downlevel call in RDS or if security required"));
            return FALSE;
        }

        pSocket->SecState = SC_NONSECURE;

        // Downlevel: send packet w/out TSELECTOR variable portion
        cc_fixed.rfc.lsbPacketSize = sizeof(X224_CC_FIXED);
        cc_fixed.HeaderSize = sizeof(X224_CONNECT_COMMON);
        cbToSendBuf = sizeof(X224_CC_FIXED);
                pbToSendBuf = new BYTE[cbToSendBuf];
                memcpy(pbToSendBuf, (LPBYTE) &cc_fixed, sizeof(cc_fixed));
    }

    /* Attempt to send data out the socket */
#ifdef DEBUG
    TransportError error =
#endif // DEBUG
    FlushSendBuffer(pSocket, pbToSendBuf, cbToSendBuf);
#ifdef  DEBUG
    ASSERT (TRANSPORT_NO_ERROR == error);
#endif  // DEBUG
        delete [] pbToSendBuf;
    return TRUE;
}

BOOL SendX224DisconnectRequest(PSocket pSocket, unsigned int remote, USHORT usReason)
{
    LPBYTE      pbToSendBuf = NULL;
    UINT    cbToSendBuf = 0;
    CNPPDU      cnp_pdu;
    LPBYTE      encoded_pdu = NULL;
    UINT        encoded_pdu_length = 0;

    TRACE_OUT(("SendX224DisconnectRequest"));

    static X224_DR_FIXED dr_fixed =
    {
        { 3, 0, 0, UNK },   // RFC1006 header
        UNK,
        { DISCONNECT_REQUEST_PACKET, UNK, UNK, UNK, UNK, 0 },
    };

    ASSERT (pSocket->fExtendedX224);
    ASSERT (sizeof(RFC_HEADER) == 4);
    ASSERT (sizeof(X224_DATA_PACKET) == 7);

    ::OnProtocolControl(pSocket->XprtConn, PLUGXPRT_DISCONNECTING);

    dr_fixed.disconn.msbDest = (UChar) (remote >> 8);
    dr_fixed.disconn.lsbDest = (UChar) remote;
    dr_fixed.disconn.msbSrc = (UChar) (pSocket->XprtConn.nLogicalHandle >> 8);
    dr_fixed.disconn.lsbSrc = (UChar) pSocket->XprtConn.nLogicalHandle;

    cnp_pdu.choice = disconnectRequest_chosen;
    cnp_pdu.u.disconnectRequest.bit_mask = 0;
    cnp_pdu.u.disconnectRequest.disconnectReason.choice = usReason;

    if (! g_CNPCoder->Encode((LPVOID) &cnp_pdu,
                             CNPPDU_PDU,
                             PACKED_ENCODING_RULES,
                             &encoded_pdu,
                             &encoded_pdu_length))
    {
        ERROR_OUT(("SendX224DisconnectRequest: Can't encode cnp pdu"));
        return FALSE;
    }

    cbToSendBuf = sizeof(X224_DR_FIXED) + sizeof(X224_VARIABLE_INFO) + encoded_pdu_length;
    dr_fixed.rfc.lsbPacketSize = (UChar)cbToSendBuf;
    dr_fixed.HeaderSize = (UChar)(sizeof(X224_DISCONN) + sizeof(X224_VARIABLE_INFO) + encoded_pdu_length);
    ASSERT( cbToSendBuf <= 128 );
    pbToSendBuf = new BYTE[cbToSendBuf];
    if (NULL == pbToSendBuf)
    {
        ERROR_OUT(("SendX224DisconnectRequest: failed to allocate memory"));
        return FALSE;
    }
    LPBYTE pbTemp = pbToSendBuf;
    memcpy(pbTemp, (LPBYTE) &dr_fixed, sizeof(dr_fixed));
    pbTemp += sizeof(dr_fixed);
    X224_VARIABLE_INFO x224_var_info = { 0xe0, (UChar)encoded_pdu_length };
    memcpy(pbTemp, (LPBYTE) &x224_var_info, sizeof(x224_var_info));
    pbTemp += sizeof(x224_var_info);
    memcpy(pbTemp, encoded_pdu, encoded_pdu_length);

    g_CNPCoder->FreeEncoded(encoded_pdu);

    /* Attempt to send data out the socket */
#ifdef DEBUG
    TransportError error =
#endif // DEBUG
        FlushSendBuffer(pSocket, pbToSendBuf, cbToSendBuf);
#ifdef  DEBUG
    ASSERT (TRANSPORT_NO_ERROR == error);
#endif  // DEBUG
    return TRUE;
}

/*
 *    void    ContinueAuthentication (PSocket pSocket)
 *
 *    Functional Description:
 */
void ContinueAuthentication (PSocket pSocket)
{
    ULong                packet_size;
    PUChar                Buffer;
    PSecurityContext    pSC = pSocket->pSC;

    if (NULL != pSC) {

        TRACE_OUT(("ContinueAuthentication: sending data packet"));

        ASSERT(NULL != pSC->GetTokenBuf());
        ASSERT(0 != pSC->GetTokenSiz());

        /* We send an X224 data */
        packet_size = sizeof(X224_DATA_PACKET) + pSC->GetTokenSiz();
        DBG_SAVE_FILE_LINE
        Buffer = new UChar[packet_size];
        if (NULL != Buffer)
        {
            memcpy(Buffer + sizeof(X224_DATA_PACKET),
                    pSC->GetTokenBuf(),
                    pSC->GetTokenSiz());

            /* X224 header */
            memcpy (Buffer, g_X224Header, sizeof(X224_DATA_PACKET));
            AddRFCSize (Buffer, packet_size);

            /* Attempt to send data out the socket */
#ifdef DEBUG
            TransportError error = FlushSendBuffer(pSocket, (LPBYTE) Buffer, packet_size);
            ASSERT (TRANSPORT_NO_ERROR == error);
#else  // DEBUG
            FlushSendBuffer(pSocket, (LPBYTE) Buffer, packet_size);
#endif  // DEBUG
            delete [] Buffer;
        }
        else {
            // bugbug: what do we need to do in case of a mem alloc failure?
            WARNING_OUT (("ContinueAuthentication: memory allocation failure."));
        }
    }
    else {
        ERROR_OUT(("ContinueAuthentication called w/ bad socket"));
    }
}

/*
 *    The following function processes the variable part of incoming X.224
 *    CONNECT_REQUEST and CONNECT_CONFIRM PDUs.
 *    For now, it can only process Max PDU size and security T_SELECTOR requests.
 */
BOOL ProcessX224ConnectPDU (PSocket pSocket, PUChar CP_ptr, UINT CP_length, ULONG *pNotify)
{
    UChar                length;
    BOOL                bSecurityInfoFound = FALSE;
    PSecurityContext     pSC = pSocket->pSC;

/* This structure must be accessed using byte-alignment */
#pragma pack(1)
    X224_VARIABLE_INFO        *pX224VarInfo;
/* return to normal alignment */
#pragma pack()

    while (CP_length > 0) {
        pX224VarInfo = (X224_VARIABLE_INFO *) CP_ptr;

        /*
         *    Check the packet to see if it contains a valid TPDU_SIZE part.  If it
         *    does, we need to reset the max packet size for this socket.
         */
        if (TPDU_SIZE == pX224VarInfo->InfoType) {
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
                X224_TPDU_INFO        *pX224TpduSize;
/* return to normal alignment */
#pragma pack()
            pX224TpduSize = (X224_TPDU_INFO *) CP_ptr;
            ASSERT (pX224TpduSize->InfoSize == 1);
            if (pX224TpduSize->Info != DEFAULT_TPDU_SIZE) {

                // We do not accept too small PDU sizes
                if ((pX224TpduSize->Info < LOWEST_TPDU_SIZE) && (pX224TpduSize->Info < HIGHEST_TPDU_SIZE))
                {
                  if (NULL != pNotify)
                    *pNotify = TPRT_NOTIFY_INCOMPATIBLE_T120_TPDU;
                  return FALSE;
                }
                pSocket->Max_Packet_Length = (1 << pX224TpduSize->Info);
            }
        }
        /*
         *    Check the packet to see if it contains a valid
         *    TSELECTOR variable portion. If so, make sure it's security related
         *    and include one in the reply
         */
        else if (T_SELECTOR == pX224VarInfo->InfoType || T_SELECTOR_2 == pX224VarInfo->InfoType)
                {
                    // Try to decode
                    LPVOID pdecoding_buf = NULL;
                    UINT decoding_len = 0;
                    LPBYTE pbEncoded_data = CP_ptr + sizeof(X224_VARIABLE_INFO);
                    if ( g_CNPCoder->Decode (pbEncoded_data,
                                             pX224VarInfo->InfoSize,
                                             CNPPDU_PDU, PACKED_ENCODING_RULES,
                                             (LPVOID *) &pdecoding_buf, &decoding_len))
                    {
                        bSecurityInfoFound = TRUE;
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
    CNPPDU        *pCnp_pdu;
/* return to normal alignment */
#pragma pack()
                        pCnp_pdu = (CNPPDU *) pdecoding_buf;
                        if (pSocket->Read_State == CONNECTION_REQUEST) {
                            TRACE_OUT(("CR packet using TSELECTOR extension"));
                            pSocket->fExtendedX224 = TRUE;
                            if (pCnp_pdu->u.connectRequest.bit_mask & reliableSecurityProtocols_present)
                            {
                                PConnectRequestPDU_reliableSecurityProtocols pRSP = pCnp_pdu->u.connectRequest.reliableSecurityProtocols;
                                if (gssApiX224_chosen == pRSP->value.choice)
                                {
                                    pSocket->fIncomingSecure = TRUE;
                                }
                            }
                        }
                        else {
                            ASSERT (pSocket->Read_State == CONNECTION_CONFIRM);
                            if ((NULL != pSC) && (pSC->ContinueNeeded())) {
                                ConnectConfirmPDU *pCnpCc = &pCnp_pdu->u.connectConfirm;
                                if ((pCnpCc->bit_mask & ConnectConfirmPDU_reliableSecurityProtocol_present )
                                    && gssApiX224_chosen == pCnpCc->reliableSecurityProtocol.choice)
                                {
                                    // Everything is OK, we got an extended X224 response
                                    // to our secure CR.
                                    ContinueAuthentication(pSocket);
                                }
                                else {
                                    WARNING_OUT(("No-support response to secure call attempt"));
                                    if (NULL != pNotify)
                                        *pNotify = TPRT_NOTIFY_REMOTE_NO_SECURITY;
                                    return FALSE;
                                }
                            }
                        }
                    }
                    g_CNPCoder->FreeDecoded(CNPPDU_PDU, pdecoding_buf);
        }
        else {
            ERROR_OUT (("ProcessX224ConnectPDU: Received X.224 Connect packet with unrecognizable parts."));
        }

        // Adjust the pointer and length and the X.224 CR packet.
        length = pX224VarInfo->InfoSize + sizeof(X224_VARIABLE_INFO);
        CP_ptr += length;
        CP_length -= length;
    }

    if (bSecurityInfoFound == FALSE) {
        if ((pSocket->Read_State == CONNECTION_CONFIRM) && (pSC != NULL) && pSC->ContinueNeeded()) {
            WARNING_OUT(("Downlevel response to secure call attempt"));
            if (NULL != pNotify)
              *pNotify = TPRT_NOTIFY_REMOTE_DOWNLEVEL_SECURITY;
            return FALSE;
        }
    }

    return TRUE;
}

void ProcessX224DisconnectPDU(PSocket pSocket, PUChar CP_ptr, UINT CP_length, ULONG *pNotify)
{
    UChar                length;
    BOOL                bSecurityInfoFound = FALSE;
    PSecurityContext     pSC = pSocket->pSC;

    /* This structure must be accessed using byte-alignment */
#pragma pack(1)
    X224_VARIABLE_INFO        *pX224VarInfo;
    /* return to normal alignment */
#pragma pack()

    while (CP_length > 0) {
        pX224VarInfo = (X224_VARIABLE_INFO *) CP_ptr;
        if ( 0xe0 == pX224VarInfo->InfoType) {
            LPVOID pdecoding_buf = NULL;
            UINT decoding_len = 0;
            LPBYTE pbEncoded_data = CP_ptr + sizeof(X224_VARIABLE_INFO);
            if ( g_CNPCoder->Decode (pbEncoded_data,
                                     pX224VarInfo->InfoSize,
                                     CNPPDU_PDU, PACKED_ENCODING_RULES,
                                     (LPVOID *) &pdecoding_buf, &decoding_len))
            {
#pragma pack(1)
                CNPPDU        *pCnp_pdu;
                /* return to normal alignment */
#pragma pack()
                pCnp_pdu = (CNPPDU *) pdecoding_buf;
                if (disconnectRequest_chosen == pCnp_pdu->choice)
                {
                    switch (pCnp_pdu->u.disconnectRequest.disconnectReason.choice)
                    {
                    case securityDenied_chosen:
                        *pNotify = TPRT_NOTIFY_REMOTE_REQUIRE_SECURITY;
                        break;
                    default:
                        *pNotify = TPRT_NOTIFY_OTHER_REASON;
                        break;
                    }
                }
            }
            g_CNPCoder->FreeDecoded(decoding_len, pdecoding_buf);
        }
        length = pX224VarInfo->InfoSize + sizeof(X224_VARIABLE_INFO);
        CP_ptr += length;
        CP_length -= length;
    }
}


/*
 *    void DisconnectRequest (TransportConnection    XprtConn)
 *
 *    Functional Description:
 *        This function closes the socket and deletes its connection node.
 */
void DisconnectRequest (TransportConnection    XprtConn,
                        ULONG            ulNotify)
{
    PSocket    pSocket;

    TRACE_OUT(("DisconnectRequest"));

    /* If the transport connection handle is not registered, return error */
    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn, TRUE)))
    {
        // LONCHANC: cannot do Remove in the above line because PurgeRequest() uses it again.
        ::PurgeRequest(XprtConn);

        // SendStatusMessage (pSocket -> Remote_Address, TSTATE_NOT_CONNECTED, IDS_NULL_STRING);
        if (IS_PLUGGABLE_PSTN(XprtConn))
        {
            CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
            if (NULL != p)
            {
                p->TDisconnectRequest();
            }
        }

        /* Free the structures and close the socket */
        TransportConnection XprtConn2 = XprtConn;
        if (IS_SOCKET(XprtConn2))
        {
            XprtConn2.nLogicalHandle = INVALID_SOCKET;
        }
        ::freeSocket(pSocket, XprtConn2);

        // Notify the user
        if (TPRT_NOTIFY_NONE != ulNotify)
        {
            TRACE_OUT (("TCP Callback: g_Transport->DisconnectIndication (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));

            /* We issue a callback to the user to notify him of the message */
            g_Transport->DisconnectIndication(XprtConn, ulNotify);
        }
    }
    else
    {
        WARNING_OUT(("DisconnectRequest: logical handle (%d, %d) not found",
                XprtConn.eType, XprtConn.nLogicalHandle));
    }

    ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTED);
}

typedef enum {
    RECVRET_CONTINUE = 0,
    RECVRET_NON_FATAL_ERROR,
    RECVRET_DISCONNECT,
    RECVRET_NO_PLUGGABLE_CONNECTION,
} RecvReturn;

/* RecvReturn        Call_recv (PSocket pSocket)
 *
 * Functional Description:
 *        This function calls recv once and checks for errors coming from the
 *        recv call.  It knows about the socket's state from the "pSocket" argument
 *        and uses this info to create the arguments for the recv call.
 *
 * Return value:
 *        Continue, if everything went ok and we have new data
 *        Non_Fatal_Error, if no real error has happenned, but we did not recv all data we asked for
 *        Disconnect, if a real error has occurred, or the other side has disconnected.
 */
RecvReturn Call_recv (PSocket pSocket)
{
    PUChar        buffer;
    int            length;
    int            bytes_received;
    BOOL        bAllocationOK;
    RecvReturn    rrCode = RECVRET_NON_FATAL_ERROR;
    PLUGXPRT_RESULT plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    TRACE_OUT(("Call_recv"));

    if (READ_HEADER != pSocket->Read_State)
    {
        ASSERT ((pSocket->X224_Length) > 0 && (pSocket->X224_Length <= 8192));

        // Compute how much data we have to read from this X.224 pkt.
        length = pSocket->X224_Length - sizeof(X224_DATA_PACKET);

        // Space allocation
        if (! pSocket->bSpaceAllocated)
        {
            // We need to allocate the space for the recv call.
            if (NULL == pSocket->Data_Indication_Buffer)
            {
                DBG_SAVE_FILE_LINE
                pSocket->Data_Memory = AllocateMemory (
                                NULL, pSocket->X224_Length,
                                ((READ_DATA == pSocket->Read_State) ?
                                RECV_PRIORITY : HIGHEST_PRIORITY));
                // Leave space for the X.224 header in the newly allocated data buffer
                pSocket->Data_Indication_Length = sizeof (X224_DATA_PACKET);
                bAllocationOK = (pSocket->Data_Memory != NULL);
            }
            else
            {
                // This is an MCS PDU broken up in many X.224 packets.
                ASSERT (READ_DATA == pSocket->Read_State);
                bAllocationOK = ReAllocateMemory (&(pSocket->Data_Memory), length);
            }

            // Check whether the allocations were successful.
            if (bAllocationOK)
            {
                pSocket->bSpaceAllocated = TRUE;
                pSocket->Data_Indication_Buffer = pSocket->Data_Memory->GetPointer();
                /*
                 *    If this is an X.224 CONNECT_REQUEST or CONNECT_CONFIRM packet,
                 *    we need to copy the first 7 bytes into the buffer for the whole
                 *    packet.
                 */
                if (READ_DATA != pSocket->Read_State)
                {
                    memcpy ((void *) pSocket->Data_Indication_Buffer,
                            (void *) &(pSocket->X224_Header),
                            sizeof(X224_DATA_PACKET));
                }
            }
            else
            {
                /*
                 *    We will retry the operation later.
                 */
                WARNING_OUT (("Call_recv: Buffer allocation failed."));
                g_pMCSController->HandleTransportWaitUpdateIndication(TRUE);
                goto ExitLabel;
            }
        }
        buffer = pSocket->Data_Indication_Buffer + pSocket->Data_Indication_Length;
    }
    else
    {
        buffer = (PUChar) &(pSocket->X224_Header);
        length = sizeof(X224_DATA_PACKET);
    }

    // Adjust "buffer" and "length" for data already read from the current X.224 pkt.
    buffer += pSocket->Current_Length;
    length -= pSocket->Current_Length;

    ASSERT (length > 0);

    if (IS_SOCKET(pSocket->XprtConn))
    {
        // Issue the recv call.
        bytes_received = recv (pSocket->XprtConn.nLogicalHandle, (char *) buffer, length, 0);
    }
    else
    {
        bytes_received = ::X224Recv(pSocket, buffer, length, &plug_rc);
    }

    if (bytes_received == length)
    {
        TRACE_OUT (("Call_recv: Received %d bytes on socket (%d, %d).", bytes_received,
                            pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        // We have received the whole X.224 packet.
        if (READ_HEADER != pSocket->Read_State)
        {
            pSocket->Data_Indication_Length += pSocket->X224_Length - sizeof(X224_DATA_PACKET);
        }
        // Reset the current length variable for the next Call_recv().
        pSocket->Current_Length = 0;
        rrCode = RECVRET_CONTINUE;
    }
    // Handle errors
    else
    if (bytes_received == SOCKET_ERROR)
    {
        if (IS_SOCKET(pSocket->XprtConn))
        {
            if(WSAGetLastError() == WSAEWOULDBLOCK)
            {
                TRACE_OUT(("Call_recv: recv blocked on socket (%d, %d).",
                        pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
            }
            else
            {
                 /* If the error is not WOULD BLOCK, we have a real error. */
                WARNING_OUT (("Call_recv: Error %d on recv. Socket: (%d, %d). Disconnecting...",
                            WSAGetLastError(), pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
                rrCode = RECVRET_DISCONNECT;
            }
        }
        else
        {
            if (PLUGXPRT_RESULT_SUCCESSFUL == plug_rc)
            {
                // do nothing, treat it as WSAEWOULDBLOCK
            }
            else
            {
                 /* If the error is not WOULD BLOCK, we have a real error. */
                WARNING_OUT (("Call_recv: Error %d on recv. Socket: (%d, %d). Disconnecting...",
                            WSAGetLastError(), pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
                rrCode = RECVRET_DISCONNECT;
            }
        }
    }
    else
    if (bytes_received > 0)
    {
        TRACE_OUT(("Call_recv: Received %d bytes out of %d bytes requested on socket (%d, %d).",
                    bytes_received, length, pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        // We received only part of what we wanted.  We retry later.
        pSocket->Current_Length += bytes_received;
    }
    else
    {
        WARNING_OUT(("Call_recv: Socket (%d, %d) has been gracefully closed.",
                    pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        rrCode = RECVRET_DISCONNECT;
    }

ExitLabel:
    return rrCode;
}


int X224Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("X224Recv"));

    if (IS_PLUGGABLE_X224(pSocket->XprtConn))
    {
        return ::SubmitPluggableRead(pSocket, buffer, length, plug_rc);
    }

    if (IS_PLUGGABLE_PSTN(pSocket->XprtConn))
    {
        return Q922Recv(pSocket, buffer, length, plug_rc);
    }

    ERROR_OUT(("X224Recv: invalid plugable type (%d, %d)",
                pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
    return SOCKET_ERROR;
}


int Q922Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    ERROR_OUT(("Q922Recv: NYI (%d, %d)",
                pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
    return SOCKET_ERROR;
}


typedef enum {
    FreeX224AndExit,
    ErrorExit,
    ImmediateExit
} ExitWay;


/*
 *    void    ReadRequest ( TransportConnection )
 *
 *    Functional Description:
 *        This function will attempt to read and process a full X.224 packet.
 *        However, it may only be able to read part of a packet or fail to
 *        process it at this time.  In this case, it must keep enough state
 *        info for the next entrance into this function, to be able to handle
 *        the partly-received or unprocessed X.224 packet.
 */
void ReadRequest (TransportConnection XprtConn)
{
    PSocket                pSocket;
    ExitWay                ew = ImmediateExit;
    RecvReturn            rrCode;
    ULONG               ulNotify = TPRT_NOTIFY_OTHER_REASON;

    TRACE_OUT(("ReadRequest"));

    if (IS_PLUGGABLE_PSTN(XprtConn))
    {
        ERROR_OUT(("ReadRequest: PSTN should not be here"));
        return;
    }

    /* If the transport connection handle is not registered, return */
    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        if (pSocket->State != WAITING_FOR_CONNECTION)
        {
            PSecurityContext     pSC = pSocket->pSC;
            /*
             *    If we haven't read the header of the incoming packet yet,
             *    we need to read it into the header space
             */
            if (READ_HEADER == pSocket->Read_State)
            {
                rrCode = Call_recv (pSocket);
                if (RECVRET_CONTINUE == rrCode)
                {
                    // We need to allocate the space for the rest of the X.224 packet.
                    pSocket->bSpaceAllocated = FALSE;

                    // Find the length of the X.224 packet.
                    pSocket->X224_Length = (pSocket->X224_Header.rfc.msbPacketSize << 8) +
                                            pSocket->X224_Header.rfc.lsbPacketSize;
                    /*
                     *    We have the whole X.224 header. Compute the next state,
                     *    based on the packet type.
                     */
                    switch (pSocket->X224_Header.PacketType)
                    {
                    case DATA_PACKET:
                        pSocket->Read_State = READ_DATA;
                        break;

                    case CONNECTION_CONFIRM_PACKET:
                        if (pSocket->State != X224_CONNECTED)
                        {
                            pSocket->Read_State = CONNECTION_CONFIRM;
                        }
                        else
                        {
                            ERROR_OUT (("ReadRequest: Received X.224 CONNECTION_CONFIRM packet while already connected!! Socket: (%d, %d).",
                                        XprtConn.eType, XprtConn.nLogicalHandle));
                            ew = ErrorExit;
                        }
                        break;

                    case CONNECTION_REQUEST_PACKET:
                        // we just received a X224 Connect request
                        pSocket->Read_State = CONNECTION_REQUEST;
                        ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTING);
                        break;

                    case DISCONNECT_REQUEST_PACKET:
                        // we just received a X224 Disconnect request
                        pSocket->Read_State = DISCONNECT_REQUEST;
                        ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTING);
                        break;

                    default:
                        // We have lost sync with the remote side.
                        ERROR_OUT (("ReadRequest: Bad X.224 packet on socket (%d, %d). Disconnecting...", XprtConn.eType, XprtConn.nLogicalHandle));
                        ew = ErrorExit;
                        break;
                    }
                }
                else
                if (RECVRET_DISCONNECT == rrCode)
                {
                    ew = ErrorExit;
                }
            }

            if ((READ_DATA <= pSocket->Read_State) &&
                (CONNECTION_REQUEST >= pSocket->Read_State))
            {
                rrCode = Call_recv (pSocket);
                if (RECVRET_CONTINUE == rrCode)
                {
                    // We now have the whole X.224 packet.

                    switch (pSocket->Read_State)
                    {
                    case READ_DATA:
                        // Check whether this is the final X.224 packet
                        if (pSocket->X224_Header.FinalPacket & EOT_BIT)
                        {
                            // If we're waiting for a security data packet we will process
                            // this internally without passing it up to the transport
                            // client.
                            if (NULL != pSC)
                            {
                                if (pSC->WaitingForPacket())
                                {
                                    TransportSecurityError SecErr;

                                    SecErr = pSC->AdvanceState((PBYTE) pSocket->Data_Indication_Buffer +
                                                            sizeof(X224_DATA_PACKET),
                                                        pSocket->Data_Indication_Length -
                                                            sizeof(X224_DATA_PACKET));

                                    if (TPRTSEC_NOERROR != SecErr)
                                    {
                                        // Something has gone wrong. Need to disconnect
                                        delete pSC;
                                        pSocket->pSC = NULL;
                                        ulNotify = TPRT_NOTIFY_AUTHENTICATION_FAILED;
                                        ew = ErrorExit;
                                        break;
                                    }

                                    if (pSC->ContinueNeeded())
                                    {
                                        // We need to send out another token
                                        // bugbug: what should we do if this fails?
                                        ContinueAuthentication(pSocket);
                                    }

                                    if (pSC->StateComplete())
                                    {
                                        // We're connected... inform the client
                                        TRACE_OUT(("deferred g_Transport->ConnectConfirm"));
                                        g_Transport->ConnectConfirm(XprtConn);
                                    }
                                    ew = FreeX224AndExit;
                                    break;
                                }

                                // We must decrypt the data (in place)
                                TRACE_OUT(("Decrypting received data"));

                                if (! pSC->Decrypt(pSocket->Data_Indication_Buffer +
                                                        sizeof(X224_DATA_PACKET),
                                                    pSocket->Data_Indication_Length -
                                                        sizeof(X224_DATA_PACKET)))
                                {
                                    TRACE_OUT(("Sending %d bytes to application",
                                                pSocket->Data_Indication_Length - sizeof(X224_DATA_PACKET)));
                                }
                                else
                                {
                                    ERROR_OUT(("Error decrypting packet"));
                                    ew = ErrorExit;
                                    break;
                                }
                            }
                            pSocket->Read_State = DATA_READY;
                        }
                        else
                        {
                            // This and the next X.224 packets are part of a bigger MCS data PDU.
                            ASSERT (NULL == pSC);
                            pSocket->Read_State = READ_HEADER;
                        }
                        break;

                    case CONNECTION_CONFIRM:
                        {
                            TRACE_OUT(("ReadRequest: X224 CONNECTION_CONFIRM_PACKET received"));
                                BOOL    bCallback = ((NULL == pSC) || (! pSC->ContinueNeeded()));

                            // Process the CC packet.
                            if (FALSE == ProcessX224ConnectPDU (pSocket,
                                                pSocket->Data_Indication_Buffer + sizeof(X224_CONNECT),
                                                pSocket->X224_Length - sizeof (X224_CONNECT), &ulNotify))
                            {
                                ew = ErrorExit;
                                break;
                            }

                            // Issue the callback if the CC was not on a secure connection
                            // Otherwise, we don't notify the transport client yet... still need to
                            // exchange security information. TRANSPORT_CONNECT_CONFIRM will
                            // be sent when the final security data token is received and
                            // processed.
                            if (bCallback)
                            {
                                TRACE_OUT (("TCP Callback: g_Transport->ConnectConfirm (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                                /* We issue a callback to the user to notify him of the message */
                                g_Transport->ConnectConfirm(XprtConn);
                            }
                            pSocket->State = X224_CONNECTED;
                            ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                            ew = FreeX224AndExit;
                        }
                        break;

                    case CONNECTION_REQUEST:
                        {
                                UINT             remote;
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
                                X224_CONNECT        *pConnectRequest;
/* return to normal alignment */
#pragma pack()
                            /* Grab the remote connection ID */
                            TRACE_OUT (("ReadRequest: X224 CONNECTION_REQUEST_PACKET received"));
                            pConnectRequest = (X224_CONNECT *) pSocket->Data_Indication_Buffer;
                            remote = ((unsigned int) pConnectRequest->conn.msbSrc) << 8;
                            remote |= pConnectRequest->conn.lsbSrc;

                            if (FALSE == ProcessX224ConnectPDU (pSocket, (PUChar) (pConnectRequest + 1),
                                                pSocket->X224_Length - sizeof (X224_CONNECT), &ulNotify))
                            {
                                ew = ErrorExit;
                                break;
                            }

                            if (::SendX224ConnectConfirm(pSocket, remote))
                            {
                                // success
                                if (IS_PLUGGABLE(pSocket->XprtConn))
                                {
                                    pSocket->State = SOCKET_CONNECTED;
                                    g_Transport->ConnectIndication(XprtConn);
                                    ASSERT(X224_CONNECTED == pSocket->State);
                                }
                                ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                                ew = FreeX224AndExit;
                            }
                            else
                            {
                                if (pSocket->fExtendedX224)
                                {
                                    ::SendX224DisconnectRequest(pSocket, remote, securityDenied_chosen);
                                }
                                ew = ErrorExit;
                            }
                        }
                        break;

                    case DISCONNECT_REQUEST:
                        {
                            UINT               remote;
                            X224_DR_FIXED      *pX224_DR_fixed;

                            TRACE_OUT(("ReadRequest: X224 DISCONNECT_REQUEST_PACKET received"));
                            pX224_DR_fixed = (X224_DR_FIXED *) pSocket->Data_Indication_Buffer;
                            remote = ((unsigned int) pX224_DR_fixed->disconn.msbSrc) << 8;
                            remote |= pX224_DR_fixed->disconn.lsbSrc;

                            ProcessX224DisconnectPDU(pSocket, pSocket->Data_Indication_Buffer + sizeof(X224_DR_FIXED),
                                                     pSocket->X224_Length - sizeof(X224_DR_FIXED), &ulNotify);
                            ew = ErrorExit;
                        }
                        break;
                    }
                }
                else if (RECVRET_DISCONNECT == rrCode)
                {
                    ew = ErrorExit;
                }
            }

            if (DATA_READY == pSocket->Read_State)
            {
                TransportData        transport_data;

                // Fill in the callback structure.
                transport_data.transport_connection = XprtConn;
                transport_data.user_data = pSocket->Data_Indication_Buffer;
                transport_data.user_data_length = pSocket->Data_Indication_Length;
                transport_data.memory = pSocket->Data_Memory;

                /*
                 *    If there is an incoming security context associated with this
                 *  socket, we must adjust pointer by header and overall size by header and
                 *    trailer.
                 */
                if (NULL != pSC)
                {
                    transport_data.user_data += pSC->GetStreamHeaderSize();
                    transport_data.user_data_length -= (pSC->GetStreamHeaderSize() +
                                                        pSC->GetStreamTrailerSize());
                }

                if (TRANSPORT_NO_ERROR == g_Transport->DataIndication(&transport_data))
                {
                    TRACE_OUT (("ReadRequest: %d bytes were accepted from socket (%d, %d)",
                                transport_data.user_data_length, XprtConn.eType, XprtConn.nLogicalHandle));
                    // Prepare for the next X.224 packet
                    pSocket->Read_State = READ_HEADER;
                    pSocket->Data_Indication_Buffer = NULL;
                    pSocket->Data_Memory = NULL;
                }
                else
                {
                    WARNING_OUT(("ReadRequest: Error on g_Transport->DataIndication from socket (%d, %d)",
                                XprtConn.eType, XprtConn.nLogicalHandle));
                }
            }
        }
        else
        {
            WARNING_OUT (("ReadRequest: socket (%d, %d) is in WAITING_FOR_CONNECTION state.", XprtConn.eType, XprtConn.nLogicalHandle));
        }
    }
    else
    {
        WARNING_OUT (("ReadRequest: socket (%d, %d) can not be found.", XprtConn.eType, XprtConn.nLogicalHandle));
    }

    switch (ew)
    {
    case FreeX224AndExit:
        if (NULL != pSocket)
        {
            // Free the buffers we have allocated.
            pSocket->FreeTransportBuffer();
            // Prepare for the next X.224 packet
            pSocket->Read_State = READ_HEADER;
        }
        break;

    case ErrorExit:
        // We get here only if we need to disconnect the socket (because of an error)
        ASSERT(TPRT_NOTIFY_NONE != ulNotify);
        ::DisconnectRequest(XprtConn, ulNotify);
        break;
    }

    if (NULL != pSocket)
    {
        pSocket->Release(); // offset the previous AddRef.
    }
}


/*
 *    TransportError    FlushSendBuffer ( PSocket pSocket )
 *
 *    Functional Description:
 *        This function sends any pending data through the transport.
 */
TransportError    FlushSendBuffer(PSocket pSocket, LPBYTE buffer, UINT length)
{
    int     bytes_sent = SOCKET_ERROR;
    PLUGXPRT_RESULT plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    TRACE_OUT(("FlushSendBuffer"));

    /* send the data */
    if (IS_SOCKET(pSocket->XprtConn))
    {
        bytes_sent = ::send(pSocket->XprtConn.nLogicalHandle, (PChar) buffer,
                            (int) length, 0);
    }
    else
    if (IS_PLUGGABLE_X224(pSocket->XprtConn))
    {
        bytes_sent = ::SubmitPluggableWrite(pSocket, buffer, length, &plug_rc);
    }
    else
    if (IS_PLUGGABLE_PSTN(pSocket->XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(pSocket);
        if (NULL != p)
        {
            bytes_sent = p->TDataRequest(buffer, length, &plug_rc);
        }
        else
        {
            plug_rc = PLUGXPRT_RESULT_WRITE_FAILED;
        }
    }

    if (bytes_sent == SOCKET_ERROR)
    {
        if (IS_SOCKET(pSocket->XprtConn))
        {
            /* If the error is not WOULD BLOCK, it is a real error! */
            if (::WSAGetLastError() != WSAEWOULDBLOCK)
            {
                WARNING_OUT (("FlushSendBuffer: Error %d on write", ::WSAGetLastError()));

                 /* Notify the owner of the broken connection */
                WARNING_OUT (("FlushSendBuffer: Sending up DISCONNECT_INDICATION"));
                // SendStatusMessage (pSocket -> Remote_Address,  TSTATE_REMOVED, IDS_NULL_STRING);
                ::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
                return (TRANSPORT_WRITE_QUEUE_FULL);
            }
        }
        else
        {
            // do nothing if it is WSAEWOULDBLOCK
            if (PLUGXPRT_RESULT_SUCCESSFUL != plug_rc)
            {
                 /* Notify the owner of the broken connection */
                WARNING_OUT (("FlushSendBuffer: Sending up DISCONNECT_INDICATION"));
                // SendStatusMessage (pSocket -> Remote_Address,  TSTATE_REMOVED, IDS_NULL_STRING);
                ::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
                return (TRANSPORT_WRITE_QUEUE_FULL);
            }
        }

        bytes_sent = 0;
    }

     /* If the transport layer did not accept the data, its write buffers are full */
    if (bytes_sent != (int) length)
    {
        ASSERT (bytes_sent == 0);
        TRACE_OUT(("FlushSendBuffer: returning TRANSPORT_WRITE_QUEUE_FULL"));
        return (TRANSPORT_WRITE_QUEUE_FULL);
    }

    TRACE_OUT (("FlushSendBuffer: %d bytes sent on Socket (%d, %d).",
                length, pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));

    return (TRANSPORT_NO_ERROR);
}



/*
 *    SegmentX224Data
 *
 *    This function segments outgoing data into X.224 packets of the appropriate size.
 *    It should not be called in a NM to NM call or in a call when we have negotiated an
 *    X.224 max PDU size of at least the size of a max MCS PDU.  NM attempts to negotiate
 *    X.224 sizes of 8K, but will accept anything the other side proposes.
 *    This function does memcpy's so it will slow us down sending data.
 *
 *    The 2 buffers specified by "ptr1" and "ptr2" and their lengths are used to create
 *    one stream of X.224 bytes.  The function will return TRANSPORT_WRITE_QUEUE_FULL if
 *    it fails to allocate the necessary amount of memory.
 */
TransportError SegmentX224Data (PSocket pSocket,
                                LPBYTE *pPtr1,     UINT *pLength1,
                                LPBYTE Ptr2,     UINT Length2)
{
    TransportError        TransError;
    UINT                length;
    LPBYTE                ptr1 = *pPtr1 + sizeof (X224_DATA_PACKET);
    UINT                length1 = *pLength1 - sizeof (X224_DATA_PACKET);
    LPBYTE                ptr;
    UINT                max_pdu_length = pSocket->Max_Packet_Length;
    X224_DATA_PACKET    l_X224Header = {3, 0, (UChar) (max_pdu_length >> 8), (UChar) (max_pdu_length & 0xFF),
                                        2, DATA_PACKET, 0};
    UINT                last_length;
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
    X224_DATA_PACKET    *pX224Data;
/* return to normal alignment */
#pragma pack()


    ASSERT(! IS_PLUGGABLE_PSTN(pSocket->XprtConn));

    // Calculate how much space we need.
    length = *pLength1 + Length2;
    ASSERT (pSocket->Max_Packet_Length < length);
    ASSERT (pSocket->Max_Packet_Length > sizeof(X224_DATA_PACKET));

    max_pdu_length -= sizeof (X224_DATA_PACKET);
    /*
     *    Calculate the space we need to allocate.  Notice that the data already
     *    contains one X.224 header.
     */
    length += (length / max_pdu_length) * sizeof (X224_DATA_PACKET);
    *pPtr1 = Allocate (length);

    if (*pPtr1 != NULL) {
        TransError = TRANSPORT_NO_ERROR;
        ptr = *pPtr1;

        // Go through the 1st buffer.
        while (length1 > 0) {
            // Copy the X.224 header.
            memcpy (ptr, &l_X224Header, sizeof(X224_DATA_PACKET));
            pX224Data = (X224_DATA_PACKET *) ptr;
            ptr += sizeof (X224_DATA_PACKET);

            // Copy data
            length = ((max_pdu_length > length1) ? length1 : max_pdu_length);
            memcpy (ptr, ptr1, length);
            last_length = length;

            // Advance pointers
            ptr1 += length;
            ptr += length;
            length1 -= length;
        }

        // If there is space in the current X.224 PDU, we need to use it.
        length = max_pdu_length - length;
        if (length > 0 && Length2 > 0) {
            if (length > Length2)
                length = Length2;
            memcpy (ptr, Ptr2, length);
            last_length += length;
            Ptr2 += length;
            ptr += length;
            Length2 -= length;
        }

        // Go through the 2nd buffer.
        while (Length2 > 0) {
            // Copy the X.224 header.
            memcpy (ptr, &l_X224Header, sizeof(X224_DATA_PACKET));
            pX224Data = (X224_DATA_PACKET *) ptr;
            ptr += sizeof (X224_DATA_PACKET);

            // Copy data
            length = ((max_pdu_length > Length2) ? Length2 : max_pdu_length);
            memcpy (ptr, Ptr2, length);
            last_length = length;

            // Advance pointers
            Ptr2 += length;
            ptr += length;
            Length2 -= length;
        }

        // Prepare for return
        *pLength1 = (UINT)(ptr - *pPtr1);

        // Set the last X.224 header
        last_length += sizeof(X224_DATA_PACKET);
        pX224Data->FinalPacket = EOT_BIT;
        pX224Data->rfc.msbPacketSize = (UChar) (last_length >> 8);
        pX224Data->rfc.lsbPacketSize = (UChar) (last_length & 0xFF);
    }
    else {
        ERROR_OUT (("SegmentX224Data: Failed to allocate memory of length %d.", length));
        TransError = TRANSPORT_WRITE_QUEUE_FULL;
    }

    return TransError;
}

/*
 *    SendSecureData
 *
 *    This function segments secure data into X.224 packets, if needed, and flushes them through
 *    the transport.  "pBuf" and "cbBuf" provide the encrypted data buffer and length.
 */
TransportError SendSecureData (PSocket pSocket, LPBYTE pBuf, UINT cbBuf)
{
    TransportError        TransError;
    LPBYTE                pBuf_Copy = pBuf;
    UINT                cbBuf_Copy = cbBuf;

    // Do we need to segment the data into X.224 packets?
    if (pSocket->Max_Packet_Length >= cbBuf) {
        TransError = TRANSPORT_NO_ERROR;
    }
    else {
        TransError = SegmentX224Data (pSocket, &pBuf, &cbBuf, NULL, 0);
    }

    // Flush the data, if everything OK so far.
    if (TRANSPORT_NO_ERROR == TransError)
        TransError = FlushSendBuffer (pSocket, pBuf, cbBuf);

    // If we segmented the data, we need to free the segmented buffer.
    if (pBuf != pBuf_Copy)
        Free(pBuf);

    // If there are errors, we need to store the decrypted data for the next time, so don't free it.
    if (TRANSPORT_NO_ERROR == TransError) {
        LocalFree(pBuf_Copy);
    }

    return TransError;
}

/*
 *    TransportError    DataRequest (    TransportConnection    XprtConn,
 *                                    PSimplePacket    packet)
 *
 *    Functional Description:
 *        This function is used to send a data packet to the remote site.
 *        If the user_data_length is zero, and we have no pending data,
 *        it sends a keep-alive (zero-length) packet.
 */
TransportError    DataRequest (TransportConnection    XprtConn,
                            PSimplePacket    packet)
{
    PSocket            pSocket;
    LPBYTE            ptr1, ptr2;
    UINT            length1, length2;
    TransportError    TransError = TRANSPORT_NO_ERROR;

    TRACE_OUT(("DataRequest: packet=0x%x", packet));

    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        // First, we need to handle the retry operations.
        if (NULL != pSocket->pSC) {
                LPBYTE lpBuf;
            /*
             *    Check to see whether we have already encrypted, but not sent
             *    the last piece of data.
             */
            lpBuf = pSocket->Retry_Info.sbiBufferInfo.lpBuffer;
            if (NULL != lpBuf) {
                TransError = SendSecureData (pSocket, lpBuf,
                                            pSocket->Retry_Info.sbiBufferInfo.uiLength);

                if (TransError == TRANSPORT_NO_ERROR) {
                    TRACE_OUT(("DataRequest: Sent previously-encrypted piece of data."));
                    pSocket->Retry_Info.sbiBufferInfo.lpBuffer = NULL;
                }
            }
        }
        else {
                PDataPacket        pdpPacket = pSocket->Retry_Info.pUnfinishedPacket;

            // Check to see whether we have half-sent the last packet.
            if (NULL  != pdpPacket) {
                /*
                 *    We need to send the rest of the unfinished packet,
                 *    before we can go on.  The 1st part of the packet
                 *    must have already been sent.
                 */
                // The packet's encoded data must be in 2 buffers.
                ASSERT (TRUE == pdpPacket->IsEncodedDataBroken());

                TransError = FlushSendBuffer (pSocket, pdpPacket->GetUserData(),
                                            pdpPacket->GetUserDataLength());
                if (TransError == TRANSPORT_NO_ERROR) {
                    pdpPacket->Unlock();
                    TRACE_OUT(("DataRequest: 2nd part of data packet was sent out in separate request"));
                    pSocket->Retry_Info.pUnfinishedPacket = NULL;
                }
            }
        }

        if ((TransError == TRANSPORT_NO_ERROR) && (packet != NULL)) {

            // Now, let's try to send this new packet.
            ptr1 = packet->GetEncodedData();
            length1 = packet->GetEncodedDataLength();

            /*
             *    We need to find out whether the packet to send is a
             *    DataPacket or a Packet object.  If it's a DataPacket, the
             *    encoded data may not be contiguous (may be broken in 2 parts)
             */
            if ((packet->IsDataPacket()) &&
                ((PDataPacket) packet)->IsEncodedDataBroken()) {
                // the data to send is broken into 2 parts.
                ptr2 = ((PDataPacket) packet)->GetUserData();
                length2 = ((PDataPacket) packet)->GetUserDataLength();
            }
            else {
                // the data to send is contiguous.
                ptr2 = NULL;
                length2 = 0;
            }

            if (NULL != pSocket->pSC) {
                    LPBYTE     pBuf;
                    UINT     cbBuf;

                TRACE_OUT(("Encrypting %d bytes of outgoing data",
                            (length1 + length2) - sizeof(X224_DATA_PACKET)));

                if (!pSocket->pSC->Encrypt(ptr1 + sizeof(X224_DATA_PACKET),
                                            length1 - sizeof(X224_DATA_PACKET),
                                            ptr2, length2, &pBuf, &cbBuf))
                {

                    ASSERT (TransError == TRANSPORT_NO_ERROR);

                    TransError = SendSecureData (pSocket, pBuf, cbBuf);
                    if (TRANSPORT_NO_ERROR != TransError) {
                        TRACE_OUT(("DataRequest: Failed to send encrypted data. Keeping buffer for retry."));
                        pSocket->Retry_Info.sbiBufferInfo.lpBuffer = pBuf;
                        pSocket->Retry_Info.sbiBufferInfo.uiLength = cbBuf;
                        // The caller needs to remove the packet from its queue.
                        TransError = TRANSPORT_NO_ERROR;
                    }
                }
                else
                {
                    WARNING_OUT (("DataRequest: Encryption failed. Disconnecting..."));
                    ::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
                    TransError = TRANSPORT_MEMORY_FAILURE;
                }
            }
            else {
                BOOL        bNeedToFree = FALSE;
                // Do we need to segment the data into X.224 packets?
                if (pSocket->Max_Packet_Length >= length1 + length2)
                    ;
                else {
                    TransError = SegmentX224Data (pSocket, &ptr1, &length1, ptr2, length2);
                    if (TRANSPORT_NO_ERROR == TransError) {
                        // The data is now contiguous
                        ptr2 = NULL;
                        bNeedToFree = TRUE;
                    }
                }

                // Flush the data, if everything OK so far.
                if (TRANSPORT_NO_ERROR == TransError)
                    TransError = FlushSendBuffer (pSocket, ptr1, length1);

                // Free the temporary X.224 buffer if we need to.
                if (bNeedToFree)
                    Free(ptr1);

                if (TRANSPORT_NO_ERROR == TransError) {
                    // If there is more, send it, too.
                    if (NULL != ptr2) {
                        TransError = FlushSendBuffer (pSocket, ptr2, length2);
                        if (TRANSPORT_NO_ERROR != TransError) {
                            /*
                             *    We need to keep the partial packet to send it later.
                             *    Notice we have already sent a part of this packet.
                             */
                            ASSERT (pSocket->Retry_Info.pUnfinishedPacket == NULL);
                            pSocket->Retry_Info.pUnfinishedPacket = (PDataPacket) packet;
                            packet->Lock();

                            // Return success.
                            TransError = TRANSPORT_NO_ERROR;
                        }
                    }
                }
            }
        }

        pSocket->Release();
    }
    else {
        TransError = TRANSPORT_NO_SUCH_CONNECTION;
        WARNING_OUT (("DataRequest: Attempt to send to unknown transport connection (%d, %d)",
                    XprtConn.eType, XprtConn.nLogicalHandle));
    }

    return TransError;
}


/*
 *    void PurgeRequest (TransportConnection    XprtConn)
 *
 *    Functional Description:
 *        This function purges the outbound packets for the given transport
 *        connection.
 */
void PurgeRequest (TransportConnection XprtConn)
{

    PSocket pSocket;

    TRACE_OUT (("In PurgeRequest for transport connection (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));

    if (IS_PLUGGABLE_PSTN(XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
        if (NULL != p)
        {
            p->TPurgeRequest();
        }
    }
    else
    /* If the logical connection handle is not registered, return error */
    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        /* Purge the pending data stored in the socket struct */
        if (NULL != pSocket->pSC) {
            if (NULL != pSocket->Retry_Info.sbiBufferInfo.lpBuffer) {
                TRACE_OUT (("PurgeRequest: Purging data packet for secure connection"));
                LocalFree (pSocket->Retry_Info.sbiBufferInfo.lpBuffer);
                pSocket->Retry_Info.sbiBufferInfo.lpBuffer = NULL;
            }
        }
        pSocket->Release();
    }
}


/*
 *    void    EnableReceiver (Void)
 *
 *    Functional Description:
 *        This function allows packets to be sent to the user application.
 */
void EnableReceiver (void)
{
    PSocket            pSocket;

    ::EnterCriticalSection(&g_csTransport);
    CSocketList     Connection_List_Copy (*g_pSocketList);
    ::LeaveCriticalSection(&g_csTransport);

    TRACE_OUT(("EnableReceiver"));

    if (NULL != g_pLegacyTransport)
    {
        g_pLegacyTransport->TEnableReceiver();
    }

    /* Go thru all the sockets and enable receiving */
    while (NULL != (pSocket = Connection_List_Copy.Get()))
    {
        /*
         *    If we had failed to deliver a data pkt to MCS before, we need
         *    an extra ReadRequest to recv and keep the FD_READ msgs coming.
         */
        if (DATA_READY == pSocket->Read_State)
        {
            ::ReadRequest(pSocket->XprtConn);
        }

        TRACE_OUT (("EnableReceiver: Calling ReadRequestEx on socket (%d, %d)",
                    pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        ::ReadRequestEx(pSocket->XprtConn);
    }
}


/*
 *    TransportError    ShutdownAndClose (TransportConnection , BOOL fShutdown, int how)
 *
 *    Functional Description
 *        This function shuts down the socket and closes it.
 *
 */
void ShutdownAndClose (TransportConnection XprtConn, BOOL fShutdown, int how)
{
    if (IS_SOCKET(XprtConn))
    {
        int error;

        if (fShutdown)
        {
            error = ::shutdown(XprtConn.nLogicalHandle, how);

            ASSERT(error != SOCKET_ERROR);
#ifdef DEBUG
            if(error == SOCKET_ERROR)
            {
                error = WSAGetLastError();
                WARNING_OUT (("ShutdownAndClose: shutdown returned %d", error));
            }
#endif // DEBUG
        }

        error = ::closesocket(XprtConn.nLogicalHandle);

#ifdef DEBUG
        if(error == SOCKET_ERROR)
        {
            WARNING_OUT(("ShutdownAndClose: closesocket returned %d", WSAGetLastError()));
        }
#endif // DEBUG
    }
}


/*
 *    TransportError GetLocalAddress (TransportConnection    XprtConn,
 *                                    TransportAddress    address,
 *                                    int *        size)
 *
 *    Functional Description:
 *        This function retrieves the local IP address associated with the given
 *        connection. It returns TRANSPORT_NO_SUCH_CONNECTION if the address is
 *        not available. If the address is available, the size parameter specifies
 *        the size of the address buffer on entry, and it is filled in with the size
 *        used for the address on exit.
 */
TransportError GetLocalAddress(    TransportConnection    XprtConn,
                                TransportAddress    address,
                                int *                size)
{
    SOCKADDR_IN        socket_control;
    PChar             szTemp;
    int                Length;
    TransportError    error = TRANSPORT_NO_SUCH_CONNECTION;

    if (NULL != g_pSocketList->FindByTransportConnection(XprtConn, TRUE))
    {
        if (IS_SOCKET(XprtConn))
        {
            /* Get the local name for the socket */
            Length = sizeof(socket_control);
            if (getsockname(XprtConn.nLogicalHandle, (LPSOCKADDR) &socket_control, &Length) == 0) {
                /* Convert it to an IP address string */
                szTemp = inet_ntoa(socket_control.sin_addr);

                ASSERT (szTemp);
                Length = (int) strlen(szTemp) + 1;

                ASSERT (*size >= Length);
                ASSERT (address);

                /* Copy it to the buffer */
                lstrcpyn((PChar)address, szTemp, Length);
                *size = Length;

                error = TRANSPORT_NO_ERROR;
            }
        }
        else
        {
            ASSERT(IS_PLUGGABLE(XprtConn));

            // string should look like "xprt: 1"
            char szConnStr[T120_CONNECTION_ID_LENGTH];
            Length = ::CreateConnString((UINT)XprtConn.nLogicalHandle, szConnStr);
            if (*size > ++Length)
            {
                ::lstrcpyn(address, szConnStr, Length+1);
                *size = Length;
                error = TRANSPORT_NO_ERROR;
                TRACE_OUT (("GetLocalAddress: plugable connection local address (%s)", address));
            }
            else
            {
                ERROR_OUT(("GetLocalAddress: buffer too small, given=%d, required=%d", *size, Length));
                error = TRANSPORT_BUFFER_TOO_SMALL;
            }
        }
    }

#ifdef DEBUG
    if (error != TRANSPORT_NO_ERROR)
        WARNING_OUT (("GetLocalAddress: Failure to obtain local address (%d)", WSAGetLastError()));
#endif // DEBUG

    return (error);
}


/*
 *    void    AcceptCall (BOOL fSecure)
 *
 *    Functional Description:
 *        This function calls Winsock to answer an incoming call.
 */

void AcceptCall (TransportConnection XprtConn)
{
    PSocket            pSocket;
    PSecurityContext pSC = NULL;
    SOCKADDR_IN        socket_control;
    int                size;

    TRACE_OUT(("AcceptCall"));

    if (IS_SOCKET(XprtConn))
    {
        ASSERT(XprtConn.nLogicalHandle == Listen_Socket);
        ASSERT (Listen_Socket != INVALID_SOCKET);

        /* Call accept() to see if anyone is calling us */
        size = sizeof (socket_control);
        XprtConn.nLogicalHandle = ::accept ( Listen_Socket,
                                (struct sockaddr *) &socket_control, &size);

        /* Note that we expect accept to complete immediately */
        if (XprtConn.nLogicalHandle == INVALID_SOCKET)
        {
            ERROR_OUT (("AcceptCall: Error on accept = %d", WSAGetLastError()));
            // SendStatusMessage ("", TSTATE_NOT_READY, IDS_NULL_STRING);
            return;
        }
    }

    /* If the accept() received an incoming call, create a connection and notify our owner object. */
    pSocket = newSocket(XprtConn, NULL);
    if( pSocket == NULL )
    {
         /* Close the socket */
         ::ShutdownAndClose(XprtConn, TRUE, 2);
        return;
    }

    pSocket -> State = SOCKET_CONNECTED;

    if (IS_SOCKET(XprtConn))
    {
        /* Issue the getpeername() function to get the remote user's address */
        size = sizeof (socket_control);
        if (::getpeername(XprtConn.nLogicalHandle, (LPSOCKADDR) &socket_control, &size) == 0)
        {
            lstrcpyn (
                pSocket -> Remote_Address,
                inet_ntoa (socket_control.sin_addr),
                MAXIMUM_IP_ADDRESS_SIZE-1);
            pSocket -> Remote_Address[MAXIMUM_IP_ADDRESS_SIZE - 1] = NULL;
        }

        // SendStatusMessage(pSocket -> Remote_Address, TSTATE_CONNECTED, IDS_NULL_STRING);
    }

    /* Add to connection list */
    // bugbug: we fail to insert.
    g_pSocketList->SafeAppend(pSocket);

    /* Notify the user */
    TRACE_OUT (("TCP Callback: g_Transport->ConnectIndication (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
    /* We issue a callback to the user to notify him of the message */
    g_Transport->ConnectIndication(XprtConn);
}


//
// ReadRequestEx() is for the plugable transport.
// Since we do not have the FD_ACCEPT notifcation, we try to make sure
// we have a valid transport connection for every read...
// The following piece of code is derived from AcceptCall().
//
void ReadRequestEx(TransportConnection XprtConn)
{
    if (! IS_PLUGGABLE_PSTN(XprtConn))
    {
        ::ReadRequest(XprtConn);
    }
}

/*
 *    LRESULT    WindowProcedure (
 *                            HWND         window_handle,
 *                            UINT        message,
 *                            WPARAM         wParam,
 *                            LPARAM        lParam)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by Windows when we dispatch a TCP message from the
 *        event loop above.  It gives us a chance to process the incoming socket messages.
 */
LRESULT    WindowProcedure (HWND         window_handle,
                         UINT        message,
                         WPARAM        wParam,
                         LPARAM        lParam)
{
    TransportConnection XprtConn;
    UShort        error;
    UShort        event;
    //PSocket        pSocket;

    switch (message)
    {
#ifndef NO_TCP_TIMER
    case WM_TIMER:
        {
             /*
             **    We are currently using a slow timer to keep reading even when
             ** FD_READ msgs get lost (this happens on Win95).
             **
             */
            if (NULL != g_Transport) {
                TRACE_OUT(("MSMCSTCP: WM_TIMER"));
                EnableReceiver ();
            }
        }
        break;
#endif    /* NO_TCP_TIMER */

    case WM_SOCKET_NOTIFICATION:
        {
            /* This message is generated by WinSock */
            event = WSAGETSELECTEVENT (lParam);
            error = WSAGETSELECTERROR (lParam);

            SET_SOCKET_CONNECTION(XprtConn, wParam);

            /* We disconnect whenever a socket command generates an error message */
            if (error)
            {
                WARNING_OUT (("TCP: error %d on socket (%d). Event: %d", error, XprtConn.nLogicalHandle, event));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                break;
            }

            /* We get FD_CLOSE when the socket is closed by the remote site. */
            if (event & FD_CLOSE)
            {
                TRACE_OUT (("TCP: FD_CLOSE(%d)", XprtConn.nLogicalHandle));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                break;
            }

            /* We get FD_READ when there is data available for us to read. */
            if (event & FD_READ)
            {
                // TRACE_OUT(("MSMCSTCP: FD_READ(%d)", (UINT) wParam));
                ::ReadRequest(XprtConn);
            }

            /* We get FD_ACCEPT when a remote site is connecting with us */
            if (event & FD_ACCEPT)
            {
                TRACE_OUT (("TCP: FD_ACCEPT(%d)", XprtConn.nLogicalHandle));

                /* Note that we always accept calls. Disconnect cancels them. */
                TransportConnection XprtConn2;
                SET_SOCKET_CONNECTION(XprtConn2, Listen_Socket);
                ::AcceptCall(XprtConn2);
            }

            /* We get FD_CONNECT when our connect completes */
            if (event & FD_CONNECT)
            {
                TRACE_OUT (("TCP: FD_CONNECT(%d)", XprtConn.nLogicalHandle));
                ::SendX224ConnectRequest(XprtConn);
            }

            /* We get FD_WRITE when there is space available to write data to WinSock */
            if (event & FD_WRITE)
            {
                /*
                 *    We need to send a BUFFER_EMPTY_INDICATION to the connection associated
                 *    with the socket
                 */
                TRACE_OUT (("TCP: FD_WRITE(%d)", XprtConn.nLogicalHandle));
                // We need to flush the socket's pending data first.
                if (TRANSPORT_NO_ERROR == ::DataRequest(XprtConn, NULL))
                {
                    TRACE_OUT (("TCP: Sending BUFFER_EMPTY_INDICATION to transport."));
                    g_Transport->BufferEmptyIndication(XprtConn);
                }
            }
        }
        break;

    case WM_PLUGGABLE_X224:
        // for low level read and write,
        {
            XprtConn.eType = (TransportType) PLUGXPRT_WPARAM_TO_TYPE(wParam);
            XprtConn.nLogicalHandle = PLUGXPRT_WPARAM_TO_ID(wParam);
            ASSERT(IS_PLUGGABLE(XprtConn));

            event = PLUGXPRT_LPARAM_TO_EVENT(lParam);
            error = PLUGXPRT_LPARAM_TO_ERROR(lParam);

            /* We disconnect whenever a socket command generates an error message */
            if (error)
            {
                WARNING_OUT(("PluggableWndProc: error %d on socket (%d, %d). Event: %d",
                         error, XprtConn.eType, XprtConn.nLogicalHandle, event));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                ::PluggableShutdown(XprtConn);
                break;
            }

            switch (event)
            {
            case PLUGXPRT_EVENT_READ:
                 TRACE_OUT(("PluggableWndProc: READ(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::ReadRequestEx(XprtConn);
                break;

            case PLUGXPRT_EVENT_WRITE:
                TRACE_OUT(("PluggableWndProc: WRITE(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::PluggableWriteTheFirst(XprtConn);
                break;

            case PLUGXPRT_EVENT_CLOSE:
                TRACE_OUT(("PluggableWndProc: CLOSE(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                break;

            case PLUGXPRT_HIGH_LEVEL_READ:
                TRACE_OUT(("PluggableWndProc: READ_NEXT(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::ReadRequestEx(XprtConn);
                break;

            case PLUGXPRT_HIGH_LEVEL_WRITE:
                TRACE_OUT(("PluggableWndProc: WRITE_NEXT(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                // We need to flush the socket's pending data first.
                if (TRANSPORT_NO_ERROR == ::DataRequest(XprtConn, NULL))
                {
                    TRACE_OUT(("PluggableWndProc: Sending BUFFER_EMPTY_INDICATION to transport."));
                    g_Transport->BufferEmptyIndication(XprtConn);
                }
                break;

            default:
                ERROR_OUT(("PluggableWndProc: unknown event=%d.", event));
                break;
            }
        }
        break;

    case WM_PLUGGABLE_PSTN:
        {
            extern void HandlePSTNCallback(WPARAM wParam, LPARAM lParam);
            HandlePSTNCallback(wParam, lParam);
        }
        break;

    default:
        {
             /*
             **    The message is not related to WinSock messages, so let
             **    the default window procedure handle it.
             */
            return (DefWindowProc (window_handle, message, wParam, lParam));
        }
    }

    return (0);
}

//  GetSecurityInfo() takes a connection_handle and returns the security information associated with
//  it.
//
//    Returns TRUE if we can either find the information or we are not directly connected to the node
//    represented by this connection handle.
//
//    Returns FALSE if we are directly connected but for some reason could not get the info -- this
//    result should be viewed as suspicious.
BOOL GetSecurityInfo(ConnectionHandle connection_handle, PBYTE pInfo, PDWORD pcbInfo)
{
    PSocket pSocket;
    SOCKET socket_number;

    if (g_pMCSController->FindSocketNumber(connection_handle, &socket_number))
    {
        TransportConnection XprtConn;
        SET_SOCKET_CONNECTION(XprtConn, socket_number);

        BOOL fRet = FALSE;
        if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
        {
            if (NULL != pSocket->pSC)
            {
                fRet = pSocket->pSC->GetUserCert(pInfo, pcbInfo);
            }
            else
            {
                WARNING_OUT(("GetSecurityInfo: queried non-secure socket %d", socket_number));
            }

            pSocket->Release();
        }
        else
        {
            WARNING_OUT(("GetSecurityInfo: socket %d not found", socket_number ));
        }
        return fRet;
    }
    // In this case we are not directly connected, so will return length of NOT_DIRECTLY_CONNECTED
    // but positive return value.
    *pcbInfo = NOT_DIRECTLY_CONNECTED;
    return TRUE;
}

//     GetSecurityInfoFromGCCID() takes a GCCID and returns the security information associated with
//    it.
//
//    Returns TRUE if either (1) we successfully retrieve the information from a transport-level
//    connection, or (2) we find that we are not directly connected to the node with this GCCID.
//
//    Returns FALSE if we are directly connected but cannot retrieve the info, or some other error
//    occurs.  A FALSE return value should be treated as a security violation.

BOOL WINAPI T120_GetSecurityInfoFromGCCID(DWORD dwGCCID, PBYTE pInfo, PDWORD pcbInfo)
{
    PSocket            pSocket;

    SOCKET socket_number;
    if ( NULL != dwGCCID )
    {
        // Get the user info for a remote connection
        ConnectionHandle connection_handle;
        BOOL fConnected = FindSocketNumber(dwGCCID, &socket_number);
        if (fConnected == FALSE) {
            (* pcbInfo) = 0;
            return TRUE;
        }

        TransportConnection XprtConn;
        SET_SOCKET_CONNECTION(XprtConn, socket_number);

        BOOL fRet = FALSE;
        if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
        {
            if (NULL != pSocket->pSC)
            {
                fRet = pSocket->pSC->GetUserCert(pInfo, pcbInfo);
            }
            else
            {
                WARNING_OUT(("GetSecurityInfoFromGCCID: queried non-secure socket %d", socket_number));
            }
            pSocket->Release();
        }
        else
        {
            ERROR_OUT(("GetSecurityInfoFromGCCID: socket %d not found", socket_number ));
        }
        return fRet;
    }
    else
    {
        // Get the user info for the local user
        if ( NULL != g_Transport && NULL != g_Transport->pSecurityInterface )
            return g_Transport->pSecurityInterface->GetUserCert( pInfo, pcbInfo );
        else
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\tprtntfy.h ===
#ifndef _TPRT_NOTIFY_
#define _TPRT_NOTIFY_

#define TPRT_NOTIFY_NONE                                0
#define TPRT_NOTIFY_OTHER_REASON                        1
#define TPRT_NOTIFY_REMOTE_NO_SECURITY        	        2
#define TPRT_NOTIFY_REMOTE_DOWNLEVEL_SECURITY           3
#define TPRT_NOTIFY_INCOMPATIBLE_T120_TPDU              4
#define TPRT_NOTIFY_REMOTE_REQUIRE_SECURITY		5
#define TPRT_NOTIFY_AUTHENTICATION_FAILED		6

#endif // _TPRT_NOTIFY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\tprtsec.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);

// #define FORCE_SSL3_NEGOTIATION

#include "tprtsec.h"

/*    Tprtsec.cpp
 *
 *    Copyright (c) 1997 by Microsoft Corporation
 *
 *    Abstract:
 *        This module maintains security for the TCP transport.
 *
 */

/* External definitions */
extern HINSTANCE            g_hDllInst;

/*
 *    The following array contains a template for the X.224 data header.
 *    The 5 of the 7 bytes that it initializes are actually sent to the
 *    wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *    The array is only used when we encode a data PDU.
 */
extern UChar g_X224Header[];


#ifdef DEBUG
//#define TESTHACKS // DANGER! don't turn on in public build!
//#define DUMP
//#define DUMPCERTS
//#undef TRACE_OUT
//#define TRACE_OUT WARNING_OUT
#endif //DEBUG

#define    SZSECPKG    UNISP_NAME_A

#define    ISC_REQ_FLAGS (    ISC_REQ_SEQUENCE_DETECT |\
                        ISC_REQ_REPLAY_DETECT |\
                        ISC_REQ_CONFIDENTIALITY |\
                        ISC_REQ_EXTENDED_ERROR |\
                        ISC_REQ_ALLOCATE_MEMORY |\
                        ISC_REQ_STREAM)

#define    ASC_REQ_FLAGS (    ASC_REQ_SEQUENCE_DETECT |\
                        ASC_REQ_REPLAY_DETECT |\
                        ASC_REQ_CONFIDENTIALITY |\
                        ASC_REQ_EXTENDED_ERROR |\
                        ASC_REQ_ALLOCATE_MEMORY |\
                        ASC_REQ_MUTUAL_AUTH |\
                        ASC_REQ_STREAM)


#if defined(DUMP) || defined(DUMPCERTS)

#define MAX_DUMP_BYTES    512

void dumpbytes(PSTR szComment, PBYTE p, int cb)
{
    int i,j;
    char buf[80];
    char buf2[80];
    DWORD dwCheckSum = 0;
    int cbShow = min(MAX_DUMP_BYTES,cb);

    for (i=0; i<cb; i++)
        dwCheckSum += p[i];

    wsprintf(buf,"%s (%d bytes, checksum %x):",
        szComment? szComment : "unknown", cb, dwCheckSum);
    OutputDebugString(buf);
    WARNING_OUT(("%s",buf));
    OutputDebugString("\n\r");

    for (i=0; i<cbShow/16; i++)
    {
        wsprintf(buf, "%08x: ", (DWORD) &p[(i*16)] );
        for (j=0; j<16; j++)
        {
            wsprintf(buf2," %02x", (int) (unsigned char) p[(i*16)+j] );
            lstrcat ( buf, buf2 );
        }
        WARNING_OUT(("%s",buf));
        lstrcat ( buf, "\n\r");
        OutputDebugString(buf);
    }
    if ( cbShow%16 )
    {
        wsprintf(buf, "%08x: ", (DWORD) &p[(i*16)] );
        for (j=0; j<cbShow%16; j++)
        {
            wsprintf(buf2," %02x", (int) (unsigned char) p[(i*16)+j] );
            lstrcat ( buf, buf2 );
        }
        WARNING_OUT(("%s",buf));
        lstrcat(buf,"\n\r");
        OutputDebugString(buf);
    }
    if ( cbShow < cb )
    {
        OutputDebugString("...\n\r");
        WARNING_OUT(("..."));
    }
}
#endif //DUMP or DUMPCERTS


///////////////////////////////////////////////////////////////////////////
// Security Interface
///////////////////////////////////////////////////////////////////////////




SecurityInterface::SecurityInterface(void) :
                LastError(TPRTSEC_NOERROR),
                bInboundCredentialValid(FALSE),
                bOutboundCredentialValid(FALSE),
                m_pbEncodedCert(NULL),
                m_cbEncodedCert(0),
                hSecurityDll(NULL),
                pfnTable(NULL)
{
}

SecurityInterface::~SecurityInterface(VOID)
{
    if ( pfnTable && bInboundCredentialValid )
    {
        pfnTable->FreeCredentialHandle ( &hInboundCredential );
    }

    if ( pfnTable && bOutboundCredentialValid )
    {
        pfnTable->FreeCredentialHandle ( &hOutboundCredential );
    }

    if ( NULL != m_pbEncodedCert )
    {
        delete m_pbEncodedCert;
    }

    if ( NULL != hSecurityDll )
    {
        FreeLibrary( hSecurityDll );
    }
}

#ifdef DUMPCERTS
VOID DumpCertStore ( SecurityInterface * pSI, char * sz, HCERTSTORE hStore)
{
    WARNING_OUT(("************ %s *************", sz));
    PCCERT_CONTEXT pC = NULL;
    int i = 0;
    char buf[256];

    while ( pC = CertEnumCertificatesInStore(
                                    hStore, (PCERT_CONTEXT)pC ))
    {
        WARNING_OUT(("----------- Entry %d: ----------------", i));

        // Dump stuff in pC->pCertInfo
        //DWORD                       dwVersion;
        //CRYPT_INTEGER_BLOB          SerialNumber;
        //CRYPT_ALGORITHM_IDENTIFIER  SignatureAlgorithm;
        //CERT_NAME_BLOB              Issuer;
        //FILETIME                    NotBefore;
        //FILETIME                    NotAfter;
        //CERT_NAME_BLOB              Subject;
        //CERT_PUBLIC_KEY_INFO        SubjectPublicKeyInfo;
        //CRYPT_BIT_BLOB              IssuerUniqueId;
        //CRYPT_BIT_BLOB              SubjectUniqueId;
        //DWORD                       cExtension;
        //PCERT_EXTENSION             rgExtension;

        WARNING_OUT(("dwVersion: %x", pC->pCertInfo->dwVersion));

        dumpbytes("SerialNumber",
            pC->pCertInfo->SerialNumber.pbData,
            pC->pCertInfo->SerialNumber.cbData );

        WARNING_OUT(("SignatureAlgorithm (name): %s",
            pC->pCertInfo->SignatureAlgorithm.pszObjId ));

        CertNameToStr( pC->dwCertEncodingType, &pC->pCertInfo->Issuer,
            CERT_X500_NAME_STR, buf, sizeof(buf) );
        WARNING_OUT(("Issuer: %s", buf ));

        WARNING_OUT(("NotBefore: %x,%x",
            pC->pCertInfo->NotBefore.dwLowDateTime,
            pC->pCertInfo->NotBefore.dwHighDateTime ));
        WARNING_OUT(("NotAfter: %x,%x",
            pC->pCertInfo->NotAfter.dwLowDateTime,
            pC->pCertInfo->NotAfter.dwHighDateTime ));

        CertNameToStr( pC->dwCertEncodingType, &pC->pCertInfo->Subject,
            CERT_X500_NAME_STR, buf, sizeof(buf) );
        WARNING_OUT(("Subject: %s", buf ));

        WARNING_OUT(("<stuff omitted for now>"));

        dumpbytes("IssuerUniqueId",
            pC->pCertInfo->IssuerUniqueId.pbData,
            pC->pCertInfo->IssuerUniqueId.cbData );

        dumpbytes("SubjectUniqueId",
            pC->pCertInfo->SubjectUniqueId.pbData,
            pC->pCertInfo->SubjectUniqueId.cbData );

        WARNING_OUT(("cExtension: %x", pC->pCertInfo->cExtension ));
        WARNING_OUT(("<stuff omitted for now>"));

        i++;
    }
}
#endif // DUMPCERTS

TransportSecurityError SecurityInterface::InitializeCreds(
                        PCCERT_CONTEXT pCertContext )
{
    SECURITY_STATUS ss;
    SCHANNEL_CRED CredData;

    CredHandle hNewInboundCred;
    CredHandle hNewOutboundCred;

    //
    // Are we going to create new creds or just clean up?
    //

    if ( NULL != pCertContext )
    {
        ZeroMemory(&CredData, sizeof(CredData));
        CredData.dwVersion = SCHANNEL_CRED_VERSION;

        #ifdef FORCE_SSL3_NEGOTIATION
        CredData.grbitEnabledProtocols = SP_PROT_SSL3_CLIENT |
                                    SP_PROT_SSL3_SERVER;
        #endif // FORCE_SSL3_NEGOTIATION

        CredData.dwFlags = SCH_CRED_NO_SERVERNAME_CHECK |
                            SCH_CRED_NO_DEFAULT_CREDS |
                            SCH_CRED_MANUAL_CRED_VALIDATION;

        CredData.cCreds = 1;
        CredData.paCred = &pCertContext;

        // Acquire client and server credential handles

        ss = pfnTable->AcquireCredentialsHandle (
            NULL,
            SZSECPKG,
            SECPKG_CRED_INBOUND,
            NULL,
            &CredData,
            NULL,
            NULL,
            &hNewInboundCred,
            &tsExpiry );

        if ( SEC_E_OK != ss )
        {
            WARNING_OUT(("AcquireCredentialsHandle (inbound) failed %lx", ss));
            LastError = TPRTSEC_SSPIFAIL;
            goto error;
        }

        ss = pfnTable->AcquireCredentialsHandle (
            NULL,
            SZSECPKG,
            SECPKG_CRED_OUTBOUND,
            NULL,
            &CredData,
            NULL,
            NULL,
            &hNewOutboundCred,
            &tsExpiry );

        if ( SEC_E_OK != ss )
        {
            WARNING_OUT(("AcquireCredentialsHandle (outbound) failed %lx", ss));
            pfnTable->FreeCredentialHandle( &hNewInboundCred );
            LastError = TPRTSEC_SSPIFAIL;
            goto error;
        }

        // Empty the SSL cache
        if (pfn_SslEmptyCache)
        {
            pfn_SslEmptyCache();
        }

        // This member can be called even when we're already initialized, as
        // when the user chooses a different cert and we need to build new
        // credentials based on it. Clear out the old information as necessary:

        if ( NULL != m_pbEncodedCert )
        {
            delete m_pbEncodedCert;
            m_pbEncodedCert = NULL;
        }
    }

    if ( bInboundCredentialValid )
        pfnTable->FreeCredentialHandle ( &hInboundCredential );

    if ( bOutboundCredentialValid )
        pfnTable->FreeCredentialHandle ( &hOutboundCredential );

    if ( NULL != pCertContext )
    {
        hInboundCredential = hNewInboundCred;
        hOutboundCredential = hNewOutboundCred;
        bInboundCredentialValid = TRUE;
        bOutboundCredentialValid = TRUE;

        //
        // Save the cert name for later use
        //

        ASSERT( NULL == m_pbEncodedCert );
        m_pbEncodedCert = new BYTE[pCertContext->cbCertEncoded];

        if ( NULL == m_pbEncodedCert )
        {
            ERROR_OUT(("Error allocating data for encoded Cert"));
            goto error;
        }

        memcpy( m_pbEncodedCert, pCertContext->pbCertEncoded,
                                pCertContext->cbCertEncoded );

        ASSERT(pCertContext->cbCertEncoded);
        m_cbEncodedCert = pCertContext->cbCertEncoded;
    }
    else
    {
        bInboundCredentialValid = FALSE;
        bOutboundCredentialValid = FALSE;
    }

    LastError = TPRTSEC_NOERROR;

error:

    return LastError;
}

TransportSecurityError SecurityInterface::Initialize(VOID)
{
    TRACE_OUT(("Initializing security interface"));

    // Load the security provider DLL

    hSecurityDll = LoadLibrary("SCHANNEL");

    if ( !hSecurityDll )
    {
        ERROR_OUT(("Loadlib schannel.dll failed"));
        LastError = TPRTSEC_NODLL;
        goto error;
    }

    // Get the initialization entrypoint
    pfnInitSecurityInterface = (INIT_SECURITY_INTERFACE)GetProcAddress(
                                hSecurityDll,
                                SECURITY_ENTRYPOINT );

    if ( NULL == pfnInitSecurityInterface )
    {
        ERROR_OUT(("GetProcAddr %s failed", SECURITY_ENTRYPOINT));
        LastError = TPRTSEC_NOENTRYPT;
        goto error;
    }

    // Get the SSPI function table
    pfnTable = (*pfnInitSecurityInterface)();

    if ( NULL == pfnTable )
    {
        ERROR_OUT(("InitializeSecurityProvider failed"));
        LastError = TPRTSEC_SSPIFAIL;
        goto error;
    }

    pfn_SslEmptyCache = (PFN_SSL_EMPTY_CACHE)GetProcAddress(hSecurityDll, SZ_SSLEMPTYCACHE);
    if ( NULL == pfnInitSecurityInterface )
    {
        ERROR_OUT(("GetProcAddr %s failed", SZ_SSLEMPTYCACHE));
        LastError = TPRTSEC_NOENTRYPT;
        goto error;
    }

error:

    return LastError;
}

BOOL SecurityInterface::GetUserCert(PBYTE pInfo, PDWORD pcbInfo)
{
    if ( NULL == m_pbEncodedCert)
    {
        WARNING_OUT(("GetUserCert: no encoded certname"));
        return FALSE;
    }

    ASSERT(m_cbEncodedCert > 0);

    if ( NULL == pInfo )
    {
        // Caller wants to know how much to allocate
        ASSERT(pcbInfo);
        *pcbInfo = m_cbEncodedCert;
        return TRUE;
    }

    if ( *pcbInfo < m_cbEncodedCert )
    {
        ERROR_OUT(("GetUserCert: insufficient buffer (%ld) %ld required",
            *pcbInfo, m_cbEncodedCert ));
        return FALSE;
    }

    memcpy ( (PCHAR)pInfo, m_pbEncodedCert, m_cbEncodedCert );
    *pcbInfo = m_cbEncodedCert;

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// Security Context
///////////////////////////////////////////////////////////////////////////





SecurityContext::SecurityContext(PSecurityInterface pSI, LPCSTR szHostName) :
                    scstate(SECCTX_STATE_NEW),
                    fContinueNeeded(FALSE),
                    LastError(TPRTSEC_NOERROR),
                    bContextHandleValid(FALSE)
{
    ASSERT(pSI);
    ASSERT(szHostName);

    pSecurityInterface = pSI;

    OutBuffers[0].pvBuffer = NULL;
    OutBuffers[0].cbBuffer = 0;

    if ( NULL != szHostName )
    {
        wsprintf( szTargetName, "%s:%x%x", szHostName,
            pSI->hOutboundCredential.dwUpper,
            pSI->hOutboundCredential.dwLower);
        TRACE_OUT(("SecurityContext::SecurityContext: targ %s",szTargetName));
    }
    ASSERT(pSecurityInterface);
}

SecurityContext::~SecurityContext(VOID)
{
    ASSERT(pSecurityInterface);
    if ( NULL != OutBuffers[0].pvBuffer )
    {
        ASSERT(pSecurityInterface->pfnTable);

        pSecurityInterface->pfnTable->FreeContextBuffer(OutBuffers[0].pvBuffer);
        OutBuffers[0].pvBuffer = NULL;
    }
    if ( bContextHandleValid )
    {
        pSecurityInterface->pfnTable->DeleteSecurityContext(&hContext);
    }
}


TransportSecurityError SecurityContext::InitContextAttributes(VOID)
{
    SECURITY_STATUS ss;

    ss = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                     SECPKG_ATTR_STREAM_SIZES,
                                     &Sizes );
    if (ss != ERROR_SUCCESS)
    {
        ERROR_OUT(("QueryContextAttributes returned [%x]", ss));
        return LastError = TPRTSEC_SSPIFAIL;
    }
    else
    {
        ASSERT (Sizes.cbHeader + Sizes.cbTrailer <= PROTOCOL_OVERHEAD_SECURITY);
        TRACE_OUT(("QueryContextAttributes returned header=%d trailer=%d",
                        Sizes.cbHeader, Sizes.cbTrailer));
    }

    #ifdef DEBUG //////////////////////////////////////////////////////////
    SecPkgContext_KeyInfo KeyInfo;

    ss = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                    SECPKG_ATTR_KEY_INFO,
                                    &KeyInfo );
    if (ss != ERROR_SUCCESS)
    {
        ERROR_OUT(("QueryContextAttributes (KEY_INFO) failed %x", ss));
    }
    else
    {
        WARNING_OUT(("KEY INFO: Sign:%s Encrypt:%s Keysize:%d",
                    KeyInfo.sSignatureAlgorithmName,
                    KeyInfo.sEncryptAlgorithmName,
                    KeyInfo.KeySize ));
        pSecurityInterface->pfnTable->FreeContextBuffer(
                    KeyInfo.sSignatureAlgorithmName );
        pSecurityInterface->pfnTable->FreeContextBuffer(
                    KeyInfo.sEncryptAlgorithmName );
    }

    #endif //DEBUG ///////////////////////////////////////////////////////

    return TPRTSEC_NOERROR;
}


TransportSecurityError SecurityContext::Initialize(PBYTE pData, DWORD cbData)
{
    SECURITY_STATUS ss;
    DWORD dwReqFlags;

    TRACE_OUT(("SecurityContext Initialize (%x,%d)", pData, cbData));

    fContinueNeeded = FALSE;

    ASSERT(pSecurityInterface);
    ASSERT(SECCTX_STATE_INIT == scstate || SECCTX_STATE_NEW == scstate);

    if ( !pSecurityInterface->bOutboundCredentialValid )
    {
        WARNING_OUT(("SecurityContext::Initialize: no outbound cred"));
        return TPRTSEC_SSPIFAIL;
    }

    if ( SECCTX_STATE_INIT == scstate)
    {
        ASSERT(NULL != pData);
        ASSERT(0 != cbData);

        if ( NULL == pData || 0 == cbData )
        {
            ERROR_OUT(("Second initialize call with no data"));
            return LastError = TPRTSEC_INVALID_PARAMETER;
        }

        // Build the input buffer descriptor

        InputBufferDescriptor.cBuffers = 2;
        InputBufferDescriptor.pBuffers = InBuffers;
        InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

        InBuffers[0].BufferType = SECBUFFER_TOKEN;
        InBuffers[0].cbBuffer = cbData;
        InBuffers[0].pvBuffer = pData;

        InBuffers[1].BufferType = SECBUFFER_EMPTY;
        InBuffers[1].cbBuffer = 0;
        InBuffers[1].pvBuffer = NULL;
    }
    else
    {
        ASSERT(NULL == pData);
        ASSERT(0 == cbData);
    }

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = OutBuffers;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    // If there's a output buffer from a previous call, free it here
    if ( NULL != OutBuffers[0].pvBuffer )
    {
        pSecurityInterface->pfnTable->FreeContextBuffer(OutBuffers[0].pvBuffer);
    }

    dwReqFlags = ISC_REQ_FLAGS;

    while ( 1 )
    {
        OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer = 0;
        OutBuffers[0].pvBuffer = NULL;

        #ifdef DUMP
        if (SECCTX_STATE_INIT == scstate)
        {
            dumpbytes("input token", (unsigned char *)InBuffers[0].pvBuffer,
                                                    InBuffers[0].cbBuffer);
        }
        #endif //DUMP

        ss = pSecurityInterface->pfnTable->InitializeSecurityContext(
                &(pSecurityInterface->hOutboundCredential),
                SECCTX_STATE_INIT == scstate ?  &hContext : NULL,
                szTargetName, // TargetName
                dwReqFlags,
                0, // Reserved
                SECURITY_NATIVE_DREP,
                SECCTX_STATE_INIT == scstate ?  &InputBufferDescriptor : NULL,
                0,        // reserved
                &hContext,
                &OutputBufferDescriptor,
                &ContextAttributes,
                &Expiration );

        // Some security providers don't process all the packet data
        // in one call to SCA - readjust the input buffers with the offset
        // returned in the extra buffer and iterate as necessary

        if (( SEC_I_CONTINUE_NEEDED == ss
            && NULL == OutBuffers[0].pvBuffer )
            && SECBUFFER_EXTRA == InBuffers[1].BufferType
            && 0 != InBuffers[1].cbBuffer )
        {
            InBuffers[0].pvBuffer = (PBYTE)(InBuffers[0].pvBuffer) +
                        ( InBuffers[0].cbBuffer - InBuffers[1].cbBuffer );
            InBuffers[0].BufferType = SECBUFFER_TOKEN;
            InBuffers[0].cbBuffer = InBuffers[1].cbBuffer;

            InBuffers[1].BufferType = SECBUFFER_EMPTY;
            InBuffers[1].cbBuffer = 0;
            InBuffers[1].pvBuffer = NULL;

            continue;
        }
        break;
    }


    #ifdef DUMP
    if ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss )
    {
        dumpbytes("output token",
            (unsigned char *)OutBuffers[0].pvBuffer,
            OutBuffers[0].cbBuffer);
    }
    #endif //DUMP

#ifdef ALLOW_NON_AUTHENTICATED_CLIENTS
    if ( SEC_I_INCOMPLETE_CREDENTIALS == ss )
    {
        WARNING_OUT(("InitializeSecurityContext:SEC_I_INCOMPLETE_CREDENTIALS"));

        dwReqFlags |= ISC_REQ_USE_SUPPLIED_CREDS;

        ss = pSecurityInterface->pfnTable->InitializeSecurityContext(
                &(pSecurityInterface->hOutboundCredential),
                SECCTX_STATE_INIT == scstate ?  &hContext : NULL,
                szTargetName, // TargetName
                dwReqFlags,
                0, // Reserved
                SECURITY_NATIVE_DREP,
                SECCTX_STATE_INIT == scstate ?  &InputBufferDescriptor : NULL,
                0,        // reserved
                &hContext,
                &OutputBufferDescriptor,
                &ContextAttributes,
                &Expiration );
    }
#endif // ALLOW_NON_AUTHENTICATED_CLIENTS

    if ( SEC_E_OK != ss )
    {
        if ( SEC_I_CONTINUE_NEEDED == ss && NULL != OutBuffers[0].pvBuffer )
        {
            ASSERT(SECCTX_STATE_NEW == scstate || SECCTX_STATE_INIT == scstate);

            TRACE_OUT(("Initialize: SEC_I_CONTINUE_NEEDED"));
            scstate = SECCTX_STATE_INIT;
        }
        else
        {
            ERROR_OUT(("Initialize failed: %x in state %d",(DWORD)ss,scstate));
            return LastError = TPRTSEC_SSPIFAIL;
        }
    }
    else
    {
        //  We're almost done,
        //  find the header and trailer sizes
        //

        if ( TPRTSEC_NOERROR != InitContextAttributes() )
            return LastError;

        if ( !Verify() )
            return LastError = TPRTSEC_SSPIFAIL;

        TRACE_OUT(("INITIALIZE OK"));

        scstate = SECCTX_STATE_INIT_COMPLETE;
    }

    // If there is an output buffer, set the flag to get it sent accross
    if ( ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss ) &&
                                NULL != OutBuffers[0].pvBuffer )
    {
        fContinueNeeded = TRUE;
    }

    bContextHandleValid = TRUE;
    return LastError = TPRTSEC_NOERROR;
}


TransportSecurityError SecurityContext::Accept(PBYTE pData, DWORD cbData)
{
    SECURITY_STATUS ss;

    fContinueNeeded = FALSE;

    ASSERT(SECCTX_STATE_NEW == scstate || SECCTX_STATE_ACCEPT == scstate);

    if ( !pSecurityInterface->bInboundCredentialValid )
    {
        WARNING_OUT(("SecurityContext::Initialize: no inbound cred"));
        return TPRTSEC_SSPIFAIL;
    }

    // Check to see if the required data is present
    if ( NULL == pData || 0 == cbData )
    {
        ERROR_OUT(("Accept: no data"));
        return LastError = TPRTSEC_INVALID_PARAMETER;
    }

    // Build the input buffer descriptor

    InputBufferDescriptor.cBuffers = 2;
    InputBufferDescriptor.pBuffers = InBuffers;
    InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    InBuffers[0].BufferType = SECBUFFER_TOKEN;
    InBuffers[0].cbBuffer = cbData;
    InBuffers[0].pvBuffer = pData;

    InBuffers[1].BufferType = SECBUFFER_EMPTY;
    InBuffers[1].cbBuffer = 0;
    InBuffers[1].pvBuffer = NULL;

    // Build the output buffer descriptor

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = OutBuffers;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    // If there's a output buffer from a previous call, free it here
    if ( NULL != OutBuffers[0].pvBuffer )
    {
        pSecurityInterface->pfnTable->FreeContextBuffer(OutBuffers[0].pvBuffer);
    }

    while ( 1 )
    {
        OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer = 0;
        OutBuffers[0].pvBuffer = NULL;

        #ifdef DUMP
        dumpbytes("input token", (unsigned char *)InBuffers[0].pvBuffer,
                                        InBuffers[0].cbBuffer);
        #endif //DUMP

        ss = pSecurityInterface->pfnTable->AcceptSecurityContext(
                    &(pSecurityInterface->hInboundCredential),
                    SECCTX_STATE_NEW == scstate ?  NULL : &hContext,
                    &InputBufferDescriptor,
                    ASC_REQ_FLAGS,
                    SECURITY_NATIVE_DREP,
                    &hContext, // receives new context handle
                    &OutputBufferDescriptor, // receives output security token
                    &ContextAttributes,        // receives context attributes
                    &Expiration );            // receives expiration time

        // Some security providers don't process all the packet data
        // in one call to SCA - readjust the input buffers with the offset
        // returned in the extra buffer and iterate as necessary

        if (( SEC_I_CONTINUE_NEEDED == ss
            && NULL == OutBuffers[0].pvBuffer )
            && SECBUFFER_EXTRA == InBuffers[1].BufferType
            && 0 != InBuffers[1].cbBuffer )
        {
            InBuffers[0].pvBuffer = (PBYTE)(InBuffers[0].pvBuffer) +
                        ( InBuffers[0].cbBuffer - InBuffers[1].cbBuffer );
            InBuffers[0].BufferType = SECBUFFER_TOKEN;
            InBuffers[0].cbBuffer = InBuffers[1].cbBuffer;

            InBuffers[1].BufferType = SECBUFFER_EMPTY;
            InBuffers[1].cbBuffer = 0;
            InBuffers[1].pvBuffer = NULL;

            continue;
        }
        break;
    }

    #ifdef DUMP
    if ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss )
    {
        dumpbytes("output token",
            (unsigned char *)OutBuffers[0].pvBuffer,
            OutBuffers[0].cbBuffer);
    }
    #endif //DUMP

    if ( SEC_E_OK != ss )
    {
        if ( SEC_I_CONTINUE_NEEDED == ss )
        {
            TRACE_OUT(("Accept: SEC_I_CONTINUE_NEEDED"));

            scstate = SECCTX_STATE_ACCEPT;
        }
        else
        {
            ERROR_OUT(("AcceptSecurityContext failed: %x", (DWORD)ss));
            return LastError = TPRTSEC_SSPIFAIL;
        }
    }
    else
    {

        //  We're almost done,
        //  find the header and trailer sizes
        //

        if ( TPRTSEC_NOERROR != InitContextAttributes() )
            return LastError;

        if ( !Verify() )
            return LastError = TPRTSEC_SSPIFAIL;

        TRACE_OUT(("ACCEPT OK"));

        scstate = SECCTX_STATE_ACCEPT_COMPLETE;
    }

    // If there is an output buffer, set the flag to get it sent accross
    if ( ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss ) &&
                                NULL != OutBuffers[0].pvBuffer )
    {
        fContinueNeeded = TRUE;
    }

    bContextHandleValid = TRUE;
    return LastError = TPRTSEC_NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
//
// Encrypt()
//
// Description:
//    Encrypts a packet to be sent using SSL/PCT by calling SealMessage().
//
// Parameters:
//    phContext         - security context handle returned from InitiateSecConnection
//    pBufIn1, pBufIn2  - buffers to be encrypted
//    cbBufIn1,cbBufIn2    - lengths of buffers to be encrypted
//    ppBufOut          - allocated encrypted buffer, to be freed by caller
//    pcbBufOut         - length of encrypted buffer
//
// Return:
//    TransprotSecurityError
//
TransportSecurityError SecurityContext::Encrypt(
                  LPBYTE      pBufIn1,
                  UINT        cbBufIn1,
                  LPBYTE      pBufIn2,
                  UINT        cbBufIn2,
                  LPBYTE     *ppBufOut,
                  UINT        *pcbBufOut)
{
    SECURITY_STATUS           scRet = ERROR_SUCCESS;
    SecBufferDesc             Buffer;
    SecBuffer                 Buffers[4];
    UINT                      cbBufInTotal;
    LPBYTE                      pbTemp;

    // pBufIn2 and cbBufIn2 maybe NULL and 0, respectively.
    ASSERT(pBufIn1);
    ASSERT(cbBufIn1);
    ASSERT(ppBufOut);
    ASSERT(pcbBufOut);

    ASSERT(SECCTX_STATE_INIT_COMPLETE == scstate ||
            SECCTX_STATE_ACCEPT_COMPLETE == scstate);
    if (SECCTX_STATE_INIT_COMPLETE != scstate &&
        SECCTX_STATE_ACCEPT_COMPLETE != scstate)
        return LastError = TPRTSEC_INCOMPLETE_CONTEXT;

    *pcbBufOut = 0;
    cbBufInTotal = cbBufIn1 + cbBufIn2;

    // We allocate a buffer to hold the (larger) encrypted data.
    // This must be freed by the caller!
    // christts: The buffer will now also hold the X.224 header.
    if (NULL == (*ppBufOut = (LPBYTE)LocalAlloc(0, cbBufInTotal
                                + Sizes.cbHeader + Sizes.cbTrailer +
                                sizeof(X224_DATA_PACKET))))
        return LastError = TPRTSEC_NOMEM;

    pbTemp = *ppBufOut + sizeof(X224_DATA_PACKET);

    //
    // prepare data for SecBuffer
    //
    Buffers[0].pvBuffer = pbTemp;
    Buffers[0].cbBuffer = Sizes.cbHeader;
    Buffers[0].BufferType = SECBUFFER_STREAM_HEADER;

    Buffers[1].pvBuffer = pbTemp + Sizes.cbHeader;
    // Copy the user's data
    CopyMemory(Buffers[1].pvBuffer, pBufIn1, cbBufIn1);
    if (NULL != pBufIn2) {
        CopyMemory((PVoid) ((PUChar) (Buffers[1].pvBuffer) + cbBufIn1),
                    pBufIn2, cbBufIn2);
    }
    Buffers[1].cbBuffer = cbBufInTotal;
    Buffers[1].BufferType = SECBUFFER_DATA;

    Buffers[2].pvBuffer = pbTemp + Sizes.cbHeader + cbBufInTotal;
    Buffers[2].cbBuffer = Sizes.cbTrailer;
    Buffers[2].BufferType = SECBUFFER_STREAM_TRAILER;

    Buffers[3].pvBuffer = NULL;
    Buffers[3].cbBuffer = 0;
    Buffers[3].BufferType = SECBUFFER_EMPTY;

    Buffer.cBuffers = 4;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    #ifdef DUMP
    dumpbytes("data BEFORE encryption", (PBYTE)Buffers[1].pvBuffer,
                    Buffers[1].cbBuffer);
    #endif // DUMP

    // Call the semi-documented SealMessage function (Reserved3)

    scRet = ((SEAL_MESSAGE_FN)pSecurityInterface->pfnTable->Reserved3)(
        &hContext, 0, &Buffer, 0);


    if (scRet != ERROR_SUCCESS)
    {
        //
        // Map the SSPI error.
        //
        ERROR_OUT(("SealMessage failed: %x", scRet));
        LocalFree(*ppBufOut);
        return LastError = TPRTSEC_SSPIFAIL;
    }

    // We also have to add the X.224 header.
    *pcbBufOut = cbBufInTotal + Sizes.cbHeader + Sizes.cbTrailer + sizeof(X224_DATA_PACKET);
    memcpy (*ppBufOut, g_X224Header, sizeof(X224_DATA_PACKET));
    AddRFCSize(*ppBufOut, *pcbBufOut);

    #ifdef TESTHACKS
    // Inject an error...
    if (GetAsyncKeyState(VK_CONTROL)&0x8000) {
        OutputDebugString("*** INJECTING ERROR IN OUTGOING PACKET ***\n\r");
        pbTemp[(*pcbBufOut - sizeof(X224_DATA_PACKET))/2] ^= 0x55;
    }
    #endif //TESTHACKS

    #ifdef DUMP
    dumpbytes("data AFTER encryption",  pbTemp, *pcbBufOut - sizeof(X224_DATA_PACKET));
    #endif // DUMP

    TRACE_OUT(("SealMessage returned Buffer = %p, EncryptBytes = %d, UnencryptBytes = %d", pbTemp,
                *pcbBufOut - sizeof(X224_DATA_PACKET), cbBufInTotal));

    return LastError = TPRTSEC_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
//
// Decrypt
//
// Description:
//    Decrypts a buffer received using SCHANNEL by calling UnsealMessage().
//
// Parameters:
//    pBuf      - buffer to be decrypted
//    cbBufIn       - length of buffer to be decrypted
//
TransportSecurityError SecurityContext::Decrypt( PBYTE pBuf, DWORD cbBuf)
{
    SecBufferDesc   Buffer;
    SecBuffer       Buffers[4];
    DWORD           scRet = ERROR_SUCCESS;
    SecBuffer * pDataBuffer;
    int i;

    LastError = TPRTSEC_SSPIFAIL;

    ASSERT(SECCTX_STATE_INIT_COMPLETE == scstate ||
            SECCTX_STATE_ACCEPT_COMPLETE == scstate);
    if (SECCTX_STATE_INIT_COMPLETE != scstate &&
        SECCTX_STATE_ACCEPT_COMPLETE != scstate)
        return LastError = TPRTSEC_INCOMPLETE_CONTEXT;

    ASSERT(!IsBadWritePtr(pBuf,cbBuf));

    #ifdef TESTHACKS
    // Inject an error...
    if ( GetAsyncKeyState(VK_SHIFT) & 0x8000 ) {
        OutputDebugString("*** INJECTING ERROR IN INCOMING PACKET ***\n\r");
        pBuf[cbBuf/2] ^= 0x55;
    }
    #endif //TESTHACKS

    //
    // prepare data the SecBuffer for a call to SSL/PCT decryption code.
    //
    Buffers[0].pvBuffer   = pBuf;
    Buffers[0].cbBuffer      = cbBuf;

    Buffers[0].BufferType = SECBUFFER_DATA;

    Buffers[1].pvBuffer   = NULL;
    Buffers[1].cbBuffer   = 0;
    Buffers[1].BufferType = SECBUFFER_EMPTY;
    Buffers[2].pvBuffer   = NULL;
    Buffers[2].cbBuffer   = 0;
    Buffers[2].BufferType = SECBUFFER_EMPTY;
    Buffers[3].pvBuffer   = NULL;
    Buffers[3].cbBuffer   = 0;
    Buffers[3].BufferType = SECBUFFER_EMPTY;

    Buffer.cBuffers = 4;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    // Call the semi-documented UnsealMessage function (Reserved4)

    #ifdef DUMP
    dumpbytes("data BEFORE decryption:", (PBYTE)Buffers[0].pvBuffer,
                                        Buffers[0].cbBuffer);
    #endif // DUMP

    scRet = ((UNSEAL_MESSAGE_FN)pSecurityInterface->pfnTable->Reserved4)(
        &hContext, &Buffer, 0, NULL);

    pDataBuffer = NULL;

    for( i=0; i<4; i++ )
    {
        if ( NULL == pDataBuffer && SECBUFFER_DATA == Buffers[i].BufferType )
        {
            pDataBuffer = &Buffers[i];
        }
    }

    if ( NULL == pDataBuffer )
    {
        ERROR_OUT(("Unseal: no data buffer found"));
        return LastError = TPRTSEC_SSPIFAIL;
    }

    #ifdef DUMP
    dumpbytes("data AFTER decryption:", (PBYTE)pDataBuffer->pvBuffer,
                                        pDataBuffer->cbBuffer);
    #endif // DUMP

    if (scRet != ERROR_SUCCESS)
    {
        ERROR_OUT(("UnsealMessage failed with [%x]", scRet));
        return LastError = TPRTSEC_SSPIFAIL;
    }
    return LastError = TPRTSEC_NOERROR;
}


TransportSecurityError SecurityContext::AdvanceState(PBYTE pIncomingData,
                                                    DWORD cbBuf)
{
    TRACE_OUT(("AdvanceState: state %d using data %x (%d)",
        scstate, pIncomingData, cbBuf ));

    switch ( scstate )
    {
        case SECCTX_STATE_INIT:
            if ( TPRTSEC_NOERROR != Initialize( pIncomingData, cbBuf ) )
            {
                WARNING_OUT(("AdvanceState: Initialize failed in INIT"));
                goto error;
            }
            break;

        case SECCTX_STATE_ACCEPT:
        case SECCTX_STATE_NEW:
            if ( TPRTSEC_NOERROR != Accept( pIncomingData, cbBuf ) )
            {
                WARNING_OUT(("AdvanceState: Accept failed in ACCEPT or NEW"));
                goto error;
            }
            break;

        case SECCTX_STATE_INIT_COMPLETE:
        case SECCTX_STATE_ACCEPT_COMPLETE:
        case SECCTX_STATE_ERROR:
        default:
            ERROR_OUT(("AdvanceState: called in unexpected state %d"));
            goto error;

    }
    return LastError = TPRTSEC_NOERROR;

error:

    scstate = SECCTX_STATE_ERROR;
    return LastError;
}

#define CHECKFLAGS  (CERT_STORE_REVOCATION_FLAG |\
                CERT_STORE_SIGNATURE_FLAG |\
                CERT_STORE_TIME_VALIDITY_FLAG)

BOOL SecurityContext::Verify(VOID)
{
    BOOL fRet = TRUE;
    DWORD sc;
    PCCERT_CONTEXT pCert = NULL, pIssuerCert = NULL, pCACert = NULL;
    DWORD dwFlags;
    HCERTSTORE hStore = NULL;
    HCERTSTORE hCAStore = NULL;
    CHAR * pIssuer = NULL;

    ASSERT( NULL != pSecurityInterface );

    // Get the subject cert context
    sc = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                        SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                        (PVOID)&pCert );

    if ( SEC_E_OK != sc )
    {
        ERROR_OUT(("QueryContextAttributes (REMOTE_CERT_CONTEXT) failed"));
        goto error;
    }

    if ( NULL == pCert )
    {
        // The caller is not authenticated
        WARNING_OUT(("No remote cred data"));
        goto error;
    }

    // Open the root store for certificate verification
    hStore = CertOpenSystemStore(0, "Root");

    if( NULL == hStore )
    {
        ERROR_OUT(("Couldn't open root certificate store"));
        goto error;
    }

    dwFlags = CHECKFLAGS;

    // Get the issuer of this cert

    pIssuerCert = CertGetIssuerCertificateFromStore(
                        hStore,
                        pCert,
                        NULL,
                        &dwFlags );

    // If the issuer of the certificate cannot be found in the root store,
    // check the CA store iteratively until we work our way back to a root
    // certificate

    pCACert = pCert;

    while ( NULL == pIssuerCert )
    {
        PCCERT_CONTEXT pTmpCert;

        if ( NULL == hCAStore )
        {
            hCAStore = CertOpenSystemStore(0, "CA");

            if ( NULL == hCAStore )
            {
                ERROR_OUT(("Couldn't open CA certificate store"));
                goto error;
            }
        }

        dwFlags =   CERT_STORE_REVOCATION_FLAG |
                    CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;

        pTmpCert = CertGetIssuerCertificateFromStore(
                        hCAStore,
                        pCACert,
                        NULL,
                        &dwFlags );

        if ( NULL == pTmpCert )
        {
            TRACE_OUT(("Issuer not found in CA store either"));
            break;
        }

        if ( pCACert != pCert )
            CertFreeCertificateContext(pCACert);
        pCACert = pTmpCert;

        if ((( CERT_STORE_REVOCATION_FLAG & dwFlags ) &&
             !( CERT_STORE_NO_CRL_FLAG & dwFlags )) ||
             ( CERT_STORE_SIGNATURE_FLAG & dwFlags ) ||
             ( CERT_STORE_TIME_VALIDITY_FLAG & dwFlags ))
        {
            TRACE_OUT(("Problem with issuer in CA store: %x", dwFlags));
            break;
        }

        dwFlags =   CERT_STORE_REVOCATION_FLAG |
                    CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;

        pIssuerCert = CertGetIssuerCertificateFromStore(
                        hStore,
                        pCACert,
                        NULL,
                        &dwFlags );

    }

    if ( pCACert != pCert )
        CertFreeCertificateContext ( pCACert );

    if ( NULL == pIssuerCert )
    {
        WARNING_OUT(("Verify: Can't find issuer in store"));
    }

    // Check certificate

    if ( NULL != pIssuerCert && 0 != dwFlags )
    {
        if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
        {
            WARNING_OUT(("Verify: Signature invalid"));
        }
        if ( dwFlags & CERT_STORE_TIME_VALIDITY_FLAG )
        {
            WARNING_OUT(("Verify: Cert expired"));
        }
        if ( dwFlags & CERT_STORE_REVOCATION_FLAG )
        {
            if (!(dwFlags & CERT_STORE_NO_CRL_FLAG))
            {
                WARNING_OUT(("Verify: Cert revoked"));
            }
            else
            {
                // We have no CRL for this issuer, do not
                // treat as revoked by default:
                dwFlags &= ~CERT_STORE_REVOCATION_FLAG;
            }
        }
    }

    //
    // Check for no-incomplete-certs policy
    //

#if 0
    if (( NULL == pIssuerCert || ( 0 != ( CHECKFLAGS & dwFlags )))
    {
        WARNING_OUT(("Verify: policy prevents cert use"));
        fRet = FALSE;
        goto error;
    }

    //
    // Is there a mandatory issuer?
    //

    if ( lstrlen(rePol.GetString( REGVAL_POL_ISSUER )))
    {
        DWORD cbIssuer;

        //
        // Get the issuer information
        //

        cbIssuer = CertNameToStr (
                            pCert->dwCertEncodingType,
                            &pCert->pCertInfo->Issuer,
                            CERT_FORMAT_FLAGS,
                            NULL, 0);

        if ( 0 == cbIssuer )
        {
            ERROR_OUT(("GetUserInfo: no issuer string"));
            fRet = FALSE;
            goto error;
        }

        pIssuer = new CHAR[cbIssuer + 1];

        if ( NULL == pIssuer )
        {
            ERROR_OUT(("GetUserInfo: error allocating issuer name"));
        }

        if ( 0 >= CertNameToStr (
                            pCert->dwCertEncodingType,
                            &pCert->pCertInfo->Issuer,
                            CERT_FORMAT_FLAGS,
                            pIssuer, cbIssuer+1))
        {
            ERROR_OUT(("GetUserInfo: error getting issuer string"));
            fRet = FALSE;
            goto error;
        }

        if ( lstrcmp ( rePol.GetString(REGVAL_POL_ISSUER),
            pIssuer ))
        {
            WARNING_OUT(("Issuer (%s) didn't match policy (%s)",
                pIssuer, rePol.GetString(REGVAL_POL_ISSUER)));
            fRet = FALSE;
        }
    }
#endif

error:

    if ( NULL != hStore )
    {
        CertCloseStore(hStore, 0);
    }

    if ( NULL != hCAStore )
    {
        CertCloseStore(hCAStore, 0);
    }

    if ( NULL != pCert )
    {
        CertFreeCertificateContext ( pCert );
    }

    if ( NULL != pIssuerCert )
    {
        CertFreeCertificateContext ( pIssuerCert );
    }

    if ( NULL != pIssuer )
    {
        delete pIssuer;
    }

    return fRet;
}


BOOL SecurityContext::GetUserCert(PBYTE pInfo, PDWORD pcbInfo)
{
    BOOL fRet = FALSE;
    DWORD sc;
    PCCERT_CONTEXT pCert = NULL;

    ASSERT( NULL != pSecurityInterface );

    //
    // Get the certificate from the context
    //

    sc = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                        SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                        (PVOID)&pCert );

    if ( SEC_E_OK != sc )
    {
        ERROR_OUT(("QueryContextAttributes failed"));
        goto cleanup;
    }

    if ( NULL == pCert )
    {
        // The caller is not authenticated
        WARNING_OUT(("No remote cred data"));
        goto cleanup;
    }


    if ( NULL != pInfo && *pcbInfo >= pCert->cbCertEncoded )
    {
        memcpy ( pInfo, pCert->pbCertEncoded, pCert->cbCertEncoded );
    }
    *pcbInfo = pCert->cbCertEncoded;

    fRet = TRUE;

cleanup:

    if ( NULL != pCert )
    {
        CertFreeCertificateContext ( pCert );
    }

    return fRet;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\tprtctrl.h ===
/*	Tprtctrl.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the transport for Winsock over TCP.
 *
 *		This module controls making and breaking socket connections. When the
 *		transport creates or detects a connection, Transprt.cpp is notified.
 *		It then instantiates a connection object which tracks the socket until
 *		it is destroyed.  The TCP stack notifies Transprt.cpp when a socket
 *		connection is up and running. It also notifies us if the link is broken
 *		for some reason. As a result, the Tprtctrl module will notify the user
 *		of new or broken connections.
 *
 *		When the user wants to make a data request of a specific transport
 *		connection, this module maps the connection id to a socket number.  The
 *		data request is passed on to TCP.  Data Indications are passed
 *		to the user by ReadRequest().
 *
 *	USER CALLBACKS:
 *		The user communicates with this DLL by making calls directly to the
 *		DLL.  The DLL communicates with the user by issuing callbacks.
 *		The TInitialize() call accepts as a parameter, a callback address and
 *		a user defined variable.  When a significant event occurs in the DLL,
 *		the DLL will jump to the callback address.  The first parameter of
 *		the callback is the message.  This could be a CONNECT_INDICATION, 
 *		DISCONNECT_INDICATION, or any number of significant events.  The
 *		second parameter is a message specific parameter.  The third 
 *		parameter is the user defined variable that was passed in during
 *		the TInitialize() function.  See the MCATTPRT.h interface file
 *		for a complete description of the callback messages.
 *
 *	MAKING A CALL:
 *		After the initialization has been done, the user will eventually,
 *		want to attempt a connection. The user issues a TConnectRequest() call 
 *		with the IP address of the remote location. The connection request 
 *		is passed on to the Winsock layer. It eventually issues FD_CONNECT to
 *		our window to say that the connection was successful.
 *
 *	RECEIVING A CALL:
 *		If we receive a call from a remote location, Winsock notifies
 *		us with FD_ACCEPT.  We then create a new connection object
 *		associated with the new socket.
 *
 *	SENDING PACKETS:
 *		To send data to the remote location, use the DataRequest() function
 *		call.  This module will pass the packet to the socket that it is
 *		associated with.  The send may actually occur after the call has 
 *		returned to the user.
 *
 *	RECEIVING PACKETS:
 *		The user receives packets by DATA_INDICATION callbacks.  When Winsock
 *		notifies us with a FD_READ, we issue a recv() to receive any new
 *		packets. If a packet is complete, we issue a DATA_INDICATION
 *		callback to the user with the socket handle, the address 
 *		of the packet, and the packet length.
 *
 *	DISCONNECTING A TRANSPORT:
 *		To disconnect a transport connection, use the DisconnectRequest()
 *		function.  After the link has been brought down, we perform a 
 *		callback to the user to verify the disconnect.
 *
 */
#ifndef	_TRANSPORT_CONTROLLER_
#define	_TRANSPORT_CONTROLLER_

/* Header for a RFC1006 packet */
typedef struct _rfc_tag
{
	UChar	Version;		/* Should be RFC1006_VERSION_NUMBER (3) */
	UChar	Reserved;		/* Must be 0x00 */
	UChar	msbPacketSize;	/* msb of packet size, including RFC header */
	UChar	lsbPacketSize;	/* lsb of packet size, including RFC header */
} RFC_HEADER;

/* Header for X224 data packet */
typedef struct _data_packet_tag
{
	RFC_HEADER	rfc;		/* RFC1006 packet header */
	UChar	HeaderSize;		/* Must be 0x02, for data packets */
	UChar	PacketType;		/* Must be DATA_PACKET, for data packets */
	UChar	FinalPacket;	/* EOT_BIT or 0 */
} X224_DATA_PACKET;

#include "socket.h"

/* Connection Info (used for both CONNECTION_REQUEST and CONNECTION_CONFIRM) */
typedef struct _connect_common_tag
{
	UChar	PacketType;		/* CONNECTION_REQUEST_PACKET or CONFIRM_PACKET */
	UChar	msbDest;		/* msb of destination-side (answering) socket id */
	UChar	lsbDest;		/* lsb of destination-side (answering) socket id */
	UChar	msbSrc;			/* msb of source-side (initiating) socket id */
	UChar	lsbSrc;			/* lsb of source-side (initiating) socket id */
	UChar	DataClass;		/* Must be 0x00 */
} X224_CONNECT_COMMON;

/* Transport variable field info type and size. */
typedef struct _t_variable_field_info
{
	UChar	InfoType;
	UChar	InfoSize;
} X224_VARIABLE_INFO;

/* TPDU Arbitration Info (not used with CONNECTION_CONFIRM) */
typedef struct _tpdu_info_tag
{
	UChar	InfoType;		/* Must be TPDU_SIZE (192) */
	UChar	InfoSize;		/* Must be 1 */
	UChar	Info;			/* Requested PDU Size (default: 10, or 1K bytes) */
} X224_TPDU_INFO;

/* Minimal Connection Request/Confirm packet */
typedef struct _connect_tag
{
	RFC_HEADER			rfc;	/* RFC1006 packet header */
	UChar	HeaderSize;			
	X224_CONNECT_COMMON	conn;	/* Connection Info */
} X224_CONNECT;

typedef X224_CONNECT X224_CR_FIXED;
typedef X224_CONNECT X224_CC_FIXED;

typedef struct _disconnect_info_tag
{
	UChar	PacketType;		/* Must be DISCONNECT_REQUEST_PACKET */
	UChar	msbDest;		
	UChar	lsbDest;
	UChar	msbSrc;
	UChar	lsbSrc;
	UChar	reason;			/* DR Reason Code */
} X224_DISCONN;

typedef struct _disconnect_request_fixed
{
    RFC_HEADER      rfc;
    UChar           HeaderSize;
    X224_DISCONN    disconn;
} X224_DR_FIXED;

#define X224_SIZE_OFFSET		2

#define	UNK					0	// Used to initialize fields in static
								// data structures that will be initialized
								// later.

/* 2^DEFAULT_TPDU_SIZE is the default X224 packet size we request */
#define DEFAULT_TPDU_SIZE		13	/* 2^13 is 8K packet size */
#define	LOWEST_TPDU_SIZE		7	/* 2^7 is 128 bytes */
#define	HIGHEST_TPDU_SIZE		20	/* 2^20 is ... too big */
#define	DEFAULT_MAX_X224_SIZE	(1 << DEFAULT_TPDU_SIZE)

/* Function definitions */
TransportError	ConnectRequest (TransportAddress transport_address, BOOL fSecure, PTransportConnection pXprtConn);
BOOL			ConnectResponse (TransportConnection XprtConn);
void			DisconnectRequest (TransportConnection XprtConn, ULONG ulNotify);
TransportError	DataRequest (	TransportConnection	XprtConn,
								PSimplePacket	packet);
void 			SendX224ConnectRequest (TransportConnection);
void			EnableReceiver (Void);
void			PurgeRequest (TransportConnection	XprtConn);
void 			AcceptCall (TransportType);
void 			AcceptCall (TransportConnection);
void 			ReadRequest(TransportConnection);
void            ReadRequestEx(TransportConnection);
TransportError	FlushSendBuffer(PSocket pSocket, LPBYTE buffer, UINT length);
#ifdef TSTATUS_INDICATION
Void 			SendStatusMessage(	PChar RemoteAddress,
					  				TransportState state,
					  				UInt message_id);
#endif
void			QoSLock(Void);
void			QoSUnlock(Void);
void 			ShutdownAndClose (TransportConnection, BOOL fShutdown, int how );
TransportError 	GetLocalAddress(TransportConnection	XprtConn,
								TransportAddress	address,
								int	*	size);
								
/* The TCP message window procedure (processes all Windows messages) */
LRESULT 		WindowProcedure (HWND, UINT, WPARAM, LPARAM);

/* RFC definitions */
#define	RFC1006_VERSION_NUMBER		3
#define RFC1006_VERSION_SHIFTED_LEFT	0x03000000L		/* Optimizes AddRFCHeader */

/* Packet types */
#define	CONNECTION_REQUEST_PACKET	0xe0
#define	CONNECTION_CONFIRM_PACKET	0xd0
#define	DISCONNECT_REQUEST_PACKET	0x80
#define	ERROR_PACKET				0x70
#define	DATA_PACKET					0xf0

#define	TPDU_SIZE					0xc0
#define T_SELECTOR					0xc1
#define T_SELECTOR_2                                    0xc2
/* X224 definitions */
#define	EOT_BIT						0x80

/* Macro to fill-in RFC header at specified buffer location */
#define	AddRFCSize(ptr, size)	{ \
	ASSERT((size) < 65536L ); \
	((LPBYTE) (ptr))[X224_SIZE_OFFSET] = (BYTE) ((size) >> 8); \
	((LPBYTE) (ptr))[X224_SIZE_OFFSET + 1] = (BYTE) (size); }

#endif	/* _TRANSPORT_CONTROLLER_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\tptif.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);
/*
 *	tptif.cpp
 *
 *	Copyright (c) 1996-1997 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the implementation module for the TCP TransportInterface class.
 *		It implements the Win32 TCP transport stack.
 *		This file contains all of the public functions needed to use
 *		the TCP stack.
 *
 *		It uses owner callbacks to forward transport events upward to interested
 *		parties.  It has one default callback to handle
 *		events for unregistered transport connections (such as incoming connect
 *		indications).  It also maintains an array of callbacks so that events
 *		for a particular transport connection can be routed appropriately.
 *
 *		X.214 INTERFACE
 *	
 *		You will notice that many of the entry points to this DLL were taken
 *		from the X.214 service definition.  These entry points are consistent
 *		with the DataBeam Transport DLLs.  This gives the user application
 *		a consistent interface.
 *
 *  Protected Instance Variables:
 *		m_TrnsprtConnCallbackList2
 *			This is the dictionary containg the addresses of the callbacks for
 *			each transport connection.
 *
 *	Private Member Functions:
 *		CreateConnectionCallback
 *			This function creates a new entry in the callback list.
 *		ConnectIndication
 *			Handles TRANSPORT_CONNECT_INDICATION messages from the transport
 *			layer.
 *		ConnectConfirm
 *			Handles TRANSPORT_CONNECT_CONFIRM messages from the transport
 *			layer.
 *		DisconnectIndication
 *			Handles TRANSPORT_DISCONNECT_INDICATION messages from the transport
 *			layer.
 *		DataIndication
 *			Handles TRANSPORT_DATA_INDICATION messages from the transport
 *			layer.
 *
 *	Global Variables:
 *
 *	Transport					- Address of this object (used by tprtctrl.cpp)
 *	g_pSocketList    			- List of all active connection structures.
 *	Listen_Socket				- The listening socket number.
 *
 *	Caveats:
 *		This code is NOT portable.  It is very specific to the Windows
 *		operating system.
 *
 *	Author:
 *		Christos Tsollis
 */

/*
 *	External Interfaces
 */

#include <tprtntfy.h>
#include "plgxprt.h"
#include <service.h>

/* This is the number of the buckets for the socket dictionary */
#define NUMBER_OF_SOCKET_BUCKETS                8

PTransportInterface	g_Transport = NULL;
CSocketList        *g_pSocketList = NULL;   // key=socket_number, data=pSocket
SOCKET				Listen_Socket = INVALID_SOCKET;

// The external MCS Controller object
extern PController	g_pMCSController;
extern CPluggableTransport *g_pPluggableTransport;
extern BOOL g_bRDS;

/*
 *	TransportInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the class constructor.
 *
 *		Note that this version of the constructor is specific to 32-bit
 *		Windows.
 */
TransportInterface::TransportInterface (
		HANDLE						transport_transmit_event,
		PTransportInterfaceError	transport_interface_error) :
		Transport_Transmit_Event (transport_transmit_event),
		m_TrnsprtConnCallbackList2()
{
		TransportInterfaceError		tcp_error = TRANSPORT_INTERFACE_NO_ERROR;
		//WORD 						version_requested;
		//int							error;
		WSADATA						wsa_data;

	TRACE_OUT(("TCP Initialization..."));

    ASSERT(NULL == g_pSocketList);
	DBG_SAVE_FILE_LINE
	g_pSocketList = new CSocketList(NUMBER_OF_SOCKET_BUCKETS);
	if (g_pSocketList == NULL)
	{
		WARNING_OUT (("TransportInterface::TransportInterface:  Unable to allocate socket dictionary."));
		tcp_error = TRANSPORT_INTERFACE_INITIALIZATION_FAILED;
	}

	if (tcp_error == TRANSPORT_INTERFACE_NO_ERROR) {		
		/* WSAStartup() must be called to initialize WinSock */
		WORD version_requested = MAKEWORD (1,1);
		int error = WSAStartup (version_requested, &wsa_data);
		ASSERT(error == 0);
		if (error) {
			WARNING_OUT (("ThreadFunction: WSAStartup returned error %d", error));
			tcp_error = TRANSPORT_INTERFACE_INITIALIZATION_FAILED;
		}
		else {
			/* Print out the developer of this version of WinSock */
			TRACE_OUT (("TransportInterface::TransportInterface: WinSock implementation by %s", &wsa_data.szDescription));
		}
	}

    //
    // ALWAYS initialize security
    //
	DBG_SAVE_FILE_LINE
	pSecurityInterface = new SecurityInterface();

	if ( TPRTSEC_NOERROR != pSecurityInterface->Initialize())
	{
		WARNING_OUT(("Creating security interface failed!"));
		delete pSecurityInterface;
		pSecurityInterface = NULL;
	}

	/* Initialize the listen socket. This socket will wait for incoming calls */
	if (tcp_error == TRANSPORT_INTERFACE_NO_ERROR) {

    	// Listen on standard socket
	    Listen_Socket = CreateAndConfigureListenSocket();

	    if ( INVALID_SOCKET == Listen_Socket ) {
		    ERROR_OUT(("TransportInterface::TransportInterface: Error - could not initialize listen socket"));
   			tcp_error = TRANSPORT_INTERFACE_INITIALIZATION_FAILED;
    	}
	}

	*transport_interface_error = tcp_error;
}


void CloseListenSocket(void)
{
	if (Listen_Socket != INVALID_SOCKET)
    {
        TransportConnection XprtConn;
        SET_SOCKET_CONNECTION(XprtConn, Listen_Socket);
		::freeListenSocket(XprtConn);
		Listen_Socket = INVALID_SOCKET;
	}
}


/*
 *	~TransportInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the class destructor.  It unloads the DLL (if necessary).
 */
TransportInterface::~TransportInterface ()
{
    PSocket                     pSocket;

	TRACE_OUT (("Cleaning up the TCP transport..."));

	/* Delete all of the Logical Connection Structures */
    if (g_pSocketList != NULL)
	{
        ::EnterCriticalSection(&g_csTransport);
        CSocketList     Connection_List_Copy (*g_pSocketList);
        ::LeaveCriticalSection(&g_csTransport);

		while (NULL != (pSocket = Connection_List_Copy.Get()))
		{
		    // LONCHANC: cannot remove pSocket out of the list now
		    // because DisconnectRequest() uses it.

			/* Disconnect, trash packets, and delete the first connection in the list */
			::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_NONE);
		}

        ::EnterCriticalSection(&g_csTransport);
		delete g_pSocketList;
        g_pSocketList = NULL;
        ::LeaveCriticalSection(&g_csTransport);
	}

	/* Close the listening socket */
    ::CloseListenSocket();

	delete pSecurityInterface;

	/* Force Winsock to cleanup immediately */
	WSACleanup();
	
	TRACE_OUT (("TCP Transport has been cleaned up."));
	
}

/*
 *	TransportInterfaceError 	RegisterTransportConnection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is used to register a callback for a particular
 *		transport connection.  This will usually be done for incoming
 *		connections, when you know the transport connection handle BEFORE
 *		registering the callback.
 */
TransportInterfaceError TransportInterface::RegisterTransportConnection (
								TransportConnection		XprtConn,
								PConnection				owner_object,
								BOOL					bNoNagle)
{
	TransportInterfaceError 	return_value;

	/*
	 *	Check to see if the transport connection in question exists.  If
	 *	it does, then remove it and add it again with the new owner.
	 *	If not, fail the call.
	 */
	if (m_TrnsprtConnCallbackList2.RemoveEx(XprtConn))
	{
		/*
		 *	Get the address of the associated connection callback structure.
		 *	Then put the new callback information into it.
		 */
		TRACE_OUT (("TransportInterface::RegisterTransportConnection: "
				"registering new owner"));

        m_TrnsprtConnCallbackList2.AppendEx(owner_object ? owner_object : (PConnection) LPVOID_NULL, XprtConn);

        if (IS_SOCKET(XprtConn))
        {
    		if (bNoNagle)
    		{
    			// We need to disable the Nagle algorithm
    			TRACE_OUT(("TransportInterface::RegisterTransportConnection: disabling Nagle for socket (%d, %d)", 
    						XprtConn.eType, XprtConn.nLogicalHandle));
    			::setsockopt(XprtConn.nLogicalHandle, IPPROTO_TCP, TCP_NODELAY,
    						(const char *) &bNoNagle, sizeof(BOOL));
    		}
		}
		return_value = TRANSPORT_INTERFACE_NO_ERROR;
	}
	else
	{
		/*
		 *	There is no entry in the callback list for the specified transport
		 *	connection.  Since this function is only used to replace callback
		 *	information for existing connections, it is necessary to fail the
		 *	request.
		 */
		WARNING_OUT (("TransportInterface::RegisterTransportConnection: "
				"no such connection"));
		return_value = TRANSPORT_INTERFACE_NO_SUCH_CONNECTION;
	}

	return (return_value);
}

#ifdef NM_RESET_DEVICE
/*
 *	TransportError 	ResetDevice ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function merely makes the call to the transport DLL if the
 *		library was successfully loaded.
 */
TransportError 	TransportInterface::ResetDevice (
						PChar			device_identifier)
{
	PSocket pSocket;
	PChar 	Remote_Address;

    ::EnterCriticalSection(&g_csTransport);
    CSocketList     Connection_List_Copy (*g_pSocketList);
    ::LeaveCriticalSection(&g_csTransport);

	while (NULL != (pSocket = Connection_List_Copy.Get()))
	{
		Remote_Address = pSocket->Remote_Address;
		if(Remote_Address && (strcmp(Remote_Address, device_identifier) == 0))
		{
			::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
			break;
		}
	}

	return (TRANSPORT_NO_ERROR);
}
#endif // NM_RESET_DEVICE

/*
 *	TransportError 	ConnectRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		After checking to make sure that the library was loaded properly, this
 *		routine takes the steps required to create a new transport connection.
 */
TransportError 	TransportInterface::ConnectRequest (
					TransportAddress		transport_address,
					BOOL					fSecure,
					BOOL					bNoNagle,
					PConnection				owner_object,
					PTransportConnection	pXprtConn)
{
	TransportError 			return_value;
	TransportInterfaceError	transport_interface_error;

	TRACE_OUT (("TransportInterface::ConnectRequest"));
	/*
	 *	Issue a call to the Transport's ConnectRequest API routine.  Note that
	 *	this MUST be done first since one of the return values is the
	 *	transport connection handle of the newly created connection.
	 *	Also note that this is a non-blocking call, so what we have done
	 *	is begun the process of forming a connection.  The connection
	 *	cannot be used until a connect confirm is received.
	 */
	return_value = ::ConnectRequest(transport_address, fSecure, pXprtConn);
			
	if (return_value == TRANSPORT_NO_ERROR) {
		/*
		 *	If the call to create the connection was successful, then
		 *	put a new entry into the callback list.  This entry will
		 *	contain the callback information provided as parameters to
		 *	this routine.
		 */
		transport_interface_error = CreateConnectionCallback (
					*pXprtConn, owner_object);
        if (IS_SOCKET(*pXprtConn))
        {
    		if (bNoNagle)
    		{
    			// We need to disable the Nagle algorithm
    			TRACE_OUT(("TransportInterface::ConnectRequest: disabling Nagle for socket (%d, %d)", 
    						pXprtConn->eType, pXprtConn->nLogicalHandle));
    			::setsockopt(pXprtConn->nLogicalHandle, IPPROTO_TCP, TCP_NODELAY,
    						(const char *) &bNoNagle, sizeof(BOOL));
    		}

#ifdef DEBUG
		    if (TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS == 
			    transport_interface_error) {
			    /*
			     *	The transport connection handle returned from the
			     *	transport layer is the same as one we already have
			     *	listed.  We will therefore terminate the existing
			     *	connection (since its integrity appears to have been
			     *	compromised).  We will also fail this request.
			     */
			    WARNING_OUT (("DLLTransportInterface::ConnectRequest: "
						    "ERROR - duplicate connections"));

			    // This should NOT be happenning!!!
			    ASSERT (FALSE);

		    }
		    else {
			    /*
			     *	Everything worked fine, so do nothing.
			     */
			    TRACE_OUT (("DLLTransportInterface::ConnectRequest: "
						    "callback added to list"));
		    }
#endif // DEBUG
		}
	}
	else
	{
		/*
		 *	The call to TConnectRequest failed.  Report it and let the
		 *	error fall through.
		 */
		WARNING_OUT (("DLLTransportInterface::ConnectRequest: "
					"TConnectRequest failed"));
	}

	return (return_value);
}

/*
 *	void DisconnectRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is called to break an existing transport
 *		connection.  After checking to make sure that the transport connection
 *		is valid, it passes the call onto the DLL and removes the transport
 *		connection from the local callback list.
 */
void TransportInterface::DisconnectRequest (TransportConnection	transport_connection)
{
	TRACE_OUT (("TransportInterface::DisconnectRequest"));

	if (m_TrnsprtConnCallbackList2.RemoveEx(transport_connection))
    {
		::DisconnectRequest (transport_connection, TPRT_NOTIFY_NONE);
	}
	else
    {
		TRACE_OUT (("DLLTransportInterface::DisconnectRequest: the specified connection can not be found"));
	}
}

/*
 *	BOOL GetSecurity ()
 *
 *	Public
 *
 *	Functional Description:
 */
BOOL TransportInterface::GetSecurity (TransportConnection XprtConn)
{
	PSocket			pSocket;

	if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
	{
	    BOOL fRet = (pSocket->pSC != NULL);
	    pSocket->Release();
	    return fRet;
	}
	ERROR_OUT(("GetSecurity: could not find socket"));
	return FALSE; // Err on the safe side
}

/*
 *	Void ReceiveBufferAvailable ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void TransportInterface::ReceiveBufferAvailable ()
{		
	TRACE_OUT(("TransportInterface::ReceiveBufferAvailable"));

	// Reset the controller's wait info
	g_pMCSController->HandleTransportWaitUpdateIndication(FALSE);

    TReceiveBufferAvailable();

	// Poll all the transport connections
	EnableReceiver ();
}



/*
 *	Void	ConnectIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a connect indication from the
 *		transport layer.  Normally this involves putting a new entry in the
 *		callback list, and forwarding the connect indication to the default
 *		owner object.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the new connection.  This includes: the logical handle of the new
 *			connection; and the handle of the physical connection which will
 *			carry the new connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::ConnectIndication (
				TransportConnection	transport_connection)
{
	TransportInterfaceError		transport_interface_error;
	PConnection					pConnection;

	/*
	 *	Put the new connection into the callback list.
	 */
	transport_interface_error = CreateConnectionCallback (transport_connection,
														 NULL);

	switch (transport_interface_error)
	{
		case TRANSPORT_INTERFACE_NO_ERROR:
			/*
			 *	Everything worked fine, so do forward the indication to the
			 *	default owner object.
			 */
			TRACE_OUT (("DLLTransportInterface::ConnectIndication: "
					"calling ConnectResponse."));
			::ConnectResponse (transport_connection);
			break;

		case TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS:
			/*
			 *	The transport connection handle sent by the transport layer is
			 *	the same as one we already have listed.  We will therefore
			 *	terminate the existing connection (since its integrity appears
			 *	to have been compromised).
			 */
			WARNING_OUT (("DLLTransportInterface::ConnectIndication: "
					"ERROR - duplicate connections. Connection: %d", transport_connection));
			::DisconnectRequest (transport_connection, TPRT_NOTIFY_NONE);

			/*
			 *	Get the callback information for the previously existing
			 *	connection.  Then delete it.
			 */
			if (NULL != (pConnection = m_TrnsprtConnCallbackList2.RemoveEx(transport_connection)))
            {
                if (LPVOID_NULL != (LPVOID) pConnection)
                {
        			/*
        			 *	Let the former owner of the connection know that it has been
        			 *	terminated.
        			 */
			        ULONG ulReason = TPRT_NOTIFY_NONE;
			        pConnection->HandleDisconnectIndication(transport_connection, &ulReason);
                }
                else
                {
                    ERROR_OUT(("TransportInterface::ConnectIndication: null pConnection"));
                }
            }
			break;
	}
}

/*
 *	Void	ConnectConfirm ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a connect confirm frmo the
 *		transport layer.  Assuming that the connect confirm is the result of
 *		a previously outstanding connect request. everything will be processed
 *		normally, and the confirm will forwarded to the object that originated
 *		the request.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the connection being confirmed.  This includes: the logical handle
 *			of the connection; and the handle of the physical connection which
 *			is carrying the connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::ConnectConfirm (
				TransportConnection	transport_connection)
{
	PConnection			connection;

	/*
	 *	Since a connect confirm should only result from an earlier connect
	 *	request, the transport connection handle SHOULD already be in the
	 *	callback list.  If it is, then process this confirm normally.
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.FindEx(transport_connection)))
	{
		/*
		 *	Get the address of the callback structure from the Connection List.
		 *	Then invoke the callback, passing the message and parameter to it.
		 */
		TRACE_OUT (("DLLTransportInterface::ConnectConfirm: forwarding CONNECT_CONFIRM"));

		if (LPVOID_NULL != (LPVOID) connection)
        {
			// The owner is a Connection object.
			connection->HandleConnectConfirm(transport_connection);
		}
	}
	else
	{
		/*
		 *	This transport connection handle is invalid.  It is therefore
		 *	necessary to terminate the connection, and otherwise ignore the
		 *	confirm.
		 */
		WARNING_OUT (("DLLTransportInterface::ConnectConfirm: "
			"terminating unknown connection %d", transport_connection));
		// ::DisconnectRequest (transport_connection, TPRT_NOTIFY_NONE);
	}
}

/*
 *	Void	DisconnectIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a disconnect indication from the
 *		transport layer.  If the specified transport connection exists, it will
 *		be removed, and the object that owns it will be informed of the loss.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the connection being disconnected.  This includes: the logical
 *			handle of the connection; and the handle of the physical connection
 *			which carried the connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::DisconnectIndication (
				TransportConnection			transport_connection,
				ULONG                       ulReason)
{
	PConnection			connection;

	/*
	 *	It should only be possible to receive a disconnect on a transport
	 *	connection that we already know about.  Therefore, the transport
	 *	connection handle SHOULD already be in the list.  Check this.
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.RemoveEx(transport_connection)))
	{
		/*
		 *	Get the address of the callback structure from the callback list.
		 *	Then delete it from the list.
		 */
		TRACE_OUT (("DLLTransportInterface::DisconnectIndication: "
				"forwarding DISCONNECT_INDICATION"));

        if (LPVOID_NULL != (LPVOID) connection)
        {
			// The owner is a Connection object.
			connection->HandleDisconnectIndication(transport_connection, &ulReason);
		}
		else
        {
			// The owner is the MCS Controller
			g_pMCSController->HandleTransportDisconnectIndication(transport_connection, &ulReason);
		}
	}
	else
	{
		/*
		 *	We have received a disconnect indication on an unknown transport
		 *	connection.  Ignore it.
		 */
		WARNING_OUT (("DLLTransportInterface::DisconnectIndication: "
				"disconnect on unknown connection"));
	}
}

/*
 *	TransportError	DataIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a data indication from the
 *		transport layer.  If the transport connection is properly registered,
 *		the data will be forwarded to the object that owns the connection.
 *
 *	Formal Parameters:
 *		transport_data (i)
 *			This is the address of a structure that contains information about
 *			the data in the indication.  This includes what transport
 *			connection the data was received on, as well as the address and
 *			length of the data itself.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			This indicates that the data was processed.
 *		TRANSPORT_READ_QUEUE_FULL
 *			This means that the transport layer should try resending the data
 *			during the next heartbeat.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
TransportError	TransportInterface::DataIndication (PTransportData transport_data)
{
	PConnection				connection;
	TransportError			return_value = TRANSPORT_NO_ERROR;

	/*
	 *	If the transport connection is in the callback list, then send the
	 *	data to the registered callback.  If it is not in the Connection
	 *	List, then ignore the data (we have nowhere to send it).
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.FindEx(transport_data->transport_connection)))
	{
		if (LPVOID_NULL != (LPVOID) connection)
		{
			// The owner is a Connection object.
			return_value = connection->HandleDataIndication(transport_data, 
										transport_data->transport_connection);
		}
		else
		{
			// The owner is the MCS Controller
			g_pMCSController->HandleTransportDataIndication(transport_data);
		}

		/*
		 *	If we fail to deliver the data indication, we need to set the amount
		 *	of data available to be received and notify the controller to 
		 *	retry the operation later.
		 */		
		if (TRANSPORT_NO_ERROR != return_value)
		{
			g_pMCSController->HandleTransportWaitUpdateIndication(TRUE);
		}
	}
	else
	{
		/*
		 *	We have received data on an unknown transport connection.
		 *	Ignore the indication.
		 */
		WARNING_OUT (("TransportInterface::DataIndication: data on unknown connection"));
		return_value = TRANSPORT_NO_SUCH_CONNECTION;
	}
	
	return (return_value);
}

/*
 *	Void	BufferEmptyIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a buffer-empty indication from the
 *		transport layer.  If the specified transport connection exists, the object
 *		that owns it will be notified that it can proceed sending data on the 
 *		transport connection.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the connection.  This includes: the logical
 *			handle of the connection; and the handle of the physical connection
 *			which carried the connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::BufferEmptyIndication (
				TransportConnection			transport_connection)
{
	PConnection			connection;

	/*
	 *	It should only be possible to receive a disconnect on a transport
	 *	connection that we already know about.  Therefore, the transport
	 *	connection handle SHOULD already be in the list.  Check this.
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.FindEx(transport_connection)))
	{
		/*
		 *	Get the address of the callback structure from the callback list.
		 *	Then delete it from the list.
		 */
		TRACE_OUT(("DLLTransportInterface::BufferEmptyIndication: "
				"forwarding BUFFER_EMPTY_INDICATION"));
		
		/*
		 *	Forward the disconnect indication to the owner of this transport
		 *	connection.
		 */
		if (LPVOID_NULL != (LPVOID) connection)
        {
			connection->HandleBufferEmptyIndication(transport_connection);
        }
	}
	else
	{
		/*
		 *	We have received a buffer empty indication on an unknown transport
		 *	connection.  Ignore it.
		 */
		TRACE_OUT (("TransportInterface::BufferEmptyIndication: "
				"indication on unknown connection"));
	}
}

/*
 *	TransportInterfaceError 	CreateConnectionCallback ()
 *
 *	Protected
 *
 *	Functional Description:
 *		This private member function is used to create new entries in the
 *		callback list.  Each entry consists of a pointer to a structure that
 *		contains the address of the object that "owns" the transport connection,
 *		as well as the message index to be used for the owner callbacks.
 *
 *		This routine allocates the memory used to hold the callback information,
 *		and puts it in the callback list if everything is successful.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection for which the callback information
 *			is to be associated.
 *		owner_object (i)
 *			This is the address of the object that is to receive all transport
 *			layer events for the specified transport connection.
 *
 *	Return Value:
 *		TRANSPORT_INTERFACE_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS
 *			This value indicates that the request was unsuccessful because the
 *			specified transport connection already exists in the callback list
 *			(it is an error to try and create an entry for the same transport
 *			connection more than once).
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
TransportInterfaceError TransportInterface::CreateConnectionCallback (
								TransportConnection		transport_connection,
								PConnection				owner_object)
{
	TransportInterfaceError 	return_value;

	/*
	 *	See if there is already an entry in the callback list for the specified
	 *	transport connection.  If there is, then abort this request before
	 *	doing anything.
	 */
	if (m_TrnsprtConnCallbackList2.FindEx(transport_connection) == FALSE)
	{
		/*
		 *	Put the callback information into the newly allocated
		 *	structure.  Then put the structure into the callback list.
		 */
		TRACE_OUT (("TransportInterface::CreateConnectionCallback: "
					"adding new callback object"));

        m_TrnsprtConnCallbackList2.AppendEx(owner_object ? owner_object : (PConnection) LPVOID_NULL, transport_connection);

		return_value = TRANSPORT_INTERFACE_NO_ERROR;
	}
	else
	{
		/*
		 *	There is already an entry in the callback list for the specified
		 *	transport connection.  It is therefore necessary to fail this
		 *	request.
		 */
		WARNING_OUT (("TransportInterface::CreateConnectionCallback: "
				"callback already exists"));
		return_value = TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS;
	}

	return (return_value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\translat.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	translat.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Reason and Result Translator
 *		Class. 
 *
 *	Caveats:
 *		None. 
 *
 *	Author:
 *		jbo
 */


#include "pdutypes.h"
#include "translat.h"


/*
 *	TranslateGCCResultToCreateResult ()
 *
 *	Public Function Description:
 */
ConferenceCreateResult
TranslateGCCResultToCreateResult ( GCCResult gcc_result )
{
	ConferenceCreateResult	create_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		create_result = CCRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_USER_REJECTED:
		create_result = CCRS_USER_REJECTED;
		break;

	case GCC_RESULT_RESOURCES_UNAVAILABLE:
		create_result = RESOURCES_NOT_AVAILABLE;
		break;

	case GCC_RESULT_SYMMETRY_BROKEN:
		create_result = REJECTED_FOR_SYMMETRY_BREAKING;
		break;

	case GCC_RESULT_LOCKED_NOT_SUPPORTED:
		create_result = LOCKED_CONFERENCE_NOT_SUPPORTED;
		break;

	default:
		create_result = RESOURCES_NOT_AVAILABLE;
		break;
	}

	return (create_result);
}


/*
 *	TranslateGCCResultToQueryResult ()
 *
 *	Public Function Description:
 */
ConferenceQueryResult
TranslateGCCResultToQueryResult ( GCCResult gcc_result )
{
	ConferenceQueryResult	query_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		query_result = CQRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_USER_REJECTED:
		query_result = CQRS_USER_REJECTED;
		break;

	default:
		query_result = CQRS_USER_REJECTED;
		break;
	}

	return (query_result);
}


/*
 *	TranslateGCCResultToJoinResult ()
 *
 *	Public Function Description:
 */
ConferenceJoinResult
TranslateGCCResultToJoinResult ( GCCResult gcc_result )
{
	ConferenceJoinResult	join_result;

    switch (gcc_result)
    {
	case GCC_RESULT_SUCCESSFUL:
    	join_result = CJRS_RESULT_SUCCESS;
        break;

	case GCC_RESULT_USER_REJECTED:
    	join_result = CJRS_USER_REJECTED;
        break;

    case GCC_RESULT_INVALID_CONFERENCE:
    	join_result = INVALID_CONFERENCE;
        break;

    case GCC_RESULT_INVALID_PASSWORD:
    	join_result = INVALID_PASSWORD;
        break;

    case GCC_RESULT_INVALID_CONVENER_PASSWORD:
    	join_result = INVALID_CONVENER_PASSWORD;
    	break;

    case GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED:
    	join_result = CHALLENGE_RESPONSE_REQUIRED;
    	break;

    case GCC_RESULT_INVALID_CHALLENGE_RESPONSE:
    	join_result = INVALID_CHALLENGE_RESPONSE;
    	break;

    default:
    	join_result = INVALID_CONFERENCE;
    	break;
    }

    return (join_result);
}


/*
 *	TranslateGCCResultToInviteResult ()
 *
 *	Public Function Description:
 */
ConferenceInviteResult
TranslateGCCResultToInviteResult ( GCCResult gcc_result )
{
	ConferenceInviteResult	invite_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		invite_result = CIRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_USER_REJECTED:
		invite_result = CIRS_USER_REJECTED;
		break;

	default:
		invite_result = CIRS_USER_REJECTED;
		break;
	}

	return (invite_result);
}


/*
 *	TranslateGCCResultToRegistryResp ()
 *
 *	Public Function Description:
 */
RegistryResponseResult
TranslateGCCResultToRegistryResp ( GCCResult gcc_result )
{
	RegistryResponseResult			registry_response_result;

    switch (gcc_result)
    {
	case GCC_RESULT_SUCCESSFUL:
    	registry_response_result = RRRS_RESULT_SUCCESSFUL;
        break;

    case GCC_RESULT_INDEX_ALREADY_OWNED:
    	registry_response_result = BELONGS_TO_OTHER;
    	break;

    case GCC_RESULT_REGISTRY_FULL:
    	registry_response_result = TOO_MANY_ENTRIES;
        break;

    case GCC_RESULT_INCONSISTENT_TYPE:
    	registry_response_result = INCONSISTENT_TYPE;
        break;

    case GCC_RESULT_ENTRY_DOES_NOT_EXIST:
    	registry_response_result = ENTRY_NOT_FOUND;
        break;

    case GCC_RESULT_ENTRY_ALREADY_EXISTS:
    	registry_response_result = ENTRY_ALREADY_EXISTS;
        break;

    case GCC_RESULT_INVALID_REQUESTER:
		registry_response_result = RRRS_INVALID_REQUESTER;
        break;

    default:
		registry_response_result = RRRS_INVALID_REQUESTER;//jbo default???????
    	break;
    }

    return (registry_response_result);
}


/*
 *	TranslateCreateResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult 
TranslateCreateResultToGCCResult ( ConferenceCreateResult create_result )
{
	GCCResult	gcc_result;
  
	switch (create_result)
	{
	case CCRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CCRS_USER_REJECTED:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;

	case RESOURCES_NOT_AVAILABLE:
		gcc_result = GCC_RESULT_RESOURCES_UNAVAILABLE;
		break;

	case REJECTED_FOR_SYMMETRY_BREAKING:
		gcc_result = GCC_RESULT_SYMMETRY_BROKEN;
		break;

	case LOCKED_CONFERENCE_NOT_SUPPORTED:
		gcc_result = GCC_RESULT_LOCKED_NOT_SUPPORTED;
		break;

	default:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateQueryResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult 
TranslateQueryResultToGCCResult ( ConferenceQueryResult query_result )
{
	GCCResult	gcc_result;
  
	switch (query_result)
	{
	case CQRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CQRS_USER_REJECTED:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;

	default:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateJoinResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateJoinResultToGCCResult ( ConferenceJoinResult join_result )
{
	GCCResult	gcc_result;

    switch (join_result)
    {
	case CJRS_RESULT_SUCCESS:
    	gcc_result = GCC_RESULT_SUCCESSFUL;
        break;

    case CJRS_USER_REJECTED:
    	gcc_result = GCC_RESULT_USER_REJECTED;
        break;

    case INVALID_CONFERENCE:
		gcc_result = GCC_RESULT_INVALID_CONFERENCE;
        break;

    case INVALID_PASSWORD:
    	gcc_result = GCC_RESULT_INVALID_PASSWORD;
        break;

    case INVALID_CONVENER_PASSWORD:
    	gcc_result = GCC_RESULT_INVALID_CONVENER_PASSWORD;
    	break;

    case CHALLENGE_RESPONSE_REQUIRED:
    	gcc_result = GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED;
    	break;

    case INVALID_CHALLENGE_RESPONSE:
    	gcc_result = GCC_RESULT_INVALID_CHALLENGE_RESPONSE;
    	break;

    default:
    	gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
    	break;
    }

    return (gcc_result);
}


/*
 *	TranslateInviteResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateInviteResultToGCCResult ( ConferenceInviteResult invite_result )
{
	GCCResult	gcc_result;
  
	switch (invite_result)
	{
	case CIRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;
		
	case CIRS_USER_REJECTED:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;

	default:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateRegistryRespToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateRegistryRespToGCCResult ( RegistryResponseResult response_result )
{
	GCCResult 	gcc_result;
	
	switch (response_result)
    {
	case RRRS_RESULT_SUCCESSFUL:
		gcc_result = GCC_RESULT_SUCCESSFUL;
        break;

	case BELONGS_TO_OTHER:
		gcc_result = GCC_RESULT_INDEX_ALREADY_OWNED;
       	break;

	case TOO_MANY_ENTRIES:
		gcc_result = GCC_RESULT_REGISTRY_FULL;
        break;

	case INCONSISTENT_TYPE:
		gcc_result = GCC_RESULT_INCONSISTENT_TYPE;
    	break;

    case ENTRY_NOT_FOUND:
    	gcc_result = GCC_RESULT_ENTRY_DOES_NOT_EXIST;
        break;

    case ENTRY_ALREADY_EXISTS:
    	gcc_result = GCC_RESULT_ENTRY_ALREADY_EXISTS;
        break;

    case RRRS_INVALID_REQUESTER:
    	gcc_result = GCC_RESULT_INVALID_REQUESTER;
        break;

	default:
		gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;//jbo default ???????
		break;
     }

	return (gcc_result);
}


/*
 *	TranslateTerminateRqReasonToGCCReason ()
 *
 *	Public Function Description:
 */
GCCReason
TranslateTerminateRqReasonToGCCReason ( ConferenceTerminateRequestReason reason )
{
	GCCReason	gcc_reason;

	switch (reason)
	{
	case CTRQ_REASON_USER_INITIATED:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;

	case CTRQ_TIMED_CONFERENCE_TERMINATE:
		gcc_reason = GCC_REASON_TIMED_TERMINATION;
		break;

	default:
		gcc_reason = GCC_REASON_ERROR_TERMINATION;
		break;
	}

	return (gcc_reason);
}


/*
 *	TranslateGCCReasonToTerminateRqReason ()
 *
 *	Public Function Description:
 */
ConferenceTerminateRequestReason
TranslateGCCReasonToTerminateRqReason ( GCCReason gcc_reason )
{
	ConferenceTerminateRequestReason	reason;

	switch (gcc_reason)
	{
	case GCC_REASON_USER_INITIATED:
		reason = CTRQ_REASON_USER_INITIATED;
		break;

	case GCC_REASON_TIMED_TERMINATION:
		reason = CTRQ_TIMED_CONFERENCE_TERMINATE;
		break;

	default:
		reason = CTRQ_REASON_USER_INITIATED;
		break;
	}

	return (reason);
}


/*
 *	TranslateEjectIndReasonToGCCReason ()
 *
 *	Public Function Description:
 */
GCCReason
TranslateEjectIndReasonToGCCReason ( ConferenceEjectIndicationReason eject_reason )
{
	GCCReason	gcc_reason;

	switch (eject_reason)
	{
	case CEIN_USER_INITIATED:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;

	case HIGHER_NODE_DISCONNECTED:
		gcc_reason = GCC_REASON_HIGHER_NODE_DISCONNECTED;
		break;

	case HIGHER_NODE_EJECTED:
		gcc_reason = GCC_REASON_HIGHER_NODE_EJECTED;
		break;

	default:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;
	}

	return (gcc_reason);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
ConferenceEjectIndicationReason
TranslateGCCReasonToEjectInd ( GCCReason gcc_reason )
{
	ConferenceEjectIndicationReason	eject_reason;

	switch (gcc_reason)
	{
	case GCC_REASON_USER_INITIATED:
		eject_reason = CEIN_USER_INITIATED;
		break;

	case GCC_REASON_HIGHER_NODE_DISCONNECTED:
		eject_reason = HIGHER_NODE_DISCONNECTED;
		break;

	case GCC_REASON_HIGHER_NODE_EJECTED:
		eject_reason = HIGHER_NODE_EJECTED;
		break;

	default:
		eject_reason = CEIN_USER_INITIATED;
		break;
	}

	return (eject_reason);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateEjectResultToGCCResult ( ConferenceEjectResult eject_result )
{
	GCCResult	gcc_result;

	switch (eject_result)
	{
	case CERS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CERS_INVALID_REQUESTER:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;

	case CERS_INVALID_NODE:
		gcc_result = GCC_RESULT_INVALID_NODE;
		break;

	default:
		gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
ConferenceEjectResult
TranslateGCCResultToEjectResult ( GCCResult gcc_result )
{
	ConferenceEjectResult	eject_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		eject_result = CERS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		eject_result = CERS_INVALID_REQUESTER;
		break;

	case GCC_RESULT_INVALID_NODE:
		eject_result = CERS_INVALID_NODE;
		break;

	default:
		eject_result = CERS_INVALID_NODE;
		break;
	}

	return (eject_result);
}


/*
 *	TranslateTerminateInReasonToGCCReason ()
 *
 *	Public Function Description:
 */
GCCReason
TranslateTerminateInReasonToGCCReason ( ConferenceTerminateIndicationReason reason )
{
	GCCReason		gcc_reason;

	switch (reason)
	{
	case CTIN_REASON_USER_INITIATED:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;

	case CTIN_TIMED_CONFERENCE_TERMINATE:
		gcc_reason = GCC_REASON_TIMED_TERMINATION;
		break;

	default:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;
	}

	return (gcc_reason);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
ConferenceTerminateIndicationReason
TranslateGCCReasonToTerminateInReason ( GCCReason gcc_reason )
{
	ConferenceTerminateIndicationReason		reason;

	switch (gcc_reason)
	{
	case GCC_REASON_USER_INITIATED:
		reason = CTIN_REASON_USER_INITIATED;
		break;

	case GCC_REASON_TIMED_TERMINATION:
		reason = CTIN_TIMED_CONFERENCE_TERMINATE;
		break;

	default:
		reason = CTIN_REASON_USER_INITIATED;
		break;
	}

	return (reason);
}


/*
 *	TranslateGCCResultToTerminateResult ()
 *
 *	Public Function Description:
 */
ConferenceTerminateResult
TranslateGCCResultToTerminateResult ( GCCResult gcc_result )
{
	ConferenceTerminateResult	result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		result = CTRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		result = CTRS_INVALID_REQUESTER;
		break;

	default:
		result = CTRS_INVALID_REQUESTER;
		break;
	}

	return (result);
}


/*
 *	TranslateTerminateResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateTerminateResultToGCCResult ( ConferenceTerminateResult result )
{
	GCCResult	gcc_result;

	switch (result)
	{
	case CTRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CTRS_INVALID_REQUESTER:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;

	default:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateGCCResultToLockResult ()
 *
 *	Public Function Description:
 */
ConferenceLockResult
TranslateGCCResultToLockResult ( GCCResult gcc_result )
{
	ConferenceLockResult	return_value;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		return_value = CLRS_SUCCESS;
		break;

	case GCC_RESULT_CONFERENCE_ALREADY_LOCKED:
		return_value = CLRS_ALREADY_LOCKED;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		return_value = CLRS_INVALID_REQUESTER;
		break;

	default:
		return_value = CLRS_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateLockResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateLockResultToGCCResult ( ConferenceLockResult result )
{
	GCCResult	return_value;

	switch (result)
	{
	case CLRS_SUCCESS:
		return_value = GCC_RESULT_SUCCESSFUL;
		break;

	case CLRS_ALREADY_LOCKED:
		return_value = GCC_RESULT_CONFERENCE_ALREADY_LOCKED;
		break;

	case CLRS_INVALID_REQUESTER:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;

	default:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateGCCResultToUnlockResult ()
 *
 *	Public Function Description:
 */
ConferenceUnlockResult
TranslateGCCResultToUnlockResult ( GCCResult gcc_result )
{
	ConferenceUnlockResult	return_value;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		return_value = CURS_SUCCESS;
		break;

	case GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED:
		return_value = CURS_ALREADY_UNLOCKED;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		return_value = CURS_INVALID_REQUESTER;
		break;

	default:
		return_value = CURS_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateUnlockResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateUnlockResultToGCCResult ( ConferenceUnlockResult result )
{
	GCCResult		return_value;

	switch (result)
	{
	case CURS_SUCCESS:
		return_value = GCC_RESULT_SUCCESSFUL;
		break;

	case CURS_ALREADY_UNLOCKED:
		return_value = GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED;
		break;

	case CURS_INVALID_REQUESTER:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;

	default:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateGCCResultToAddResult ()
 *
 *	Public Function Description:
 */
ConferenceAddResult
TranslateGCCResultToAddResult ( GCCResult gcc_result )
{
	ConferenceAddResult	add_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		add_result = CARS_SUCCESS;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		add_result = CARS_INVALID_REQUESTER;
		break;

	case GCC_RESULT_INVALID_NETWORK_TYPE:
		add_result = INVALID_NETWORK_TYPE;
		break;

	case GCC_RESULT_INVALID_NETWORK_ADDRESS:
		add_result = INVALID_NETWORK_ADDRESS;
		break;

	case GCC_RESULT_ADDED_NODE_BUSY:
		add_result = ADDED_NODE_BUSY;
		break;

	case GCC_RESULT_NETWORK_BUSY:
		add_result = NETWORK_BUSY;
		break;

	case GCC_RESULT_NO_PORTS_AVAILABLE:
		add_result = NO_PORTS_AVAILABLE;
		break;

	case GCC_RESULT_CONNECTION_UNSUCCESSFUL:
		add_result = CONNECTION_UNSUCCESSFUL;
		break;

	default:
		add_result = CARS_INVALID_REQUESTER;
		break;
	}

	return (add_result);
}


/*
 *	TranslateAddResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateAddResultToGCCResult ( ConferenceAddResult add_result )
{
	GCCResult	gcc_result;

	switch (add_result)
	{
	case CARS_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CARS_INVALID_REQUESTER:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;

	case INVALID_NETWORK_TYPE:
		gcc_result = GCC_RESULT_INVALID_NETWORK_TYPE;
		break;

	case INVALID_NETWORK_ADDRESS:
		gcc_result = GCC_RESULT_INVALID_NETWORK_ADDRESS;
		break;

	case ADDED_NODE_BUSY:
		gcc_result = GCC_RESULT_ADDED_NODE_BUSY;
		break;

	case NETWORK_BUSY:
		gcc_result = GCC_RESULT_NETWORK_BUSY;
		break;

	case NO_PORTS_AVAILABLE:
		gcc_result = GCC_RESULT_NO_PORTS_AVAILABLE;
		break;

	case CONNECTION_UNSUCCESSFUL:
		gcc_result = GCC_RESULT_CONNECTION_UNSUCCESSFUL;
		break;

	default:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return (gcc_result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\userdata.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);

/* 
 *	userdata.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CUserDataListContainer. CUserDataListContainer
 *		objects are used to maintain user data elements. A user data element
 *		consists of an Object Key and an optional octet string.  The Object
 *		Key data is maintained internally by this class by using an
 *		CObjectKeyContainer container.  The optional octet string data is maintained
 *		internally through the use of a Rogue Wave string container.
 *
 *	Protected Instance Variables:
 *		m_UserDataItemList
 *			List of structures used to hold the user data internally.
 *		m_pSetOfUserDataPDU
 *			Storage for the "PDU" form of the user data.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCUserData structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "userdata.h"
#include "clists.h"

USER_DATA::~USER_DATA(void)
{
	if (NULL != key)
    {
        key->Release();
    }
	delete poszOctetString;
}

/*
 *	CUserDataListContainer()
 *
 *	Public Function Description
 *		This CUserDataListContainer constructor is used to create a CUserDataListContainer object
 *		from "API" data.  The constructor immediately copies the user data 
 *		passed in as a list of "GCCUserData" structures into it's internal form
 *		where a Rogue Wave container holds the data in the form of 
 *		USER_DATA structures.
 */
CUserDataListContainer::
CUserDataListContainer(UINT cMembers, PGCCUserData *user_data_list, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('U','r','D','L')),
    m_UserDataItemList(DESIRED_MAX_USER_DATA_ITEMS),
    m_cbDataSize(0),
    m_pSetOfUserDataPDU(NULL)
{
	/*
	 * Copy the user data into the internal structures.
	 */
	*pRetCode = CopyUserDataList(cMembers, user_data_list);
}

/*
 *	CUserDataListContainer()
 *
 *	Public Function Description
 *		This CUserDataListContainer constructor is used to create a CUserDataListContainer object 
 *		from data passed in as a "PDU" SetOfUserData structure.  The user
 *		data is copied into it's internal form where a Rogue Wave container 
 *		holds the data in the form of USER_DATA structures.
 */
CUserDataListContainer::
CUserDataListContainer(PSetOfUserData set_of_user_data, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('U','r','D','L')),
    m_UserDataItemList(DESIRED_MAX_USER_DATA_ITEMS),
    m_cbDataSize(0),
    m_pSetOfUserDataPDU(NULL)
{
	/*
	 * Copy the user data into the internal structures.
	 */
	*pRetCode = UnPackUserDataFromPDU(set_of_user_data);
}

/*
 *	CUserDataListContainer()
 *
 *	Public Function Description
 *		This CUserDataListContainer copy constructor is used to create a CUserDataListContainer 
 *		object from	another CUserDataListContainer object.  The constructor immediately
 *		copies the user data passed in into it's internal form where a Rogue 
 *		Wave list holds the data in the form of USER_DATA structures.
 */
CUserDataListContainer::
CUserDataListContainer(CUserDataListContainer *user_data_list, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('U','r','D','L')),
    m_UserDataItemList(DESIRED_MAX_USER_DATA_ITEMS),
    m_cbDataSize(0),
    m_pSetOfUserDataPDU(NULL)
{
	GCCError		rc;
	USER_DATA       *user_data_info_ptr;
	USER_DATA       *lpUsrDataInfo;

	/*
	 * Set up an iterator for the internal list of "info" structures in the
	 * CUserDataListContainer object to be copied.
	 */
	user_data_list->m_UserDataItemList.Reset();

	/*
	 * Copy each USER_DATA structure contained in the CUserDataListContainer object to
	 * be copied.
	 */
	while (NULL != (lpUsrDataInfo = user_data_list->m_UserDataItemList.Iterate()))
	{
		/*
		 * Create a new USER_DATA structure to hold each element of the new
		 * CUserDataListContainer object.  Report an error if creation of this structure
		 * fails.
		 */
		DBG_SAVE_FILE_LINE
		user_data_info_ptr = new USER_DATA;
		if (user_data_info_ptr != NULL)
		{
		    user_data_info_ptr->poszOctetString = NULL;

			/*
			 * Go ahead and insert the pointer to the USER_DATA structure
			 * into the internal Rogue Wave list.
			 */
			m_UserDataItemList.Append(user_data_info_ptr);

			/*
			 * Create a new CObjectKeyContainer object to hold the "key" using the 
			 * copy constructor for the CObjectKeyContainer class.  Check to be sure
			 * construction of the object is successful.  Note that validation
			 * of the object key data is not done here since this would be done
			 * when the original CUserDataListContainer object was created.
			 */
    		DBG_SAVE_FILE_LINE
			user_data_info_ptr->key = new CObjectKeyContainer(lpUsrDataInfo->key, &rc);
			if ((NULL != user_data_info_ptr->key) && (GCC_NO_ERROR == rc))
			{
    			/*
    			 * If an octet string exists, create a new Rogue Wave string to hold
    			 * the octet string portion	of the "key" and copy the octet string 
    			 * from the old CUserDataListContainer object into the new USER_DATA 
    			 * structure.
    			 */
    			if (lpUsrDataInfo->poszOctetString != NULL)
    			{
    				if (NULL == (user_data_info_ptr->poszOctetString =
    									::My_strdupO(lpUsrDataInfo->poszOctetString)))
    				{
    					ERROR_OUT(("UserData::UserData: can't create octet string"));
    					rc = GCC_ALLOCATION_FAILURE;
    					goto MyExit;
    				}
    			}
    			else
    			{
    				ASSERT(NULL == user_data_info_ptr->poszOctetString);
    			}
			}
            else
			{
				ERROR_OUT(("UserData::UserData: Error creating new ObjectKeyData"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
		}
		else
		{
			ERROR_OUT(("UserData::UserData: can't create USER_DATA"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
	}

    rc = GCC_NO_ERROR;

MyExit:

    *pRetCode = rc;
}

/*
 *	~CUserDataListContainer()
 *
 *	Public Function Description
 *		This is the destructor for the CUserDataListContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 */
CUserDataListContainer::
~CUserDataListContainer(void)
{
	/*
	 * Free any PDU data which may have not been freed.
	 */
	if (m_pSetOfUserDataPDU)
    {
		FreeUserDataListPDU();
    }

	/*
	 * Set up an iterator to use for iterating through the internal Rogue
	 * Wave list of USER_DATA structures.
	 */
	USER_DATA  *pUserDataItem;
	m_UserDataItemList.Reset();
	while (NULL != (pUserDataItem = m_UserDataItemList.Iterate()))
	{
		/*
		 * Delete any memory being referenced in the USER_DATA structure.
		 */
		delete pUserDataItem;
	}
}


/*
 *	LockUserDataList ()
 *
 *	Public Function Description:
 *		This routine locks the user data list and determines the amount of
 *		memory referenced by the "API" user data list structures.
 */
UINT CUserDataListContainer::
LockUserDataList(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data.  Otherwise, just increment the 
	 * lock count.
	 */
	if (Lock() == 1)
	{
		USER_DATA *lpUsrDataInfo;
		/*
		 * Set aside memory to hold the pointers to the GCCUserData structures
		 * as well as the structures themselves.  The "sizeof" the structure 
		 * must be rounded to an even four-byte boundary.
		 */
		m_cbDataSize = m_UserDataItemList.GetCount() * 
				(sizeof(PGCCUserData) + ROUNDTOBOUNDARY(sizeof(GCCUserData)) );

		m_UserDataItemList.Reset();
	 	while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
		{
			/*
			 * Lock the data for the object keys, adding the amount of memory
			 * necessary to hold the object key data to the total memory size.
			 */
			m_cbDataSize += lpUsrDataInfo->key->LockObjectKeyData();

			/*
			 * Check to see if this user data element contains the optional
			 * user data octet string.  Add the space to hold it if it exists.
			 */
			if (lpUsrDataInfo->poszOctetString != NULL)
			{
				/*
				 * Since the user data structure contains a pointer to a
				 * OSTR structure, we must add the amount of memory
				 * needed to hold the structure as well as the string data.
				 */
				m_cbDataSize += ROUNDTOBOUNDARY(sizeof(OSTR));

				/*
				 * The data referenced by the octet string is just the byte
				 * length of the octet string.
				 */
				m_cbDataSize += ROUNDTOBOUNDARY(lpUsrDataInfo->poszOctetString->length);
			}
		}
	}

	return m_cbDataSize;
}

/*
 *	GetUserDataList	()
 *
 *	Public Function Description:
 *		This routine retrieves user data elements contained in the user data
 *		object and returns them in the "API" form of a list of pointers to 
 *		"GCCUserData" structures.  The number of user data elements contained 
 *		in this object is also returned.
 */
UINT CUserDataListContainer::
GetUserDataList(USHORT *number_of_members, PGCCUserData **user_data_list, LPBYTE memory)
{
	UINT			cbDataSizeToRet = 0;
	UINT			data_length = 0;
	Int				user_data_counter = 0;
	PGCCUserData	user_data_ptr;
	
	/*
	 * If the user data has been locked, fill in the output parameters and
	 * the data referenced by the pointers.  Otherwise, report that the object
	 * has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		USER_DATA  *lpUsrDataInfo;
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the number of user data entities and save a pointer to the 
		 * memory location passed in.  This is where the pointers to the 
		 * GCCUserData structures will be written.  The actual structures will 
		 * be written into memory immediately following the list of pointers.
		 */
		*number_of_members = (USHORT) m_UserDataItemList.GetCount();

		*user_data_list = (PGCCUserData *)memory;

		/*
		 * Save the amount of memory needed to hold the list of pointers
		 * as well as the actual user data structures.
		 */
		data_length = m_UserDataItemList.GetCount() * sizeof(PGCCUserData);

		/*
		 * Move the memory pointer past the list of user data pointers.  This 
		 * is where the first user data structure will be written.
		 */
		memory += data_length;

		/*
		 * Iterate through the internal list of USER_DATA structures,
		 * building "API" GCCUserData structures in memory.
		 */
		m_UserDataItemList.Reset();
		while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
		{
			/*
			 * Save the pointer to the user data structure in the list 
			 * of pointers.
			 */
			user_data_ptr = (PGCCUserData)memory;
			(*user_data_list)[user_data_counter++] = user_data_ptr;

			/*
			 * Move the memory pointer past the user data structure.  This is 
			 * where the object key data and octet string data will be written.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCUserData));

			/*
			 * Fill in the user data structure starting with the object key.
			 */
			data_length = lpUsrDataInfo->key->GetGCCObjectKeyData(&user_data_ptr->key, memory);

			/*
			 * Move the memory pointer past the object key data.  This is 
			 * where the octet string structure will be written, if it exists.
			 * If the octet string does exist, save the memory pointer in the 
			 * user data structure's octet string pointer and fill in the 
			 * elements of the octet string structure.  Otherwise, set the
			 * octet string pointer to NULL.
			 */
			memory += data_length;

			if (lpUsrDataInfo->poszOctetString == NULL)
            {
				user_data_ptr->octet_string = NULL;
            }
			else
			{
				user_data_ptr->octet_string = (LPOSTR) memory;

				/*
				 * Move the memory pointer past the octet string structure.  
				 * This is where the actual string data for the octet string 
				 * will be written.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(OSTR));

				/*
				 * Write the octet string data into memory and set the octet 
				 * string structure pointer and length.
				 */
				user_data_ptr->octet_string->length =
					lpUsrDataInfo->poszOctetString->length;
				user_data_ptr->octet_string->value = (LPBYTE)memory;

				/*
				 * Now copy the octet string data from the internal Rogue Wave
				 * string into the object key structure held in memory.
				 */		
				::CopyMemory(memory, lpUsrDataInfo->poszOctetString->value,
							lpUsrDataInfo->poszOctetString->length);

				/*
				 * Move the memory pointer past the octet string data.
				 */
				memory += ROUNDTOBOUNDARY(user_data_ptr->octet_string->length);
			}
		}
	}
	else
	{
    	*user_data_list = NULL;
		*number_of_members = 0;
		ERROR_OUT(("CUserDataListContainer::GetUserDataList: Error Data Not Locked"));
	}
	
	return cbDataSizeToRet;
}

/*
 *	UnLockUserDataList	()
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeUserDataList.  If so, the object will automatically delete
 *		itself.
 */
void CUserDataListContainer::
UnLockUserDataList(void)
{
	USER_DATA  *user_data_info_ptr;

	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock any memory locked for the CObjectKeyContainer objects in the
		 * internal USER_DATA structures.
		 */
		m_UserDataItemList.Reset();
		while (NULL != (user_data_info_ptr = m_UserDataItemList.Iterate()))
		{
			/*
			 * Unlock any CObjectKeyContainer memory being referenced in the 
			 * USER_DATA structure.
			 */
			if (user_data_info_ptr->key != NULL)
			{
				user_data_info_ptr->key->UnLockObjectKeyData ();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetUserDataPDU	()
 *
 *	Public Function Description:
 *		This routine converts the user data from it's internal form of a list
 *		of USER_DATA structures into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "SetOfUserData" structure is 
 *		returned.
 */
GCCError CUserDataListContainer::
GetUserDataPDU(PSetOfUserData *set_of_user_data)
{
	GCCError				rc = GCC_NO_ERROR;
	PSetOfUserData			new_pdu_user_data_ptr;
	PSetOfUserData			old_pdu_user_data_ptr = NULL;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (NULL == m_pSetOfUserDataPDU)
	{
		USER_DATA  *lpUsrDataInfo;

		/*
		 * Iterate through the list of USER_DATA structures, converting 
		 * each into "PDU" form and saving the pointers in the linked list of 
		 * "SetsOfUserData".
		 */
		m_UserDataItemList.Reset();
		while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_pdu_user_data_ptr = new SetOfUserData;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_pdu_user_data_ptr == NULL)
			{
				ERROR_OUT(("CUserDataListContainer::GetUserDataPDU: Allocation error, cleaning up"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}

			//
			// Ensure everything is clean.
			//
			::ZeroMemory(new_pdu_user_data_ptr, sizeof(SetOfUserData));

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfUserData created.  On subsequent loops, set
			 * the structure's "next" pointer equal to the new structure.
			 */
			if (m_pSetOfUserDataPDU == NULL)
			{
				m_pSetOfUserDataPDU = new_pdu_user_data_ptr;
			}
			else
            {
				old_pdu_user_data_ptr->next = new_pdu_user_data_ptr;
            }

			old_pdu_user_data_ptr = new_pdu_user_data_ptr;

			/*
			 * Initialize the new "next" pointer to NULL and convert the
			 * user data element.
			 */
			new_pdu_user_data_ptr->next = NULL;

			if (ConvertUserDataInfoToPDUUserData(lpUsrDataInfo, new_pdu_user_data_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("UserData::GetUserDataPDU: can't convert USER_DATA to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}

		if (GCC_NO_ERROR != rc)
		{
			FreeUserDataListPDU();
			ASSERT(NULL == m_pSetOfUserDataPDU);
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*set_of_user_data = m_pSetOfUserDataPDU;

	return rc;
}

/*
 *	FreeUserDataListPDU	()
 *
 *	Public Function Description:
 *		This routine frees any data which was allocated as a result of a call
 *		to "GetUserDataPDU" which was called in order to build up a "PDU"
 *		structure holding the user data.
 */
void CUserDataListContainer::
FreeUserDataListPDU(void)
{
	PSetOfUserData		pdu_user_data_set;
	PSetOfUserData		next_pdu_user_data_set;
	USER_DATA           *lpUsrDataInfo;

	/*
	 * Check to make sure "PDU" data has been allocated for this object.
	 */
	if (NULL != m_pSetOfUserDataPDU)
	{
		pdu_user_data_set = m_pSetOfUserDataPDU;
        m_pSetOfUserDataPDU = NULL; // so no one can use it now.

		/*
		 * Loop through the list, freeing the user data associated with 
		 * each structure contained in the list.
		 */
		while (pdu_user_data_set != NULL)
		{
			next_pdu_user_data_set = pdu_user_data_set->next;
			delete pdu_user_data_set;
			pdu_user_data_set = next_pdu_user_data_set;
		}
	}
	else
	{
		TRACE_OUT(("CUserDataListContainer::FreeUserDataListPDU: Error PDU data not allocated"));
	}

	/*
	 * Iterate through the internal list, telling each CObjectKeyContainer object
	 * to free any PDU data which it has allocated.
	 */
	m_UserDataItemList.Reset();
	while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
	{
		if (lpUsrDataInfo->key != NULL)
        {
			lpUsrDataInfo->key->FreeObjectKeyDataPDU();
        }
	}
}

/*
 *	GCCError	CopyUserDataList ( 	UINT					number_of_members,
 *									PGCCUserData	*		user_data_list)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine copies the user data passed in as "API" data into it's
 *		internal form where the Rogue Wave m_UserDataItemList holds the data
 *		in the form of USER_DATA structures.
 *
 *	Formal Parameters:
 *		number_of_members	(i) The number of elements in the user data list.
 *		user_datalist		(i)	The list holding the user data to store.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
CopyUserDataList(UINT number_of_members, PGCCUserData *user_data_list)
{
	GCCError				rc = GCC_NO_ERROR;
	USER_DATA			    *user_data_info_ptr;
	UINT					i;
	LPOSTR      			octet_string_ptr;

	/*
	 * Return an error if no user data is passed in.
	 */
	if (number_of_members == 0)
		return (GCC_BAD_USER_DATA);

	for (i = 0; i < number_of_members; i++)
	{
		/*
		 * Create a new "info" structure to hold the user data internally.
		 */
		DBG_SAVE_FILE_LINE
		user_data_info_ptr = new USER_DATA;
		if (user_data_info_ptr != NULL)
		{
		    user_data_info_ptr->poszOctetString = NULL;

			/*
			 * Create a new CObjectKeyContainer object which will be used to store
			 * the "key" portion of the object data internally.
			 */
    		DBG_SAVE_FILE_LINE
			user_data_info_ptr->key = new CObjectKeyContainer(&user_data_list[i]->key, &rc);
			if (user_data_info_ptr->key == NULL)
			{
				ERROR_OUT(("UserData::CopyUserDataList: Error creating new CObjectKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
			else if (rc != GCC_NO_ERROR)
			{
				ERROR_OUT(("UserData::CopyUserDataList: Error creating new CObjectKeyContainer - bad data"));
				goto MyExit;
    		}

			/*
			 * Store the optional user data octet string in the list.
			 */
			octet_string_ptr = user_data_list[i]->octet_string;

			if ((octet_string_ptr != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * Create a new Rogue Wave string container to hold the
				 * octet string.
				 */
				if (NULL == (user_data_info_ptr->poszOctetString = ::My_strdupO2(
									octet_string_ptr->value,
									octet_string_ptr->length)))
				{	
					ERROR_OUT(("UserData::CopyUserDataList: can't create octet string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
			{
				ASSERT(NULL == user_data_info_ptr->poszOctetString);
			}
		}
		else
		{
			ERROR_OUT(("UserData::CopyUserDataList: can't create USER_DATA"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		/*
		 * Insert the pointer to the USER_DATA structure into the Rogue Wave list.
		 */
		m_UserDataItemList.Append(user_data_info_ptr);
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete user_data_info_ptr;
    }

	return rc;
}

/*
 *	GCCError	UnPackUserDataFromPDU (PSetOfUserData		set_of_user_data)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine unpacks the user data from the "PDU" form into the
 *		internal form which is maintained as a Rogue Wave list of USER_DATA
 *		structures.
 *
 *	Formal Parameters:
 *		set_of_user_data	(i) The "PDU" user data list to copy.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
UnPackUserDataFromPDU(PSetOfUserData set_of_user_data)
{
	PSetOfUserData		pUserData;
	GCCError			rc = GCC_NO_ERROR;

    for (pUserData = set_of_user_data; NULL != pUserData; pUserData = pUserData->next)
	{ 
		/*
		 * Convert the user data elements into the internal format which
		 * is a USER_DATA structure and insert the pointers to the 
		 * USER_DATA structures into the m_UserDataItemList.
		 */  
		if (ConvertPDUDataToInternal(pUserData) != GCC_NO_ERROR)
		{
			ERROR_OUT(("CUserDataListContainer::UnPackUserDataFromPDU: Error converting PDU data to internal"));
			rc = GCC_ALLOCATION_FAILURE;
			break;
		}
	}

	return rc;
}

/*
 *	GCCError	ConvertPDUDataToInternal ( PSetOfUserData		user_data_ptr)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine converts an individual user data element from the "PDU" 
 *		structure form into	the internal form which is a USER_DATA	
 *		structure.
 *
 *	Formal Parameters:
 *		user_data_ptr		(i) The "PDU" user data list to copy.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
ConvertPDUDataToInternal(PSetOfUserData user_data_ptr)
{
	USER_DATA   		*user_data_info_ptr;
	GCCError			rc = GCC_NO_ERROR;

	DBG_SAVE_FILE_LINE
	user_data_info_ptr = new USER_DATA;
	if (user_data_info_ptr != NULL)
	{
	    user_data_info_ptr->poszOctetString = NULL;

		/*
		 * Create a new CObjectKeyContainer object which will be used to store the
		 * "key" portion of the user data internally.  If an error occurs
		 * constructing the key report it.  Otherwise, check for any user data
		 * which may need to be stored.	 Note that any error in creating the 
		 * CObjectKeyContainer object is reported as an allocation failure.  An error
		 * could occur if a bad object	key was received as PDU data but this 
		 * would have originated from some other provider since we validate all
		 * object keys created locally.  We therefore report it as an allocation
		 * failure.
		 */
		DBG_SAVE_FILE_LINE
		user_data_info_ptr->key = new CObjectKeyContainer(&user_data_ptr->user_data_element.key, &rc);
		if ((user_data_info_ptr->key == NULL) || (rc != GCC_NO_ERROR))
		{
			ERROR_OUT(("UserData::ConvertPDUDataToInternal: Error creating new CObjectKeyContainer"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
		else
		{
			/*
			 * The object key was successfully saved so store any actual user 
			 * data in the list if it is present.
			 */
			if (user_data_ptr->user_data_element.bit_mask & USER_DATA_FIELD_PRESENT)
			{
				if (NULL == (user_data_info_ptr->poszOctetString = ::My_strdupO2(
								user_data_ptr->user_data_element.user_data_field.value,
								user_data_ptr->user_data_element.user_data_field.length)))
				{	
					ERROR_OUT(("UserData::ConvertPDUDataToInternal: can't create octet string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
			{
				ASSERT(NULL == user_data_info_ptr->poszOctetString);
			}
		}

		/*
		 * Initialize the structure pointers to NULL and insert the pointer
		 * to the USER_DATA structure into the Rogue Wave list.
		 */
		m_UserDataItemList.Append(user_data_info_ptr);
	}
	else
	{
		ERROR_OUT(("UserData::ConvertPDUDataToInternal: can't create USER_DATA"));
		rc = GCC_ALLOCATION_FAILURE;
		// goto MyExit;
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete user_data_info_ptr;
    }

	return rc;
}

/*
 *	GCCError	ConvertUserDataInfoToPDUUserData (	
 *									USER_DATA		*user_data_info_ptr,
 *									PSetOfUserData		pdu_user_data_ptr)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine converts the user data from the internal form which is a 
 *		USER_DATA structure into the "PDU" structure form "SetOfUserData".
 *
 *	Formal Parameters:
 *		user_data_info_ptr	(i) The internal user data structure to convert.
 *		pdu_user_data_ptr	(o)	The structure to hold the PDU data after
 *									conversion.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	The internal key pointer was
 *												corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
ConvertUserDataInfoToPDUUserData(USER_DATA *user_data_info_ptr, PSetOfUserData pdu_user_data_ptr)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Initialize the user data bit mask to zero.
	 */
	pdu_user_data_ptr->user_data_element.bit_mask = 0;

	/*
	 * Fill in the octet string pointer and length if the octet string 
	 * exists.  Set the bit mask indicating that the string exists.
	 */
	if (user_data_info_ptr->poszOctetString != NULL)
	{
		pdu_user_data_ptr->user_data_element.user_data_field.value =
				user_data_info_ptr->poszOctetString->value;
		pdu_user_data_ptr->user_data_element.user_data_field.length =
				user_data_info_ptr->poszOctetString->length;

		pdu_user_data_ptr->user_data_element.bit_mask |= USER_DATA_FIELD_PRESENT;
	}
	
	/*
	 * Fill in the object key data.
	 */
	if (user_data_info_ptr->key != NULL)
	{
		/*
		 * Retrieve the "PDU" object key data from the internal CObjectKeyContainer
		 * object.
		 */
		if (user_data_info_ptr->key->GetObjectKeyDataPDU (
				&pdu_user_data_ptr->user_data_element.key) != GCC_NO_ERROR)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("UserData::ConvertUserDataInfoToPDUUserData: no valid UserDataInfo key"));
		rc = GCC_INVALID_PARAMETER;
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icshelper\icshelp.c ===
// ICSHelp.c : Implementation of DLL Exports.


#include <windows.h>


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
    }

    return TRUE;    // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\user.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	user.cpp
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the User class.  Objects of this
 *		class represent the attachment between a user application and an MCS
 *		domain.  It "talks" to the application through an application interface
 *		object, which is identified to it as a constructor parameter.  Since
 *		this class inherits from CommandTarget, it can talk to the domain
 *		object using the MCS command language defined therein.  The domain
 *		object to which it must attach is another constructor parameter.
 *
 *		When one of these objects is first created, it must register its
 *		presence with both the application interface object above it, and the
 *		domain object below it.  To register with the application interface
 *		object it sends it a registration message through the owner callback.
 *		To register with the domain object, it issues an attach user request
 *		on behalf of the application that created this attachment.
 *
 *		This module contains code to perform three different tasks: accept
 *		T.122 requests and responses from the user application and forward them
 *		to the domain as MCS commands; accept MCS commands from the domain and
 *		forward them to the application as T.122 primitives; and buffer those
 *		indications and confirms until the controller allocates a time slice in
 *		which to send them.
 *
 *		T.122 requests and responses come from the application interface as
 *		public member functions whose name is prefixed with "MCS" (for example,
 *		"MCSChannelJoinRequest").  After validation, the equivalent MCS command
 *		(whose name does NOT begin with "MCS") is sent to the domain object.
 *
 *		MCS commands come from the domain object as public member functions that
 *		are inherited from CommandTarget and overridden by this class.  The
 *		names of these functions are NOT prefixed with "MCS".  Any MCS commands
 *		that do not map to (or can be converted to) T.122 primitives are simply
 *		not overridden.  The default behavior of these functions ,as defined in
 *		the CommandTarget class, is to return an error.
 *
 *		Indication and confirm primitives are buffered by objects of this class
 *		before being sent to the application.  This allows the controller more
 *		flexibility in the timing of events in the system.  This is done by
 *		allocating a structure to hold the information associated with the
 *		primitive, and then putting a pointer to that structure into a linked
 *		list.  When the command comes to flush this message queue, the
 *		primitives are sent to the application interface object through the
 *		owner callback, and the structures are released.
 *
 *	Private Instance Variables:
 *		m_pDomain
 *			This is a pointer to the domain, to which this user is (or wishes
 *			to be) attached.
 *		User_ID
 *			This is the user ID assigned to this user attachment.  This is
 *			guaranteed to be unique ONLY within this domain.  Note that a value
 *			of 0 (zero) indicates that this user is not yet attached to the
 *			domain.  This is set by a successful attach user confirm, and the
 *			user application should wait until that confirm is received before
 *			trying to invoke any other MCS services.
 *		Merge_In_Progress
 *			This is a boolean flag that indicates whether or not the attached
 *			Domain object is in the merge state.  When in the merge state it
 *			is invalid to send it any MCS commands.
 *		Deletion_Pending
 *			This is a boolean flag that indicates whether or not an internally
 *			requested deletion is pending.  This is used by the destructor to
 *			determine if a deletion was requested by the object itself, or is
 *			simply an asynchronous event.
 *		Maximum_User_Data_Length
 *			This is the maximum amount of user data that can be placed into
 *			a single MCS PDU.  This number is derived from the arbitrated
 *			maximum MCS PDU size (minus enough space for overhead bytes).
 *
 *	Private Member Functions:
 *		ValidateUserRequest
 *			This member function is called each time the user application makes
 *			a request.  It checks the current state of the system to see if
 *			conditions are such that the request can be processed at the
 *			current time.
 *		PurgeMessageQueue
 *			This member function walks through the current message queue,
 *			freeing all resources held therein.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

 #include "omcscode.h"

#define USER_MSG_BASE       WM_APP

/*
 *	bugbug:
 *	The following constant is only used to cover a bug in NM 2.0 for backward
 *	compatibility purposes.  NM 2.0 can not accept MCS data PDUs with more than
 *	4096 bytes of user data.  Because of the Max MCS PDU size we negotiate (4128),
 *	even in NM 2.0, we should have been able to send 4120 bytes.  But NM 2.0 chokes
 *	in this case.
 *	The constant should eliminated after NM 3.0.
 */
#define		BER_PROTOCOL_EXTRA_OVERHEAD		24

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CMCSCoder				*g_MCSCoder;
// The external MCS Controller object
extern PController				g_pMCSController;
// The global MCS Critical Section
extern CRITICAL_SECTION 		g_MCS_Critical_Section;
// The DLL's HINSTANCE
extern HINSTANCE 				g_hDllInst;
// Class name for windows used by MCS attachments.
static char						s_WindowClassName[CLASS_NAME_LENGTH];


// Initialization of the class's static variables.
CTimerUserList2* User::s_pTimerUserList2 = NULL;
HINSTANCE		 User::s_hInstance = NULL;

/*
 *	BOOL		InitializeClass ()
 *
 *	Public, static
 *
 *	Functional Description
 *
 *	This function initializes the class's static variables.  It is
 *	called during the MCS Controller's construction.
 */
BOOL User::InitializeClass (void)
{
		BOOL		bReturnValue;
		WNDCLASS	window_class;

	DBG_SAVE_FILE_LINE
	s_pTimerUserList2 = new CTimerUserList2();
	bReturnValue = (s_pTimerUserList2 != NULL);

	if (bReturnValue) {
		//	Construct the window class name
		wsprintf (s_WindowClassName, "MCS Window %x %x", GetCurrentProcessId(), GetTickCount());

		/*
		 *	Fill out a window class structure in preparation for registering
		 *	the window with Windows.  Note that since this is a hidden
		 *	window, most of the fields can be set to NULL or 0.
		 */
		ZeroMemory (&window_class, sizeof(WNDCLASS));
		window_class.lpfnWndProc	= (WNDPROC) UserWindowProc;
		window_class.hInstance		= s_hInstance = g_hDllInst;
		window_class.lpszClassName	= s_WindowClassName;

		/*
		 *	Register the class with Windows so that we can create a window
		 *	for use by this portal.
		 */
		if (RegisterClass (&window_class) == 0)
		{
			ERROR_OUT (("InitWindowPortals: window class registration failed. Error: %d", GetLastError()));
			bReturnValue = FALSE;
		}
	}
	else {
		ERROR_OUT(("User::InitializeClass: Failed to allocate timer dictionary."));
	}

	return bReturnValue;
}


/*
 *	void		CleanupClass ()
 *
 *	Public, static
 *
 *	Functional Description
 *
 *	This function cleans up the class's static variables.  It is
 *	called when the MCS Controller is deleted.
 */
void User::CleanupClass (void)
{
	delete s_pTimerUserList2;
	UnregisterClass (s_WindowClassName, s_hInstance);
}

/*
 *	MCSError	MCS_AttachRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This API entry point is used to attach to an existing domain.  Once
 *		attached, a user application can utilize the services of MCS.  When
 *		a user application is through with MCS, it should detach from the domain
 *		by calling MCSDetachUserRequest (see below).
 */
MCSError WINAPI MCS_AttachRequest (IMCSSap **			ppIMCSSap,
							DomainSelector		domain_selector,
							UINT,                                   // domain_selector_length
							MCSCallBack			user_callback,
							PVoid				user_defined,
							UINT				flags)
{
	MCSError				return_value = MCS_NO_ERROR;
	AttachRequestInfo		attach_request_info;
	PUser					pUser;

	TRACE_OUT(("AttachUserRequest: beginning attachment process"));
	ASSERT (user_callback);

	// Initialize the interface ptr.
	*ppIMCSSap = NULL;
	
	/*
	 *	Pack the attach parameters into a structure since they will not fit
	 *	into the one parameter we have available in the owner callback.
	 */
	attach_request_info.domain_selector = (GCCConfID *) domain_selector;
	attach_request_info.ppuser = &pUser;

	/*
	 *	Enter the critical section which protects global data.
	 */
	EnterCriticalSection (& g_MCS_Critical_Section);

	if (g_pMCSController != NULL) {

		/*
		 *	Send an attach user request message to the controller through its
		 *	owner callback function.
		 */
		return_value = g_pMCSController->HandleAppletAttachUserRequest(&attach_request_info);
		if (return_value == (ULong) MCS_NO_ERROR)
		{
			// Set the returned interface ptr
			*ppIMCSSap = (IMCSSap *) pUser;

			/*
			 *	If the request was accepted, then register
			 *	the new user attachment.  Note that there
			 *	is still no user ID associated with this
			 *	attachment, since the attach user confirm
			 *	has not yet been received.
			 */
			pUser->RegisterUserAttachment (user_callback, user_defined,
											flags);
		}
	}
	else {
		ERROR_OUT(("MCS_AttachRequest: MCS Provider is not initialized."));
		return_value = MCS_NOT_INITIALIZED;
	}
	/*
	 *	Leave the critical section before returning.
	 */
	LeaveCriticalSection (& g_MCS_Critical_Section);
	
	return (return_value);
}


/*
 *	User ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the user class.  It initializes all instance
 *		variables (mostly with passed in information).  It then registers its
 *		presence with the application interface object, so that user requests
 *		and responses will get here okay.  Finally, it issues an attach user
 *		request to the domain to start the attachment process.
 */
User::User (PDomain		pDomain,
			PMCSError	pError)
:
    CAttachment(USER_ATTACHMENT),
	m_pDomain(pDomain),
	Deletion_Pending (FALSE),
	User_ID (0),
	Merge_In_Progress (FALSE),
	m_DataPktQueue(),
	m_PostMsgPendingQueue(),
	m_DataIndMemoryBuf2(),
	CRefCount(MAKE_STAMP_ID('U','s','e','r'))
{
	DomainParameters		domain_parameters;

	g_pMCSController->AddRef();
	/*
	 * We now need to create the window that the MCS Provider
	 * will use to deliver MCS messages to the attachment.
	 * These messages are indications and confirms.
	 */
	m_hWnd = CreateWindow (s_WindowClassName,
							NULL,
							WS_POPUP,
							CW_USEDEFAULT,
							CW_USEDEFAULT,
							CW_USEDEFAULT,
							CW_USEDEFAULT,
							NULL,
							NULL,
							g_hDllInst,
							NULL);

	if (m_hWnd != NULL) {
		/*
		 *	Call the domain object to find out the current domain parameters.
		 *	From this, set the maximum user data length appropriately.
		 */
		m_pDomain->GetDomainParameters (&domain_parameters, NULL, NULL);
		Maximum_User_Data_Length = domain_parameters.max_mcspdu_size -
									(MAXIMUM_PROTOCOL_OVERHEAD_MCS +
									BER_PROTOCOL_EXTRA_OVERHEAD);
		TRACE_OUT (("User::User: "
			"maximum user data length = %ld", Maximum_User_Data_Length));

		/*
		 *	Use the specified domain parameters to set the type of encoding rules
		 *	to be used.
		 */
		ASSERT (domain_parameters.protocol_version == PROTOCOL_VERSION_PACKED);

		/*
		 *	Send an attach user request to the specified domain.
		 */
		m_pDomain->AttachUserRequest (this);
		*pError = MCS_NO_ERROR;
	}
	else {
		*pError = MCS_ALLOCATION_FAILURE;
	}
}

/*
 *	~User ()
 *
 *	Public
 *
 *	Functional Description:
 *		
 */
User::~User ()
{
	PDataPacket packet;
	while (NULL != (packet = m_PostMsgPendingQueue.Get()))
	{
		packet->Unlock();
    }

	if (m_hWnd) {
		// Destroy the window; we do not need it anymore
		DestroyWindow (m_hWnd);
	}
	g_pMCSController->Release();
}

/*
 *	MCSError	GetBuffer ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function allocates an MCS buffer for a user attachment.
 *		Because this function allocates a buffer for the user and a Memory
 *		object that immediately precedes the buffer, after the user fills in
 *		the buffer with data and gives it to MCS to send, it needs to specify the
 *		right flags in the SendData request API.
 */

MCSError User::GetBuffer (UINT	size, PVoid	*pbuffer)
{

	MCSError				return_value;
	PMemory					memory;

	EnterCriticalSection (& g_MCS_Critical_Section);
	
	/*
	 *	This request may be a retry from a previous request which
	 *	returned MCS_TRANSMIT_BUFFER_FULL.  If so, delete the associated
	 *	buffer retry info structure since resource levels will be
	 *	checked in this function anyway.
	 */
	if (m_BufferRetryInfo != NULL) {
		KillTimer (NULL, m_BufferRetryInfo->timer_id);
		s_pTimerUserList2->Remove(m_BufferRetryInfo->timer_id);
		delete m_BufferRetryInfo;
		m_BufferRetryInfo = NULL;
		
	}

	// Allocate the memory
	DBG_SAVE_FILE_LINE
	memory = AllocateMemory (NULL, size + MAXIMUM_PROTOCOL_OVERHEAD,
							 SEND_PRIORITY);
							
	LeaveCriticalSection (& g_MCS_Critical_Section);

	if (NULL != memory) {
		// the allocation succeeded.
		ASSERT ((PUChar) memory + sizeof(Memory) == memory->GetPointer());
		*pbuffer = (PVoid) (memory->GetPointer() + MAXIMUM_PROTOCOL_OVERHEAD);
		return_value = MCS_NO_ERROR;
	}
	else {
		// the allocation failed.
		TRACE_OUT (("User::GetBuffer: Failed to allocate data buffer."));
		CreateRetryTimer (size + MAXIMUM_PROTOCOL_OVERHEAD);
		return_value = MCS_TRANSMIT_BUFFER_FULL;
	}
	return (return_value);
}

/*
 *	MCSError	FreeBuffer ()
 *
 *	Public
 *
 *	Functional Description:
 */

void User::FreeBuffer (PVoid	buffer_ptr)
{
		PMemory		memory;

	ASSERT (m_fFreeDataIndBuffer == FALSE);

	/*
	 *	Attempt to find the buffer in the m_DataIndDictionary dictionary.
	 *	This is where irregular data indications go.
	 */
	if (NULL == (memory = m_DataIndMemoryBuf2.Remove(buffer_ptr)))
    {
		memory = GetMemoryObject(buffer_ptr);
    }

	// Free the memory.
	EnterCriticalSection (& g_MCS_Critical_Section);
	FreeMemory (memory);
	LeaveCriticalSection (& g_MCS_Critical_Section);
}

/*
 *	Void	CreateRetryTimer
 *
 *	Private
 *
 *	Functional Description
 *		This functions creates a timer in response to a failure to
 *		allocate memory for the send data that the user is trying to
 *		send.  The timer will fire off periodically so that this code
 *		will remember to check the memory levels and provide an
 *		MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION to the user.
 *
 *	Return Value:
 *		None.
 *
 *	Side effects:
 *		The timer is created.
 */

Void User::CreateRetryTimer (ULong size)
{
	UINT_PTR timer_id;
			
	timer_id = SetTimer (NULL, 0, TIMER_PROCEDURE_TIMEOUT, (TIMERPROC) TimerProc);
	if (timer_id != 0) {
		DBG_SAVE_FILE_LINE
		m_BufferRetryInfo = new BufferRetryInfo;

		if (m_BufferRetryInfo != NULL) {
			m_BufferRetryInfo->user_data_length = size;
			m_BufferRetryInfo->timer_id = timer_id;

			s_pTimerUserList2->Append(timer_id, this);
		}
		else {
			ERROR_OUT (("User::CreateRetryTimer: Failed to allocate BufferRetryInfo struct."));
			KillTimer (NULL, timer_id);
		}
	}
	else {
		/*
		 *	This is a bad error, The notification to the user when buffers
		 *	are available will be lost.  Hopefully, the user will try again
		 *	later.
		 */
		WARNING_OUT(("User::CreateRetryTimer: Could not SetTimer."));
	}
}

/*
 *	MCSError	ReleaseInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wishes to detach from the domain.
 *		It kicks off the process of detaching, and seeing that this object
 *		is properly deleted.
 */
MCSError	User::ReleaseInterface ()
{
	CUidList		deletion_list;
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Check to see if there is a merge operation in progress before proceeding
	 *	with the request.
	 */
	if (Merge_In_Progress == FALSE)
	{
		/*
		 *	If deletion is not already pending, then it is necessary for us
		 *	to tell the domain that we are leaving.
		 */
		if (Deletion_Pending == FALSE)
		{
			/*
			 *	If we are already attached, user ID will not be 0, and we
			 *	should send a detach user request.  If user ID IS 0, then we
			 *	are not yet attached to the domain, so a disconnect provider
			 *	ultimatum is used instead.
			 */
			if (User_ID != 0)
			{
				deletion_list.Append(User_ID);
				m_pDomain->DetachUserRequest (this,
							REASON_USER_REQUESTED, &deletion_list);
				User_ID = 0;
			}
			else
				m_pDomain->DisconnectProviderUltimatum (this,
							REASON_USER_REQUESTED);

			/*
			 *	Set the flag that will cause the object to be deleted during
			 *	the next call to FlushMessageQueue.
			 */
			Deletion_Pending = TRUE;
		}

		/*
		 *	Empty out the message queue (the application should receive no
		 *	messages once the attachment has been deleted).
		 */
		PurgeMessageQueue ();

		// Cleanup timers and retry structures;
		if (m_BufferRetryInfo != NULL) {
			s_pTimerUserList2->Remove(m_BufferRetryInfo->timer_id);
			KillTimer (NULL, m_BufferRetryInfo->timer_id);
			delete m_BufferRetryInfo;
			m_BufferRetryInfo = NULL;
		}

		return_value = MCS_NO_ERROR;

		// Release can release the MCS Controller, so, we have to exit the CS now.
		LeaveCriticalSection (& g_MCS_Critical_Section);
		
		/*
		 *	Release this object. Note that the object may be deleted
		 *	here, so, we should not access any member variables after this
		 *	call.
		 */
		Release();
	}
	else
	{
		LeaveCriticalSection (& g_MCS_Critical_Section);
		/*
		 *	This operation could not be processed at this time due to a merge
		 *	operation in progress at the local provider.
		 */
		WARNING_OUT (("User::ReleaseInterface: "
				"merge in progress"));
		return_value = MCS_DOMAIN_MERGING;
	}

	return (return_value);
}

#define CHANNEL_JOIN		0
#define CHANNEL_LEAVE		1
#define CHANNEL_CONVENE		2
#define CHANNEL_DISBAND		3

/*
 *	MCSError	ChannelJLCD ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to join/leave/convene/disband
 *		a channel.  If the user is attached to the domain, the request will be
 *		repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelJLCD (int type, ChannelID channel_id)
{
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR) {
		switch (type) {
		case CHANNEL_JOIN:
			m_pDomain->ChannelJoinRequest (this, User_ID, channel_id);
			break;
		case CHANNEL_LEAVE:
			{
				CChannelIDList	deletion_list;
				deletion_list.Append(channel_id);
				m_pDomain->ChannelLeaveRequest (this, &deletion_list);
			}
			break;
		case CHANNEL_CONVENE:
			m_pDomain->ChannelConveneRequest (this, User_ID);
			break;
		case CHANNEL_DISBAND:
			m_pDomain->ChannelDisbandRequest (this, User_ID, channel_id);
			break;
		}
	}

	LeaveCriticalSection (& g_MCS_Critical_Section);

	return (return_value);
}

/*
 *	MCSError	ChannelJoin ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to join a
 *		channel.  If the user is attached to the domain, the request will be
 *		repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelJoin (ChannelID channel_id)
{
	return (ChannelJLCD (CHANNEL_JOIN, channel_id));
}

/*
 *	MCSError	ChannelLeave ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to leave a
 *		channel.  If the user is attached to the domain, the request will be
 *		repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelLeave (ChannelID	channel_id)
{
	return (ChannelJLCD (CHANNEL_LEAVE, channel_id));
}

/*
 *	MCSError	ChannelConvene ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to convene a
 *		private channel.  If the user is attached to the domain, the request
 *		will be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelConvene ()
{
	return (ChannelJLCD (CHANNEL_CONVENE, 0));
}

/*
 *	MCSError	ChannelDisband ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to disband a
 *		private channel.  If the user is attached to the domain, the request
 *		will be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelDisband (
					ChannelID			channel_id)
{
	return (ChannelJLCD (CHANNEL_DISBAND, channel_id));
}

/*
 *	MCSError	ChannelAdmit ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to admit more
 *		users to a private channel for which it is manager.  If the user is
 *		attached to the domain, the request will be repackaged as an MCS command
 *		and sent to the domain object.
 */
MCSError	User::ChannelAdmit (
					ChannelID			channel_id,
					PUserID				user_id_list,
					UINT				user_id_count)
{
	UINT			count;
	CUidList		local_user_id_list;
	MCSError		return_value = MCS_NO_ERROR;

	/*
	 *	Verify that the value of each user ID included in the user ID list is
	 *	a valid value.  Otherwise, fail the call.
	 */
	for (count = 0; count < user_id_count; count++)
	{
		if (user_id_list[count] > 1000) {
			// add the UserID into the singly-linked list.
			local_user_id_list.Append(user_id_list[count]);
		}
		else {
			return_value = MCS_INVALID_PARAMETER;
			break;
		}
	}

	if (return_value == MCS_NO_ERROR) {

		EnterCriticalSection (& g_MCS_Critical_Section);
	
		/*
		 *	Verify that current conditions are appropriate for a request to be
		 *	accepted from a user attachment.
		 */
		return_value = ValidateUserRequest ();

		if (return_value == MCS_NO_ERROR)
		{
			m_pDomain->ChannelAdmitRequest (this, User_ID, channel_id,
												&local_user_id_list);
		}

		LeaveCriticalSection (& g_MCS_Critical_Section);
	}

	return (return_value);
}

#ifdef USE_CHANNEL_EXPEL_REQUEST
/*
 *	MCSError	MCSChannelExpelRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to expel
 *		users from a private channel for which it is manager.  If the user is
 *		attached to the domain, the request will be repackaged as an MCS command
 *		and sent to the domain object.
 */
MCSError	User::ChannelExpel (
					ChannelID			channel_id,
					PMemory				memory,
					UINT				user_id_count)
{
	UINT			count;
	CUidList		local_user_id_list;
	MCSError		return_value;
	PUserID			user_id_list = (PUserID) memory->GetPointer();

	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR)
	{
		/*
		 *	Repack the user ID list into an S-list before sending it on.
		 */
		for (count=0; count < user_id_count; count++)
			local_user_id_list.append ((DWORD) user_id_list[count]);

		m_pDomain->ChannelExpelRequest (this, User_ID, channel_id,
				&local_user_id_list);
	}

	if (return_value != MCS_DOMAIN_MERGING)
		FreeMemory (memory);

	return (return_value);
}
#endif // USE_CHANNEL_EXPEL_REQUEST

/*
 *	MCSError	SendData ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to send data
 *		on a channel.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 *
 *		Note that this version of the send data request assumes that the user
 *		data has not already been segmented.  This is the function that
 *		performs the segmentation.
 */
MCSError	User::SendData (DataRequestType		request_type,
							ChannelID			channel_id,
							Priority			priority,
							unsigned char *		user_data,
							ULong		 		user_data_length,
							SendDataFlags		flags)
{
	MCSError			return_value = MCS_NO_ERROR;
	ULong				i, request_count, user_packet_length;
	PDataPacket			packet;
	ASN1choice_t		choice;
	UINT				type;
	PUChar				data_ptr = user_data;
	PacketError			packet_error;
	Segmentation		segmentation;
	PMemory				memory;
	PDataPacket			*packets;

	/*
	 *	Calculate how many different MCS packets are going to be generated.
	 *	Remember that if the size of the request exceeds the maximum allowed
	 *	value, we will segment the data into multiple smaller pieces.
	 */
	request_count = ((user_data_length + (Maximum_User_Data_Length - 1)) /
					Maximum_User_Data_Length);

	/*
	 *	Allocate the array of PDataPackets, before we get the critical section.
	 */
	if (request_count == 1) {
		packets = &packet;
		packet = NULL;
	}
	else {
		DBG_SAVE_FILE_LINE
		packets = new PDataPacket[request_count];
		if (packets == NULL) {
			ERROR_OUT (("User::SendData: Failed to allocate packet array."));
			return_value = MCS_TRANSMIT_BUFFER_FULL;
		}
		else {
			ZeroMemory ((PVoid) packets, request_count * sizeof(PDataPacket));
		}
	}

	if (MCS_NO_ERROR == return_value) {
		// Set the choice and type variables for all the DataPackets.
		if (NORMAL_SEND_DATA == request_type) {
			choice = SEND_DATA_REQUEST_CHOSEN;
			type = MCS_SEND_DATA_INDICATION;
		}
		else {
			choice = UNIFORM_SEND_DATA_REQUEST_CHOSEN;
			type = MCS_UNIFORM_SEND_DATA_INDICATION;
		}
					
		EnterCriticalSection (& g_MCS_Critical_Section);

		/*
		 *	Verify that current conditions are appropriate for a request to be
		 *	accepted from a user attachment.
		 */
		return_value = ValidateUserRequest ();
	
		/*
		 *	Check to see if there is a merge operation in progress before proceeding
		 *	with the request.
		 */
		if (MCS_NO_ERROR == return_value) {

			/*
			 *	This request may be a retry from a previous request which
			 *	returned MCS_TRANSMIT_BUFFER_FULL.  If so, delete the associated
			 *	buffer retry info structure since resource levels will be
			 *	checked in this function anyway.
			 */
			if (m_BufferRetryInfo != NULL) {
                s_pTimerUserList2->Remove(m_BufferRetryInfo->timer_id);
				KillTimer (NULL, m_BufferRetryInfo->timer_id);
				delete m_BufferRetryInfo;
				m_BufferRetryInfo = NULL;
			}

			/*
			 *	Depending on the "flags" argument, we either have
			 *	to allocate the buffer space and copy the data into
			 *	it, or just create a Memory object for the supplied
			 *	buffer.
			 */
			if (flags != APP_ALLOCATION) {
		
				ASSERT (flags == MCS_ALLOCATION);
				/*
				 *	The buffer was allocated by MCS, thru an
				 *	MCSGetBufferRequest call.  So, the Memory object
				 *	must preceed the buffer.	
				 */
				 memory = GetMemoryObject (user_data);
				 ASSERT (SIGNATURE_MATCH(memory, MemorySignature));
			}
			else
				memory = NULL;

			/*
			 *	We now attempt to allocate all data packets at once.
			 *	We need to do that before starting to send them, because
			 *	the request has to be totally successful or totally fail.
			 *	We can not succeed in sending a part of the request.
			 */
			for (i = 0; (ULong) i < request_count; i++) {
				// take care of segmentation flags
				if (i == 0)
					// first segment
					segmentation = SEGMENTATION_BEGIN;
				else
					segmentation = 0;
				if (i == request_count - 1) {
					// last segment
					segmentation |= SEGMENTATION_END;
					user_packet_length = user_data_length - (ULong)(data_ptr - user_data);
				}
				else {
					user_packet_length = Maximum_User_Data_Length;
				}

				// Now, create the new DataPacket.
				DBG_SAVE_FILE_LINE
				packets[i] = new DataPacket (choice, data_ptr, user_packet_length,
									 (UINT) channel_id, priority,
									 segmentation, (UINT) User_ID,
									 flags, memory, &packet_error);

				// Make sure the allocation succeeded
				if ((packets[i] == NULL) || (packet_error != PACKET_NO_ERROR)) {
					/*
					 *	The allocation of the packet failed.  We must therefore
					 *	return a failure to the user application.
					 */
					WARNING_OUT (("User::SendData: data packet allocation failed"));
					return_value = MCS_TRANSMIT_BUFFER_FULL;
					break;
				}
					
				// Adjust the user data ptr
				data_ptr += Maximum_User_Data_Length;
			}

			if (return_value == MCS_NO_ERROR) {
				// We now can send the data.
				// Forward all the data packets to the appropriate places.
				for (i = 0; i < request_count; i++) {
					/*
					 *	Send the successfully created packet to the domain
					 *	for processing.
					 */
					m_pDomain->SendDataRequest (this, (UINT) type, packets[i]);

					/*
					 *	Enable the packet to free itself.  Note that it will not
					 *	actually do so until everyone that is using it is through
					 *	with it.  Also, if nobody has locked it so far,
					 *	it will be deleted.
					 */
					packets[i]->Unlock ();
				}
			}
			else {
				// some packet allocation failed
				for (i = 0; i < request_count; i++)
					delete packets[i];
			}
		}
		if (request_count > 1)
			delete [] packets;
	}

	if (MCS_TRANSMIT_BUFFER_FULL == return_value) {
		CreateRetryTimer(user_data_length + request_count * MAXIMUM_PROTOCOL_OVERHEAD);
	}
	else if (MCS_NO_ERROR == return_value) {
		FreeMemory (memory);
	}

	LeaveCriticalSection (& g_MCS_Critical_Section);
	return (return_value);
}

#define GRAB		0
#define INHIBIT		1
#define	PLEASE		2
#define RELEASE		3
#define TEST		4

/*
 *	MCSError	TokenGIRPT ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to grab/inhibit/request/release/test
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenGIRPT (int type, TokenID	token_id)
{
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR)
	{
		switch (type) {
		case GRAB:
			m_pDomain->TokenGrabRequest (this, User_ID, token_id);
			break;
		case INHIBIT:
			m_pDomain->TokenInhibitRequest (this, User_ID, token_id);
			break;
		case PLEASE:
			m_pDomain->TokenPleaseRequest (this, User_ID, token_id);
			break;
		case RELEASE:
			m_pDomain->TokenReleaseRequest (this, User_ID, token_id);
			break;
		case TEST:
			m_pDomain->TokenTestRequest (this, User_ID, token_id);
			break;
		}
	}
	LeaveCriticalSection (& g_MCS_Critical_Section);

	return (return_value);
}

/*
 *	MCSError	TokenGrab ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to grab
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenGrab (TokenID				token_id)
{
	return (TokenGIRPT (GRAB, token_id));
}

/*
 *	MCSError	TokenInhibit ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to inhibit
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenInhibit (TokenID				token_id)
{
	return (TokenGIRPT (INHIBIT, token_id));
}

/*
 *	MCSError	TokenGive ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to give away
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenGive (TokenID token_id, UserID receiver_id)
{
	MCSError		return_value;
	TokenGiveRecord TokenGiveRec;

	if (receiver_id > 1000) {
		// Fill in the TokenGive command structure.
		TokenGiveRec.uidInitiator = User_ID;
		TokenGiveRec.token_id = token_id;
		TokenGiveRec.receiver_id = receiver_id;

		EnterCriticalSection (& g_MCS_Critical_Section);
		/*
		 *	Verify that current conditions are appropriate for a request to be
		 *	accepted from a user attachment.
		 */
		return_value = ValidateUserRequest ();

		if (return_value == MCS_NO_ERROR) {	
			m_pDomain->TokenGiveRequest (this, &TokenGiveRec);
		}
		LeaveCriticalSection (& g_MCS_Critical_Section);
	}
	else {
		ERROR_OUT(("User::TokenGive: Invalid UserID for receiver."));
		return_value = MCS_INVALID_PARAMETER;
	}

	return (return_value);
}

/*
 *	MCSError	TokenGiveResponse ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to respond to
 *		a previously received token give indication.  If the user is attached to
 *		the domain, the request will be repackaged as an MCS command and sent to
 *		the domain object.
 */
MCSError	User::TokenGiveResponse (TokenID token_id, Result result)
{
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR)
	{
		m_pDomain->TokenGiveResponse (this, result, User_ID, token_id);
	}
	LeaveCriticalSection (& g_MCS_Critical_Section);

	return (return_value);
}

/*
 *	MCSError	TokenPlease ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to be given
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenPlease (TokenID				token_id)
{
	return (TokenGIRPT (PLEASE, token_id));
}

/*
 *	MCSError	TokenRelease ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to release
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenRelease (TokenID	token_id)
{
	return (TokenGIRPT (RELEASE, token_id));
}

/*
 *	MCSError	TokenTest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to test
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenTest (TokenID	token_id)
{
	return (TokenGIRPT (TEST, token_id));
}

/*
 *	MCSError	ValidateUserRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to determine if it is valid to process an incoming
 *		request at the current time.  It checks several different conditions
 *		to determine this, as follows:
 *
 *		- If there is a merge in progress, then the request is not valid.
 *		- If this user is not yet attached to a domain, then the request
 *		  is not valid.
 *		- If there are not enough objects of the Memory, Packet, or UserMessage
 *		  class to handle a reasonable request, then the request is not valid.
 *
 *		Note that the check on number of objects is not an absolute guarantee
 *		that there will be enough to handle a given request, because a request
 *		can result in MANY PDUs and user messages being generated.  For example,
 *		a single channel admit request can result in lots of channel admit
 *		indications being sent.  However, checking against a minimum number
 *		of objects can reduce the possibility of failure to be astronomically
 *		low.  And remember, even if MCS runs out of something while processing
 *		such a request, it WILL handle it properly (by cleanly destroying the
 *		user attachment or MCS connection upon which the failure occurred).  So
 *		there is no chance of MCS crashing as a result of this.
 *
 *	Caveats:
 *		None.
 */
MCSError	User::ValidateUserRequest ()
{
	MCSError		return_value = MCS_NO_ERROR;

	/*
	 *	Check to see if there is a merge operation in progress.
	 */
	if (Merge_In_Progress == FALSE)
	{
		/*
		 *	Make sure the user is attached to the domain.
		 */
		if (User_ID == 0)
		{
			/*
			 *	The user is not yet attached to the domain.  So fail the request
			 *	without passing it on to the domain object.
			 */
			TRACE_OUT (("User::ValidateUserRequest: user not attached"));
			return_value = MCS_USER_NOT_ATTACHED;
		}
	}
	else
	{
		/*
		 *	This operation could not be processed at this time due to a merge
		 *	operation in progress at the local provider.
		 *
		 *	NOTE for JASPER:
		 *	Jasper probably will need to wait on an event handle here, which will be
		 *	set when the main MCS thread receives all the merging PDUs that get us out
		 *	of the merging state.  Since the only MCS client for Jasper is the GCC,
		 *	it should be ok to block the client (GCC) while the merging goes on.
		 */
		WARNING_OUT (("User::ValidateUserRequest: merge in progress"));
		return_value = MCS_DOMAIN_MERGING;
	}

	return (return_value);
}

/*
 *	Void	RegisterUserAttachment ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method registers a user attachment with the User object.
 */
void User::RegisterUserAttachment (MCSCallBack	mcs_callback,
									PVoid		user_defined,
									UINT		flags)
{
	TRACE_OUT (("User::RegisterUserAttachment: user handle = %p", this));

	/*
	 *	Fill in all of the members of the User object.
	 */
	m_MCSCallback = mcs_callback;
	m_UserDefined = user_defined;
	m_BufferRetryInfo = NULL;
	m_fDisconnectInDataLoss = (flags & ATTACHMENT_DISCONNECT_IN_DATA_LOSS);
	m_fFreeDataIndBuffer = (flags & ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);

	// Increase the ref count to indicate that the client is now using the object.
	AddRef();
}

/*
 *	Void	SetDomainParameters ()
 *
 *	Public
 *
 *	Functional Description:
 *		This command is used to set the current value of the instance variable
 *		that holds the maximum user data field length.
 */
void	User::SetDomainParameters (
				PDomainParameters		domain_parameters)
{
	/*
	 *	Set the maximum user data length instance variable to conform to the
	 *	maximum PDU size within the attached domain (minus some overhead to
	 *	allow for protocol bytes).
	 */
	Maximum_User_Data_Length = domain_parameters->max_mcspdu_size -
								(MAXIMUM_PROTOCOL_OVERHEAD_MCS +
								BER_PROTOCOL_EXTRA_OVERHEAD);
	TRACE_OUT (("User::SetDomainParameters: "
			"maximum user data length = %ld", Maximum_User_Data_Length));

	/*
	 *	Use the specified domain parameters to set the type of encoding rules
	 *	to be used.
	 */
	ASSERT (domain_parameters->protocol_version == PROTOCOL_VERSION_PACKED);
}

/*
 *	Void	PurgeChannelsIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called during a domain merge operation when there is
 *		a conflict in the use of channels.  The former Top Provider responds
 *		by issuing this command, which causes all users of the channel to be
 *		expelled from it.  Additionally, if the channel corresponds to a user
 *		ID channel, that user is purged from the network.
 */
void	User::PurgeChannelsIndication (
				CUidList           *purge_user_list,
				CChannelIDList *)
{
	/*
	 *	Issue a DetachUserIndication to each user contained in the purge user
	 *	list.
	 */
	DetachUserIndication(REASON_PROVIDER_INITIATED, purge_user_list);
}

/*
 *	Void	DisconnectProviderUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function will be called when the domain determines the need to
 *		tear down quickly.  This call simulates the reception of a detach user
 *		indication (if the user is already attached), or an unsuccessful
 *		attach user confirm (if the user is not yet attached).  In either
 *		case, the user attachment will be eliminated by this call.
 */
void	User::DisconnectProviderUltimatum (
				Reason				reason)
{
	CUidList		deletion_list;

	if (User_ID != 0)
	{
		/*
		 *	If the user is already attached, simulate a detach user indication
		 *	on the local user ID.
		 */
		deletion_list.Append(User_ID);
		DetachUserIndication(reason, &deletion_list);
	}
	else
	{
		/*
		 *	If the user is not yet attached, simulate an unsuccessful attach
		 *	user confirm.
		 */
		AttachUserConfirm(RESULT_UNSPECIFIED_FAILURE, 0);
	}
}

/*
 *	Void	AttachUserConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to the attach user
 *		request that was sent by this object when it was first created.  This
 *		call will contain the result of that attachment operation.  If the
 *		result is successful, this call will also contain the user ID for this
 *		attachment.
 */
void	User::AttachUserConfirm (
				Result				result,
				UserID				uidInitiator)
{
	LPARAM		parameter;

	if (Deletion_Pending == FALSE)
	{
		ASSERT (User_ID == 0);
		
		/*
		 *	If the result is successful, set the user ID of this user
		 *	object to indicate its new status.
		 */
		if (result == RESULT_SUCCESSFUL)
			User_ID = uidInitiator;
		else
			Deletion_Pending = TRUE;

		parameter = PACK_PARAMETER (uidInitiator, result);

		/*
		 *	Post the user message to the application.
		 */
		if (! PostMessage (m_hWnd, USER_MSG_BASE + MCS_ATTACH_USER_CONFIRM,
							(WPARAM) this, parameter)) {
			WARNING_OUT (("User::AttachUserConfirm: Failed to post msg to application. Error: %d",
						GetLastError()));
			if (result != RESULT_SUCCESSFUL)
				Release();
		}
	}
	else {
		Release();
	}
}

/*
 *	Void	DetachUserIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain whenever a user leaves the domain
 *		(voluntarily or otherwise).  Furthermore, if a user ID in the indication
 *		is the same as the local user ID, then this user is being involuntarily
 *		detached.
 */
Void	User::DetachUserIndication (
				Reason				reason,
				CUidList           *user_id_list)
{
	UserID				uid;
	LPARAM				parameter;
	BOOL				bPostMsgResult;

	if (Deletion_Pending == FALSE)
	{
		/*
		 *	Iterate through the list of users to be deleted.
		 */
		user_id_list->Reset();
		while (NULL != (uid = user_id_list->Iterate()))
		{
			parameter = PACK_PARAMETER(uid, reason);

			/*
			 *	Post the user message to the application.
			 */
			bPostMsgResult = PostMessage (m_hWnd, USER_MSG_BASE + MCS_DETACH_USER_INDICATION,
		 								  (WPARAM) this, parameter);
			if (! bPostMsgResult) {
				WARNING_OUT (("User::DetachUserIndication: Failed to post msg to application. Error: %d",
							GetLastError()));
			}
			
			/*
			 *	If this indication is deleting this user attachment, then
			 *	set the deletion pending flag, and break out of the loop.
			 */
			if (User_ID == uid)
			{
				m_originalUser_ID = User_ID;
				User_ID = 0;
				Deletion_Pending = TRUE;
				if (! bPostMsgResult)
					Release();
				break;
			}
		}
	}
	else {
		/*
		 *	The user has already called ReleaseInterface().  If the
		 *	Indication is for this attachment, we have to release and
		 *	probably, delete the object.
		 */
		if (user_id_list->Find(User_ID)) {
			Release();
		}
	}
}

/*
 *	Void	ChannelJLCDAEConfInd ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called to post a channel confirm/indication message
 *		to the user application.  It handles ChannelJoinConfirms,
 *		ChannelLeaveIndications, ChannelConveneConfirms, ChannelDisbandIndications
 *		and ChannelExpelIndications.
 */
Void	User::ChannelConfInd (	UINT		type,
								ChannelID	channel_id,
								UINT		arg16)
{
	LPARAM		parameter;

	ASSERT (HIWORD(arg16) == 0);
	
	if (Deletion_Pending == FALSE)
	{
		parameter = PACK_PARAMETER (channel_id, arg16);

		/*
		 *	Post the user message to the application.
		 */
		if (! PostMessage (m_hWnd, USER_MSG_BASE + type,
							(WPARAM) this, parameter)) {
			WARNING_OUT (("User::ChannelConfInd: Failed to post msg to application. Type: %d. Error: %d",
						type, GetLastError()));
		}
	}
}


/*
 *	Void	ChannelJoinConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous channel
 *		join request.  This call contains the result of the join request, as
 *		well as the channel that has just been joined.
 */
Void	User::ChannelJoinConfirm (
				Result				result,
				UserID,
				ChannelID			requested_id,
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_JOIN_CONFIRM, channel_id, (UINT) result);
}


/*
 *	Void	ChannelLeaveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	User::ChannelLeaveIndication (
				Reason				reason,
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_LEAVE_INDICATION, channel_id, (UINT) reason);
}

/*
 *	Void		ChannelConveneConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous channel
 *		convene request.  This call contains the result of the request, as
 *		well as the channel that has just been convened.
 */
Void	User::ChannelConveneConfirm (
				Result				result,
				UserID,
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_CONVENE_CONFIRM, channel_id, (UINT) result);
}

/*
 *	Void		ChannelDisbandIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when MCS disbands an existing
 *		private channel.
 */
Void	User::ChannelDisbandIndication (
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_DISBAND_INDICATION, channel_id, REASON_CHANNEL_PURGED);
}

/*
 *	Void		ChannelAdmitIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when a user is admitted to a
 *		private channel.
 */
Void	User::ChannelAdmitIndication (
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList *)
{
	ChannelConfInd (MCS_CHANNEL_ADMIT_INDICATION, channel_id, (UINT) uidInitiator);
}

/*
 *	Void		ChannelExpelIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when a user is expelled from a
 *		private channel.
 */
Void	User::ChannelExpelIndication (
				ChannelID			channel_id,
				CUidList *)
{
	ChannelConfInd (MCS_CHANNEL_EXPEL_INDICATION, channel_id, REASON_USER_REQUESTED);
}

/*
 *	Void	SendDataIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when data needs to sent to the
 *		user on a channel that the user has joined.
 */
Void	User::SendDataIndication (
				UINT				message_type,
				PDataPacket			packet)
{	
	if (Deletion_Pending == FALSE)
	{
		/*
		 *	Lock the packet object to indicate that we wish to have future
		 *	access to the decoded data that it contains.  Then get the
		 *	address of the decoded data structure.
		 */
		packet->Lock ();
		packet->SetMessageType(message_type);

        // flush packets in the pending queue
    	PDataPacket pkt;
    	while (NULL != (pkt = m_PostMsgPendingQueue.PeekHead()))
    	{
    		if (::PostMessage(m_hWnd, USER_MSG_BASE + pkt->GetMessageType(),
    		                  (WPARAM) this, (LPARAM) pkt))
    		{
    		    // remove the item just posted
    		    m_PostMsgPendingQueue.Get();
    		}
    		else
    		{
    		    // fail to post pending ones, just append the new one and bail out.
    		    m_PostMsgPendingQueue.Append(packet);
    		    return;
    		}
        }

		/*
		 *	Post the user message to the application.
		 */
		if (! ::PostMessage(m_hWnd, USER_MSG_BASE + message_type,
		                    (WPARAM) this, (LPARAM) packet))
		{
		    // fail to post pending ones, just append the new one and bail out.
		    m_PostMsgPendingQueue.Append(packet);
		    return;
		}
	}
}

/*
 *	Void	TokenConfInd ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called to post a token confirm/indication message
 *		to the user application.
 */
Void	User::TokenConfInd (UINT		type,
							TokenID		token_id,
							UINT		arg16)
{
	LPARAM		parameter;

	ASSERT (HIWORD(arg16) == 0);
	
	if (Deletion_Pending == FALSE)
	{
		parameter = PACK_PARAMETER (token_id, arg16);

		/*
		 *	Post the user message to the application.
		 */
		if (! PostMessage (m_hWnd, USER_MSG_BASE + type,
							(WPARAM) this, parameter)) {
			WARNING_OUT (("User::TokenConfInd: Failed to post msg to application. Type: %d. Error: %d",
						type, GetLastError()));
		}
	}
}

/*
 *	Void	TokenGrabConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		grab request.  This call contains the result of the grab request, as
 *		well as the token that has just been grabbed.
 */
Void	User::TokenGrabConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_GRAB_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenInhibitConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		inhibit request.  This call contains the result of the inhibit request,
 *		as well as the token that has just been inhibited.
 */
Void	User::TokenInhibitConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_INHIBIT_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenGiveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when another user attempts to
 *		give this user a token.
 */
Void	User::TokenGiveIndication (
				PTokenGiveRecord	pTokenGiveRec)
{
	TokenConfInd (MCS_TOKEN_GIVE_INDICATION, pTokenGiveRec->token_id,
				  (UINT) pTokenGiveRec->uidInitiator);
}

/*
 *	Void	TokenGiveConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		give request.  This call contains the result of the give request.
 */
Void	User::TokenGiveConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_GIVE_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenPleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when a user somewhere in the
 *		domain issues a token please request for a token that is currently
 *		owned by this user.
 */
Void	User::TokenPleaseIndication (
				UserID				uidInitiator,
				TokenID				token_id)
{
	TokenConfInd (MCS_TOKEN_PLEASE_INDICATION, token_id, (UINT) uidInitiator);
}

/*
 *	Void	TokenReleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This command is called when a token is being purged from the lower
 *		domain after a new connection is established.  It causes the indication
 *		to be forwarded to the user application, letting it know that it no
 *		longer owns the token.
 */
Void	User::TokenReleaseIndication (
				Reason				reason,
				TokenID				token_id)
{
	TokenConfInd (MCS_TOKEN_RELEASE_INDICATION, token_id, (UINT) reason);
}

/*
 *	Void	TokenReleaseConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		release request.  This call contains the result of the release request,
 *		as well as the token that has just been released.
 */
Void	User::TokenReleaseConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_RELEASE_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenTestConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		test request.  This call contains the result of the test request,
 *		as well as the token that has just been tested.
 */
Void	User::TokenTestConfirm (
				UserID,
				TokenID				token_id,
				TokenStatus			token_status)
{
	TokenConfInd (MCS_TOKEN_TEST_CONFIRM, token_id, (UINT) token_status);
}

/*
 *	Void	MergeDomainIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by domain upon entering or leaving a domain
 *		merger state.
 */
Void	User::MergeDomainIndication (
				MergeStatus			merge_status)
{
	if (Deletion_Pending == FALSE)
	{
		/*
		 *	If the merge operation is starting, set a boolean flag
		 *	indicating that this object should reject all user activity.
		 *	Otherwise, reset the flag.
		 */
		if (merge_status == MERGE_DOMAIN_IN_PROGRESS)
		{
			TRACE_OUT (("User::MergeDomainIndication: entering merge state"));
			Merge_In_Progress = TRUE;
		}
		else
		{
			TRACE_OUT (("User::MergeDomainIndication: leaving merge state"));
			Merge_In_Progress = FALSE;
		}
	}
}

/*
 *	Void	PurgeMessageQueue ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called to purge all current entries from the message
 *		queue, freeing up resources correctly (to prevent leaks).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		This function should only be called in the client's thread's context.
 */
Void	User::PurgeMessageQueue ()
{
	MSG				msg;
	PDataPacket		packet;
	HWND			hWnd;

	// First, unlock the packets in the list of pending data indications
	while (NULL != (packet = m_DataPktQueue.Get()))
		packet->Unlock();

	// Keep a copy of the attachment's HWND to destroy it later.
	hWnd = m_hWnd;
	m_hWnd = NULL;
		
	/*
	 *	This loop calls PeekMessage to go through all the messages in the thread's
	 *	queue that were posted by the main MCS thread.  It removes these
	 *	messages and frees the resources that they consume.
	 */
	while (PeekMessage (&msg, hWnd, USER_MSG_BASE, USER_MSG_BASE + MCS_LAST_USER_MESSAGE,
						PM_REMOVE)) {

		if (msg.message == WM_QUIT) {
			// Repost the quit
			PostQuitMessage (0);
			break;
		}
		
		/*
		 *	If this is a data indication message, we need to unlock
		 *	the packet associated with this message.
		 */
		else if ((msg.message == USER_MSG_BASE + MCS_SEND_DATA_INDICATION) ||
			(msg.message == USER_MSG_BASE + MCS_UNIFORM_SEND_DATA_INDICATION)) {
			((PDataPacket) msg.lParam)->Unlock ();
		}
		else if (((msg.message == USER_MSG_BASE + MCS_ATTACH_USER_CONFIRM) &&
					((Result) HIWORD(msg.lParam) != RESULT_SUCCESSFUL)) ||
			((msg.message == USER_MSG_BASE + MCS_DETACH_USER_INDICATION) &&
			(m_originalUser_ID == (UserID) LOWORD(msg.lParam)))) {
			ASSERT (this == (PUser) msg.wParam);
			Release();
			break;
		}
	}

	// Destroy the window; we do not need it anymore
	DestroyWindow (hWnd);
}

void User::IssueDataIndication (
					UINT				message_type,
					PDataPacket			packet)
{
		LPARAM					parameter;
		PMemory					memory;
		BOOL					bIssueCallback = TRUE;
		BOOL					bBufferInPacket = TRUE;
		PUChar					data_ptr;
		SendDataIndicationPDU	send_data_ind_pdu;
		
	switch (packet->GetSegmentation()) {
	case SEGMENTATION_BEGIN | SEGMENTATION_END:
		parameter = (LPARAM) &(((PDomainMCSPDU) (packet->GetDecodedData()))->
							u.send_data_indication);
		data_ptr = packet->GetUserData();
		memory = packet->GetMemory();
		break;
		
	case SEGMENTATION_END:
	{
		/*
		 *	We now have to collect all the individual packets from m_DataPktQueue
		 *	that go with this MCS Data PDU and sent them as a single data indication
		 *	using a buffer large enough for all the data.
		 */
		/*
		 *	First, find out the size of the large buffer we need to allocate.
		 *	Note that we make a copy of the original m_DataPktList and operate
		 *	on the copy, since we need to remove items from the original list.
		 */
			CDataPktQueue			PktQ(&m_DataPktQueue);
			UINT					size;
			PDataPacket				data_pkt;
			PUChar					ptr;
#ifdef DEBUG
			UINT uiCount = 0;
#endif // DEBUG
		
		size = packet->GetUserDataLength();
		PktQ.Reset();
		while (NULL != (data_pkt = PktQ.Iterate()))
		{
			if (packet->Equivalent (data_pkt)) {
#ifdef DEBUG
				if (uiCount == 0) {
					ASSERT (data_pkt->GetSegmentation() == SEGMENTATION_BEGIN);
				}
				else {
					ASSERT (data_pkt->GetSegmentation() == 0);
				}
				uiCount++;
#endif // DEBUG
				size += data_pkt->GetUserDataLength();
				// Remove from the original list, since we are processing the callback.
				m_DataPktQueue.Remove(data_pkt);
			}
		}
		// Allocate the memory we need.
		DBG_SAVE_FILE_LINE
		memory = AllocateMemory (NULL, size);
		if (memory != NULL) {
			bBufferInPacket = FALSE;
			// Copy the individual indications into the large buffer.
			data_ptr = ptr = memory->GetPointer();
			PktQ.Reset();
			/*
			 *	We need to enter the MCS critical section, because
			 *	we are unlocking packets.
			 */
			EnterCriticalSection (& g_MCS_Critical_Section);
			while (NULL != (data_pkt = PktQ.Iterate()))
			{
				if (packet->Equivalent (data_pkt)) {
					size = data_pkt->GetUserDataLength();
					memcpy ((void *) ptr,
							(void *) data_pkt->GetUserData(),
							size);
					ptr += size;
					data_pkt->Unlock();
				}
			}
			// Leave the MCS critical section
			LeaveCriticalSection (& g_MCS_Critical_Section);
			
			// Copy the last indication into the large buffer.
			memcpy ((void *) ptr,
					(void *) packet->GetUserData(),
					packet->GetUserDataLength());

			/*
			 *	Prepare the SendDataIndicationPDU structure for the client.
			 *	Notice that we can use the first 8 bytes from the decoded
			 *	structure of the current "packet" to fill in the first bytes from
			 *	it.
			 */
			memcpy ((void *) &send_data_ind_pdu,
					(void *) &(((PDomainMCSPDU) (packet->GetDecodedData()))->
								u.send_data_indication), 8);
			send_data_ind_pdu.segmentation = SEGMENTATION_BEGIN | SEGMENTATION_END;
			send_data_ind_pdu.user_data.length = memory->GetLength();
			send_data_ind_pdu.user_data.value = data_ptr;
			parameter = (ULONG_PTR) &send_data_ind_pdu;
		}
		else {
			/*
			 *	We have failed to issue the data indication callback to the client.
			 *	The user attachment has been compromised.  If the attachment can not
			 *	live with this loss, we have to detach them from the conference.
			 */
			ERROR_OUT (("User::IssueDataIndication: Memory allocation failed for segmented buffer of size %d.",
						size));
			bIssueCallback = FALSE;
			
			// Clean up after the failure
			EnterCriticalSection (& g_MCS_Critical_Section);
			PktQ.Reset();
			while (NULL != (data_pkt = PktQ.Iterate()))
			{
				if (m_fDisconnectInDataLoss ||
					(packet->Equivalent (data_pkt))) {
					data_pkt->Unlock();
				}
			}
			packet->Unlock();
			LeaveCriticalSection (& g_MCS_Critical_Section);

			// Disconnect if the client wants us to.
			if (m_fDisconnectInDataLoss) {
				// Clear the list of the already-cleared pending packets. We will soon get a ReleaseInterface().
				m_DataPktQueue.Clear();
				
				ERROR_OUT(("User::IssueDataIndication: Disconnecting user because of data loss..."));
				/*
				 *	Send a detach user indication directly to the user application.
				 *	Note that this cannot go through the queue, due to the memory
				 *	failure.
				 */
				(*m_MCSCallback) (MCS_DETACH_USER_INDICATION,
								PACK_PARAMETER (User_ID, REASON_PROVIDER_INITIATED),
								m_UserDefined);

			}
		}
		break;
	}
	
	case SEGMENTATION_BEGIN:
	case 0:
		// Append the packet to the list of packets for send.
		m_DataPktQueue.Append(packet);
		bIssueCallback = FALSE;
		break;
		
	default:
		ASSERT (FALSE);
		ERROR_OUT(("User::IssueDataIndication: Processed packet with invalid segmentation field."));
		break;
	}

	if (bIssueCallback) {
		/*
		 *	If the client has advised the server not to free the data, we have to
		 *	lock the buffer.
		 */
		if (m_fFreeDataIndBuffer == FALSE) {
			if (bBufferInPacket)
				LockMemory (memory);
				
			// Enter the data indication info in a dictionary, for the Free request.
			if (GetMemoryObject(data_ptr) != memory)
            {
				m_DataIndMemoryBuf2.Append((LPVOID) data_ptr, memory);
            }
		}
		
		/*
		 *	Issue the callback. The callee can not refuse to process this.
		 */
		(*m_MCSCallback) (message_type, parameter, m_UserDefined);

		/*
		 *	If the client has advised the server to free the data indication buffer
		 *	after delivering the callback, we must do so.
		 */
		if (m_fFreeDataIndBuffer) {
			if (bBufferInPacket == FALSE)
				FreeMemory (memory);
		}

		// To unlock a packet, we need to enter the MCS CS.
		EnterCriticalSection (& g_MCS_Critical_Section);
		packet->Unlock();
		LeaveCriticalSection (& g_MCS_Critical_Section);
	}
}	
	

/*
 *	LRESULT		UserWindowProc ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the window procedure that will be used by all internally
 *		created windows.  A hidden window is created internally when the
 *		application attaches to an MCS domain.  This technique insures
 *		that callbacks are delivered to the owner in the same thread that
 *		initially created the attachment.
 */
LRESULT CALLBACK	UserWindowProc (
							HWND		window_handle,
							UINT		message,
							WPARAM		word_parameter,
							LPARAM		long_parameter)
{
		UINT		mcs_message;
		//PDataPacket	packet;
		PUser		puser;
		
	if ((message >= USER_MSG_BASE) && (message < USER_MSG_BASE + MCS_LAST_USER_MESSAGE)) {
		// This is an MCS msg going to the user application.

		// Compute the MCS msg type
		mcs_message = message - USER_MSG_BASE;

		// Retrieve the pointer to the User (interface) object.
		puser = (PUser) word_parameter;
        if (NULL != puser)
        {
    		/*
    		 *	Find out whether this is a data indication. If it is, set the
    		 *	packet variable.
    		 */
    		if ((mcs_message == MCS_SEND_DATA_INDICATION) ||
    			(mcs_message == MCS_UNIFORM_SEND_DATA_INDICATION)) {
    			puser->IssueDataIndication (mcs_message, (PDataPacket) long_parameter);
    		}
    		else {
    			/*
    			 *	Issue the callback. Notice that the callee can not refuse
    			 *	to process this.
    			 */
    			(*(puser->m_MCSCallback)) (mcs_message, long_parameter, puser->m_UserDefined);
    		}

    		/*
    		 *	We may need to release the User object.  This is the Server
    		 *	side release.
    		 */
    		if (((mcs_message == MCS_ATTACH_USER_CONFIRM) &&
    					((Result) HIWORD(long_parameter) != RESULT_SUCCESSFUL)) ||
    			((mcs_message == MCS_DETACH_USER_INDICATION) &&
    					(puser->m_originalUser_ID == (UserID) LOWORD(long_parameter)))) {
    			puser->Release();
    		}
        }
        else
        {
            ERROR_OUT(("UserWindowProc: null puser"));
        }
		return (0);
	}
	else {
		/*
		 *	Invoke the default window message handler to handle this
		 *	message.
		 */
		return (DefWindowProc (window_handle, message, word_parameter,
								long_parameter));
	}
}


/*
 *	Void	CALLBACK TimerProc (HWND, UINT, UINT, DWORD
 *
 *	Public
 *
 *	Functional Description:
 *		This is the timer procedure.  Timer messages will be routed to this
 *		function as a result of timer events which have been set up to recheck
 *		resource levels.  This would happen following a call to either
 *		MCSSendDataRequest or MCSUniformSendDataRequest which resulted in a
 *		return value of MCS_TRANSMIT_BUFFER_FULL.
 */
Void	CALLBACK TimerProc (HWND, UINT, UINT timer_id, DWORD)
{
	PUser				puser;

	/*
	 *	Enter the critical section which protects global data.
	 */
	EnterCriticalSection (& g_MCS_Critical_Section);

	/*
	 *	First, we must find which user owns this timer.  We will do this by
	 *	searching through the Static_User_List.
	 */
	if (NULL == (puser = User::s_pTimerUserList2->Find(timer_id)))
	{
		WARNING_OUT (("TimerProc: no user owns this timer - deleting timer"));
		KillTimer (NULL, timer_id);
		goto Bail;
	}

	/*
	 *	Make sure that this user is actively attached.  If not, then kill the
	 *	timer and delete the user's buffer retry info structure.
	 */
    if ((puser->User_ID == 0) || puser->Deletion_Pending)
	{
		WARNING_OUT (("TimerProc: user is not attached - deleting timer"));
		goto CleanupBail;
	}

	/*
	 *	If we don't have retryinfo just get out of here.
	 */
	 if(puser->m_BufferRetryInfo == NULL)
	 {
		WARNING_OUT (("TimerProc: user does not have buffer retry info - deleting timer"));
		goto CleanupBail;
	 }

	/*
	 *	We have identified a valid owner of this timer.
	 *	Verify that there is enough memory for the
	 *	required size before proceeding.  Note that since there
	 *	can be multiple processes allocating from the same memory
	 *	at the same time, this call does not guarantee
	 *	that that the allocations will succeed.
	 */
	if (GetFreeMemory (SEND_PRIORITY) < puser->m_BufferRetryInfo->user_data_length)
	{
		TRACE_OUT (("TimerProc: not enough memory buffers of required size"));
		goto Bail;
	}

	/*
	 *	If the routine gets this far, then an adequate level of resources
	 *	now exists.
	 */

	/*
	 *	Issue an MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION to the user.
	 */
	TRACE_OUT(("TimerProc: Delivering MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION callback."));
//	(*(puser->m_MCSCallback)) (MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION,
//								0, puser->m_UserDefined);

	
	if(!PostMessage (puser->m_hWnd, USER_MSG_BASE + MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION,(WPARAM) puser, 0))
	{
		ERROR_OUT (("TimerProc: Failed to post msg to application. Error: %d", GetLastError()));
	}


CleanupBail:
	KillTimer (NULL, timer_id);
	delete puser->m_BufferRetryInfo;
	puser->m_BufferRetryInfo = NULL;
	User::s_pTimerUserList2->Remove(timer_id);

Bail:
	// Leave the attachment's critical section
	LeaveCriticalSection (& g_MCS_Critical_Section);

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icshelper\icshelpapi.h ===
/*****************************************************************************
******************************************************************************
**
**
**	ICShelp.h
**		Contains the useful public entry points to an ICS-assistance library
**		created for the Salem/PCHealth Remote Assistance feature in Whistler
**
**	Dates:
**		11-1-2000	created by TomFr
**		11-17-2000	re-written as a DLL, had been an object.
**
******************************************************************************
*****************************************************************************/
#ifndef __ICSHELP_HH__
#define __ICSHELP_HH__

#ifdef __cplusplus
extern "C" {
#endif


/****************************************************************************
**
**	OpenPort(int port)
**		if there is no ICS available, then we should just return...
**
**		Of course, we save away the Port, as it goes back in the
**		FetchAllAddresses call, asthe formatted "port" whenever a
**		different one is not specified.
**
****************************************************************************/

DWORD APIENTRY OpenPort(int Port);

/****************************************************************************
**
**	Called to close a port, whenever a ticket is expired or closed.
**
****************************************************************************/

DWORD APIENTRY ClosePort(DWORD dwHandle);

/****************************************************************************
**
**	FetchAllAddresses
**		Returns a string listing all the valid IP addresses for the machine,
**		followed by the DNS name of the machine.
**		Formatting details:
**		1. Each address is seperated with a ";" (semicolon)
**		2. Each address consists of the "1.2.3.4", and is followed by ":p"
**		   where the colon is followed by the port number
**
****************************************************************************/

DWORD APIENTRY FetchAllAddresses(WCHAR *lpszAddr, int iBufSize);


/****************************************************************************
**
**
**
**
**
**
****************************************************************************/

DWORD APIENTRY CloseAllOpenPorts(void);

/****************************************************************************
**
**
**
**
**
**
****************************************************************************/

DWORD APIENTRY StartICSLib(void);

/****************************************************************************
**
**
**
**
**
**
****************************************************************************/

DWORD APIENTRY StopICSLib(void);

/****************************************************************************
**
**	SetAlertEvent
**		Pass in an event handle. Then, whenever the ICS changes state, I
**		will signal that event.
**
****************************************************************************/

DWORD APIENTRY SetAlertEvent(HANDLE hEvent);

/****************************************************************************
**
**	ExpandAddress(char *szIp, char *szCompIp)
**		Takes a compressed IP address and returns it to
**		"normal"
**
****************************************************************************/

DWORD APIENTRY ExpandAddress(WCHAR *szIp, WCHAR *szCompIp);

/****************************************************************************
**
**	SquishAddress(char *szIp, char *szCompIp)
**		Takes one IP address and compresses it to minimum size
**
****************************************************************************/

DWORD APIENTRY SquishAddress(WCHAR *szIp, WCHAR *szCompIp);

/****************************************************************************
**
**	FetchAllAddressesEx
**
****************************************************************************/
// these are the flag bits to use.
#define IPF_ADD_DNS		1
#define IPF_COMPRESS	2
#define IPF_NO_SORT		4

DWORD APIENTRY FetchAllAddressesEx(WCHAR *lpszAddr, int iBufSize, int IPflags);

/****************************************************************************
**
**	GetIcsStatus(PICSSTAT pStat)
**		Returns a structire detailing much of what is going on inside this
**		library. The dwSize entry must be filled in before calling this
**		function. Use "sizeof(ICSSTAT))" to populate this.
**
****************************************************************************/

typedef struct _ICSSTAT {
	DWORD	dwSize;
	BOOL	bIcsFound;	// TRUE if we found an ICS wse can talk to
	BOOL	bIcsServer;	// TRUE if this machine is the ICS server
	BOOL	bUsingDP;	// TRUE if using the DPNATHLP.DLL support
	BOOL	bUsingUpnp;	// TRUE for uPnP, FALSE for PAST
	BOOL	bModemPresent;
	BOOL	bVpnPresent;
	WCHAR	wszPubAddr[25];	// filled in with the public side addr of ICS
	WCHAR	wszLocAddr[25];	// IP of local NIC used for PAST bindings
	WCHAR	wszDllName[32]; // name of DLL used for ICS support
} ICSSTAT, *PICSSTAT;


DWORD APIENTRY GetIcsStatus(PICSSTAT pStat);

#ifdef __cplusplus
}
#endif

#endif // __ICSHELP_HH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\userchnl.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	userchnl.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the UserChannel class.  It contains
 *		the code that distinguishes this class from that of its parent, Channel.
 *
 *		The main difference between this class and that of its parent is how
 *		the join and data requests are handled.  There is also a new instance
 *		variable that keeps track of what attachment leads to the user being
 *		represented by this class.  Merge requests are also generated as is
 *		appropriate for a user channel
 *
 *		The data primitives are overridden, allowing this object to decide
 *		not to send data upward, if it is known that the user lies in the
 *		sub-tree of this provider.
 *
 *	Private Instance Variables:
 *		m_pUserAttachment
 *			This is a pointer to the attachment that leads to the user being
 *			represented by this object.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include "userchnl.h"


/*
 *	UserChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the primary constructor for UserChannel objects.  It creates
 *		an object with all instance variable initialized, but with no
 *		attachments (i.e. the user is not joined to the channel automatically).
 *
 *		Note that most instance variable initialization is done by invoking the
 *		equivalent constructor in the base class.
 *
 *		Upon successful completion, an attach user confirm is automtically
 *		issued to the new user.
 */
UserChannel::UserChannel (
		ChannelID			channel_id,
		CAttachment        *user_attachment,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list)
:
    Channel(channel_id, local_provider, top_provider, channel_list, attachment_list),
    m_pUserAttachment(user_attachment)
{
	/*
	 *	Issue an attach user confirm to the new user.
	 */
	m_pUserAttachment->AttachUserConfirm(RESULT_SUCCESSFUL, channel_id);
}

/*
 *	UserChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a secondary constructor that is only used during merge
 *		operations.  The intent of this constructor is to create an equivalent
 *		object without issuing any of the confirms.
 *
 *		Note that the additional constructor allows for the creator to specify
 *		that the user is to be already joined to the channel upon creation.
 *		The value of user_attachment and attachment should either be the same
 *		or attachment should be NULL.
 */
UserChannel::UserChannel (
		ChannelID			channel_id,
		CAttachment        *user_attachment,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list,
		PConnection         pConn)
:
    Channel(channel_id, local_provider, top_provider, channel_list, attachment_list, pConn),
    m_pUserAttachment(user_attachment)
{
}

/*
 *	~UserChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This destructor does nothing more than clear the joined attachment list.
 *		This is important because it prevents the base class destructor from
 *		trying to issue channel leave indications to the user if the user is
 *		locally attached.
 */
UserChannel::~UserChannel ()
{
}

/*
 *	Channel_Type		GetChannelType ()
 *
 *	Public
 *
 *	Functional Description:
 *		Objects of this class are always user channels, so simply return
 *		USER_CHANNEL.
 */
Channel_Type		UserChannel::GetChannelType ()
{
	return (USER_CHANNEL);
}

/*
 *	BOOL    IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		User ID channels are always valid, so return TRUE.
 */
BOOL    UserChannel::IsValid ()
{
	return (TRUE);
}

/*
 *	CAttachment *GetAttachment ()
 *
 *	Public
 *
 *	Functional Description:
 *		Return the pointer to the attachment leading to the user.
 */
CAttachment	*UserChannel::GetAttachment(void)
{
	return m_pUserAttachment;
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is used to cause the Channel object to issue a
 *		merge request to the pending top provier.
 */
Void	UserChannel::IssueMergeRequest ()
{
	ChannelAttributes		channel_attributes;
	CChannelAttributesList	merge_channel_list;
	CChannelIDList			purge_channel_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Fill in the fields of the channel attributes structure so that it
		 *	accurately describes this channel.  Then put the structure into the
		 *	merge channel list.
		 */
		channel_attributes.channel_type = USER_CHANNEL;
		if (m_JoinedAttachmentList.IsEmpty() == FALSE)
			channel_attributes.u.user_channel_attributes.joined = TRUE;
		else
			channel_attributes.u.user_channel_attributes.joined = FALSE;
		channel_attributes.u.user_channel_attributes.user_id = Channel_ID;

		merge_channel_list.Append(&channel_attributes);

		/*
		 *	Send the merge request to the indicated provider.
		 */
		m_pConnToTopProvider->MergeChannelsRequest(&merge_channel_list, &purge_channel_list);
	}
}

/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function overrides the base class implementation.  The main
 *		difference is that this implementation only allows a user to join
 *		their own channel.  No one else is allowed to join it.
 *
 *		Also, since it is possible to have a user channel object with no one
 *		joined to it, this request will be forwarded upward to the Top
 *		Provider from here (unless this is the Top Provider).
 */
Void	UserChannel::ChannelJoinRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	/*
	 *	See if the requesting user ID is the same as that of the user this
	 *	UserChannel object represents.
	 */
	if (uidInitiator == Channel_ID)
	{
		/*
		 *	See if the user is already joined to the channel.
		 */
		if (m_JoinedAttachmentList.Find(pOrigAtt) == FALSE)
		{
			/*
			 *	The user is not joined to the channel.  If this is the Top
			 *	Provider, then the request can be processed here.
			 */
			if (IsTopProvider())
			{
				/*
				 *	Add the user to its own channel, and issue a successful
				 *	channel join confirm to the user.
				 */
				TRACE_OUT (("UserChannel::ChannelJoinRequest: "
						"user joining own user ID channel = %04X",
						uidInitiator));

				m_JoinedAttachmentList.Append(pOrigAtt);
	
				pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the join request
				 *	upward to the Top Provider.
				 */
				TRACE_OUT (("UserChannel::ChannelJoinRequest: "
						"forwarding join request to Top Provider"));

				m_pConnToTopProvider->ChannelJoinRequest(uidInitiator, Channel_ID);
			}
		}
		else
		{
			/*
			 *	The user is already joined to their channel.  Go ahead and
			 *	issue a successful channel join confirm.
			 */
			WARNING_OUT (("UserChannel::ChannelJoinRequest: "
					"user already joined to own user channel"));

			pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
		}
	}
	else
	{
		/*
		 *	Someone is trying to join someone elses channel.  This is not
		 *	valid.  Reject the request without further processing.
		 */
		WARNING_OUT (("UserChannel::ChannelJoinRequest: "
				"rejecting attempt to join someone elses user channel"));

		pOrigAtt->ChannelJoinConfirm(RESULT_OTHER_USER_ID, uidInitiator, channel_id, 0);
	}
}

/*
 *	Void	SendDataRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to send data through the channel.  Note that data
 *		is NEVER sent upward, since the user (who is the only one who can be
 *		joined to this channel) is in the sub-tree of this provider.  This helps
 *		to optimize network traffic.
 */
Void	UserChannel::SendDataRequest (
				CAttachment        *pOrigAtt,
				UINT				type,
				PDataPacket			data_packet)
{
	CAttachment *pAtt;

	ASSERT (Channel_ID == data_packet->GetChannelID());

	/*
	 *	Iterate through the attachment list, sending the data to all
	 *	the attachments (except for one from whence the data came).
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		if (pAtt != pOrigAtt)
		{
			pAtt->SendDataIndication(type, data_packet);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icshelper\icsutils.c ===
//#include "ICSHelp.h"
#include <winsock2.h>
#include <wsipx.h>

#include <iphlpapi.h>

#include "ICSutils.h"

#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

int gDbgFlag=3;
extern char g_szPublicAddr;
extern int iDbgFileHandle;

/*************************************************************
*
*   DbgSpew(DbgClass, char *, ...)
*		Sends debug information.
*
*************************************************************/
void DbgSpew(int DbgClass, WCHAR *lpFormat, va_list ap)
{
	WCHAR		szMessage[2500];

	vswprintf(szMessage, lpFormat, ap);
	wcscat(szMessage, L"\r\n");

	if ((DbgClass & 0x0F) >= (gDbgFlag & 0x0F))
	{
		// should this be sent to the debugger?
		if (DbgClass & DBG_MSG_DEST_DBG)
			OutputDebugStringW(szMessage);

		// should this go to our log file?
		if (iDbgFileHandle)
			_write(iDbgFileHandle, szMessage, (2*lstrlen(szMessage)));
	}
}

void TrivialSpew(WCHAR *lpFormat, ...)
{
	va_list	vd;
	va_start(vd, lpFormat);
	DbgSpew(DBG_MSG_TRIVIAL+DBG_MSG_DEST_DBG, lpFormat, vd);
	va_end(vd);
}

void InterestingSpew(WCHAR *lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_INTERESTING+DBG_MSG_DEST_DBG, lpFormat, ap);
	va_end(ap);
}

void ImportantSpew(WCHAR *lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_IMPORTANT+DBG_MSG_DEST_DBG+DBG_MSG_DEST_FILE, lpFormat, ap);
	va_end(ap);
}

void HeinousESpew(WCHAR *lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_HEINOUS+DBG_MSG_DEST_DBG+DBG_MSG_DEST_FILE+DBG_MSG_DEST_EVENT+DBG_MSG_CLASS_ERROR, lpFormat, ap);
	va_end(ap);
}

void HeinousISpew(WCHAR *lpFormat, ...)
{
	va_list	ap;
	va_start(ap, lpFormat);
	DbgSpew(DBG_MSG_HEINOUS+DBG_MSG_DEST_DBG+DBG_MSG_DEST_FILE+DBG_MSG_DEST_EVENT, lpFormat, ap);
	va_end(ap);
}

// ------------------------------
// DumpSocketAddress - dump a socket address
//
// Entry:		Debug level
//				Pointer to socket address
//				Socket family
//
// Exit:		Nothing
// ------------------------------

void	DumpSocketAddress( const DWORD dwDebugLevel, const SOCKADDR *const pSocketAddress, const DWORD dwFamily )
{
	switch ( dwFamily )
	{
		case AF_INET:
		{
			SOCKADDR_IN	*pInetAddress = (SOCKADDR_IN*)( pSocketAddress );

			TrivialSpew(L"IP socket:\tAddress: %d.%d.%d.%d\tPort: %d", 
					pInetAddress->sin_addr.S_un.S_un_b.s_b1, 
					pInetAddress->sin_addr.S_un.S_un_b.s_b2, 
					pInetAddress->sin_addr.S_un.S_un_b.s_b3, 
					pInetAddress->sin_addr.S_un.S_un_b.s_b4, 
					ntohs( pInetAddress->sin_port ));
			break;
		}

		case AF_IPX:
		{
			SOCKADDR_IPX *pIPXAddress = (SOCKADDR_IPX*)( pSocketAddress );

			TrivialSpew(L"IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
					(BYTE)pIPXAddress->sa_netnum[ 0 ],
					(BYTE)pIPXAddress->sa_netnum[ 1 ],
					(BYTE)pIPXAddress->sa_netnum[ 2 ],
					(BYTE)pIPXAddress->sa_netnum[ 3 ],
					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
					ntohs( pIPXAddress->sa_socket )
					);
			break;
		}

		default:
		{
			TrivialSpew(L"Unknown socket type!" );
			//INT3;
			break;
		}
	}
}


DWORD GetIPAddress(WCHAR *pVal, int iSize, int iPort)
{
	DWORD hr = S_FALSE; // In case no adapter

	PMIB_IPADDRTABLE pmib=NULL;
	ULONG ulSize = 0;
	DWORD dw;
	PIP_ADAPTER_INFO pAdpInfo = NULL;
	WCHAR	szPortBfr[24];
	WCHAR	*lStr = NULL;

	TRIVIAL_MSG((L"GetIPAddress(0x%x, %d, %d)", pVal, iSize, iPort));

	szPortBfr[0]=';';
	szPortBfr[1]=0;

	if (iPort)
		wsprintf(szPortBfr, L":%d;", iPort);

	dw = GetAdaptersInfo(
		pAdpInfo,
		&ulSize );
	if (dw == ERROR_BUFFER_OVERFLOW && pVal)
	{
		/* let's make certain the buffer is as big as we'll
		 *	ever need
		 */
		ulSize*=2;

		pAdpInfo = (IP_ADAPTER_INFO*)malloc(ulSize);

		if (!pAdpInfo)
			goto done;

		lStr = (WCHAR *)malloc(4096 * sizeof(WCHAR));
		if (!lStr)
			goto done;

		*lStr = '\0';

		dw = GetAdaptersInfo(
			pAdpInfo,
			&ulSize);
		if (dw == ERROR_SUCCESS)
		{
			int iAddrSize;
            PIP_ADAPTER_INFO p;
            PIP_ADDR_STRING ps;

            for(p=pAdpInfo; p!=NULL; p=p->Next)
            {

			   INTERESTING_MSG((L"looking at %S, type=0x%x", p->Description, p->Type));
               for(ps = &(p->IpAddressList); ps; ps=ps->Next)
                {

                    if (strcmp(ps->IpAddress.String, "0.0.0.0") != 0 &&
						strcmp(ps->IpAddress.String, &g_szPublicAddr) != 0)
                    {
						WCHAR	wcsBfr[25];

						wsprintf(wcsBfr, L"%S", ps->IpAddress.String);
                        wcscat(lStr, wcsBfr);
						wcscat(lStr, szPortBfr);
                    }
                }
            }

			iAddrSize = wcslen(lStr);
            if (iAddrSize)
			{
				iAddrSize = min(iAddrSize, iSize-1);

				memcpy(pVal, lStr, (iAddrSize+1)*sizeof(WCHAR));

				TRIVIAL_MSG((L"Copying %d chars for %s", iAddrSize+1, lStr));
			}
            else
                goto done;
            hr = S_OK;
		}
	}

done:
	if (pAdpInfo)
		free(pAdpInfo);

	if (lStr)
		free(lStr);

	return hr;
}

/******************************************************************
**		
**		GetGatewayAddr -- returns a flag to
**			indicate if a gateway is present
**		
******************************************************************/
int GetGatewayAddr(char *retStr)
{
	int retval = 0;
	PMIB_IPADDRTABLE pmib=NULL;
	ULONG ulSize = 0;
	DWORD dw;
	PIP_ADAPTER_INFO pAdpInfo = NULL;

	if (!retStr) return 0;

	dw = GetAdaptersInfo(
		pAdpInfo,
		&ulSize );
	if (dw == ERROR_BUFFER_OVERFLOW)
	{
		pAdpInfo = (IP_ADAPTER_INFO*)malloc(ulSize);
		dw = GetAdaptersInfo(
			pAdpInfo,
			&ulSize);
		if (dw == ERROR_SUCCESS)
		{
			strcpy(retStr, pAdpInfo->GatewayList.IpAddress.String);
			retval = 1;
		}
		free(pAdpInfo);
	}
	
	return retval;
}

int LocalFDIsSet(SOCKET fd, fd_set *set)
/*++
Routine Description:

    Determines if a specific socket is a contained in an FD_SET.

Arguments:

    s - A descriptor identifying the socket.

    set - A pointer to an FD_SET.
Returns:

    Returns TRUE if socket s is a member of set, otherwise FALSE.

--*/
{
    int i = set->fd_count; // index into FD_SET
    int rc=FALSE; // user return code

    while (i--){
        if (set->fd_array[i] == fd) {
            rc = TRUE;
        } //if
    } //while
    return (rc);
} // LocalFDIsSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icshelper\icsutils.h ===
#ifndef __ICSUTILS_H_FILE
#define __ICSUTILS_H_FILE

/************ our debug spew stuff ******************/
//void DbgSpew(int DbgClass, WCHAR *lpFormat, ...);
void DbgSpew(int DbgClass, WCHAR *lpFormat, va_list ap);
void TrivialSpew(WCHAR *lpFormat, ...);
void InterestingSpew(WCHAR *lpFormat, ...);
void ImportantSpew(WCHAR *lpFormat, ...);
void HeinousESpew(WCHAR *lpFormat, ...);
void HeinousISpew(WCHAR *lpFormat, ...);

#define DBG_MSG_TRIVIAL			0x001
#define DBG_MSG_INTERESTING		0x002
#define DBG_MSG_IMPORTANT		0x003
#define DBG_MSG_HEINOUS			0x004
#define DBG_MSG_DEST_DBG		0x010
#define DBG_MSG_DEST_FILE		0x020
#define DBG_MSG_DEST_EVENT		0x040
#define DBG_MSG_CLASS_ERROR		0x100

#define TRIVIAL_MSG(msg)		TrivialSpew msg 
#define INTERESTING_MSG(msg)	InterestingSpew msg
#define IMPORTANT_MSG(msg)		ImportantSpew msg
#define HEINOUS_E_MSG(msg)		HeinousESpew msg
#define HEINOUS_I_MSG(msg)		HeinousISpew msg

/*
 *	This global flag controls the amount of spew that we 
 *	produce. Legit values are as follows:
 *		1 = Trivial msgs displayed
 *		2 = Interesting msgs displayed
 *		3 = Important msgs displayed
 *		4 = only the most Heinous msgs displayed
 *	The ctor actually sets this to 3 by default, but it can
 *	be overridden by setting:
 *	HKLM, Software/Microsoft/SAFSessionResolver, DebugSpew, DWORD 
 */
extern int gDbgFlag;

void	DbgSpew(int DbgClass, WCHAR *lpFormat, va_list ap);
DWORD	GetIPAddress(WCHAR *lpAdress, int iSz, int PortNum);
int		GetGatewayAddr(char *retStr);
void	DumpSocketAddress( const DWORD dwDebugLevel, const SOCKADDR *const pSocketAddress, const DWORD dwFamily );
int		LocalFDIsSet(SOCKET fd, fd_set *set);

#endif // __ICSUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icshelper\raicshelp.c ===
/*****************************************************************************
******************************************************************************
**
**
**	RAICShelp.c
**		Contains the useful public entry points to an ICS-assistance library
**		created for the Salem/PCHealth Remote Assistance feature in Whistler
**
**	Dates:
**		11-1-2000	created by TomFr
**		11-17-2000	re-written as a DLL, had been an object.
**		2-15-20001	Changed to a static lib, support added for dpnathlp.dll
**		5-2-2001	Support added for dpnhupnp.dll & dpnhpast.dll
**
******************************************************************************
*****************************************************************************/

#define INIT_GUID
#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include <winsock2.h>
#include <MMSystem.h>
#include <WSIPX.h>
#include <Iphlpapi.h>
#include <stdlib.h>
#include <malloc.h>
#include "ICSutils.h"
#include "rsip.h"
#include "icshelpapi.h"
#include <dpnathlp.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>


/*****************************************************************************
**        Some global variables
*****************************************************************************/

// the mark of the beast...
#define NO_ICS_HANDLE 0x666

long	g_waitDuration=120000;
BOOL	g_boolIcsPresent = FALSE;
BOOL	g_boolIcsOnThisMachine = FALSE;
BOOL	g_boolIcsFound = FALSE;
BOOL	g_boolUsingNatHelp = FALSE;
BOOL	g_boolUsingNatPAST = FALSE;
BOOL	g_boolInitialized = FALSE;
SOCKADDR_IN	g_saddrLocal;
HANDLE	g_hWorkerThread = 0;

HMODULE	g_hModDpNatHlp = NULL;
PDIRECTPLAYNATHELP g_pDPNH = NULL;
char g_szPublicAddr[45];
char *g_lpszDllName = "NULL";
char szInternal[]="internal";

typedef struct _MAPHANDLES {
    int     iMapped; 
	DPNHHANDLE	hMapped[16];
} MAPHANDLES, *PMAPHANDLES;

#define DP_NAT_HANDLES  256
PMAPHANDLES  g_PortHandles[DP_NAT_HANDLES];


int iDbgFileHandle;

typedef struct _SUPDLLS {
	char	*szDllName;	
	BOOL	bUsesUpnp;	// TRUE if we ICS supports UPnP
} SUPDLLS, *PSUPDLLS;

SUPDLLS	strDpHelp[] =
{
	{"dpnhupnp.dll", TRUE},
	{"dpnhpast.dll", FALSE},
	{NULL, FALSE}
};

/******* USEFULL STUFF  **********/
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) sizeof(x)/sizeof(x[0])
#endif

// forward declares...
int GetTsPort(void);

/****************************************************************************
**
**	DumpLibHr-
**		Gives us debug spew for the HRESULTS coming back from DPNATHLP.DLL
**
****************************************************************************/

void DumpLibHr(HRESULT hr)
{
	char	*pErr = NULL;
	char	scr[400];

	switch (hr){
	case DPNH_OK:
		pErr = "DPNH_OK";
		break;
	case DPNHSUCCESS_ADDRESSESCHANGED:
		pErr = "DPNHSUCCESS_ADDRESSESCHANGED";
		break;
	case DPNHERR_ALREADYINITIALIZED:
		pErr = "DPNHERR_ALREADYINITIALIZED";
		break;
	case DPNHERR_BUFFERTOOSMALL:
		pErr = "DPNHERR_BUFFERTOOSMALL";
		break;
	case DPNHERR_GENERIC:
		pErr = "DPNHERR_GENERIC";
		break;
	case DPNHERR_INVALIDFLAGS:
		pErr = "DPNHERR_INVALIDFLAGS";
		break;
	case DPNHERR_INVALIDOBJECT:
		pErr = "DPNHERR_INVALIDOBJECT";
		break;
	case DPNHERR_INVALIDPARAM:
		pErr = "DPNHERR_INVALIDPARAM";
		break;
	case DPNHERR_INVALIDPOINTER:
		pErr = "DPNHERR_INVALIDPOINTER";
		break;
	case DPNHERR_NOMAPPING:
		pErr = "DPNHERR_NOMAPPING";
		break;
	case DPNHERR_NOMAPPINGBUTPRIVATE:
		pErr = "DPNHERR_NOMAPPINGBUTPRIVATE";
		break;
	case DPNHERR_NOTINITIALIZED:
		pErr = "DPNHERR_NOTINITIALIZED";
		break;
	case DPNHERR_OUTOFMEMORY:
		pErr = "DPNHERR_OUTOFMEMORY";
		break;
	case DPNHERR_PORTALREADYREGISTERED:
		pErr = "DPNHERR_PORTALREADYREGISTERED";
		break;
	case DPNHERR_PORTUNAVAILABLE:
		pErr = "DPNHERR_PORTUNAVAILABLE";
		break;
	case DPNHERR_SERVERNOTAVAILABLE:
		pErr = "DPNHERR_SERVERNOTAVAILABLE";
		break;
	case DPNHERR_UPDATESERVERSTATUS:
		pErr = "DPNHERR_UPDATESERVERSTATUS";
		break;
	default:
		wsprintfA(scr, "unknown error: 0x%x", hr);
		pErr = scr;
		break;
	};

	IMPORTANT_MSG((L"DpNatHlp result=%S", pErr));
}

/****************************************************************************
**
**	GetAllAdapters
**
****************************************************************************/

int GetAllAdapters(int *iFound, int iMax, SOCKADDR_IN *sktArray)
{
	PIP_ADAPTER_INFO p;
	PIP_ADDR_STRING ps;
    DWORD dw;
    ULONG ulSize = 0;
	int i=0;

    PIP_ADAPTER_INFO pAdpInfo = NULL;

	if (!iFound || !sktArray) return 1;

	*iFound = 0;
	ZeroMemory(sktArray, sizeof(SOCKADDR) * iMax);

	dw = GetAdaptersInfo(
		pAdpInfo,
		&ulSize );

    pAdpInfo = (IP_ADAPTER_INFO*)malloc(ulSize);

	if (!pAdpInfo)
    {
        INTERESTING_MSG((L"GetAddr malloc failed"));
		return 1;
    }

	dw = GetAdaptersInfo(
		pAdpInfo,
		&ulSize);
	if (dw != ERROR_SUCCESS)
	{
        INTERESTING_MSG((L"GetAdaptersInfo failed"));
        free(pAdpInfo);
        return 1;
    }

	for(p=pAdpInfo; p!=NULL; p=p->Next)
	{

	   for(ps = &(p->IpAddressList); ps; ps=ps->Next)
		{
			if (strcmp(ps->IpAddress.String, "0.0.0.0") != 0 && i < iMax)
			{
				sktArray[i].sin_family = AF_INET;
				sktArray[i].sin_addr.S_un.S_addr = inet_addr(ps->IpAddress.String);
				TRIVIAL_MSG((L"Found adapter #%d at [%S]", i+1, ps->IpAddress.String));
				i++;
			}
		}
	}

	*iFound = i;
    TRIVIAL_MSG((L"GetAllAdapters- %d found", *iFound));
    free(pAdpInfo);
    return 0;
}

/****************************************************************************
**
**	OpenPort(int port)
**		if there is no ICS available, then we should just return...
**
**		Of course, we save away the Port, as it goes back in the
**		FetchAllAddresses call, asthe formatted "port" whenever a
**		different one is not specified.
**
****************************************************************************/

DWORD APIENTRY OpenPort(int Port)
{
    DWORD   dwRet = (int)-1;

    TRIVIAL_MSG((L"OpenPort(%d)", Port ));

    if (!g_boolInitialized)
    {
        HEINOUS_E_MSG((L"ERROR: OpenPort- library not initialized"));
        return 0;
    }

    // save away for later retrieval
    g_iPort = Port;

    if (g_boolIcsPresent && g_pDPNH)
    {
        HRESULT hr=0;
        int i;
        DPNHHANDLE  *pHnd;
        SOCKADDR_IN lSockAddr[16];
		PMAPHANDLES hMap;

        for (i=0;g_PortHandles[i] != NULL; i++);

        if (i >= ARRAYSIZE(g_PortHandles))
        {
            // we have no more memory for mappings!
            // should never hit this, unless we are leaking...
            HEINOUS_E_MSG((L"Out of table space in OpenPort"));
            return 0;
        }
        // now we have a pointer for our handle array
		hMap = (PMAPHANDLES)malloc(sizeof(MAPHANDLES));
		g_PortHandles[i] = hMap;
		dwRet = 0x8000000 + i;

		// get adapters
		GetAllAdapters(&hMap->iMapped, ARRAYSIZE(lSockAddr), &lSockAddr[0]);

		TRIVIAL_MSG((L"GetAllAdapters found %d adapters to deal with", hMap->iMapped));

		/* Now we cycle through all the found adapters and get a mapping for each 
		 * This insures that the ICF is opened on all adapters...
		 */
		for (i = 0; i < hMap->iMapped; i++)
		{
			pHnd = &hMap->hMapped[i];
			lSockAddr[i].sin_port = ntohs((unsigned)Port);

			hr = IDirectPlayNATHelp_RegisterPorts(g_pDPNH, 
					(SOCKADDR *)&lSockAddr[i], sizeof(lSockAddr[0]), 1,
					30000, pHnd, DPNHREGISTERPORTS_TCP);
			if (hr != DPNH_OK)
			{
				IMPORTANT_MSG((L"RegisterPorts failed in OpenPort for adapter #%d, ", i ));
				DumpLibHr(hr);
			}
			else
			{
				TRIVIAL_MSG((L"OpenPort Assigned: 0x%x", *pHnd));
			}
		}
    }
    else
    {
        dwRet = NO_ICS_HANDLE;
        TRIVIAL_MSG((L"OpenPort- no ICS found"));
    }

    TRIVIAL_MSG((L"OpenPort- returns 0x%x", dwRet ));
    return dwRet;
}


/****************************************************************************
**
**	Called to close a port, whenever a ticket is expired or closed.
**
****************************************************************************/

DWORD APIENTRY ClosePort(DWORD MapHandle)
{
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwIndex;

    TRIVIAL_MSG((L"ClosePort(0x%x)", MapHandle ));

    if (!g_boolInitialized)
    {
        HEINOUS_E_MSG((L"ERROR: ClosePort- library not initialized"));
        return ERROR_INVALID_PARAMETER;
    }

    // if we didn't open this thru the ICS, then just return
    if (!g_boolIcsPresent && MapHandle == NO_ICS_HANDLE)
        return ERROR_SUCCESS;

    dwIndex = MapHandle - 0x8000000;

    if (g_boolIcsPresent && g_pDPNH && dwIndex < ARRAYSIZE(g_PortHandles))
    {
        HRESULT hr=0;
        int i;
	PMAPHANDLES	pMap = g_PortHandles[dwIndex];

        if (pMap)
	{
	    TRIVIAL_MSG((L"closing %d port mappings", pMap->iMapped));

	    for (i = 0; i < pMap->iMapped; i++)
	    {

                hr = IDirectPlayNATHelp_DeregisterPorts(g_pDPNH, pMap->hMapped[i], 0);

                if (hr != DPNH_OK)
                {
	                IMPORTANT_MSG((L"DeregisterPorts failed in ClosePort for handle 0x%x", pMap->hMapped[i]));
	                DumpLibHr(hr);
	                dwRet = ERROR_INVALID_ACCESS;
                }
		    }
		    // remove the handle from our array
		    free(g_PortHandles[dwIndex]);
		    g_PortHandles[dwIndex] = NULL;
	    }
    }
    else
        IMPORTANT_MSG((L"Bad handle passed into ClosePort!!"));

    TRIVIAL_MSG((L"ClosePort returning 0x%x", dwRet ));
    return(dwRet);
}

/****************************************************************************
**
**	FetchAllAddresses
**		Returns a string listing all the valid IP addresses for the machine
**		Formatting details:
**		1. Each address is seperated with a ";" (semicolon)
**		2. Each address consists of the "1.2.3.4", and is followed by ":p"
**		   where the colon is followed by the port number
**
****************************************************************************/

DWORD APIENTRY FetchAllAddresses(WCHAR *lpszAddr, int iBufSize)
{
	return FetchAllAddressesEx(lpszAddr, iBufSize, IPF_ADD_DNS);
}


/****************************************************************************
**
**	CloseAllPorts
**		Does just that- closes all port mappings that have been opened 
**
****************************************************************************/

DWORD APIENTRY CloseAllOpenPorts(void)
{
    DWORD   dwRet = 1;

    INTERESTING_MSG((L"CloseAllOpenPorts()" ));

    if (g_boolIcsPresent && g_pDPNH)
    {
        HRESULT hr=0;
        int i;

        // call DPNATHLP to unregister the mapping
        // then remove the handle from our array
        for (i = 0; i < ARRAYSIZE(g_PortHandles); i++)
        {
            if (g_PortHandles[i])
            {
				PMAPHANDLES pMap = g_PortHandles[i];
				int j;

				for (j = 0; j < pMap->iMapped; j++)
				{
                    hr = IDirectPlayNATHelp_DeregisterPorts(g_pDPNH, pMap->hMapped[j], 0);

					if (hr != DPNH_OK)
					{
						IMPORTANT_MSG((L"DeregisterPorts failed in CloseAllOpenPorts"));
						DumpLibHr(hr);
					}
				}
                free(g_PortHandles[i]);
                g_PortHandles[i] = 0;
            }
        }
    }

    return(dwRet);
}

/****************************************************************************
**
**	The worker thread for use with the DPHATHLP.DLL. 
**
**	This keeps the leases updated on any open
**	port assignments. Eventually, this will also check & update the sessmgr
**	when the ICS comes & goes, or when the address list changes.
**
****************************************************************************/

DWORD WINAPI DpNatHlpThread(PVOID ContextPtr)
{
	DWORD	dwRet=1;
	DWORD	dwWaitResult=WAIT_TIMEOUT;
	ULONG	ulCurIpTblSz, ulLastIpTblSz;
	long	l_waitTime = g_waitDuration;
	PMIB_IPADDRTABLE	pCurIpTbl=NULL, pLastIpTbl=NULL;

	TRIVIAL_MSG((L"DpNatHlpThread()" ));

	/*
	 *	Initialize the IP tables that we keep
	 *	Get 1 copy from IP Helper, then make a 
	 *	second local copy for later comparison.
	 */
	ulLastIpTblSz=0;
	GetIpAddrTable(NULL, &ulLastIpTblSz, FALSE);
	pLastIpTbl = (PMIB_IPADDRTABLE)malloc(ulLastIpTblSz);
	if (!pLastIpTbl)
		goto shutdown;

	if (NO_ERROR != GetIpAddrTable(pLastIpTbl, &ulLastIpTblSz, FALSE))
		IMPORTANT_MSG((L"Failed to get initial IpAddrTable in DpNatHlpThread; err=0x%x", GetLastError()));

	TRIVIAL_MSG((L"Initial IPtblSz = %d", ulLastIpTblSz));

	ulCurIpTblSz=ulLastIpTblSz;
	pCurIpTbl = (PMIB_IPADDRTABLE)malloc(ulCurIpTblSz);
	if (!pCurIpTbl)
	{
		goto shutdown;
	}
	memcpy(pCurIpTbl, pLastIpTbl, ulCurIpTblSz);

	/*
	 *	Then the 2 minute wait loop
	 */
	while(dwWaitResult == WAIT_TIMEOUT)
	{
		DWORD		dwTime;
		BOOL		bAddrChanged;

		if (dwWaitResult != WAIT_TIMEOUT)
		{
			IMPORTANT_MSG((L"error: got bad wait return in DpNatHlpThread() val=0x%x", dwWaitResult));
			goto shutdown;
		}
	
		// our default is NO CHANGE
		bAddrChanged = FALSE;

		if (NO_ERROR != GetIpAddrTable(pCurIpTbl, &ulCurIpTblSz, FALSE))
		{
			/* 
			 *	If we couldn't get the tables, it would be because the table grew
			 *	in size beyind the old one. Hmm- that must mean that the table changed
			 */
			bAddrChanged=TRUE;
			TRIVIAL_MSG((L"IpAddrTable GREW in DpNatHlpThread"));
		}
		else
		{
			/*
			 *	If the table shrunk, then it must have changed
			 */
			if (ulCurIpTblSz != ulLastIpTblSz)
			{
				bAddrChanged = TRUE;
				TRIVIAL_MSG((L"IpAddrTable SHRUNK in DpNatHlpThread"));
			}
			/*
			 *	Maybe one of the addresses in the table changed?
			 */
			if (0 != memcmp(pCurIpTbl, pLastIpTbl, ulCurIpTblSz))
			{
				bAddrChanged=TRUE;
				TRIVIAL_MSG((L"IpAddrTable CHANGED in DpNatHlpThread"));
			}
		}

		if (bAddrChanged)
		{
			TRIVIAL_MSG((L"DpNatHlpThread: IP Tables changed; cur=%d, last=%d", ulCurIpTblSz, ulLastIpTblSz));

			/* free the old tables */
			if (pCurIpTbl) free(pCurIpTbl);
			if (pLastIpTbl) free(pLastIpTbl);

			/* then get new tables */
			ulLastIpTblSz=0;
			GetIpAddrTable(NULL, &ulLastIpTblSz, FALSE);
			pLastIpTbl = (PMIB_IPADDRTABLE)malloc(ulLastIpTblSz);
			if(pLastIpTbl)
			{
				if (NO_ERROR != GetIpAddrTable(pLastIpTbl, &ulLastIpTblSz, FALSE))
					IMPORTANT_MSG((L"Failed to update IpAddrTable in DpNatHlpThread; err=0x%x", GetLastError()));

				ulCurIpTblSz=ulLastIpTblSz;
				pCurIpTbl = (PMIB_IPADDRTABLE)malloc(ulCurIpTblSz);
				memcpy(pCurIpTbl, pLastIpTbl, ulCurIpTblSz);
			}
			else
			{
				/* we got here because the machine ran out of memory 
				 *	so we will try again later to allocate the tables
				 *	maybe more memory will be free then.
				 */
				pCurIpTbl = NULL;
				pLastIpTbl = NULL;
				ulLastIpTblSz=0;
				ulCurIpTblSz=1;
				IMPORTANT_MSG((L"Failed to get memory for IP tables in DpNatHlpThread; err=0x%x", GetLastError()));
			}
		}

		if (g_pDPNH)
		{
			HRESULT hr;
			DPNHCAPS lCaps;

			/* Call GetCaps to renew all open leases */
			lCaps.dwSize = sizeof(lCaps);
			hr = IDirectPlayNATHelp_GetCaps(g_pDPNH, &lCaps, DPNHGETCAPS_UPDATESERVERSTATUS);

			if (hr == DPNH_OK)
			{
				if (lCaps.dwMinLeaseTimeRemaining)
				l_waitTime = min(g_waitDuration, (long)lCaps.dwMinLeaseTimeRemaining);
			}
			else if (hr == DPNHSUCCESS_ADDRESSESCHANGED)
				bAddrChanged = TRUE;
			else
			{
				IMPORTANT_MSG((L"GetCaps failed in NatHlpDaemon"));
				DumpLibHr(hr);
			}
		}

		if (bAddrChanged && g_hAlertEvent)
		{
			SetEvent(g_hAlertEvent);
		}

		dwWaitResult = WaitForSingleObject(g_hThreadEvent, l_waitTime);	
	}

shutdown:
	TRIVIAL_MSG((L"DpNatHlpThread shutting down"));

	/*
	 *	Then the shutdown code
	 *		free all memory
	 *		then close out DPNATHLP.DLL
	 *		and return all objects
	 */
	if (pCurIpTbl) free(pCurIpTbl);
	if (pLastIpTbl) free(pLastIpTbl);

	if (g_pDPNH)
	{
		IDirectPlayNATHelp_Close(g_pDPNH, 0);
		IDirectPlayNATHelp_Release(g_pDPNH);
	}
	g_pDPNH = NULL;
	if (g_hModDpNatHlp)
		FreeLibrary(g_hModDpNatHlp);
	g_hModDpNatHlp = 0;

	DeleteCriticalSection( &g_CritSec );
	CloseHandle(g_hThreadEvent);

	TRIVIAL_MSG((L"DpNatHlpThread() returning 0x%x", dwRet ));

	WSACleanup();

	ExitThread(dwRet);
	// of course we never get this far...
    return(dwRet);
}

/****************************************************************************
**
**	The actual worker thread. This keeps the leases updated on any open
**	port assignments. This will also check & update the sessmgr
**	when the ICS comes & goes, or when the address list changes.
**
****************************************************************************/

DWORD WINAPI RsipDaemonThread(PVOID ContextPtr)
{
	DWORD	dwRet=1;
	DWORD	dwWaitResult=WAIT_TIMEOUT;
	ULONG	ulCurIpTblSz, ulLastIpTblSz;
	PMIB_IPADDRTABLE	pCurIpTbl=NULL, pLastIpTbl=NULL;

	TRIVIAL_MSG((L"RsipDaemonThread()" ));

	/*
	 *	Initialize the IP tables that we keep
	 *	Get 1 copy from IP Helper, then make a 
	 *	second local copy for later comparison.
	 */
	ulLastIpTblSz=0;
	GetIpAddrTable(NULL, &ulLastIpTblSz, FALSE);
	pLastIpTbl = (PMIB_IPADDRTABLE)malloc(ulLastIpTblSz);
	if (NO_ERROR != GetIpAddrTable(pLastIpTbl, &ulLastIpTblSz, FALSE))
		IMPORTANT_MSG((L"Failed to get initial IpAddrTable in RsipDaemonThread; err=0x%x", GetLastError()));

	TRIVIAL_MSG((L"Initial IPtblSz = %d", ulLastIpTblSz));

	ulCurIpTblSz=ulLastIpTblSz;
	pCurIpTbl = (PMIB_IPADDRTABLE)malloc(ulCurIpTblSz);
	if (!pCurIpTbl)
		goto shutdown;

	memcpy(pCurIpTbl, pLastIpTbl, ulCurIpTblSz);

	/*
	 *	Then the 2 minute wait loop
	 */
	while(dwWaitResult == WAIT_TIMEOUT)
	{
		DWORD		dwTime;
		BOOL		bAddrChanged;

		if (dwWaitResult != WAIT_TIMEOUT)
		{
			IMPORTANT_MSG((L"error: got bad wait return in RsipDaemonThread() val=0x%x", dwWaitResult));
			goto shutdown;
		}
	
		// our default is NO CHANGE
		bAddrChanged = FALSE;

		if (NO_ERROR != GetIpAddrTable(pCurIpTbl, &ulCurIpTblSz, FALSE))
		{
			/* 
			 *	If we couldn't get the tables, it would be because the table grew
			 *	in size beyind the old one. Hmm- that must mean that the table changed
			 */
			bAddrChanged=TRUE;
			TRIVIAL_MSG((L"IpAddrTable GREW in RsipDaemonThread"));
		}
		else
		{
			/*
			 *	If the table shrunk, then it must have changed
			 */
			if (ulCurIpTblSz != ulLastIpTblSz)
			{
				bAddrChanged = TRUE;
				TRIVIAL_MSG((L"IpAddrTable SHRUNK in RsipDaemonThread"));
			}
			/*
			 *	Maybe one of the addresses in the table changed?
			 */
			if (0 != memcmp(pCurIpTbl, pLastIpTbl, ulCurIpTblSz))
			{
				bAddrChanged=TRUE;
				TRIVIAL_MSG((L"IpAddrTable CHANGED in RsipDaemonThread"));
			}
		}

		if (bAddrChanged)
		{
			TRIVIAL_MSG((L"RsipDaemonThread: IP Tables changed; cur=%d, last=%d", ulCurIpTblSz, ulLastIpTblSz));

			/* free the old tables */
			if (pCurIpTbl) free(pCurIpTbl);
			if (pLastIpTbl) free(pLastIpTbl);

			/* then get new tables */
			ulLastIpTblSz=0;
			GetIpAddrTable(NULL, &ulLastIpTblSz, FALSE);
			pLastIpTbl = (PMIB_IPADDRTABLE)malloc(ulLastIpTblSz);
			if(pLastIpTbl)
			{
				if (NO_ERROR != GetIpAddrTable(pLastIpTbl, &ulLastIpTblSz, FALSE))
					IMPORTANT_MSG((L"Failed to update IpAddrTable in RsipDaemonThread; err=0x%x", GetLastError()));

				ulCurIpTblSz=ulLastIpTblSz;
				pCurIpTbl = (PMIB_IPADDRTABLE)malloc(ulCurIpTblSz);
				memcpy(pCurIpTbl, pLastIpTbl, ulCurIpTblSz);
			}
			else
			{
				/* we got here because the machine ran out of memory 
				 *	so we will try again later to allocate the tables
				 *	maybe more memory will be free then.
				 */
				pCurIpTbl = NULL;
				pLastIpTbl = NULL;
				ulLastIpTblSz=0;
				ulCurIpTblSz=1;
				IMPORTANT_MSG((L"Failed to get memory for IP tables in RsipDaemonThread; err=0x%x", GetLastError()));
			}
		}

		if (g_boolIcsPresent)
		{
			PRSIP_LEASE_RECORD pLeaseRecord;

			// update the leases
			dwTime = timeGetTime();
			if (!PortExtend( dwTime ) && g_hAlertEvent)
			{
				// If we cannot extend the lease, then we must notify the user
				TRIVIAL_MSG((L"Sending RSIP alert event from RsipDaemonThread"));
				bAddrChanged = TRUE;
			}

			CacheClear( dwTime );

			if (g_iPort && 	(pLeaseRecord = FindLease( TRUE, htons((WORD)g_iPort) )))
			{
				/* .
				 *	We got here because there are open leases. That means we must
				 *	periodically check to see if the public address has changed.
				 *	This would happen if the ICS's modem got disconnected or
				 *	reconnected. In the first case, we no longer have a valid public
				 *	address, in the second case we have a new public address.
				 */

				SOCKADDR_IN	saddrPublic, saddrNew;
				DWORD	dwBindId = 0;
				DWORD	dwSpewSave;

				saddrPublic.sin_family = AF_INET;
				saddrPublic.sin_addr.s_addr = pLeaseRecord->addrV4;
				saddrPublic.sin_port        = pLeaseRecord->rport;

				dwSpewSave = gDbgFlag;
				gDbgFlag |= 3;

				/*
				 *	The basic algorithm for this is to ask for a new port mapping
				 *	and compare the address to what we already have. I chose to ask
				 *	for a port that will never be mapped onto a MS PC- the Sun
				 *	RPC port. This should always be available to us, as no
				 *	smart gamer will use this port.
				 *	It should not cause us any security problems, as the OS never
				 *	has any sockets open & listening on that port. Besides, the 
				 *	port mapping is only valid for ~500 mSec- not long enough to cause
				 *	any real mischief.
				 *	BTW, this algorithm workd on WinME ICS servers as well.
				 */
				if (S_OK == AssignPort( TRUE, htons(111), (SOCKADDR *)&saddrNew, &dwBindId ))
				{
					// free the port mapping, as all we care about is the public address
					FreePort(dwBindId);
					gDbgFlag = dwSpewSave;

					// check for invalid address (modem probably disconnected)
					if (!saddrNew.sin_addr.s_addr)
					{
						TRIVIAL_MSG((L"Public address all zeros- no longer on Internet"));

						/*
						 *	How should this be handled? 
						 *	Well, if we notify Salem, then they will try to update the ticket.
						 *	but that may cause more trouble, as that would cause a reconnect
						 *	which would then cause another address change, which would cause
						 *	a second ticket update.
						 *
						 *	We certainly should try to maintain the current leases, in case 
						 *	the connection returns.
						 */
//						bAddrChanged=TRUE;
					}
					else if (saddrNew.sin_addr.s_addr != saddrPublic.sin_addr.s_addr)
					{
						// change the public address in all the leases...
						RSIP_LEASE_RECORD	*pLeaseWalker;
						RSIP_LEASE_RECORD	*pNextLease;

						TRIVIAL_MSG((L"==> public address changed: OLD, then NEW address <=="));
						DumpSocketAddress( 8, (SOCKADDR *)&saddrPublic, AF_INET );
						DumpSocketAddress( 8, (SOCKADDR *)&saddrNew, AF_INET );

						pLeaseWalker = g_pRsipLeaseRecords;
						while( pLeaseWalker )
						{
							pNextLease = pLeaseWalker->pNext;

							// copy the address
							pLeaseWalker->addrV4 = saddrNew.sin_addr.s_addr;
							pLeaseWalker=pNextLease;
						}
						bAddrChanged=TRUE;
					}
				}
				else
				{
					gDbgFlag = dwSpewSave;

					IMPORTANT_MSG((L"AssignPort failed in daemon thread"));

					// Hmmm- we can't get to the ICS server any longer
					bAddrChanged=TRUE;
					// delete all open mappings
					CloseAllOpenPorts();
				}
			}
		}

		if (bAddrChanged && g_hAlertEvent)
		{
			SetEvent(g_hAlertEvent);
		}

		dwWaitResult = WaitForSingleObject(g_hThreadEvent, g_waitDuration);	
	}

shutdown:
	TRIVIAL_MSG((L"RsipDaemonThread shutting down"));

	/*
	 *	Then the shutdown code
	 *		release any open ports
	 */
	if (pCurIpTbl) free(pCurIpTbl);
	if (pLastIpTbl) free(pLastIpTbl);

	Deinitialize();
	DeleteCriticalSection( &g_CritSec );
	CloseHandle(g_hThreadEvent);

	TRIVIAL_MSG((L"RsipDaemonThread() returning 0x%x", dwRet ));

	WSACleanup();

	ExitThread(dwRet);
	// of course we never get this far...
    return(dwRet);
}

/****************************************************************************
**
**	This should initialize the ICS library for use with the DirectPlay
**	ICS/NAT helper DLL.
**	All will happen in this order:
**		1. Call DirectPlayNATHelpCreate()
**		2. Call IDirectPlayNATHelp::Initialize to prepare the object
**
****************************************************************************/
DWORD StartDpNatHlp(void)
{
	DWORD dwRet = ERROR_CALL_NOT_IMPLEMENTED;
	HRESULT hr;
	HMODULE	hMod;
	PFN_DIRECTPLAYNATHELPCREATE pfnDirectPlayNATHelpCreate;
	PDIRECTPLAYNATHELP pDirectPlayNATHelp = NULL;
	DPNHCAPS dpnhCaps;
	PSUPDLLS	pDll = &strDpHelp[0];

try_again:
	TRIVIAL_MSG((L"starting StartDpNatHlp for %S (%S)", pDll->szDllName, pDll->bUsesUpnp?"UPnP":"PAST"));

	// start out with no public address
	g_szPublicAddr[0] = 0;

	hMod = LoadLibraryA(pDll->szDllName);
	if (!hMod)
	{
		IMPORTANT_MSG((L"ERROR:%S could not be found", pDll->szDllName));
		pDll++;
		if (!pDll->szDllName)
		{
			dwRet = ERROR_FILE_NOT_FOUND;
			goto done;
		}
		goto try_again;
	}

	pfnDirectPlayNATHelpCreate = (PFN_DIRECTPLAYNATHELPCREATE) GetProcAddress(hMod, "DirectPlayNATHelpCreate");
	if (!pfnDirectPlayNATHelpCreate)
	{
		IMPORTANT_MSG((L"\"DirectPlayNATHelpCreate\" proc in %S could not be found", pDll->szDllName));
		dwRet = ERROR_INVALID_FUNCTION;
		goto done;
	}

	hr = pfnDirectPlayNATHelpCreate(&IID_IDirectPlayNATHelp,
				(void**) (&pDirectPlayNATHelp));
	if (hr != DPNH_OK)
	{
		IMPORTANT_MSG((L"DirectPlayNATHelpCreate failed in %S", pDll->szDllName));
		DumpLibHr(hr);
		dwRet = ERROR_BAD_UNIT;
		goto done;
	}

	hr = IDirectPlayNATHelp_Initialize(pDirectPlayNATHelp, 0);
	if (hr != DPNH_OK)
	{
		IMPORTANT_MSG((L"IDirectPlayNATHelp_Initialize failed in %S", pDll->szDllName));
		DumpLibHr(hr);
		dwRet = ERROR_BAD_UNIT;
		goto done;
	}

	/* Get capabilities of NAT/RSIP/PAST server */
	dpnhCaps.dwSize = sizeof(dpnhCaps);
	hr = IDirectPlayNATHelp_GetCaps(pDirectPlayNATHelp, &dpnhCaps, DPNHGETCAPS_UPDATESERVERSTATUS);
	if (hr != DPNH_OK && hr != DPNHSUCCESS_ADDRESSESCHANGED)
	{
		IMPORTANT_MSG((L"IDirectPlayNATHelp_GetCaps failed"));
		DumpLibHr(hr);
		dwRet = ERROR_BAD_UNIT;
		goto done;
	}

	if (dpnhCaps.dwFlags & (DPNHCAPSFLAG_LOCALFIREWALLPRESENT | DPNHCAPSFLAG_GATEWAYPRESENT))
	{
		PIP_ADAPTER_INFO pAdpInfo = NULL;
		SOCKADDR_IN	saddrOurLAN;
		PMIB_IPADDRTABLE pmib=NULL;
		ULONG ulSize = 0;
		DWORD dw;

		g_boolIcsPresent = TRUE;

		TRIVIAL_MSG((L"ICS server found using %S", pDll->szDllName));

		g_lpszDllName = pDll->szDllName;

		// copy this pointer where it will do us some good
		g_pDPNH = pDirectPlayNATHelp;
		g_boolUsingNatHelp = TRUE;
		g_boolUsingNatPAST = pDll->bUsesUpnp;
		dwRet = ERROR_SUCCESS;

		// is this machine an ICS host?
		if (dpnhCaps.dwFlags & (DPNHCAPSFLAG_LOCALFIREWALLPRESENT | DPNHCAPSFLAG_GATEWAYISLOCAL))
			g_boolIcsOnThisMachine = TRUE;

		ZeroMemory(&saddrOurLAN, sizeof(saddrOurLAN));
		saddrOurLAN.sin_family = AF_INET;

		dw = GetAdaptersInfo(
			pAdpInfo,
			&ulSize );
		if (dw == ERROR_BUFFER_OVERFLOW && ulSize)
		{
			pAdpInfo = (IP_ADAPTER_INFO*)malloc(ulSize);

			if (!pAdpInfo)
				goto done;

			dw = GetAdaptersInfo(
				pAdpInfo,
				&ulSize);
			if (dw == ERROR_SUCCESS)
			{
				PIP_ADAPTER_INFO p;
				PIP_ADDR_STRING ps;

				for(p=pAdpInfo; p!=NULL; p=p->Next)
				{

				   for(ps = &(p->IpAddressList); ps; ps=ps->Next)
					{
						if (strcmp(ps->IpAddress.String, "0.0.0.0") != 0)
						{
							// blah blah blah
							saddrOurLAN.sin_addr.S_un.S_addr = inet_addr(ps->IpAddress.String);
							TRIVIAL_MSG((L"Initializing RSIP to LAN adapter at [%S]", ps->IpAddress.String));
							goto doit;
						}
					}
				}

			}
		}
doit:
		memcpy(&g_saddrLocal, &saddrOurLAN, sizeof(saddrOurLAN));

		// Does the ICS have a public address?
		if ( 1 )
		{
			/* then we will discover the public address */
			DPNHHANDLE	dpHnd;

			saddrOurLAN.sin_port = ntohs(3389);

			/* first we ask for a new mapping */
			hr = IDirectPlayNATHelp_RegisterPorts(g_pDPNH, 
					(SOCKADDR *)&saddrOurLAN, sizeof(saddrOurLAN), 1,
					30000, &dpHnd, DPNHREGISTERPORTS_TCP);
			if (hr != DPNH_OK)
			{
				IMPORTANT_MSG((L"IDirectPlayNATHelp_RegisterPorts failed in StartDpNatHlp"));
				DumpLibHr(hr);
			}
			else
			{
				/* we succeeded, so query for the address */
				SOCKADDR_IN	lsi;
				DWORD dwSize, dwTypes;

				TRIVIAL_MSG((L"IDirectPlayNATHelp_RegisterPorts Assigned: 0x%x", dpHnd));

				dwSize = sizeof(lsi);
				ZeroMemory(&lsi, dwSize);

				hr = IDirectPlayNATHelp_GetRegisteredAddresses(g_pDPNH, dpHnd, (SOCKADDR *)&lsi, 
								&dwSize, &dwTypes, NULL, 0, );
				if (hr == DPNH_OK && dwSize)
				{
					wsprintfA(g_szPublicAddr, "%d.%d.%d.%d",
						lsi.sin_addr.S_un.S_un_b.s_b1,
						lsi.sin_addr.S_un.S_un_b.s_b2,
						lsi.sin_addr.S_un.S_un_b.s_b3,
						lsi.sin_addr.S_un.S_un_b.s_b4);

					TRIVIAL_MSG((L"Public Address=[%S]", g_szPublicAddr ));
				}
				else
				{
					IMPORTANT_MSG((L"GetRegisteredAddresses[0x%x] failed, size=0x%x", dpHnd, dwSize));
					DumpLibHr(hr);
				}
				/* close out the temp port we got */
				hr = IDirectPlayNATHelp_DeregisterPorts(g_pDPNH, dpHnd, 0);

				if (hr != DPNH_OK)
				{
					IMPORTANT_MSG((L"DeregisterPorts failed in ClosePort"));
					DumpLibHr(hr);
					dwRet = ERROR_INVALID_ACCESS;
				}
			}
		}
	}
	else
	{
		hr = IDirectPlayNATHelp_Close(pDirectPlayNATHelp, 0);

		if (hr != DPNH_OK)
		{
			IMPORTANT_MSG((L"IDirectPlayNATHelp_Close failed"));
			DumpLibHr(hr);
		}
		hr = IDirectPlayNATHelp_Release(pDirectPlayNATHelp);
		if (hr != DPNH_OK)
		{
			IMPORTANT_MSG((L"IDirectPlayNATHelp_Release failed"));
			DumpLibHr(hr);
		}

		pDll++;
		if (pDll->szDllName)
		{
			if (hMod) FreeLibrary(hMod);
			hMod = 0;
			goto try_again;
		}
		g_pDPNH = NULL;
		g_boolUsingNatHelp = FALSE;
		dwRet = ERROR_BAD_UNIT;
	}
done:
	if (dwRet != ERROR_SUCCESS)
	{
		if (hMod) 
			FreeLibrary(hMod);
		hMod = 0;
	}

	TRIVIAL_MSG((L"done with StartDpNatHlp, result=0x%x", dwRet));
	// save hMod so we can close it out in StopICSLibrary
	g_hModDpNatHlp = hMod;
	return dwRet;
};

/****************************************************************************
**
**	The first call to be made into this library. It is responsible for
**	starting up all worker threads, initializing all memory and libs,
**	and starting up the DPHLPAPI.DLL function (if found).
**
****************************************************************************/

DWORD APIENTRY StartICSLib(void)
{
	WSADATA	WsaData;
	DWORD	dwThreadId;
	HANDLE	hEvent, hThread;
	HKEY	hKey;
	int sktRet;

	// open reg key first, to get ALL the spew...
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\ICSHelper", 0, KEY_READ, &hKey))
	{
		DWORD	dwSize;

		dwSize = sizeof(gDbgFlag);
		RegQueryValueEx(hKey, L"DebugSpew", NULL, NULL, (LPBYTE)&gDbgFlag, &dwSize);

		g_waitDuration = 0;
		dwSize = sizeof(g_waitDuration);
		RegQueryValueEx(hKey, L"RetryTimeout", NULL, NULL, (LPBYTE)&g_waitDuration, &dwSize);
	
		if (g_waitDuration)
			g_waitDuration *= 1000;
		else
			g_waitDuration = 120000;

		RegCloseKey(hKey);
	}
	// should we create a debug log file?
	if (gDbgFlag & DBG_MSG_DEST_FILE)
	{
		WCHAR szLogfileName[MAX_PATH];

		GetSystemDirectory(szLogfileName, sizeof(szLogfileName)/sizeof(szLogfileName[0]));
		lstrcat(szLogfileName, L"\\SalemICSHelper.log");

		iDbgFileHandle = _wopen(szLogfileName, _O_APPEND | _O_BINARY | _O_RDWR, 0);
		if (-1 != iDbgFileHandle)
		{
			OutputDebugStringA("opened debug log file\n");
		}
		else
		{
			unsigned char UniCode[2] = {0xff, 0xfe};

			// we must create the file
			OutputDebugStringA("must create debug log file");
			iDbgFileHandle = _wopen(szLogfileName, _O_BINARY | _O_CREAT | _O_RDWR, _S_IREAD | _S_IWRITE);
			if (-1 != iDbgFileHandle)
				_write(iDbgFileHandle, &UniCode, sizeof(UniCode));
			else
			{
				OutputDebugStringA("ERROR: failed to create debug log file");
				iDbgFileHandle = 0;
			}
		}
	}

	g_iPort = GetTsPort();

	TRIVIAL_MSG((L"StartICSLib()" ));

	ZeroMemory(g_PortHandles, sizeof(g_PortHandles));

	if (g_boolInitialized)
	{
		HEINOUS_E_MSG((L"ERROR: StartICSLib called twice"));
		return ERROR_INVALID_PARAMETER;
	}
	else
		g_boolInitialized = TRUE;

	// of course, this must be done...
	InitializeCriticalSection(&g_CritSec);

	// create an event for later use by the daemon thread
	hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

	if (!hEvent)
	{
		IMPORTANT_MSG((L"Could not create an event for RSIP worker thread, err=0x%x", GetLastError()));
		return GetLastError();
	}

	g_hThreadEvent = hEvent;

	if (0 != WSAStartup(MAKEWORD(2,2), &WsaData))
	{
		if (0 != (sktRet = WSAStartup(MAKEWORD(2,0), &WsaData)))
		{
			IMPORTANT_MSG((L"WSAStartup failed:"));
			return sktRet;
		}
	}

	if (ERROR_SUCCESS == StartDpNatHlp())
	{

		// start RSIP daemon process, which will do all the work
		hThread = CreateThread( NULL,		// SD- not needed
								0,			// Stack Size
								(LPTHREAD_START_ROUTINE)DpNatHlpThread,
								NULL,
								0,
								&dwThreadId );
	}
	else
	{
		// start up RSIP lib
		g_szPublicAddr[0]=0;
		if (RsipIsRunningOnThisMachine( &g_saddrPublic ))
		{
			// makes casting easier
			SOCKADDR_IN	*pPubAddr = (SOCKADDR_IN*)( &g_saddrPublic );

			g_boolIcsPresent = g_boolIcsOnThisMachine = TRUE;

			// save the public side address so that we can filter it out
			// of the address list we return
			wsprintfA(g_szPublicAddr,  "%d.%d.%d.%d",
					pPubAddr->sin_addr.S_un.S_un_b.s_b1, 
					pPubAddr->sin_addr.S_un.S_un_b.s_b2, 
					pPubAddr->sin_addr.S_un.S_un_b.s_b3, 
					pPubAddr->sin_addr.S_un.S_un_b.s_b4);
			INTERESTING_MSG((L"PAST Host is local- public address is [%S]", &g_szPublicAddr));
		}
		else
		{
			SOCKADDR_IN	saddrOurLAN;
			PMIB_IPADDRTABLE pmib=NULL;
			ULONG ulSize = 0;
			DWORD dw;
			PIP_ADAPTER_INFO pAdpInfo = NULL;

			ZeroMemory(&saddrOurLAN, sizeof(saddrOurLAN));
			saddrOurLAN.sin_family = AF_INET;

			dw = GetAdaptersInfo(
				pAdpInfo,
				&ulSize );
			if (dw == ERROR_BUFFER_OVERFLOW && ulSize)
			{
				pAdpInfo = (IP_ADAPTER_INFO*)malloc(ulSize);

				if (!pAdpInfo)
					goto done;

				dw = GetAdaptersInfo(
					pAdpInfo,
					&ulSize);
				if (dw == ERROR_SUCCESS)
				{
					PIP_ADAPTER_INFO p;
					PIP_ADDR_STRING ps;

					for(p=pAdpInfo; p!=NULL; p=p->Next)
					{

					   for(ps = &(p->IpAddressList); ps; ps=ps->Next)
						{
							if (strcmp(ps->IpAddress.String, "0.0.0.0") != 0)
							{
								// blah blah blah
								saddrOurLAN.sin_addr.S_un.S_addr = inet_addr(ps->IpAddress.String);
								TRIVIAL_MSG((L"Initializing RSIP to LAN adapter at [%S]", ps->IpAddress.String));
								goto doit;
							}
						}
					}

				}
			}
	doit:
			g_boolIcsPresent = Initialize((SOCKADDR *)&saddrOurLAN, FALSE);

			if (g_boolIcsPresent)
			{
				DWORD		dwBindID=0;
				SOCKADDR	saddrAssigned;

				if (S_OK == AssignPort( FALSE, 6969, &saddrAssigned, &dwBindID ))
				{
					// free the port, since we just wanted the public IP address				
					FreePort( dwBindID );
					wsprintfA(g_szPublicAddr,  "%d.%d.%d.%d",
							(UCHAR)saddrAssigned.sa_data[2], 
							(UCHAR)saddrAssigned.sa_data[3], 
							(UCHAR)saddrAssigned.sa_data[4], 
							(UCHAR)saddrAssigned.sa_data[5]);
					INTERESTING_MSG((L"PAST Host is NOT local- public address is [%S]", &g_szPublicAddr));
				}
				else
				{
					IMPORTANT_MSG((L"Failed to assign port when attempting to determine public network address!" ));
				}

			}
		}
done:
		g_lpszDllName = szInternal;

		// start RSIP daemon process, which will do all the work
		hThread = CreateThread( NULL,		// SD- not needed
								0,			// Stack Size
								(LPTHREAD_START_ROUTINE)RsipDaemonThread,
								NULL,
								0,
								&dwThreadId );
	}
	if (!hThread)
	{
		IMPORTANT_MSG((L"Could not create RSIP worker thread, err=0x%x", GetLastError()));
		return GetLastError();
	}

	// save this for later, as we need it in the close function
	g_hWorkerThread = hThread;

	TRIVIAL_MSG((L"StartICSLib() returning ERROR_SUCCESS"));

    return(ERROR_SUCCESS);
}


/****************************************************************************
**
**	The last call to be made into this library. Do not call any other 
**	functiopn in this library after you call this!
**
****************************************************************************/

DWORD APIENTRY StopICSLib(void)
{
	DWORD	dwRet = ERROR_SUCCESS;
	DWORD	dwTmp;

	TRIVIAL_MSG((L"StopICSLib()" ));

	// signal the worker thread, so that it will do a shutdown
	SetEvent(g_hThreadEvent);

	// then wait for it to shutdown.
	dwTmp = WaitForSingleObject(g_hWorkerThread, 15000);

	if (dwTmp == WAIT_OBJECT_0)
		TRIVIAL_MSG((L"ICS worker thread closed down normally"));
	else if (dwTmp == WAIT_ABANDONED)
		IMPORTANT_MSG((L"ICS worker thread did not complete in 15 seconds"));
	else
		IMPORTANT_MSG((L"WaitForWorkerThread failed"));

	CloseHandle(g_hWorkerThread);

	TRIVIAL_MSG((L"StopICSLib() returning 0x%x", dwRet ));

	_close(iDbgFileHandle);
	g_boolInitialized = FALSE;
    return(dwRet);
}

/****************************************************************************
**
**	SetAlertEvent
**		Pass in an event handle. Then, whenever the ICS changes state, I
**		will signal that event.
**
****************************************************************************/

DWORD APIENTRY SetAlertEvent(HANDLE hEvent)
{
	TRIVIAL_MSG((L"SetAlertEvent(0x%x)", hEvent));

	g_hAlertEvent = hEvent;

    return 1;
}


/****************************************************************************
**
**		Address String Compression routines
**
*****************************************************************************
**
**	The following is a group of routines designed to compress and expand
**	IPV4 addresses into the absolute minimum size possible. This is to
**	provide a compressed ASCII string that can be parsed using standard
**	shell routines for command line parsing.
**	The compressed string has the following restrictions:
**		-> Must not expand to more characters if UTF8 encoded.
**		-> Must not contain the NULL character so that string libs work.
**		-> Cannot contain double quote character, the shell needs that.
**		-> Does not have to be human readable.
**
**	Data Types:
**	There are three data types used here:
**	szAddr		The orginal IPV4 string address ("X.X.X.X:port")
**	blobAddr	Six byte struct with 4 bytes of address, and 2 bytes of port
**	szComp		Eight byte ascii string of compressed IPV4 address
**
****************************************************************************/

#define COMP_OFFSET '#'
#define COMP_SEPERATOR	'!'

#pragma pack(push,1)

typedef struct _BLOB_ADDR {
	UCHAR	addr_d;		// highest order address byte
	UCHAR	addr_c;
	UCHAR	addr_b;
	UCHAR	addr_a;		// lowest order byte (last in IP string address)
	WORD	port;
} BLOB_ADDR, *PBLOB_ADDR;

#pragma pack(pop)

WCHAR	b64Char[64]={
'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
'0','1','2','3','4','5','6','7','8','9','+','/'
};

void DumpBlob(PBLOB_ADDR pba)
{
	UCHAR	*lpa;

	lpa = (UCHAR *)pba;

	TRIVIAL_MSG((L"blob (hex): %x,%x,%x,%x,%x,%x", *lpa, *(lpa+1), *(lpa+2), *(lpa+3), *(lpa+4), *(lpa+5)));
	TRIVIAL_MSG((L"  (struct): %x,%x,%x,%x:%x", pba->addr_d, pba->addr_c, pba->addr_b, pba->addr_a, pba->port));
	TRIVIAL_MSG((L"      (IP): %d.%d.%d.%d:%d", pba->addr_d, pba->addr_c, pba->addr_b, pba->addr_a, pba->port));
}

/****************************************************************************
**	char * atob(char *szVal, UCHAR *result)
****************************************************************************/
WCHAR *atob(WCHAR *szVal, UCHAR *result)
{
	WCHAR	*lptr;
	WCHAR	ucb;
	UCHAR	foo;
	
	if (!result || !szVal)
	{
		IMPORTANT_MSG((L"ERROR: NULL ptr passed in atob"));
		return NULL;
	}
	// start ptr at the beginning of string
	lptr = szVal;
	foo = 0;
	ucb = *lptr++ - '0';

	while (ucb >= 0 && ucb <= 9)
	{
		foo *= 10;
		foo += ucb;
		ucb = (*lptr++)-'0';
	}

	*result = (UCHAR)foo;
	return lptr;
}

/****************************************************************************
**
**	CompressAddr(pszAddr, pblobAddr);
**		Takes an ascii IP address (X.X.X.X:port) and converts it to a
**		6 byte binary blob.
**
**	returns TRUE for success, FALSE for failure.
**
****************************************************************************/

BOOL CompressAddr(WCHAR *pszAddr, PBLOB_ADDR pblobAddr)
{
	BLOB_ADDR	lblob;
	WCHAR		*lpsz;

	if (!pszAddr || !pblobAddr) 
	{
		IMPORTANT_MSG((L"ERROR: NULL ptr passed in CompressAddr"));
		return FALSE;
	}

	lpsz = pszAddr;

	lpsz = atob(lpsz, &lblob.addr_d);
	if (*(lpsz-1) != '.')
	{
		IMPORTANT_MSG((L"ERROR: bad address[0] passed in CompressAddr for %s", pszAddr));
		return FALSE;
	}

	lpsz = atob(lpsz, &lblob.addr_c);
	if (*(lpsz-1) != '.')
	{
		IMPORTANT_MSG((L"ERROR: bad address[1] passed in CompressAddr"));
		return FALSE;
	}

	lpsz = atob(lpsz, &lblob.addr_b);
	if (*(lpsz-1) != '.')
	{
		IMPORTANT_MSG((L"ERROR: bad address[2] passed in CompressAddr"));
		return FALSE;
	}

	lpsz = atob(lpsz, &lblob.addr_a);

	// is there a port number here?
	if (*(lpsz-1) == ':')
		lblob.port = (WORD)_wtoi(lpsz);
	else
		lblob.port = 0;

	// copy back the result
	memcpy(pblobAddr, &lblob, sizeof(*pblobAddr));
    return TRUE;
}

/****************************************************************************
**
**	ExpandAddr(pszAddr, pblobAddr);
**		Takes 6 byte binary blob and converts it into an ascii IP 
**		address (X.X.X.X:port) 
**
**	returns TRUE for success, FALSE for failure.
**
****************************************************************************/

BOOL ExpandAddr(WCHAR *pszAddr, PBLOB_ADDR pba)
{
	if (!pszAddr || !pba) 
	{
		IMPORTANT_MSG((L"ERROR: NULL ptr passed in ExpandAddr"));
		return FALSE;
	}

	wsprintf(pszAddr, L"%d.%d.%d.%d", pba->addr_d, pba->addr_c,
		pba->addr_b, pba->addr_a);
	if (pba->port)
	{
		WCHAR	scratch[8];
		wsprintf(scratch, L":%d", pba->port);
		wcscat(pszAddr, scratch);
	}

	return TRUE;
}

/****************************************************************************
**
**	AsciifyAddr(pszAddr, pblobAddr);
**		Takes 6 byte binary blob and converts it into compressed ascii
**		will return either 6 or 8 bytes of string
**
**	returns TRUE for success, FALSE for failure.
**
****************************************************************************/

BOOL AsciifyAddr(WCHAR *pszAddr, PBLOB_ADDR pba)
{
	UCHAR		tmp;
	DWORDLONG	dwl;
	int			i, iCnt;

	if (!pszAddr || !pba) 
	{
		IMPORTANT_MSG((L"ERROR: NULL ptr passed in AsciifyAddr"));
		return FALSE;
	}

	iCnt = 6;
	if (pba->port)
		iCnt = 8;

	dwl = 0;
	memcpy(&dwl, pba, sizeof(*pba));

	for (i = 0; i < iCnt; i++)
	{
		// get 6 bits of data
		tmp = (UCHAR)(dwl & 0x3f);
		// add the offset to asciify this
		// offset must be bigger the double-quote char.
		pszAddr[i] = b64Char[tmp];			// (WCHAR)(tmp + COMP_OFFSET);

		// Shift right 6 bits
		dwl = Int64ShrlMod32(dwl, 6);
	}
	// terminating NULL
	pszAddr[iCnt] = 0;

	return TRUE;
}

/****************************************************************************
**
**	DeAsciifyAddr(pszAddr, pblobAddr);
**		Takes a compressed ascii string and converts it into a 
**		6  or 8 byte binary blob
**
**	returns TRUE for success, FALSE for failure.
**
****************************************************************************/

BOOL DeAsciifyAddr(WCHAR *pszAddr, PBLOB_ADDR pba)
{
	UCHAR	tmp;
	WCHAR	wtmp;
	DWORDLONG	dwl;
	int			i;
	int  iCnt;

	if (!pszAddr || !pba) 
	{
		IMPORTANT_MSG((L"ERROR: NULL ptr passed in DeAsciifyAddr"));
		return FALSE;
	}

	/* how long is this string?
	 *	if it is 6 bytes, then there is no port
	 *	else it should be 8 bytes
	 */
	i = wcslen(pszAddr);
	if (i == 6 || i == 8)
		iCnt = i;
	else
	{
		iCnt = 8;
		IMPORTANT_MSG((L"Strlen (%d) is wrong in DeAsciifyAddr", i));
	}

	dwl = 0;
	for (i = iCnt-1; i >= 0; i--)
	{
		wtmp = pszAddr[i];

		if (wtmp >= L'A' && wtmp <= L'Z')
			tmp = wtmp - L'A';
		else if  (wtmp >= L'a' && wtmp <= L'z')
			tmp = wtmp - L'a' + 26;
		else if  (wtmp >= L'0' && wtmp <= L'9')
			tmp = wtmp - L'0' + 52;
		else if (wtmp == L'+')
			tmp = 62;
		else if (wtmp == L'/')
			tmp = 63;
		else
		{
			tmp = 0;
			HEINOUS_E_MSG((L"ERROR:found invalid character in decode stream"));
		}

//		tmp = (UCHAR)(pszAddr[i] - COMP_OFFSET);

		if (tmp > 63)
		{
			tmp = 0;
			HEINOUS_E_MSG((L"ERROR:screwup in DeAsciify"));
		}

		dwl = Int64ShllMod32(dwl, 6);
		dwl |= tmp;
	}

	memcpy(pba, &dwl, sizeof(*pba));
	return TRUE;
}

/****************************************************************************
**
**	SquishAddress(char *szIp, char *szCompIp)
**		Takes one IP address and compresses it to minimum size
**
****************************************************************************/

DWORD APIENTRY SquishAddress(WCHAR *szIp, WCHAR *szCompIp)
{
	WCHAR	*thisAddr, *nextAddr;
	BLOB_ADDR	ba;

	if (!szIp || !szCompIp)
	{
		HEINOUS_E_MSG((L"SquishAddress called with NULL ptr"));
		return ERROR_INVALID_PARAMETER;
	}

//	TRIVIAL_MSG((L"SquishAddress(%s)", szIp));

	thisAddr = szIp;
	szCompIp[0] = 0;

	while (thisAddr)
	{
		WCHAR	scr[10];

		nextAddr = wcschr(thisAddr, L';');
		if (nextAddr && *(nextAddr+1)) 
		{
			*nextAddr = 0;
		}
		else
			nextAddr=0;

		CompressAddr(thisAddr, &ba);
//		DumpBlob(&ba);
		AsciifyAddr(scr, &ba);

		wcscat(szCompIp, scr);

		if (nextAddr)
		{
			// restore seperator found earlier
			*nextAddr = ';';

			nextAddr++;
			wcscat(szCompIp, L"!" /* COMP_SEPERATOR */);
		}
		thisAddr = nextAddr;
	}

//	TRIVIAL_MSG((L"SquishAddress returns [%s]", szCompIp));
    return ERROR_SUCCESS;
}


/****************************************************************************
**
**	ExpandAddress(char *szIp, char *szCompIp)
**		Takes a compressed IP address and returns it to
**		"normal"
**
****************************************************************************/

DWORD APIENTRY ExpandAddress(WCHAR *szIp, WCHAR *szCompIp)
{
	BLOB_ADDR	ba;
	WCHAR	*thisAddr, *nextAddr;

	if (!szIp || !szCompIp)
	{
		HEINOUS_E_MSG((L"ExpandAddress called with NULL ptr"));
		return ERROR_INVALID_PARAMETER;
	}

//	TRIVIAL_MSG((L"ExpandAddress(%s)", szCompIp));

	thisAddr = szCompIp;
	szIp[0] = 0;

	while (thisAddr)
	{
		WCHAR scr[32];

		nextAddr = wcschr(thisAddr, COMP_SEPERATOR);
		if (nextAddr) *nextAddr = 0;

		DeAsciifyAddr(thisAddr, &ba);
//		DumpBlob(&ba);
		ExpandAddr(scr, &ba);

		wcscat(szIp, scr);

		if (nextAddr)
		{
			// restore seperator found earlier
			*nextAddr = COMP_SEPERATOR;

			nextAddr++;
			wcscat(szIp, L";");
		}
		thisAddr = nextAddr;
	}

// 	TRIVIAL_MSG((L"ExpandAddress returns [%s]", szIp));
	return ERROR_SUCCESS;
}


/****************************************************************************
**
**	FetchAllAddressesEx
**		Returns a string listing all the valid IP addresses for the machine
**		controlled by a set of "flags". These are as follows:
**		IPflags=
**			IPF_ADD_DNS		adds the DNS name to the IP list
**			IPF_COMPRESS	compresses the IP address list (exclusive w/ IPF_ADD_DNS)
**			IPF_NO_SORT		do not sort adapter IP list
**
**		Formatting details:
**		1. Each address is seperated with a ";" (semicolon)
**		2. Each address consists of the "1.2.3.4", and is followed by ":p"
**		   where the colon is followed by the port number
**
****************************************************************************/
#define WCHAR_CNT	4096

DWORD APIENTRY FetchAllAddressesEx(WCHAR *lpszAddr, int iBufSize, int IPflags)
{
	DWORD	dwRet = 1;
	WCHAR	*AddressLst;
	int		iAddrLen;
	BOOL	bSort=FALSE;

	AddressLst = (WCHAR *) malloc(WCHAR_CNT * sizeof(WCHAR));
	if (!AddressLst)
	{
		HEINOUS_E_MSG((L"Fatal error: malloc failed in FetchAllAddressesEx"));
		return 0;
	}
	*AddressLst = 0;

	INTERESTING_MSG((L"FetchAllAddressesEx()" ));

	// sanity check the flags
	if ((IPflags & IPF_COMPRESS) && IPflags != IPF_COMPRESS+IPF_NO_SORT)
	{
		IMPORTANT_MSG((L"Illegal IPflags value (0x%x) in FetchAllAddressesEx, forcing to IPF_COMPRESS+IPF_NO_SORT", IPflags));
		IPflags = IPF_COMPRESS+IPF_NO_SORT;
	}

	if (g_boolIcsPresent && g_pDPNH)
	{
		if (g_boolUsingNatHelp)
		{
			int i;
			// gotta cycle through the g_PortHandles list...
			for (i=0;i<ARRAYSIZE(g_PortHandles); i++)
			{
				if (g_PortHandles[i])
				{
					HRESULT hr = E_FAIL;
					SOCKADDR_IN	lsi;
					DWORD dwSize, dwTypes;
					DPNHCAPS lCaps;
					int j;
					PMAPHANDLES pMap = g_PortHandles[i];

					/* 
					 *  Call GetCaps so that we get an updated address list .
					 *  Not sure why we would want any other kind...
					 */
					lCaps.dwSize = sizeof(lCaps);
					hr = IDirectPlayNATHelp_GetCaps(g_pDPNH, &lCaps, DPNHGETCAPS_UPDATESERVERSTATUS);

					for (j=0; j < pMap->iMapped; j++)
					{

						dwSize = sizeof(lsi);
						ZeroMemory(&lsi, dwSize);

						hr = IDirectPlayNATHelp_GetRegisteredAddresses(g_pDPNH, pMap->hMapped[j], (SOCKADDR *)&lsi, 
								&dwSize, &dwTypes, NULL, 0, );

						if (hr == DPNH_OK && dwSize)
						{
							WCHAR   scratch[32];
							wsprintf(scratch, L"%d.%d.%d.%d:%d;",
								lsi.sin_addr.S_un.S_un_b.s_b1,
								lsi.sin_addr.S_un.S_un_b.s_b2,
								lsi.sin_addr.S_un.S_un_b.s_b3,
								lsi.sin_addr.S_un.S_un_b.s_b4,
								ntohs( lsi.sin_port ));
							wcscat(AddressLst, scratch);

							TRIVIAL_MSG((L"GetRegisteredAddresses(0x%x)=[%s]", g_PortHandles[i], scratch ));
						}
						else
						{
							IMPORTANT_MSG((L"GetRegisteredAddresses[0x%x] failed, size=0x%x", g_PortHandles[i], dwSize));
							DumpLibHr(hr);
						}
					}
                                    goto got_addresses;
				}
			}
		}
		else
		{
			union AddrV4 {
					DWORD	d;
					BYTE	b[4];
			};
			WCHAR	scratch[32];
			union AddrV4	a;
			RSIP_LEASE_RECORD	*pLeaseWalker;
			RSIP_LEASE_RECORD	*pNextLease;

			pLeaseWalker = g_pRsipLeaseRecords;
			while( pLeaseWalker )
			{
				bSort=TRUE;
				pNextLease = pLeaseWalker->pNext;

				a.d = pLeaseWalker->addrV4;
				wsprintf(scratch, L"%d.%d.%d.%d:%d;",
						a.b[0],
						a.b[1],
						a.b[2],
						a.b[3],
						ntohs(pLeaseWalker->rport));
				wcscat(AddressLst, scratch);
				pLeaseWalker=pNextLease;
			}
		}
	}
got_addresses:
	iAddrLen = wcslen(AddressLst);
	GetIPAddress(AddressLst+iAddrLen, WCHAR_CNT-iAddrLen, g_iPort);

	if (IPflags & IPF_ADD_DNS)
	{
		WCHAR	*DnsName=NULL;
		DWORD	dwNameSz=0;

		GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, NULL, &dwNameSz);

		dwNameSz++;
		DnsName = (WCHAR *)malloc(dwNameSz * sizeof(WCHAR));
		if (DnsName)
		{
			*DnsName = 0;
			if (GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, DnsName, &dwNameSz))
			{
				if ((dwNameSz + iAddrLen) < WCHAR_CNT-4)
					wcscat(AddressLst, DnsName);
				if (g_iPort)
				{
					WCHAR scr[16];
					wsprintf(scr, L":%d", g_iPort);
					wcscat(AddressLst, scr);
				}
			}
			free(DnsName);
		}
	}

	if (!(IPflags & IPF_NO_SORT) && bSort)
	{
		WCHAR *lpStart;
		WCHAR	szLast[36];
		int i=0;

		TRIVIAL_MSG((L"Sorting address list : %s", AddressLst));

		lpStart = AddressLst+iAddrLen;

		while (*(lpStart+i) && *(lpStart+i) != L';')
		{
			szLast[i] = *(lpStart+i);
			i++;
		}
		szLast[i++]=0;
		wcscpy(lpStart, lpStart+i);

		TRIVIAL_MSG((L"inter sort: %s, %s", AddressLst, szLast));

		wcscat(AddressLst, L";");
		wcscat(AddressLst, szLast);

		TRIVIAL_MSG((L"sort done"));
	}

	if (IPflags & IPF_COMPRESS)
	{
		WCHAR compBfr[1000];

		compBfr[0]=0;
		SquishAddress(AddressLst, compBfr);
		TRIVIAL_MSG((L"inner comp: %s, %s", AddressLst, compBfr));
		wcscpy(AddressLst, compBfr);
	}

	dwRet = 1 + wcslen(AddressLst);

	if (lpszAddr && iBufSize >= (int)dwRet)
		memcpy(lpszAddr, AddressLst, dwRet*(sizeof(AddressLst[0])));

	INTERESTING_MSG((L"Fetched all Ex-addresses:cnt=%d, sz=[%s]", dwRet, AddressLst));

	free(AddressLst);
	return dwRet;
}

// it is hard to imagine a machine with this many simultaneous connections, but it is possible, I suppose

#define RAS_CONNS	6

DWORD	GetConnections()
{
	DWORD		dwRet;
	RASCONN		*lpRasConn, *lpFree;
	DWORD		lpcb, lpcConnections;
	int			i;

	TRIVIAL_MSG((L"entered GetConnections"));

	lpFree = NULL;
	lpcb = RAS_CONNS * sizeof(RASCONN);
	lpRasConn = (LPRASCONN) malloc(lpcb);

	if (!lpRasConn) return 0;

	lpFree = lpRasConn;
	lpRasConn->dwSize = sizeof(RASCONN);
 
	lpcConnections = RAS_CONNS;

	dwRet = RasEnumConnections(lpRasConn, &lpcb, &lpcConnections);
	if (dwRet != 0)
	{
		IMPORTANT_MSG((L"RasEnumConnections failed: Error = %d", dwRet));
		free(lpFree);
		return 0;
	}

	dwRet = 0;

	TRIVIAL_MSG((L"Found %d connections", lpcConnections));

	if (lpcConnections)
	{
		for (i = 0; i < (int)lpcConnections; i++)
		{
			TRIVIAL_MSG((L"Entry name: %s, type=%s\n", lpRasConn->szEntryName, lpRasConn->szDeviceType));

			if (!_wcsicmp(lpRasConn->szDeviceType, RASDT_Modem ))
			{
				TRIVIAL_MSG((L"Found a modem (%s)", lpRasConn->szDeviceName));
				dwRet |= 1;
			}
			else if (!_wcsicmp(lpRasConn->szDeviceType, RASDT_Vpn))
			{
				TRIVIAL_MSG((L"Found a VPN (%s)", lpRasConn->szDeviceName));
				dwRet |= 2;
			}
			else
			{
				// probably ISDN, or something like that...
				TRIVIAL_MSG((L"Found something else, (%s)", lpRasConn->szDeviceType));
				dwRet |= 4;
			}

			lpRasConn++;
		}
	}

	if (lpFree)
		free(lpFree);

	TRIVIAL_MSG((L"GetConnections returning 0x%x", dwRet));
	return dwRet;
}
#undef RAS_CONNS

/****************************************************************************
**
**	GetIcsStatus(PICSSTAT pStat)
**		Returns a structure detailing much of what is going on inside this
**		library. The dwSize entry must be filled in before calling this
**		function. Use "sizeof(ICSSTAT))" to populate this.
**
****************************************************************************/
DWORD APIENTRY GetIcsStatus(PICSSTAT pStat)
{
	DWORD	dwSz;

	if (!pStat || pStat->dwSize > sizeof(ICSSTAT))
	{
		HEINOUS_E_MSG((L"ERROR:Bad pointer or size passed in to GetIcsStatus"));
		return ERROR_INVALID_PARAMETER;
	}

	// clear out the struct
	dwSz = pStat->dwSize;
	ZeroMemory(pStat, dwSz);
	pStat->dwSize = dwSz;
	pStat->bIcsFound = g_boolIcsPresent;
	pStat->bIcsServer = g_boolIcsOnThisMachine;
	pStat->bUsingDP = g_boolUsingNatHelp;
	if (g_boolUsingNatHelp)
		pStat->bUsingUpnp = !g_boolUsingNatPAST;

	if (g_boolIcsPresent)
	{
		wsprintf(pStat->wszPubAddr, L"%S", g_szPublicAddr);
		wsprintf(pStat->wszLocAddr, L"%d.%d.%d.%d",
						g_saddrLocal.sin_addr.S_un.S_un_b.s_b1,
						g_saddrLocal.sin_addr.S_un.S_un_b.s_b2,
						g_saddrLocal.sin_addr.S_un.S_un_b.s_b3,
						g_saddrLocal.sin_addr.S_un.S_un_b.s_b4);
		wsprintf(pStat->wszDllName, L"%S", g_lpszDllName);
	}
	else
		wsprintf(pStat->wszDllName, L"none");

	dwSz = GetConnections();

	if (dwSz & 1)
		pStat->bModemPresent = TRUE;

	if (dwSz & 2)
		pStat->bVpnPresent = TRUE;

	return ERROR_SUCCESS;
}

/*************************************************************************************
**
**
*************************************************************************************/
int GetTsPort(void)
{
	DWORD	dwRet = 3389;
	HKEY	hKey;

	// open reg key first, to get ALL the spew...HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp", 0, KEY_READ, &hKey))
	{
		DWORD	dwSize;

		dwSize = sizeof(dwRet);
		RegQueryValueEx(hKey, L"PortNumber", NULL, NULL, (LPBYTE)&dwRet, &dwSize);
		RegCloseKey(hKey);
	}
	return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icshelper\rsip.c ===
/*******************************************************************************
********************************************************************************
**
**	The RSIP implementation
**
********************************************************************************
*******************************************************************************/

#include <winsock2.h>
#include <MMSystem.h>
#include <WSIPX.h>
#include <stdlib.h>
#include <malloc.h>

#include "RSIPdefs.h"
#include "ICSutils.h"
#include "rsip.h"

/*******************************************************************************
********************************************************************************
**
**	LOCAL variables used by this module
**
********************************************************************************
*******************************************************************************/
CRITICAL_SECTION	g_CritSec;
SOCKET  			g_sRsip;
SOCKADDR_IN			g_saddrGateway;
SOCKADDR			g_saddrPublic;

int					g_iPort;
DWORD				g_ClientID;
HANDLE				g_hThreadEvent=NULL;
HANDLE				g_hAlertEvent=NULL;

RSIP_LEASE_RECORD	*g_pRsipLeaseRecords;	// list of leases.
ADDR_ENTRY        	*g_pAddrEntry;			// cache of mappings.
DWORD 		 		g_tuRetry;				// microseconds starting retry time.
LONG				g_MsgID = 0;

//**********************************************************************
// the mark of the beast...
#define NO_ICS_HANDLE 0x666

#define DPN_OK				S_OK
#define DPNERR_GENERIC		E_FAIL
#define DPNERR_INVALIDPARAM	E_INVALIDARG


void	Lock( void ) 
{ 
	EnterCriticalSection( &g_CritSec );
}

void	Unlock( void ) 
{ 
	LeaveCriticalSection( &g_CritSec ); 
}

/*=============================================================================

	Initialize - Initialize RSIP support.  If this function succeeds then there
			   is an RSIP gateway on the network and the SP should call the
			   RSIP services when creating and destroying sockets that need
			   to be accessed from machines outside the local realm.

    Description:

		Looks for the Gateway, then check to see if it is RSIP enabled.

    Parameters:

		Pointer to base socket address
			Used to take SP guid to look up gateway on Win95.  Since this
			only works on Win9x, the GUID is hard-coded in the function call
			because old DPlay is guaranteed to be available on a Win9x system.
			Any new systems won't care because they'll support the GetAdaptersInfo
			call.
		Boolean indicating that this is an Rsip host

    Return Values:

		TRUE  - found and RSIP gateway and initialized.
		FALSE - no RSIP gateway found.

-----------------------------------------------------------------------------*/
BOOL Initialize( SOCKADDR *pBaseSocketAddress, 
				BOOL fIsRsipServer )
{
	BOOL		bReturn = TRUE;
	BOOL		fBroadcastFlag;
	INT_PTR		iReturnValue;
	SOCKADDR_IN saddr;

	TRIVIAL_MSG((L"Initialize(%S)", fIsRsipServer?"TRUE":"FALSE" ));

	// create a SOCKADDR to address the RSIP service on the gateway
	memset(&g_saddrGateway, 0, sizeof( g_saddrGateway ) );
	g_saddrGateway.sin_family		= AF_INET;
	g_saddrGateway.sin_port			= htons( RSIP_HOST_PORT );

	// create an address to specify the port to bind our datagram socket to.
	memset(&saddr,0,sizeof(SOCKADDR_IN));
	saddr.sin_family	  = AF_INET;
	saddr.sin_port        = htons(0);

	//
	// if this is the Rsip server, bind to all adapters and talk via loopback.
	// If not, bind to the particular adapter and use broadcast to find the
	// Rsip server
	//
	if ( fIsRsipServer != FALSE )
	{
		g_saddrGateway.sin_addr.S_un.S_addr = htonl( INADDR_LOOPBACK );
		saddr.sin_addr.s_addr = htonl( INADDR_ANY );
	}
	else
	{
		g_saddrGateway.sin_addr.S_un.S_addr = htonl( INADDR_BROADCAST );
		saddr.sin_addr.s_addr = ((SOCKADDR_IN*)( pBaseSocketAddress ))->sin_addr.s_addr;
	}

	// create a datagram socket for talking to the RSIP facility on the gateway
	if( ( g_sRsip = socket( AF_INET, SOCK_DGRAM, 0 ) ) == INVALID_SOCKET ){
		IMPORTANT_MSG((L"ERROR: rsipInit() socket call for RSIP listener failed\n"));
		bReturn = FALSE;
		goto Exit;
	}

	//
	// set socket to allow broadcasts
	//
	fBroadcastFlag = TRUE;
	iReturnValue = setsockopt( g_sRsip,			// socket
	    						 SOL_SOCKET,		// level (set socket options)
	    						 SO_BROADCAST,		// set broadcast option
	    						 (char *)( &fBroadcastFlag ),	// allow broadcast
	    						 sizeof( fBroadcastFlag )	// size of parameter
	    						 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = WSAGetLastError();
	    IMPORTANT_MSG((L"Unable to set socket options!"));
		bReturn = FALSE;
	    goto Exit;
	}
	
	// bind the datagram socket to any local address and port.
	if( bind(g_sRsip, (PSOCKADDR)&saddr, sizeof(saddr) ) != 0){
		IMPORTANT_MSG((L"ERROR: rsipInit() bind for RSIP listener failed\n"));
		bReturn=FALSE;
		goto Exit;
	}

	g_tuRetry=12500; // start retry timer at 12.5 ms

	// find out if there is an rsip service and register with it.
	if ( Register() != DPN_OK )
	{
		bReturn=FALSE;
		goto Exit;
	}

Exit:
	if( bReturn == FALSE )
	{
		if( g_sRsip != INVALID_SOCKET )
		{
			closesocket( g_sRsip );
			g_sRsip = INVALID_SOCKET;
		}
	}

	return bReturn;
}


/*=============================================================================

	Deinitialize - Shut down RSIP support

	   All threads that might access RSIP MUST be stopped before this
	   is called.

    Description:

		Deregisters with the Rsip Agent on the gateway, and cleans up
		the list of lease records.

    Parameters:

		Pointer to thread pool

    Return Values:

		None.

-----------------------------------------------------------------------------*/
void Deinitialize( void )
{
	RSIP_LEASE_RECORD	*pLeaseWalker;
	RSIP_LEASE_RECORD	*pNextLease;
	ADDR_ENTRY			*pAddrWalker;
	ADDR_ENTRY			*pNextAddr;


	if(g_sRsip!=INVALID_SOCKET){
		Deregister();	
		closesocket(g_sRsip);
		g_sRsip=INVALID_SOCKET;
	}	
	
	// free the leases
	pLeaseWalker = g_pRsipLeaseRecords;
	while( pLeaseWalker ){
		pNextLease = pLeaseWalker->pNext;
		free(pLeaseWalker);
		pLeaseWalker=pNextLease;
	}
	g_pRsipLeaseRecords=NULL;

	// free the cached address mappings
	pAddrWalker=g_pAddrEntry;
	while(pAddrWalker){
		pNextAddr=pAddrWalker->pNext;
		free(pAddrWalker);
		pAddrWalker=pNextAddr;
	}
	g_pAddrEntry=NULL;

	g_MsgID = 0;
	g_tuRetry = 0;
	memset( &g_saddrGateway, 0x00, sizeof( g_saddrGateway ) );
}


//**********************************************************************
// ------------------------------
// RsipIsRunningOnThisMachine - return Boolean indicating whether this machine
//		is an Rsip machine.
//
// Entry:		Pointer to socket address to be filled in with public address
//
// Exit:		Boolean
//				TRUE = this is Rsip machine
//				FALSE = this is not Rsip machine
// ------------------------------
BOOL RsipIsRunningOnThisMachine( SOCKADDR *pPublicSocketAddress )
{
	SOCKET		Socket;
	BOOL		fReturn;

	Socket = INVALID_SOCKET;
	fReturn = FALSE;
	
	TRIVIAL_MSG((L"RsipIsRunningOnThisMachine begins"));

	//
	// Attempt to bind to the Rsip port.  If we can't bind to it, assume that
	// Rsip is running on this machine.
	//
	Socket = socket( AF_INET, SOCK_DGRAM, 0 );
	if ( Socket != INVALID_SOCKET )
	{
		SOCKADDR_IN	addr;
		

		memset( &addr, 0, sizeof(SOCKADDR_IN ) );
		addr.sin_family = AF_INET;
		addr.sin_addr.S_un.S_addr = htonl( INADDR_LOOPBACK );
		addr.sin_port = htons( RSIP_HOST_PORT );
		
		if ( bind( Socket, (SOCKADDR*)( &addr ), sizeof( addr ) ) != 0 )
		{
			fReturn = TRUE;
			TRIVIAL_MSG((L"bind successfull"));
		}

		closesocket( Socket );
		Socket = INVALID_SOCKET;
	}

	//
	// This is an Rsip server, create a local socket and bind it to the server
	// to find out what the public address is.
	//
	if ( fReturn != FALSE )
	{		
		HRESULT			hr;
		SOCKADDR_IN 	SocketAddress;
		INT				iBoundAddressSize;
		SOCKADDR_IN		BoundAddress;
		SOCKADDR		RsipAssignedAddress;
		DWORD			dwBindID;

			
		Socket = socket( AF_INET, SOCK_DGRAM, 0 );
		if ( Socket == INVALID_SOCKET )
		{
			fReturn = FALSE;
			TRIVIAL_MSG((L"socket choked"));
			goto Failure;
		}

		memset( &SocketAddress, 0x00, sizeof( SocketAddress ) );
		SocketAddress.sin_family = AF_INET;
		SocketAddress.sin_addr.S_un.S_addr = htonl( INADDR_ANY );
		SocketAddress.sin_port = htons( ANY_PORT );

		if ( bind( Socket, (SOCKADDR*)( &SocketAddress ), sizeof( SocketAddress ) ) != 0 )
		{
			TRIVIAL_MSG((L"bind failed in query"));
			fReturn = FALSE;
			goto Failure;
		}

		iBoundAddressSize = sizeof( BoundAddress );
		if ( getsockname( Socket, (SOCKADDR*)( &BoundAddress ), &iBoundAddressSize ) != 0 )
		{
			TRIVIAL_MSG((L"failed in getsockname"));
			fReturn = FALSE;
			goto Failure;
		}

		if ( Initialize((SOCKADDR*)( &SocketAddress ), TRUE ) == FALSE )
		{
			TRIVIAL_MSG((L"failed in Initialize"));
			fReturn = FALSE;
			goto Failure;
		}

		hr = AssignPort( FALSE, BoundAddress.sin_port, &RsipAssignedAddress, &dwBindID );
		if ( hr != DPN_OK )
		{
			fReturn = FALSE;
			IMPORTANT_MSG((L"Failed to assign port when attempting to determine public network address!" ));
			goto Failure;
		}

		memcpy( pPublicSocketAddress, &RsipAssignedAddress, sizeof( *pPublicSocketAddress ) );
		
		FreePort( dwBindID );
	}

Exit:
	if ( Socket != INVALID_SOCKET )
	{
		closesocket( Socket );
		Socket = INVALID_SOCKET;
	}
	
	TRIVIAL_MSG((L"RsipIsRunningOnThisMachine ends, returning %S", fReturn?"TRUE":"FALSE"));
	return	fReturn;

Failure:
	goto Exit;
}

/*=============================================================================

	ExchangeAndParse - send a request to the rsip server and
						   wait for and parse the reply


    Description:

	Since there is almost no scenario where we don't immediately need to know
	the response to an rsipExchange, there is no point in doing this
	asynchronously.  The assumption is that an RSIP server is sufficiently
	local that long retries are not necessary.  We use the approach suggested
	in the IETF draft protocol specification, that is 12.5ms retry timer
	with 7-fold exponential backoff.  This can lead to up to a total 1.5
	second wait in the worst case.  (Note this section may no longer be
	available since the rsip working group decided to drop UDP support)

    Parameters:

		pRequest  - a fully formatted RSIP request buffer
		cbReq     - size of request buffer
		pRespInfo - structure that returns response parameters
		messageid - the message id of this request
		bConnect  - whether this is the register request, we use a different
					timer strategy on initial connect because we really
					don't want to miss it if there is a gateway.
		pRecvSocketAddress - pointer to recv address destination (needed for connect)

    Return Values:

		DPN_OK - exchange succeeded, reply is in the reply buffer.
		otw, failed, RespInfo is bogus.

-----------------------------------------------------------------------------*/

#define MAX_RSIP_RETRY	6

struct timeval tv0={0,0};

DWORD ExchangeAndParse( PCHAR pRequest,
						 UINT cbReq,
						 RSIP_RESPONSE_INFO *pRespInfo,
						 DWORD messageid,
						 BOOL bConnect,
						 SOCKADDR *pRecvSocketAddress )
{
	CHAR	RespBuffer[ RESP_BUF_SIZE ];
	DWORD	dwRespLen = sizeof( RespBuffer );
	INT		iRecvSocketAddressSize = sizeof( *pRecvSocketAddress );

	struct timeval tv;
	FD_SET readfds;
	INT    nRetryCount=0;
	int    rc;
	int    cbReceived;
	HRESULT hr=DPN_OK;

	if ( pRequest == NULL ||
		 pRespInfo == NULL ||
		 pRecvSocketAddress == NULL )
	{
		IMPORTANT_MSG((L"RsipExchangeAndParse bad params passed (0x%x, 0x%x, 0x%x)",pRequest,pRespInfo,pRecvSocketAddress));
		return DPNERR_INVALIDPARAM;
	}

	INTERESTING_MSG((L"==>RsipExchangeAndParse msgid %d", messageid ));

	memset(RespBuffer, 0, RESP_BUF_SIZE);
	memset(pRespInfo, 0, sizeof(RSIP_RESPONSE_INFO));

	if(!bConnect){
		tv.tv_usec = g_tuRetry;
		tv.tv_sec  = 0;
		nRetryCount = 0;
	} else {
		// on a connect request we try twice with a 1 second total timeout
		tv.tv_usec = 500000;	// 0.5 seconds
		tv.tv_sec  = 0;
		nRetryCount = MAX_RSIP_RETRY-2;
	}


	FD_ZERO(&readfds);
	FD_SET(g_sRsip, &readfds);

	rc=0;

	// First clear out any extraneous responses.
	while( select( 0, &readfds, NULL, NULL, &tv0 ) )
	{
		cbReceived = recvfrom( g_sRsip, RespBuffer, dwRespLen, 0, NULL, NULL );
		switch ( cbReceived )
		{
			//
			// nothing received, try again
			//
			case 0:
			{
				break;
			}

			//
			// read failure, bail!
			//
			case SOCKET_ERROR:
			{
				rc = WSAGetLastError();
				IMPORTANT_MSG((L"Got sockets error %d trying to receive (clear incoming queue) on RSIP socket", rc ));
				hr = DPNERR_GENERIC;
				
				break;
			}

			default:
			{
				TRIVIAL_MSG((L"Found extra response from previous RSIP request" ));
				if( g_tuRetry < RSIP_tuRETRY_MAX )
				{
					// don't re-try so quickly
					g_tuRetry *= 2;
					TRIVIAL_MSG((L"rsip Set g_tuRetry to %d usec", g_tuRetry ));
				}	
				
				break;
			}
		}
		
		FD_ZERO(&readfds);
		FD_SET(g_sRsip, &readfds);
	}


	// Now do the exchange, get a response to the request, does retries too.
	do{

		if(++nRetryCount > MAX_RSIP_RETRY) {
			break;
		}

		TRIVIAL_MSG((L"Sending RSIP Request to gateway, RetryCount=%d", nRetryCount ));
		DumpSocketAddress( 0, (SOCKADDR*)( &g_saddrGateway ), AF_INET);

		// First send off the request
		rc=sendto(g_sRsip, pRequest, cbReq, 0, (SOCKADDR *)&g_saddrGateway, sizeof(SOCKADDR) );

		if( rc == SOCKET_ERROR )
		{
			rc = WSAGetLastError();
			IMPORTANT_MSG((L"Got sockets error %d on sending to RSIP gateway", rc ));
			hr = DPNERR_GENERIC;
			goto exit;
		}

		if( rc != (int)cbReq )
		{
			IMPORTANT_MSG((L"Didn't send entire datagram?  shouldn't happen" ));
			hr=DPNERR_GENERIC;
			goto exit;
		}

		// Now see if we get a response.
select_again:		
		FD_ZERO(&readfds);
		FD_SET(g_sRsip, &readfds);

		rc=select(0,&readfds,NULL,NULL,&tv);

		if(rc==SOCKET_ERROR){
			rc=WSAGetLastError();
			IMPORTANT_MSG((L"Got sockets error %d trying to select on RSIP socket",rc));
			hr=DPNERR_GENERIC;
		}

		TRIVIAL_MSG((L"Return From Select %d",rc));

		
		//
		// there's only one item in the set, make sure of this, and if there
		// was a signalled socket, make sure it's our socket.
		//
		if( LocalFDIsSet(g_sRsip, &readfds)){
			break;
		}

		if(!bConnect){
			IMPORTANT_MSG((L"Didn't get response, increasing timeout value" ));
			// don't use exponential backoff on initial connect
			tv.tv_usec *= 2;	// exponential backoff.
		}	
	} while (rc==0); // keep retrying...


	if(rc == SOCKET_ERROR){
		IMPORTANT_MSG((L"GotSocketError on select, extended error %d",WSAGetLastError()));
		hr=DPNERR_GENERIC;
		goto exit;
	}

	if(rc)
	{
		// We Got Mail, err data....
		dwRespLen=RESP_BUF_SIZE;
		
		TRIVIAL_MSG((L"Receiving Data" ));

		memset( pRecvSocketAddress, 0x00, sizeof( *pRecvSocketAddress ) );
		cbReceived=recvfrom(g_sRsip, RespBuffer, dwRespLen, 0, pRecvSocketAddress, &iRecvSocketAddressSize);

		TRIVIAL_MSG((L"cbReceived = %d", cbReceived ));

		if( ( cbReceived == 0 ) || ( cbReceived == SOCKET_ERROR ) )
		{
			rc=WSAGetLastError();
			IMPORTANT_MSG((L"Got sockets error %d trying to receive on RSIP socket", rc ));
			hr=DPNERR_GENERIC;
		}
		else
		{
			TRIVIAL_MSG((L"Parsing Receive Buffer" ));
			Parse( RespBuffer, cbReceived, pRespInfo );
			if(pRespInfo->messageid != messageid)
			{
				// Got a dup from a previous retry, go try again.
				IMPORTANT_MSG((L"Got messageid %d, expecting messageid %d", pRespInfo->messageid, messageid ));
				goto select_again;
			}
		}
	}

	INTERESTING_MSG((L"<==RsipExchangeAndParse hr=%x, Resp msgid %d", hr, pRespInfo->messageid ));

exit:
	return hr;
}

/*=============================================================================

	Parse - parses an RSIP request and puts fields into a struct.

    Description:

		This parser parses and RSIP request or response and extracts
		out the codes into a standard structure.  This is not completely
		general, as we know that we will only operate with v4 addresses
		and our commands will never deal with more than 1 address at a
		time.  If you need to handle multiple address requests
		and responses, then you will need to change this function.

	Limitations:

		This function only deals with single address/port responses.
		Rsip allows for multiple ports to be allocated in a single
		request, but we do not take advantage of this feature.

    Parameters:

		pBuf  		- buffer containing an RSIP request or response
		cbBuf 		- size of buffer in bytes
		pRespInfo   - a structure that is filled with the parameters
					  from the RSIP buffer.

    Return Values:

		DPN_OK - connected to the RSIP server.

-----------------------------------------------------------------------------*/
HRESULT Parse( CHAR *pBuf, DWORD cbBuf, PRSIP_RESPONSE_INFO pRespInfo )
{
	// character pointer version of parameter pointer.

	BOOL bGotlAddress=FALSE;
	BOOL bGotlPort   =FALSE;

	DWORD code;
	DWORD codelen;

	PRSIP_MSG_HDR pHeader;
	PRSIP_PARAM   pParam,pNextParam;
	CHAR          *pc;

	CHAR *pBufEnd = pBuf+cbBuf;

	if(cbBuf < 2){
		return DPNERR_INVALIDPARAM;
	}	

	pHeader=(PRSIP_MSG_HDR)pBuf;

	pRespInfo->version = pHeader->version;
	pRespInfo->msgtype = pHeader->msgtype;

	INTERESTING_MSG((L"rsipParse: version %d msgtype %d",pRespInfo->version, pRespInfo->msgtype));

	pParam = (PRSIP_PARAM)(pHeader+1);

	while((CHAR*)(pParam+1) < pBufEnd)
	{
		pc=(CHAR *)(pParam+1);
		pNextParam = (PRSIP_PARAM)(pc + pParam->len);

		if((CHAR *)pNextParam > pBufEnd){
			break;
		}	

		switch(pParam->code){

			case RSIP_ADDRESS_CODE:

				// Addresses are type[1]|addr[?]

				switch(*pc){
					case 1:
						if(!bGotlAddress){
							TRIVIAL_MSG((L"rsipParse: lAddress %S",inet_ntoa(*((PIN_ADDR)(pc+1)))));
							memcpy((char *)&pRespInfo->lAddressV4, pc+1, 4);
							bGotlAddress=TRUE;
						} else {	
							bGotlPort=TRUE; // just in case there wasn't a local port
							TRIVIAL_MSG((L"rsipParse: rAddress %S,",inet_ntoa(*((PIN_ADDR)(pc+1)))));
							memcpy((char *)&pRespInfo->rAddressV4, pc+1, 4);
						}	
						break;
					case 0:
					case 2:
					case 3:
					case 4:
					case 5:
						TRIVIAL_MSG((L"Unexpected RSIP address code type %d",*pc));
					break;
				}
				break;

			case RSIP_PORTS_CODE:

				// Ports are Number[1]|Port[2]....Port[2]
				if(!bGotlPort){
					TRIVIAL_MSG((L"rsipParse lPort: %d", *((WORD *)(pc+1))));
					memcpy((char *)&pRespInfo->lPort, pc+1,2);
				} else {
					TRIVIAL_MSG((L"rsipParse rPort: %d", *((WORD *)(pc+1))));
					memcpy((char *)&pRespInfo->rPort, pc+1,2);
					bGotlPort=TRUE;					
				}
				break;

  			case RSIP_LEASE_CODE:
				if(pParam->len == 4){
					memcpy((char *)&pRespInfo->leasetime,pc,4);
					TRIVIAL_MSG((L"rsipParse Lease: %d",pRespInfo->leasetime));
				}	
  				break;

  			case RSIP_CLIENTID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->clientid,pc,4);
					TRIVIAL_MSG((L"rsipParse clientid: %d",pRespInfo->clientid));
  				}
  				break;

  			case RSIP_BINDID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->bindid,pc,4);
					TRIVIAL_MSG((L"rsipParse bindid: %x",pRespInfo->bindid));
  				}
  				break;

  			case RSIP_MESSAGEID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->messageid,pc,4);
					TRIVIAL_MSG((L"rsipParse messageid: %d",pRespInfo->messageid));
  				}
  				break;

  			case RSIP_TUNNELTYPE_CODE:
  				TRIVIAL_MSG((L"rsipParse Got Tunnel Type %d, ignoring",*pc));
  				break;

  			case RSIP_RSIPMETHOD_CODE:
  				TRIVIAL_MSG((L"rsipParse Got RSIP Method %d, ignoring",*pc));
  				break;

  			case RSIP_ERROR_CODE:
  				if(pParam->len==2){
  					memcpy((char *)&pRespInfo->error,pc,2);
  				}
  				TRIVIAL_MSG((L"rsipParse Got RSIP error %d",pRespInfo->error));
  				break;

  			case RSIP_FLOWPOLICY_CODE:
  				TRIVIAL_MSG((L"rsipParse Got RSIP Flow Policy local %d remote %d, ignoring",*pc,*(pc+1)));
  				break;

  			case RSIP_VENDOR_CODE:
  				break;

  			default:
  				TRIVIAL_MSG((L"Got unknown parameter code %d, ignoring",pParam->code));
  				break;
		}

		pParam=pNextParam;

	}

	return DPN_OK;
}

/*=============================================================================

	Register - register with the RSIP server on the gateway (if present)

    Description:

		Trys to contact the RSIP service on the gateway.

		Doesn't require lock since this is establishing the link during
		startup.  So no-one is racing with us.

    Parameters:

    	None.

    Return Values:

		DPN_OK 		  - connected to the RSIP server.
		DPNERR_GENERIC - can't find the RSIP service on the gateway.

-----------------------------------------------------------------------------*/
HRESULT	Register( void )
{
	HRESULT		hr;
	SOCKADDR	RecvSocketAddress;
	MSG_RSIP_REGISTER  RegisterReq;
	RSIP_RESPONSE_INFO RespInfo;


	INTERESTING_MSG((L"==>RSIP Register" ));

	// Initialize the message sequencing.  Each message response pair
	// is numbered sequentially to allow differentiation over UDP link.

	g_MsgID = 0;
	
	// Build the request

	RegisterReq.version    	= RSIP_VERSION;
	RegisterReq.command    	= RSIP_REGISTER_REQUEST;
	RegisterReq.msgid.code 	= RSIP_MESSAGEID_CODE;
	RegisterReq.msgid.len  	= sizeof(DWORD);
	RegisterReq.msgid.msgid = InterlockedIncrement( &g_MsgID );

	hr = ExchangeAndParse( (PCHAR)&RegisterReq,
						   sizeof(RegisterReq),
						   &RespInfo,
						   RegisterReq.msgid.msgid,
						   TRUE,
						   &RecvSocketAddress );
	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_REGISTER_RESPONSE){
		TRIVIAL_MSG((L"Failing registration, response was message type %d",RespInfo.msgtype));
		goto error_exit;
	}

	g_ClientID = RespInfo.clientid;
	memcpy( &g_saddrGateway, &RecvSocketAddress, sizeof( g_saddrGateway ) );

	INTERESTING_MSG((L"<==RSIP Register, ClientId %d", g_ClientID ));

exit:
	return hr;

error_exit:
	IMPORTANT_MSG((L"<==RSIP Register FAILED" ));
	return DPNERR_GENERIC;

}

/*=============================================================================

	Deregister - close connection to RSIP gateway.

    Description:

    	Shuts down the registration of this application with the RSIP
    	gateway.  All port assignments are implicitly freed as a result
    	of this operation.

		- must be called with lock held.

    Parameters:

		None.

    Return Values:

		DPN_OK - successfully deregistered with the RSIP service.

-----------------------------------------------------------------------------*/
HRESULT	Deregister( void )
{
	HRESULT 	hr;
	SOCKADDR	RecvSocketAddress;

	MSG_RSIP_DEREGISTER  DeregisterReq;
	RSIP_RESPONSE_INFO RespInfo;

	INTERESTING_MSG((L"==>RSIP Deregister" ));

	// Build the request

	DeregisterReq.version    	    = RSIP_VERSION;
	DeregisterReq.command    	    = RSIP_DEREGISTER_REQUEST;

	DeregisterReq.clientid.code     = RSIP_CLIENTID_CODE;
	DeregisterReq.clientid.len      = sizeof(DWORD);
	DeregisterReq.clientid.clientid = g_ClientID;

	DeregisterReq.msgid.code 	    = RSIP_MESSAGEID_CODE;
	DeregisterReq.msgid.len  	    = sizeof(DWORD);
	DeregisterReq.msgid.msgid       = InterlockedIncrement( &g_MsgID );

	hr=ExchangeAndParse( (PCHAR)&DeregisterReq,
						 sizeof(DeregisterReq),
						 &RespInfo,
						 DeregisterReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );
	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_DEREGISTER_RESPONSE){
		TRIVIAL_MSG((L"Failing registration, response was message type %d",RespInfo.msgtype));
		goto error_exit;
	}

	TRIVIAL_MSG((L"<==RSIP Deregister Succeeded" ));

exit:
	g_ClientID = 0;
	return hr;

error_exit:
	TRIVIAL_MSG((L"<==RSIP Deregister Failed" ));
	hr = DPNERR_GENERIC;
	goto exit;
}

/*=============================================================================

	AssignPort - assign a port mapping with the rsip server

    Description:

		Asks for a public realm port that is an alias for the local port on
		this local realm node.  After this request succeeds, all traffic
		directed to the gateway on the public side at the allocated public
		port, which the gateway provides and specifies in the response, will
		be directed to the specified local port.

		This function also adds the lease for the port binding to a list of
		leases and will renew the lease before it expires if the binding
		hasn't been released by a call to rsipFree first.

    Parameters:


		WORD	     port     - local port to get a remote port for (big endian)
    	BOOL		 ftcp_udp - whether we are assigning a UDP or TCP port
    	SOCKADDR     psaddr   - place to return assigned global realm address
    	PDWORD       pBindid  - identifier for this binding, used to extend
    							lease and/or release the binding (OPTIONAL).

    Return Values:

		DPN_OK - assigned succeeded, psaddr contains public realm address,
				*pBindid is the binding identifier.

		DPNERR_GENERIC - assignment of a public port could not be made.

-----------------------------------------------------------------------------*/
HRESULT	AssignPort( BOOL fTCP_UDP, WORD wPort, SOCKADDR *psaddr, DWORD *pdwBindid )
{
	#define psaddr_in ((SOCKADDR_IN *)psaddr)

	HRESULT hr;

	MSG_RSIP_ASSIGN_PORT AssignReq;
	RSIP_RESPONSE_INFO RespInfo;
	PRSIP_LEASE_RECORD pLeaseRecord;
	SOCKADDR	RecvSocketAddress;


	Lock();

	TRIVIAL_MSG((L"==>RSIP Assign Port %d\n", htons( wPort ) ));

	if(g_sRsip == INVALID_SOCKET){
		IMPORTANT_MSG((L"rsipAssignPort: g_sRsip is invalid, bailing...\n"));
		Unlock();
		return DPNERR_GENERIC;
	}

	if(pLeaseRecord=FindLease( fTCP_UDP, wPort )){

		// hey, we've already got a lease for this port, so use it.
		pLeaseRecord->dwRefCount++;

		if(psaddr_in){
			psaddr_in->sin_family = AF_INET;
			psaddr_in->sin_addr.s_addr = pLeaseRecord->addrV4;
			psaddr_in->sin_port		   = pLeaseRecord->rport;
		}	

		if(pdwBindid != NULL )
		{
			*pdwBindid = pLeaseRecord->bindid;
		}

		TRIVIAL_MSG((L"<==Rsip Assign, already have lease Bindid %d\n", pLeaseRecord->bindid ));

		Unlock();

		hr=DPN_OK;


		goto exit;
	}

	// Build the request.

	AssignReq.version    		= RSIP_VERSION;
	AssignReq.command    		= RSIP_ASSIGN_REQUEST_RSAP_IP;

	AssignReq.clientid.code 	= RSIP_CLIENTID_CODE;
	AssignReq.clientid.len 		= sizeof(DWORD);
	AssignReq.clientid.clientid = g_ClientID;

	// Local Address (will be returned by RSIP server, us don't care value)

	AssignReq.laddress.code		= RSIP_ADDRESS_CODE;
	AssignReq.laddress.len		= sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	AssignReq.laddress.version	= 1; // IPv4
	AssignReq.laddress.addr		= 0; // Don't care

	// Local Port, this is a port we have opened that we are assigning a
	// global alias for.

	AssignReq.lport.code		= RSIP_PORTS_CODE;
	AssignReq.lport.len			= sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	AssignReq.lport.nports      = 1;
	AssignReq.lport.port		= htons( wPort );

	// Remote Address (not used with our flow control policy, use don't care value)

	AssignReq.raddress.code		= RSIP_ADDRESS_CODE;
	AssignReq.raddress.len		= sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	AssignReq.raddress.version  = 1; // IPv4
	AssignReq.raddress.addr     = 0; // Don't care

	AssignReq.rport.code		= RSIP_PORTS_CODE;
	AssignReq.rport.len			= sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	AssignReq.rport.nports      = 1;
	AssignReq.rport.port		= 0; // Don't care

	// Following parameters are optional according to RSIP spec...

	// Lease code, ask for an hour, but don't count on it.

	AssignReq.lease.code		 = RSIP_LEASE_CODE;
	AssignReq.lease.len			 = sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	AssignReq.lease.leasetime    = 3600;

	// Tunnell Type is IP-IP

	AssignReq.tunnel.code		 = RSIP_TUNNELTYPE_CODE;
	AssignReq.tunnel.len		 = sizeof(RSIP_TUNNEL)-sizeof(RSIP_PARAM);
	AssignReq.tunnel.tunneltype  = TUNNEL_IP_IP;

	// Message ID is optional, but we use it since we use UDP xport it is required.

	AssignReq.msgid.code 		 = RSIP_MESSAGEID_CODE;
	AssignReq.msgid.len  		 = sizeof(DWORD);
	AssignReq.msgid.msgid   	 = InterlockedIncrement( &g_MsgID );

	// Vendor specific - need to specify port type and no-tunneling

	AssignReq.porttype.code     	 = RSIP_VENDOR_CODE;
	AssignReq.porttype.len      	 = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	AssignReq.porttype.vendorid 	 = RSIP_MS_VENDOR_ID;
	AssignReq.porttype.option   	 = (fTCP_UDP)?RSIP_TCP_PORT:RSIP_UDP_PORT;

	AssignReq.tunneloptions.code     = RSIP_VENDOR_CODE;
	AssignReq.tunneloptions.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	AssignReq.tunneloptions.vendorid = RSIP_MS_VENDOR_ID;
	AssignReq.tunneloptions.option   = RSIP_NO_TUNNEL;


	hr=ExchangeAndParse( (PCHAR)&AssignReq,
						 sizeof(AssignReq),
						 &RespInfo,
						 AssignReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );
	Unlock();

	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_ASSIGN_RESPONSE_RSAP_IP){
		IMPORTANT_MSG((L"Assignment failed? Response was %d",RespInfo.msgtype));
		goto error_exit;
	}

	if(psaddr_in){
		psaddr_in->sin_family = AF_INET;
		psaddr_in->sin_addr.s_addr = RespInfo.lAddressV4;
		psaddr_in->sin_port		   = htons(RespInfo.lPort);
	}


	if( pdwBindid != NULL )
	{
		*pdwBindid = RespInfo.bindid;
	}

	AddLease( RespInfo.bindid,
			  fTCP_UDP,
			  RespInfo.lAddressV4,
			  htons(RespInfo.lPort),
			  wPort,
			  RespInfo.leasetime);

	if(psaddr_in){
		TRIVIAL_MSG((L"RSIP Port Assigned: " ));
		DumpSocketAddress( 8, (SOCKADDR*)( psaddr_in ), psaddr_in->sin_family );
		TRIVIAL_MSG((L"<== BindId %d, leasetime=%d", RespInfo.bindid, RespInfo.leasetime ));
	}
exit:
	return hr;

error_exit:
	IMPORTANT_MSG((L"<==Assign Port Failed" ));
	return DPNERR_GENERIC;

	#undef psaddr_in
}

/*=============================================================================

	ExtendPort - extend a port mapping

    Description:

		Extends the lease on a port mapping.

    Parameters:

    	DWORD        Bindid - binding identifier specified by the rsip service.
    	DWORD        ptExtend - amount of extra lease time granted.

    Return Values:

		DPN_OK - lease extended.
		DPNERR_GENERIC - couldn't extend the lease.

-----------------------------------------------------------------------------*/
HRESULT ExtendPort( DWORD Bindid, DWORD *ptExtend )
{
	HRESULT hr;

	MSG_RSIP_EXTEND_PORT  ExtendReq;
	RSIP_RESPONSE_INFO RespInfo;
	SOCKADDR	RecvSocketAddress;


	Lock();

	TRIVIAL_MSG((L"==>Extend Port, Bindid %d\n", Bindid ));

	if(g_sRsip == INVALID_SOCKET){
		IMPORTANT_MSG((L"rsipExtendPort: g_sRsip is invalid, bailing...\n"));
		Unlock();
		return DPNERR_GENERIC;
	}

	// Build the request

	ExtendReq.version    		= RSIP_VERSION;
	ExtendReq.command    		= RSIP_EXTEND_REQUEST;

	ExtendReq.clientid.code 	= RSIP_CLIENTID_CODE;
	ExtendReq.clientid.len 		= sizeof(DWORD);
	ExtendReq.clientid.clientid = g_ClientID;

	ExtendReq.bindid.code 		= RSIP_BINDID_CODE;
	ExtendReq.bindid.len 		= sizeof(DWORD);
	ExtendReq.bindid.bindid 	= Bindid;

	// Lease code, ask for an hour, but don't count on it.

	ExtendReq.lease.code		= RSIP_LEASE_CODE;
	ExtendReq.lease.len			= sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	ExtendReq.lease.leasetime   = 3600;

	ExtendReq.msgid.code 		= RSIP_MESSAGEID_CODE;
	ExtendReq.msgid.len  		= sizeof(DWORD);
	ExtendReq.msgid.msgid   	= InterlockedIncrement( &g_MsgID );

	hr=ExchangeAndParse( (PCHAR)&ExtendReq,
						 sizeof(ExtendReq),
						 &RespInfo,
						 ExtendReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );

	Unlock();

	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_EXTEND_RESPONSE){
		IMPORTANT_MSG((L"Failing registration, response was message type %d\n",RespInfo.msgtype));
		goto error_exit;
	}

	*ptExtend=RespInfo.leasetime;

	TRIVIAL_MSG((L"<==Extend Port, Bindid %d Succeeded, extra lease time %d\n", Bindid, *ptExtend ));

exit:
	return hr;

error_exit:
	IMPORTANT_MSG((L"<==Extend Port, Failed" ));
	return DPNERR_GENERIC;

}

/*=============================================================================

	FreePort - release a port binding

    Description:

		Removes the lease record for our port binding (so we don't renew it
		after we actually release the binding from the gateway).  Then informs
		the gateway that we are done with the binding.

    Parameters:

    	DWORD        Bindid - gateway supplied identifier for the binding

    Return Values:

		DPN_OK - port binding released.
		DPNERR_GENERIC - failed.

-----------------------------------------------------------------------------*/
HRESULT	FreePort( DWORD dwBindid )
{
	HRESULT hr;

	MSG_RSIP_FREE_PORT  FreeReq;
	RSIP_RESPONSE_INFO RespInfo;
	SOCKADDR	RecvSocketAddress;


	Lock();

	TRIVIAL_MSG((L"==>Release Port, Bindid %d\n", dwBindid ));

	if(g_sRsip == INVALID_SOCKET){
		IMPORTANT_MSG((L"rsipFreePort: g_sRsip is invalid, bailing...\n"));
		Unlock();
		return DPNERR_GENERIC;
	}

	RemoveLease( dwBindid );

	FreeReq.version    			= RSIP_VERSION;
	FreeReq.command    			= RSIP_FREE_REQUEST;

	FreeReq.clientid.code 		= RSIP_CLIENTID_CODE;
	FreeReq.clientid.len 		= sizeof(DWORD);
	FreeReq.clientid.clientid 	= g_ClientID;

	FreeReq.bindid.code 		= RSIP_BINDID_CODE;
	FreeReq.bindid.len 			= sizeof(DWORD);
	FreeReq.bindid.bindid 		= dwBindid;

	FreeReq.msgid.code 			= RSIP_MESSAGEID_CODE;
	FreeReq.msgid.len  			= sizeof(DWORD);
	FreeReq.msgid.msgid   		= InterlockedIncrement( &g_MsgID );

	hr=ExchangeAndParse( (PCHAR)&FreeReq,
						 sizeof(FreeReq),
						 &RespInfo,
						 FreeReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );

	Unlock();


	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_FREE_RESPONSE){
		IMPORTANT_MSG((L"Failing registration, response was message type %d\n",RespInfo.msgtype));
		goto error_exit;
	}

exit:
	TRIVIAL_MSG((L"<==Release Port, Succeeded" ));
	return hr;

error_exit:
	IMPORTANT_MSG((L"<==Release Port, Failed" ));
	return DPNERR_GENERIC;

}

/*=============================================================================

	QueryLocalAddress - get the local address of a public address

    Description:

    	Before connecting to anyone we need to see if there is a local
    	alias for its global address.  This is because the gateway will
    	not loopback if we try and connect to the global address, so
    	we need to know the local alias.

    Parameters:

    	BOOL		 ftcp_udp - whether we are querying a UDP or TCP port
    	SOCKADDR     saddrquery - the address to look up
    	SOCKADDR     saddrlocal - local alias if one exists

    Return Values:

		DPN_OK - got a local address.
		other - no mapping exists.

-----------------------------------------------------------------------------*/
HRESULT QueryLocalAddress( BOOL ftcp_udp, SOCKADDR *saddrquery, SOCKADDR *saddrlocal )
{
	#define saddrquery_in ((const SOCKADDR_IN *)saddrquery)
	#define saddrlocal_in ((SOCKADDR_IN *)saddrlocal)
	HRESULT hr;

	MSG_RSIP_QUERY  QueryReq;
	RSIP_RESPONSE_INFO RespInfo;

	PADDR_ENTRY pAddrEntry;
	SOCKADDR	RecvSocketAddress;


	Lock();

	TRIVIAL_MSG((L"==>RSIP QueryLocalAddress" ));
	DumpSocketAddress( 8, saddrquery, saddrquery->sa_family );

	if(g_sRsip == INVALID_SOCKET){
		IMPORTANT_MSG((L"rsipQueryLocalAddress: g_sRsip is invalid, bailing...\n"));
		Unlock();
		return DPNERR_GENERIC;
	}

	// see if we have a cached entry.

	if(pAddrEntry=FindCacheEntry(ftcp_udp,saddrquery_in->sin_addr.s_addr,saddrquery_in->sin_port)){
		if(pAddrEntry->raddr){
			saddrlocal_in->sin_family      = AF_INET;
			saddrlocal_in->sin_addr.s_addr = pAddrEntry->raddr;
			saddrlocal_in->sin_port        = pAddrEntry->rport;
			Unlock();
			TRIVIAL_MSG((L"<==Found Local address in cache.\n" ));
			return DPN_OK;
		} else {
			TRIVIAL_MSG((L"<==Found lack of local address in cache\n" ));
			Unlock();
			return DPNERR_GENERIC;
		}
	}		

	// Build the request

	QueryReq.version    		= RSIP_VERSION;
	QueryReq.command    		= RSIP_QUERY_REQUEST;

	QueryReq.clientid.code 		= RSIP_CLIENTID_CODE;
	QueryReq.clientid.len 		= sizeof(DWORD);
	QueryReq.clientid.clientid 	= g_ClientID;

	QueryReq.address.code		= RSIP_ADDRESS_CODE;
	QueryReq.address.len		= sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	QueryReq.address.version	= 1; // IPv4
	QueryReq.address.addr		= saddrquery_in->sin_addr.s_addr;

	QueryReq.port.code			= RSIP_PORTS_CODE;
	QueryReq.port.len			= sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	QueryReq.port.nports      	= 1;
	QueryReq.port.port			= htons(saddrquery_in->sin_port);

	QueryReq.porttype.code      = RSIP_VENDOR_CODE;
	QueryReq.porttype.len       = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	QueryReq.porttype.vendorid  = RSIP_MS_VENDOR_ID;
	QueryReq.porttype.option    = (ftcp_udp)?RSIP_TCP_PORT:RSIP_UDP_PORT;

	QueryReq.querytype.code	    = RSIP_VENDOR_CODE;
	QueryReq.querytype.len	    = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	QueryReq.querytype.vendorid = RSIP_MS_VENDOR_ID;
	QueryReq.querytype.option   = RSIP_QUERY_MAPPING;

	QueryReq.msgid.code 	    = RSIP_MESSAGEID_CODE;
	QueryReq.msgid.len  	    = sizeof(DWORD);
	QueryReq.msgid.msgid   		= InterlockedIncrement( &g_MsgID );

	hr=ExchangeAndParse( (PCHAR)&QueryReq,
						 sizeof(QueryReq),
						 &RespInfo,
						 QueryReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );

	Unlock();

	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_QUERY_RESPONSE){
		IMPORTANT_MSG((L"Failing query, response was message type %d\n",RespInfo.msgtype));
		goto error_exit;
	}

	saddrlocal_in->sin_family      = AF_INET;
	saddrlocal_in->sin_addr.s_addr = RespInfo.lAddressV4;
	saddrlocal_in->sin_port        = htons(RespInfo.lPort);

	//rsipAddCacheEntry(pgd,ftcp_udp,saddrquery_in->sin_addr.s_addr,saddrquery_in->sin_port,RespInfo.lAddressV4,p_htons(RespInfo.lPort));

	TRIVIAL_MSG((L"<==RSIP QueryLocalAddress, local alias is" ));
	DumpSocketAddress( 8, (SOCKADDR*)( saddrlocal_in ), saddrlocal_in->sin_family );

exit:
	return hr;

error_exit:
	AddCacheEntry(ftcp_udp,saddrquery_in->sin_addr.s_addr,saddrquery_in->sin_port,0,0);
	INTERESTING_MSG((L"<==RSIP QueryLocalAddress, NO Local alias\n" ));
	return DPNERR_GENERIC;

	#undef saddrlocal_in
	#undef saddrquery_in
}

/*=============================================================================

	ListenPort - assign a port mapping with the rsip server with a fixed
					 port.

    Description:

		Only used for the host server port (the one that is used for enums).
		Other than the fixed port this works the same as an rsipAssignPort.

		Since the port is fixed, the local and public port address are
		obviously the same.

    Parameters:

    	WORD	     port     - local port to get a remote port for (big endian)
    	BOOL		 ftcp_udp - whether we are assigning a UDP or TCP port
    	SOCKADDR     psaddr   - place to return assigned global realm address
    	PDWORD       pBindid  - identifier for this binding, used to extend
    							lease and/or release the binding (OPTIONAL).
    Return Values:

		DPN_OK - assigned succeeded, psaddr contains public realm address,
				*pBindid is the binding identifier.

		DPNERR_GENERIC - assignment of a public port could not be made.


-----------------------------------------------------------------------------*/

HRESULT ListenPort( BOOL ftcp_udp, WORD port, SOCKADDR *psaddr, DWORD *pBindid )
{
	#define psaddr_in ((SOCKADDR_IN *)psaddr)

	HRESULT hr;
	SOCKADDR	RecvSocketAddress;

	MSG_RSIP_LISTEN_PORT ListenReq;
	RSIP_RESPONSE_INFO RespInfo;

	Lock();

	TRIVIAL_MSG((L"RSIP Listen Port %d\n", htons( port ) ));

	if(g_sRsip == INVALID_SOCKET){
		IMPORTANT_MSG((L"rsipListenPort: g_sRsip is invalid, bailing...\n"));
		Unlock();
		return DPNERR_GENERIC;
	}

	// Build the request

	ListenReq.version    		  = RSIP_VERSION;
	ListenReq.command    		  = RSIP_LISTEN_REQUEST;

	ListenReq.clientid.code 	  = RSIP_CLIENTID_CODE;
	ListenReq.clientid.len 		  = sizeof(DWORD);
	ListenReq.clientid.clientid   = g_ClientID;

	// Local Address (will be returned by RSIP server, us don't care value)

	ListenReq.laddress.code		  = RSIP_ADDRESS_CODE;
	ListenReq.laddress.len		  = sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	ListenReq.laddress.version	  = 1; // IPv4
	ListenReq.laddress.addr		  = 0; // Don't care

	// Local Port, this is a port we have opened that we are assigning a
	// global alias for.

	ListenReq.lport.code		 = RSIP_PORTS_CODE;
	ListenReq.lport.len			 = sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	ListenReq.lport.nports       = 1;
	ListenReq.lport.port		 = htons(port);//->little endian for wire

	// Remote Address (not used with our flow control policy, use don't care value)

	ListenReq.raddress.code		 = RSIP_ADDRESS_CODE;
	ListenReq.raddress.len		 = sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	ListenReq.raddress.version   = 1; // IPv4
	ListenReq.raddress.addr      = 0; // Don't care

	ListenReq.rport.code		 = RSIP_PORTS_CODE;
	ListenReq.rport.len			 = sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	ListenReq.rport.nports       = 1;
	ListenReq.rport.port		 = 0; // Don't care

	// Following parameters are optional according to RSIP spec...

	// Lease code, ask for an hour, but don't count on it.

	ListenReq.lease.code		 = RSIP_LEASE_CODE;
	ListenReq.lease.len			 = sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	ListenReq.lease.leasetime    = 3600;

	// Tunnell Type is IP-IP

	ListenReq.tunnel.code		 = RSIP_TUNNELTYPE_CODE;
	ListenReq.tunnel.len		 = sizeof(RSIP_TUNNEL)-sizeof(RSIP_PARAM);
	ListenReq.tunnel.tunneltype  = TUNNEL_IP_IP;

	// Message ID is optional, but we use it since we use UDP xport it is required.

	ListenReq.msgid.code 		 = RSIP_MESSAGEID_CODE;
	ListenReq.msgid.len  		 = sizeof(DWORD);
	ListenReq.msgid.msgid   	 = InterlockedIncrement( &g_MsgID );

	// Vendor specific - need to specify port type and no-tunneling

	ListenReq.porttype.code      = RSIP_VENDOR_CODE;
	ListenReq.porttype.len       = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.porttype.vendorid  = RSIP_MS_VENDOR_ID;
	ListenReq.porttype.option    = (ftcp_udp)?(RSIP_TCP_PORT):(RSIP_UDP_PORT);

	ListenReq.tunneloptions.code     = RSIP_VENDOR_CODE;
	ListenReq.tunneloptions.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.tunneloptions.vendorid = RSIP_MS_VENDOR_ID;
	ListenReq.tunneloptions.option   = RSIP_NO_TUNNEL;

	ListenReq.listentype.code     = RSIP_VENDOR_CODE;
	ListenReq.listentype.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.listentype.vendorid = RSIP_MS_VENDOR_ID;
	ListenReq.listentype.option   = RSIP_SHARED_UDP_LISTENER;


	hr=ExchangeAndParse( (PCHAR)&ListenReq,
						 sizeof(ListenReq),
						 &RespInfo,
						 ListenReq.msgid.msgid,
						 FALSE,
						 &RecvSocketAddress );
	Unlock();

	if(hr!=DPN_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_LISTEN_RESPONSE){
		IMPORTANT_MSG((L"Assignment failed? Response was %d\n",RespInfo.msgtype));
		goto error_exit;
	}

	if(psaddr_in){
		psaddr_in->sin_family      = AF_INET;
		psaddr_in->sin_addr.s_addr = RespInfo.lAddressV4;
		psaddr_in->sin_port        = htons(RespInfo.lPort);// currently little endian on wire

		TRIVIAL_MSG((L"RSIP Listen, public address is" ));
		DumpSocketAddress( 8, (SOCKADDR*)( psaddr_in ), psaddr_in->sin_family );
	}

	if(pBindid){
		*pBindid = RespInfo.bindid;
	}	

	// remember the lease so we will renew it when necessary.
	AddLease(RespInfo.bindid,ftcp_udp,RespInfo.lAddressV4,htons(RespInfo.lPort),port,RespInfo.leasetime);

exit:
	TRIVIAL_MSG((L"<==RSIP Listen succeeded\n" ));
	return hr;

error_exit:
	IMPORTANT_MSG((L"<==RSIP Listen failed\n"));
	return DPNERR_GENERIC;

	#undef psaddr_in
}

/*=============================================================================

	FindLease - see if we already have a lease for a local port.

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
PRSIP_LEASE_RECORD FindLease( BOOL ftcp_udp, WORD port)
{
	PRSIP_LEASE_RECORD pLeaseWalker;

	pLeaseWalker = g_pRsipLeaseRecords;

	while(pLeaseWalker){
		if( ( pLeaseWalker->ftcp_udp == ftcp_udp ) && ( pLeaseWalker->port == port ) )
		{
			break;
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}

	return pLeaseWalker;
}

/*=============================================================================

	AddLease - adds a lease record to our list of leases

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

void	AddLease( DWORD bindid, BOOL ftcp_udp, DWORD addrV4, WORD rport, WORD port, DWORD tLease)
{
	RSIP_LEASE_RECORD	*pLeaseWalker;
	RSIP_LEASE_RECORD	*pNewLease;
	DWORD	tNow;

	tNow=timeGetTime();

	// First see if we already have a lease for this port;
	Lock();

	// first make sure there isn't already a lease for this port
	pLeaseWalker = g_pRsipLeaseRecords;
	while(pLeaseWalker){
		if(pLeaseWalker->ftcp_udp == ftcp_udp &&
		   pLeaseWalker->port     == port     &&
		   pLeaseWalker->bindid   == bindid
		)
		{
			break;
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}

	if(pLeaseWalker){
		pLeaseWalker->dwRefCount++;
		pLeaseWalker->tExpiry = tNow+(tLease*1000);
	} else {
		pNewLease = (RSIP_LEASE_RECORD*)( malloc( sizeof( *pNewLease ) ) );
		if(pNewLease){
			pNewLease->dwRefCount = 1;
			pNewLease->ftcp_udp   = ftcp_udp;
			pNewLease->tExpiry    = tNow+(tLease*1000);
			pNewLease->bindid     = bindid;
			pNewLease->port		  = port;
			pNewLease->rport      = rport;
			pNewLease->addrV4     = addrV4;
			pNewLease->pNext	  = g_pRsipLeaseRecords;
			g_pRsipLeaseRecords= pNewLease;
		} else {
			IMPORTANT_MSG((L"rsip: Couldn't allocate new lease block for port %x\n",port));
		}
	}

	Unlock();
}

/*=============================================================================

	RemoveLease - removes a lease record from our list of leases

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
void	RemoveLease( DWORD bindid )
{
	PRSIP_LEASE_RECORD pLeaseWalker, pLeasePrev;

	TRIVIAL_MSG((L"==>rsipRemoveLease bindid %d\n", bindid));

	Lock();

	pLeaseWalker = g_pRsipLeaseRecords;
	pLeasePrev=(PRSIP_LEASE_RECORD)&g_pRsipLeaseRecords; //sneaky.

	while(pLeaseWalker){
		if(pLeaseWalker->bindid==bindid){
			--pLeaseWalker->dwRefCount;
			if(!pLeaseWalker->dwRefCount){
				// link over it
				pLeasePrev->pNext=pLeaseWalker->pNext;
				TRIVIAL_MSG((L"rsipRemove: removing bindid %d\n", bindid ));
				free(pLeaseWalker);
			} else {
				TRIVIAL_MSG((L"Remove: refcount on bindid %d is %d\n", bindid, pLeaseWalker->dwRefCount ));
			}
			break;
		}
		pLeasePrev=pLeaseWalker;
		pLeaseWalker=pLeaseWalker->pNext;
	}

	Unlock();

	TRIVIAL_MSG((L"<==rsipRemoveLease bindid %d\n", bindid ));
}

/*=============================================================================

	PortExtend - checks if port leases needs extension and extends
					 them if necessary

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
BOOL	PortExtend( DWORD time )
{
	BOOL	bRet = TRUE;
	PRSIP_LEASE_RECORD pLeaseWalker;
	DWORD tExtend;
	HRESULT hr;


	Lock();

	pLeaseWalker = g_pRsipLeaseRecords;
	while(pLeaseWalker)
	{

		if((int)(pLeaseWalker->tExpiry - time) < 180000)
		{
			// less than 3 minutes left on lease.
			hr=ExtendPort(pLeaseWalker->bindid, &tExtend);			
			if(hr != DPN_OK)
			{
				// this binding is now gone!
				IMPORTANT_MSG((L"Couldn't renew lease on bindid %d, port %x\n",pLeaseWalker->bindid, pLeaseWalker->port));
				bRet = FALSE;
			} 
			else 
			{
				pLeaseWalker->tExpiry=time+(tExtend*1000);
				TRIVIAL_MSG((L"rsip: Extended Lease of Port %x by %d seconds\n", pLeaseWalker->bindid, tExtend ));
//				assert(tExtend > 180);
			}
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}

	Unlock();
	return bRet;
}


/*=============================================================================

	FindCacheEntry

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
PADDR_ENTRY FindCacheEntry( BOOL ftcp_udp, DWORD addr, WORD port)
{
	PADDR_ENTRY pAddrWalker;

	pAddrWalker = g_pAddrEntry;

	while(pAddrWalker){
		if(pAddrWalker->ftcp_udp == ftcp_udp &&
		   pAddrWalker->port     == port     &&
		   pAddrWalker->addr     == addr
		)
		{
			// if he looked it up, give it another minute to time out.
			pAddrWalker->tExpiry=timeGetTime()+60*1000;
			// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
			TRIVIAL_MSG((L"Returning Cache Entry Addr:Port (%p:%d)  Alias Addr:(Port %p:%d)\n", \
				pAddrWalker->addr,			\
				htons(pAddrWalker->port),	\
				pAddrWalker->raddr,			\
				htons(pAddrWalker->rport)));
			break;
		}
		pAddrWalker=pAddrWalker->pNext;
	}

	return pAddrWalker;


}

/*=============================================================================

	AddCacheEntry - adds a cache entry or updates timeout on existing one.

    Description:

    	Adds an address mapping from public realm to local realm (or the
    	lack of such a mapping) to the cache of mappings.

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
void	AddCacheEntry( BOOL ftcp_udp, DWORD addr, WORD port, DWORD raddr, WORD rport)
{
	ADDR_ENTRY	*pAddrWalker;
	ADDR_ENTRY	*pNewAddr;
	DWORD		tNow;


	tNow=timeGetTime();

	// First see if we already have a lease for this port;
	Lock();

	// first make sure there isn't already a lease for this port
	pAddrWalker = g_pAddrEntry;
	while(pAddrWalker){
		if(pAddrWalker->ftcp_udp == ftcp_udp &&
		   pAddrWalker->port     == port     &&
		   pAddrWalker->addr     == addr
		)
		{
			break;
		}
		pAddrWalker=pAddrWalker->pNext;
	}

	if(pAddrWalker){
		pAddrWalker->tExpiry = tNow+(60*1000); // keep for 60 seconds or 60 seconds from last reference
	} else {
		pNewAddr = (ADDR_ENTRY*)( malloc( sizeof( *pNewAddr ) ) );
		if(pNewAddr){
			// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
			TRIVIAL_MSG((L"Added Cache Entry Addr:Port (%p:%d)  Alias Addr:(Port %p:%d)\n", addr, htons( port ), raddr, htons( rport ) ));
			pNewAddr->ftcp_udp   = ftcp_udp;
			pNewAddr->tExpiry    = tNow+(60*1000);
			pNewAddr->port		 = port;
			pNewAddr->addr		 = addr;
			pNewAddr->rport      = rport;
			pNewAddr->raddr      = raddr;
			pNewAddr->pNext	     = g_pAddrEntry;
			g_pAddrEntry		 = pNewAddr;
		} else {
			IMPORTANT_MSG((L"rsip: Couldn't allocate new lease block for port %x\n",port));
		}
	}

	Unlock();
}


/*=============================================================================

	CacheClear - checks if cached mappings are old and deletes them.

    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
void CacheClear( DWORD time )
{
	PADDR_ENTRY pAddrWalker, pAddrPrev;


	Lock();

	pAddrWalker = g_pAddrEntry;
	pAddrPrev=(PADDR_ENTRY)&g_pAddrEntry; //sneaky.

	while(pAddrWalker){

		if((int)(pAddrWalker->tExpiry - time) < 0){
			// cache entry expired.
			pAddrPrev->pNext=pAddrWalker->pNext;
			// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
			TRIVIAL_MSG((L"rsipRemove: removing cached address entry %p\n", pAddrWalker ));
			free(pAddrWalker);
		} else {
			pAddrPrev=pAddrWalker;
		}	
		pAddrWalker=pAddrPrev->pNext;
	}

	Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icshelper\rsip.h ===
#ifndef __RSIP_H_
#define __RSIP_H_
#include "rsipdefs.h"	// make certain this is defined first!

// globals here
extern CRITICAL_SECTION	g_CritSec;
extern SOCKET  			g_sRsip;
extern SOCKADDR_IN		g_saddrGateway;
extern SOCKADDR			g_saddrPublic;

extern int					g_iPort;
extern DWORD				g_ClientID;
extern HANDLE				g_hThreadEvent;
extern HANDLE				g_hAlertEvent;

extern RSIP_LEASE_RECORD	*g_pRsipLeaseRecords;	// list of leases.
extern ADDR_ENTRY        	*g_pAddrEntry;			// cache of mappings.
extern DWORD 		 		g_tuRetry;				// microseconds starting retry time.
extern LONG					g_MsgID;


/*
 *	Here is all the RSIP code we swiped from the DirectPlay guys
 */
BOOL	Initialize(	SOCKADDR *pBaseSocketAddress,
					BOOL fIsRsipServer );

void	Deinitialize( void );

BOOL	RsipIsRunningOnThisMachine( SOCKADDR *pPublicSocketAddress );

HRESULT	AssignPort( BOOL fTCP_UDP,
					WORD wPort,
					SOCKADDR *pSocketAddress,
					DWORD *pdwBindID );	// gets address on RSIP box

HRESULT FreePort( DWORD dwBindID );		// when port is done

HRESULT QueryLocalAddress( BOOL fTCP_UDP,
						   SOCKADDR *pQueryAddress,
						   SOCKADDR *pLocalAddress) ;	// called to map remote to local

HRESULT ListenPort( BOOL fTCP_UDP,
					WORD wPort,
					SOCKADDR *pListenAddress,
					DWORD *pBindID );		// called for ROD

HRESULT	FindGateway( UINT myip, char *gwipaddr);
HRESULT	Register( void );
HRESULT	Deregister( void );

DWORD	ExchangeAndParse( PCHAR pRequest,
						  UINT cbReq,
						  RSIP_RESPONSE_INFO *pRespInfo,
						  DWORD messageid,
						  BOOL bConnect,
						  SOCKADDR *pRecvSocketAddress );

HRESULT	Parse( CHAR *pBuf, DWORD cbBuf, RSIP_RESPONSE_INFO *pRespInfo );
HRESULT ExtendPort( DWORD Bindid, DWORD *ptExtend );
void	RemoveLease( DWORD dwBindID );
void	AddLease( DWORD dwBindID, BOOL fTCP_UDP, DWORD addrV4, WORD lport, WORD port, DWORD tLease);
RSIP_LEASE_RECORD	*FindLease( BOOL fTCP_UDP, WORD port );
void	AddCacheEntry( BOOL fTCP_UDP, DWORD addr, WORD port, DWORD raddr, WORD rport);
ADDR_ENTRY	*FindCacheEntry( BOOL fTCP_UDP, DWORD addr, WORD port);


void	RsipTimerComplete( HRESULT hCompletionCode, void *pContext );	
void	RsipTimerFunction( void *pContext );
BOOL 	PortExtend( DWORD dwTime );		// every 2 minutes
void 	CacheClear( DWORD dwTime );		// every 2 minutes
	


#endif // __RSIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icstest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ICSTEST.rc
//
#define IDC_MYICON                      2
#define IDC_MYICON2                     3
#define IDD_ICSTEST_DIALOG              102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDM_ABOUT2                      105
#define IDS_HELLO                       106
#define IDI_ICSTEST                     107
#define IDI_SMALL                       108
#define IDC_ICSTEST                     109
#define IDM_CLOSE                       110
#define IDS_ICS_NONE                    110
#define IDS_ICS_LOCAL                   111
#define IDS_ICS_DISTANT                 112
#define IDR_MAINFRAME                   128
#define IDD_MAIN                        129
#define IDC_ADDRLIST                    1003
#define IDC_ADDRLIST2                   1004
#define IDC_ICS_STAT                    1006
#define IDC_ICS_DLL_NAME                1007
#define IDC_LOCAL_ADDR                  1008
#define IDC_PUBLIC_ADDR                 1009
#define IDC_CONN_TYPES                  1010
#define IDC_ICS_DLL_NAME2               1011
#define IDC_LOCAL_ADDR2                 1012
#define IDC_PUBLIC_ADDR2                1013
#define IDC_ICS_STAT2                   1014
#define IDC_CONN_TYPES2                 1015
#define IDM_OPEN                        32771
#define IDM_OPEN2                       32772
#define ID_FILE_CLOSEPORT               32773
#define ID_FILE_REFRESH                 32774
#define ID_FILE_CLOSEALLPORTS           32775
#define ID_FILE_CLOSEPORT2              32776
#define ID_FILE_CLOSEALLPORTS2          32777
#define ID_FILE_REFRESH2                32778
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icshelper\rsipdefs.h ===
#ifndef __RSIPDEFS_H_FILE
#define __RSIPDEFS_H_FILE

//**********************************************************************
// Constant definitions
//**********************************************************************

/*
 * Whats implemented:
 *  as_req_rsap(localaddr=0,localports=4-a:b:c:d,
 *              remaddr=0,remports=0)
 *  as_res_rsap(localaddr=24.128.34.21,localports=4-A:B:C:D,
 *              remaddr=0,remports=0)
 *  where a,b,c,d are listening ports on the client (192.168.0.2)
 *        and A,B,C,D are the associated ports visible
 *        on the external IP address 24.128.34.21.
 *
 * Operation: When packet from the outside is destined for
 *            24.128.34.21:A is recieved, the ip->dst and udp->dst
 *            (or tcp->dst) fields are changed to 192.168.0.2:a
 *            and then sent along - unencapsulated.
 *            When a packet is sent out from the client, the
 *            app (e.g. dplay) uses 192.168.0.2:a as in the
 *            IP+UDP/TCP header but uses 24.128.34.21:A for
 *            any information encoded in the data portion of
 *            the packet.
 */
#define RSIP_VERSION 1
#define RSIP_HOST_PORT 2234

// How often we scan the list for liscence renewals
#define RSIP_RENEW_TEST_INTERVAL 60000

/* start RSIP retry timer at 12.5 ms */
#define RSIP_tuRETRY_START	12500
/* max starting retry is 100 ms */
#define RSIP_tuRETRY_MAX	100000

#define RESP_BUF_SIZE	100

enum { /* TUNNELS */
  TUNNEL_RESERVED = 0,
  TUNNEL_IP_IP = 1,
  TUNNEL_GRE = 2, /* PPTP */
  TUNNEL_L2TP = 3,
  /*TUNNEL_NONE = 4, /* THIS IS NOT PART OR THE SPEC */
};
enum { /* METHODS */
  METHOD_RESERVED = 0,
  RSA_IP = 1,
  RSAP_IP = 2,
  RSA_IP_IPSEC = 3,
  RSAP_IP_IPSEC = 4,
};
enum { /* FLOWS */
  FLOW_RESERVED = 0,
  FLOW_MACRO = 1,
  FLOW_MICRO = 2,
  FLOW_NONE = 3,
};
enum { /* ERROR CODES */
  UNKNOWNERROR = 1,
  BADBINDID = 2,
  BADCLIENTID = 3,
  MISSINGPARAM = 4,
  DUPLICATEPARAM = 5,
  ILLEGALPARAM = 6,
  ILLEGALMESSAGE = 7,
  REGISTERFIRST = 8,
  BADMESSAGEID = 9,
  ALREADYREGISTERED = 10,
  ALREADYUNREGISTERED = 11,
  BADTUNNELTYPE = 12,
  ADDRUNAVAILABLE = 13,
  PORTUNAVAILABLE = 14,
};

enum { /* MESSAGES */
  RSIP_ERROR_RESPONSE = 1,
  RSIP_REGISTER_REQUEST = 2,
  RSIP_REGISTER_RESPONSE = 3,
  RSIP_DEREGISTER_REQUEST = 4,
  RSIP_DEREGISTER_RESPONSE = 5,
  RSIP_ASSIGN_REQUEST_RSA_IP = 6,
  RSIP_ASSIGN_RESPONSE_RSA_IP = 7,
  RSIP_ASSIGN_REQUEST_RSAP_IP = 8,
  RSIP_ASSIGN_RESPONSE_RSAP_IP = 9,
  RSIP_EXTEND_REQUEST = 10,
  RSIP_EXTEND_RESPONSE = 11,
  RSIP_FREE_REQUEST = 12,
  RSIP_FREE_RESPONSE = 13,
  RSIP_QUERY_REQUEST = 14,
  RSIP_QUERY_RESPONSE = 15,
  RSIP_DEALLOCATE = 16,
  RSIP_OK = 17,
  RSIP_LISTEN_REQUEST = 18,
  RSIP_LISTEN_RESPONSE = 19,
};
enum { /* PARAMETERS */
  RSIP_ADDRESS_CODE = 1,
  RSIP_PORTS_CODE = 2,
  RSIP_LEASE_CODE = 3,
  RSIP_CLIENTID_CODE = 4,
  RSIP_BINDID_CODE = 5,
  RSIP_MESSAGEID_CODE = 6,
  RSIP_TUNNELTYPE_CODE = 7,
  RSIP_RSIPMETHOD_CODE = 8,
  RSIP_ERROR_CODE = 9,
  RSIP_FLOWPOLICY_CODE = 10,
  RSIP_VENDOR_CODE = 11,
};

/*
 * MS specific Vendor Codes
 */
#define RSIP_MS_VENDOR_ID 734
enum {
  RSIP_NO_TUNNEL = 1,
  RSIP_TCP_PORT = 2,
  RSIP_UDP_PORT = 3,
  RSIP_SHARED_UDP_LISTENER = 4,
  RSIP_QUERY_MAPPING = 5,
};

#define	ANY_PORT	0

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#pragma pack(push,1)

typedef struct _RSIP_MSG_HDR {
	CHAR	version;
	CHAR	msgtype;
} RSIP_MSG_HDR, *PRSIP_MSG_HDR;

typedef struct _RSIP_PARAM {
	CHAR	code;
	WORD	len;
} RSIP_PARAM, *PRSIP_PARAM;

typedef struct _RSIP_MESSAGEID{
	CHAR	code;
	WORD	len;
	DWORD   msgid;	
} RSIP_MESSAGEID, *PRSIP_MESSAGEID;

typedef struct _RSIP_CLIENTID {
	CHAR 	code;
	WORD	len;
	DWORD	clientid;
} RSIP_CLIENTID, *PRSIP_CLIENTID;

typedef struct _RSIP_ADDRESS {
	CHAR 	code;
	WORD	len;
	CHAR    version;	// 1==v4
	DWORD	addr;
} RSIP_ADDRESS, *PRSIP_ADDRESS;

typedef struct _RSIP_PORT {
	CHAR	code;
	WORD 	len;
	CHAR	nports;		// we only do 1 port at a time
	WORD	port;
} RSIP_PORT, *PRSIP_PORT;

typedef struct _RSIP_LEASE {
	CHAR	code;
	WORD	len;
	DWORD	leasetime;
} RSIP_LEASE, *PRSIP_LEASE;

typedef struct _RSIP_BINDID {
	CHAR	code;
	WORD	len;
	DWORD	bindid;
} RSIP_BINDID, *PRSIP_BINDID;

typedef struct _RSIP_TUNNEL {
	CHAR	code;
	WORD	len;
	CHAR	tunneltype;
} RSIP_TUNNEL, *PRSIP_TUNNEL;

// Vendor Specific structures

typedef struct _RSIP_MSVENDOR_CODE {
	CHAR	code;
	WORD	len;
	WORD	vendorid;
	WORD	option;
}RSIP_MSVENDOR_CODE, *PRSIP_MSVENDOR_CODE;

//
// RSIP Message templates
//

typedef struct _MSG_RSIP_REGISTER {
	CHAR			version;
	CHAR			command;
	RSIP_MESSAGEID  msgid;
} MSG_RSIP_REGISTER, *PMSG_RSIP_REGISTER;

typedef struct _MSG_RSIP_DEREGISTER {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID   clientid;
	RSIP_MESSAGEID  msgid;
} MSG_RSIP_DEREGISTER, *PMSG_RSIP_DEREGISTER;

typedef struct _MSG_RSIP_ASSIGN_PORT {
	CHAR 			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	laddress;	// local
	RSIP_PORT		lport;
	RSIP_ADDRESS	raddress;	// remote
	RSIP_PORT		rport;
	RSIP_LEASE		lease;
	RSIP_TUNNEL		tunnel;
	RSIP_MESSAGEID  msgid;

	RSIP_MSVENDOR_CODE  porttype;
	RSIP_MSVENDOR_CODE  tunneloptions;
} MSG_RSIP_ASSIGN_PORT, *PMSG_RSIP_ASSIGN_PORT;

typedef struct _MSG_RSIP_LISTEN_PORT {
	CHAR 			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	laddress;	// local
	RSIP_PORT		lport;
	RSIP_ADDRESS	raddress;	// remote
	RSIP_PORT		rport;
	RSIP_LEASE		lease;
	RSIP_TUNNEL		tunnel;
	RSIP_MESSAGEID  msgid;

	RSIP_MSVENDOR_CODE porttype;
	RSIP_MSVENDOR_CODE tunneloptions;
	RSIP_MSVENDOR_CODE listentype;
} MSG_RSIP_LISTEN_PORT, *PMSG_RSIP_LISTEN_PORT;


typedef struct _MSG_RSIP_EXTEND_PORT {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_BINDID		bindid;
	RSIP_LEASE		lease;
	RSIP_MESSAGEID	msgid;
} MSG_RSIP_EXTEND_PORT, *PMSG_RSIP_EXTEND_PORT;

typedef struct _MSG_RSIP_FREE_PORT {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_BINDID     bindid;
	RSIP_MESSAGEID	msgid;	
} MSG_RSIP_FREE_PORT, *PMSG_RSIP_FREE_PORT;

typedef struct _MSG_RSIP_QUERY {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	address;
	RSIP_PORT		port;

	RSIP_MSVENDOR_CODE porttype;
	RSIP_MSVENDOR_CODE querytype;

	RSIP_MESSAGEID	msgid;
} MSG_RSIP_QUERY, *PMSG_RSIP_QUERY;

typedef struct _RSIP_RESPONSE_INFO {
	DWORD	clientid;
	DWORD	messageid;
	DWORD	bindid;
	DWORD	leasetime;
	CHAR    version;
	CHAR    msgtype;
	CHAR	tunneltype;
	CHAR	rsipmethod;
	DWORD	lAddressV4;	
	WORD	lPort;
	DWORD   rAddressV4;
	WORD    rPort;
	WORD	error;
} RSIP_RESPONSE_INFO, *PRSIP_RESPONSE_INFO;

#pragma pack(pop)

typedef struct _RSIP_LEASE_RECORD {
	struct _RSIP_LEASE_RECORD * pNext;
	DWORD   dwRefCount;
	BOOL    ftcp_udp;
	DWORD	tExpiry;
	DWORD   bindid;
	DWORD   addrV4; // remote IP address
	SHORT   rport; 	// remote port
	SHORT	port;	// local port
} RSIP_LEASE_RECORD, *PRSIP_LEASE_RECORD;

// Cache of queried address mappings so we don't
// need to requery the mappings over and over
typedef struct _ADDR_ENTRY {
	struct _ADDR_ENTRY *pNext;
	BOOL	ftcp_udp;
	DWORD	tExpiry;
	DWORD	addr;
	DWORD	raddr;
	WORD	port;
	WORD	rport;
} ADDR_ENTRY, *PADDR_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

#if 0
static const char *rsip_error_strs[]={
  "RESERVED",
  "UNKNOWNERROR",
  "BADBINDID",
  "BADCLIENTID",
  "MISSINGPARAM",
  "DUPLICATEPARAM",
  "ILLEGALPARAM",
  "ILLEGALMESSAGE",
  "REGISTERFIRST",
  "BADMESSAGEID",
  "ALREADYREGISTERED",
  "ALREADYUNREGISTERED",
  "BADTUNNELTYPE",
  "ADDRUNAVAILABLE",
  "PORTUNAVAILABLE",
  (char *)0
};
#endif


#endif  // __RSIPDEFS_H_FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icstest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icstest\icstest.h ===
#if !defined(AFX_ICSTEST_H__F35B0083_3C91_4B4A_AED2_5010DEBBDB96__INCLUDED_)
#define AFX_ICSTEST_H__F35B0083_3C91_4B4A_AED2_5010DEBBDB96__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_ICSTEST_H__F35B0083_3C91_4B4A_AED2_5010DEBBDB96__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icstest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ICSTEST.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\ics\icstest\icstest.cpp ===
// ICSTEST.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "resource.h"
#include "..\icshelper\icshelpapi.h"
#include <winuser.h>
#include <mmsystem.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text
DWORD	hPort=0;
HANDLE	hAlertEvent=0;
int		iAlerts=0;
WCHAR	szAddr[4096];

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) sizeof(x)/sizeof(x[0])
#endif

// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
	MSG msg;
//	HACCEL hAccelTable;
	HWND hWnd;
	WNDCLASSEX wcex;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_ICSTEST, szWindowClass, MAX_LOADSTRING);
	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= DLGWINDOWEXTRA;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_ICSTEST);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= GetSysColorBrush(COLOR_BTNFACE);
	wcex.lpszMenuName	= NULL;	//(LPCSTR)IDC_ICSTEST;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);
	RegisterClassEx(&wcex);

	hInst = hInstance; // Store instance handle in our global variable

	hWnd = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_MAIN), 0, (DLGPROC)WndProc);

	ShowWindow(hWnd, nCmdShow);

//	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_ICSTEST);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
//		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}

void fileSpew(HANDLE hFile, WCHAR *szMessage)
{
	if (hFile)
		_write((int)hFile, szMessage, (2*lstrlenW(szMessage)));
}

WCHAR szLogfileName[MAX_PATH];

HANDLE OpenSpewFile(void)
{
	HANDLE iDbgFileHandle;

	GetSystemWindowsDirectoryW(szLogfileName, sizeof(szLogfileName)/sizeof(szLogfileName[0]));
	lstrcatW(szLogfileName, L"\\PCHealthICStest.log");

	iDbgFileHandle = (HANDLE)_wopen(szLogfileName, _O_APPEND | _O_BINARY | _O_RDWR, 0);
	if (-1 != (int)iDbgFileHandle)
	{
		OutputDebugStringA("opened debug log file:");
		OutputDebugStringW(szLogfileName);
		OutputDebugStringA("\r\n");
	}
	else
	{
		unsigned char UniCode[2] = {0xff, 0xfe};

		// we must create the file
		OutputDebugStringA("must create debug log file");
		iDbgFileHandle = (HANDLE)_wopen(szLogfileName, _O_BINARY | _O_CREAT | _O_RDWR, _S_IREAD | _S_IWRITE);
		if (-1 != (int)iDbgFileHandle)
			_write((int)iDbgFileHandle, &UniCode, sizeof(UniCode));
		else
		{
			OutputDebugStringA("ERROR: failed to create debug log file");
			iDbgFileHandle = 0;
		}
	}

	return iDbgFileHandle;
}

void CloseSpewFile(HANDLE hSpew)
{
	if (hSpew)
		_close((int)hSpew);
}

void ExecSpewFile(HANDLE hSpew)
{
	if (hSpew)
	{
		STARTUPINFOW	sui;
		PROCESS_INFORMATION	pi;

		ZeroMemory(&sui, sizeof(sui));
		sui.cb = sizeof(sui);

		OutputDebugStringA("start up:");
		OutputDebugStringW(szLogfileName);
		OutputDebugStringA("\r\n");

		if (CreateProcessW(L"%windir%\notepad.exe", szLogfileName, NULL, NULL, FALSE, 0, NULL, NULL, &sui, &pi))
		{
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
			OutputDebugStringA("started OK\r\n");
		}
		else
		{
			char foo[400];

			wsprintf(foo, "failed to start [%S], err=0x%x\r\n", szLogfileName, GetLastError());
			OutputDebugStringA(foo);
		}
	}
}

BOOL PrintSettings(HWND hWnd)
{
	WCHAR scratch[2000];
	ICSSTAT	is;
	HANDLE	hSpew;

	hSpew = OpenSpewFile();

	fileSpew(hSpew, L"ICS test results:\r\n");

	// get current address list
	FetchAllAddresses(scratch, ARRAYSIZE(scratch));
	fileSpew(hSpew, scratch);

	// get ICS status struct
	is.dwSize = sizeof(is);
	GetIcsStatus(&is);

	// print connection types
	wcscpy(scratch, L"Connections found: ");
	if (is.bModemPresent)
		wcscat(scratch, L"Modem connection");
	else
		wcscat(scratch, L"Network (LAN) connection");

	if (is.bVpnPresent)
		wcscat(scratch, L" with VPN");

	wcscat(scratch, L"\r\n");
	fileSpew(hSpew, scratch);


	if (is.bIcsFound)
	{
		if (is.bIcsServer)
		{
			// this is an ICS server
			fileSpew(hSpew, L"Found, server on this machine\r\n");
		}
		else
		{
			// must be an ICS client
			fileSpew(hSpew, L"Found, server not local\r\n");
		}
		wsprintfW(scratch, L"local addr=%s\r\npublic addr=%s\r\nDLL=%s", is.wszLocAddr, is.wszPubAddr, is.wszDllName);
		fileSpew(hSpew, scratch);
	}
	else
	{
		fileSpew(hSpew, L"no ICS found");
	}

	CloseSpewFile(hSpew);
	ExecSpewFile(hSpew);

	return TRUE;
}

BOOL	DisplaySettings(HWND hWnd)
{
	WCHAR scratch[2000];
	ICSSTAT	is;

	FetchAllAddresses(szAddr, ARRAYSIZE(szAddr));
	SetDlgItemTextW(hWnd, IDC_ADDRLIST, szAddr);

	is.dwSize = sizeof(is);
	GetIcsStatus(&is);

	scratch[0] = 0;
	if (is.bModemPresent)
		wcscat(scratch, L"Modem connection");
	else
		wcscat(scratch, L"Network (LAN) connection");

	if (is.bVpnPresent)
		wcscat(scratch, L" with VPN");
	SetDlgItemTextW(hWnd, IDC_CONN_TYPES, scratch);

	if (is.bIcsFound)
	{
		if (is.bIcsServer)
		{
			// this is an ICS server
			SetDlgItemText(hWnd, IDC_ICS_STAT, "Found, server on this machine");
		}
		else
		{
			// must be an ICS client
			SetDlgItemText(hWnd, IDC_ICS_STAT, "Found, server not local");
		}
		// set the addresses
		SetDlgItemTextW(hWnd, IDC_LOCAL_ADDR, is.wszLocAddr);
		SetDlgItemTextW(hWnd, IDC_PUBLIC_ADDR, is.wszPubAddr);
		// and the support DLL name
		SetDlgItemTextW(hWnd, IDC_ICS_DLL_NAME, is.wszDllName);
	}
	else
	{
		char *szNullIP = "";
		SetDlgItemText(hWnd, IDC_ICS_STAT, "none found");
		SetDlgItemText(hWnd, IDC_ICS_DLL_NAME, szNullIP);
		SetDlgItemText(hWnd, IDC_LOCAL_ADDR, szNullIP);
		SetDlgItemText(hWnd, IDC_PUBLIC_ADDR, szNullIP);
	}

	return TRUE;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	TEXTMETRIC	tm;
	HDC hdc;
	int i;

	switch (message) 
	{
		case WM_INITDIALOG:
			hAlertEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
			StartICSLib();
			SetAlertEvent(hAlertEvent);
			Sleep(250);	// gives the lib time to start up...
			SetTimer(hWnd, 1, 1000, NULL);
			DisplaySettings(hWnd);
			break;

		case WM_TIMER:
			if (hAlertEvent)
			{
				if (WaitForSingleObjectEx(hAlertEvent, 0, FALSE) == WAIT_OBJECT_0)
				{
					FLASHWINFO	fw;

					fw.cbSize=sizeof(fw);
					fw.hwnd=hWnd;
					fw.dwFlags=FLASHW_ALL;
					fw.uCount=8;
					fw.dwTimeout=0;

					DisplaySettings(hWnd);

					iAlerts++;

					FlashWindowEx(&fw);

					PlaySound("AddressChange", NULL, SND_ASYNC);
					ResetEvent(hAlertEvent);
				}
			}
			break;

		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			SetFocus(hWnd);

			// Parse the menu selections:
			switch (wmId)
			{
				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
				   break;
				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;
				case ID_FILE_CLOSEPORT:
					if (hPort)
					{
						ClosePort(hPort);
						DisplaySettings(hWnd);
					}
					hPort = 0;
					break;
				case ID_FILE_CLOSEALLPORTS:
					CloseAllOpenPorts();
					DisplaySettings(hWnd);
					hPort = 0;
					break;
				case ID_FILE_REFRESH:
					DisplaySettings(hWnd);
					break;
				case IDC_MYICON:
					PrintSettings(hWnd);
					break;
				case IDM_OPEN:
					if (!hPort)
					{
						hPort = OpenPort(3389);
						DisplaySettings(hWnd);
					}
					break;
				default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;

		case WM_DESTROY:
			KillTimer(hWnd, 1);
			SetAlertEvent(0);
			CloseHandle(hAlertEvent);
			hAlertEvent=0;
			CloseAllOpenPorts();
			StopICSLib();
			PostQuitMessage(0);
			break;

		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

// Mesage handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RDSHost.rc
//
#define IDS_PROJNAME						100
#define IDR_RDSHost							100
#define IDR_REMOTEDESKTOPSERVERHOST			101
#define IDR_REMOTEDESKTOPSESSION			102
#define	IDR_TSRDPSERVERCHANNELMGR			201
#define	IDR_TSRDPSERVERDATACHANNEL			203
#define	IDR_CLIENTREMOTEDESTKOPCHANNELMGR	204


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE			211
#define _APS_NEXT_COMMAND_VALUE				32768
#define _APS_NEXT_CONTROL_VALUE				201
#define _APS_NEXT_SYMED_VALUE				103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\rdshostcp.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDSHostCP.h

Abstract:

    Wizard-generated code for invoking server-side event sink functions.

    I added the "scriptDisp" field.  If it is non-NULL, then its default method
    will be called along with any registered interfaces.  This is to accomodate
    script clients that need to bind their event interfaces when the script
    engine initializes.  Our objects are dynamically retrieved by the client
    script or application post-init.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef _RDSHOSTCP_H_
#define _RDSHOSTCP_H_


template <class T>
class CProxy_ISAFRemoteDesktopSessionEvents : public IConnectionPointImpl<T, &DIID__ISAFRemoteDesktopSessionEvents, CComDynamicUnkArray>
{
public:

	VOID Fire_ClientConnected(IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				HRESULT hr = pDispatch->Invoke(DISPID_RDSSESSIONSEVENTS_CLIENTCONNECTED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}

        //
        //  Invoke the scriptable IDispatch interface, if specified.
        //
        if (scriptDisp != NULL) {
			DISPPARAMS disp = { NULL, NULL, 0, 0 };
			HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
        }
	}

	VOID Fire_ClientDisconnected(IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				HRESULT hr = pDispatch->Invoke(DISPID_RDSSESSIONSEVENTS_CLIENTDISCONNECTED, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}

        //
        //  Invoke the scriptable IDispatch interface, if specified.
        //
        if (scriptDisp != NULL) {
			DISPPARAMS disp = { NULL, NULL, 0, 0 };
			HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
        }
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\rdshost.cpp ===
// RDSHost.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f RDSHostps.mk in the project directory.

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_rdshost"

#include "resource.h"
#include <initguid.h>
#include "RDSHost.h"

#include "RDSHost_i.c"
#include "RemoteDesktopServerHost.h"


const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Lock()
{
    DC_BEGIN_FN("CExeModule::Lock");

    LONG l = CComModule::Lock();
    TRC_NRM((TB, L"Lock count:  %ld", l));

    DC_END_FN();
    return l;
}

LONG CExeModule::Unlock()
{
    DC_BEGIN_FN("CExeModule::Unlock");

    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }

    TRC_NRM((TB, L"Lock count:  %ld", l));
    DC_END_FN();
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAFRemoteDesktopServerHost, CRemoteDesktopServerHost)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT


#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));

    //
    // This makes us accessible by anyone from user-mode.  This is required from
    // a security perspective because our interfaces are passed from SYSTEM context
    // to USER context, by a "trusted" creator.
    //
    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();
    HRESULT testHR = CoInitializeSecurity(sd, -1, NULL, NULL,
                            RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, 
                            NULL, EOAC_NONE, NULL);
    _ASSERTE(SUCCEEDED(testHR));

    _Module.Init(ObjectMap, hInstance, &LIBID_RDSSERVERHOSTLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_RDSHost, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_RDSHost, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {

        WSADATA wsaData;

        //
        // ignore WinSock startup error, failure in starting Winsock does not
        // damage our function, only thing will failed is gethostbyname()
        // which is use in callback, however, connection parameter contain
        // all IP address except last one is the machine name.
        //
        WSAStartup(0x0101, &wsaData);

        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish

        WSACleanup();
    }

    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\serverdatachannelmgrp.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    DataChannelMgrP.h

Abstract:

    Wizard-generated code for invoking data channel event sink functions.

    I added the "scriptDisp" field.  If it is non-NULL, then its default method
    will be called along with any registered interfaces.  This is to accomodate
    script clients that need to bind their event interfaces when the script
    engine initializes.  Our objects are dynamically retrieved by the client
    script or application post-init.

Author:

    Tad Brockway 06/00

Revision History:

--*/

#ifndef _DATACHANNELMGRP_H_
#define _DATACHANNELMGRP_H_

#include <atlcom.h>

template <class T>
class CProxy_ISAFRemoteDesktopDataChannelEvents : public IConnectionPointImpl<T, &DIID__ISAFRemoteDesktopDataChannelEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_ChannelDataReady(BSTR channelName, IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];

        if (pvars) {
    		int nConnections = m_vec.GetSize();
		
	    	for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
    		{
	    		pT->Lock();
			    CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			    pT->Unlock();
			    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			    if (pDispatch != NULL)
			    {
    				pvars[0] = channelName;
	    			DISPPARAMS disp = { pvars, NULL, 1, 0 };
				    pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			    }
		    }

            //
            //  Invoke the scriptable IDispatch interface, if specified.
            //
            if (scriptDisp != NULL) {
                pvars[0] = channelName;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
		    delete[] pvars;
	
	    }
    }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\remotedesktopsession.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDPRemoteDesktopSession

Abstract:

    The CRemoteDesktopSession class is the parent 
    class for the Remote Desktop class hierarchy on the server-side.  
    It helps the CRemoteDesktopServerHost class to implement 
    the ISAFRemoteDesktopSession interface.  
    
    The Remote Desktop class hierarchy provides a pluggable C++ interface 
    for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the server-side.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include <RemoteDesktop.h>
#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_srdses"

#include "RDSHost.h"
#include "RemoteDesktopSession.h"
#include "RemoteDesktopServerHost.h"
#include <sessmgr_i.c>
#include <objidl.h>
#include <objbase.h>


///////////////////////////////////////////////////////
//
//  CRemoteDesktopSession Methods
//

HRESULT 
CRemoteDesktopSession::FinalConstruct()
/*++

Routine Description:

    Final Constructor

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::FinalConstruct");

    DC_END_FN();

    return S_OK;
}

CRemoteDesktopSession::~CRemoteDesktopSession()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::~CRemoteDesktopSession");

    Shutdown();

    //
    //  Release any lingering outgoing interfaces.  Need to catch
    //  exceptions here in case the outgoing interface application
    //  has already gone away.
    //
    try {
        if (m_OnConnected != NULL) {
            m_OnConnected->Release();
        }
        if (m_OnDisconnected != NULL) {
            m_OnDisconnected->Release();
        }
    }
    catch (...) {
        TRC_ALT((TB, L"Exception caught in outgoing interface release."));
    }

    DC_END_FN();
}

HRESULT
CRemoteDesktopSession::Initialize(
    BSTR connectParms,
    CRemoteDesktopServerHost *hostObject,
    REMOTE_DESKTOP_SHARING_CLASS sharingClass,
    BOOL bEnableCallback,
    DWORD timeOut,
    BSTR userHelpCreateBlob,
    LONG tsSessionID,
    BSTR userSid
    )
/*++

Routine Description:

    The Initialize method prepares the COM object for connection by 
    the client-side Remote Desktop Host ActiveX Control.

Arguments:

    connectParms    -   If parms are non-NULL, then the session already exists.  
                        Otherwise, a new session should be created.
    hostObject      -   Back pointer to containing RDS Host object.
    sharingClass    -   Level of desktop sharing for a new session.
    bEnableCallback -   TRUE to instruct sessmgr to call session resolver, FALSE otherwise.
    timeOut         -   Help session timeout value.  0, if not specified.
    userHelpCreateBlob - user specified help session creation blob.
    tsSessionID     - Terminal Services Session ID or -1 if
                      undefined.  
    userSid         - User SID or "" if undefined.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::Initialize");

    HRESULT hr;
    DWORD ret;
    DWORD protocolType;
    CComBSTR parmsMachineName;
    CComBSTR parmsAssistantAccount;
    CComBSTR parmsAssistantAccountPwd;
    CComBSTR parmsHelpSessionName;
    CComBSTR parmsHelpSessionPwd;
    CComBSTR parmsProtocolSpecificParms;
    CComBSTR helpSessionName;
    CComBSTR sessionDescr;
    DWORD dwVersion;

    ASSERT(IsValid());
    if (!IsValid()) {
        return E_FAIL;
    }

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

    //
    //  Keep a back pointer to the RDS host object.
    //
    m_RDSHost = hostObject;

    //
    //  Open an instance of the Remote Desktop Help Session Manager service.
    //
    ASSERT(m_HelpSessionManager == NULL);
    hr = m_HelpSessionManager.CoCreateInstance(CLSID_RemoteDesktopHelpSessionMgr);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("Can't create help session manager:  %08X"), hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by 
    //  the session manager.
    //
    hr = CoSetProxyBlanket(
                (IUnknown *)m_HelpSessionManager,
                RPC_C_AUTHN_DEFAULT,
                RPC_C_AUTHZ_DEFAULT,
                NULL,
                RPC_C_AUTHN_LEVEL_DEFAULT,
                RPC_C_IMP_LEVEL_IMPERSONATE,
                NULL,
                EOAC_NONE
                );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("CoSetProxyBlanket:  %08X"), hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create a new help session if we don't already have connection 
    //  parms.
    //
    if (connectParms == NULL) {
        TRC_NRM((TB, L"Creating new help session."));
        GetSessionName(helpSessionName);
        GetSessionDescription(sessionDescr);

        hr = m_HelpSessionManager->CreateHelpSessionEx(
                                            sharingClass,
                                            bEnableCallback,
                                            timeOut,
                                            tsSessionID,
                                            userSid,
                                            userHelpCreateBlob,
                                            &m_HelpSession
                                            );
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, L"CreateHelpSession:  %08X", hr));
            goto CLEANUPANDEXIT;
        }

        hr = m_HelpSession->get_HelpSessionId(&m_HelpSessionID);
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, L"get_HelpSessionId:  %08X", hr));
            goto CLEANUPANDEXIT;
        }
    }
    else {

        //
        //  Parse the connection parms to get the help
        //  session ID.
        //
        ret = ParseConnectParmsString(
                            connectParms,
                            &dwVersion,
                            &protocolType,
                            parmsMachineName,
                            parmsAssistantAccount,
                            parmsAssistantAccountPwd,
                            m_HelpSessionID,
                            parmsHelpSessionName,
                            parmsHelpSessionPwd,
                            parmsProtocolSpecificParms
                            );
        if (ret != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(ret);
            goto CLEANUPANDEXIT;
        }

        //
        //  Open the help session interface.
        //
        hr = m_HelpSessionManager->RetrieveHelpSession(
                            m_HelpSessionID,
                            &m_HelpSession
                            );
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, L"Failed to open existing help session %s:  %08X.", 
                    m_HelpSessionID, hr));
            goto CLEANUPANDEXIT;
        }
        else {
            TRC_NRM((TB, L"Opened existing help session %s.", m_HelpSessionID));
        }

    }

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

void 
CRemoteDesktopSession::Shutdown()
/*++

Routine Description:

  The Shutdown method causes the COM object to no longer be 
  prepared for connection by the client-side Remote Desktop Host 
  ActiveX Control.

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::Shutdown");

    //
    //  Delete the help session created via the call to StartListening
    //  and delete the instance of the Remote Desktop Help Session Manager 
    //  service.
    //
    if (m_HelpSessionManager != NULL) {
        m_HelpSessionManager->DeleteHelpSession(m_HelpSessionID);
        m_HelpSessionManager = NULL;
    }

CLEANUPANDEXIT:

    DC_END_FN();
}

STDMETHODIMP 
CRemoteDesktopSession::put_SharingClass(
    REMOTE_DESKTOP_SHARING_CLASS sharingClass
    )
/*++

Routine Description:

    Set the desktop sharing level.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::put_SharingClass");

    HRESULT hr = m_HelpSession->put_UserHelpSessionRemoteDesktopSharingSetting(
                                                sharingClass
                                                );
    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopSession::get_SharingClass(
    REMOTE_DESKTOP_SHARING_CLASS *sharingClass
    )
/*++

Routine Description:

    Get the desktop sharing level.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::get_SharingClass");

    HRESULT hr = m_HelpSession->get_UserHelpSessionRemoteDesktopSharingSetting(
                                            sharingClass
                                            );

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopSession::put_OnConnected(
    IDispatch *iDisp
    ) 
/*++

Routine Description:

    Assign the outgoing interface for 'connected' events.
    Only one interface can be assigned at a time.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::put_OnConnected");

    HRESULT hr = S_OK;

    if (m_OnConnected != NULL) {
        //
        //  The client proc may have gone away, so we need 
        //  to catch exceptions on the release.
        //
        try {
            m_OnConnected->Release();
        }
        catch (...) {
        }
    }

    m_OnConnected = iDisp;
    if (m_OnConnected != NULL) {
        try {
            m_OnConnected->AddRef();
        }
        catch (...) {
            m_OnConnected = NULL;
            TRC_ERR((TB, L"Exception caught in AddRef"));
            hr = E_FAIL;
        }
    }

    DC_END_FN();
    return hr; 
}

STDMETHODIMP 
CRemoteDesktopSession::put_OnDisconnected(
    IDispatch *iDisp
    ) 
/*++

Routine Description:

    Assign the outgoing interface for 'disconnected' events.
    Only one interface can be assigned at a time.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::put_OnDisconnected(");

    HRESULT hr = S_OK;
    if (m_OnDisconnected != NULL) {
        //
        //  The client proc may have gone away, so we need 
        //  to catch exceptions on the release.
        //
        try {
            m_OnDisconnected->Release();
        }
        catch (...) {
        }
    }

    m_OnDisconnected = iDisp;
    if (m_OnDisconnected != NULL) {
        try {
            m_OnDisconnected->AddRef();
        }
        catch (...) {
            m_OnDisconnected = NULL;
            TRC_ERR((TB, L"Exception caught in AddRef"));
            hr = E_FAIL;
        }
    }

    DC_END_FN();
    return hr; 
}

STDMETHODIMP 
CRemoteDesktopSession::CloseRemoteDesktopSession()
/*++

Routine Description:

    Remove RDS session from the containing host object.  Note that 
    this function does not dereference the ISAFRemoteDesktopSession 
    interface.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::CloseRemoteDesktopSession");

    HRESULT hr = m_RDSHost->CloseRemoteDesktopSession(this);

    DC_END_FN();
    return hr;
}

VOID
CRemoteDesktopSession::ClientConnected()
/*++

Routine Description:

    Called when a connection to the client has been established.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::Connected");

    ASSERT(IsValid());

    //
    //  We will catch and ignore exceptions here.  The interface may
    //  have been implemented in a client application that has 'gone
    //  away.'
    //
    try {
        Fire_ClientConnected(m_OnConnected);
    }
    catch (...) {
        TRC_ALT((TB, L"Exception caught."));
    }

    DC_END_FN();
}

VOID
CRemoteDesktopSession::ClientDisconnected()
/*++

Routine Description:

    Called when a connection to the client has been terminated.
cd 
Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopSession::Disconnected");

    ASSERT(IsValid());

    //
    //  We will catch and ignore exceptions here.  The interface may
    //  have been implemented in a client application that has 'gone
    //  away.'
    //
    try {
        Fire_ClientDisconnected(m_OnDisconnected);
    }
    catch (...) {
        TRC_ALT((TB, L"Exception caught."));
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\remotedesktopsession.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopSession

Abstract:

    The CRemoteDesktopSession class is the parent 
    class for the Remote Desktop class hierarchy on the server-side.  
    It helps the CRemoteDesktopServerHost class to implement 
    the ISAFRemoteDesktopSession interface.  
    
    The Remote Desktop class hierarchy provides a pluggable C++ interface 
    for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the server-side.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPSESSION_H_
#define __REMOTEDESKTOPSESSION_H_

#include <RemoteDesktopTopLevelObject.h>
#include "resource.h"       
#include <rdshost.h>
#include "RDSHostCP.h"
#include <DataChannelMgr.h>
#include <sessmgr.h>
    

///////////////////////////////////////////////////////
//
//  CRemoteDesktopSession
//

class CRemoteDesktopServerHost;
class ATL_NO_VTABLE CRemoteDesktopSession : 
    public CRemoteDesktopTopLevelObject,
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CRemoteDesktopSession, &CLSID_SAFRemoteDesktopSession>,
    public IConnectionPointContainerImpl<CRemoteDesktopSession>,
    public IDispatchImpl<ISAFRemoteDesktopSession, &IID_ISAFRemoteDesktopSession, &LIBID_RDSSERVERHOSTLib>,
    public IProvideClassInfo2Impl<&CLSID_SAFRemoteDesktopSession, &DIID__ISAFRemoteDesktopSessionEvents, &LIBID_RDSSERVERHOSTLib>,
    public CProxy_ISAFRemoteDesktopSessionEvents< CRemoteDesktopSession >
{
private:

protected:

    CComPtr<IRemoteDesktopHelpSessionMgr> m_HelpSessionManager;
    CComPtr<IRemoteDesktopHelpSession> m_HelpSession;
    CComBSTR m_HelpSessionID;

    //
    //  Keep a back pointer to the RDS host object.
    //
    CRemoteDesktopServerHost *m_RDSHost;

    //
    //  IDispatch Pointers for Scriptable Event Object Registrations
    //
    IDispatch *m_OnConnected;
    IDispatch *m_OnDisconnected;

    //
    //  Accessor Method for Data Channel Manager
    //
    virtual CRemoteDesktopChannelMgr *GetChannelMgr() = 0;

    //
    //  Return the session description and name, depending on the subclass.
    //
    virtual VOID GetSessionName(CComBSTR &name) = 0;
    virtual VOID GetSessionDescription(CComBSTR &descr) = 0;

    //
    //  Shutdown method.
    //
    void Shutdown();

public:

    //
    //  Constructor/Destructor
    //
    CRemoteDesktopSession()
    {
        m_OnConnected = NULL;
        m_OnDisconnected = NULL;
    }
    virtual ~CRemoteDesktopSession();

    //
    //  Return the help session ID.
    //
    CComBSTR &GetHelpSessionID() {
        return m_HelpSessionID;
    }

    HRESULT FinalConstruct();

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPSESSION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    //  COM Interface Map
    //
BEGIN_COM_MAP(CRemoteDesktopSession)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopSession)
    COM_INTERFACE_ENTRY2(IDispatch, ISAFRemoteDesktopSession)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

    //
    //  Connection Point Map
    //  
BEGIN_CONNECTION_POINT_MAP(CRemoteDesktopSession)
    CONNECTION_POINT_ENTRY(DIID__ISAFRemoteDesktopSessionEvents)
END_CONNECTION_POINT_MAP()

public:

    //
    //  If subclass overrides, it should invoke the parent implementation.
    //  
    //  If parms are non-NULL, then the session already exists.  Otherwise,
    //  a new session should be created.
    //
    virtual HRESULT Initialize(
                        BSTR connectParms,
                        CRemoteDesktopServerHost *hostObject,
                        REMOTE_DESKTOP_SHARING_CLASS sharingClass,
                        BOOL enableCallback,
                        DWORD timeOut,
                        BSTR userHelpCreateBlob,                            
                        LONG tsSessionID,
                        BSTR userSID
                        );

    //
    //  Called when a connection to the client has been established/
    //  terminated
    //
    virtual VOID ClientConnected();
    virtual VOID ClientDisconnected();

    //
    // Instruct object to use hostname or ipaddress when constructing 
    // connect parameters
    //
    virtual HRESULT UseHostName( BSTR hostname ) { return S_OK; }


    //
    //  ISAFRemoteDesktopSession Methods
    //
    STDMETHOD(get_ConnectParms)(BSTR *parms) = 0;
    STDMETHOD(get_ChannelManager)(ISAFRemoteDesktopChannelMgr **mgr) = 0;
    STDMETHOD(Disconnect)() = 0;
    STDMETHOD(put_SharingClass)(REMOTE_DESKTOP_SHARING_CLASS sharingClass);
    STDMETHOD(get_SharingClass)(REMOTE_DESKTOP_SHARING_CLASS *sharingClass);
    STDMETHOD(CloseRemoteDesktopSession)();
    STDMETHOD(put_OnConnected)(/*[in]*/IDispatch *iDisp);
    STDMETHOD(put_OnDisconnected)(/*[in]*/IDispatch *iDisp);

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    { return _T("CRemoteDesktopSession"); }

        
    virtual HRESULT StartListening() = 0;
};

#endif //__REMOTEDESKTOPSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\remotedesktopserverhost.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopServerHost

Abstract:

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPSERVERHOST_H_
#define __REMOTEDESKTOPSERVERHOST_H_

#include <RemoteDesktopTopLevelObject.h>
#include "resource.h"       
#include "RemoteDesktopSession.h"


///////////////////////////////////////////////////////
//
//  CRemoteDesktopServerHost
//

class ATL_NO_VTABLE CRemoteDesktopServerHost : 
    public CRemoteDesktopTopLevelObject,
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CRemoteDesktopServerHost, &CLSID_SAFRemoteDesktopServerHost>,
    public IDispatchImpl<ISAFRemoteDesktopServerHost, &IID_ISAFRemoteDesktopServerHost, &LIBID_RDSSERVERHOSTLib>
{
private:

    CComPtr<IRemoteDesktopHelpSessionMgr> m_HelpSessionManager;
    PSID    m_LocalSystemSID;

    //
    //  Session Map
    //
    typedef struct SessionMapEntry
    {
        CComObject<CRemoteDesktopSession> *obj;
    } SESSIONMAPENTRY, *PSESSIONMAPENTRY;
    typedef std::map<CComBSTR, PSESSIONMAPENTRY, CompareBSTR, CRemoteDesktopAllocator<PSESSIONMAPENTRY> > SessionMap;
    SessionMap  m_SessionMap;

    //
    //  Return the Local System SID.
    //
    PSID GetLocalSystemSID() {
        if (m_LocalSystemSID == NULL) {
            DWORD result = CreateSystemSid(&m_LocalSystemSID);
            if (result != ERROR_SUCCESS) {
                SetLastError(result);
                m_LocalSystemSID = NULL;
            }
        }
        return m_LocalSystemSID;
    }

    HRESULT
    TranslateStringAddress(
        LPTSTR pszAddress,
        ULONG* pNetAddr
    );

public:

    CRemoteDesktopServerHost() {
        m_LocalSystemSID = NULL;
    }
    ~CRemoteDesktopServerHost();
    HRESULT FinalConstruct();

//  There should be a single instance of this class for each server.
DECLARE_CLASSFACTORY_SINGLETON(CRemoteDesktopServerHost);

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPSERVERHOST)

DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    //  COM Interface Map
    //
BEGIN_COM_MAP(CRemoteDesktopServerHost)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopServerHost)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    
    //
    //  ISAFRemoteDesktopServerHost Methods
    //
    STDMETHOD(CreateRemoteDesktopSession)(
                        REMOTE_DESKTOP_SHARING_CLASS sharingClass,
                        BOOL fEnableCallback,
                        LONG timeOut,
                        BSTR userHelpBlob,
                        ISAFRemoteDesktopSession **session
                        );
    STDMETHOD(CreateRemoteDesktopSessionEx)(
                        REMOTE_DESKTOP_SHARING_CLASS sharingClass,
                        BOOL bEnableCallback,
                        LONG timeout,
                        BSTR userHelpCreateBlob,
                        LONG tsSessionID,
                        BSTR userSID,
                        ISAFRemoteDesktopSession **session
                        );

    STDMETHOD(OpenRemoteDesktopSession)(
                        BSTR parms,
                        ISAFRemoteDesktopSession **session
                        );
    STDMETHOD(CloseRemoteDesktopSession)(ISAFRemoteDesktopSession *session);

    STDMETHOD(ConnectToExpert)(
        /*[in]*/ BSTR connectParmToExpert,
        /*[in]*/ LONG timeout,
        /*[out, retval]*/ LONG* SafErrCode
    );

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CRemoteDesktopServerHost");
    }
};

#endif //__REMOTEDESKTOPSERVERHOST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\remotedesktopserverhost.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDPRemoteDesktopServerHost

Abstract:

    This module contains the CRemoteDesktopServerHost implementation
    of RDS session objects.

    It manages a collection of open ISAFRemoteDesktopSession objects.
    New RDS session objects instances are created using the CreateRemoteDesktopSession
    method.  Existing RDS session objects are opened using the OpenRemoteDesktopSession
    method.  RDS session objects are closed using the CloseRemoteDesktopSession method.

    When an RDS object is opened or created, the CRemoteDesktopServerHost
    object adds a reference of its own to the object so that the object will
    stay around, even if the opening application exits.  This reference
    is retracted when the application calls the CloseRemoteDesktopSession method.

    In addition to the reference count the CRemoteDesktopServerHost adds to
    the RDS session object, a reference count is also added to itself so that
    the associated exe continues to run while RDS session objects are active.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include <RemoteDesktop.h>

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_svrhst"
#include "RemoteDesktopUtils.h"
#include "parseaddr.h"
#include "RDSHost.h"
#include "RemoteDesktopServerHost.h"
#include "TSRDPRemoteDesktopSession.h"
#include "rderror.h"



///////////////////////////////////////////////////////
//
//  CRemoteDesktopServerHost Methods
//

HRESULT
CRemoteDesktopServerHost::FinalConstruct() 
/*++

Routine Description:

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::FinalConstruct");

    HRESULT hr = S_OK;

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

CRemoteDesktopServerHost::~CRemoteDesktopServerHost() 
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::~CRemoteDesktopServerHost");

    //
    //  We shouldn't be shutting down, unless our session map is empty.
    //
    ASSERT(m_SessionMap.empty());

    //
    //  Clean up the local system SID.
    //
    if (m_LocalSystemSID == NULL) {
        FreeSid(m_LocalSystemSID);
    }

    DC_END_FN();
}


STDMETHODIMP
CRemoteDesktopServerHost::CreateRemoteDesktopSession(
                        REMOTE_DESKTOP_SHARING_CLASS sharingClass, 
                        BOOL fEnableCallback,
                        LONG timeOut,
                        BSTR userHelpBlob,
                        ISAFRemoteDesktopSession **session
                        )
/*++

Routine Description:

    Create a new RDS session

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::CreateRemoteDesktopSession");
    HRESULT hr;

    
    CComBSTR bstr; bstr = "";
    hr = CreateRemoteDesktopSessionEx(
                            sharingClass,
                            fEnableCallback,
                            timeOut,
                            userHelpBlob,
                            -1,
                            bstr,
                            session
                            );
    DC_END_FN();
    return hr;
}

STDMETHODIMP
CRemoteDesktopServerHost::CreateRemoteDesktopSessionEx(
                        REMOTE_DESKTOP_SHARING_CLASS sharingClass, 
                        BOOL bEnableCallback, 
                        LONG timeout,
                        BSTR userHelpCreateBlob, 
                        LONG tsSessionID,
                        BSTR userSID,
                        ISAFRemoteDesktopSession **session
                        )
/*++

Routine Description:

    Create a new RDS session
    Note that the caller MUST call OpenRemoteDesktopSession() subsequent to 
    a successful completion of this call.
    The connection does NOT happen until OpenRemoteDesktopSession() is called.
    This call just initializes certain data, it does not open a connection

Arguments:

    sharingClass                - Desktop Sharing Class
    fEnableCallback             - TRUE if the Resolver is Enabled
    timeOut                     - Lifespan of Remote Desktop Session
    userHelpBlob                - Optional User Blob to be Passed
                                  to Resolver.
    tsSessionID                 - Terminal Services Session ID or -1 if
                                  undefined.  
    userSID                     - User SID or "" if undefined.
    session                     - Returned Remote Desktop Session Interface.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::CreateRemoteDesktopSessionEx");

    HRESULT hr = S_OK;
    CComObject<CRemoteDesktopSession> *obj = NULL;
    PSESSIONMAPENTRY mapEntry;
    PSID psid;

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

    //
    //  Get the local system SID.
    //
    psid = GetLocalSystemSID();
    if (psid == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUPANDEXIT;
    }

    //
    //  Need to impersonate the caller in order to determine if it is
    //  running in SYSTEM context.
    //
    hr = CoImpersonateClient();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoImpersonateClient:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  For Whistler, instances of a Remote Desktop Session are only
    //  "openable" from SYSTEM context, for security reasons.
    //
#ifndef DISABLESECURITYCHECKS
    if (!IsCallerSystem(psid)) {
        TRC_ERR((TB, L"Caller is not SYSTEM."));
        ASSERT(FALSE);
        CoRevertToSelf();
        hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;
    }        
#endif
    hr = CoRevertToSelf();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoRevertToSelf:  %08X", hr));
        goto CLEANUPANDEXIT;
    } 

    if( sharingClass != DESKTOPSHARING_DEFAULT &&
        sharingClass != NO_DESKTOP_SHARING &&
        sharingClass != VIEWDESKTOP_PERMISSION_REQUIRE &&
        sharingClass != VIEWDESKTOP_PERMISSION_NOT_REQUIRE &&
        sharingClass != CONTROLDESKTOP_PERMISSION_REQUIRE &&
        sharingClass != CONTROLDESKTOP_PERMISSION_NOT_REQUIRE ) {

        // invalid parameter.
        hr = E_INVALIDARG;
        goto CLEANUPANDEXIT;
    }

    if( timeout < 0 ) {

        hr = E_INVALIDARG;
        goto CLEANUPANDEXIT;

    }
 
    if( NULL == session ) {

        hr = E_POINTER;
        goto CLEANUPANDEXIT;

    }

    //
    //  Instantiate the desktop server.  Currently, we only support 
    //  TSRDP.
    //
    obj = new CComObject<CTSRDPRemoteDesktopSession>();
    if (obj != NULL) {

        //
        //  ATL would normally take care of this for us.
        //
        obj->InternalFinalConstructAddRef();
        hr = obj->FinalConstruct();
        obj->InternalFinalConstructRelease();

    }
    else {
        TRC_ERR((TB, L"Can't instantiate CTSRDPRemoteDesktopServer"));
        hr = E_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the object.
    //
    hr = obj->Initialize(
                    NULL, this, sharingClass, bEnableCallback, 
                    timeout, userHelpCreateBlob, tsSessionID, userSID
                    );
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Add it to the session map.
    //
    mapEntry = new SESSIONMAPENTRY();
    if (mapEntry == NULL) {
        goto CLEANUPANDEXIT;
    }
    mapEntry->obj = obj;
    try {
        m_SessionMap.insert(
                    SessionMap::value_type(obj->GetHelpSessionID(), mapEntry)
                    );        
    }
    catch(CRemoteDesktopException x) {
        hr = HRESULT_FROM_WIN32(x.m_ErrorCode);
        delete mapEntry;
        goto CLEANUPANDEXIT;
    }
    //
    //  Get the ISAFRemoteDesktopSession interface pointer.
    //
    hr = obj->QueryInterface(
                        IID_ISAFRemoteDesktopSession, 
                        (void**)session
                        );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"m_RemoteDesktopSession->QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add a reference to the object and to ourself so we can both
    //  stick around, even if the app goes away.  The app needs to explicitly
    //  call CloseRemoteDesktopSession for the object to go away.
    //
    obj->AddRef();
    this->AddRef();

CLEANUPANDEXIT:

    //
    //  Delete the object on error.
    //
    if (!SUCCEEDED(hr)) {
        if (obj != NULL) delete obj;
    }

    DC_END_FN();
    return hr;
}

/*++

Routine Description:

    Open an existing RDS session
    This call should ALWAYS be made in order to connect to the client
    Once this is called and connection is complete, the caller 
    MUST call DisConnect() to make another connection to the client
    Otherwise, the connection does not happen

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
STDMETHODIMP
CRemoteDesktopServerHost::OpenRemoteDesktopSession(
                        BSTR parms,
                        ISAFRemoteDesktopSession **session
                        )
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::OpenRemoteDesktopSession");

    CComObject<CRemoteDesktopSession> *obj = NULL;
    CComBSTR hostname;
    CComBSTR tmp("");
    HRESULT hr = S_OK;
    SessionMap::iterator iter;
    CComBSTR parmsHelpSessionId;
    DWORD protocolType;
    PSESSIONMAPENTRY mapEntry;
    PSID psid;

    //
    //  Get the local system SID.
    //
    psid = GetLocalSystemSID();
    if (psid == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUPANDEXIT;
    }

    //
    //  Need to impersonate the caller in order to determine if it is
    //  running in SYSTEM context.
    //
    hr = CoImpersonateClient();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoImpersonateClient:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  For Whistler, instances of a Remote Desktop Session are only
    //  "openable" from SYSTEM context, for security reasons.
    //
#ifndef DISABLESECURITYCHECKS
    if (!IsCallerSystem(psid)) {
        TRC_ERR((TB, L"Caller is not SYSTEM."));
        ASSERT(FALSE);
        CoRevertToSelf();
        hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;
    } 
#endif    
    hr = CoRevertToSelf();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoRevertToSelf:  %08X", hr));
        goto CLEANUPANDEXIT;
    }
    
    //
    //  Parse out the help session ID.
    //  TODO:   Need to modify this so some of the parms are 
    //  optional.
    //
    DWORD dwVersion;
    DWORD result = ParseConnectParmsString(
                        parms, &dwVersion, &protocolType, hostname, tmp, tmp,
                        parmsHelpSessionId, tmp, tmp, tmp
                        );
    if (result != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(result);
        goto CLEANUPANDEXIT;
    }

    //
    //  If we already have the session open then just return a 
    //  reference.
    //
    iter = m_SessionMap.find(parmsHelpSessionId);
    if (iter != m_SessionMap.end()) {
        mapEntry = (*iter).second;
        hr = mapEntry->obj->QueryInterface(
                            IID_ISAFRemoteDesktopSession, 
                            (void**)session
                            );
        //
        //Start listening if we succeeded
        //
        if (SUCCEEDED(hr)) {
            hr = mapEntry->obj->StartListening();
            //
            //release the interface pointer if we didn't succeed
            //
            if (!SUCCEEDED(hr)) {
                (*session)->Release();
                *session = NULL;
            }
        }
        goto CLEANUPANDEXIT;
    }

    //
    //  Instantiate the desktop server.  Currently, we only support 
    //  TSRDP.
    //
    obj = new CComObject<CTSRDPRemoteDesktopSession>();
    if (obj != NULL) {

        //
        //  ATL would normally take care of this for us.
        //
        obj->InternalFinalConstructAddRef();
        hr = obj->FinalConstruct();
        obj->InternalFinalConstructRelease();

    }
    else {
        TRC_ERR((TB, L"Can't instantiate CTSRDPRemoteDesktopServer"));
        hr = E_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the object.
    //
    //  The desktop sharing parameter (NO_DESKTOP_SHARING) is ignored for 
    //  an existing session.
    //  bEnableCallback and timeout parameter is ignored for existing session
    //
    hr = obj->Initialize(parms, this, NO_DESKTOP_SHARING, TRUE, 0, CComBSTR(L""), -1, CComBSTR(L""));
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    hr = obj->StartListening();

    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    hr = obj->UseHostName( hostname );
    if( FAILED(hr) ) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Add it to the session map.
    //
    mapEntry = new SESSIONMAPENTRY();
    if (mapEntry == NULL) {
        goto CLEANUPANDEXIT;
    }
    mapEntry->obj = obj;
    try {
        m_SessionMap.insert(
                    SessionMap::value_type(obj->GetHelpSessionID(), mapEntry)
                    );        
    }
    catch(CRemoteDesktopException x) {
        hr = HRESULT_FROM_WIN32(x.m_ErrorCode);
        delete mapEntry;
        goto CLEANUPANDEXIT;
    }
    //
    //  Get the ISAFRemoteDesktopSession interface pointer.
    //
    hr = obj->QueryInterface(
                        IID_ISAFRemoteDesktopSession, 
                        (void**)session
                        );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"m_RemoteDesktopSession->QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }
    
    //
    //  Add a reference to the object and to ourself so we can both
    //  stick around, even if the app goes away.  The app needs to explicitly
    //  call CloseRemoteDesktopSession for the object to go away.
    //
    obj->AddRef();
    this->AddRef();
 
CLEANUPANDEXIT:
    //
    //  Delete the object on error.
    //
    if (!SUCCEEDED(hr)) {
        if (obj != NULL) delete obj;
    }


    DC_END_FN();

    return hr;
}

/*++

Routine Description:

    Close an existing RDS session

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
STDMETHODIMP
CRemoteDesktopServerHost::CloseRemoteDesktopSession(
                        ISAFRemoteDesktopSession *session
                        )
{
    DC_BEGIN_FN("CRemoteDesktopServerHost::CloseRemoteDesktopSession");

    HRESULT hr;
    DWORD result;
    CComBSTR tmp;
    CComBSTR parmsHelpSessionId;
    CComBSTR parms;
    DWORD protocolType;
    SessionMap::iterator iter;
    DWORD dwVersion;

    //
    //  Get the connection parameters.
    //
    hr = session->get_ConnectParms(&parms);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Parse them for the help session ID.
    //  TODO:   I should make some of the args to this function, optional.
    //
    result = ParseConnectParmsString(
                        parms, &dwVersion, &protocolType, tmp, tmp, tmp,
                        parmsHelpSessionId, tmp, tmp, tmp
                        );
    if (result != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(result);
        goto CLEANUPANDEXIT;
    }

    //
    //  Delete the entry from the session map.
    //
    iter = m_SessionMap.find(parmsHelpSessionId);
    if (iter != m_SessionMap.end()) {
        m_SessionMap.erase(iter);        
    }
    else {
        ASSERT(FALSE);
    }

    //
    //  Remove our reference to the session object.  This way it can
    //  go away when the application releases it.
    //
    session->Release();

    //
    //  Remove the reference to ourself that we added when we opened
    //  the session object.
    //
    this->Release();

    //
    //  Get the session manager interface, if we don't already have one.
    //
    //
    //  Open an instance of the Remote Desktop Help Session Manager service.
    //
    if (m_HelpSessionManager == NULL) {
        hr = m_HelpSessionManager.CoCreateInstance(CLSID_RemoteDesktopHelpSessionMgr);
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, TEXT("Can't create help session manager:  %08X"), hr));
            goto CLEANUPANDEXIT;
        }

        //
        //  Set the security level to impersonate.  This is required by
        //  the session manager.
        //
        hr = CoSetProxyBlanket(
                    (IUnknown *)m_HelpSessionManager,
                    RPC_C_AUTHN_DEFAULT,
                    RPC_C_AUTHZ_DEFAULT,
                    NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE
                    );
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, TEXT("CoSetProxyBlanket:  %08X"), hr));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Remove the help session with the session manager.
    //
    hr = m_HelpSessionManager->DeleteHelpSession(parmsHelpSessionId);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"DeleteHelpSession:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}


STDMETHODIMP
CRemoteDesktopServerHost::ConnectToExpert(
    /*[in]*/ BSTR connectParmToExpert,
    /*[in]*/ LONG timeout,
    /*[out, retval]*/ LONG* pSafErrCode
    )
/*++

Description:

    Given connection parameters to expert machine, routine invoke TermSrv winsta API to 
    initiate connection from TS server to TS client ActiveX control on the expert side.

Parameters:

    connectParmToExpert : connection parameter to connect to expert machine.
    timeout : Connection timeout, this timeout is per ip address listed in connection parameter
              not total connection timeout for the routine.
    pSafErrCode : Pointer to LONG to receive detail error code.

Returns:

    S_OK or E_FAIL

--*/
{
    HRESULT hr = S_OK;
    ServerAddress expertAddress;
    ServerAddressList expertAddressList;
    LONG SafErrCode = SAFERROR_NOERROR;
    TDI_ADDRESS_IP expertTDIAddress;
    ULONG netaddr;
    WSADATA wsaData;
    PSID psid;
    
    DC_BEGIN_FN("CRemoteDesktopServerHost::ConnectToExpert");

    //
    //  Get the local system SID.
    //
    psid = GetLocalSystemSID();
    if (psid == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUPANDEXIT;
    }

    //
    //  Need to impersonate the caller in order to determine if it is
    //  running in SYSTEM context.
    //
    hr = CoImpersonateClient();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoImpersonateClient:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  For Whistler, instances of a Remote Desktop Session are only
    //  "openable" from SYSTEM context, for security reasons.
    //
#ifndef DISABLESECURITYCHECKS
    if (!IsCallerSystem(psid)) {
        TRC_ERR((TB, L"Caller is not SYSTEM."));
        ASSERT(FALSE);
        CoRevertToSelf();
        hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;
    }        
#endif

    hr = CoRevertToSelf();
    if (hr != S_OK) {
        TRC_ERR((TB, L"CoRevertToSelf:  %08X", hr));
        goto CLEANUPANDEXIT;
    } 

    //
    // Parse address list in connection parameter.
    //
    hr = ParseAddressList( connectParmToExpert, expertAddressList );
    if( FAILED(hr) ) {
        TRC_ERR((TB, TEXT("ParseAddressList:  %08X"), hr));
        hr = E_INVALIDARG;
        SafErrCode = SAFERROR_INVALIDPARAMETERSTRING;
        goto CLEANUPANDEXIT;
    }

    if( 0 == expertAddressList.size() ) {
        TRC_ERR((TB, L"Invalid connection address list"));
        SafErrCode = SAFERROR_INVALIDPARAMETERSTRING;
        hr = E_INVALIDARG;
        goto CLEANUPANDEXIT;
    }

    //
    // Loop thru all address in parm and try connection one
    // at a time, bail out if system is shutting down or
    // some critical error
    //
    while( expertAddressList.size() > 0 ) {

        expertAddress = expertAddressList.front();
        expertAddressList.pop_front();

        //
        // Invalid connect parameters, we must have port number at least.
        //
        if( 0 == expertAddress.portNumber ||
            0 == lstrlen(expertAddress.ServerName) ) {
            TRC_ERR((TB, L"Invalid address/port %s %d", expertAddress.ServerName, expertAddress.portNumber));
            SafErrCode = SAFERROR_INVALIDPARAMETERSTRING;
            continue;
        }

        hr = TranslateStringAddress( expertAddress.ServerName, &netaddr );
        if( FAILED(hr) ) {
            TRC_ERR((TB, L"TranslateStringAddress() on %s failed with 0x%08x", expertAddress.ServerName, hr));
            SafErrCode = SAFERROR_INVALIDPARAMETERSTRING;
            continue;
        }

        ZeroMemory(&expertTDIAddress, TDI_ADDRESS_LENGTH_IP);
        expertTDIAddress.in_addr = netaddr;
        expertTDIAddress.sin_port = htons(expertAddress.portNumber);

        if( FALSE == WinStationConnectCallback(
                                      SERVERNAME_CURRENT,
                                      timeout,
                                      TDI_ADDRESS_TYPE_IP,
                                      (PBYTE)&expertTDIAddress,
                                      TDI_ADDRESS_LENGTH_IP
                                  ) ) {
            //
            // TransferConnectionToIdleWinstation() in TermSrv might just return -1
            // few of them we need to bail out.

            DWORD dwStatus;

            dwStatus = GetLastError();
            if( ERROR_SHUTDOWN_IN_PROGRESS == dwStatus ) {
                // system or termsrv is shuting down.
                hr = HRESULT_FROM_WIN32( ERROR_SHUTDOWN_IN_PROGRESS );
                SafErrCode = SAFERROR_SYSTEMSHUTDOWN;
                break;
            }
            else if( ERROR_ACCESS_DENIED == dwStatus ) {
                // security check failed
                hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
                SafErrCode = SAFERROR_BYSERVER;
                ASSERT(FALSE);
                break;
            }
            else if( ERROR_INVALID_PARAMETER == dwStatus ) { 
                // internal error in rdshost.
                hr = HRESULT_FROM_WIN32( ERROR_INTERNAL_ERROR );
                SafErrCode = SAFERROR_INTERNALERROR;
                ASSERT(FALSE);
                break;
            }

            SafErrCode = SAFERROR_WINSOCK_FAILED;
        }
        else {
            //
            // successful connection
            //

            SafErrCode = SAFERROR_NOERROR;
            break;
        }
        

        //
        // Try next connection.
        //
    }

CLEANUPANDEXIT:

    *pSafErrCode = SafErrCode;

    DC_END_FN();
    return hr;
}    


HRESULT
CRemoteDesktopServerHost::TranslateStringAddress(
    IN LPTSTR pszAddress,
    OUT ULONG* pNetAddr
    )
/*++

Routine Description:

    Translate IP Address or machine name to network address.

Parameters:

    pszAddress : Pointer to IP address or machine name.
    pNetAddr : Point to ULONG to receive address in IPV4.

Returns:

    S_OK or error code

--*/
{
    HRESULT hr = S_OK;
    unsigned long addr;
    LPSTR pszAnsiAddress = NULL;
    DWORD dwAddressBufSize;
    DWORD dwStatus;


    DC_BEGIN_FN("CRemoteDesktopServerHost::TranslateStringAddress");


    dwAddressBufSize = lstrlen(pszAddress) + 1;
    pszAnsiAddress = (LPSTR)LocalAlloc(LPTR, dwAddressBufSize); // converting from WCHAR to CHAR.
    if( NULL == pszAnsiAddress ) {
        hr = E_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    // Convert wide char to ANSI string
    //
    dwStatus = WideCharToMultiByte(
                                GetACP(),
                                0,
                                pszAddress,
                                -1,
                                pszAnsiAddress,
                                dwAddressBufSize,
                                NULL,
                                NULL
                            );

    if( 0 == dwStatus ) {
        dwStatus = GetLastError();
        hr = HRESULT_FROM_WIN32(dwStatus);

        TRC_ERR((TB, L"WideCharToMultiByte() failed with %d", dwStatus));
        goto CLEANUPANDEXIT;
    }
    
    addr = inet_addr( pszAnsiAddress );
    if( INADDR_NONE == addr ) {
        struct hostent* pHostEnt = NULL;
        pHostEnt = gethostbyname( pszAnsiAddress );
        if( NULL != pHostEnt ) {
            addr = ((struct sockaddr_in *)(pHostEnt->h_addr))->sin_addr.S_un.S_addr;
        }
    }

    if( INADDR_NONE == addr ) {
        dwStatus = GetLastError();

        hr = HRESULT_FROM_WIN32(dwStatus);
        TRC_ERR((TB, L"Can't translate address %w", pszAddress));
        goto CLEANUPANDEXIT;
    }

    *pNetAddr = addr;

CLEANUPANDEXIT:

    if( NULL != pszAnsiAddress ) {
        LocalFree(pszAnsiAddress);
    }

    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\tsrdpremotedesktopsession.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    TSRDPRemoteDesktopSession

Abstract:

    This is the TS/RDP implementation of the Remote Desktop Server class.
    
    The Remote Desktop Server class defines functions that define 
    pluggable C++ interface for remote desktop access, by abstracting 
    the implementation specific details of remote desktop access for the 
    server-side into the following C++ methods:

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __TSRDPREMOTEDESKTOPSESSION_H_
#define __TSRDPREMOTEDESKTOPSESSION_H_

#include "RemoteDesktopSession.h"
#include "TSRDPServerDataChannelMgr.h"
#include <sessmgr.h>
    

///////////////////////////////////////////////////////
//
//  CTSRDPRemoteDesktopSession
//

class CTSRDPRemoteDesktopSession : public CComObject<CRemoteDesktopSession>
{
private:

    DWORD       m_SessionID;
    CComBSTR    m_ConnectParms;
    CComBSTR    m_UseHostName;

protected:

    //
    //  Final Initialization and Shutdown
    //
    //  Parms are non-null, if the session is being opened, instead of
    //  create new.
    //
    virtual HRESULT Initialize(
                    BSTR connectParms,
                    CRemoteDesktopServerHost *hostObject,
                    REMOTE_DESKTOP_SHARING_CLASS sharingClass,
                    BOOL bEnableCallback,
                    DWORD timeOut,
                    BSTR userHelpCreateBlob,
                    LONG tsSessionID,
                    BSTR userSID
                    );
    void Shutdown();

    //
    // Instruct object to use hostname or ipaddress when constructing 
    // connect parameters
    //
    virtual HRESULT UseHostName( BSTR hostname ) {

        CComObject<CRemoteDesktopSession>::UseHostName( hostname );
        m_UseHostName = hostname;
    
        return S_OK;
    }


    //  
    //  Multiplexes Channel Data
    //
    CComObject<CTSRDPServerChannelMgr> *m_ChannelMgr;

    //
    //  Accessor Method for Data Channel Manager
    //
    virtual CRemoteDesktopChannelMgr *GetChannelMgr() {
        return m_ChannelMgr;
    }

    //
    //  Return the session description and name, depending on the subclass.
    //
    virtual VOID GetSessionName(CComBSTR &name);
    virtual VOID GetSessionDescription(CComBSTR &descr);

    //
    //  Fetch our Token User struct.
    //
    HRESULT FetchOurTokenUser(PTOKEN_USER *tokenUser);

public:

    //
    //  Constructor/Destructor
    //
    CTSRDPRemoteDesktopSession();
    ~CTSRDPRemoteDesktopSession();

    //
    //  ISAFRemoteDesktopSession Methods
    //
    STDMETHOD(get_ConnectParms)(BSTR *parms);
    STDMETHOD(get_ChannelManager)(ISAFRemoteDesktopChannelMgr **mgr) {
        DC_BEGIN_FN("get_ChannelManager");
        HRESULT hr = S_OK;

        if (m_ChannelMgr != NULL) {
            m_ChannelMgr->AddRef();
            *mgr = m_ChannelMgr;
        }
        else {
            ASSERT(FALSE);
            hr = E_FAIL;
        }

        DC_END_FN();
        return hr;
    }
    STDMETHOD(Disconnect)();

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CTSRDPRemoteDesktopSession");
    }

    HRESULT StartListening();
};  

#endif //__TSRDPREMOTEDESKTOPSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessadd\rdsaddin.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    rdsaddin.cpp

Abstract:

    The TSRDP Assistant Session VC Add-In is an executable that is 
    loaded in the session that is created when the TSRDP client plug-in 
    first logs in to the server machine.  It acts, primarily, as a 
    proxy between the client VC interface and the Remote Desktop Host 
    COM Object.  Channel data is routed from the TSRDP Assistant Session 
    VC Add-In to the Remote Desktop Host COM Object using a named pipe 
    that is created by the Remote Desktop Host COM Object when it enters 
    "listen" mode.

    In addition to its duties as a proxy, the Add-In also manages a control 
    channel between the client and the server.  This control channel is 
    used by the client-side to direct the server side to initiate remote 
    control of the end user's TS session. 

    TODO:   We should make the pipe IO synchronous since we now have two
            IO threads.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_sesa"

#include <windows.h>
#include <process.h>
#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>
#include <RemoteDesktopChannels.h>
#include <TSRDPRemoteDesktop.h>
#include <wtblobj.h>
#include <wtsapi32.h>
#include <sessmgr.h>
#include <winsta.h>
#include <atlbase.h>
#include <RemoteDesktopUtils.h>
#include <sessmgr_i.c>
#include <pchannel.h>
#include <RDCHost.h>
#include <regapi.h>


///////////////////////////////////////////////////////
//
//  Defines
//

#define CLIENTPIPE_CONNECTTIMEOUT   (20 * 1000) // 20 seconds.
#define VCBUFFER_RESIZE_DELTA       CHANNEL_CHUNK_LENGTH  
#define RDS_CHECKCONN_TIMEOUT       (30 * 1000) //millisec. default value to ping is 30 seconds 
#define RDC_CONNCHECK_ENTRY         L"ConnectionCheck"
#define THREADSHUTDOWN_WAITTIMEOUT  30 * 1000


///////////////////////////////////////////////////////
//
//  Typedefs
//

typedef struct _IOBuffer {
    PREMOTEDESKTOP_CHANNELBUFHEADER  buffer;
    DWORD bufSize;
    DWORD offset;
} IOBUFFER;


///////////////////////////////////////////////////////
//
//  Internal Prototypes
//

DWORD ReturnResultToClient(
    LONG result
    );
VOID RemoteControlDesktop(
    BSTR parms
    );
BOOL ClientVersionCompatible( 
    DWORD dwMajor, 
    DWORD dwMinor 
    );
VOID ClientAuthenticate(
    BSTR parms,
    BSTR blob
    );
DWORD ProcessControlChannelRequest(
    IOBUFFER &msg
    );
DWORD SendMsgToClient(
    PREMOTEDESKTOP_CHANNELBUFHEADER  msg
    );
VOID HandleVCReadComplete(
    HANDLE waitableObject, 
    PVOID clientData
    );
DWORD HandleReceivedVCMsg(
    IOBUFFER &msg
    );
VOID HandleVCClientConnect(
    HANDLE waitableObject, 
    PVOID clientData
    );
VOID HandleVCClientDisconnect(
    HANDLE waitableObject, 
    PVOID clientData
    );
VOID HandleNamedPipeReadComplete(
    OVERLAPPED &incomingPipeOL,
    IOBUFFER &incomingPipeBuf
    );
VOID HandleReceivedPipeMsg(
    IOBUFFER &msg
    );
DWORD ConnectVC();
DWORD ConnectClientSessionPipe();
DWORD IssueVCOverlappedRead(
    IOBUFFER &msg,
    OVERLAPPED &ol
    );
DWORD IssueNamedPipeOverlappedRead(
    IOBUFFER &msg,
    OVERLAPPED &ol
    );
void __cdecl
NamedPipeReadThread(
    void* ptr
    );
VOID WakeUpFunc(
    HANDLE waitableObject, 
    PVOID clientData
    );
VOID HandleHelpCenterExit(
    HANDLE waitableObject,
    PVOID clientData
    );
DWORD
SendNullDataToClient(
    );

BOOL GetDwordFromRegistry(PDWORD pdwValue);


///////////////////////////////////////////////////////
//
//  Globals to this Module
//
CComBSTR    g_bstrCmdLineHelpSessionId;
WTBLOBJMGR  g_WaitObjMgr            = NULL;
BOOL        g_Shutdown              = FALSE;
HANDLE      g_VCHandle              = NULL;
HANDLE      g_ProcHandle            = NULL;
DWORD       g_SessionID             = 0;
HANDLE      g_ProcToken             = NULL;
HANDLE      g_WakeUpForegroundThreadEvent = NULL;
DWORD       g_PrevTimer             = 0;
DWORD       g_dwTimeOutInterval     = 0;
HANDLE      g_ShutdownEvent         = NULL;
HANDLE      g_RemoteControlDesktopThread = NULL;
HANDLE      g_NamedPipeReadThread   = NULL;
HANDLE      g_NamedPipeWriteEvent   = NULL;

//
//  VC Globals
//  
HANDLE      g_ClientIsconnectEvent = NULL;
HANDLE      g_VCFileHandle          = NULL;
OVERLAPPED  g_VCReadOverlapped      = { 0, 0, 0, 0, NULL };
BOOL        g_ClientConnected       = FALSE;

//
//  Client Session Information
//
LONG        g_ClientSessionID       = -1;
HANDLE      g_ClientSessionPipe     = NULL;

//
//  True if the client has been successfully authenticated.
//
BOOL        g_ClientAuthenticated   = FALSE;

//
//  Incoming Virtual Channel Buf.              
//
IOBUFFER    g_IncomingVCBuf = { NULL, 0, 0 };

//
// Global help session manager object, this need to be
// global so that when process exit, object destructor
// can inform resolver about the disconnect
//
CComPtr<IRemoteDesktopHelpSessionMgr> g_HelpSessionManager;

//
//  Help Session Identifier for the Current Client Connection
//
CComBSTR    g_HelpSessionID;

//
// Client (expert side) rdchost major version
//
DWORD       g_ClientMajor;
DWORD       g_ClientMinor;

//
// Handle to Help Center : B2 blocker workaround for BUG:342742
//
HANDLE      g_hHelpCenterProcess = NULL;


//------------------------------------------------------------------
BOOL WINAPI
ControlHandler(
    IN DWORD dwCtrlType
    )
/*++

Abstract:


Parameter:

    IN dwCtrlType : control type

Return:


++*/
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
        case CTRL_CLOSE_EVENT:
        case CTRL_LOGOFF_EVENT:
        case CTRL_SHUTDOWN_EVENT:
            SetEvent( g_ShutdownEvent );
            g_Shutdown = TRUE;
            return TRUE;

    }
    return FALSE;
}

DWORD
ReturnResultToClient(
    LONG clientResult                        
    )
/*++

Routine Description:

    Return a result code to the client in the form of a 
    REMOTEDESKTOP_RC_CONTROL_CHANNEL channel REMOTEDESKTOP_CTL_RESULT message.    

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("ReturnResultToClient");
    DWORD result;

    REMOTEDESKTOP_CTL_RESULT_PACKET msg;

    memcpy(msg.packetHeader.channelName, REMOTEDESKTOP_RC_CONTROL_CHANNEL,
        sizeof(REMOTEDESKTOP_RC_CONTROL_CHANNEL));
    msg.packetHeader.channelBufHeader.channelNameLen = REMOTEDESKTOP_RC_CHANNELNAME_LENGTH;

#ifdef USE_MAGICNO
    msg.packetHeader.channelBufHeader.magicNo = CHANNELBUF_MAGICNO;
#endif

    msg.packetHeader.channelBufHeader.dataLen = sizeof(REMOTEDESKTOP_CTL_RESULT_PACKET) - 
                                    sizeof(REMOTEDESKTOP_CTL_PACKETHEADER);
    msg.msgHeader.msgType   = REMOTEDESKTOP_CTL_RESULT;
    msg.result              = clientResult;

    result = SendMsgToClient((PREMOTEDESKTOP_CHANNELBUFHEADER )&msg);

    DC_END_FN();
    return result;
}

void __cdecl
RemoteControlDesktopThread(
    void* ptr
    )
/*++

Routine Description:

    Thread func for Remote Control

Arguments:

Return Value:

    This function returns a status back to the Salem client when shadow 
    terminates.  It is only allowed to return error codes that are prefixed by
    SAFERROR_SHADOWEND

 --*/
{
    BSTR parms = (BSTR) ptr;

    DC_BEGIN_FN("RemoteControlDesktopThread");

    CComPtr<IRemoteDesktopHelpSessionMgr> helpSessionManager;
    CComPtr<IRemoteDesktopHelpSession> helpSession;

    HRESULT hr;
    DWORD result;

    LONG errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;

    //
    // If we have not resolve the right user session ID
    //
    if( g_ClientSessionID == -1 ) {
        TRC_ALT((TB, L"Invalid user session ID %ld",
                 g_ClientSessionID));

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD);
        errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    CoInitialize(NULL);

    //
    // Create a new instance of helpmgr object to get around threading issue
    // in COM
    //
    hr = helpSessionManager.CoCreateInstance(CLSID_RemoteDesktopHelpSessionMgr);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("Can't create help session manager:  %08X"), hr));

        //  Setup issue
        errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by 
    //  the session manager.
    //
    hr = CoSetProxyBlanket(
                        (IUnknown *)helpSessionManager,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        NULL,
                        RPC_C_AUTHN_LEVEL_DEFAULT,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        EOAC_NONE
                   );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("CoSetProxyBlanket:  %08X"), hr));
	ASSERT(FALSE);
        errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        goto CLEANUPANDEXIT;
    }

    //
    // Retrieve help session object for the incident
    //
    hr = helpSessionManager->RetrieveHelpSession(
                                            g_HelpSessionID,
                                            &helpSession
                                        );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"RetrieveHelpSession:  %08X", hr));
        errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        goto CLEANUPANDEXIT;
    }

    //
    // Set shadow configuration to help session RDS setting
    // Console shadow always reset shadow class back to
    // original value.
    //
    hr = helpSession->EnableUserSessionRdsSetting(TRUE);
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"Can't set shadow setting on %ld :  %08X.", hr));
        errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        goto CLEANUPANDEXIT;
    }

    //
    //  Shadow the desktop.
    //
    if (!WinStationShadow(
                    SERVERNAME_CURRENT,
                    NULL, //machineName,
                    g_ClientSessionID,
                    TSRDPREMOTEDESKTOP_SHADOWVKEY,
                    TSRDPREMOTEDESKTOP_SHADOWVKEYMODIFIER
            )) {
        result = GetLastError();
        hr = HRESULT_FROM_WIN32(result);

        //
        //  Map the error code to a SAF error code.
        //
        if( result == ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE ) {
            errReturnCode = SAFERROR_SHADOWEND_CONFIGCHANGE;
        }
        else {
            errReturnCode = SAFERROR_SHADOWEND_UNKNOWN;
        }
    }

    //
    // No need to reset g_ClientSessionID, we don't support multiple instance.
    //

    //
    // Inform help session object that shadow has completed, NotifyRemoteControl() 
    // internally invoke EnableUserSessionRdsSetting(TRUE) to change
    // TS shadow class
    // No need to reset g_ClientSessionID, we don't support multiple instance.
    //

    //
    // Inform help session object that shadow has completed
    //
    hr = helpSession->EnableUserSessionRdsSetting( FALSE );
    if (FAILED(hr)) {
        TRC_ERR((TB, L"Can't reset shadow setting on %ld :  %08X.",
                 g_ClientSessionID, hr));
        //
        // not a critical error.
        //
    }

CLEANUPANDEXIT:

    //
    //  Send the result to the client on failure to shadow.
    //  
    ReturnResultToClient(errReturnCode);

    CoUninitialize();

    DC_END_FN();
    _endthread();
}


VOID
RemoteControlDesktop(
    BSTR parms                               
    )
/*++

Routine Description:

Arguments:

    Connection Parameters

Return Value:

 --*/
{
    DC_BEGIN_FN("RemoteControlDesktop");

    //
    // RDCHOST.DLL will not send any control message so there is no checking on
    // second remote control command.
    //
    g_RemoteControlDesktopThread = (HANDLE)_beginthread( RemoteControlDesktopThread, 0, (void *)parms );
    if ((uintptr_t)g_RemoteControlDesktopThread == -1 ) {
        g_RemoteControlDesktopThread = NULL;
        TRC_ERR((TB, L"Failed to create RemoteControlDesktopThread for session %s - %ld",
                 g_ClientSessionID, GetLastError()));
        // return error code only when 
        // failed to spawn another thread
        ReturnResultToClient(SAFERROR_SHADOWEND_UNKNOWN);
    } 
    DC_END_FN();
}

BOOL
ClientVersionCompatible( 
    DWORD dwMajor, 
    DWORD dwMinor 
    )
/*++

Routine Description:

    Verify client (expert) version is compatible with our version.

Parameters:

    dwMajor : Client major version.
    dwMinor : Client minor version.

Returns:

    None.

--*/
{
    //
    // Build 2409 or earlier (including B1 release has major version of 1 and minor version of 1
    // rdchost/rdsaddin need to deal with versioning, for build 2409 or earlier, we
    // just make it in-compatible since we need some expert identity from rdchost.dll
    //

#if FEATURE_USERBLOBS
    if( dwMajor == 1 && dwMinor == 1 ) {
        return FALSE;
    }
#endif

    return TRUE;
}



VOID
ClientAuthenticate(
    BSTR parms,
    BSTR blob                               
    )
/*++

Routine Description:

    Handle a REMOTEDESKTOP_CTL_AUTHENTICATE request from the client.

Arguments:

Return Value:

    This function will return the following results back to the client, 
    based on the following 

 --*/
{
    DC_BEGIN_FN("ClientAuthenticate");

    HRESULT hr;
    DWORD result = ERROR_NOT_AUTHENTICATED;
    CComBSTR machineName;
    CComBSTR assistantAccount;
    CComBSTR assistantAccountPwd;
    CComBSTR helpSessionPwd;
    CComBSTR helpSessionName;
    CComBSTR protocolSpecificParms;
    BOOL match;
    DWORD protocolType;
    long userTSSessionID;
    DWORD dwVersion;
    LONG clientReturnCode = SAFERROR_NOERROR;

    if( FALSE == ClientVersionCompatible( g_ClientMajor, g_ClientMinor ) ) {
        clientReturnCode = SAFERROR_INCOMPATIBLEVERSION;
        goto CLEANUPANDEXIT;
    }
    

    //
    //  Parse the parms.
    //
    result = ParseConnectParmsString(
                                parms,
                                &dwVersion,
                                &protocolType,
                                machineName,
                                assistantAccount,
                                assistantAccountPwd,
                                g_HelpSessionID,
                                helpSessionName,
                                helpSessionPwd,
                                protocolSpecificParms
                                );

    if (result != ERROR_SUCCESS) {
        clientReturnCode = SAFERROR_INVALIDPARAMETERSTRING;
        goto CLEANUPANDEXIT;
    }

    //
    // Verify HelpSession ID and password match with our command line
    // parameter
    //
    if( !(g_bstrCmdLineHelpSessionId == g_HelpSessionID) ) {
        clientReturnCode = SAFERROR_MISMATCHPARMS;
        TRC_ERR((TB, TEXT("Parameter mismatched")));
        goto CLEANUPANDEXIT;
    }

    //
    //  Open an instance of the Remote Desktop Help Session Manager service.
    //
    hr = g_HelpSessionManager.CoCreateInstance(CLSID_RemoteDesktopHelpSessionMgr);
    if (!SUCCEEDED(hr)) {
        clientReturnCode = SAFERROR_INTERNALERROR;
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by 
    //  the session manager.
    //
    hr = CoSetProxyBlanket(
                        (IUnknown *)g_HelpSessionManager,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        NULL,
                        RPC_C_AUTHN_LEVEL_DEFAULT,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        EOAC_NONE
                   );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("CoSetProxyBlanket:  %08X"), hr));
	ASSERT(FALSE);			
        clientReturnCode = SAFERROR_INTERNALERROR;
        goto CLEANUPANDEXIT;
    }

    //
    //  Resolve the Terminal Services session with help from the session
    //  manager.  This gives the help application the opportunity to "find
    //  the user" and to start the TS-session named pipe component,
    //  by opening the relevant Remote Desktopping Session Object.
    //

    hr = g_HelpSessionManager->VerifyUserHelpSession(
                                            g_HelpSessionID,
                                            helpSessionPwd,
                                            CComBSTR(parms),
                                            blob,
                                            GetCurrentProcessId(),
                                            (ULONG_PTR*)&g_hHelpCenterProcess,
                                            &clientReturnCode,
                                            &userTSSessionID
                                            );
    if (SUCCEEDED(hr)) {
        if( userTSSessionID != -1 ) {
            //
            // Cache the session ID so we don't have to make extra call 
            // to get the actual session ID, note, one instance of RDSADDIN
            // per help assistant connection.
            //
            g_ClientSessionID = userTSSessionID;
            match = TRUE;
        }

        if (match) {
            TRC_NRM((TB, L"Successful password authentication for %ld",
                     g_ClientSessionID));
        }
        else {
            TRC_ALT((TB, L"Can't authenticate pasword %s for %s",
                     helpSessionPwd, g_HelpSessionID));
            clientReturnCode = SAFERROR_INVALIDPASSWORD;
            goto CLEANUPANDEXIT;
        }
    }
    else {
        TRC_ERR((TB, L"Can't verify user help session %s:  %08X.", 
                 g_HelpSessionID, hr));

        if( SAFERROR_NOERROR == clientReturnCode ) {

            ASSERT(FALSE);
            TRC_ERR((TB, L"Sessmgr did not return correct error code for VerifyUserHelpSession."));
            clientReturnCode = SAFERROR_UNKNOWNSESSMGRERROR;
        }

        goto CLEANUPANDEXIT;
    }

#ifndef DISABLESECURITYCHECKS
    //
    //  Wait on Help Center to terminate as a fix for B2 Stopper:  342742.
    //
    if (g_hHelpCenterProcess == NULL) {
        TRC_ERR((TB, L"Invalid g_HelpCenterProcess."));
        ASSERT(FALSE);
        clientReturnCode = SAFERROR_INTERNALERROR;
        goto CLEANUPANDEXIT;
    }
    result = WTBLOBJ_AddWaitableObject(
                                g_WaitObjMgr, NULL,
                                g_hHelpCenterProcess,
                                HandleHelpCenterExit
                                );
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }
#endif

    //
    //  Connect to the client session's named pipe.
    //
    result = ConnectClientSessionPipe();
    if (result !=  ERROR_SUCCESS) {
        clientReturnCode = SAFERROR_CANTFORMLINKTOUSERSESSION;
    }

CLEANUPANDEXIT:

    if (result == ERROR_SUCCESS) {
        g_ClientAuthenticated = TRUE;
    }

    //
    //  Send the result to the client.
    //
    ReturnResultToClient(clientReturnCode);

    DC_END_FN();
}

DWORD
ProcessControlChannelRequest(
    IOBUFFER &msg                                  
    )
/*++

Routine Description:

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("ProcessControlChannelRequest");

    PREMOTEDESKTOP_CTL_BUFHEADER ctlHdr;
    PBYTE ptr;

    //
    //  Sanity check the message size.
    //
    DWORD minSize = sizeof(REMOTEDESKTOP_CHANNELBUFHEADER) + sizeof(REMOTEDESKTOP_CTL_BUFHEADER);
    if (msg.bufSize < minSize) {
        TRC_ERR((TB, L"minSize == %ld", minSize));
        ASSERT(FALSE);            
        DC_END_FN();
        return E_FAIL;
    }

    //
    //  Switch on the request type.
    //
    ptr = (PBYTE)(msg.buffer + 1);
    ptr += msg.buffer->channelNameLen;
    ctlHdr = (PREMOTEDESKTOP_CTL_BUFHEADER)ptr;
    switch(ctlHdr->msgType) 
    {
    case REMOTEDESKTOP_CTL_AUTHENTICATE:
        {
            CComBSTR bstrConnectParm;

            #if FEATURE_USERBLOBS
            CComBSTR bstrExpertBlob;
            #endif

            bstrConnectParm = (BSTR)(ptr+sizeof(REMOTEDESKTOP_CTL_BUFHEADER));

            #if FEATURE_USERBLOBS
            bstrExpertBlob = (BSTR)(ptr+sizeof(REMOTEDESKTOP_CTL_BUFHEADER)+(bstrConnectParm.Length()+1)*sizeof(WCHAR));
            #endif

            ClientAuthenticate(
                        bstrConnectParm, 
                    #if FEATURE_USERBLOBS
                        bstrExpertBlob
                    #else
                        CComBSTR(L"")
                    #endif
                    );
        }
        break;
    case REMOTEDESKTOP_CTL_REMOTE_CONTROL_DESKTOP    :
        RemoteControlDesktop((BSTR)(ptr+sizeof(REMOTEDESKTOP_CTL_BUFHEADER)));
        break;

    case REMOTEDESKTOP_CTL_VERSIONINFO:
        g_ClientMajor = *(DWORD *)(ptr + sizeof(REMOTEDESKTOP_CTL_BUFHEADER));
        g_ClientMinor = *(DWORD *)(ptr + sizeof(REMOTEDESKTOP_CTL_BUFHEADER) + sizeof(DWORD));

        TRC_NRM((TB, L"dwMajor = %ld, dwMinor = %d", g_ClientMajor, g_ClientMinor));

        //
        // We only store version number and let ClientAuthenticate() disconnect client,
        // rdchost.dll send two packets, version and AUTHENTICATE in sequence.
        //
        break;

    default:
        //  
        //  We will ignore unknown control messages for forward compatibility
        //
        TRC_NRM((TB, L"Unknown ctl message from client:  %ld", ctlHdr->msgType));
    }

    DC_END_FN();

    return ERROR_SUCCESS;
}

DWORD
SendMsgToClient(
    PREMOTEDESKTOP_CHANNELBUFHEADER  msg
    )
/*++

Routine Description:

Arguments:

    msg -   Message to send.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("SendMsgToClient");

    OVERLAPPED overlapped;
    PBYTE ptr;
    DWORD bytesToWrite;
    DWORD bytesWritten;
    DWORD result = ERROR_SUCCESS;

#ifdef USE_MAGICNO
    ASSERT(msg->magicNo == CHANNELBUF_MAGICNO);
#endif

    //
    //  Send the data out the virtual channel interface.
    //
    //  TODO:  Figure out why this flag is not getting set ... and
    //         if it really matters.  Likely, remove the flag.
    //
    //if (g_ClientConnected) {
    {

        ptr = (PBYTE)msg;
        bytesToWrite = msg->dataLen + msg->channelNameLen + 
                       sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);
        while (bytesToWrite > 0) {

            //
            //  Write
            //
            memset(&overlapped, 0, sizeof(overlapped));
            if (!WriteFile(g_VCFileHandle, ptr, bytesToWrite,
                           &bytesWritten, &overlapped)) {
                if (GetLastError() == ERROR_IO_PENDING) {

                    if (!GetOverlappedResult(
                                    g_VCFileHandle,
                                    &overlapped,
                                    &bytesWritten,
                                    TRUE)) {
                        result = GetLastError();
                        TRC_ERR((TB, L"GetOverlappedResult:  %08X", result));
                        break;
                    }

                }
                else {
                    result = GetLastError();
                    TRC_ERR((TB, L"WriteFile:  %08X", result));
                    // ASSERT(FALSE); overactive assert after disconnect
                    break;
                }
            }

            //
            //  Increment the ptr and decrement the bytes remaining.
            //
            bytesToWrite -= bytesWritten;
            ptr += bytesWritten;

        }
    }
    /*
    else {
        result = ERROR_NOT_CONNECTED;
    }
    */
    //
    //update the timer
    //
    g_PrevTimer = GetTickCount();

    DC_END_FN();

    return result;
}

VOID 
HandleVCReadComplete(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleVCReadComplete");

    DWORD bytesRead;
    DWORD result = ERROR_SUCCESS;
    BOOL resizeBuf = FALSE;

    //
    //  Get the results of the read.
    //
    if (!GetOverlappedResult(
                        g_VCFileHandle,
                        &g_VCReadOverlapped,
                        &bytesRead,
                        FALSE)) {

        //
        //  If we are too small, then reissue the read with a larger buffer.
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            resizeBuf = TRUE;
        }
        else {
            result = GetLastError();
            TRC_ERR((TB, L"GetOverlappedResult:  %08X", result));
            goto CLEANUPANDEXIT;
        }
    }
    else {
        g_IncomingVCBuf.offset += bytesRead;
    }

    //
    //  See if we have a complete packet from the client.
    //
    if (g_IncomingVCBuf.offset >= sizeof(REMOTEDESKTOP_CHANNELBUFHEADER)) {
        DWORD packetSize = g_IncomingVCBuf.buffer->dataLen + 
                           g_IncomingVCBuf.buffer->channelNameLen +
                           sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);

        //
        //  If we have a complete packet, then handle the read and reset the offset.
        //
        if (g_IncomingVCBuf.offset >= packetSize) {
            result = HandleReceivedVCMsg(g_IncomingVCBuf);
            if (result == ERROR_SUCCESS) {
                g_IncomingVCBuf.offset = 0;
            }
            else {
                goto CLEANUPANDEXIT;
            }
        }
        //
        //  Otherwise, resize the incoming buf if we are exactly at the incoming
        //  buffer boundary.
        //
        else if (g_IncomingVCBuf.offset == g_IncomingVCBuf.bufSize) {
            resizeBuf = TRUE;
        }
    }

    //
    //  Resize, if necessary.
    //
    if (resizeBuf) {
        g_IncomingVCBuf.buffer = 
                    (PREMOTEDESKTOP_CHANNELBUFHEADER )REALLOCMEM(
                                    g_IncomingVCBuf.buffer,
                                    g_IncomingVCBuf.bufSize + VCBUFFER_RESIZE_DELTA
                                    );
        if (g_IncomingVCBuf.buffer != NULL) {
            result = ERROR_SUCCESS;
            g_IncomingVCBuf.bufSize = g_IncomingVCBuf.bufSize + 
                                      VCBUFFER_RESIZE_DELTA;
        }
        else {
            result = ERROR_NOT_ENOUGH_MEMORY;
            TRC_ERR((TB, L"Couldn't allocate incoming VC buf."));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //update the timer
    //
    g_PrevTimer = GetTickCount();

    //
    //  Issue the next read request.
    //
    result = IssueVCOverlappedRead(g_IncomingVCBuf, g_VCReadOverlapped) ;

CLEANUPANDEXIT:

    //
    //  Any failure is fatal.  The client will need to reconnect to get things 
    //  started again.
    //
    if (result != ERROR_SUCCESS) {
        TRC_ERR((TB, L"Client considered disconnected.  Shutting down."));
        g_Shutdown = TRUE;
    }

    DC_END_FN();
}

DWORD    
IssueVCOverlappedRead(
    IOBUFFER &msg,
    OVERLAPPED &ol
    )
/*++

Routine Description:

    Issue an overlapped read for the next VC buffer.

Arguments:

    msg -   Incoming VC buffer.        
    ol  -   Corresponding overlapped IO struct.  

Return Value:

    Returns ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("IssueVCOverlappedRead");

    DWORD result = ERROR_SUCCESS;

    ol.Internal = 0;
    ol.InternalHigh = 0;
    ol.Offset = 0;
    ol.OffsetHigh = 0;
    ResetEvent(ol.hEvent);
    if (!ReadFile(g_VCFileHandle, ((PBYTE)msg.buffer)+msg.offset, 
                  msg.bufSize - msg.offset, NULL, &ol)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            result = GetLastError();
            TRC_ERR((TB, L"ReadFile failed:  %08X", result));
        }
    }

    DC_END_FN();

    return result;
}

DWORD    
IssueNamedPipeOverlappedRead(
    IOBUFFER &msg,
    OVERLAPPED &ol,
    DWORD len
    )
/*++

Routine Description:

    Issue an overlapped read for the next named pipe buffer.

Arguments:

    msg -   Incoming Named Pipe buffer.        
    ol  -   Corresponding overlapped IO struct.  

Return Value:

    Returns ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("IssueNamedPipeOverlappedRead");

    DWORD result = ERROR_SUCCESS;

    ol.Internal = 0;
    ol.InternalHigh = 0;
    ol.Offset = 0;
    ol.OffsetHigh = 0;
    ResetEvent(ol.hEvent);

    if (!ReadFile(g_ClientSessionPipe, ((PBYTE)msg.buffer), len, NULL, &ol)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            result = GetLastError();
            TRC_ERR((TB, L"ReadFile failed:  %08X", result));
        }
    }

    DC_END_FN();

    return result;
}

DWORD
HandleReceivedVCMsg(
    IOBUFFER &msg
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleReceivedVCMsg");

    OVERLAPPED overlapped;
    PBYTE ptr;
    DWORD bytesToWrite;
    DWORD bytesWritten;
    DWORD result = ERROR_SUCCESS;
    BSTR channelName;
    BSTREqual isBSTREqual;
    CComBSTR tmpStr;

#ifdef USE_MAGICNO
    ASSERT(msg.buffer->magicNo == CHANNELBUF_MAGICNO);
#endif

    //
    //  Get the channel name.
    //  TODO:   We could actually be smarter about this by checking the
    //          length for a match, first.
    //
    channelName = SysAllocStringByteLen(NULL, msg.buffer->channelNameLen);
    if (channelName == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate channel name.")));
        goto CLEANUPANDEXIT;
    }
    ptr = (PBYTE)(msg.buffer + 1);
    memcpy(channelName, ptr, msg.buffer->channelNameLen);

    //
    //  Filter control channel data.
    //
    tmpStr = REMOTEDESKTOP_RC_CONTROL_CHANNEL;
    if (isBSTREqual(channelName, tmpStr)) {
        result = ProcessControlChannelRequest(msg);
        goto CLEANUPANDEXIT;
    }

    //
    //  If the client is not yet authenticated.
    //
    if (!g_ClientAuthenticated) {
        ASSERT(FALSE);
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Send the message header.
    //
    memset(&overlapped, 0, sizeof(overlapped));
    overlapped.hEvent = g_NamedPipeWriteEvent;
    ResetEvent(g_NamedPipeWriteEvent);
    if (!WriteFile(g_ClientSessionPipe, 
                   msg.buffer, sizeof(REMOTEDESKTOP_CHANNELBUFHEADER),
                   &bytesWritten, &overlapped)) {
        if (GetLastError() == ERROR_IO_PENDING) {

            if (WaitForSingleObject(
                            g_NamedPipeWriteEvent, 
                            INFINITE
                            ) != WAIT_OBJECT_0) {
                result = GetLastError();
                TRC_ERR((TB, L"WaitForSingleObject:  %08X", result));
                goto CLEANUPANDEXIT;
            }

            if (!GetOverlappedResult(
                            g_ClientSessionPipe,
                            &overlapped,
                            &bytesWritten,
                            FALSE)) {
                result = GetLastError();
                TRC_ERR((TB, L"GetOverlappedResult:  %08X", result));
                goto CLEANUPANDEXIT;
            }
        }
        else {
            result = GetLastError();
            TRC_ERR((TB, L"WriteFile:  %08X", result));
            goto CLEANUPANDEXIT;
        }
    }
    ASSERT(bytesWritten == sizeof(REMOTEDESKTOP_CHANNELBUFHEADER));

    //
    //  Send the message data.
    //
    ptr = ((PBYTE)msg.buffer) + sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);
    memset(&overlapped, 0, sizeof(overlapped));
    overlapped.hEvent = g_NamedPipeWriteEvent;
    ResetEvent(g_NamedPipeWriteEvent);

    if (!WriteFile(g_ClientSessionPipe, 
                   ptr, msg.buffer->dataLen + 
                        msg.buffer->channelNameLen,
                   &bytesWritten, &overlapped)) {
        if (GetLastError() == ERROR_IO_PENDING) {

            if (WaitForSingleObject(
                            g_NamedPipeWriteEvent, 
                            INFINITE
                            ) != WAIT_OBJECT_0) {
                result = GetLastError();
                TRC_ERR((TB, L"WaitForSingleObject:  %08X", result));
                goto CLEANUPANDEXIT;
            }

            if (!GetOverlappedResult(
                            g_ClientSessionPipe,
                            &overlapped,
                            &bytesWritten,
                            FALSE)) {
                result = GetLastError();
                TRC_ERR((TB, L"GetOverlappedResult:  %08X", result));
                goto CLEANUPANDEXIT;
            }
        }
        else {
            result = GetLastError();
            TRC_ERR((TB, L"WriteFile:  %08X", result));
            goto CLEANUPANDEXIT;
        }
    }
    ASSERT(bytesWritten == msg.buffer->dataLen + 
                           msg.buffer->channelNameLen);

CLEANUPANDEXIT:

    if (channelName != NULL) {
        SysFreeString(channelName);
    }

    DC_END_FN();

    return result;
}

VOID 
HandleVCClientConnect(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleVCClientConnect");

    g_ClientConnected = TRUE;

    DC_END_FN();
}

VOID
HandleVCClientDisconnect(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++

Routine Description:

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("HandleVCClientDisconnect");
    DWORD dwCurTimer = GetTickCount();
    //
    //see if the timer wrapped around to zero (does so if the system was up 49.7 days or something), if so reset it
    //
    if(dwCurTimer > g_PrevTimer && ( dwCurTimer - g_PrevTimer >= g_dwTimeOutInterval)) {
        //
        //enough time passed since the last check. send data to client
        if( SendNullDataToClient() != ERROR_SUCCESS ) {
            //
            //set the shutdown flag
            //
            g_Shutdown = TRUE;
            g_ClientConnected = FALSE;
        }
    }
    
    g_PrevTimer = dwCurTimer;
    DC_END_FN();
}


VOID
HandleNamedPipeReadComplete(
    OVERLAPPED &incomingPipeOL,
    IOBUFFER &incomingPipeBuf
    )
/*++

Routine Description:

    Handle a read complete event on the session's named pipe.

Arguments:

    incomingPipeOL  -   Overlapped Read Struct
    incomingPipeBuf -   Incoming Data Buffer.

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleNamedPipeReadComplete");

    DWORD bytesRead;
    DWORD requiredSize;
    BOOL disconnectClientPipe = FALSE;
    DWORD result;
    DWORD bytesToRead;
    HANDLE waitableObjects[2];
    DWORD waitResult;

    //
    //  Get the results of the read on the buffer header.
    //
    if (!GetOverlappedResult(
                        g_ClientSessionPipe,
                        &incomingPipeOL,
                        &bytesRead,
                        FALSE)
                        || (bytesRead != sizeof(REMOTEDESKTOP_CHANNELBUFHEADER))) {
        disconnectClientPipe = TRUE;
        goto CLEANUPANDEXIT;
    }

    //
    //  Make sure the incoming buffer is large enough.
    //
    requiredSize = incomingPipeBuf.buffer->dataLen + 
                   incomingPipeBuf.buffer->channelNameLen + 
                   sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);
    if (incomingPipeBuf.bufSize < requiredSize) {
        incomingPipeBuf.buffer = (PREMOTEDESKTOP_CHANNELBUFHEADER )REALLOCMEM(
                                                    incomingPipeBuf.buffer,
                                                    requiredSize
                                                    );
        if (incomingPipeBuf.buffer != NULL) {
            incomingPipeBuf.bufSize = requiredSize;
        }
        else {
            TRC_ERR((TB, L"Shutting down because of memory allocation failure."));
            g_Shutdown = TRUE;
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Now read the buffer data.
    //
    incomingPipeOL.Internal = 0;
    incomingPipeOL.InternalHigh = 0;
    incomingPipeOL.Offset = 0;
    incomingPipeOL.OffsetHigh = 0;
    ResetEvent(incomingPipeOL.hEvent);
    if (!ReadFile(
                g_ClientSessionPipe, 
                incomingPipeBuf.buffer + 1,
                incomingPipeBuf.buffer->channelNameLen +
                incomingPipeBuf.buffer->dataLen, 
                &bytesRead, &incomingPipeOL)
                ) {

        if (GetLastError() == ERROR_IO_PENDING) {

            waitableObjects[0] = incomingPipeOL.hEvent;
            waitableObjects[1] = g_ShutdownEvent;
            waitResult = WaitForMultipleObjects(
                            2, waitableObjects, 
                            FALSE,
                            INFINITE
                            );      
            if ((waitResult != WAIT_OBJECT_0) || g_Shutdown) {
                disconnectClientPipe = TRUE;
                goto CLEANUPANDEXIT;
            }

            if (!GetOverlappedResult(
                        g_ClientSessionPipe,
                        &incomingPipeOL,
                        &bytesRead,
                        FALSE)) {
                disconnectClientPipe = TRUE;
                goto CLEANUPANDEXIT;
            }

        }
        else {
            disconnectClientPipe = TRUE;
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Make sure we got all the data.
    //
    bytesToRead = incomingPipeBuf.buffer->channelNameLen +
                  incomingPipeBuf.buffer->dataLen;
    if (bytesRead != bytesToRead) {
        TRC_ERR((TB, L"Bytes read: %ld != bytes requested: %ld", 
                bytesRead, bytesToRead));
        ASSERT(FALSE);
        disconnectClientPipe = TRUE;
        goto CLEANUPANDEXIT;
    }

    //
    //  Handle the read data.    
    //
    HandleReceivedPipeMsg(incomingPipeBuf);

    //
    //  Issue the read for the next message header.
    //
    result = IssueNamedPipeOverlappedRead(
                                incomingPipeBuf,
                                incomingPipeOL,
                                sizeof(REMOTEDESKTOP_CHANNELBUFHEADER)
                                );
    disconnectClientPipe = (result != ERROR_SUCCESS);

CLEANUPANDEXIT:

    //
    //  This is considered a fatal error because the client session must
    //  no longer be in "listen" mode.
    //
    if (disconnectClientPipe) {
        TRC_ERR((TB, L"Connection to client pipe lost:  %08X", 
                GetLastError()));
        g_Shutdown = TRUE;
    }

    DC_END_FN();
}

VOID
HandleReceivedPipeMsg(
    IOBUFFER &msg
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleReceivedPipeMsg");

    DWORD result;
    
    //
    //  Forward the message to the client.
    //  
    result = SendMsgToClient(msg.buffer);

    //
    //  This is considered a fatal error.  The client will need to reconnect
    //  to get things started again.
    //
    if (result != ERROR_SUCCESS) {
        TRC_ERR((TB, L"Shutting down because of VC IO error."));
        g_Shutdown = TRUE;
    }

    DC_END_FN();
}

DWORD
ConnectVC()
/*++

Routine Description:

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("ConnectVC");
    WCHAR buf[256];
    DWORD len;
    PVOID vcFileHandlePtr;
    REMOTEDESKTOP_CTL_SERVERANNOUNCE_PACKET msg;
    REMOTEDESKTOP_CTL_VERSIONINFO_PACKET versionInfoMsg;

    DWORD result = ERROR_SUCCESS;

    //
    //  Open the virtual channel.
    //
    g_VCHandle = WTSVirtualChannelOpen(
                                WTS_CURRENT_SERVER_HANDLE, 
                                WTS_CURRENT_SESSION,
                                TSRDPREMOTEDESKTOP_VC_CHANNEL_A
                                );

    if (g_VCHandle == NULL) {
        result = GetLastError();
        if (result == ERROR_SUCCESS) { result = E_FAIL; }
        TRC_ERR((TB, L"WTSVirtualChannelOpen:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get access to the underlying file handle for async IO.
    //
    if (!WTSVirtualChannelQuery(
                        g_VCHandle,
                        WTSVirtualFileHandle,
                        &vcFileHandlePtr,
                        &len
                        )) {
        result = GetLastError();
        TRC_ERR((TB, L"WTSQuerySessionInformation:  %08X", result));
        goto CLEANUPANDEXIT;
    }
    ASSERT(len == sizeof(g_VCFileHandle));

    //
    //  WTSVirtualChannelQuery allocates the returned buffer.
    //
    memcpy(&g_VCFileHandle, vcFileHandlePtr, sizeof(g_VCFileHandle));
    LocalFree(vcFileHandlePtr);

    //
    //create the timer event, we will start it later
    //it will be signaled when the time is up
    //
    g_ClientIsconnectEvent = CreateWaitableTimer( NULL, FALSE, NULL); 
    if (g_ClientIsconnectEvent == NULL) {
        result = GetLastError();
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the read finish event.      
    //
    g_VCReadOverlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_VCReadOverlapped.hEvent == NULL) {
        result = GetLastError();
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Register the read finish event.
    //
    result = WTBLOBJ_AddWaitableObject(
                                g_WaitObjMgr, NULL, 
                                g_VCReadOverlapped.hEvent,
                                HandleVCReadComplete
                                );
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    // register the disconnect event
    //NOTE : order IS important
    //waitformultipleobjects returns the lowest index
    //when more than one are signaled
    //we want to use the read event, not the disconnect event
    //in case both are signaled

    result = WTBLOBJ_AddWaitableObject(
                                g_WaitObjMgr, NULL, 
                                g_ClientIsconnectEvent,
                                HandleVCClientDisconnect
                                );
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }
    //
    //  Allocate space for the first VC read.
    //
    g_IncomingVCBuf.buffer = (PREMOTEDESKTOP_CHANNELBUFHEADER )ALLOCMEM(
                                        VCBUFFER_RESIZE_DELTA
                                        );
    if (g_IncomingVCBuf.buffer != NULL) {
        g_IncomingVCBuf.bufSize = VCBUFFER_RESIZE_DELTA;
        g_IncomingVCBuf.offset  = 0;
    }
    else {
        TRC_ERR((TB, L"Can't allocate VC read buffer."));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Issue the first overlapped read on the VC.
    //
    result = IssueVCOverlappedRead(g_IncomingVCBuf, g_VCReadOverlapped);
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Notify the client that we are alive.
    //
    memcpy(msg.packetHeader.channelName, REMOTEDESKTOP_RC_CONTROL_CHANNEL,
        sizeof(REMOTEDESKTOP_RC_CONTROL_CHANNEL));
    msg.packetHeader.channelBufHeader.channelNameLen = REMOTEDESKTOP_RC_CHANNELNAME_LENGTH;

#ifdef USE_MAGICNO
    msg.packetHeader.channelBufHeader.magicNo = CHANNELBUF_MAGICNO;
#endif

    msg.packetHeader.channelBufHeader.dataLen = 
                           sizeof(REMOTEDESKTOP_CTL_SERVERANNOUNCE_PACKET) - 
                           sizeof(REMOTEDESKTOP_CTL_PACKETHEADER);
    msg.msgHeader.msgType = REMOTEDESKTOP_CTL_SERVER_ANNOUNCE;
    result = SendMsgToClient((PREMOTEDESKTOP_CHANNELBUFHEADER)&msg);
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Send the server protocol version information.
    //

    memcpy(versionInfoMsg.packetHeader.channelName, REMOTEDESKTOP_RC_CONTROL_CHANNEL,
        sizeof(REMOTEDESKTOP_RC_CONTROL_CHANNEL));
    versionInfoMsg.packetHeader.channelBufHeader.channelNameLen = REMOTEDESKTOP_RC_CHANNELNAME_LENGTH;

#ifdef USE_MAGICNO
    versionInfoMsg.packetHeader.channelBufHeader.magicNo = CHANNELBUF_MAGICNO;
#endif

    versionInfoMsg.packetHeader.channelBufHeader.dataLen =
                           sizeof(REMOTEDESKTOP_CTL_VERSIONINFO_PACKET) -
                           sizeof(REMOTEDESKTOP_CTL_PACKETHEADER);
    versionInfoMsg.msgHeader.msgType = REMOTEDESKTOP_CTL_VERSIONINFO;
    versionInfoMsg.versionMajor = REMOTEDESKTOP_VERSION_MAJOR;
    versionInfoMsg.versionMinor = REMOTEDESKTOP_VERSION_MINOR;
    result = SendMsgToClient((PREMOTEDESKTOP_CHANNELBUFHEADER)&versionInfoMsg);
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return result;
}

DWORD 
ConnectClientSessionPipe()
/*++

Routine Description:

    Connect to the client session TSRDP plug-in named pipe.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("ConnectClientSessionPipe");

    WCHAR pipePath[MAX_PATH+1];
    DWORD result;
    DWORD pipeMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;

    //
    //  Loop until we are connected or time out.
    //
    ASSERT(g_ClientSessionPipe == NULL);
    while(g_ClientSessionPipe == NULL) {
        wsprintf(pipePath, L"\\\\.\\pipe\\%s-%s", 
                 TSRDPREMOTEDESKTOP_PIPENAME, g_HelpSessionID);
        g_ClientSessionPipe = CreateFile(
                                    pipePath,
                                    GENERIC_READ |  
                                    GENERIC_WRITE, 
                                    0,              
                                    NULL,           
                                    OPEN_EXISTING,  
                                    FILE_FLAG_OVERLAPPED, NULL
                                    );
        
        if (g_ClientSessionPipe != INVALID_HANDLE_VALUE) {
            TRC_NRM((TB, L"Pipe successfully connected."));
            result = ERROR_SUCCESS;
            break;
        }
        else {
            TRC_ALT((TB, L"Waiting for pipe availability: %08X.",
                    GetLastError()));
            WaitNamedPipe(pipePath, CLIENTPIPE_CONNECTTIMEOUT);
            result = GetLastError();
            if (result != ERROR_SUCCESS) {
                TRC_ERR((TB, L"WaitNamedPipe:  %08X", result));
                break;
            }
        }

    }

    //
    //  If we didn't get a valid connection, then bail out of 
    //  this function and shut down.
    //
    if (g_ClientSessionPipe == INVALID_HANDLE_VALUE) {
        ASSERT(result != ERROR_SUCCESS);

        TRC_ERR((TB, L"Shutting down because of named pipe error."));
        g_Shutdown = TRUE;

        goto CLEANUPANDEXIT;
    }

    //
    //set the options on the pipe to be the same as that of the server end to avoid problems
    //fatal if we could not set it
    //
     if(!SetNamedPipeHandleState(g_ClientSessionPipe,
                                 &pipeMode, // new pipe mode
                                 NULL,
                                 NULL
                                 )) {
        result = GetLastError();
        TRC_ERR((TB, L"Shutting down, SetNamedPipeHandleState:  %08X", result));
        g_Shutdown = TRUE;
        goto CLEANUPANDEXIT;
    }

    //
    //  Spin off the pipe read background thread.
    //
    g_NamedPipeReadThread = (HANDLE)_beginthread(NamedPipeReadThread, 0, NULL);
    if ((uintptr_t)g_NamedPipeReadThread == -1) {
        g_NamedPipeReadThread = NULL;
        TRC_ERR((TB, L"Failed to create NamedPipeReadThread:  %08X", GetLastError()));
        g_Shutdown = TRUE;
        result = errno; 
        goto CLEANUPANDEXIT;
    } 

CLEANUPANDEXIT:

    DC_END_FN();

    return result;
}

void __cdecl
NamedPipeReadThread(
    void* ptr
    )
/*++

Routine Description:

    Named Pipe Input Thread

Arguments:

    ptr - Ignored

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("NamedPipeReadThread");

    IOBUFFER    incomingPipeBuf = { NULL, 0, 0 };
    OVERLAPPED  overlapped = { 0, 0, 0, 0, NULL };
    DWORD waitResult;
    DWORD ret;
    HANDLE waitableObjects[2];

    //
    //  Allocate the initial buffer for incoming named pipe data.
    //
    incomingPipeBuf.buffer = (PREMOTEDESKTOP_CHANNELBUFHEADER )
                                        ALLOCMEM(sizeof(REMOTEDESKTOP_CHANNELBUFHEADER));
    if (incomingPipeBuf.buffer != NULL) {
        incomingPipeBuf.bufSize = sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);
    }
    else {
        TRC_ERR((TB, L"Can't allocate named pipe buf."));
        g_Shutdown = TRUE;
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the overlapped pipe read event.
    //
    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (overlapped.hEvent == NULL) {
        TRC_ERR((TB, L"CreateEvent:  %08X", GetLastError()));
        g_Shutdown = TRUE;
        goto CLEANUPANDEXIT;
    }

    //
    //  Issue the read for the first message header.
    //
    ret = IssueNamedPipeOverlappedRead(
                                incomingPipeBuf,
                                overlapped,
                                sizeof(REMOTEDESKTOP_CHANNELBUFHEADER)
                                );

    //
    //  If we can't connect, that's considered a fatal error because
    //  the client must no longer be in "listen" mode.  
    //
    if (ret != ERROR_SUCCESS) {
        TRC_ERR((TB, L"Shutting down because of named pipe error."));
        g_Shutdown = TRUE;
    }

    //
    //  Loop until shut down.
    //
    waitableObjects[0] = overlapped.hEvent;
    waitableObjects[1] = g_ShutdownEvent;
    while (!g_Shutdown) {

        //
        //  We will be signalled when the pipe closes or the read completes.
        //
        waitResult = WaitForMultipleObjects(
                        2, waitableObjects, 
                        FALSE,
                        INFINITE
                        );      
        if ((waitResult == WAIT_OBJECT_0) && !g_Shutdown) {
            HandleNamedPipeReadComplete(overlapped, incomingPipeBuf);
        }
        else {
            TRC_ERR((TB, L"WaitForMultipleObjects:  %08X", GetLastError()));
            g_Shutdown = TRUE;
        }
    }


CLEANUPANDEXIT:
    //
    //  Make sure the foreground thread knows that we are shutting down.
    //
    if (g_WakeUpForegroundThreadEvent != NULL) {
        SetEvent(g_WakeUpForegroundThreadEvent);
    }

    if (overlapped.hEvent != NULL) {
        CloseHandle(overlapped.hEvent);
    }
    if (incomingPipeBuf.buffer != NULL) {
        FREEMEM(incomingPipeBuf.buffer);
    }

    DC_END_FN();

    _endthread();
}

VOID WakeUpFunc(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++

Routine Description:

    Stub function, called when the background thread wants the foreground
    thread to wake up because of a state change.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("WakeUpFunc");
    DC_END_FN();
}

VOID HandleHelpCenterExit(
    HANDLE waitableObject, 
    PVOID clientData
    )
/*++

Routine Description:

    Woken up when Help Center exits as a fix for B2 Stopper:  342742

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("HandleHelpCenterExit");
    g_Shutdown = TRUE;
    DC_END_FN();
}

extern "C"
int 
__cdecl
wmain( int argc, wchar_t *argv[])
{
    DC_BEGIN_FN("Main");

    DWORD result = ERROR_SUCCESS;
    DWORD sz;
    HRESULT hr;
    LARGE_INTEGER liDueTime;
    BOOL backgroundThreadFailedToExit = FALSE;
    DWORD waitResult;

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    //
    // Expecting two parameters, first is HelpSession ID and second is
    // HelpSession Password, we don't want to failed here just because
    // number of argument mismatched, we will let authentication fail and
    // return error code.
    //
    ASSERT( argc == 2 );
    if( argc >= 2 ) {
        g_bstrCmdLineHelpSessionId = argv[1];
        TRC_ALT((TB, L"Input Parameters 1 : %ws ", argv[1]));
    }
    
    //
    //  Initialize COM.
    //
    hr = CoInitialize(NULL);
    if (!SUCCEEDED(hr)) {
        result = E_FAIL;
        TRC_ERR((TB, L"CoInitialize:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get our process.
    //
    g_ProcHandle = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, 
                               GetCurrentProcessId());
    if (g_ProcHandle == NULL) {
        result = GetLastError();
        TRC_ERR((TB, L"OpenProcess:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get our process token.
    //
    if (!OpenProcessToken(g_ProcHandle, TOKEN_READ, &g_ProcToken)) {
        result = GetLastError();
        TRC_ERR((TB, L"OpenProcessToken:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get our session ID.  
    //
    if (!GetTokenInformation(g_ProcToken, TokenSessionId, 
                    &g_SessionID, sizeof(g_SessionID), &sz)) {
        result = GetLastError();
        TRC_ERR((TB, L"GetTokenInformation:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the waitable object manager.
    //
    g_WaitObjMgr = WTBLOBJ_CreateWaitableObjectMgr();
    if (g_WaitObjMgr == NULL) {
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //initialize the timer, get the timer interval from registry or use default
    //used for finding if the client (expert) is still connected
    //
    g_PrevTimer = GetTickCount();

    if(!GetDwordFromRegistry(&g_dwTimeOutInterval))
        g_dwTimeOutInterval = RDS_CHECKCONN_TIMEOUT;
    else
        g_dwTimeOutInterval *= 1000; //we need this in millisec
    
    liDueTime.QuadPart =  -1 * g_dwTimeOutInterval * 1000 * 100; //in one hundred nanoseconds

    //
    //  Initiate the VC channel connection.
    //
    result = ConnectVC();
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    //
    //  This is an event the background thread can use to wake up the
    //  foreground thread in order to check state.
    //
    g_WakeUpForegroundThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_WakeUpForegroundThreadEvent == NULL) {
        TRC_ERR((TB, L"CreateEvent:  %08X", GetLastError()));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    result = WTBLOBJ_AddWaitableObject(
                                g_WaitObjMgr, NULL, 
                                g_WakeUpForegroundThreadEvent,
                                WakeUpFunc
                                );
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the named pipe write complete event.
    //
    g_NamedPipeWriteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_NamedPipeWriteEvent == NULL) {
        result = GetLastError();
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //start the timer event, ignore error. 0 in the registry means don't send any pings
    //worst case, we don't get disconnected which is fine
    //
    if(g_dwTimeOutInterval)
        SetWaitableTimer( g_ClientIsconnectEvent, &liDueTime, g_dwTimeOutInterval, NULL, NULL, FALSE );

    //
    //  Create the shutdown event.
    //
    g_ShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_ShutdownEvent == NULL) {
        result = GetLastError();
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Handle IO events until the shut down flag is set.
    //
    while (!g_Shutdown) {
        result = WTBLOBJ_PollWaitableObjects(g_WaitObjMgr);
        if (result != ERROR_SUCCESS) {
            g_Shutdown = TRUE;
        }
    }

    //
    //  Notify the client that we have disconnected, in case it hasn't
    //  figured it out yet.
    //
    if (g_VCFileHandle != NULL) {

        REMOTEDESKTOP_CTL_DISCONNECT_PACKET msg;

        memcpy(msg.packetHeader.channelName, REMOTEDESKTOP_RC_CONTROL_CHANNEL,
            sizeof(REMOTEDESKTOP_RC_CONTROL_CHANNEL));
        msg.packetHeader.channelBufHeader.channelNameLen =
            REMOTEDESKTOP_RC_CHANNELNAME_LENGTH;

#ifdef USE_MAGICNO
        msg.packetHeader.channelBufHeader.magicNo = CHANNELBUF_MAGICNO;
#endif

        msg.packetHeader.channelBufHeader.dataLen = 
                                        sizeof(REMOTEDESKTOP_CTL_DISCONNECT_PACKET) - 
                                        sizeof(REMOTEDESKTOP_CTL_PACKETHEADER);
        msg.msgHeader.msgType = REMOTEDESKTOP_CTL_DISCONNECT;

        SendMsgToClient((PREMOTEDESKTOP_CHANNELBUFHEADER)&msg);
    }

CLEANUPANDEXIT:

    //
    //  Signal the shutdown event.
    //
    if (g_ShutdownEvent != NULL) {
        SetEvent(g_ShutdownEvent);
    }

    //
    //  Wait for the background threads to exit.
    //
    if (g_RemoteControlDesktopThread != NULL) {
        waitResult = WaitForSingleObject(
                            g_RemoteControlDesktopThread, 
                            THREADSHUTDOWN_WAITTIMEOUT
                            );
        if (waitResult == WAIT_OBJECT_0) {
            backgroundThreadFailedToExit = TRUE;
            TRC_ERR((TB, L"WaitForSingleObject g_RemoteControlDesktopThread:  %ld", 
                    waitResult));
        }
    }

    if (g_NamedPipeReadThread != NULL) {
        waitResult = WaitForSingleObject(
                            g_NamedPipeReadThread, 
                            THREADSHUTDOWN_WAITTIMEOUT
                            );
        if (waitResult == WAIT_OBJECT_0) {
            backgroundThreadFailedToExit = TRUE;
            TRC_ERR((TB, L"WaitForSingleObject g_NamedPipeReadThread:  %ld", waitResult));
        }
    }

    if (g_hHelpCenterProcess) {
        CloseHandle(g_hHelpCenterProcess);
    }

    if( g_HelpSessionManager != NULL ) {
        g_HelpSessionManager.Release();
    }

    if (g_WaitObjMgr != NULL) {
        WTBLOBJ_DeleteWaitableObjectMgr(g_WaitObjMgr);
    }

    if (g_ProcHandle != NULL) {
        CloseHandle(g_ProcHandle);
    } 

    if (g_ClientIsconnectEvent != NULL) {
        CloseHandle(g_ClientIsconnectEvent);
    }
    if (g_VCReadOverlapped.hEvent != NULL) {
        CloseHandle(g_VCReadOverlapped.hEvent);
    }
    if (g_ClientSessionPipe != NULL) {
        CloseHandle(g_ClientSessionPipe);
    }
    if (g_IncomingVCBuf.buffer != NULL) {
        FREEMEM(g_IncomingVCBuf.buffer);
    }

    if (g_ShutdownEvent != NULL) {
        CloseHandle(g_ShutdownEvent);
        g_ShutdownEvent = NULL;
    }

    if (g_NamedPipeWriteEvent != NULL) {
        CloseHandle(g_NamedPipeWriteEvent);
    }

    CoUninitialize();

    DC_END_FN();

    //
    //  If any of the background threads failed to exit then terminate
    //  the process.
    //
    if (backgroundThreadFailedToExit) {
        ExitProcess(0);
    }

    return result;
}


DWORD
SendNullDataToClient(
    )
/*++

Routine Description:

    sends a null data packet to client.
    Only purpose is to find out if the client is still connected; if not we exit the process
    REMOTEDESKTOP_RC_CONTROL_CHANNEL channel REMOTEDESKTOP_CTL_RESULT message.    

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("SendNullDataToClient");
    DWORD result;
    DWORD bytesWritten = 0;

    REMOTEDESKTOP_CTL_ISCONNECTED_PACKET msg;

    memcpy(msg.packetHeader.channelName, REMOTEDESKTOP_RC_CONTROL_CHANNEL,
        sizeof(REMOTEDESKTOP_RC_CONTROL_CHANNEL));
    msg.packetHeader.channelBufHeader.channelNameLen = REMOTEDESKTOP_RC_CHANNELNAME_LENGTH;

#ifdef USE_MAGICNO
    msg.packetHeader.channelBufHeader.magicNo = CHANNELBUF_MAGICNO;
#endif

    msg.packetHeader.channelBufHeader.dataLen = sizeof(REMOTEDESKTOP_CTL_ISCONNECTED_PACKET) - 
                                    sizeof(REMOTEDESKTOP_CTL_PACKETHEADER);
    msg.msgHeader.msgType   = REMOTEDESKTOP_CTL_ISCONNECTED;
    result = SendMsgToClient((PREMOTEDESKTOP_CHANNELBUFHEADER )&msg);
    //if we couldn't write all data to the client
    //if we could write some data, assume it is still connected
    //client probably disconnected
    if(result != ERROR_SUCCESS)
        result = SAFERROR_SESSIONNOTCONNECTED;
    DC_END_FN();
    return result;
}


BOOL GetDwordFromRegistry(PDWORD pdwValue)
{
    BOOL fSuccess = FALSE;
    HKEY hKey = NULL;
    
    if( NULL == pdwValue )
        return FALSE;
    
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REG_CONTROL_SALEM,
                    0,
                    KEY_READ,
                    &hKey
                   ) == ERROR_SUCCESS ) {

        DWORD dwSize = sizeof(DWORD);
        DWORD dwType;
        if((RegQueryValueEx(hKey,
                            RDC_CONNCHECK_ENTRY,
                            NULL,
                            &dwType,
                            (PBYTE) pdwValue,
                            &dwSize
                           ) == ERROR_SUCCESS) && dwType == REG_DWORD ) {
            //
            //fall back to default
            //
            fSuccess = TRUE;
        }
    }

CLEANUPANDEXIT:
    if(NULL != hKey )
        RegCloseKey(hKey);
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\tsrdpserverdatachannelmgr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    CTSRDPServerChannelMgr.cpp

Abstract:

    This module contains the TSRDP server-side subclass of 
    CRemoteDesktopChannelMgr.  Classes in this hierarchy are used to multiplex 
    a single data channel into multiple client channels.

    CRemoteDesktopChannelMgr handles most of the details of multiplexing
    the data.  Subclasses are responsible for implementing the details of
    interfacing with the transport for the underlying single data channel.

    The CTSRDPServerChannelMgr creates a named pipe that
    can be connected to by the TSRDP Assistant SessionVC Add-In.  The TSRDP
    Assistant Session VC Add-In acts as a proxy for virtual channel data 
    from the client-side Remote Desktop Host ActiveX Control.  A background 
    thread in this class handles the movement of data between an instance 
    of this class and the proxy.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_tsrdpscm"

#include "TSRDPServerDataChannelMgr.h"
#include <TSRDPRemoteDesktop.h>
#include "TSRDPRemoteDesktopSession.h"
#include <RemoteDesktopUtils.h>

#define INCOMINGBUFFER_RESIZEDELTA  1024


///////////////////////////////////////////////////////
//
//	CTSRDPServerDataChannel Members
//

CTSRDPServerDataChannel::CTSRDPServerDataChannel()
/*++

Routine Description:

    Constructor

Arguments:

Return Value:

    None.

 --*/
{
	DC_BEGIN_FN("CTSRDPServerDataChannel::CTSRDPServerDataChannel");

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

	DC_END_FN();
}

CTSRDPServerDataChannel::~CTSRDPServerDataChannel()
/*++

Routine Description:

    Destructor

Arguments:
7
Return Value:

    None.

 --*/
{
	DC_BEGIN_FN("CTSRDPServerDataChannel::~CTSRDPServerDataChannel");

	//
	//	Notify the channel manager that we have gone away.
	//
	m_ChannelMgr->RemoveChannel(m_ChannelName);

	DC_END_FN();
}

STDMETHODIMP 
CTSRDPServerDataChannel::ReceiveChannelData(
	BSTR *data
	)
/*++

Routine Description:

    Receive the next complete data packet on this channel.

Arguments:

	data	-	The next data packet.  Should be released by the
				caller.

Return Value:

    S_OK on success.  Otherwise, an error result is returned.

 --*/
{
	HRESULT result;

	DC_BEGIN_FN("CTSRDPServerDataChannel::ReceiveChannelData");

	result = m_ChannelMgr->ReadChannelData(m_ChannelName, data);

	DC_END_FN();

	return result;
}

STDMETHODIMP 
CTSRDPServerDataChannel::SendChannelData(
	BSTR data
	)
/*++

Routine Description:

    Send data on this channel.

Arguments:

	data	-	Data to send.

Return Value:

    S_OK on success.  Otherwise, an error result is returned.

 --*/
{
	HRESULT hr;

	DC_BEGIN_FN("CTSRDPServerDataChannel::SendChannelData");
	hr = m_ChannelMgr->SendChannelData(m_ChannelName, data);
	DC_END_FN();

	return hr;
}

STDMETHODIMP 
CTSRDPServerDataChannel::put_OnChannelDataReady(
	IDispatch * newVal
	)
/*++

Routine Description:

    SAFRemoteDesktopDataChannel Scriptable Event Object Registration 
    Properties

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
	DC_BEGIN_FN("CTSRDPServerDataChannel::put_OnChannelDataReady");
	m_OnChannelDataReady = newVal;
	DC_END_FN();
	return S_OK;
}

STDMETHODIMP 
CTSRDPServerDataChannel::get_ChannelName(
	BSTR *pVal
	)
/*++

Routine Description:

    Return the channel name.

Arguments:

	pVal	-	Returned channel name.

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
	DC_BEGIN_FN("CTSRDPServerDataChannel::get_ChannelName");

	CComBSTR str;
	str = m_ChannelName;
	*pVal = str.Detach();

	DC_END_FN();

	return S_OK;
}

/*++

Routine Description:

    Called when data is ready on our channel.

Arguments:

	pVal	-	Returned channel name.

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
VOID 
CTSRDPServerDataChannel::DataReady()
{
	DC_BEGIN_FN("CTSRDPServerDataChannel::DataReady");

	//
	//	Fire our data ready event.
	//
	Fire_ChannelDataReady(m_ChannelName, m_OnChannelDataReady);

	DC_END_FN();
}


///////////////////////////////////////////////////////
//
//  CTSRDPServerChannelMgr Methods
//

CTSRDPServerChannelMgr::CTSRDPServerChannelMgr()
/*++

Routine Description:

    Constructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::CTSRDPServerChannelMgr");

    m_IOThreadBridge			=   NULL;
    m_IOThreadBridgeThreadID	=   0;
    m_IOThreadBridgeStream		=   NULL;

    m_VCAddInPipe				= INVALID_HANDLE_VALUE;
    m_Connected					= FALSE;

    m_ReadIOCompleteEvent		= NULL;
    m_WriteIOCompleteEvent		= NULL;
    m_PipeCreateEvent           = NULL;

    m_IncomingBufferSize		= 0;
    m_IncomingBuffer			= NULL;

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

#if DBG
    m_LockCount = 0;        
#endif

    m_IOThreadHndl = NULL;

    //
    //  Initialize the critical section.
    //
    InitializeCriticalSection(&m_cs);

    //
    //  Not valid, until initialized.
    //
    SetValid(FALSE);

    DC_END_FN();
}

CTSRDPServerChannelMgr::~CTSRDPServerChannelMgr()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::~CTSRDPServerChannelMgr");

    //
    //  Make sure we are no longer listening for data.
    // 
    StopListening();

    //
    //  Close the read IO processing event.
    //
    if (m_ReadIOCompleteEvent != NULL) {
        CloseHandle(m_ReadIOCompleteEvent);
        m_ReadIOCompleteEvent = NULL;
    }

    //
    //  Close the write IO processing event.
    //
    if (m_WriteIOCompleteEvent != NULL) {
        CloseHandle(m_WriteIOCompleteEvent);
        m_WriteIOCompleteEvent = NULL;
    }

    //
    //  Release the incoming buffer.
    //
    if (m_IncomingBuffer != NULL) {
        SysFreeString(m_IncomingBuffer);
        m_IncomingBuffer = NULL;
    }

    if (m_PipeCreateEvent != NULL) {
        CloseHandle(m_PipeCreateEvent);
        m_PipeCreateEvent = NULL;
    }

    if( NULL != m_IOThreadHndl ) {
        CloseHandle( m_IOThreadHndl );
        m_IOThreadHndl = NULL;
    }
    
    //
    //  This should have been cleaned up in the background thread.
    //
    ASSERT(m_IOThreadBridge == NULL);
    ASSERT(m_IOThreadBridgeStream == NULL);

    DeleteCriticalSection(&m_cs);

    DC_END_FN();
}

HRESULT 
CTSRDPServerChannelMgr::Initialize(
	CTSRDPRemoteDesktopSession *sessionObject,
	BSTR helpSessionID
	)
/*++

Routine Description:

    Initialize an instance of this class.      

Arguments:

	sessionObject	-	Back pointer to the containing 
						session object.

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::Initialize");

    HRESULT result = ERROR_SUCCESS;

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

	//
	//	Record help session id.
	//	
	m_HelpSessionID = helpSessionID;

	//
	//	Record the containing session object.
	//	
	m_RDPSessionObject = sessionObject;

    //
    //  Set the initial buffer size and buffer to be at least the 
    //  size of a channel buffer header.
    //
    ASSERT(m_IncomingBuffer == NULL);
    m_IncomingBuffer = SysAllocStringByteLen(
									NULL,
									INCOMINGBUFFER_RESIZEDELTA
									);
    if (m_IncomingBuffer == NULL) {
        result = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUPANDEXIT;
    }
    m_IncomingBufferSize = INCOMINGBUFFER_RESIZEDELTA;
    
    //
    //  Create the read IO processing event.
    //
    ASSERT(m_ReadIOCompleteEvent == NULL);
    m_ReadIOCompleteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_ReadIOCompleteEvent == NULL) {
        result = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the write IO processing event.
    //
    ASSERT(m_WriteIOCompleteEvent == NULL);
    m_WriteIOCompleteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_WriteIOCompleteEvent == NULL) {
        result = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the named pipe create event
    //
    ASSERT(m_PipeCreateEvent == NULL);
    m_PipeCreateEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    
    if (m_PipeCreateEvent == NULL) {
        result = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"CreateEvent:  %08X", result));
        goto CLEANUPANDEXIT;
    }


    //
    //  Initialize the parent class.
    //  
    result = CRemoteDesktopChannelMgr::Initialize();
	if (result != S_OK) {
		goto CLEANUPANDEXIT;
	}

    //
    //  We are valid, if we made it here.
    //
    SetValid(TRUE);

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

CLEANUPANDEXIT:

    DC_END_FN();

    return result;
}

VOID 
CTSRDPServerChannelMgr::ClosePipe()
/*++

Routine Description:

    Close the named pipe.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ClosePipe");

    ASSERT(m_VCAddInPipe != INVALID_HANDLE_VALUE);
    
    FlushFileBuffers(m_VCAddInPipe); 

    //
    // reset the pipe creation event so that the foreground
    // thread can wait for the next help session
    //
    ResetEvent(m_PipeCreateEvent);
    DisconnectNamedPipe(m_VCAddInPipe); 
    CloseHandle(m_VCAddInPipe); 
    m_VCAddInPipe = INVALID_HANDLE_VALUE;
    m_Connected = FALSE;

    DC_END_FN();
}

HRESULT 
CTSRDPServerChannelMgr::StartListening(
    BSTR assistAccount                                                 
    )
/*++

Routine Description:

    Start listening for data channel data.

Arguments:

    assistAccount   -   Name of machine assistant account.

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::StartListening");

    HRESULT hr = S_OK;

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //  If the background thread is still active, then fail.  This
    //  means that it is still trying to shut down.  
    //
    if (m_IOThreadHndl != NULL) {
        if (WaitForSingleObject(m_IOThreadHndl, 0) == WAIT_OBJECT_0) {
            CloseHandle( m_IOThreadHndl );
            m_IOThreadHndl = NULL;
        }
        else {
            TRC_ERR((TB, L"Background thread not shut down, yet:  %08X.",
                    GetLastError()));
			hr = HRESULT_FROM_WIN32(ERROR_ACTIVE_CONNECTIONS);
            goto CLEANUPANDEXIT;
        }
    }

	//
	//	Make the thread bridge interface available to the background thread.
	//
    hr = CoMarshalInterThreadInterfaceInStream(
                                IID_IRDSThreadBridge,
                                (ISAFRemoteDesktopChannelMgr*)this,
                                &m_IOThreadBridgeStream
                                );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("CoMarshalInterThreadInterfaceInStream:  %08X"), hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Reset the connected flag.
    //
    m_Connected = FALSE;

    //
    //  Record the machine assistant account name.
    //
    ASSERT(assistAccount != NULL);
    m_AssistAccount = assistAccount;                                                 

    //
    //  Reset the read IO processing event.
    //
    ASSERT(m_ReadIOCompleteEvent != NULL);
    ResetEvent(m_ReadIOCompleteEvent);

    //
    //  Reset the write IO processing event.
    //
    ASSERT(m_WriteIOCompleteEvent != NULL);
    ResetEvent(m_WriteIOCompleteEvent);

    //
    //reset the named pipe creation event
    ASSERT(m_PipeCreateEvent != NULL);
    ResetEvent(m_PipeCreateEvent);

     //  
    //  Create the background thread that receives data from the
    //  named pipe.
    //
    ASSERT(m_IOThreadHndl == NULL);

    m_IOThreadHndl = CreateThread(
                                NULL, 0, 
                                (LPTHREAD_START_ROUTINE)_IOThread, 
                                this,
                                0,&m_IOThreadID         
                                );
    if (m_IOThreadHndl == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, TEXT("CreateThread:  %08X"), hr));
        goto CLEANUPANDEXIT;
    }

    //
    //wait for the named pipe creation event to be signaled
    //and check for the result. If failed, bail
    //
    WaitForSingleObject(m_PipeCreateEvent, INFINITE);

    //
    //set the error to pipe_busy because we assume that someone else
    //has already created it and that is the reason the CreateNamedPipe call failed.
    //
    if (m_VCAddInPipe == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(ERROR_PIPE_BUSY);
        TRC_ERR((TB, L"CreateNamedPipe returned fail"));
        goto CLEANUPANDEXIT;
    }


CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

HRESULT
CTSRDPServerChannelMgr::StopListening()
/*++

Routine Description:

    Stop listening for data channel data.

Arguments:

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::StopListening");

    DWORD waitResult;

    //
    //  Close the named pipe.  
    //
    ThreadLock();
    if (m_VCAddInPipe != INVALID_HANDLE_VALUE) {
        ClosePipe();
    }

    ThreadUnlock();

    TRC_NRM((TB, L"***Ref count is:  %ld", m_dwRef));

    DC_END_FN();

    return S_OK;
}

HRESULT 
CTSRDPServerChannelMgr::SendData(
    PREMOTEDESKTOP_CHANNELBUFHEADER msg 
    )
/*++

Routine Description:

    Send Function Invoked by Parent Class

Arguments:

    msg -   Message data.  Note that the underlying representation
            for this data structure is a BSTR so that it is compatible
            with COM methods.

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::SendData");

    HRESULT result = S_OK;
    DWORD bytesWritten;
    OVERLAPPED ol;
	DWORD msgLen;

    if (!IsValid()) {
        ASSERT(FALSE);
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    if (m_Connected) {

        //
        //  Write the header.
        //
        memset(&ol, 0, sizeof(ol));
        ol.hEvent = m_WriteIOCompleteEvent;
        ResetEvent(ol.hEvent);
        BOOL ret = WriteFile( 
                        m_VCAddInPipe,
                        msg,
                        sizeof(REMOTEDESKTOP_CHANNELBUFHEADER),
                        NULL,
                        &ol
                        );
        if (ret || (!ret && (GetLastError() == ERROR_IO_PENDING))) {
            ret = GetOverlappedResult(
                            m_VCAddInPipe,
                            &ol, 
                            &bytesWritten,
                            TRUE
                            );
        }
        if (!ret) {
            result = HRESULT_FROM_WIN32(GetLastError());
            TRC_ALT((TB, TEXT("Header write failed:  %08X"), result));
            goto CLEANUPANDEXIT;
        }
        ASSERT(bytesWritten == sizeof(REMOTEDESKTOP_CHANNELBUFHEADER));

        //
        //  Write the rest of the message.
        //
		msgLen = msg->dataLen + msg->channelNameLen;
        memset(&ol, 0, sizeof(ol));
        ol.hEvent = m_WriteIOCompleteEvent;
        ResetEvent(ol.hEvent);
        ret = WriteFile( 
                        m_VCAddInPipe,
                        (PBYTE)(msg+1),
                        msgLen,
                        NULL,
                        &ol
                        );
        if (ret || (!ret && (GetLastError() == ERROR_IO_PENDING))) {
            ret = GetOverlappedResult(
                            m_VCAddInPipe,
                            &ol, 
                            &bytesWritten,
                            TRUE
                            );
        }
        if (!ret) {
            result = HRESULT_FROM_WIN32(GetLastError());
            TRC_ALT((TB, TEXT("Message write failed:  %08X"), result));
            goto CLEANUPANDEXIT;
        }
        ASSERT(bytesWritten == msgLen);
    }
    else {
        result = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

CLEANUPANDEXIT:

    //
    //  If there was an error, we should close the pipe so it
    //  can be reopened in the background thread.
    //
    if (result != S_OK) {
        ThreadLock();
        if (m_VCAddInPipe != INVALID_HANDLE_VALUE) {
            ClosePipe();
        }
        ThreadUnlock();
    }

    DC_END_FN();

    return result;
}

DWORD 
CTSRDPServerChannelMgr::IOThread()
/*++

Routine Description:

    Background Thread Managing Named Pipe Connection to the
    TSRDP Assistant SessionVC Add-In.

Arguments:

Return Value:

    Returns 0

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::IOThread");

    DWORD result;
    DWORD lastError;
    WCHAR pipePath[MAX_PATH+1];
    OVERLAPPED ol;
    DWORD waitResult;
    WCHAR pipeName[MAX_PATH];
    PSECURITY_ATTRIBUTES pipeAttribs = NULL;

    //
    //  Notify the parent class that the IO thread is being initialized.
    //
    
    result = IOThreadInit();
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }


    //
    //  Get the security descriptor for the named pipe.
    //
    pipeAttribs = GetPipeSecurityAttribs(m_AssistAccount);
    if (pipeAttribs == NULL) {
        result = GetLastError();
        goto CLEANUPANDEXIT;
    }


        lastError = ERROR_SUCCESS;

        ASSERT(!m_Connected);
        //
        //  Handle connections by the TSRDP Assistant SessionVC Add-In
        //  until we are supposed to shut down.
        //
        ASSERT(m_VCAddInPipe == INVALID_HANDLE_VALUE);
        ASSERT(!m_Connected);
        wsprintf(pipeName, L"%s-%s", TSRDPREMOTEDESKTOP_PIPENAME, m_HelpSessionID);
        wsprintf(pipePath, L"\\\\.\\pipe\\%s", pipeName);
        m_VCAddInPipe = CreateNamedPipe( 
                              pipePath,
                              PIPE_ACCESS_DUPLEX |
                              FILE_FLAG_OVERLAPPED,     
                              PIPE_TYPE_MESSAGE |       
                              PIPE_READMODE_MESSAGE |   
                              PIPE_WAIT,                
                              1,                        
                              TSRDPREMOTEDESKTOP_PIPEBUFSIZE, 
                              TSRDPREMOTEDESKTOP_PIPEBUFSIZE,
                              TSRDPREMOTEDESKTOP_PIPETIMEOUT,
                              pipeAttribs               
                              );      
        
        //
        //signal the foreground thread about the pipe creation result
        //
        SetEvent(m_PipeCreateEvent);

        if (m_VCAddInPipe == INVALID_HANDLE_VALUE) {
            lastError = GetLastError();
            TRC_ERR((TB, TEXT("CreatePipe:  %08X.  Shutting down background thread."), 
                    lastError)); 
            goto CLEANUPANDEXIT;
        }

        //
        //  Wait for the TSRDP Assistant SesionVC Add-In to connect.
        //  If it succeeds, the function returns a nonzero value. If the 
        //  function returns zero, GetLastError returns ERROR_PIPE_CONNECTED. 
        //

        memset(&ol, 0, sizeof(ol));
        ol.hEvent = m_ReadIOCompleteEvent;
        ResetEvent(ol.hEvent);
        
        if (!ConnectNamedPipe(m_VCAddInPipe, &ol) && (GetLastError() == ERROR_IO_PENDING)) {

            TRC_NRM((TB, L"Waiting for connect."));

            //
            //  Wait for the connect event to fire.
            //
            waitResult = WaitForSingleObject(m_ReadIOCompleteEvent, INFINITE);
            if (waitResult != WAIT_OBJECT_0)
            {
                m_Connected = FALSE;
            }
            //
            //  Otherwise, if the io complete event fired.
            //
            else
            {

                //
                //  If the io complete event fired.
                //
                TRC_NRM((TB, L"Connect event signaled."));
                DWORD ignored;
                m_Connected = GetOverlappedResult(m_VCAddInPipe, &ol, &ignored, TRUE);
            
                if (!m_Connected) {
                    lastError = GetLastError();
                    TRC_ERR((TB, L"GetOverlappedResult:  %08X", lastError));
                }
                else {
                    TRC_NRM((TB, L"Connection established."));
                }
            }
        } //!ConnectNamedPipe

        else if (GetLastError() == ERROR_PIPE_CONNECTED) {
            TRC_NRM((TB, L"Connected without pending."));
            m_Connected = TRUE;
        }
        
        else {
            lastError = GetLastError();
            TRC_ERR((TB, L"ConnectNamedPipe:  %08X", lastError));
        }

 
        //
        //  If we got a valid connection, process reads until the pipe is
        //  disconnected, after notifying the parent class that we have 
        //  a valid connection.
        //
        if (m_Connected) {

			//
			//	Notify the foreground thread that the client connected.
			//
            m_IOThreadBridge->ClientConnectedNotify();

            ProcessPipeMessagesUntilDisconnect();            

            //
            //  Notify the foreground thread that the the client has disconnected.
            //
            m_IOThreadBridge->ClientDisconnectedNotify();
        }

CLEANUPANDEXIT:

    //
    //  Close the pipe if it is still open.
    //
    ThreadLock();
    if (m_VCAddInPipe != INVALID_HANDLE_VALUE) {
        ClosePipe();
    }
    ThreadUnlock();
    
    //
    //  Clean up the named pipe security attribs.
    //
    if (pipeAttribs != NULL) {
        FreePipeSecurityAttribs(pipeAttribs);
    }

    //
    //  Notify the parent class that the IO thread is shutting down.
    //  The parent class will signal this event when the class is completely 
    //  shut down.
    //
    result = IOThreadShutdown(NULL);

    DC_END_FN();

    return result;
}
DWORD CTSRDPServerChannelMgr::_IOThread(
    CTSRDPServerChannelMgr *instance
    )
{
    return instance->IOThread();
}

VOID 
CTSRDPServerChannelMgr::ProcessPipeMessagesUntilDisconnect()
/*++

Routine Description:

    Process messages on the named pipe until it disconnects or
    until the shutdown flag is set.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ProcessPipeMessagesUntilDisconnect");

    DWORD bytesRead;
    DWORD result;
    PREMOTEDESKTOP_CHANNELBUFHEADER hdr;
	DWORD msgLen;

    //
    //  Loop until the connection is terminated or we are to shut down.
    //
    while (m_Connected) {

        //
        //  Read the next buffer header.
        //
        ASSERT(m_IncomingBufferSize >= sizeof(REMOTEDESKTOP_CHANNELBUFHEADER));
        result = ReadNextPipeMessage(
                    sizeof(REMOTEDESKTOP_CHANNELBUFHEADER),
                    &bytesRead,
                    (PBYTE)m_IncomingBuffer
                    );
        if ((result != ERROR_SUCCESS) && (result != ERROR_MORE_DATA)) {
            break;
        }
        ASSERT(bytesRead == sizeof(REMOTEDESKTOP_CHANNELBUFHEADER));
        hdr = (PREMOTEDESKTOP_CHANNELBUFHEADER)m_IncomingBuffer;

#ifdef USE_MAGICNO
        ASSERT(hdr->magicNo == CHANNELBUF_MAGICNO);
#endif


        //
        //  Size the incoming buffer.
        //
		msgLen = hdr->dataLen + hdr->channelNameLen;
        if (m_IncomingBufferSize < msgLen) {
            DWORD sz = msgLen + sizeof(REMOTEDESKTOP_CHANNELBUFHEADER);
            m_IncomingBuffer = (BSTR)ReallocBSTR(
                                        m_IncomingBuffer, sz
                                        );
            if (m_IncomingBuffer != NULL) {
                hdr = (PREMOTEDESKTOP_CHANNELBUFHEADER)m_IncomingBuffer;
                m_IncomingBufferSize = sz;
            }
            else {
                TRC_ERR((TB, L"Can't resize %ld bytes for incoming buffer.",
                        m_IncomingBufferSize + INCOMINGBUFFER_RESIZEDELTA));
                m_IncomingBufferSize = 0;
                break;
            }
        }

        //
        //  Read the buffer data.
        //
        result = ReadNextPipeMessage(
                    msgLen,
                    &bytesRead,
                    ((PBYTE)m_IncomingBuffer) + sizeof(REMOTEDESKTOP_CHANNELBUFHEADER)
                    );
        if (result != ERROR_SUCCESS) {
            break;
        }
        ASSERT(bytesRead == msgLen);

        //
        //  Process the complete buffer in the foreground thread.
        //
		m_IOThreadBridge->DataReadyNotify(m_IncomingBuffer);
    }

    //
    //  We are here because something went wrong and we should disconnect.
    //
    ThreadLock();
    if (m_VCAddInPipe != INVALID_HANDLE_VALUE) {
        ClosePipe();
    }
    ThreadUnlock();

    DC_END_FN();
}

DWORD   
CTSRDPServerChannelMgr::ReadNextPipeMessage(
    IN DWORD bytesToRead,
    OUT DWORD *bytesRead,
    IN PBYTE buf
    )
/*++

Abstract:

    Read the next message from the pipe.
Parameter:

    bytesToRead -   Number of bytes to read.
    bytesRead   -   Number of bytes read.
    buf         -   Buffer for data read.

Returns:

    ERROR_SUCCESS on success.  Otherwise, a windows error code is
    returned.

--*/
{       
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ReadNextPipeMessage");

    OVERLAPPED ol;
    BOOL result;
    DWORD lastError;
    DWORD waitResult;

    memset(&ol, 0, sizeof(ol));
    ol.hEvent = m_ReadIOCompleteEvent;
    ResetEvent(ol.hEvent);
    lastError = ERROR_SUCCESS;
    result = ReadFile(m_VCAddInPipe, buf, bytesToRead, bytesRead, &ol);     
    if (!result) {
        //
        //  If IO is pending.
        //
        lastError = GetLastError();
        if (lastError == ERROR_IO_PENDING) {

            //
            //  Wait for the read to finish and for the shutdown event to fire.
            //
            waitResult = WaitForSingleObject(m_ReadIOCompleteEvent, INFINITE);
            if (waitResult == WAIT_OBJECT_0)
            {
                if (GetOverlappedResult(m_VCAddInPipe, &ol, bytesRead, TRUE)) {
                    lastError = ERROR_SUCCESS;
                }
                else {
                    lastError = GetLastError();
                    TRC_ALT((TB, L"GetOverlappedResult:  %08X", lastError));
                }
            }
            else {
                lastError = GetLastError();
                TRC_NRM((TB, L"WaitForSingleObject failed : %08x", lastError));
            }
        }
    }
    else {
        lastError = ERROR_SUCCESS;
    }

    DC_END_FN();
    return lastError;
}

PSECURITY_ATTRIBUTES   
CTSRDPServerChannelMgr::GetPipeSecurityAttribs(
    IN LPTSTR assistantUserName
    )
/*++

Abstract:

    Returns the security attribs for the named pipe.

Parameter:

    assistantUserName   -   Machine assistant user account.

Returns:

    NULL on error.  Otherwise, the security attribs are returned
    and should be freed via call to FREEMEM.  On error, GetLastError()
    can be used to get extended error information.

--*/
{
    PACL pAcl=NULL;     
    DWORD sidSz;
    DWORD domainSz;
    PSID pCurrentUserSid = NULL;
    PSID pHelpAssistantSid = NULL;
    DWORD result = ERROR_SUCCESS;
    PSECURITY_ATTRIBUTES attribs = NULL;
    SID_NAME_USE sidNameUse;
    DWORD aclSz;
    HANDLE userToken = NULL;
    WCHAR *domainName = NULL;

    DC_BEGIN_FN("CTSRDPServerChannelMgr::GetPipeSecurityAttribs");

    //
    //   Allocate the security attributes.
    //
    attribs = (PSECURITY_ATTRIBUTES)ALLOCMEM(sizeof(SECURITY_ATTRIBUTES));
    if (attribs == NULL) {
        TRC_ERR((TB, L"Can't allocate security attribs."));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }
    memset(attribs, 0, sizeof(SECURITY_ATTRIBUTES)); 

    //
    //  Allocate the security descriptor.
    //
    attribs->lpSecurityDescriptor = ALLOCMEM(sizeof(SECURITY_DESCRIPTOR));
    if (attribs->lpSecurityDescriptor == NULL) {
        TRC_ERR((TB, L"Can't allocate SD"));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the security descriptor.
    //
    if (!InitializeSecurityDescriptor(
                    attribs->lpSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    )) {
        result = GetLastError();
        TRC_ERR((TB, L"InitializeSecurityDescriptor:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the token for the current process.
    //
    if (!OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_QUERY,
                    &userToken
                    )) {
        result = GetLastError();
        TRC_ERR((TB, L"OpenProcessToken:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the SID for the current user.
    //
    pCurrentUserSid = GetUserSid(userToken);
    if (pCurrentUserSid == NULL) {
        result = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the size for the assistant account user SID.
    //
    domainSz = 0; sidSz = 0;
    if (!LookupAccountName(NULL, assistantUserName, NULL,
                        &sidSz, NULL, &domainSz, &sidNameUse
                        ) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        result = GetLastError();
        TRC_ERR((TB, L"LookupAccountName:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Allocate the SID.
    //
    pHelpAssistantSid = (PSID)ALLOCMEM(sidSz);
    if (pHelpAssistantSid == NULL) {
        TRC_ERR((TB, L"Can't allocate help asistant SID."));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    //  
    //  Allocate the domain name.
    //
    domainName = (WCHAR *)ALLOCMEM(domainSz * sizeof(WCHAR));
    if (domainName == NULL) {
        TRC_ERR((TB, L"Can't allocate domain"));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the assistant account SID.
    //
    if (!LookupAccountName(NULL, assistantUserName, pHelpAssistantSid,
                        &sidSz, domainName, &domainSz, &sidNameUse
                        )) {
        result = GetLastError();
        TRC_ERR((TB, L"LookupAccountName:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Allocate space for the ACL.
    //
    aclSz = GetLengthSid(pCurrentUserSid) + 
            GetLengthSid(pHelpAssistantSid) + 
            sizeof(ACL) + 
            (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    pAcl = (PACL)ALLOCMEM(aclSz); 
    if(pAcl == NULL) {
        TRC_ERR((TB, L"Can't allocate ACL"));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the ACL.
    //
    if (!InitializeAcl(pAcl, aclSz, ACL_REVISION)) {
        result = GetLastError();
        TRC_ERR((TB, L"InitializeACL:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add the current user ace.
    //
    if (!AddAccessAllowedAce(pAcl, 
                        ACL_REVISION, 
                        GENERIC_READ | GENERIC_WRITE | GENERIC_ALL, 
                        pCurrentUserSid
                        )) {
        result = GetLastError();
        TRC_ERR((TB, L"AddAccessAllowedAce:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add the help assistant ace.
    //
    if (!AddAccessAllowedAce(pAcl, 
                        ACL_REVISION, 
                        GENERIC_READ | GENERIC_WRITE | GENERIC_ALL, 
                        pHelpAssistantSid
                        )) {
        result = GetLastError();
        TRC_ERR((TB, L"AddAccessAllowedAce:  %08X", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the secrity descriptor discretionary ACL. 
    //
    if (!SetSecurityDescriptorDacl(attribs->lpSecurityDescriptor, 
                                  TRUE, pAcl, FALSE)) {     
        result = GetLastError();
        TRC_ERR((TB, L"SetSecurityDescriptorDacl:  %08X", result));
        goto CLEANUPANDEXIT;
    } 

CLEANUPANDEXIT:

    if (pCurrentUserSid != NULL) {
        FREEMEM(pCurrentUserSid);
    }

    if (pHelpAssistantSid != NULL) {
        FREEMEM(pHelpAssistantSid);
    }

    if (domainName != NULL) {
        FREEMEM(domainName);
    }

    if( userToken != NULL ) {
        CloseHandle( userToken );
    }

    //
    //  Clean up on error.
    //
    if (result != ERROR_SUCCESS) {
        if (attribs != NULL) {
            FreePipeSecurityAttribs(attribs);
            attribs = NULL;
        }
    }

    SetLastError(result);
    DC_END_FN();

    return attribs;
}

VOID   
CTSRDPServerChannelMgr::FreePipeSecurityAttribs(
    PSECURITY_ATTRIBUTES attribs
    )
/*++

Abstract:

    Release security attribs allocated via a call to GetPipeSecurityAttribs

Parameter:

    attribs  -  Attribs returned by GetPipeSecurityAttribs.

Returns:

--*/
{
    BOOL daclPresent;
    PACL pDacl = NULL;
    BOOL daclDefaulted;

    DC_BEGIN_FN("CTSRDPServerChannelMgr::FreePipeSecurityAttribs");

    ASSERT(attribs != NULL);

    if (attribs->lpSecurityDescriptor) {
        if (GetSecurityDescriptorDacl(
                                attribs->lpSecurityDescriptor,
                                &daclPresent,
                                &pDacl,
                                &daclDefaulted
                                )) {
            ASSERT(!daclDefaulted);
            if (pDacl != NULL) {
                FREEMEM(pDacl);
            }
        }
        FREEMEM(attribs->lpSecurityDescriptor);
    }
    FREEMEM(attribs);

    DC_END_FN();
}

PSID
CTSRDPServerChannelMgr::GetUserSid(
    IN HANDLE userToken
    ) 
/*++

Routine Description:

    Get the SID for a particular user.

Arguments:

    Access Token for the User

Return Value:

    The PSID if successful.  Otherwise, NULL is returned and
    GetLastError can be used to retrieve the windows error code.

--*/
{

    DC_BEGIN_FN("CTSRDPServerChannelMgr::GetUserSid");

    TOKEN_USER * ptu = NULL;
    BOOL bResult;
    PSID psid = NULL;

    DWORD defaultSize = sizeof(TOKEN_USER);
    DWORD size;
    DWORD result = ERROR_SUCCESS;

    ptu = (TOKEN_USER *)ALLOCMEM(defaultSize);
    if (ptu == NULL) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Get information about the user token.
    //
    bResult = GetTokenInformation(
                    userToken,             
                    TokenUser,             
                    ptu,                   
                    defaultSize,           
                    &size
                    );                

    if (bResult == FALSE) {
        result = GetLastError();
        if (result == ERROR_INSUFFICIENT_BUFFER) {

            //
            //  sAllocate required memory
            //
            FREEMEM(ptu);
            ptu = (TOKEN_USER *)ALLOCMEM(size);

            if (ptu == NULL) {
                TRC_ERR((TB, L"Can't allocate user token."));
                result = ERROR_NOT_ENOUGH_MEMORY;
                goto CLEANUPANDEXIT;
            }
            else {
                defaultSize = size;
                bResult = GetTokenInformation(
                                userToken,
                                TokenUser,
                                ptu,
                                defaultSize,
                                &size
                                );

                if (bResult == FALSE) {  
                    result = GetLastError();
                    TRC_ERR((TB, L"GetTokenInformation:  %08X", result));
                    goto CLEANUPANDEXIT;
                }
            }
        }
        else {
            TRC_ERR((TB, L"GetTokenInformation:  %08X", result));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Get the length of the SID.
    //
    size = GetLengthSid(ptu->User.Sid);

    //
    // Allocate memory. This will be freed by the caller.
    //
    psid = (PSID)ALLOCMEM(size);
    if (psid != NULL) {         
        CopySid(size, psid, ptu->User.Sid);
    }
    else {
        TRC_ERR((TB, L"Can't allocate SID"));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    if (ptu != NULL) {
        FREEMEM(ptu);
    }

    SetLastError(result);

    DC_END_FN();
    return psid;
}

DWORD 
CTSRDPServerChannelMgr::IOThreadInit()
/*++

Routine Description:

    Called on Init of Background Thread

Arguments:

Return Value:

	Returns ERROR_SUCCESS on success.  Otherwise, an error code
	is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::IOThreadInit");

    HRESULT hr;
    DWORD result = ERROR_SUCCESS;

    if (!IsValid()) {
        ASSERT(FALSE);
        return E_FAIL;
    }

    //
    //  We only allow one IO thread.
    //
    ASSERT(m_IOThreadBridgeThreadID == 0);
    m_IOThreadBridgeThreadID = GetCurrentThreadId();

    //
    //  Need to define the apartment for this thread as STA.
    //
    hr = CoInitialize(NULL);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, TEXT("CoInitializeEx:  %08X"), hr));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Grab the thread bridge 
    //
    hr = CoGetInterfaceAndReleaseStream(
                            m_IOThreadBridgeStream,
                            IID_IRDSThreadBridge,
                            (PVOID*)&m_IOThreadBridge
                            );
    if (SUCCEEDED(hr)) {
        m_IOThreadBridgeStream = NULL;
    }
    else { 
        TRC_ERR((TB, TEXT("CoGetInterfaceAndReleaseStream:  %08X"), hr));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    if (!SUCCEEDED(hr)) {
        m_IOThreadBridgeThreadID = 0;
    }

    DC_END_FN();

    return result;
}

DWORD 
CTSRDPServerChannelMgr::IOThreadShutdown(
    HANDLE shutDownEvent
    )
/*++

Routine Description:

    Called on Shutdown of Background Thread

Arguments:

    shutDownEvent   -   We need to signal this when we are completely
                        done shutting down.

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::IOThreadShutdown");

    IRDSThreadBridge *tmp;

    //
    //  Make sure the init CB was called and succeded.
    //
    ASSERT(m_IOThreadBridgeThreadID != 0);
    m_IOThreadBridgeThreadID = 0;

    //
    //  Get a reference to the thread interface bridge so the foreground
    //  thread doesn't try to whack it when we signal the event, indicating
    //  that the background thread has completely shut down.
    //
    tmp = m_IOThreadBridge;
    m_IOThreadBridge = NULL;

    //
    //  Signal that the thread is shut down, completely.
    //
    if (shutDownEvent != NULL) {
        SetEvent(shutDownEvent);
    }

    //
    //  Decrement the ref count on the IO thread bridge.  This may cause the
    //  COM object that contains us to go away, so we need to do this,
    //  carefully, as the last thing before shutting down COM for this thread.
    //
    if (tmp != NULL) {
        tmp->Release();
    }

    CoUninitialize();

    DC_END_FN();

    return ERROR_SUCCESS;
}

STDMETHODIMP
CTSRDPServerChannelMgr::ClientConnectedNotify()
/*++

Routine Description:

    This function is implemented for the IRDSThreadBridge interface and
	is called by the background thread when a client connects.  This 
	function, in turn, notifies the containing Remote Desktop Session class.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ClientConnectedNotify");
	
	m_RDPSessionObject->ClientConnected();

	DC_END_FN();
	return S_OK;
}

STDMETHODIMP
CTSRDPServerChannelMgr::ClientDisconnectedNotify()
/*++

Routine Description:

    This function is implemented for the IRDSThreadBridge interface and
	is called by the background thread when a client disconnects.  This 
	function, in turn, notifies the containing Remote Desktop Session class.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ClientDisconnectedNotify");
	
	m_RDPSessionObject->ClientDisconnected();

	DC_END_FN();
	return S_OK;
}

STDMETHODIMP
CTSRDPServerChannelMgr::DataReadyNotify(
	BSTR data
	)
/*++

Routine Description:

    This function is implemented for the IRDSThreadBridge interface and
	is called by the background thread when new data is received.  This 
	function, in turn, notifies the parent class.

Arguments:

    data	-	New data.

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ClientDisconnectedNotify");
	
	CRemoteDesktopChannelMgr::DataReady(data);

	DC_END_FN();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

//  Enable for ATL tracing.
/*
#define _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_REFCOUNT
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#define ATL_TRACE_LEVEL 4
#define DEBUG
*/

#if !defined(AFX_STDAFX_H__7A2C5023_D9D1_4F82_A665_FEA3E9E7DFF9__INCLUDED_)
#define AFX_STDAFX_H__7A2C5023_D9D1_4F82_A665_FEA3E9E7DFF9__INCLUDED_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winsta.h>
#include <tdi.h>



#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:

    LONG Lock();
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7A2C5023_D9D1_4F82_A665_FEA3E9E7DFF9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\global.cpp ===
#include "stdafx.h"
#include "helpacc.h"
#include "helptab.h"

#include "global.h"

HelpAssistantAccount    g_HelpAccount;
CHelpSessionTable       g_HelpSessTable;
CComBSTR                g_LocalSystemSID;
PSID                    g_pSidSystem = NULL;
CComBSTR                g_UnknownString;
CComBSTR                g_RAString;
CComBSTR                g_URAString;

CComBSTR                g_TSSecurityBlob;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\tsrdpserverdatachannelmgr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    CTSRDPServerChannelMgr.h

Abstract:

    This module contains the TSRDP server-side subclass of 
    CRemoteDesktopChannelMgr.  Classes in this hierarchy are used to multiplex 
    a single data channel into multiple client channels.

    CRemoteDesktopChannelMgr handles most of the details of multiplexing
    the data.  Subclasses are responsible for implementing the details of
    interfacing with the transport for the underlying single data channel.

    The CTSRDPServerChannelMgr class creates a named pipe that
    can be connected to by the TSRDP Assistant SessionVC Add-In.  The TSRDP
    Assistant Session VC Add-In acts as a proxy for virtual channel data 
    from the client-side Remote Desktop Host ActiveX Control.  A background 
    thread in this class handles the movement of data between an instance 
    of this class and the proxy.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __CTSRDPSERVERDATACHANNELMGR_H__
#define __CTSRDPSERVERDATACHANNELMGR_H__

#include <DataChannelMgr.h>
#include <atlbase.h>
#include <aclapi.h>
#include <RemoteDesktopChannels.h>
#include <rdshost.h>
#include <resource.h>
#include <ServerDataChannelMgrP.h>


///////////////////////////////////////////////////////
//
//	CTSRDPServerDataChannel	
//
//	TSRDP Server-Specific Subclass of CRemoteDesktopDataChannel.	
//

class ATL_NO_VTABLE CTSRDPServerDataChannel : 
	public CRemoteDesktopDataChannel,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTSRDPServerDataChannel, &CLSID_TSRDPServerDataChannel>,
	public IConnectionPointContainerImpl<CTSRDPServerDataChannel>,
	public IDispatchImpl<ISAFRemoteDesktopDataChannel, &IID_ISAFRemoteDesktopDataChannel, &LIBID_RDSSERVERHOSTLib>,
	public IProvideClassInfo2Impl<&CLSID_TSRDPServerDataChannelMgr, NULL, &LIBID_RDSSERVERHOSTLib>,
	public CProxy_ISAFRemoteDesktopDataChannelEvents< CTSRDPServerDataChannel >
{
protected:

	//
	//	Scriptable Event Callback Object
	//
	CComPtr<IDispatch>  m_OnChannelDataReady;

	//
	//	Back pointer to the channel manager.
	//	
	CRemoteDesktopChannelMgr *m_ChannelMgr;

public:

	//
	//	Constructor/Destructor
	//
	CTSRDPServerDataChannel();
	virtual ~CTSRDPServerDataChannel();

    //  
    //  Initialize an instance of this class.      
    //
    virtual void Initialize(
				CRemoteDesktopChannelMgr *mgr,
				BSTR channelName
				) 
	{
		m_ChannelMgr = mgr;
		m_ChannelName = channelName;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TSRDPSERVERDATACHANNEL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTSRDPServerDataChannel)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopDataChannel)
	COM_INTERFACE_ENTRY2(IDispatch, ISAFRemoteDesktopDataChannel)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CTSRDPServerDataChannel)
    CONNECTION_POINT_ENTRY(DIID__ISAFRemoteDesktopDataChannelEvents)
END_CONNECTION_POINT_MAP()

	//
	//	ISAFRemoteDesktopDataChannel Methods
	//
	//	The parent class handles the details of these methods.
	//

	STDMETHOD(ReceiveChannelData)(/*[out, retval]*/BSTR *data);
	STDMETHOD(SendChannelData)(BSTR data);
	STDMETHOD(put_OnChannelDataReady)(/*[in]*/ IDispatch * newVal);
	STDMETHOD(get_ChannelName)(/*[out, retval]*/ BSTR *pVal);

	//
	//	Called to return our ISAFRemoteDesktopDataChannel interface.
	//
	virtual HRESULT GetISAFRemoteDesktopDataChannel(
				ISAFRemoteDesktopDataChannel **channel
				) {
		HRESULT hr;				
		hr = this->QueryInterface(
					IID_ISAFRemoteDesktopDataChannel, (PVOID*)channel
					);
		return hr;					
	}	

	//
	//	Called by the data channel manager when data is ready on our channel.
	//	
    virtual VOID DataReady();

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    { return TEXT("CTSRDPServerDataChannel"); }
};


///////////////////////////////////////////////////////
//
//  CTSRDPServerChannelMgr
//

class CTSRDPRemoteDesktopSession;
class CTSRDPServerChannelMgr : public CRemoteDesktopChannelMgr,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTSRDPServerChannelMgr, &CLSID_TSRDPServerDataChannelMgr>,
	public IDispatchImpl<ISAFRemoteDesktopChannelMgr, &IID_ISAFRemoteDesktopChannelMgr, &LIBID_RDSSERVERHOSTLib>,
    public IDispatchImpl<IRDSThreadBridge, &IID_IRDSThreadBridge, &LIBID_RDSSERVERHOSTLib>
{
private:

    //
    //  Named pipe connection to TSRDP Assistant Session VC Add-In
    //
    HANDLE  m_VCAddInPipe;
    BOOL    m_Connected;

    //
    //  Management of Bridge between Background Thread and STA
    //  for this component.
    //
    LPSTREAM    m_IOThreadBridgeStream;
    DWORD       m_IOThreadBridgeThreadID;
    IRDSThreadBridge *m_IOThreadBridge;

	//
	//	Back Pointer to the TSRDP Session Object
	//
	CTSRDPRemoteDesktopSession *m_RDPSessionObject;

    //
    //  Incoming buffer and size.  
    //
    BSTR  m_IncomingBuffer;
    DWORD m_IncomingBufferSize;

    //
    //  Handle to background thread and related events.
    //
    HANDLE  m_IOThreadHndl;
    DWORD   m_IOThreadID;
    HANDLE  m_ReadIOCompleteEvent;
    HANDLE  m_WriteIOCompleteEvent;
    HANDLE  m_PipeCreateEvent;

    //
    //  Machine Assistant Account Name
    //
    CComBSTR    m_AssistAccount;

	//
	//	Help session ID for the help session associated with this
	//	instance of the channel manager.
	//
	CComBSTR	m_HelpSessionID;

    //
    //  Shutdown flag.
    //
    BOOL		m_ThreadShutdownFlag;

    //
    //  ThreadLock
    //
    CRITICAL_SECTION m_cs;

#if DBG
    LONG   m_LockCount;
#endif

    //  
    //  ThreadLock/ThreadUnlock an instance of this class.      
    //
    VOID ThreadLock();
    VOID ThreadUnlock();

    //
    //  Background Thread Managing Named Pipe Connection to the
    //  TSRDP Assistant SessionVC Add-In.
    //
    DWORD IOThread();
    static DWORD _IOThread(CTSRDPServerChannelMgr *instance);

    //
    //  Process messages on the named pipe until it disconnects or
    //  until the shutdown flag is set.
    //
    VOID ProcessPipeMessagesUntilDisconnect();

    //
    //  Get the SID for a particular user.
    //
    PSID GetUserSid(HANDLE userToken);

    //
    //  Release security attribs allocated via a call to 
    //  GetPipeSecurityAttribs
    //
    VOID FreePipeSecurityAttribs(PSECURITY_ATTRIBUTES attribs);

    //
    //  Returns the security attribs for the named pipe.
    //
    PSECURITY_ATTRIBUTES GetPipeSecurityAttribs(LPTSTR assistantUserName);

    //
    //  Close the named pipe.
    //
    VOID ClosePipe();

    //
    //  Called on Init/Shutdown of IO Background Thread.
    //
    DWORD	IOThreadInit();
    DWORD	IOThreadShutdown(HANDLE shutDownEvent);

	//
	//	Help the parent class out by opening the right channel object
	//	for the platform.
	//
	virtual CRemoteDesktopDataChannel *OpenPlatformSpecificDataChannel(
										BSTR channelName,			
										ISAFRemoteDesktopDataChannel **channel
										) 
	{
		CComObject<CTSRDPServerDataChannel> *obj;
		obj = new CComObject<CTSRDPServerDataChannel>();
		if (obj != NULL) {
			obj->Initialize(this, channelName);
			obj->QueryInterface(
						__uuidof(ISAFRemoteDesktopDataChannel), 
						(PVOID *)channel
						);
		}
		return obj;
	}

protected:

    //
    //  Send Function Invoked by Parent Class
    //
    virtual HRESULT SendData(PREMOTEDESKTOP_CHANNELBUFHEADER msg);

    //
    //  Read the next message from the pipe.  This function will
    //  return, immediately, if the shutdown event is signaled.
    //
    DWORD ReadNextPipeMessage(DWORD bytesToRead, DWORD *bytesRead, PBYTE buf);

public:

    //
    //  Constructor/Destructor
    //
    CTSRDPServerChannelMgr();
    ~CTSRDPServerChannelMgr();

    //
    //  Start/stop listening for channel data.
    //
    virtual HRESULT StartListening(BSTR assistAccount);
    virtual HRESULT StopListening();

DECLARE_REGISTRY_RESOURCEID(IDR_TSRDPSERVERCHANNELMGR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTSRDPServerChannelMgr)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopChannelMgr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IRDSThreadBridge)
END_COM_MAP()

	// 
	//	ISAFRemoteDesktopChannelMgr Methods
	//
	STDMETHOD(OpenDataChannel)(BSTR name, ISAFRemoteDesktopDataChannel **channel) 
	{
		//
		//	Let the parent handle it.
		//
		return OpenDataChannel_(name, channel);
	}

    //
    //  Force a disconnect of the currently connected client.
    //
    VOID Disconnect() {
        StopListening();
    }

    //
    //  IRDSThreadBridge Functions
    //
    //  These functions are used to bridge functions that get called, 
    //  asynchronously, from a thread other than the STA thread associated
    //  with an instance of this class.
    //
    STDMETHOD(ClientConnectedNotify)();
    STDMETHOD(ClientDisconnectedNotify)();
	STDMETHOD(DataReadyNotify)(BSTR data);
	
    //  
    //  Initialize an instance of this class.      
    //
    virtual HRESULT Initialize(
			CTSRDPRemoteDesktopSession *sessionObject,
			BSTR helpSessionID
			);

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    
        { return TEXT("CTSRDPServerChannelMgr"); }

};



///////////////////////////////////////////////////////
//
//  Inline Members
//

//
//  TODO: If nothing is using these functions, 
//

inline VOID CTSRDPServerChannelMgr::ThreadLock()
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ThreadLock");
#if DBG
    m_LockCount++;
    //TRC_NRM((TB, TEXT("ThreadLock count is now %ld."), m_LockCount));
#endif
    EnterCriticalSection(&m_cs);
    DC_END_FN();
}

inline VOID CTSRDPServerChannelMgr::ThreadUnlock()
{
    DC_BEGIN_FN("CTSRDPServerChannelMgr::ThreadUnlock");
#if DBG
    m_LockCount--;
    //TRC_NRM((TB, TEXT("ThreadLock count is now %ld."), m_LockCount));
    ASSERT(m_LockCount >= 0);
#endif
    LeaveCriticalSection(&m_cs);
    DC_END_FN();
}

#endif //__CTSRDPSERVERDATACHANNELMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\global.h ===
#ifndef __HELP_GLOBAL_H__

#define __HELP_GLOBAL_H__


#include "helpacc.h"
#include "helptab.h"
#include <atlctl.h>

extern HelpAssistantAccount g_HelpAccount;
extern CHelpSessionTable    g_HelpSessTable;
extern CComBSTR g_LocalSystemSID;
extern PSID     g_pSidSystem;
extern CComBSTR g_UnknownString;
extern CComBSTR g_RAString;
extern CComBSTR g_URAString;

extern CComBSTR g_TSSecurityBlob;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\rdhost\tsrdpremotedesktopsession.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    TSRDPRemoteDesktopSession

Abstract:

    This is the TS/RDP implementation of the Remote Desktop Session class.
    
    The Remote Desktop Session class defines functions that define 
    pluggable C++ interface for remote desktop access, by abstracting 
    the implementation specific details of remote desktop access for the 
    server-side into the following C++ methods:

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include <RemoteDesktop.h>

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_tsrdss"

#include <RDSHost.h>
#include "TSRDPRemoteDesktopSession.h"
#include "TSRDPServerDataChannelMgr.h"
#include <RemoteDesktopChannels.h>
#include "RemoteDesktopUtils.h"
#include <Sddl.h>

#include <windows.h>


///////////////////////////////////////////////////////
//
//  CTSRDPRemoteDesktopSession Methods
//

CTSRDPRemoteDesktopSession::CTSRDPRemoteDesktopSession() :
    m_ChannelMgr(NULL)
/*++

Routine Description:

    Constructor

Arguments:

Return Value:

    None.

 --*/

{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::CTSRDPRemoteDesktopSession");
    DC_END_FN();
}

CTSRDPRemoteDesktopSession::~CTSRDPRemoteDesktopSession()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

    None.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::~CTSRDPRemoteDesktopSession");

    Shutdown();

    DC_END_FN();
}

HRESULT
CTSRDPRemoteDesktopSession::Initialize(
    BSTR connectParms,
    CRemoteDesktopServerHost *hostObject,
    REMOTE_DESKTOP_SHARING_CLASS sharingClass,
    BOOL bEnableCallback,
    DWORD timeOut,
    BSTR userHelpCreateBlob,
    LONG tsSessionID,
    BSTR userSID
    )
/*++

Routine Description:

  The Initialize method prepares the COM object for connection by 
  the client-side Remote Desktop Host ActiveX Control.

Arguments:

    connectParms        - If parms are non-NULL, then the session already exists.  
                          Otherwise, a new session should be created.
    hostObject          - Back pointer to containing RDS Host object.
    sharingClass        - Level of desktop sharing for a new session.
    callbackCLSID       - Callback object class ID for a new session.
    timeOut             - Help session timeout value.  0, if not specified.
    userHelpCreateBlob  - user specific help session create blob.
    tsSessionID         - Terminal Services Session ID or -1 if
                          undefined.  
    userSID             - User SID or "" if undefined.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::Initialize");

    WSADATA wsData;
    CComBSTR helpAccountName;
    CComBSTR helpSessionID;
    HANDLE tokenHandle;
    PTOKEN_USER tokenUser = NULL;
    HRESULT hr = S_OK;
    CComBSTR tmpBstr;
    LPTSTR sidStr;

    //
    //  Make a copy of connect parms.
    //
    m_ConnectParms = connectParms;

    //
    //  Get our session ID if one is not provided.
    //
    if (tsSessionID != -1) {
        m_SessionID = tsSessionID;
    }
    else {
        if (!ProcessIdToSessionId(GetCurrentProcessId(), &m_SessionID)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            TRC_ERR((TB, TEXT("Error fetching session ID:  %08X."),
                    GetLastError()));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  If we didn't get a SID, use our SID.
    //
    UINT len = SysStringByteLen(userSID);
    if (len == 0) {
        hr = FetchOurTokenUser(&tokenUser);
        if (hr != S_OK) {
            goto CLEANUPANDEXIT;
        }
        userSID = NULL;

        //
        //  Copy the user SID into a BSTR.
        //
        if (!ConvertSidToStringSid(tokenUser->User.Sid, &sidStr)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            TRC_ERR((TB, L"ConvertSidToStringSid:  %08X", hr));
            goto CLEANUPANDEXIT;
        }
        tmpBstr = sidStr;
    }

    //
    //  Give the parent class a chance to initialize.
    //
    hr = CRemoteDesktopSession::Initialize(
                                    connectParms, hostObject, 
                                    sharingClass,
                                    bEnableCallback,
                                    timeOut,
                                    userHelpCreateBlob,
                                    m_SessionID,
                                    (userSID != NULL) ? userSID : tmpBstr
                                    );
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

#if 0

    // WinSock is initialize as main(), we need to keep code here so
    // when we move from EXE to DLL, need to un-comment this 

    //
    //  Need to initialize winsock to get our host name.
    //
    if (WSAStartup(0x0101, &wsData) != 0) {
        TRC_ERR((TB, TEXT("WSAStartup:  %08X"), WSAGetLastError()));
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        goto CLEANUPANDEXIT;
    }
#endif

    //
    //  Instantiate the channel manager object and store in the parent
    //  class.
    //
    m_ChannelMgr = new CComObject<CTSRDPServerChannelMgr>();
    if (m_ChannelMgr == NULL) {
        TRC_ERR((TB, TEXT("Error instantiating channel manager.")));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUPANDEXIT;
    }
    m_ChannelMgr->AddRef();

    //
    //  Get the help account name.
    //
    hr = m_HelpSession->get_AssistantAccountName(&helpAccountName);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"get_AssistantAccountName:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the help session ID.
    //
    hr = m_HelpSession->get_HelpSessionId(&helpSessionID);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"get_HelpSessionId:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the channel mnager
    //
    hr = m_ChannelMgr->Initialize(this, helpSessionID);
    if (hr != S_OK) {
        goto CLEANUPANDEXIT;
    }
    

CLEANUPANDEXIT:

    if (tokenUser != NULL) {
        LocalFree(tokenUser);
    }

    SetValid(SUCCEEDED(hr));

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopSession::Disconnect()
/*++

Routine Description:

    Force a disconnect of the currently connected client,
    if one is connected.

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::Disconnect");

    if (m_ChannelMgr != NULL) {
        m_ChannelMgr->Disconnect();
    }

    DC_END_FN();

    return S_OK;
}

void 
CTSRDPRemoteDesktopSession::Shutdown()
/*++

Routine Description:

    Final Initialization

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::Shutdown");

    //
    //  Tell the channel manager to stop listening for data so it can
    //  shut down when its ref count goes to 0.  And, decrement its
    //  ref count.
    //
    if (m_ChannelMgr != NULL) {
        m_ChannelMgr->StopListening();
        m_ChannelMgr->Release();
        m_ChannelMgr = NULL;
    }

    DC_END_FN();
}

STDMETHODIMP 
CTSRDPRemoteDesktopSession::get_ConnectParms(
    OUT BSTR *parms
    )
/*++

Routine Description:

    Return parms that can be used to connect from the ActiveX client
    control.

Arguments:

    parms   -   Parms returned here.

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::get_ConnectParms");

    HRESULT hr = S_OK;

    //
    //  If we are not valid, fail.
    //
    if (!IsValid()) {
        hr = E_FAIL;
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    // Always get latest connect parm again, IP address might 
    // change

    hr = m_HelpSession->get_ConnectParms( parms );

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

VOID 
CTSRDPRemoteDesktopSession::GetSessionName(
    CComBSTR &name
    )
/*++

Routine Description:

    Return a string representation for the session.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::GetSessionName");

    WCHAR buf[256];

    ASSERT(IsValid());

    wsprintf(buf, L"TSRDP%ld", m_SessionID);
    name = buf;

    DC_END_FN();
}
VOID 
CTSRDPRemoteDesktopSession::GetSessionDescription(
    CComBSTR &descr
    )
{
    GetSessionName(descr);
}
    

HRESULT 
CTSRDPRemoteDesktopSession::FetchOurTokenUser(
    PTOKEN_USER *tokenUser
    )
/*++

Routine Description:

    Fetch our Token User struct.

Arguments:
    
    tokenUser   -   Returned token user for this thread.  Should
                    be freed using LocalFree.

Return Value:

    S_OK on success.  An error HRESULT otherwise.

 --*/
{
    HRESULT hr = S_OK;
    ULONG bufferLength;
    HANDLE tokenHandle = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::FetchOurTokenUser");

    *tokenUser = NULL;

    //
    //  Get our process token.
    //
    if (!OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_QUERY,
                    &tokenHandle
                    )) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"OpenThreadToken:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Fetch our Token User struct.
    //
    bufferLength = 0;
    GetTokenInformation(
                    tokenHandle,
                    TokenUser,
                    NULL,
                    0,
                    &bufferLength
                    );
    if (bufferLength == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"OpenThreadToken:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    *tokenUser = (PTOKEN_USER)LocalAlloc(LPTR, bufferLength);
    if (*tokenUser == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"LocalAlloc:  %08X", GetLastError()));
        goto CLEANUPANDEXIT;
    }

    if (!GetTokenInformation(
                    tokenHandle,
                    TokenUser,
                    *tokenUser,
                    bufferLength,
                    &bufferLength
                    )) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LocalFree(*tokenUser);
        *tokenUser = NULL;
    }

CLEANUPANDEXIT:

   if (tokenHandle != NULL) {
       CloseHandle(tokenHandle);
   }

   DC_END_FN();
   return hr;
}



HRESULT CTSRDPRemoteDesktopSession::StartListening()

/*++

Routine Description:

    Start listening
    Should be called everytime the client disconnects and everytime we open
    a remote desktop session
    This is because the named pipe would have been closed in the disconnect
    
Return Value:

    S_OK on success.  An error HRESULT otherwise.

 --*/

{

    DC_BEGIN_FN("CTSRDPRemoteDesktopSession::StartListening");
    HRESULT hr = E_FAIL;
    CComBSTR helpAccountName;

    //
    //  Tell the channel manager to start listening
    //
    if (m_ChannelMgr != NULL) {
        //
        //  Get the help account name.
        //
        hr = m_HelpSession->get_AssistantAccountName(&helpAccountName);
        if (!SUCCEEDED(hr)) {
            TRC_ERR((TB, L"get_AssistantAccountName:  %08X", hr));
            goto CLEANUPANDEXIT;
        }
        
        hr = m_ChannelMgr->StartListening(helpAccountName);
    }

    DC_END_FN();
CLEANUPANDEXIT:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\helper.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    Helper.h

Abstract:

    Funtion prototype.

Author:

    HueiWang    2/17/2000

--*/

#ifndef __HELPER_H__
#define __HELPER_H__
#include <windows.h>

#define MAX_ACCDESCRIPTION_LENGTH       256

#define MAX_HELPACCOUNT_NAME		256

#ifndef __WIN9XBUILD__

#define MAX_HELPACCOUNT_PASSWORD	LM20_PWLEN		// from lmcons.h

#else

// keep same max. password length same as NT
#define MAX_HELPACCOUNT_PASSWORD	14

#endif




typedef HRESULT (WINAPI* RegEnumKeyCallback)(
                                    IN HKEY hKey,
                                    IN LPTSTR pszKeyName,
                                    IN HANDLE userData
                                );



#ifndef __WIN9XBUILD__
#include <ntsecapi.h>
#endif


#ifdef __cplusplus
extern "C"{
#endif

    DWORD
    GenerateRandomString(
        IN DWORD dwSizeRandomSeed,
        IN OUT LPTSTR* pszRandomString
    );

    DWORD
    GenerateRandomBytes(
        IN DWORD dwSize,
        IN OUT LPBYTE pbBuffer
    );

    void
    UnixTimeToFileTime(
        time_t t,
        LPFILETIME pft
    );


    long
    GetUserTSLogonId();

    //
    // create a random password, buffer must 
    // be at least MAX_HELPACCOUNT_PASSWORD+1
    DWORD
    CreatePassword(
        TCHAR   *pszPassword
    );


    DWORD
    RegEnumSubKeys(
        IN HKEY hKey,
        IN LPCTSTR pszSubKey,
        IN RegEnumKeyCallback pFunc,
        IN HANDLE userData
    );

    DWORD
    RegDelKey(
        IN HKEY hRegKey,
        IN LPCTSTR pszSubKey
    );

    DWORD
    GetUserSid(
        PBYTE* ppbSid,
        DWORD* pcbSid
    );

    HRESULT
    GetUserSidString(
        OUT CComBSTR& bstrSid
    );


#ifndef __WIN9XBUILD__

    BOOL
    MyMkTime(
        IN SYSTEMTIME* pSysTime,
        OUT FILETIME* pft
    );
    
    BOOL
    IsPersonalOrProMachine();


    // 
    // Check if a user is in a local group
    //
    DWORD
    IsUserInLocalGroup(
        IN PBYTE pbUserSid,
        IN LPCTSTR pszLocalGroup,
        OUT BOOL* pbInGroup
    );

    //
    // Create a local account
    //
    DWORD
    CreateLocalAccount(
        IN LPWSTR pszUserName,
        IN LPWSTR pszUserPwd,
        IN LPWSTR pszUserFullName,
        IN LPWSTR pszUserDesc,
        IN LPWSTR pszGroupName,
        IN LPWSTR pszScript,
        OUT BOOL* pbAccountExists
    );

    //
    // Check if a user account is enabled.
    //
    DWORD
    IsLocalAccountEnabled(
        IN LPWSTR pszUserName,
        IN BOOL* pEnabled
    );

    //
    // Rename local account
    //
    DWORD
    RenameLocalAccount(
        IN LPWSTR pszOrgName,
        IN LPWSTR pszNewName
    );

    DWORD
    UpdateLocalAccountFullnameAndDesc(
        IN LPWSTR pszAccOrgName,
        IN LPWSTR pszAccFullName,
        IN LPWSTR pszAccDesc
    );

    //
    // Enable/disable a user account
    //
    DWORD
    EnableLocalAccount(
        IN LPWSTR pszUserName,
        IN BOOL bEnable
    );

    //
    // Change local account password
    //
    DWORD
    ChangeLocalAccountPassword(
        IN LPWSTR pszUserName,
        IN LPWSTR pszOldPwd,
        IN LPWSTR pszNewPwd
    );
    
    //
    // Check if a specific group exist
    // on local machine.
    //
    BOOL
    IsLocalGroupExists(
        IN LPWSTR pszGroupName
    );

    //
    // Create a local group
    //
    DWORD
    CreateLocalGroup(
        IN LPWSTR pszGroupName,
        IN LPWSTR pszGroupDesc,
        IN BOOL bAddEveryone
    );

    //
    // Validate a user password
    //
    BOOL 
    ValidatePassword(
        IN LPWSTR UserName,
        IN LPWSTR Domain,
        IN LPWSTR Password
    );

    //
    // Retrieve private data saved to LSA
    //
    DWORD
    RetrieveKeyFromLSA(
	    PWCHAR pwszKeyName,
	    PBYTE * ppbKey,
        DWORD * pcbKey 
    );

    //
    // Save private data to LSA
    //
    DWORD
    StoreKeyWithLSA(
	    PWCHAR  pwszKeyName,
        BYTE *  pbKey,
        DWORD   cbKey 
    );
    
    //
    // Open LSA policy
    //
    DWORD
    OpenPolicy( 
	    LPWSTR ServerName,
	    DWORD  DesiredAccess,
	    PLSA_HANDLE PolicyHandle 
    );

    //
    // Initialize LSA string
    //
    void
    InitLsaString(  
	    PLSA_UNICODE_STRING LsaString,
        LPWSTR String 
    );



#ifdef DBG

    void
    DebugPrintf(
        IN LPCTSTR format, ...
    );

#else

    #define DebugPrintf

#endif //PRIVATE_DEBUG  


    //
    // Convert a user SID to string form
    //
    BOOL 
    GetTextualSid(
        IN PSID pSid,
        IN OUT LPTSTR TextualSid,
        IN OUT LPDWORD lpdwBufferLen
    );

    DWORD 
    IsUserAdmin(
        BOOL* bMember
    );


    BOOL
    LookupAliasFromRid(
        LPWSTR pTargetComputer,
        DWORD Rid,
        LPWSTR pName,
        PDWORD cchName
    );

#else

    #define DebugPrintf

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\helpacc.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpAcc.cpp

Abstract:

    Implementation of __HelpAssistantAccount to manage Help Assistant account, this
    including creating account, setting various account rights and password.

Author:

    HueiWang    06/29/2000

--*/
#include "stdafx.h"

#include "helpacc.h"
#include "resource.h"
#include "policy.h"

#include "cfgbkend.h"
#include "cfgbkend_i.c"
#include "helper.h"


//
// Help account lock
CCriticalSection __HelpAssistantAccount::gm_HelpAccountCS;    

// Help Account name and pasword
CComBSTR __HelpAssistantAccount::gm_bstrHelpAccountPwd;
CComBSTR __HelpAssistantAccount::gm_bstrHelpAccountName(HELPASSISTANTACCOUNT_NAME);

// Help Account SID
PBYTE __HelpAssistantAccount::gm_pbHelpAccountSid = NULL;
DWORD __HelpAssistantAccount::gm_cbHelpAccountSid = 0;
DWORD __HelpAssistantAccount::gm_dwAccErrCode = ERROR_INVALID_DATA;


///////////////////////////////////////////////////////////////////////////
//
//
//

DWORD
GetGUIDString(
    OUT LPTSTR* pszString
    )
/*++

--*/
{
    UUID uuid;
    RPC_STATUS rpcStatus;
    LPTSTR pszUuid = NULL;

    rpcStatus = UuidCreate( &uuid );
    if( rpcStatus != RPC_S_OK && 
        rpcStatus != RPC_S_UUID_LOCAL_ONLY && 
        rpcStatus != RPC_S_UUID_NO_ADDRESS )
    {
        goto CLEANUPANDEXIT;
    }
    
    rpcStatus = UuidToString( &uuid, &pszUuid );
    if( RPC_S_OK == rpcStatus )
    {
        *pszString = (LPTSTR)LocalAlloc( LPTR, (lstrlen(pszUuid)+1)*sizeof(TCHAR));
        if( NULL == *pszString )
        {
            rpcStatus = GetLastError();
        }
        else
        {
            lstrcpy( *pszString, pszUuid );
        }
    }

CLEANUPANDEXIT:

    if( NULL != pszUuid )
    {
        RpcStringFree(&pszUuid);
    }

    return rpcStatus;
}

DWORD
GenerateUniqueHelpAssistantName(
    IN LPCTSTR pszAccNamePrefix,
    OUT CComBSTR& bstrAccName
    )
/*++


--*/
{
    DWORD dwStatus;
    LPTSTR pszString;

    dwStatus = GetGUIDString( &pszString );

    if( ERROR_SUCCESS == dwStatus )
    {
        DWORD dwLen;
        DWORD dwAppendStrLen;
        LPTSTR pszAppendStr;

        // MAX user account name is 20 chars.
        bstrAccName = pszAccNamePrefix;
        bstrAccName += L"_";
        dwLen = bstrAccName.Length();
        dwAppendStrLen = lstrlen(pszString);

        if( dwAppendStrLen < MAX_USERNAME_LENGTH - dwLen )
        {
            pszAppendStr = pszString;
        }
        else
        {
            pszAppendStr = pszString + dwAppendStrLen - (MAX_USERNAME_LENGTH - dwLen);
        }

        bstrAccName += pszAppendStr;
    }

    return dwStatus;
}


HRESULT
__HelpAssistantAccount::SetupHelpAccountTSSettings()
/*++

Routine Description:

    Setup bunch of HelpAssistant account TS settings.

Parameters:

    None

Returns:

    ERROR_SUCCESS or error code

--*/
{
    CComBSTR bstrScript;
    DWORD dwStatus;
    PBYTE pbAlreadySetup = NULL;
    DWORD cbAlreadySetup = 0;
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(gm_HelpAccountCS);

    dwStatus = RetrieveKeyFromLSA(
                                HELPACCOUNTPROPERLYSETUP,
                                (PBYTE *)&pbAlreadySetup,
                                &cbAlreadySetup
                            );

    if( ERROR_SUCCESS != dwStatus )
    {
        hRes = GetHelpAccountScript( bstrScript );
        if( SUCCEEDED(hRes) )
        {
            // always config again.
            hRes = ConfigHelpAccountTSSettings( 
                                            gm_bstrHelpAccountName, 
                                            bstrScript
                                        );

            if( SUCCEEDED(hRes) )
            {
                dwStatus = StoreKeyWithLSA(
                                        HELPACCOUNTPROPERLYSETUP,
                                        (PBYTE) &dwStatus,
                                        sizeof(dwStatus)
                                    );          

                if( ERROR_SUCCESS != dwStatus )
                {
                    hRes = HRESULT_FROM_WIN32(hRes);
                }
            }
        }                 
    }

    if( NULL != pbAlreadySetup )
    {
        LocalFree( pbAlreadySetup );
    }

    return hRes;
}



HRESULT
__HelpAssistantAccount::LookupHelpAccountSid(
    IN LPTSTR pszAccName,
    OUT PSID* ppSid,
    OUT DWORD* pcbSid
    )
/*++

Routine Description:

    This routine retrieve help assistant account's SID.

Parameters:

    pszAccName : Name of Help Assistant Account.
    ppSid : Pointer to PSID to receive account SID.
    cbSid : Size of SID return on ppSid

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD cbSid = 0;
    DWORD cbDomainName = 0;
    PSID pAccSid = NULL;
    LPTSTR pszDomainName = NULL;
    BOOL bSuccess;
    SID_NAME_USE SidUse;


    // Get buffer size required for SID
    bSuccess = LookupAccountName( 
                            NULL,
                            pszAccName,
                            NULL,
                            &cbSid,
                            NULL,
                            &cbDomainName,
                            &SidUse
                        );
    
    if( TRUE == bSuccess ||
        ERROR_INSUFFICIENT_BUFFER == GetLastError() )
    {
        pAccSid = (PSID)LocalAlloc( LPTR, cbSid );
        if( NULL == pAccSid )
        {
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }

        // allocate buffer for domain name so LookupAccountName()
        // does not return insufficient buffer
        pszDomainName = (LPTSTR)LocalAlloc( LPTR, (cbDomainName + 1) * sizeof(TCHAR) );
        if( NULL == pszDomainName )
        {
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }

        bSuccess = LookupAccountName( 
                                NULL,
                                pszAccName,
                                pAccSid,
                                &cbSid,
                                pszDomainName,
                                &cbDomainName,
                                &SidUse
                            );
    
        if( FALSE == bSuccess || SidTypeUser != SidUse )
        {
            //MYASSERT(FALSE);
            dwStatus = E_UNEXPECTED;
            goto CLEANUPANDEXIT;
        }

        // Make sure we gets valid SID
        bSuccess = IsValidSid( pAccSid );

        if( FALSE == bSuccess )
        {
            dwStatus = E_UNEXPECTED;
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

CLEANUPANDEXIT:

    if( dwStatus == ERROR_SUCCESS )
    {
        *ppSid = pAccSid;
        *pcbSid = cbSid;
    }
    else 
    {
        if( NULL != pAccSid )
        {
            LocalFree( pAccSid );
        }
    }

    if( NULL != pszDomainName )
    {
        LocalFree( pszDomainName );
    }

    return HRESULT_FROM_WIN32(dwStatus);
}



HRESULT
__HelpAssistantAccount::CacheHelpAccountSID()
/*++

Routine Description:

    This routine retrieve help assistant account's SID and store
    it with LSA, this is so that PTS can verify login user is
    the actual Salem Help Assistant Account.

Parameters:

    None.

Returns:

    S_OK

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD cbSid = 0;
    PSID pAccSid = NULL;


    dwStatus = LookupHelpAccountSid(
                            gm_bstrHelpAccountName,
                            &pAccSid,
                            &cbSid
                        );

    if( ERROR_SUCCESS == dwStatus )
    {
        // Store this with LSA
        dwStatus = StoreKeyWithLSA(
                                HELPASSISTANTACCOUNT_SIDKEY,
                                (PBYTE)pAccSid,
                                cbSid
                            );

    }

    if( NULL != pAccSid )
    {
        LocalFree( pAccSid );
    }

    return HRESULT_FROM_WIN32(dwStatus);
}



HRESULT
__HelpAssistantAccount::GetHelpAccountScript(
    OUT CComBSTR& bstrScript
    )
/*++

Routine Description:

    Routine to retrieve logon script for help assistant account.

Parameters:

    bstrScript : Reference to CComBSTR, on return, this parameter contains
                 full path to the logon script.

Returns:

    ERROR_SUCCESS or error code from GetSystemDirectory

NOTE:

    TODO - Need to get the actual path/name.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TCHAR szScript[MAX_PATH + 1];

    dwStatus = (DWORD)GetSystemDirectory( szScript, MAX_PATH );
    if( 0 == dwStatus )
    {
        //MYASSERT(FALSE);
        dwStatus = GetLastError();
    }
    else
    {
        bstrScript = szScript;
        bstrScript += _TEXT("\\");
        bstrScript += RDSADDINEXECNAME;
        dwStatus = ERROR_SUCCESS;
    }

    return HRESULT_FROM_WIN32(dwStatus);
}



HRESULT
__HelpAssistantAccount::Initialize(
    BOOL bVerifyPassword /* = TRUE */
    )
/*++

Routine Description:

    Initialize HelpAssistantAccount structure global variables.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;
    LPTSTR pszOldPassword = NULL;
    DWORD cbOldPassword = 0;
    DWORD dwStatus;
    BOOL bStatus;
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD cbComputerName = MAX_COMPUTERNAME_LENGTH+1;

    PSID pCachedHelpAccSid = NULL;
    DWORD cbCachedHelpAccSid = 0;

    BOOL bAccountEnable = TRUE;
    LPTSTR rights[1];

    LPTSTR pszHelpAcctName = NULL;
    LPTSTR pszHelpAcctDomainName = NULL;


    CCriticalSectionLocker l(gm_HelpAccountCS);

    if( FALSE == GetComputerName( szComputerName, &cbComputerName ) )
    {
        //MYASSERT(FALSE);
        gm_dwAccErrCode = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    // Load password from LSA
    //
    dwStatus = RetrieveKeyFromLSA(
                            HELPASSISTANTACCOUNT_PASSWORDKEY,
                            (PBYTE *)&pszOldPassword,
                            &cbOldPassword
                        );

    if( ERROR_SUCCESS != dwStatus )
    {
        //
        // Account is not properly setup
        gm_dwAccErrCode = dwStatus;
        goto CLEANUPANDEXIT;
    }

    // Load account SID
    dwStatus = RetrieveKeyFromLSA(
                            HELPASSISTANTACCOUNT_SIDKEY,
                            (PBYTE *)&pCachedHelpAccSid,
                            &cbCachedHelpAccSid
                        );

    if( ERROR_SUCCESS != dwStatus )
    {
        gm_dwAccErrCode = dwStatus;
        goto CLEANUPANDEXIT;
    }

    dwStatus = TSGetHelpAssistantAccountName( &pszHelpAcctDomainName, &pszHelpAcctName );
    if( ERROR_SUCCESS != dwStatus )
    {
        gm_dwAccErrCode = dwStatus;
        goto CLEANUPANDEXIT;
    }

    gm_bstrHelpAccountName = pszHelpAcctName;

    DebugPrintf(
            _TEXT("HelpAssistant account name : %s\n"), 
            gm_bstrHelpAccountName
        );

    //
    // Check if account is enable, if not enable it or
    // LogonUser() will failed with error 1331
    //
    dwStatus = IsLocalAccountEnabled(
                                gm_bstrHelpAccountName,
                                &bAccountEnable
                            );

    if( ERROR_SUCCESS != dwStatus )
    {
        // critical error, account might not exist.
        gm_dwAccErrCode = ERROR_INVALID_DATA;
        goto CLEANUPANDEXIT;
    }

    //
    // Everything is OK, cache values.
    //
    gm_bstrHelpAccountPwd = pszOldPassword;
    gm_pbHelpAccountSid = (PBYTE)pCachedHelpAccSid;
    gm_cbHelpAccountSid = cbCachedHelpAccSid;
    pCachedHelpAccSid = NULL;

    //
    // Setup/upgrade on DC will try to validate password but
    // since account on DC goes to ADS, server might not be
    // available, we will reset password on start up so we don't
    // need to validate password on upgrade.
    //
    if( TRUE == bVerifyPassword )
    {
        if( FALSE == bAccountEnable )
        {
            // enable the account so we can check password
            dwStatus = EnableHelpAssistantAccount( TRUE );

            if( ERROR_SUCCESS != dwStatus )
            {
                //
                // Can't enable the account, critical error
                //
                gm_dwAccErrCode = dwStatus;
                goto CLEANUPANDEXIT;
            }
        }
        
        rights[0] = SE_NETWORK_LOGON_NAME;

        //
        // Enable network logon rights to validate password
        //
        dwStatus = EnableAccountRights( 
                                    TRUE,
                                    1,
                                    rights
                                );

        if( ERROR_SUCCESS != dwStatus )
        {
            DebugPrintf(
                    _TEXT("EnableAccountRights() returns 0x%08x\n"),
                    dwStatus
                );

            gm_dwAccErrCode = dwStatus;

            //
            // Error code path, restore account status
            //
            if( FALSE == bAccountEnable )
            {
                // non-critical error.
                EnableHelpAssistantAccount( bAccountEnable );
            }

            goto CLEANUPANDEXIT;
        }        

        // valid password
        bStatus = ValidatePassword(
                                gm_bstrHelpAccountName,
                                L".", 
                                pszOldPassword
                            );

    
        if( FALSE == bStatus )
        {
            // mismatch password, force password change
            dwStatus = ChangeLocalAccountPassword(
                                    gm_bstrHelpAccountName,
                                    pszOldPassword,
                                    pszOldPassword
                                );

            DebugPrintf(
                    _TEXT("ChangeLocalAccountPassword() returns %d\n"),
                    dwStatus
                );

            if( ERROR_SUCCESS != dwStatus )
            {
                gm_dwAccErrCode = ERROR_LOGON_FAILURE;
            }
            else
            {
                bStatus = ValidatePassword( 
                                        gm_bstrHelpAccountName, 
                                        L".", 
                                        pszOldPassword 
                                    );

            }
        }

        //
        // Disable network interactive rights
        //
        dwStatus = EnableAccountRights( 
                                    FALSE,
                                    1,
                                    rights
                                );

        MYASSERT( ERROR_SUCCESS == dwStatus );


        //
        // Restore account status
        //
        if( FALSE == bAccountEnable )
        {
            // non-critical error.
            EnableHelpAssistantAccount( bAccountEnable );
        }
    }
    
    //
    // No checking on dwStatus from disabling account rights,
    // security risk but not affecting our operation
    //
    gm_dwAccErrCode = dwStatus;    

CLEANUPANDEXIT:

    FreeMemory(pszHelpAcctDomainName);
    FreeMemory(pszHelpAcctName);
    FreeMemory( pszOldPassword );
    FreeMemory( pCachedHelpAccSid );

    return HRESULT_FROM_WIN32( gm_dwAccErrCode );
}



HRESULT
__HelpAssistantAccount::DeleteHelpAccount()
/*++

Routine Description:

    Delete Help Assistant Account.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus;
    BOOL bStatus;
    BOOL bEnable;

    CCriticalSectionLocker l(gm_HelpAccountCS);

    if( ERROR_SUCCESS == IsLocalAccountEnabled(gm_bstrHelpAccountName, &bEnable) )
    {
        //
        // remove all TS rights or it will shows up 
        // as unknown SID string on TSCC permission page
        //
        SetupHelpAccountTSRights(
                        TRUE,
                        FALSE,
                        FALSE,
                        WINSTATION_ALL_ACCESS
                    );
        // don't need to verify password
        (void) Initialize(FALSE);

        // Always delete interactive right or there will
        // be lots of entries in local security 
        (void) EnableRemoteInteractiveRight(FALSE);
    }


    //
    // Delete NT account
    //
    dwStatus = NetUserDel( 
                        NULL, 
                        gm_bstrHelpAccountName 
                    );

    if( ERROR_ACCESS_DENIED == dwStatus )
    {
        // We don't have priviledge, probably can't
        // touch accunt, get out.
        // MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    dwStatus = ERROR_SUCCESS;

    // 
    // Overwrite password stored with LSA
    //
    StoreKeyWithLSA(
                HELPASSISTANTACCOUNT_PASSWORDKEY,
                NULL,
                0
            );

    //
    // Overwrite Help Assistant Account SID store in LSA
    //
    StoreKeyWithLSA(
                HELPASSISTANTACCOUNT_SIDKEY,
                NULL,
                0
            );

    // Not yet setup Help Assistant account
    StoreKeyWithLSA(
                HELPACCOUNTPROPERLYSETUP,
                NULL,
                0
            );
                

CLEANUPANDEXIT:          
    
    return HRESULT_FROM_WIN32(dwStatus);
}

    

HRESULT
__HelpAssistantAccount::CreateHelpAccount(
    IN LPCTSTR pszPassword
    )
/*++

Routine Description:

    Create Help Assistant Account.

Parameters:

    pszPassword : Suggested password.

Returns:

    S_OK or error code.

Note:

    1) Routine should only be invoked during setup.
    2) Password parameter might not be honor in future so
       it is only a suggestion.

--*/
{
    HRESULT hRes = S_OK;
    BOOL bStatus;
    DWORD dwStatus;
    CComBSTR AccFullName;
    CComBSTR AccDesc;
    CComBSTR AccName;

    CComBSTR bstrNewHelpAccName;

    TCHAR newAssistantAccountPwd[MAX_HELPACCOUNT_PASSWORD + 1];
    CComBSTR bstrScript;
    BOOL bPersonalOrProMachine;

    CCriticalSectionLocker l(gm_HelpAccountCS);

    bStatus = AccName.LoadString(IDS_HELPACCNAME);
    if( FALSE == bStatus )
    {
        hRes = E_UNEXPECTED;
        return hRes;
    }

    bStatus = AccFullName.LoadString(
                                    IDS_HELPACCFULLNAME
                                );
    if( FALSE == bStatus )
    {
        hRes = E_UNEXPECTED;
        return hRes;
    }

    bStatus = AccDesc.LoadString(
                                IDS_HELPACCDESC
                            );
    if( FALSE == bStatus )
    {
        hRes = E_UNEXPECTED;
        return hRes;
    }

    bPersonalOrProMachine = IsPersonalOrProMachine();


    //
    // Verify help assistant account exist and don't check
    // password, on service startup, we will verify password
    // if mismatch, service startup will reset the password.
    //
    hRes = Initialize( FALSE );

    if( SUCCEEDED(hRes) )
    {
        // Account already exists, check if this is the hardcoded HelpAssistant,
        // if so, rename to whatever in resource, we only need to rename
        // account if 
        // 1) existing account is HelpAssistant - administrator has not rename it.
        // 2) account name in resource is not HelpAssistant.
        // 3) We are running on server or above SKU.
        if( (FALSE == bPersonalOrProMachine) ||
            (gm_bstrHelpAccountName == HELPASSISTANTACCOUNT_NAME &&
             AccName != HELPASSISTANTACCOUNT_NAME) )
        {
            if( FALSE == bPersonalOrProMachine )
            {
                // on server or above SKU, we rename it to unique name.
                dwStatus = GenerateUniqueHelpAssistantName( AccName, bstrNewHelpAccName );
            }
            else
            {
                dwStatus = ERROR_SUCCESS;
                bstrNewHelpAccName = AccName;
            }

            if( ERROR_SUCCESS == dwStatus )
            {
                dwStatus = RenameLocalAccount( gm_bstrHelpAccountName, bstrNewHelpAccName );
            }

            if( ERROR_SUCCESS == dwStatus )
            {
                // cache the new help assistant account name.
                gm_bstrHelpAccountName = bstrNewHelpAccName;
            }
            else 
            {
                // force a delete and reload.
                hRes = HRESULT_FROM_WIN32( dwStatus );
            }
        }

        //
        // Account already exist, change the description,
        // if failed, force delete and re-create account again
        //
        if( SUCCEEDED(hRes) )
        {
            //
            // Update account description
            //
            dwStatus = UpdateLocalAccountFullnameAndDesc(
                                            gm_bstrHelpAccountName,
                                            AccFullName,
                                            AccDesc
                                        );

            if( ERROR_SUCCESS != dwStatus )
            {
                hRes = HRESULT_FROM_WIN32(dwStatus);
            }
        }
    }
    
    if( FAILED(hRes) )
    {
        //
        // Either password mismatch or account not exists,...
        // delete account and re-create one
        //
        (void)DeleteHelpAccount();

        // generate password if NULL or zero length string
        if( NULL == pszPassword || 0 == lstrlen(pszPassword) )
        {
            dwStatus = CreatePassword(newAssistantAccountPwd);

            if( ERROR_SUCCESS != dwStatus )
            {
                hRes = HRESULT_FROM_WIN32(dwStatus);
                goto CLEANUPANDEXIT;
            }
        }
        else
        {
            memset( 
                    newAssistantAccountPwd, 
                    0, 
                    sizeof(newAssistantAccountPwd) 
                );

            _tcsncpy( 
                    newAssistantAccountPwd, 
                    pszPassword, 
                    min(lstrlen(pszPassword), MAX_HELPACCOUNT_PASSWORD) 
                );
        }

        hRes = GetHelpAccountScript( bstrScript );
        if( FAILED(hRes) )
        {
            goto CLEANUPANDEXIT;
        }

        //
        // On personal or pro machine, we use what's in resorce.
        // server or advance server, we use HelpAssist_<Random string>
        //
        if( FALSE == bPersonalOrProMachine )
        {
            dwStatus = GenerateUniqueHelpAssistantName(
                                                AccName,
                                                gm_bstrHelpAccountName
                                            );
            if( ERROR_SUCCESS != dwStatus )
            {
                hRes = HRESULT_FROM_WIN32(dwStatus);
                goto CLEANUPANDEXIT;
            }
        }
        else
        {
            gm_bstrHelpAccountName = AccName;
        }

        if( SUCCEEDED(hRes) )
        {
            BOOL bAccExist;

            //
            // Create local account will enables it if account is disabled
            //
            dwStatus = CreateLocalAccount(
                                    gm_bstrHelpAccountName,
                                    newAssistantAccountPwd,
                                    AccFullName,
                                    AccDesc,
                                    NULL, 
                                    bstrScript,
                                    &bAccExist
                                );

            if( ERROR_SUCCESS == dwStatus )
            {
                if( FALSE == bAccExist )
                {
                    DebugPrintf( _TEXT("%s account is new\n"), gm_bstrHelpAccountName );
                    //
                    // Store the actual Help Assistant Account's SID with LSA 
                    // so TermSrv can verify this SID
                    //
                    hRes = CacheHelpAccountSID();
                }
                else
                {
                    DebugPrintf( _TEXT("%s account exists\n") );

                    hRes = ResetHelpAccountPassword(newAssistantAccountPwd);
                }

                if( SUCCEEDED(hRes) )
                {
                    dwStatus = StoreKeyWithLSA(
                                        HELPASSISTANTACCOUNT_PASSWORDKEY,
                                        (PBYTE)newAssistantAccountPwd,
                                        sizeof(newAssistantAccountPwd)
                                    );

                    hRes = HRESULT_FROM_WIN32( dwStatus );
                }

                if( SUCCEEDED(hRes) )
                {
                    // reload global variable here, don't need to
                    // verify password, DC ADS might not be available.
                    hRes = Initialize( FALSE );
                }

                //
                // TODO - need to fix CreateLocalAccount() on SRV SKU
                // too riskly for client release.
                //
                UpdateLocalAccountFullnameAndDesc(
                                            gm_bstrHelpAccountName,
                                            AccFullName,
                                            AccDesc
                                        );
            }
            else
            {
                hRes = HRESULT_FROM_WIN32( dwStatus );
            }
        }
    }

    if( SUCCEEDED(hRes) )
    {
        // remove network and interactive logon rights from account.
        LPTSTR rights[1];
        DWORD dwStatus;

        rights[0] = SE_NETWORK_LOGON_NAME;
        dwStatus = EnableAccountRights( FALSE, 1, rights );        


        //
        // Just for backward compatible, ignore error
        //
        
        rights[0] = SE_INTERACTIVE_LOGON_NAME;
        dwStatus = EnableAccountRights( FALSE, 1, rights );

        //
        // Just for backward compatible, ignore error
        //
        hRes = S_OK;
    }

    if( SUCCEEDED(hRes) )
    {
        //
        // TS setup always overwrite default security on upgrade.
        //

        //
        // Give user all rights except SeRemoteInterativeRights, Whilster does
        // not use WINSTATION_CONNECT any more.
        hRes = SetupHelpAccountTSRights(
                                    FALSE,  // Not deleting, refer to ModifyUserAccess()
                                    TRUE,   // enable TS rights
                                    TRUE,   // delete existing entry if exist.
                                    WINSTATION_ALL_ACCESS // (WINSTATION_ALL_ACCESS) & ~(WINSTATION_CONNECT | WINSTATION_SET | WINSTATION_RESET)
                                );
    }

CLEANUPANDEXIT:

    return hRes;
}


HRESULT
__HelpAssistantAccount::ConfigHelpAccountTSSettings(
    IN LPTSTR pszUserName,
    IN LPTSTR pszInitProgram
    )
/*++

Routine Description:

    This routine configurate TS specific settings
    for user account.

Parameters:

    pszUserName : Name of user account to configurate.
    pszInitProgram : Full path to init. program when user
                     login.

Returns:

    ERROR_SUCCESS or error code

--*/
{
    BOOL bStatus;
    HRESULT hRes = S_OK;
    HMODULE hWtsapi32 = NULL;
    PWTSSetUserConfigW pConfig = NULL;
    BOOL bManualSetConsole = TRUE;
    BOOL bEnable;
    DWORD dwStatus;

    //DebugPrintf( _TEXT("SetupHelpAccountTSSettings...\n") );

    CCriticalSectionLocker l(gm_HelpAccountCS);

    dwStatus = IsLocalAccountEnabled( 
                                pszUserName, 
                                &bEnable 
                            );

    if( ERROR_SUCCESS != dwStatus )
    {
        //MYASSERT(FALSE);
        hRes = HRESULT_FROM_WIN32( dwStatus );
        return hRes;
    }

    hWtsapi32 = LoadLibrary( _TEXT("wtsapi32.dll") );
    if( NULL != hWtsapi32 )
    {
        pConfig = (PWTSSetUserConfigW)GetProcAddress( 
                                                hWtsapi32, 
                                                "WTSSetUserConfigW" 
                                            );

        if( NULL != pConfig )
        {
            DWORD dwSettings;

            //
            // Set WTSUserConfigfAllowLogonTerminalServer
            //
            dwSettings = TRUE;
            bStatus = (pConfig)( 
                                NULL,
                                pszUserName,
                                WTSUserConfigfAllowLogonTerminalServer,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

            if( FALSE == bStatus )
            {
                bStatus = TRUE;
            }

            // MYASSERT( TRUE == bStatus );

            if( TRUE == bStatus )
            {
                //
                // Ignore all error and continue on setting values
                // catch error at the calling routine
                //

                dwSettings = TRUE;

                // Reset connection when connection broken
                bStatus = (pConfig)( 
                                    NULL,
                                    pszUserName,
                                    WTSUserConfigBrokenTimeoutSettings,
                                    (LPWSTR)&dwSettings,
                                    sizeof(dwSettings)
                                );

                dwSettings = FALSE;

                // initial program
                bStatus = (pConfig)(        
                                NULL,
                                pszUserName,
                                WTSUserConfigfInheritInitialProgram,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

                dwSettings = FALSE;

                // No re-connect.
                bStatus = (pConfig)(        
                                NULL,
                                pszUserName,
                                WTSUserConfigReconnectSettings,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

                dwSettings = FALSE;

                // No drive mapping
                bStatus = (pConfig)(        
                                NULL,
                                pszUserName,
                                WTSUserConfigfDeviceClientDrives,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

                dwSettings = FALSE;

                // No printer.
                bStatus = (pConfig)(        
                                NULL,
                                pszUserName,
                                WTSUserConfigfDeviceClientPrinters,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

                dwSettings = FALSE;

                // No defaultPrinter
                bStatus = (pConfig)(        
                                NULL,
                                pszUserName,
                                WTSUserConfigfDeviceClientDefaultPrinter,
                                (LPWSTR)&dwSettings,
                                sizeof(dwSettings)
                            );

                bStatus = (pConfig)(
                                NULL,
                                pszUserName,
                                WTSUserConfigInitialProgram,
                                pszInitProgram,
                                wcslen(pszInitProgram)
                            );

                TCHAR path_buffer[MAX_PATH+1];
                TCHAR drive[_MAX_DRIVE + 1];
                TCHAR dir[_MAX_DIR + 1];

                memset( path_buffer, 0, sizeof(path_buffer) );

                _tsplitpath( pszInitProgram, drive, dir, NULL, NULL );
                wsprintf( path_buffer, L"%s%s", drive, dir );
            
                bStatus = (pConfig)(
                                NULL,
                                pszUserName,
                                WTSUserConfigWorkingDirectory,
                                path_buffer,
                                wcslen(path_buffer)
                            );
            }

            if( FALSE == bStatus )
            {
                hRes = HRESULT_FROM_WIN32( GetLastError() );
            }

        } // end (pConfig != NULL)
    }

    if( NULL != hWtsapi32 )
    {
        FreeLibrary( hWtsapi32 );
    }

    //DebugPrintf( _TEXT("SetupHelpAccountTSSettings() ended...\n") ); 

    return hRes;
}


HRESULT
__HelpAssistantAccount::SetupHelpAccountTSRights(
    IN BOOL bDel,
    IN BOOL bEnable,
    IN BOOL bDeleteExisting,
    IN DWORD dwPermissions
    )
/*++

Routine Description:

    This routine configurate TS specific settings
    for user account.

Parameters:

    pszUserName : Name of user account to configurate.
    bDel : TRUE to delete account, FALSE otherwise.
    bEnable : TRUE if enable, FALSE otherwise.
    dwPermissions : Permission to be enable or disable

Returns:

    ERROR_SUCCESS or error code

Note:

    Refer to cfgbkend.idl for bDel and bEnable parameter.

--*/
{
    BOOL bStatus;
    HRESULT hRes = S_OK;
    CComPtr<ICfgComp> tsccICfgComp;
    IUserSecurity* tsccIUserSecurity = NULL;
    DWORD dwNumWinStations = 0;
    DWORD dwWinStationSize = 0;
    PWS pWinStationList = NULL;
    DWORD index;
    DWORD dwCfgStatus = ERROR_SUCCESS;
    BOOL bManualSetConsole = TRUE;
    ULONG cbSecDescLen;

    CCriticalSectionLocker l(gm_HelpAccountCS);

    CoInitialize(NULL);

    //hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    hRes = tsccICfgComp.CoCreateInstance( CLSID_CfgComp );
    if( FAILED(hRes) )
    {
        DebugPrintf( _TEXT("CoCreateInstance() failed with error code 0x%08x\n"), hRes );

        //MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    } 

    hRes = tsccICfgComp->Initialize();
    if( FAILED(hRes) )
    {
        DebugPrintf( _TEXT("tsccICfgComp->Initialize() failed with error code 0x%08x\n"), hRes );

        // MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    } 
    
    hRes = tsccICfgComp->QueryInterface( 
                                    IID_IUserSecurity, 
                                    reinterpret_cast<void **>(&tsccIUserSecurity) 
                                );

    if( FAILED(hRes) || NULL == tsccIUserSecurity)
    {
        DebugPrintf( _TEXT("QueryInterface() failed with error code 0x%08x\n"), hRes );

        // MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    //
    // Setting Default security shadow permission
    //
    hRes = tsccIUserSecurity->ModifyDefaultSecurity(
                                            L"",
                                            gm_bstrHelpAccountName,
                                            dwPermissions, 
                                            bDel, 
                                            bEnable,
                                            FALSE,
                                            &dwCfgStatus
                                        );

    if( FAILED(hRes) || ERROR_SUCCESS != dwCfgStatus )
    {
        DebugPrintf(
                _TEXT("ModifyDefaultSecurity on default security return 0x%08x, dwCfgStatus = %d\n"),
                hRes,    
                dwCfgStatus
            );
       
        // MYASSERT(FALSE);

        //
        // Continue on to setting wtsapi32, we still can 
        // RDS on non-console winstation
        //
        hRes = S_OK;
        dwCfgStatus = ERROR_SUCCESS;
    }

    // retrieve a list of winstation name
    hRes = tsccICfgComp->GetWinstationList( 
                                        &dwNumWinStations,
                                        &dwWinStationSize,
                                        &pWinStationList
                                    );

              
    if( FAILED(hRes) )
    {
        DebugPrintf( _TEXT("QueryInterface() failed with error code 0x%08x\n"), hRes );

        goto CLEANUPANDEXIT;
    }

    //
    // Set TS Logon permission on all winstation
    //
    for( index = 0; index < dwNumWinStations && ERROR_SUCCESS == dwCfgStatus && SUCCEEDED(hRes); index ++ )
    {
        if( 0 == _tcsicmp( pWinStationList[index].Name, L"Console" ) )
        {
            bManualSetConsole = FALSE;
        }

        dwCfgStatus = 0;
        //DebugPrintf( _TEXT("Name of Winstation : %s\n"), pWinStationList[index].Name );

        // check if custom security exist for this winstation
        dwCfgStatus = RegWinStationQuerySecurity(
                                            SERVERNAME_CURRENT,
                                            pWinStationList[index].Name,
                                            NULL,
                                            0,
                                            &cbSecDescLen
                                        );

        if( ERROR_INSUFFICIENT_BUFFER == dwCfgStatus )
        {
            DebugPrintf( _TEXT("Winstation : %s has custom security\n"), pWinStationList[index].Name );

            // From TS Setup, Insufficient buffer means the winstation has custom security
            hRes = tsccIUserSecurity->ModifyUserAccess(
                                                pWinStationList[index].Name,
                                                gm_bstrHelpAccountName,
                                                dwPermissions, 
                                                bDel,
                                                bEnable,
                                                bDeleteExisting,
                                                FALSE,
                                                &dwCfgStatus
                                            );

            if( FAILED(hRes) || ERROR_SUCCESS != dwCfgStatus )
            {
                DebugPrintf(
                        _TEXT("ModifyUserAccess return 0x%08x, dwCfgStatus = %d\n"),
                        hRes,    
                        dwCfgStatus
                    );
            
                // MYASSERT(FALSE);
                continue;
            }
        }
        else if( ERROR_FILE_NOT_FOUND == dwCfgStatus )
        {
            // no custom security for this winstation
            dwCfgStatus = ERROR_SUCCESS;
        } 
        else
        {
            DebugPrintf( 
                    _TEXT("RegWinStationQuerySecurity returns %d\n"),
                    dwCfgStatus 
                );

            // MYASSERT(FALSE);
        }
    }

    if( ERROR_SUCCESS != dwCfgStatus || FAILED(hRes) )
    {
        DebugPrintf( 
                _TEXT("ModifyUserAccess() Loop failed - 0x%08x, %d...\n"),
                hRes, dwCfgStatus
            );
        goto CLEANUPANDEXIT;
    }        

    if( TRUE == bManualSetConsole )
    {
        //
        // Setting Console shadow permission, we don't know when GetWinstationList()
        // will return us Console so...
        //
        hRes = tsccIUserSecurity->ModifyUserAccess(
                                                L"Console",
                                                gm_bstrHelpAccountName,
                                                dwPermissions, 
                                                bDel,
                                                bEnable,
                                                bDeleteExisting,
                                                FALSE,
                                                &dwCfgStatus
                                            );

        if( FAILED(hRes) || ERROR_SUCCESS != dwCfgStatus )
        {
            DebugPrintf(
                    _TEXT("ModifyUserAccess on console return 0x%08x, dwCfgStatus = %d\n"),
                    hRes,    
                    dwCfgStatus
                );
           
            // MYASSERT(FALSE);

            //
            // Continue on to setting wtsapi32, we still can 
            // RDS on non-console winstation
            //
            hRes = S_OK;
            dwCfgStatus = ERROR_SUCCESS;

            // goto CLEANUPANDEXIT;
        }
    }

    if( SUCCEEDED(hRes) )
    {
        tsccICfgComp->ForceUpdate();
    }

CLEANUPANDEXIT:

    if( NULL != pWinStationList )
    {
        CoTaskMemFree( pWinStationList );
    }

    if( NULL != tsccIUserSecurity )
    {
        tsccIUserSecurity->Release();
    }

    if( tsccICfgComp )
    {
        tsccICfgComp.Release();
    }

    //DebugPrintf( _TEXT("SetupHelpAssistantTermSrvPermissions() ended...\n") ); 

    CoUninitialize();
    return hRes;
}


HRESULT
__HelpAssistantAccount::ResetHelpAccountPassword( 
    IN LPCTSTR pszPassword 
    )
/*++
Routine Description:


    This routine change help assistant account password and
    store corresponding password to LSA.

Parameters:

    None.

Returns:

    ERROR_SUCCESS or error code.

Note:

    If help account is disable or not present on local machine,
    we assume no help can be done on local machine.

--*/
{
    DWORD dwStatus;
    BOOL bEnabled;
    TCHAR szNewPassword[MAX_HELPACCOUNT_PASSWORD+1];

    CCriticalSectionLocker l(gm_HelpAccountCS);

    memset(
            szNewPassword, 
            0,
            sizeof(szNewPassword)
        );

    //
    // Check if help assistant account is enabled.
    //
    dwStatus = IsLocalAccountEnabled(
                                gm_bstrHelpAccountName, 
                                &bEnabled
                            );

    if( ERROR_SUCCESS != dwStatus )
    {
        dwStatus = SESSMGR_E_HELPACCOUNT;
        goto CLEANUPANDEXIT;
    }

    //
    // Account is disable, don't reset password
    //
    if( FALSE == bEnabled )
    {
        // help account is disabled, no help is available from this box
        DebugPrintf(
                    _TEXT("Account is disabled...\n")
                );
        dwStatus = SESSMGR_E_HELPACCOUNT;
        goto CLEANUPANDEXIT;
    }

    //
    // if account is enabled, re-set password
    //
    if( NULL == pszPassword || 0 == lstrlen(pszPassword) )
    {
        // we are asked to generate a random password,
        // bail out if can't create random password
        dwStatus = CreatePassword( szNewPassword );
        if( ERROR_SUCCESS != dwStatus )
        {
            MYASSERT( FALSE );
            goto CLEANUPANDEXIT;
        }
    }
    else
    {
        memset( 
                szNewPassword,
                0,
                sizeof(szNewPassword)
            );


        _tcsncpy( 
                szNewPassword, 
                pszPassword, 
                min(lstrlen(pszPassword), MAX_HELPACCOUNT_PASSWORD) 
            );
    }

    //
    // Change the password and cache with LSA, if caching failed
    // reset password back to what we have before.
    //
    dwStatus = ChangeLocalAccountPassword(
                                    gm_bstrHelpAccountName,
                                    gm_bstrHelpAccountPwd,
                                    szNewPassword
                                );

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // save the password with LSA
        //
        dwStatus = StoreKeyWithLSA(
                                HELPASSISTANTACCOUNT_PASSWORDKEY,
                                (PBYTE) szNewPassword,
                                (lstrlen(szNewPassword)+1) * sizeof(TCHAR)
                            );

        if( ERROR_SUCCESS != dwStatus )
        {
            DWORD dwStatus1;

            //
            // something wrong with storing password, reset password
            // back so we can recover next time.
            //
            dwStatus1 = ChangeLocalAccountPassword(
                                            gm_bstrHelpAccountName,
                                            szNewPassword,
                                            gm_bstrHelpAccountPwd
                                        );

            if( ERROR_SUCCESS != dwStatus1 )
            {
                //
                // we have a big problem here, should we delete the account
                // and recreate one again?
                //
            }
        }
        else
        {
            //
            // make a copy of new password.
            //
            gm_bstrHelpAccountPwd = szNewPassword;
        }
    }

CLEANUPANDEXIT:

    return HRESULT_FROM_WIN32(dwStatus);
}


DWORD
__HelpAssistantAccount::EnableAccountRights(
    BOOL bEnable,
    DWORD dwNumRights,
    LPTSTR* rights
    )
/*++


--*/
{
    DWORD dwStatus;
    LSA_UNICODE_STRING UserRightString[1];
    LSA_HANDLE PolicyHandle = NULL;

    //
    // create an lsa policy for it
    dwStatus = OpenPolicy(
                        NULL,
                        POLICY_ALL_ACCESS,
                        &PolicyHandle
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        for( DWORD i=0; i < dwNumRights && ERROR_SUCCESS == dwStatus ; i++ )
        {
            DebugPrintf(
                    _TEXT("%s Help Assistant rights %s\n"),
                    (bEnable) ? _TEXT("Enable") : _TEXT("Disable"),
                    rights[i]
                );

            // Remote interactive right
            InitLsaString(
                        UserRightString,
                        rights[i] 
                    );

            if( bEnable )
            {
                dwStatus = LsaAddAccountRights(
                                        PolicyHandle,
                                        gm_pbHelpAccountSid,
                                        UserRightString,
                                        1
                                    );
            }
            else
            {
                dwStatus = LsaRemoveAccountRights(
                                        PolicyHandle,
                                        gm_pbHelpAccountSid,
                                        FALSE,
                                        UserRightString,
                                        1
                                    );
            }

            DebugPrintf(
                    _TEXT("\tEnable/disable account rights %s returns 0x%08x\n"), 
                    rights[i],
                    dwStatus 
                );

            if( dwStatus == STATUS_NO_SUCH_PRIVILEGE )
            {
                dwStatus = ERROR_SUCCESS;
            }
        }

        LsaClose(PolicyHandle);
    }

    return dwStatus;
}


HRESULT
__HelpAssistantAccount::EnableRemoteInteractiveRight(
    IN BOOL bEnable
    )
/*++

Routine Description:

    Routine to enable/disable Help Assistant account remote interactive 
    logon rights.

Parameters:

    bEnable : TRUE to enable, FALSE to disable.

Returns:

    S_OK or error code.

--*/
{
    LPTSTR rights[1];
    DWORD dwStatus;

    rights[0] = SE_REMOTE_INTERACTIVE_LOGON_NAME;
    dwStatus = EnableAccountRights( bEnable, 1, rights );

    return HRESULT_FROM_WIN32(dwStatus);
}


BOOL
__HelpAssistantAccount::IsAccountHelpAccount(
    IN PBYTE pbSid,
    IN DWORD cbSid
    )
/*++

Routine Description:

    Check if a user is Help Assistant.

Parameters:

    pbSid : Pointer to user SID to checked.
    cbSid : Size of user SID.

Returns:

    TRUE/FALSE

--*/
{
    BOOL bSuccess = FALSE;

    if( NULL != pbSid )
    {
        // make sure it is a valid sid.
        bSuccess = IsValidSid( (PSID)pbSid );

        if( FALSE == bSuccess )
        {
            SetLastError( ERROR_INVALID_SID );
        }
        else
        {
            bSuccess = EqualSid( gm_pbHelpAccountSid, pbSid );
            if( FALSE == bSuccess )
            {
                SetLastError( ERROR_INVALID_DATA );
            }
        }
    }

    return bSuccess;
}

HRESULT
__HelpAssistantAccount::EnableHelpAssistantAccount(
    BOOL bEnable
    )
/*++


--*/
{
    DWORD dwStatus;

    dwStatus = EnableLocalAccount( gm_bstrHelpAccountName, bEnable );

    DebugPrintf(
            _TEXT("%s %s returns %d\n"),
            gm_bstrHelpAccountName,
            (bEnable) ? _TEXT("Enable") : _TEXT("Disable"),
            dwStatus
        );

    return HRESULT_FROM_WIN32( dwStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\helper.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    Helper.cpp

Abstract:

    Various funtion encapsulate HELP user account
    validation, creating.

Author:

    HueiWang    2/17/2000

--*/

#include "stdafx.h"
#include <time.h>
#include <stdio.h>

#ifndef __WIN9XBUILD__

#include <windows.h>
#include <ntsecapi.h>
#include <lmcons.h>
#include <lm.h>
#include <sspi.h>
#include <wtsapi32.h>
#include <winbase.h>
#include <security.h>


#endif

#include "Helper.h"

#ifndef __WIN9XBUILD__

#if DBG

void
DebugPrintf(
    IN LPCTSTR format, ...
    )
/*++

Routine Description:

    sprintf() like wrapper around OutputDebugString().

Parameters:

    hConsole : Handle to console.
    format : format string.

Returns:

    None.

Note:

    To be replace by generic tracing code.

++*/
{
    TCHAR  buf[8096];   // max. error text
    DWORD  dump;
    va_list marker;
    va_start(marker, format);

    SYSTEMTIME sysTime;
    GetSystemTime(&sysTime);

    try {

        memset(
                buf, 
                0, 
                sizeof(buf)
            );

        _sntprintf(
                buf,
                sizeof(buf)/sizeof(buf[0]),
                _TEXT(" %d [%d:%d:%d:%d:%d.%d] : "),
                GetCurrentThreadId(),
                sysTime.wMonth,
                sysTime.wDay,
                sysTime.wHour,
                sysTime.wMinute,
                sysTime.wSecond,
                sysTime.wMilliseconds
            );

        _vsntprintf(
                buf + lstrlen(buf),
                sizeof(buf)/sizeof(buf[0]) - lstrlen(buf),
                format,
                marker
            );

        OutputDebugString(buf);
    }
    catch(...) {
    }

    va_end(marker);
    return;
}
#endif

#endif


void
UnixTimeToFileTime(
    time_t t,
    LPFILETIME pft
    )
{
    LARGE_INTEGER li;

    li.QuadPart = Int32x32To64(t, 10000000) + 116444736000000000;

    pft->dwHighDateTime = li.HighPart;
    pft->dwLowDateTime = li.LowPart;
}


#ifndef __WIN9XBUILD__

/*----------------------------------------------------------------------------
Routine Description:

    This function checks to see whether the specified sid is enabled in
    the specified token.

Arguments:

    TokenHandle - If present, this token is checked for the sid. If not
        present then the current effective token will be used. This must
        be an impersonation token.

    SidToCheck - The sid to check for presence in the token

    IsMember - If the sid is enabled in the token, contains TRUE otherwise
        false.

Return Value:

    TRUE - The API completed successfully. It does not indicate that the
        sid is a member of the token.

    FALSE - The API failed. A more detailed status code can be retrieved
        via GetLastError()


Note : Code modified from 5.0 \\rastaman\ntwin\src\base\advapi\security.c
----------------------------------------------------------------------------*/
BOOL
TLSCheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
{
    HANDLE ProcessToken = NULL;
    HANDLE EffectiveToken = NULL;
    DWORD  Status = ERROR_SUCCESS;
    PISECURITY_DESCRIPTOR SecDesc = NULL;
    ULONG SecurityDescriptorSize;
    GENERIC_MAPPING GenericMapping = { STANDARD_RIGHTS_READ,
                                       STANDARD_RIGHTS_EXECUTE,
                                       STANDARD_RIGHTS_WRITE,
                                       STANDARD_RIGHTS_ALL };
    //
    // The size of the privilege set needs to contain the set itself plus
    // any privileges that may be used. The privileges that are used
    // are SeTakeOwnership and SeSecurity, plus one for good measure
    //
    BYTE PrivilegeSetBuffer[sizeof(PRIVILEGE_SET) + 3*sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET PrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;
    ULONG PrivilegeSetLength = sizeof(PrivilegeSetBuffer);
    ACCESS_MASK AccessGranted = 0;
    BOOL AccessStatus = FALSE;
    PACL Dacl = NULL;

    #define MEMBER_ACCESS 1

    *IsMember = FALSE;

    //
    // Get a handle to the token
    //
    if (TokenHandle != NULL)
    {
        EffectiveToken = TokenHandle;
    }
    else
    {
        if(!OpenThreadToken(GetCurrentThread(),
                            TOKEN_QUERY,
                            FALSE,              // don't open as self
                            &EffectiveToken))
        {
            //
            // if there is no thread token, try the process token
            //
            if((Status=GetLastError()) == ERROR_NO_TOKEN)
            {
                if(!OpenProcessToken(GetCurrentProcess(),
                                     TOKEN_QUERY | TOKEN_DUPLICATE,
                                     &ProcessToken))
                {
                    Status = GetLastError();
                }

                //
                // If we have a process token, we need to convert it to an
                // impersonation token
                //
                if (Status == ERROR_SUCCESS)
                {
                    BOOL Result;
                    Result = DuplicateToken(ProcessToken,
                                            SecurityImpersonation,
                                            &EffectiveToken);
                    CloseHandle(ProcessToken);
                    if (!Result)
                    {
                        return(FALSE);
                    }
                }
            }

            if (Status != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        }
    }

    //
    // Construct a security descriptor to pass to access check
    //

    //
    // The size is equal to the size of an SD + twice the length of the SID
    // (for owner and group) + size of the DACL = sizeof ACL + size of the
    // ACE, which is an ACE + length of
    // ths SID.
    //

    SecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR) +
                                sizeof(ACCESS_ALLOWED_ACE) +
                                sizeof(ACL) +
                                3 * GetLengthSid(SidToCheck);

    SecDesc = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_ZEROINIT, SecurityDescriptorSize );
    if (SecDesc == NULL)
    {
        Status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    Dacl = (PACL) (SecDesc + 1);

    InitializeSecurityDescriptor(SecDesc, SECURITY_DESCRIPTOR_REVISION);

    //
    // Fill in fields of security descriptor
    //
    SetSecurityDescriptorOwner(SecDesc, SidToCheck, FALSE);
    SetSecurityDescriptorGroup(SecDesc, SidToCheck, FALSE);

    if(!InitializeAcl(  Dacl,
                        SecurityDescriptorSize - sizeof(SECURITY_DESCRIPTOR),
                        ACL_REVISION))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    if(!AddAccessAllowedAce(Dacl, ACL_REVISION, MEMBER_ACCESS, SidToCheck))
    {
        Status=GetLastError();  
        goto Cleanup;
    }

    if(!SetSecurityDescriptorDacl(SecDesc, TRUE, Dacl, FALSE))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    if(!AccessCheck(SecDesc,
                    EffectiveToken,
                    MEMBER_ACCESS,
                    &GenericMapping,
                    PrivilegeSet,
                    &PrivilegeSetLength,
                    &AccessGranted,
                    &AccessStatus))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    //
    // if the access check failed, then the sid is not a member of the
    // token
    //
    if ((AccessStatus == TRUE) && (AccessGranted == MEMBER_ACCESS))
    {
        *IsMember = TRUE;
    }


Cleanup:
    if (TokenHandle == NULL && EffectiveToken != NULL)
    {
        CloseHandle(EffectiveToken);
    }

    if (SecDesc != NULL)
    {
        LocalFree(SecDesc);
    }

    return (Status == ERROR_SUCCESS) ? TRUE : FALSE;
}


/*------------------------------------------------------------------------

 BOOL IsUserAdmin(BOOL)

  returns TRUE if user is an admin
          FALSE if user is not an admin
------------------------------------------------------------------------*/
DWORD 
IsUserAdmin(
    BOOL* bMember
    )
{
    PSID psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    DWORD dwStatus=ERROR_SUCCESS;

    do {
        if(!AllocateAndInitializeSid(&siaNtAuthority, 
                                     2, 
                                     SECURITY_BUILTIN_DOMAIN_RID,
                                     DOMAIN_ALIAS_RID_ADMINS,
                                     0, 0, 0, 0, 0, 0,
                                     &psidAdministrators))
        {
            dwStatus=GetLastError();
            continue;
        }

        // assume that we don't find the admin SID.
        if(!TLSCheckTokenMembership(NULL,
                                   psidAdministrators,
                                   bMember))
        {
            dwStatus=GetLastError();
        }

        FreeSid(psidAdministrators);

    } while(FALSE);

    return dwStatus;
}

#endif

DWORD
GetRandomNumber( 
    HCRYPTPROV hProv,
    DWORD* pdwRandom
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    if( NULL == hProv )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    else 
    {
        if( !CryptGenRandom(hProv, sizeof(*pdwRandom), (PBYTE)pdwRandom) )
        {
            dwStatus = GetLastError();
        }
    }

    MYASSERT( ERROR_SUCCESS == dwStatus );
    return dwStatus; 
}

//-----------------------------------------------------

DWORD
ShuffleCharArray(
    IN HCRYPTPROV hProv,
    IN int iSizeOfTheArray,
    IN OUT TCHAR *lptsTheArray
    )
/*++

Routine Description:

    Random shuffle content of a char. array.

Parameters:

    iSizeOfTheArray : Size of array.
    lptsTheArray : On input, the array to be randomly shuffer,
                   on output, the shuffled array.

Returns:

    None.
                   
Note:

    Code Modified from winsta\server\wstrpc.c

--*/
{
    int i;
    int iTotal;
    DWORD dwStatus = ERROR_SUCCESS;

    if( NULL == hProv )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    else
    {
        iTotal = iSizeOfTheArray / sizeof(TCHAR);
        for (i = 0; i < iTotal && ERROR_SUCCESS == dwStatus; i++)
        {
            DWORD RandomNum;
            TCHAR c;

            dwStatus = GetRandomNumber(hProv, &RandomNum);

            if( ERROR_SUCCESS == dwStatus )
            {
                c = lptsTheArray[i];
                lptsTheArray[i] = lptsTheArray[RandomNum % iTotal];
                lptsTheArray[RandomNum % iTotal] = c;
            }
        }
    }

    return dwStatus;
}

//-----------------------------------------------------

DWORD
GenerateRandomBytes(
    IN DWORD dwSize,
    IN OUT LPBYTE pbBuffer
    )
/*++

Description:

    Generate fill buffer with random bytes.

Parameters:

    dwSize : Size of buffer pbBuffer point to.
    pbBuffer : Pointer to buffer to hold the random bytes.

Returns:

    TRUE/FALSE

--*/
{
    HCRYPTPROV hProv = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Create a Crypto Provider to generate random number
    //
    if( !CryptAcquireContext(
                    &hProv,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !CryptGenRandom(hProv, dwSize, pbBuffer) )
    {
        dwStatus = GetLastError();
    }

CLEANUPANDEXIT:    

    if( NULL != hProv )
    {
        CryptReleaseContext( hProv, 0 );
    }

    return dwStatus;
}


DWORD
GenerateRandomString(
    IN DWORD dwSizeRandomSeed,
    IN OUT LPTSTR* pszRandomString
    )
/*++


--*/
{
    PBYTE lpBuffer = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    DWORD cbConvertString = 0;

    if( 0 == dwSizeRandomSeed || NULL == pszRandomString )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    *pszRandomString = NULL;

    lpBuffer = (PBYTE)LocalAlloc( LPTR, dwSizeRandomSeed );  
    if( NULL == lpBuffer )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    dwStatus = GenerateRandomBytes( dwSizeRandomSeed, lpBuffer );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    // Convert to string
    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                0,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    *pszRandomString = (LPTSTR)LocalAlloc( LPTR, (cbConvertString+1)*sizeof(TCHAR) );
    if( NULL == *pszRandomString )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                *pszRandomString,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
    }
    else
    {
        if( (*pszRandomString)[cbConvertString - 1] == '\n' &&
            (*pszRandomString)[cbConvertString - 2] == '\r' )
        {
            (*pszRandomString)[cbConvertString - 2] = 0;
        }
    }

CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        if( NULL != *pszRandomString )
        {
            LocalFree(*pszRandomString);
        }
    }

    if( NULL != lpBuffer )
    {
        LocalFree(lpBuffer);
    }

    return dwStatus;
}

DWORD
CreatePassword(
    OUT TCHAR *pszPassword
    )
/*++

Routine Description:

    Routine to randomly create a password.

Parameters:

    pszPassword : Pointer to buffer to received a randomly generated
                  password, buffer must be at least 
                  MAX_HELPACCOUNT_PASSWORD+1 characters.

Returns:

    None.

Note:

    Code copied from winsta\server\wstrpc.c

--*/
{
    HCRYPTPROV hProv = NULL;

    int   nLength = MAX_HELPACCOUNT_PASSWORD;
    int   iTotal = 0;
    DWORD RandomNum = 0;
    int   i;
    time_t timeVal;
    DWORD dwStatus = ERROR_SUCCESS;


    TCHAR six2pr[64] = 
    {
        _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'),
        _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'), _T('N'),
        _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'),
        _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z'), _T('a'), _T('b'),
        _T('c'), _T('d'), _T('e'), _T('f'), _T('g'), _T('h'), _T('i'),
        _T('j'), _T('k'), _T('l'), _T('m'), _T('n'), _T('o'), _T('p'),
        _T('q'), _T('r'), _T('s'), _T('t'), _T('u'), _T('v'), _T('w'),
        _T('x'), _T('y'), _T('z'), _T('0'), _T('1'), _T('2'), _T('3'),
        _T('4'), _T('5'), _T('6'), _T('7'), _T('8'), _T('9'), _T('*'),
        _T('_')
    };

    TCHAR something1[12] = 
    {
        _T('!'), _T('@'), _T('#'), _T('$'), _T('^'), _T('&'), _T('*'),
        _T('('), _T(')'), _T('-'), _T('+'), _T('=')
    };

    TCHAR something2[10] = 
    {
        _T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'),
        _T('7'), _T('8'), _T('9')
    };

    TCHAR something3[26] = 
    {
        _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'),
        _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'), _T('N'),
        _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'),
        _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z')
    };

    TCHAR something4[26] = 
    {
        _T('a'), _T('b'), _T('c'), _T('d'), _T('e'), _T('f'), _T('g'),
        _T('h'), _T('i'), _T('j'), _T('k'), _T('l'), _T('m'), _T('n'),
        _T('o'), _T('p'), _T('q'), _T('r'), _T('s'), _T('t'), _T('u'),
        _T('v'), _T('w'), _T('x'), _T('y'), _T('z')
    };

    //
    // Create a Crypto Provider to generate random number
    //
    if( !CryptAcquireContext(
                    &hProv,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Shuffle around the six2pr[] array.
    //

    dwStatus = ShuffleCharArray(hProv, sizeof(six2pr), six2pr);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }


    //
    //  Assign each character of the password array.
    //

    iTotal = sizeof(six2pr) / sizeof(TCHAR);
    for (i=0; i<nLength && ERROR_SUCCESS == dwStatus; i++) 
    {
        dwStatus = GetRandomNumber(hProv, &RandomNum);
        if( ERROR_SUCCESS == dwStatus )
        {
            pszPassword[i]=six2pr[RandomNum%iTotal];
        }
    }

    if( ERROR_SUCCESS != dwStatus ) 
    {
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }


    //
    //  In order to meet a possible policy set upon passwords, replace chars
    //  2 through 5 with these:
    //
    //  1) something from !@#$%^&*()-+=
    //  2) something from 1234567890
    //  3) an uppercase letter
    //  4) a lowercase letter
    //

    dwStatus = ShuffleCharArray(hProv, sizeof(something1), (TCHAR*)&something1);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = ShuffleCharArray(hProv, sizeof(something2), (TCHAR*)&something2);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = ShuffleCharArray(hProv, sizeof(something3), (TCHAR*)&something3);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = ShuffleCharArray(hProv, sizeof(something4), (TCHAR*)&something4);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }


    dwStatus = GetRandomNumber(hProv, &RandomNum);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    iTotal = sizeof(something1) / sizeof(TCHAR);
    pszPassword[2] = something1[RandomNum % iTotal];

    dwStatus = GetRandomNumber(hProv, &RandomNum);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    iTotal = sizeof(something2) / sizeof(TCHAR);
    pszPassword[3] = something2[RandomNum % iTotal];

    dwStatus = GetRandomNumber(hProv, &RandomNum);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    iTotal = sizeof(something3) / sizeof(TCHAR);
    pszPassword[4] = something3[RandomNum % iTotal];

    dwStatus = GetRandomNumber(hProv, &RandomNum);
    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    iTotal = sizeof(something4) / sizeof(TCHAR);
    pszPassword[5] = something4[RandomNum % iTotal];

    pszPassword[nLength] = _T('\0');

CLEANUPANDEXIT:

    if( NULL != hProv )
    {
        CryptReleaseContext( hProv, 0 );
    }

    return dwStatus;
}

//--------------------------------------------------------
#ifndef __WIN9XBUILD__


BOOL
LookupAliasFromRid(
    LPWSTR pTargetComputer,
    DWORD Rid,
    LPWSTR pName,
    PDWORD cchName
    )
{
    BOOL fRet;
    PSID pSid = NULL;
    SID_IDENTIFIER_AUTHORITY SidIdentifierAuthority = SECURITY_NT_AUTHORITY;
    SID_NAME_USE SidNameUse;
    ULONG cchDomainName;
    WCHAR szDomainName[256];

    //
    //  Sid is the same regardless of machine, since the well-known
    //  BUILTIN domain is referenced.
    //

    fRet = AllocateAndInitializeSid(
                                &SidIdentifierAuthority,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                Rid,
                                0, 0, 0, 0, 0, 0,
                                &pSid
                            );

    if (fRet)
    {
        cchDomainName = sizeof(szDomainName)/sizeof(szDomainName);

        fRet = LookupAccountSidW(
                            pTargetComputer,
                            pSid,
                            pName,
                            cchName,
                            szDomainName,
                            &cchDomainName,
                            &SidNameUse
                        );

        FreeSid(pSid);
    }

    return(fRet);
}


DWORD
IsUserInLocalGroup(
    IN PBYTE pbUserSid,
    IN LPCTSTR pszLocalGroup,
    OUT BOOL* pbInGroup
    )
/*++

Routine Description:

    Check if user is member of specific local group.

Parameters:

    pbUserSid : SID of user to be verified.
    pszLocalGroup : Name of local group.
    pbInGroup : Return TRUE if user is in group, FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code, membership is returned via pbInGroup
    parameter.
    
Note:

    If 'everyone' is member of the specfied group, routine will 
    immediately return SUCCESS.

--*/
{
    NET_API_STATUS netErr;
    LOCALGROUP_MEMBERS_INFO_0* pBuf=NULL;

    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID pEveryoneSID = NULL;
    DWORD dwEntries;
    DWORD dwTotal;

    *pbInGroup = FALSE;
    //
    // By default add everyone to the group
    //
    if(AllocateAndInitializeSid(  &SIDAuthWorld, 1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &pEveryoneSID) )
    {
        //
        // Retrieve group member.
        //
        netErr = NetLocalGroupGetMembers(
                                    NULL,
                                    pszLocalGroup,
                                    0,
                                    (LPBYTE *)&pBuf,
                                    MAX_PREFERRED_LENGTH,
                                    &dwEntries,
                                    &dwTotal,
                                    NULL
                                );

        if( NERR_Success == netErr )
        {
            for(DWORD index=0; index < dwEntries; index++ )
            {
                if(TRUE == EqualSid( pEveryoneSID, pBuf[index].lgrmi0_sid) )
                {
                    *pbInGroup = TRUE;
                    break;
                }

                if(NULL != pbUserSid && TRUE == EqualSid( pbUserSid, pBuf[index].lgrmi0_sid) )
                {
                    *pbInGroup = TRUE;
                    break;
                }
            }

            NetApiBufferFree( pBuf );
        }

        FreeSid( pEveryoneSID );
    }
    else
    {
        netErr = GetLastError();
    }

    return netErr;
}

BOOL
IsLocalGroupExists(
    IN LPWSTR pszGroupName
    )
/*++

Routine Description:

    Verify if local group exist on machine.

Parameter:

    pszGroupName : Name of the group to be checked.

Returns:

    TRUE/FALSE

--*/
{
    LOCALGROUP_INFO_1* pGroupInfo1;
    NET_API_STATUS netStatus;
    BOOL bGroupExists;

    //
    // Check to see if group exists
    //
    netStatus = NetLocalGroupGetInfo(
                            NULL,
                            pszGroupName,
                            1,
                            (PBYTE *)&pGroupInfo1
                        );

    if( NERR_Success == netStatus )
    {
        NetApiBufferFree(pGroupInfo1);
    }
    else
    {
        SetLastError( netStatus );
    }

    return ( NERR_Success == netStatus );
}

//---------------------------------------------------------

DWORD
CreateLocalGroup(
    IN LPWSTR pszGroupName,
    IN LPWSTR pszGroupDesc,
    IN BOOL bAddEveryone
    )
/*++

Routine Description:

    Create a group on local machine.

Parameters:

    pszGroupName : Group name.
    pszGroupDesc : Group desc.
    bAddEveryone : TRUE if add 'everyone' to the group, FALSE
                   otherwise.

Returns:
    
    ERROR_SUCCESS or error code

--*/
{
    NET_API_STATUS netStatus;
    LOCALGROUP_INFO_1 GroupInfo;
    DWORD dwParmErr;

    GroupInfo.lgrpi1_name = pszGroupName;
    GroupInfo.lgrpi1_comment = pszGroupDesc;

    netStatus = NetLocalGroupAdd(
                            NULL,
                            1,
                            (LPBYTE)&GroupInfo,
                            &dwParmErr
                        );

    if( NERR_Success == netStatus )
    {
        if(FALSE == IsLocalGroupExists(pszGroupName))
        {
            // We have big problem
            netStatus = GetLastError();
        }
    }

    if( NERR_Success == netStatus && TRUE == bAddEveryone )
    {
        LOCALGROUP_MEMBERS_INFO_0 gmember;
        SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
        PSID pEveryoneSID = NULL;

        //
        // add everyone to the group
        //
        if(AllocateAndInitializeSid(  &SIDAuthWorld, 1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &pEveryoneSID) )
        {
            gmember.lgrmi0_sid = pEveryoneSID;

            bAddEveryone = NetLocalGroupAddMembers(
                                    NULL,
                                    pszGroupName,
                                    0,
                                    (PBYTE)&gmember,
                                    1
                                );

            if( ERROR_MEMBER_IN_ALIAS == netStatus )
            {
                // ignore this error
                netStatus = NERR_Success;
            }

            FreeSid( pEveryoneSID );
        }
    }

    return netStatus;
}

//---------------------------------------------------------

DWORD
RenameLocalAccount(
    IN LPWSTR pszOrgName,
    IN LPWSTR pszNewName
)
/*++

Routine Description:


Parameters:


Returns:

    ERROR_SUCCESS or error code.

--*/
{
    NET_API_STATUS err;
    USER_INFO_0 UserInfo;

    UserInfo.usri0_name = pszNewName;
    err = NetUserSetInfo(
                        NULL,
                        pszOrgName,
                        0,
                        (LPBYTE) &UserInfo,
                        NULL
                    );

    return err;
}

DWORD
UpdateLocalAccountFullnameAndDesc(
    IN LPWSTR pszAccOrgName,
    IN LPWSTR pszAccFullName,
    IN LPWSTR pszAccDesc
    )
/*++

Routine Description:

    Update account full name and description.

Parameters:

    pszAccName : Account name.
    pszAccFullName : new account full name.
    pszAccDesc : new account description.

Returns:    

    ERROR_SUCCESS or error code

--*/
{
    LPBYTE pbServer = NULL;
    BYTE *pBuffer;
    NET_API_STATUS netErr = NERR_Success;
    DWORD parm_err;

    netErr = NetUserGetInfo( 
                        NULL, 
                        pszAccOrgName, 
                        3, 
                        &pBuffer 
                    );

    if( NERR_Success == netErr )
    {
        USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;

        lpui3->usri3_comment = pszAccDesc;
        lpui3->usri3_full_name = pszAccFullName;

        netErr = NetUserSetInfo(
                            NULL,
                            pszAccOrgName,
                            3,
                            (PBYTE)lpui3,
                            &parm_err
                        );

        NetApiBufferFree(pBuffer);
    }

    return netErr;
}

DWORD
IsLocalAccountEnabled(
    IN LPWSTR pszUserName,
    IN BOOL* pEnabled
    )
/*++

Routine Description:

    Check if local account enabled    

Parameters:

    pszUserName : Name of user account.
    pEnabled : Return TRUE is account is enabled, FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwResult;
    NET_API_STATUS err;
    LPBYTE pBuffer;
    USER_INFO_1 *pUserInfo;

    err = NetUserGetInfo(
                        NULL,
                        pszUserName,
                        1,
                        &pBuffer
                    );

    if( NERR_Success == err )
    {
        pUserInfo = (USER_INFO_1 *)pBuffer;

        if (pUserInfo != NULL)
        {
            if( pUserInfo->usri1_flags & UF_ACCOUNTDISABLE )
            {
                *pEnabled = FALSE;
            }
            else
            {
                *pEnabled = TRUE;
            }
        }

        NetApiBufferFree( pBuffer );
    }
    else if( NERR_UserNotFound == err )
    {
        *pEnabled = FALSE;
        //err = NERR_Success;
    }

    return err;
}

//---------------------------------------------------------

DWORD
EnableLocalAccount(
    IN LPWSTR pszUserName,
    IN BOOL bEnable
    )
/*++

Routine Description:

    Routine to enable/disable a local account.

Parameters:

    pszUserName : Name of user account.
    bEnable : TRUE if enabling account, FALSE if disabling account.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwResult;
    NET_API_STATUS err;
    LPBYTE pBuffer;
    USER_INFO_1 *pUserInfo;
    BOOL bChangeAccStatus = TRUE;

    err = NetUserGetInfo(
                        NULL,
                        pszUserName,
                        1,
                        &pBuffer
                    );

    if( NERR_Success == err )
    {
        pUserInfo = (USER_INFO_1 *)pBuffer;

        if(pUserInfo != NULL)
        {

            if( TRUE == bEnable && pUserInfo->usri1_flags & UF_ACCOUNTDISABLE )
            {
                pUserInfo->usri1_flags &= ~UF_ACCOUNTDISABLE;
            }
            else if( FALSE == bEnable && !(pUserInfo->usri1_flags & UF_ACCOUNTDISABLE) )
            {
                pUserInfo->usri1_flags |= UF_ACCOUNTDISABLE;
            }   
            else
            {
                bChangeAccStatus = FALSE;
            }

            if( TRUE == bChangeAccStatus )
            {
                err = NetUserSetInfo( 
                                NULL,
                                pszUserName,
                                1,
                                pBuffer,
                                &dwResult
                            );
            }
        }

        NetApiBufferFree( pBuffer );
    }

    return err;
}

//---------------------------------------------------------

BOOL
IsPersonalOrProMachine()
/*++

Routine Description:

    Check if machine is PER or PRO sku.

Parameters:

    None.

Return:

    TRUE/FALSE
--*/
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    BOOL bSuccess;

    ZeroMemory(
            &osVersionInfo, 
            sizeof(OSVERSIONINFOEX)
        );

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_SERVER;

    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    bSuccess= VerifyVersionInfo(
                            &osVersionInfo,
                            VER_PRODUCT_TYPE,
                            dwlConditionMask
                        );

    return !bSuccess;
}
    

DWORD
CreateLocalAccount(
    IN LPWSTR pszUserName,
    IN LPWSTR pszUserPwd,
    IN LPWSTR pszFullName,
    IN LPWSTR pszComment,
    IN LPWSTR pszGroup,
    IN LPWSTR pszScript,
    OUT BOOL* pbAccountExist
    )
/*++

Routine Description:

    Create an user account on local machine.

Parameters:

    pszUserName : Name of the user account.
    pszUserPwd : User account password.
    pszFullName : Account Full Name.
    pszComment : Account comment.
    pszGroup : Local group of the account.
    pbAccountExist ; Return TRUE if account already exists, FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    LPBYTE pbServer = NULL;
    BYTE *pBuffer;
    NET_API_STATUS netErr = NERR_Success;
    DWORD parm_err;
    DWORD dwStatus;

    netErr = NetUserGetInfo( 
                        NULL, 
                        pszUserName, 
                        3, 
                        &pBuffer 
                    );

    if( NERR_Success == netErr )
    {
        //
        // User account exists, if account is disabled,
        // enable it and change password
        //
        USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;

        if( lpui3->usri3_flags & UF_ACCOUNTDISABLE ||
            lpui3->usri3_flags & UF_LOCKOUT )
        {
            // enable the account
            lpui3->usri3_flags &= ~ ~UF_LOCKOUT;;

            if( lpui3->usri3_flags & UF_ACCOUNTDISABLE )
            {
                // we only reset password if account is disabled.
                lpui3->usri3_flags &= ~ UF_ACCOUNTDISABLE;
            }

            //lpui3->usri3_password = pszUserPwd;

            // reset password if account is disabled.
            lpui3->usri3_name = pszUserName;
            lpui3->usri3_comment = pszComment;
            lpui3->usri3_full_name = pszFullName;
            //lpui3->usri3_primary_group_id = dwGroupId;

            netErr = NetUserSetInfo(
                                NULL,
                                pszUserName,
                                3,
                                (PBYTE)lpui3,
                                &parm_err
                            );
        }

        *pbAccountExist = TRUE;
        NetApiBufferFree(pBuffer);
    }
    else if( NERR_UserNotFound == netErr )
    {
        //
        // Account does not exist, create and set it to our group
        //
        USER_INFO_1 UserInfo;

        memset(&UserInfo, 0, sizeof(USER_INFO_1));

        UserInfo.usri1_name = pszUserName;
        UserInfo.usri1_password = pszUserPwd;
        UserInfo.usri1_priv = USER_PRIV_USER;   // see USER_INFO_1 for detail
        UserInfo.usri1_comment = pszComment;
        UserInfo.usri1_flags = UF_PASSWD_CANT_CHANGE | UF_DONT_EXPIRE_PASSWD;

        netErr = NetUserAdd(
                        NULL,
                        1,
                        (PBYTE)&UserInfo,
                        &parm_err
                    );

        *pbAccountExist = FALSE;
    }

    return netErr;
}

///////////////////////////////////////////////////////////////////////////////
DWORD
ChangeLocalAccountPassword(
    IN LPWSTR pszAccName,
    IN LPWSTR pszOldPwd,
    IN LPWSTR pszNewPwd
    )
/*++

Routine Description:

    Change password of a local account.

Parameters:

    pszAccName : Name of user account.
    pszOldPwd : Old password.
    pszNewPwd : New password.

Returns:

    ERROR_SUCCESS or error code.

Notes:

    User NetUserChangePassword(), must have priviledge

--*/
{
    USER_INFO_1003  sUserInfo3;
    NET_API_STATUS  netErr;


    UNREFERENCED_PARAMETER( pszOldPwd );

    sUserInfo3.usri1003_password = pszNewPwd;
    netErr = NetUserSetInfo( 
                        NULL,
                        pszAccName,
                        1003,
                        (BYTE *) &sUserInfo3,
                        0 
                    );

    return netErr;
}
   
///////////////////////////////////////////////////////////////////////////////
DWORD
RetrieveKeyFromLSA(
    IN PWCHAR pwszKeyName,
    OUT PBYTE * ppbKey,
    OUT DWORD * pcbKey 
    )
/*++

Routine Description:

    Retrieve private data previously stored with StoreKeyWithLSA().

Parameters:

    pwszKeyName : Name of the key.
    ppbKey : Pointer to PBYTE to receive binary data.
    pcbKey : Size of binary data.

Returns:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER.
    ERROR_FILE_NOT_FOUND
    LSA return code

Note:

    Memory is allocated using LocalAlloc() 

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    DWORD Status;

    if( ( NULL == pwszKeyName ) || ( NULL == ppbKey ) || ( NULL == pcbKey ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    InitLsaString( 
            &SecretKeyName, 
            pwszKeyName 
        );

    Status = OpenPolicy( 
                    NULL, 
                    POLICY_GET_PRIVATE_INFORMATION, 
                    &PolicyHandle 
                );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaRetrievePrivateData(
                            PolicyHandle,
                            &SecretKeyName,
                            &pSecretData
                        );

    LsaClose( PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    if(pSecretData->Length)
    {
        *ppbKey = ( LPBYTE )LocalAlloc( LPTR, pSecretData->Length );

        if( *ppbKey )
        {
            *pcbKey = pSecretData->Length;
            CopyMemory( *ppbKey, pSecretData->Buffer, pSecretData->Length );
            Status = ERROR_SUCCESS;
        } 
        else 
        {
            Status = GetLastError();
        }
    }
    else
    {
        Status = ERROR_FILE_NOT_FOUND;
        *pcbKey = 0;
        *ppbKey = NULL;
    }

    ZeroMemory( pSecretData->Buffer, pSecretData->Length );
    LsaFreeMemory( pSecretData );

    return Status;
}

///////////////////////////////////////////////////////////////////////////////
DWORD
StoreKeyWithLSA(
    IN PWCHAR  pwszKeyName,
    IN BYTE *  pbKey,
    IN DWORD   cbKey 
    )
/*++

Routine Description:

    Save private data to LSA.

Parameters:

    pwszKeyName : Name of the key this data going to be stored under.
    pbKey : Binary data to be saved.
    cbKey : Size of binary data.

Returns:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER.
    LSA return code

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    DWORD Status;
    
    if( ( NULL == pwszKeyName ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    
    InitLsaString( 
            &SecretKeyName, 
            pwszKeyName 
        );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( 
                    NULL, 
                    POLICY_CREATE_SECRET, 
                    &PolicyHandle 
                );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    return LsaNtStatusToWinError(Status);
}


///////////////////////////////////////////////////////////////////////////////
DWORD
OpenPolicy(
    IN LPWSTR ServerName,
    IN DWORD  DesiredAccess,
    OUT PLSA_HANDLE PolicyHandle 
    )
/*++

Routine Description:

    Create/return a LSA policy handle.

Parameters:
    
    ServerName : Name of server, refer to LsaOpenPolicy().
    DesiredAccess : Desired access level, refer to LsaOpenPolicy().
    PolicyHandle : Return PLSA_HANDLE.

Returns:

    ERROR_SUCCESS or  LSA error code

--*/
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
 
    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString( &ServerString, ServerName );
        Server = &ServerString;

    } 
    else 
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    
    return( LsaOpenPolicy(
                    Server,
                    &ObjectAttributes,
                    DesiredAccess,
                    PolicyHandle ) );
}


///////////////////////////////////////////////////////////////////////////////
void
InitLsaString(
    IN OUT PLSA_UNICODE_STRING LsaString,
    IN LPWSTR String 
    )
/*++

Routine Description:

    Initialize LSA unicode string.

Parameters:

    LsaString : Pointer to LSA_UNICODE_STRING to be initialized.
    String : String to initialize LsaString.

Returns:

    None.

Note:

    Refer to LSA_UNICODE_STRING

--*/
{
    DWORD StringLength;

    if( NULL == String ) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) StringLength * sizeof( WCHAR );
    LsaString->MaximumLength=( USHORT )( StringLength + 1 ) * sizeof( WCHAR );
}

//-----------------------------------------------------
BOOL 
ValidatePassword(
    IN LPWSTR pszUserName,
    IN LPWSTR pszDomain,
    IN LPWSTR pszPassword
    )
/*++

Routine Description:

    Validate user account password.

Parameters:

    pszUserName : Name of user account.
    pszDomain : Domain name.
    pszPassword : Password to be verified.

Returns:

    TRUE or FALSE.


Note:

    To debug this code, you will need to run process as service in order
    for it to verify password.  Refer to MSDN on LogonUser
    
--*/
{
    HANDLE hToken;
    BOOL bSuccess;


    //
    // To debug this code, you will need to run process as service in order
    // for it to verify password.  Refer to MSDN on LogonUser
    //

    bSuccess = LogonUser( 
                        pszUserName, 
                        pszDomain, //_TEXT("."), //pszDomain, 
                        pszPassword, 
                        LOGON32_LOGON_NETWORK_CLEARTEXT, 
                        LOGON32_PROVIDER_DEFAULT, 
                        &hToken
                    );

    if( TRUE == bSuccess )
    {
        CloseHandle( hToken );
    }
    else
    {
        DWORD dwStatus = GetLastError();

        DebugPrintf(
                _TEXT("ValidatePassword() failed with %d\n"),
                dwStatus
            );

        SetLastError(dwStatus);
    }

    return bSuccess;
}

//---------------------------------------------------------------

BOOL 
GetTextualSid(
    IN PSID pSid,            // binary Sid
    IN OUT LPTSTR TextualSid,    // buffer for Textual representation of Sid
    IN OUT LPDWORD lpdwBufferLen // required/provided TextualSid buffersize
    )
/*++

Routine Description:

    Conver a SID to string representation, code from MSDN

Parameters:

    pSid : Pointer to SID to be converted to string.
    TextualSid : On input, pointer to buffer to received converted string, on output,
                 converted SID in string form.
    lpdwBufferLen : On input, size of the buffer, on output, length of converted string
                    or required buffer size in char.

Returns:

    TRUE/FALSE, use GetLastError() to retrieve detail error code.

--*/
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // Validate the binary SID.

    if(!IsValidSid(pSid)) 
    {
        return FALSE;
    }

    // Get the identifier authority value from the SID.

    psia = GetSidIdentifierAuthority(pSid);

    // Get the number of subauthorities in the SID.

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    // Compute the buffer length.
    // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL

    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    // Check input buffer length.
    // If too small, indicate the proper size and set last error.

    if (*lpdwBufferLen < dwSidSize)
    {
        *lpdwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Add 'S' prefix and revision number to the string.

    dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    // Add SID identifier authority to the string.

    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    // Add SID subauthorities to the string.
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize+=wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    return TRUE;
}

#endif

long
GetUserTSLogonIdEx( 
    HANDLE hToken 
    )
/*++

--*/
{
    BOOL  Result;
    LONG SessionId = -1;
    ULONG ReturnLength;

#ifndef __WIN9XBUILD__
    //
    // Use the _HYDRA_ extension to GetTokenInformation to
    // return the SessionId from the token.
    //

    Result = GetTokenInformation(
                         hToken,
                         TokenSessionId,
                         &SessionId,
                         sizeof(SessionId),
                         &ReturnLength
                     );

    if( !Result ) {

        DWORD dwStatus = GetLastError();
        SessionId = -1; 

    }

#endif

    return SessionId;
}

   

long
GetUserTSLogonId()
/*++

Routine Description:

    Return client TS Session ID.

Parameters:

    None.

Returns:

    Client's TS session ID or 0 if not on TS.

Note:

    Must have impersonate user first.

--*/
{
    LONG lSessionId = -1;

#ifndef __WIN9XBUILD__
    HANDLE hToken;
    BOOL bSuccess;

    bSuccess = OpenThreadToken(
                        GetCurrentThread(),
                        TOKEN_QUERY, //TOKEN_ALL_ACCESS,
                        FALSE,
                        &hToken
                    );

    if( TRUE == bSuccess )
    {
        lSessionId = GetUserTSLogonIdEx(hToken);   
        CloseHandle(hToken);
    }

#else

    lSessionId = 0;

#endif

    return lSessionId;
}

//
//
////////////////////////////////////////////////////////////////
//
//

DWORD
RegEnumSubKeys(
    IN HKEY hKey,
    IN LPCTSTR pszSubKey,
    IN RegEnumKeyCallback pFunc,
    IN HANDLE userData
    )
/*++


--*/
{
    DWORD dwStatus;
    HKEY hSubKey = NULL;
    int index;

    LONG dwNumSubKeys;
    DWORD dwMaxSubKeyLength;
    DWORD dwSubKeyLength;
    LPTSTR pszSubKeyName = NULL;

    DWORD dwMaxValueNameLen;
    LPTSTR pszValueName = NULL;
    DWORD dwValueNameLength;

    if( NULL == hKey )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    dwStatus = RegOpenKeyEx(
                            hKey,
                            pszSubKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hSubKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        // key does not exist
        return dwStatus;
    }

    //
    // Query number of subkeys
    //
    dwStatus = RegQueryInfoKey(
                            hSubKey,
                            NULL,
                            NULL,
                            NULL,
                            (DWORD *)&dwNumSubKeys,
                            &dwMaxSubKeyLength,
                            NULL,
                            NULL,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwMaxValueNameLen++;
    pszValueName = (LPTSTR)LocalAlloc(
                                    LPTR,
                                    dwMaxValueNameLen * sizeof(TCHAR)
                                );
    if(pszValueName == NULL)
    {
        goto cleanup;
    }

    if(dwNumSubKeys > 0)
    {
        // allocate buffer for subkeys.
        dwMaxSubKeyLength++;
        pszSubKeyName = (LPTSTR)LocalAlloc(
                                            LPTR,
                                            dwMaxSubKeyLength * sizeof(TCHAR)
                                        );
        if(pszSubKeyName == NULL)
        {
            dwStatus = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

        for(;dwStatus == ERROR_SUCCESS && dwNumSubKeys >= 0;)
        {
            // delete this subkey.
            dwSubKeyLength = dwMaxSubKeyLength;
            memset(pszSubKeyName, 0, dwMaxSubKeyLength * sizeof(TCHAR));

            // retrieve subkey name
            dwStatus = RegEnumKeyEx(
                                hSubKey,
                                (DWORD)--dwNumSubKeys,
                                pszSubKeyName,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = pFunc( 
                                hSubKey, 
                                pszSubKeyName, 
                                userData 
                            );
            }
        }

        if( ERROR_NO_MORE_ITEMS == dwStatus )
        {
            dwStatus = ERROR_SUCCESS;
        }
    }

cleanup:
                            
    // close the key before trying to delete it.
    if(hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }

    if(pszValueName != NULL)
    {
        LocalFree(pszValueName);
    }

    if(pszSubKeyName != NULL)
    {
        LocalFree(pszSubKeyName);
    }

    return dwStatus;   
}    


DWORD
RegDelKey(
    IN HKEY hRegKey,
    IN LPCTSTR pszSubKey
    )
/*++

Abstract:

    Recursively delete entire registry key.

Parameter:

    hKey : Handle to a curently open key.
    pszSubKey : Pointer to NULL terminated string containing the key to be deleted.

Returns:

    Error code from RegOpenKeyEx(), RegQueryInfoKey(), 
        RegEnumKeyEx().

++*/
{
    DWORD dwStatus;
    HKEY hSubKey = NULL;
    int index;

    DWORD dwNumSubKeys;
    DWORD dwMaxSubKeyLength;
    DWORD dwSubKeyLength;
    LPTSTR pszSubKeyName = NULL;

    DWORD dwMaxValueNameLen;
    LPTSTR pszValueName = NULL;
    DWORD dwValueNameLength;

    if( NULL == hRegKey )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    dwStatus = RegOpenKeyEx(
                            hRegKey,
                            pszSubKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hSubKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        // key does not exist
        return dwStatus;
    }

    //
    // Query number of subkeys
    //
    dwStatus = RegQueryInfoKey(
                            hSubKey,
                            NULL,
                            NULL,
                            NULL,
                            &dwNumSubKeys,
                            &dwMaxSubKeyLength,
                            NULL,
                            NULL,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwMaxValueNameLen++;
    pszValueName = (LPTSTR)LocalAlloc(
                                    LPTR,
                                    dwMaxValueNameLen * sizeof(TCHAR)
                                );
    if(pszValueName == NULL)
    {
        goto cleanup;
    }

    if(dwNumSubKeys > 0)
    {
        // allocate buffer for subkeys.

        dwMaxSubKeyLength++;
        pszSubKeyName = (LPTSTR)LocalAlloc(
                                            LPTR,
                                            dwMaxSubKeyLength * sizeof(TCHAR)
                                        );
        if(pszSubKeyName == NULL)
        {
            dwStatus = ERROR_OUTOFMEMORY;
            goto cleanup;
        }


        //for(index = 0; index < dwNumSubKeys; index++)
        for(;dwStatus == ERROR_SUCCESS;)
        {
            // delete this subkey.
            dwSubKeyLength = dwMaxSubKeyLength;
            memset(pszSubKeyName, 0, dwMaxSubKeyLength * sizeof(TCHAR));

            // retrieve subkey name
            dwStatus = RegEnumKeyEx(
                                hSubKey,
                                (DWORD)0,
                                pszSubKeyName,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = RegDelKey( hSubKey, pszSubKeyName );
            }

            // ignore any error and continue on
        }
    }

cleanup:

    for(dwStatus = ERROR_SUCCESS; pszValueName != NULL && dwStatus == ERROR_SUCCESS;)
    {
        dwValueNameLength = dwMaxValueNameLen;
        memset(pszValueName, 0, dwMaxValueNameLen * sizeof(TCHAR));

        dwStatus = RegEnumValue(
                            hSubKey,
                            0,
                            pszValueName,
                            &dwValueNameLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            RegDeleteValue(hSubKey, pszValueName);
        }
    }   
                            
    // close the key before trying to delete it.
    if(hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }

    // try to delete this key, will fail if any of the subkey
    // failed to delete in loop
    dwStatus = RegDeleteKey(
                            hRegKey,
                            pszSubKey
                        );



    if(pszValueName != NULL)
    {
        LocalFree(pszValueName);
    }

    if(pszSubKeyName != NULL)
    {
        LocalFree(pszSubKeyName);
    }

    return dwStatus;   
}    

//---------------------------------------------------------------
DWORD
GetUserSid(
    OUT PBYTE* ppbSid,
    OUT DWORD* pcbSid
    )
/*++

Routine Description:

    Retrieve user's SID , must impersonate client first.

Parameters:

    ppbSid : Pointer to PBYTE to receive user's SID.
    pcbSid : Pointer to DWORD to receive size of SID.

Returns:

    ERROR_SUCCESS or error code.

Note:

    Must have call ImpersonateClient(), funtion is NT specific,
    Win9X will return internal error.

--*/
{
#ifndef __WIN9XBUILD__

    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    HANDLE hToken = NULL;
    DWORD dwSize = 0;
    TOKEN_USER* pToken = NULL;

    *ppbSid = NULL;
    *pcbSid = 0;

    //
    // Open current process token
    //
    bSuccess = OpenThreadToken(
                            GetCurrentThread(),
                            TOKEN_QUERY, 
                            FALSE,
                            &hToken
                        );

    if( TRUE == bSuccess )
    {
        //
        // get user's token.
        //
        GetTokenInformation(
                        hToken,
                        TokenUser,
                        NULL,
                        0,
                        &dwSize
                    );

        pToken = (TOKEN_USER *)LocalAlloc( LPTR, dwSize );
        if( NULL != pToken )
        {
            bSuccess = GetTokenInformation(
                                        hToken,
                                        TokenUser,
                                        (LPVOID) pToken,
                                        dwSize,
                                        &dwSize
                                    );

            if( TRUE == bSuccess )
            {
                //
                // GetLengthSid() return size of buffer require,
                // must call IsValidSid() first
                //
                bSuccess = IsValidSid( pToken->User.Sid );
                if( TRUE == bSuccess )
                {
                    *pcbSid = GetLengthSid( (PBYTE)pToken->User.Sid );
                    *ppbSid = (PBYTE)LocalAlloc(LPTR, *pcbSid);
                    if( NULL != *ppbSid )
                    {
                        bSuccess = CopySid(
                                            *pcbSid,
                                            *ppbSid,
                                            pToken->User.Sid
                                        );                  
                    }
                    else // fail in LocalAlloc()
                    {
                        bSuccess = FALSE;
                    }
                } // IsValidSid()
            } // GetTokenInformation()
        }
        else // LocalAlloc() fail
        {
            bSuccess = FALSE;
        }
    }

    if( TRUE != bSuccess )
    {
        dwStatus = GetLastError();

        if( NULL != *ppbSid )
        {
            LocalFree(*ppbSid);
            *ppbSid = NULL;
            *pcbSid = 0;
        }
    }

    //
    // Free resources...
    //
    if( NULL != pToken )
    {
        LocalFree(pToken);
    }

    if( NULL != hToken )
    {
        CloseHandle(hToken);
    }

    return dwStatus;

#else

    return E_UNEXPECTED;

#endif
}


//----------------------------------------------------------------
HRESULT
GetUserSidString(
    OUT CComBSTR& bstrSid
    )
/*++

Routine Description:

    Retrieve user's SID in textual form, must impersonate client first.

Parameters:

    bstrSID : Return users' SID in textual form.

Returns:

    ERROR_SUCCESS or error code.

Note:

    Must have call ImpersonateClient().

--*/
{
#ifndef __WIN9XBUILD__

    DWORD dwStatus;
    PBYTE pbSid = NULL;
    DWORD cbSid = 0;
    BOOL bSuccess = TRUE;
    LPTSTR pszTextualSid = NULL;
    DWORD dwTextualSid = 0;

    dwStatus = GetUserSid( &pbSid, &cbSid );
    if( ERROR_SUCCESS == dwStatus )
    {
        bSuccess = GetTextualSid( 
                            pbSid, 
                            NULL, 
                            &dwTextualSid 
                        );

        if( FALSE == bSuccess && ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {
            pszTextualSid = (LPTSTR)LocalAlloc(
                                            LPTR, 
                                            (dwTextualSid + 1) * sizeof(TCHAR)
                                        );

            if( NULL != pszTextualSid )
            {
                bSuccess = GetTextualSid( 
                                        pbSid, 
                                        pszTextualSid, 
                                        &dwTextualSid
                                    );

                if( TRUE == bSuccess )
                {
                    bstrSid = pszTextualSid;
                }
            }
        }

        if( FALSE == bSuccess )
        {
            dwStatus = GetLastError();
        }
    }

    if( NULL != pszTextualSid )
    {
        LocalFree(pszTextualSid);
    }

    if( NULL != pbSid )
    {
        LocalFree(pbSid);
    }

    return HRESULT_FROM_WIN32(dwStatus);

#else

    bstrSid = WIN9X_USER_SID;

    return S_OK;

#endif
}

BOOL
FileExists(
    IN  LPCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    DWORD Error;

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) 
    {
        Error = GetLastError();
    } 
    else 
    {
        FindClose(FindHandle);
        if(FindData) 
        {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

     SetLastError(Error);
    return (Error == NO_ERROR);
}


BOOL
AdjustPrivilege(
    PWSTR   Privilege
    )
/*++

Routine Description:

    This routine tries to adjust the priviliege of the current process.


Arguments:

    Privilege - String with the name of the privilege to be adjusted.

Return Value:

    Returns TRUE if the privilege could be adjusted.
    Returns FALSE, otherwise.


--*/
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;

    TOKEN_PRIVILEGES    TokenPrivileges;


    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        return( FALSE );
    }


    if( !LookupPrivilegeValue( NULL,
                               Privilege, // (LPWSTR)SE_SECURITY_NAME,
                               &( LuidAndAttributes.Luid ) ) ) {
        return( FALSE );
    }

    LuidAndAttributes.Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        return( FALSE );
    }

    if( GetLastError() != NO_ERROR ) {
        return( FALSE );
    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\helpmgr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpMgr.h 

Abstract:

    Declaration of the CRemoteDesktopHelpSessionMgr

Author:

    HueiWang    2/17/2000

--*/
#ifndef __REMOTEDESKTOPHELPSESSIONMGR_H_
#define __REMOTEDESKTOPHELPSESSIONMGR_H_

#include "resource.h"       // main symbols


typedef struct __ExpertLogoffStruct {
    HANDLE hWaitObject;
    HANDLE hWaitProcess;
    LONG ExpertSessionId;
    CComBSTR bstrHelpedTicketId;

    CComBSTR bstrWinStationName;

    __ExpertLogoffStruct() {
        hWaitObject = NULL;
        hWaitProcess = NULL;
    };

    ~__ExpertLogoffStruct() {
        if( NULL != hWaitObject )
        {
            UnregisterWait( hWaitObject );
        }

        if( NULL != hWaitProcess )
        {
            CloseHandle( hWaitProcess );
        }
    }
} EXPERTLOGOFFSTRUCT, *PEXPERTLOGOFFSTRUCT;


#ifdef __cplusplus
extern "C"{
#endif

HRESULT
ImpersonateClient();

void
EndImpersonateClient();

HRESULT
LoadLocalSystemSID();

HRESULT
RegisterResolverWithGIT(
    ISAFRemoteDesktopCallback* pResolver
);

HRESULT
LoadResolverFromGIT( 
    ISAFRemoteDesktopCallback** ppResolver
);

HRESULT
UnInitializeGlobalInterfaceTable();

HRESULT
InitializeGlobalInterfaceTable();

DWORD
MonitorExpertLogoff(
    IN LONG pidToWaitFor,
    IN LONG expertSessionId,
    IN BSTR bstrHelpedTicketId
);

VOID
CleanupMonitorExpertList();

#ifdef __cplusplus
}
#endif

typedef MAP<PVOID, PEXPERTLOGOFFSTRUCT> EXPERTLOGOFFMONITORLIST;
    

class CRemoteDesktopHelpSession;


//
// Help Session Manager service name, this must be consistent with
// with COM or COM won't find us.
//
#define HELPSESSIONMGR_SERVICE_NAME \
    _TEXT("RemoteDesktopHelpSessionMgr")

//
// STL Help Session ID to actual help session object map.
//
typedef MAP< CComBSTR, CComObject<CRemoteDesktopHelpSession>* > IDToSessionMap;
typedef CComObject< CRemoteDesktopHelpSession > RemoteDesktopHelpSessionObj;


/////////////////////////////////////////////////////////////////////////////
// CRemoteDesktopHelpSessionMgr
class ATL_NO_VTABLE CRemoteDesktopHelpSessionMgr : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CRemoteDesktopHelpSessionMgr, &CLSID_RemoteDesktopHelpSessionMgr>,
    public IDispatchImpl<IRemoteDesktopHelpSessionMgr, &IID_IRemoteDesktopHelpSessionMgr, &LIBID_RDSESSMGRLib>
{
    friend class CRemoteDesktopUserPolicy;

public:
    CRemoteDesktopHelpSessionMgr();
    ~CRemoteDesktopHelpSessionMgr() {}

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPHELPSESSIONMGR)

//DECLARE_CLASSFACTORY_SINGLETON(CRemoteDesktopHelpSessionMgr)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRemoteDesktopHelpSessionMgr)
    COM_INTERFACE_ENTRY(IRemoteDesktopHelpSessionMgr)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

    //
    // Can't impersonate so can't pre-load user SID at FinalConstruct()
    // 

    HRESULT
    FinalConstruct()
    {
        ULONG count = _Module.AddRef();

        DebugPrintf( 
                _TEXT("Module AddRef by CRemoteDesktopHelpSessionMgr() %d...\n"),
                count
            );

        BOOL bSuccess = _Module.InitializeSessmgr();

        DebugPrintf(
                _TEXT("_Module.InitializeSessmgr() return %d\n"),
                bSuccess
            );

        return S_OK;
    }

    void
    FinalRelease()
    {
        Cleanup();

        ULONG count = _Module.Release();

        DebugPrintf( 
                _TEXT("Module Release by CRemoteDesktopHelpSessionMgr() %d ...\n"), 
                count 
            );
    }


// IRemoteDesktopHelpSessionMgr
public:

   
    STDMETHOD(ResetHelpAssistantAccount)(
        /*[in]*/ BOOL bForce
    );

    STDMETHOD(CreateHelpSession)(
        /*[in]*/ BSTR bstrSessName, 
        /*[in]*/ BSTR bstrSessPwd, 
        /*[in]*/ BSTR bstrUserHelpBlob, 
        /*[in]*/ BSTR bstrUserHelpCreateBlob,
        /*[out, retval]*/ IRemoteDesktopHelpSession** ppIRemoteDesktopHelpSession
    );

    STDMETHOD(DeleteHelpSession)(
        /*[in]*/ BSTR HelpSessionID
    );

    STDMETHOD(RetrieveHelpSession)(
        /*[in]*/ BSTR HelpSessionID, 
        /*[out, retval]*/ IRemoteDesktopHelpSession** ppIRemoteDesktopHelpSession
    );

    STDMETHOD(VerifyUserHelpSession)(
        /*[in]*/ BSTR HelpSessionId,
        /*[in]*/ BSTR bstrSessPwd,
        /*[in]*/ BSTR bstrResolverConnectBlob,
        /*[in]*/ BSTR bstrUserHelpCreateBlob,
        /*[in]*/ LONG CallerProcessId,
        /*[out]*/ ULONG_PTR* phHelpCtr,
        /*[out]*/ LONG* pResolverRetCode,
        /*[out, retval]*/ long* pdwUserLogonSession
    );

    STDMETHOD(GetUserSessionRdsSetting)(
        /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS* sessionRdsLevel
    );

    STDMETHOD(RemoteCreateHelpSession)(
        /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
        /*[in]*/ LONG timeOut,
        /*[in]*/ LONG userSessionId,
        /*[in]*/ BSTR userSid,
        /*[in]*/ BSTR bstrUserHelpCreateBlob,
        /*[out, retval]*/ BSTR* parms
    );

    STDMETHOD(CreateHelpSessionEx)(
        /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
        /*[in]*/ BOOL fEnableCallback,
        /*[in]*/ LONG timeOut,
        /*[in]*/ LONG userSessionId,
        /*[in]*/ BSTR userSid,
        /*[in]*/ BSTR bstrUserHelpCreateBlob,
        /*[out, retval]*/ IRemoteDesktopHelpSession** ppIRemoteDesktopHelpSession
    );

    HRESULT RemoteCreateHelpSessionEx(
        /*[in]*/ BOOL bCacheEntry,
        /*[in]*/ BOOL bEnableResolver,
        /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
        /*[in]*/ LONG timeOut,
        /*[in]*/ LONG userSessionId,
        /*[in]*/ BSTR userSid,
        /*[in]*/ BSTR bstrUserHelpCreateBlob,
        /*[out, retval]*/ RemoteDesktopHelpSessionObj** ppIRemoteDesktopHelpSession
    );

    STDMETHOD(IsValidHelpSession)(
        /*[in]*/ BSTR HelpSessionId,
        /*[in]*/ BSTR HelpSessionPwd
    );

    STDMETHOD(LogSalemEvent)(
        /*[in]*/ long ulEventType,
        /*[in]*/ long ulEventCode,
        /*[in]*/ VARIANT* pEventStrings
    );

    static HRESULT
    AddHelpSessionToCache(
        IN BSTR bstrHelpId,
        IN CComObject<CRemoteDesktopHelpSession>* pIHelpSession
    );

    static HRESULT
    DeleteHelpSessionFromCache(
        IN BSTR bstrHelpId
    );
    
    static void
    TimeoutHelpSesion();

    static void
    LockIDToSessionMapCache()
    {
        gm_HelpIdToHelpSession.Lock();
    }

    static void
    UnlockIDToSessionMapCache()
    {
        gm_HelpIdToHelpSession.Unlock();
    }


    static HRESULT
    LogoffUserHelpSessionCallback(
        IN CComBSTR& bstrHelpId,
        IN HANDLE userData
    );

    static void
    NotifyHelpSesionLogoff(
        DWORD dwLogonId
    );

    static void
    NotifyExpertLogoff( 
        LONG ExpertSessionId,
        BSTR HelpedTicketId
    );

    static void
    NotifyPendingHelpServiceStartup();

    static HRESULT
    NotifyPendingHelpServiceStartCallback(
        IN CComBSTR& bstrHelpId,
        IN HANDLE userData
    );

private:

    HRESULT
    LogSalemEvent(
        IN long ulEventType,
        IN long ulEventCode,
        IN long numStrings = 0,
        IN LPCTSTR* strings = NULL
    );

    static
    RemoteDesktopHelpSessionObj*
    LoadHelpSessionObj(
        IN CRemoteDesktopHelpSessionMgr* pMgr,
        IN BSTR bstrHelpSession,
        IN BOOL bLoadExpiredHelp = FALSE
    );

    static HRESULT
    ExpireUserHelpSessionCallback(
        IN CComBSTR& pHelp,
        IN HANDLE userData
    );

    static HRESULT
    GenerateHelpSessionId(
        OUT CComBSTR& bstrHelpId
    );

    static HRESULT
    AcquireAssistantAccount();

    static HRESULT
    ReleaseAssistantAccount();

    void
    Cleanup();

    HRESULT
    IsUserAllowToGetHelp(
        OUT BOOL* pbAllow
    );

    BOOL
    CheckAccessRights(
        IN CComObject<CRemoteDesktopHelpSession>* pIHelpSess
    );

    HRESULT
    CreateHelpSession(
        IN BOOL bCacheEntry,
        IN BSTR bstrSessName, 
        IN BSTR bstrSessPwd, 
        IN BSTR bstrSessDesc, 
        IN BSTR bstrSessBlob,
        IN LONG userLogonId,
        IN BSTR bstrClientSID,
        OUT RemoteDesktopHelpSessionObj** ppIRemoteDesktopHelpSession
    );
    
    HRESULT
    LoadUserSid();

    LONG m_LogonId;

    PBYTE m_pbUserSid;                  // Client SID.
    DWORD m_cbUserSid;                  // size of client SID.
    CComBSTR m_bstrUserSid;             // For performance reason, convert SID to string
                                        // form once for all.

    //LONG m_lAccountAcquiredByLocal;   // number of reference lock this connection placed on
                                        // help assistant account

    typedef vector< CComBSTR > LocalHelpSessionCache;

    // STL does not like list<CComBSTR>, CComBSTR has & defined.
    //LocalHelpSessionCache m_HelpListByLocal;    // ID of Help Session created by this connection.

    static CCriticalSection gm_AccRefCountCS;  
    
    //
    // COM create a new CRemoteDesktopHelpSessionMgr object for new connection
    // so these values must be static
    //
    static IDToSessionMap gm_HelpIdToHelpSession;

};




#endif //__REMOTEDESKTOPHELPSESSIONMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\helpsess.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpSess.cpp 

Abstract:

    HelpSess.cpp : Implementation of CRemoteDesktopHelpSession

Author:

    HueiWang    2/17/2000

--*/
#include "stdafx.h"

#include <time.h>
#include <Sddl.h>

#include "global.h"
#include "Sessmgr.h"
#include "rdshost.h"
#include "HelpTab.h"
#include "policy.h"
#include "HelpAcc.h"

#include "HelpMgr.h"
#include "HelpSess.h"
#include <rdshost_i.c>
#include "RemoteDesktopUtils.h"
#include "RemoteDesktop.h"

#include <safsessionresolver_i.c>


/////////////////////////////////////////////////////////////////////////////

HRESULT
ConvertSidToAccountName(
    IN CComBSTR& SidString,
    IN BSTR* ppszDomain,
    IN BSTR* ppszUserAcc
    //IN LPTSTR* ppszDomain,
    //IN LPTSTR* ppszUserAcc
    )
/*++

Description:

    Convert a string SID to domain\account.

Parameters:

    ownerSidString : SID in string form to be converted.
    ppszDomain : Pointer to string pointer to receive domain name
    UserAcc : Pointer to string pointer to receive user name

Returns:

    S_OK or error code.

Note:

    Routine uses LocalAlloc() to allocate memory for ppszDomain 
    and ppszUserAcc.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PSID pOwnerSid = NULL;
    //LPTSTR pszAccName = NULL;
    BSTR pszAccName = NULL;
    DWORD  cbAccName = 0;
    //LPTSTR pszDomainName = NULL;
    BSTR pszDomainName = NULL;    
    DWORD  cbDomainName = 0;
    SID_NAME_USE SidType;
    BOOL bSuccess;

    //
    // Convert string form SID to PSID
    //
    if( FALSE == ConvertStringSidToSid( (LPCTSTR)SidString, &pOwnerSid ) )
    {
        // this might also fail if system is in shutdown state.
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( NULL == ppszDomain || NULL == ppszUserAcc )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        MYASSERT( FALSE );
        goto CLEANUPANDEXIT;
    }

    //
    // Lookup user account for this SID
    //
    bSuccess = LookupAccountSid(
                            NULL,
                            pOwnerSid,
                            pszAccName,
                            &cbAccName,
                            pszDomainName,
                            &cbDomainName,
                            &SidType
                        );

    if( TRUE == bSuccess || ERROR_INSUFFICIENT_BUFFER == GetLastError() )
    {
        //pszAccName = (LPWSTR) LocalAlloc( LPTR, (cbAccName + 1) * sizeof(WCHAR) );
        //pszDomainName = (LPWSTR) LocalAlloc( LPTR, (cbDomainName + 1)* sizeof(WCHAR) );

        pszAccName = ::SysAllocStringLen( NULL, (cbAccName + 1) );
        pszDomainName = ::SysAllocStringLen( NULL, (cbDomainName + 1) );

        if( NULL != pszAccName && NULL != pszDomainName )
        {
            bSuccess = LookupAccountSid(
                                    NULL,
                                    pOwnerSid,
                                    pszAccName,
                                    &cbAccName,
                                    pszDomainName,
                                    &cbDomainName,
                                    &SidType
                                );
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            bSuccess = FALSE;
        }
    }

    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
    }
    else
    {
        *ppszDomain = pszDomainName;
        *ppszUserAcc = pszAccName;
        pszDomainName = NULL;
        pszAccName = NULL;
    }

CLEANUPANDEXIT:

    if( NULL != pOwnerSid )
    { 
        LocalFree( pOwnerSid );
    }

    if( NULL != pszAccName )
    {
        //LocalFree( pszAccName );
        ::SysFreeString( pszAccName );
    }

    if( NULL != pszDomainName )
    {
        // LocalFree( pszDomainName );
        ::SysFreeString( pszAccName );
    }

    return HRESULT_FROM_WIN32(dwStatus);
}

/////////////////////////////////////////////////////////////////////////////
//
// CRemoteDesktopHelpSession
//
//

CRemoteDesktopHelpSession::CRemoteDesktopHelpSession() :
    m_ulLogonId(UNKNOWN_LOGONID),
    m_ulHelperSessionId(UNKNOWN_LOGONID),
    m_ulHelpSessionFlag(0)
{
}


CRemoteDesktopHelpSession::~CRemoteDesktopHelpSession()
{
}

void
CRemoteDesktopHelpSession::FinalRelease()
{
    // Releas help entry
    if( NULL != m_pHelpSession )
    {
        DebugPrintf(
                _TEXT("FinalRelease %s on %s\n"),
                (IsUnsolicitedHelp()) ? L"Unsolicted Help" : L"Solicited Help",
                m_bstrHelpSessionId
            );

        // Notify disconnect will check if session is in help and bail out if necessary.
        // there is a timing issue that our SCM notification might came after caller close 
        // all reference counter to our session object, in this case, SCM notification will 
        // trigger reload from database which does not have helper session ID and so will 
        // not notify resolver causing helpee been helped message. 
    
        // We also has AddRef() manually in ResolveXXX call and Release() in 
        // NotifyDisconnect(), this will hold the object in memory until SCM
        // notification comes in.
        NotifyDisconnect();

        CRemoteDesktopHelpSessionMgr::DeleteHelpSessionFromCache( m_bstrHelpSessionId );

        m_pHelpSession->Close();
        m_pHelpSession = NULL;
    }

    ULONG count = _Module.Release();

    DebugPrintf( 
            _TEXT("Module Release by CRemoteDesktopHelpSession() %p %d...\n"),
            this,
            count
        );
}


HRESULT
CRemoteDesktopHelpSession::put_ICSPort(
    IN DWORD newVal
    )
/*++

Description:

    Associate ICS port number with this help session.

Parameters:

    newVal : ICS port number.

Returns:

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( FALSE == IsSessionValid() )
    {
        MYASSERT(FALSE);

        hRes = E_UNEXPECTED;
        return hRes;
    }

    //
    // Need to immediately update the value...
    //
    m_pHelpSession->m_ICSPort.EnableImmediateUpdate(TRUE);
    m_pHelpSession->m_ICSPort = newVal;
    return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::get_ConnectParms(
    OUT BSTR* bstrConnectParms
    )
/*++

Description:

    Retrieve connection parameter for help session.

Parameters:

    bstrConnectParms : Pointer to BSTR to receive connect parms.

Returns:


--*/
{
    HRESULT hRes = S_OK;
    LPTSTR pszAddress = NULL;
    int BufSize;
    DWORD dwBufferRequire;
    DWORD dwNumChars;
    DWORD dwRetry;
    CComBSTR bstrSessId;
    
    CCriticalSectionLocker l(m_HelpSessionLock);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
        goto CLEANUPANDEXIT;
    }

    //
    // Address might have change which might require bigger buffer, retry 
    //
    //
    for(dwRetry=0; dwRetry < MAX_FETCHIPADDRESSRETRY; dwRetry++)
    {
        if( NULL != pszAddress )
        {
            LocalFree( pszAddress );
        }

        //
        // Fetch all address on local machine.
        //
        dwBufferRequire = FetchAllAddresses( NULL, 0 );
        if( 0 == dwBufferRequire )
        {
            hRes = E_UNEXPECTED;
            MYASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }

        pszAddress = (LPTSTR) LocalAlloc( LPTR, sizeof(TCHAR)*(dwBufferRequire+1) );
        if( NULL == pszAddress )
        {
            hRes = E_OUTOFMEMORY;
            goto CLEANUPANDEXIT;
        }

        dwNumChars = FetchAllAddresses( pszAddress, dwBufferRequire );
        MYASSERT( dwNumChars <= dwBufferRequire );
        if( dwNumChars <= dwBufferRequire )
        {
            break;
        }
    }

    if( NULL == pszAddress )
    {
        hRes = E_UNEXPECTED;
        goto CLEANUPANDEXIT;
    }

    //
    // Store the IP address
    //
    m_pHelpSession->m_IpAddress = pszAddress;

    MYASSERT( ((CComBSTR)m_pHelpSession->m_IpAddress).Length() > 0 );
    DebugPrintf(
            _TEXT("IP Address %s\n"),
            (LPTSTR)(CComBSTR)m_pHelpSession->m_IpAddress
        );

    //
    // Create connection parameters
    //
    hRes = get_HelpSessionId( &bstrSessId );
    if( FAILED(hRes) )
    {
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }


    MYASSERT( g_TSSecurityBlob.Length() > 0 );

    *bstrConnectParms = CreateConnectParmsString(
                                            REMOTEDESKTOP_TSRDP_PROTOCOL,
                                            CComBSTR(pszAddress),
                                            CComBSTR(SALEM_CONNECTPARM_UNUSEFILED_SUBSTITUTE),
                                            CComBSTR(SALEM_CONNECTPARM_UNUSEFILED_SUBSTITUTE),
                                            bstrSessId,
                                            CComBSTR(SALEM_CONNECTPARM_UNUSEFILED_SUBSTITUTE),
                                            CComBSTR(SALEM_CONNECTPARM_UNUSEFILED_SUBSTITUTE),
                                            g_TSSecurityBlob
                                        );

    #if DBG
    if( NULL != *bstrConnectParms )
    {
        DebugPrintf(
            _TEXT("Connect Parms %s\n"),
            *bstrConnectParms
        );
    }
    #endif


CLEANUPANDEXIT:

    if( NULL != pszAddress )
    {
        LocalFree( pszAddress );
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::get_TimeOut(
    /*[out, retval]*/ DWORD* pTimeout
    )
/*++

--*/
{
    HRESULT hRes = S_OK;
    BOOL bSuccess;

    CCriticalSectionLocker l(m_HelpSessionLock);


    if( NULL == pTimeout )
    {
        hRes = E_POINTER;
    }
    else if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        FILETIME ft;
        SYSTEMTIME sysTime;

        ft = m_pHelpSession->m_ExpirationTime;
        bSuccess = FileTimeToSystemTime(&ft, &sysTime);
        
        if( TRUE == bSuccess )
        {
            if( sysTime.wYear >= 2038 )
            {
                *pTimeout = INT_MAX;
            }
            else
            {
                struct tm gmTime;

                memset(&gmTime, 0, sizeof(gmTime));
                gmTime.tm_sec = sysTime.wSecond;
                gmTime.tm_min = sysTime.wMinute;
                gmTime.tm_hour = sysTime.wHour;
                gmTime.tm_year = sysTime.wYear - 1900;
                gmTime.tm_mon = sysTime.wMonth - 1;
                gmTime.tm_mday = sysTime.wDay;

                if((*pTimeout = mktime(&gmTime)) == (time_t)-1)
                {
                    *pTimeout = INT_MAX;
                }
            }
        }
        else
        {
            hRes = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT( FALSE );
    }

	return hRes;
}



STDMETHODIMP
CRemoteDesktopHelpSession::put_TimeOut(
    /*[in]*/ DWORD Timeout
    )
/*++

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    LONG MaxTicketExpiry;

    //
    // Get default timeout value from registry, not a critical 
    // error, if we failed, we just default to 30 days
    //
    hRes = PolicyGetMaxTicketExpiry( &MaxTicketExpiry );
    if( FAILED(hRes) || 0 == MaxTicketExpiry )
    {
        MaxTicketExpiry = DEFAULT_MAXTICKET_EXPIRY;
    }

    if( Timeout > MaxTicketExpiry )
    {
        hRes = S_FALSE;
        Timeout = MaxTicketExpiry;
    }

    time_t curTime;
    FILETIME ftTimeOut;

    // Get the current time.
    time(&curTime);

    // time out in seconds
    curTime += Timeout;

    // Convert to FILETIME
    UnixTimeToFileTime( curTime, &ftTimeOut );

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        if( FALSE == m_pHelpSession->IsEntryExpired() )
        {
            //
            // operator =() update registry immediately
            //
            m_pHelpSession->m_ExpirationTime = ftTimeOut;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::get_HelpSessionId(
    OUT BSTR *pVal
    )
/*++

Routine Description:

    Get help session ID.

Parameters:

    pVal : return Help session ID of this help session instance.

Returns:

    S_OK
    E_OUTOFMEMORY
    E_UNEXPECTED

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);


    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {

        DebugPrintf(
                _TEXT("get_HelpSessionId() on %s\n"),
                m_bstrHelpSessionId
            );

        MYASSERT( m_pHelpSession->m_SessionId->Length() > 0 );
        if( m_pHelpSession->m_SessionId->Length() > 0 )
        {
	        *pVal = m_pHelpSession->m_SessionId->Copy();

            if( NULL == *pVal )
            {
                hRes = E_OUTOFMEMORY;
            }
        }
        else
        {
            hRes = E_UNEXPECTED;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT( FALSE );
    }

	return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::get_UserLogonId(
    OUT long *pVal
    )
/*++

Routine Description:

    Get user's TS session ID, note, non-ts session or Win9x always
    has 0 as user logon id.

Parameters:

    pVal : Return user logon ID.

Returns:

    S_OK

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        *pVal = m_ulLogonId;
        if( UNKNOWN_LOGONID == m_ulLogonId )
        {
            hRes = S_FALSE;
        }
    }
    else
    {
        MYASSERT( FALSE );
        hRes = E_UNEXPECTED;
    }
           
	return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::get_AssistantAccountName(
    OUT BSTR *pVal
    )
/*++

Routine Description:

    Get help assistant account name associated with this
    help session.

Parameters:

    pVal : Return help assistant account name associated 
           with this help session.

Returns:

    S_OK
    E_OUTOFMEMORY

--*/
{
    HRESULT hRes = S_OK;

    // Don't need a lock here.

    if( NULL != pVal )
    {
        CComBSTR accName;

        hRes = g_HelpAccount.GetHelpAccountNameEx( accName );
        if( SUCCEEDED(hRes) )
        {
            *pVal = accName.Copy();
            if( NULL == *pVal )
            {
                hRes = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        hRes = E_POINTER;
    }

	return hRes;
}

STDMETHODIMP 
CRemoteDesktopHelpSession::get_HelpSessionName(
    OUT BSTR *pVal
    )
/*++

Routine Description:

    Get help session name associated with this
    help session.

Parameters:

    pVal : Return help session name associated 
           with this help session.

Returns:

    S_OK
    S_FALSE         No Help Session Name
    E_OUTOFMEMORY   Out of memory
    E_POINTER       Invalid parameter
    HRESULT_FROM_WIN32( ERROR_LOCK_VIOLATION );

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);


    if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if( NULL != m_pHelpSession )
    {
        if( m_pHelpSession->m_SessionName->Length() > 0 )
        {
	        *pVal = m_pHelpSession->m_SessionName->Copy();
            if( NULL == *pVal )
            {
                hRes = E_OUTOFMEMORY;
            }
        }
        else
        {
            hRes = S_FALSE;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }

	return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::put_HelpSessionName(
    IN BSTR newVal
    )
/*++

Routine Description:

    Set help session name associated with this
    help session.

Parameters:

    newVal : New help session name.

Returns:

    S_OK
    E_OUTOFMEMORY

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( m_pHelpSession != NULL )
    {
        //
        // NULL will reset help session name
        //

        //
        // operator =() update registry immediately
        //
        m_pHelpSession->m_SessionName = newVal;
        if( !((CComBSTR)m_pHelpSession->m_SessionName == newVal) )
        {
            hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        MYASSERT(FALSE);
        hRes = E_UNEXPECTED;
    }
       
	return hRes;
}

STDMETHODIMP 
CRemoteDesktopHelpSession::put_HelpSessionPassword(
    IN BSTR newVal
    )
/*++

Routine Description:

    Change help session password associated with this
    help session.

Parameters:

    newVal : New help session password.

Returns:

    S_OK
    E_OUTOFMEMORY       Out of memory

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( NULL != m_pHelpSession )
    {

        //
        // NULL will reset password
        //

        //
        // operator =() update registry immediately
        //
	    m_pHelpSession->m_SessionPwd = newVal;

        if( !((CComBSTR)m_pHelpSession->m_SessionPwd == newVal) )
        {
            hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT( FALSE );
    }

	return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::get_HelpSessionDescription(
    OUT BSTR *pVal
    )
/*++

Routine Description:

    Get help session description associated with this
    help session.

Parameters:

    pVal : Return help session description associated 
           with this help session.

Returns:

    S_OK
    S_FALSE         No Description
    E_OUTOFMEMORY   Out of memory
    E_POINTER       Invalid argument
    
--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( m_pHelpSession != NULL )
    {

        if( m_pHelpSession->m_SessionDesc->Length() > 0 )
        {
            *pVal = m_pHelpSession->m_SessionDesc->Copy();
            if( NULL == *pVal )
            {
                hRes = E_OUTOFMEMORY;
            }
        }
        else
        {
            hRes = S_FALSE;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }

	return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::put_HelpSessionDescription(
    IN BSTR newVal
    )
/*++

Routine Description:

    Change help session description associated with this
    help session.

Parameters:

    newVal : new help session description associated 
           with this help session.

Returns:

    S_OK

Note:

    Help Session name and description is reserved for future use

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( NULL != m_pHelpSession )
    {

        //
        // NULL will reset description
        //

        //
        // operator =() update registry immediately
        //
        m_pHelpSession->m_SessionDesc = newVal;

        if( !((CComBSTR)m_pHelpSession->m_SessionDesc == newVal) )
        {
            hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }

	return hRes;
}

STDMETHODIMP
CRemoteDesktopHelpSession::get_EnableResolver(
    OUT BOOL* pVal
    )
/*++

Routine Description:

    Return Session Resolver's CLSID for this help session.

Parameters:

    pVal : Pointer to BSTR to receive pointer to Resolver's CLSID.

Returns:

    S_OK
    E_POINTER           Invalid argument

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        *pVal = ((long)m_pHelpSession->m_EnableResolver > 0) ? TRUE : FALSE;
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }
            
    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::put_EnableResolver(
    IN BOOL newVal
    )
/*++

Routine Description:

    Set Session Resolver's CLSID, if input is NULL or empty 
    string, Help Session Manager will not invoke resolver.

Parameters:

    Val : Resolver's CLSID

Returns:

    S_OK 
    E_OUTOFMEMORY

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);


    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( NULL != m_pHelpSession )
    {
        //
        // NULL will reset resolver's ID for this session
        //

        //
        // operator =() update registry immediately
        //
        m_pHelpSession->m_EnableResolver = newVal;
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::get_ResolverBlob(
    OUT BSTR* pVal
    )
/*++

Routine Description:

    Return blob for session resolver to map help session
    to user session/

Parameters:

    pVal : Pointer to BSTR to receive blob.

Returns:

    S_OK
    S_FALSE             No blob
    E_OUTOFMEMORY
    E_POINTER

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {

        if( m_pHelpSession->m_SessResolverBlob->Length() > 0 )
        {
            *pVal = m_pHelpSession->m_SessResolverBlob->Copy();
            if( NULL == *pVal )
            {
                hRes = E_OUTOFMEMORY;
            }
        }
        else
        {
            hRes = S_FALSE;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;

        MYASSERT(FALSE);
    }
            
    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::put_ResolverBlob(
    IN BSTR newVal
    )
/*++

Routine Description:

    Add/change blob which will be passed to session 
    resolver to map/find user session associated with this
    help session, Help Session Manager does not interpret this
    blob.

Parameters:

    newVal : Pointer to new blob.

Returns:

    S_OK
    E_OUTOFMEMORY       Out of memory

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( NULL != m_pHelpSession )
    {
        //
        // NULL will reset resolver's ID for this session
        //

        //
        // operator =() update registry immediately
        //
        m_pHelpSession->m_SessResolverBlob = newVal;
        if( !((CComBSTR)m_pHelpSession->m_SessResolverBlob == newVal) )
        {
            hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::get_HelpSessionCreateBlob(
    OUT BSTR* pVal
    )
/*++

Routine Description:

    Return blob for session resolver to map help session
    to user session/

Parameters:

    pVal : Pointer to BSTR to receive blob.

Returns:

    S_OK
    S_FALSE             No blob
    E_OUTOFMEMORY
    E_POINTER

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {

        if( m_pHelpSession->m_SessionCreateBlob->Length() > 0 )
        {
            *pVal = m_pHelpSession->m_SessionCreateBlob->Copy();
            if( NULL == *pVal )
            {
                hRes = E_OUTOFMEMORY;
            }
        }
        else
        {
            hRes = S_FALSE;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;

        MYASSERT(FALSE);
    }
            
    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::put_HelpSessionCreateBlob(
    IN BSTR newVal
    )
/*++

Routine Description:

    Add/change blob which will be passed to session 
    resolver to map/find user session associated with this
    help session, Help Session Manager does not interpret this
    blob.

Parameters:

    newVal : Pointer to new blob.

Returns:

    S_OK
    E_OUTOFMEMORY       Out of memory

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);


    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( NULL != m_pHelpSession )
    {
        //
        // operator =() update registry immediately
        //
        m_pHelpSession->m_SessionCreateBlob = newVal;
        if( !((CComBSTR)m_pHelpSession->m_SessionCreateBlob == newVal) )
        {
            hRes = E_OUTOFMEMORY;
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }

    return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::get_UserHelpSessionRemoteDesktopSharingSetting(
    /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS* pSetting
    )
/*++

Routine Description:

    Return help session's RDS setting.

Parameters:

    pSetting : Pointer to REMOTE_DESKTOP_SHARING_CLASS to 
               receive session's RDS setting.

Returns:

    S_OK
    E_POINTER       Invalid argument.

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( NULL == pSetting )
    {
        hRes = E_POINTER;
    }
    else if(FALSE == IsSessionValid())
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        *pSetting = (REMOTE_DESKTOP_SHARING_CLASS)(long)m_pHelpSession->m_SessionRdsSetting;
    }
    else
    {
        hRes = E_UNEXPECTED;

        MYASSERT(FALSE);
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::put_UserHelpSessionRemoteDesktopSharingSetting(
    /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS Setting
    )
/*++

Routine Description:

    Set help session's RDS setting.

Parameters:

    Setting : New RDS setting.

Returns:

    S_OK
    S_FALSE                                             New setting is overrided with 
                                                        policy setting.
    HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED )           User not allow to get help.
    HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION )       Other help session already has this set
    HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED )         Session is not connected

    HRESULT_FROM_WIN32( WinStationQueryInformation() );
    E_OUTOFMEMORY

Note:

    Only one help session can change the RDS setting, all other help session
    will get HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION ) error return.

    REMOTE_DESKTOP_SHARING_CLASS also define priviledge
    level, that is user with NO_DESKTOP_SHARING can't
    adjust his/her sharing class, user with CONTROLDESKTOP_PERMISSION_REQUIRE
    can't adjust his/her sharing class to CONTROLDESKTOP_PERMISSION_NOT_REQUIRE
    however, he/she can reset to NO_DESKTOP_SHARING, VIEWDESKTOP_PERMISSION_REQUIRE

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( FALSE == IsClientSessionCreator() )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    else if( NULL != m_pHelpSession )
    {
        //
        // operator =() update registry immediately
        //
        m_pHelpSession->m_SessionRdsSetting = Setting;
    }
    else
    {
        hRes = E_UNEXPECTED;

        MYASSERT(FALSE);
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSession::get_AllowToGetHelp(
    /*[out, retval]*/ BOOL* pVal
    )
/*++

Routine Description:

    Determine if user created this help session is
    allowed to get help or not, this is possible that policy change
    after user re-logon.

Parameters:

    pVal : Pointer to BOOL to receive result.

Returns:

    S_OK
    HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED )  User is not connected any more.
    E_UNEXPECTED;   Internal error.
    
--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);
   
    
    if( NULL == pVal )
    {
        hRes = E_POINTER;
    }
    else if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        if( UNKNOWN_LOGONID == m_ulLogonId )
        {
            hRes = HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED );
        }
        else if( m_pHelpSession->m_UserSID->Length() == 0 )
        {
            hRes = E_UNEXPECTED;
            MYASSERT(FALSE);
        }
        else
        {
            *pVal = IsUserAllowToGetHelp(
                                    m_ulLogonId,
                                    (LPCTSTR) CComBSTRtoLPTSTR( (CComBSTR)m_pHelpSession->m_UserSID )
                                );
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }


    return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSession::DeleteHelp()
/*++

Routine Description:

    Delete this help session

Parameters:

    None.

Returns:

    S_OK or error code from 
    Help Session Manager's DeleteHelpSession().

--*/
{
    HRESULT hRes = S_OK;

    CRemoteDesktopHelpSessionMgr::LockIDToSessionMapCache();

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        DebugPrintf(
                _TEXT("CRemoteDesktopHelpSession::DeleteHelp() %s...\n"),
                m_bstrHelpSessionId
            );

        // 
        // BUGBUG : Refer to timing bug, no notification about terminating 
        // shadow, and we can't reset session's shadow class. force a 
        // reset here for now.
        //
        ResetSessionRDSSetting();

        //
        // if we are not been help, just delete it, if we are in the middle
        // of help, deleting it from cache and database entry will cause
        // Resolver's OnDisconnect() never got call resulting in user
        // lock in resolver never got release so we update the expiration
        // date to current, expiration thread or next load will trigger
        // actual delete.
        //
        if(GetHelperSessionId() == UNKNOWN_LOGONID)
        { 
            CRemoteDesktopHelpSessionMgr::DeleteHelpSessionFromCache( (CComBSTR) m_pHelpSession->m_SessionId );
            if( (DWORD)(long)m_pHelpSession->m_ICSPort > 0 )
            {
                //
                // Destructor does not close ICS port, we only close
                // ICS port when help is deleted.
                //
                ClosePort( (DWORD)(long)m_pHelpSession->m_ICSPort );
            }

            // Delete will release the entry ref. count
            hRes = m_pHelpSession->Delete();
            m_pHelpSession = NULL;
            m_bDeleted = TRUE;
        }
        else
        {
            put_TimeOut(0);
        }
    }
    else
    {
        hRes = E_UNEXPECTED;

        MYASSERT(FALSE);
    }

    CRemoteDesktopHelpSessionMgr::UnlockIDToSessionMapCache();
	return hRes;
}

void
CRemoteDesktopHelpSession::ResolveTicketOwner()
/*++

Description:

    Convert ticket owner SID to domain\account.

Parameters:

    None.

Returns:

--*/
{
    //LPTSTR pszNoviceDomain = NULL;
    //LPTSTR pszNoviceName = NULL;

    BSTR pszNoviceDomain = NULL;
    BSTR pszNoviceName = NULL;

    HRESULT hRes = S_OK;
    MYASSERT( IsSessionValid() );

    if( IsSessionValid() )
    {
        hRes = ConvertSidToAccountName( 
                                    (CComBSTR)m_pHelpSession->m_UserSID, 
                                    &pszNoviceDomain,
                                    &pszNoviceName
                                );
    }
    else
    {
        // help session ticket is deleted
        hRes = E_HANDLE;
    }


    //
    // NO ASSERT, ConvertSidToAccountName() already assert.
    //

    if( SUCCEEDED(hRes) )
    {
        //
        // DO NOT FREE the memory, once string is attached to CComBSTR, 
        // CComBSTR will free it at destructor
        //
        m_EventLogInfo.bstrNoviceDomain.Attach(pszNoviceDomain);
        m_EventLogInfo.bstrNoviceAccount.Attach(pszNoviceName);

        //m_EventLogInfo.bstrNoviceDomain = pszNoviceDomain;
        //m_EventLogInfo.bstrNoviceAccount = pszNoviceName;

        //LocalFree(pszNoviceDomain);
        //LocalFree(pszNoviceName);
    }
    else
    {
        m_EventLogInfo.bstrNoviceDomain = g_UnknownString;
        m_EventLogInfo.bstrNoviceAccount = (CComBSTR)m_pHelpSession->m_UserSID;
    }

    return;
}

void
CRemoteDesktopHelpSession::ResolveHelperInformation(
    IN ULONG HelperSessionId,
    OUT CComBSTR& bstrExpertIpAddressFromClient, 
    OUT CComBSTR& bstrExpertIpAddressFromServer
    )
/*++

Description:

    Retrieve from TermSrv regarding HelpAssistant session's IP address send from
    expert (mstscax send this) and IP address of client machine retrive from TCPIP

Parameters:

    HelperSessionId : TS session ID of help assistant session.
    bstrExpertIpAddressFromClient : IP address send from mstscax.
    bstrExpertIpAddressFromServer : IP address that TS retrieve from tcpip stack.

Returns:

    

--*/
{
    HRESULT hRes = S_OK;
    WINSTATIONCLIENT winstationClient;
    WINSTATIONREMOTEADDRESS winstationRemoteAddress;
    ULONG winstationInfoLen;
    DWORD dwLength = 0;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Retrieve client IP address passed from client    
    winstationInfoLen = 0;
    ZeroMemory( &winstationClient, sizeof(winstationClient) );
    if(!WinStationQueryInformation(
                              SERVERNAME_CURRENT,
                              HelperSessionId,
                              WinStationClient,
                              (PVOID)&winstationClient,
                              sizeof(winstationClient),
                              &winstationInfoLen
                          ))
    {
        dwStatus = GetLastError();
        DebugPrintf(
                _TEXT("WinStationQueryInformation() query WinStationClient return %d\n"), dwStatus
            );
     
        // Critical error?, fro now, log as 'unknown'.
        bstrExpertIpAddressFromClient = g_UnknownString;
    }
    else
    {
        bstrExpertIpAddressFromClient = winstationClient.ClientAddress;
    }

    //
    // Retrieve client IP address retrieve from server TCPIP
    winstationInfoLen = 0;
    ZeroMemory( &winstationRemoteAddress, sizeof(winstationRemoteAddress) );

    if(!WinStationQueryInformation(
                              SERVERNAME_CURRENT,
                              HelperSessionId,
                              WinStationRemoteAddress,
                              (PVOID)&winstationRemoteAddress,
                              sizeof(winstationRemoteAddress),
                              &winstationInfoLen
                          ))
    {
        dwStatus = GetLastError();

        DebugPrintf(
                _TEXT("WinStationQueryInformation() query WinStationRemoteAddress return %d %d %d\n"), 
                dwStatus,
                sizeof(winstationRemoteAddress),
                winstationInfoLen
            );

        // Critical error?, for now, log as 'unknown'.
        bstrExpertIpAddressFromServer = g_UnknownString;
    }
    else
    {
        if( AF_INET == winstationRemoteAddress.sin_family )
        {
            // refer to in_addr structure.
            struct in_addr S;
            S.S_un.S_addr = winstationRemoteAddress.ipv4.in_addr;

            bstrExpertIpAddressFromServer = inet_ntoa(S);
            if(bstrExpertIpAddressFromServer.Length() == 0 )
            {
                MYASSERT(FALSE);
                bstrExpertIpAddressFromServer = g_UnknownString;
            }
        }
        else
        {
            // we are not yet support IPV6 address, calling WSAAddressToString() will fail with error.
            bstrExpertIpAddressFromServer = g_UnknownString;
        }
    }


CLEANUPANDEXIT:

    return;
}


STDMETHODIMP
CRemoteDesktopHelpSession::ResolveUserSession(
    IN BSTR resolverBlob,
    IN BSTR expertBlob,
    LONG CallerProcessId,
    OUT ULONG_PTR* phHelpCtr,
    OUT LONG* pResolverErrCode,
    OUT long* plUserSession
    )
/*++

Routine Description:

    Resolve a user help session to user TS session.

Parameters:

    plUserSession : Pointer to long to receive user TS session.

Returns:

    S_OK
    HRESULT_FROM_WIN32( ERROR_NO_ASSOCIATION )    No resolver for this help session
    HRESULT_FROM_WIN32( ERROR_INVALID_DATA )      Can't convert 
    result from CoCreateInstance() or IRDSCallback

-*/
{
    HRESULT hRes = S_OK;
    UUID ResolverUuid;
    RPC_STATUS rpcStatus;
    ISAFRemoteDesktopCallback* pIResolver;
    long sessionId;
    long HelperSessionId;
    int resolverRetCode;
    WINSTATIONINFORMATION HelperWinstationInfo;
    DWORD dwStatus;
    ULONG winstationInfoLen;

    CComBSTR bstrExpertAddressFromClient;
    CComBSTR bstrExpertAddressFromTSServer;

    CCriticalSectionLocker l(m_HelpSessionLock);

    DWORD dwEventLogCode;

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
        *pResolverErrCode = SAFERROR_HELPSESSIONEXPIRED;
        return hRes;
    }
    
    if( NULL == m_pHelpSession || NULL == pResolverErrCode )
    {
        hRes = E_POINTER;
        *pResolverErrCode = SAFERROR_INVALIDPARAMETERSTRING;
        MYASSERT(FALSE);
        return hRes;
    }

    if( m_pHelpSession->m_UserSID->Length() == 0 )
    {
        hRes = E_UNEXPECTED;
        *pResolverErrCode = SAFERROR_UNKNOWNSESSMGRERROR;
        goto CLEANUPANDEXIT;
    }


    //
    // must have user logon ID if we are not using resolver,
    // in pure SALEM SDK, multiple expert can connect
    // using same help ticket, only one can shadow.
    //
    *pResolverErrCode = SAFERROR_NOERROR;
    if( (long)m_pHelpSession->m_EnableResolver == 0 )
    {
        if( UNKNOWN_LOGONID != m_ulLogonId )
        {
            *plUserSession = (long) m_ulLogonId;
        }
        else
        {            
            // no resolver for this help session
            hRes = HRESULT_FROM_WIN32( ERROR_NO_ASSOCIATION );

            // user already logoff
            *pResolverErrCode = SAFERROR_USERNOTFOUND;
        }

        // 
        // We are not using resolver, bail out.
        //
        goto CLEANUPANDEXIT;
    }

      
    //
    // Retrieve Caller's TS session ID
    //
    hRes = ImpersonateClient();

    if( FAILED(hRes) )
    {
        *pResolverErrCode = SAFERROR_UNKNOWNSESSMGRERROR;
        return hRes;
    }

    HelperSessionId = GetUserTSLogonId();

    EndImpersonateClient();

    ResolveHelperInformation(
                            HelperSessionId, 
                            bstrExpertAddressFromClient, 
                            bstrExpertAddressFromTSServer 
                        );

    DebugPrintf(
            _TEXT("Expert Session ID %d, Expert Address %s %s\n"),
            HelperSessionId,
            bstrExpertAddressFromClient,
            bstrExpertAddressFromTSServer
        );
   
    DebugPrintf(
            _TEXT("Novice %s %s\n"),
            m_EventLogInfo.bstrNoviceDomain,
            m_EventLogInfo.bstrNoviceAccount
        );


    // 
    // Check if helper session is still active, under stress, we might 
    // get this call after help assistant session is gone.
    // 
    ZeroMemory( &HelperWinstationInfo, sizeof(HelperWinstationInfo) );
    winstationInfoLen = 0;
    if(!WinStationQueryInformation(
                              SERVERNAME_CURRENT,
                              HelperSessionId,
                              WinStationInformation,
                              (PVOID)&HelperWinstationInfo,
                              sizeof(HelperWinstationInfo),
                              &winstationInfoLen
                          ))
    {
        dwStatus = GetLastError();

        DebugPrintf(
                _TEXT("WinStationQueryInformation() return %d\n"), dwStatus
            );

        hRes = HRESULT_FROM_WIN32( dwStatus );
        *pResolverErrCode = SAFERROR_SESSIONNOTCONNECTED;
        goto CLEANUPANDEXIT;
    }

    if( HelperWinstationInfo.ConnectState != State_Active )
    {
        DebugPrintf(
                _TEXT("Helper session is %d"), 
                HelperWinstationInfo.ConnectState
            );

        // Helper Session is not active, can't provide help
        hRes = HRESULT_FROM_WIN32( ERROR_NO_ASSOCIATION );
        *pResolverErrCode = SAFERROR_SESSIONNOTCONNECTED;
        goto CLEANUPANDEXIT;
    }

    //
    // Either resolver is pending or already in progress,
    // we have exclusive lock so we are safe to reference 
    // m_hExpertDisconnect.
    //
    if( UNKNOWN_LOGONID != m_ulHelperSessionId )
    {
        //
        // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_USERALREADYHELP
        //
        _Module.LogSessmgrEventLog( 
                            EVENTLOG_INFORMATION_TYPE,
                            SESSMGR_I_REMOTEASSISTANCE_USERALREADYHELP,
                            m_EventLogInfo.bstrNoviceDomain,
                            m_EventLogInfo.bstrNoviceAccount,
                            (IsUnsolicitedHelp())? g_URAString : g_RAString,
                            bstrExpertAddressFromClient, 
                            bstrExpertAddressFromTSServer,
                            SAFERROR_HELPEEALREADYBEINGHELPED
                        );
                              
        *pResolverErrCode = SAFERROR_HELPEEALREADYBEINGHELPED;
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;
    }

    //
    // We assume User is going to accept help 
    // 1) When expert disconnect before user accept/deny request, 
    //    our service logoff notification can find this object and invoke
    //    OnDisconnect() into resolver.
    // 2) If another expert connect with same ticket and resolver still
    //    pending response from user, we can bail out right away.
    // 
    InterlockedExchange( (LPLONG)&m_ulHelperSessionId, (LONG)HelperSessionId );

    // 
    // Cache the SID in object
    //
    m_HelpSessionOwnerSid = (CComBSTR)m_pHelpSession->m_UserSID;

    hRes = CoInitialize( NULL );
    if( FAILED(hRes) )
    {
        // failed to coinitialize,
        *pResolverErrCode = SAFERROR_INTERNALERROR;
        goto CLEANUPANDEXIT;
    }

    //
    // Load resolver
    hRes = LoadResolverFromGIT( &pIResolver );

    if( SUCCEEDED(hRes) )
    {
        CComBSTR bstrResolverBlob;

        bstrResolverBlob.Attach(resolverBlob);

        sessionId = (long)m_ulLogonId;

        DebugPrintf(
                _TEXT("User Session ID %d\n"),
                m_ulLogonId
            );

        //
        // keep a copy of blob, we need this to send to resolver on
        // disconnect, note, caller can pass its blob so we need to 
        // keep a copy of it.
        //
        if( bstrResolverBlob.Length() == 0 )
        {
            m_ResolverConnectBlob = (CComBSTR)m_pHelpSession->m_SessResolverBlob;
        }
        else
        {
            m_ResolverConnectBlob = bstrResolverBlob;
        }

        hRes = pIResolver->ResolveUserSessionID( 
                                            m_ResolverConnectBlob, 
                                            (CComBSTR)m_pHelpSession->m_UserSID,
                                            expertBlob,
                                            (CComBSTR)m_pHelpSession->m_SessionCreateBlob,
                                            &sessionId,
                                            CallerProcessId,
                                            phHelpCtr,
                                            &resolverRetCode
                                        );

        *pResolverErrCode = resolverRetCode;
        bstrResolverBlob.Detach();
        pIResolver->Release();

        DebugPrintf(
                _TEXT("Resolver returns 0x%08x\n"),
                hRes
            );

        if( SUCCEEDED(hRes) )
        {
            *plUserSession = sessionId;

            //
            // Update session ID, take the value return from Resolver.
            //
            m_ulLogonId = sessionId;

            //
            // Add this expert to logoff monitor list, when expert session's
            // rdsaddin terminates, we will inform resolver, reason for this
            // is TS might not notify us of expert session disconnect because
            // some system component popup a dialog in help assistant session
            // and termsrv has no other way but to terminate entire session.
            //
            dwStatus = MonitorExpertLogoff( 
                                        CallerProcessId, 
                                        HelperSessionId,
                                        m_bstrHelpSessionId
                                    );

            if( ERROR_SUCCESS != dwStatus )
            {
                //
                // If we can't add to resolver list, we immediate notify 
                // resolver and return error or we will run into 'helpee
                // already been help problem
                //
                
                DebugPrintf(
                        _TEXT("MonitorExpertLogoff() failed with %d\n"), dwStatus
                    );

                // directly invoke resolver here.
                hRes = pIResolver->OnDisconnect( 
                                        m_ResolverConnectBlob,
                                        m_HelpSessionOwnerSid,
                                        m_ulLogonId
                                    );

                MYASSERT( SUCCEEDED(hRes) );
                resolverRetCode = SAFERROR_UNKNOWNSESSMGRERROR;
            }
            else
            {
    
                //
                // It is possible for caller to close all reference counter to our object
                // and cause a release of our object, if SCM notification comes in after
                // our object is deleted from cache, SCM will reload from database entry
                // and that does not have helper session ID and will not invoke NotifyDisconnect().
                //
                AddRef();
            }
        }
        else
        {
            //
            // User does not accept help from this helpassistant session,
            // reset HelpAssistant session ID
            //
            InterlockedExchange( (LPLONG)&m_ulHelperSessionId, (LONG)UNKNOWN_LOGONID );
        }

        switch( resolverRetCode )
        {
            case SAFERROR_NOERROR :

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_BEGIN

                //
                // Cache event log info so we don't have to retrieve it again.
                //
                m_EventLogInfo.bstrExpertIpAddressFromClient = bstrExpertAddressFromClient;
                m_EventLogInfo.bstrExpertIpAddressFromServer = bstrExpertAddressFromTSServer;
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_BEGIN;
                break;

            case SAFERROR_HELPEECONSIDERINGHELP:
            case SAFERROR_HELPEEALREADYBEINGHELPED:

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_USERALREADYHELP
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_USERALREADYHELP;
                break;

            case SAFERROR_HELPEENOTFOUND:

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_INACTIVEUSER
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_INACTIVEUSER;
                break;

            case SAFERROR_HELPEENEVERRESPONDED:

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_TIMEOUT
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_TIMEOUT;
                break;

            case SAFERROR_HELPEESAIDNO:

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_USERREJECT
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_USERREJECT;
                break;

            default:

                // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_UNKNOWNRESOLVERERRORCODE
                dwEventLogCode = SESSMGR_I_REMOTEASSISTANCE_UNKNOWNRESOLVERERRORCODE;
                break;
        }

        _Module.LogSessmgrEventLog( 
                            EVENTLOG_INFORMATION_TYPE,
                            dwEventLogCode,
                            m_EventLogInfo.bstrNoviceDomain,
                            m_EventLogInfo.bstrNoviceAccount,
                            (IsUnsolicitedHelp())? g_URAString : g_RAString,
                            bstrExpertAddressFromClient, 
                            bstrExpertAddressFromTSServer,
                            resolverRetCode
                        );

    }
    else
    {
        *pResolverErrCode = SAFERROR_CANTOPENRESOLVER;
    } 

    CoUninitialize();

CLEANUPANDEXIT:

    DebugPrintf(
            _TEXT("ResolverUserSession returns 0x%08x\n"),
            hRes
        );

    return hRes;
}
  


HRESULT
CRemoteDesktopHelpSession::NotifyDisconnect()
/*++

Routine Description:

    Notify Session Resolver that client is dis-connecting to help session.

Parameters:

    bstrBlob : Blob to be passed to resolver, NULL if 
               use ResolverBlob property.

Returns:

E_HANDLE							        Invalid session, database entry has been deleted but refcount > 0
E_UNEXPECTED						        Internal error
HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED )	Client disconnected
HRESULT_FROM_WIN32( ERROR_NO_ASSOCIATION )	No Resolver
S_FALSE                                     No Resolver
HRESULT_FROM_WIN32( ERROR_INVALID_DATA )	Invalid Resolver ID

Error code from CoCreateInstance() and resolver's OnConnect() method.

--*/
{
    HRESULT hRes = S_OK;
    ISAFRemoteDesktopCallback* pIResolver;

    DebugPrintf(
            _TEXT("OnDisconnect() - Helper Session ID %d\n"),
            m_ulHelperSessionId
        );

    CCriticalSectionLocker l(m_HelpSessionLock);

    //
    // If we are not been help, just bail out.
    //
    if( UNKNOWN_LOGONID != m_ulHelperSessionId )
    {
        //
        // LOGEVENT : SESSMGR_I_REMOTEASSISTANCE_END
        //

        //
        // always cache help session creator at ResolveUserSession()
        // so this value can't be empty.
        //
        MYASSERT( m_HelpSessionOwnerSid.Length() > 0 );
        MYASSERT( m_ResolverConnectBlob.Length() > 0 );
        if( m_HelpSessionOwnerSid.Length() == 0 ||
            m_ResolverConnectBlob.Length() == 0 )
        {
            MYASSERT(FALSE);
            hRes = E_UNEXPECTED;
            goto CLEANUPANDEXIT;
        }

        hRes = CoInitialize( NULL );
    
        if( FAILED(hRes) )
        {
            goto CLEANUPANDEXIT;
        }

        //
        // Load resolver
        hRes = LoadResolverFromGIT( &pIResolver );

        MYASSERT( SUCCEEDED(hRes) );

        if( SUCCEEDED(hRes) )
        {
            DebugPrintf(
                        _TEXT("OnDisconnect() - Notify Resolver, %s\n%s\n%d\n"),
                        m_ResolverConnectBlob,
                        m_HelpSessionOwnerSid,
                        m_ulLogonId
                    );
                
            hRes = pIResolver->OnDisconnect( 
                                    m_ResolverConnectBlob,
                                    m_HelpSessionOwnerSid,
                                    m_ulLogonId
                                );

            pIResolver->Release();
            m_ResolverConnectBlob.Empty();
            m_HelpSessionOwnerSid.Empty();

            InterlockedExchange( (LPLONG)&m_ulHelperSessionId, (LONG)UNKNOWN_LOGONID );

            //
            // It is possible for caller to close all reference counter to our object
            // and cause a release of our object, if SCM notification comes in after
            // our object is deleted from cache, SCM will reload from database entry
            // and that does not have helper session ID and will not invoke NotifyDisconnect().
            //
            Release();

            _Module.LogSessmgrEventLog( 
                                EVENTLOG_INFORMATION_TYPE,
                                SESSMGR_I_REMOTEASSISTANCE_END,
                                m_EventLogInfo.bstrNoviceDomain,
                                m_EventLogInfo.bstrNoviceAccount,
                                (IsUnsolicitedHelp())? g_URAString : g_RAString,
                                m_EventLogInfo.bstrExpertIpAddressFromClient, 
                                m_EventLogInfo.bstrExpertIpAddressFromServer,
                                ERROR_SUCCESS
                            );
        }

        CoUninitialize();
    }
       

CLEANUPANDEXIT:

    return hRes;
}

STDMETHODIMP
CRemoteDesktopHelpSession::EnableUserSessionRdsSetting(
    IN BOOL bEnable
    )
/*++

Routine Description:

    Enable/restore user session shadow setting.



--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else
    {
        if( TRUE == bEnable )
        {
            hRes = ActivateSessionRDSSetting();
        }
        else
        {
            hRes = ResetSessionRDSSetting();
        }
    }

    return hRes;
}


HRESULT
CRemoteDesktopHelpSession::ActivateSessionRDSSetting()
{
    HRESULT hRes = S_OK;
    DWORD dwStatus;
    REMOTE_DESKTOP_SHARING_CLASS userRDSDefault;
    BOOL bAllowToGetHelp;

    MYASSERT( TRUE == IsSessionValid() );

    //
    // check if help session user is logon
    //
    if( UNKNOWN_LOGONID == m_ulLogonId )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED );
        goto CLEANUPANDEXIT;
    }

    //
    // Make sure user can get help, this is possible since
    // policy might change after user re-logon to help session
    //
    hRes = get_AllowToGetHelp( &bAllowToGetHelp );

    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    if( FALSE == bAllowToGetHelp )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;
    }

    //
    // Retrieve current user session's shadow setting.
    //
    dwStatus = GetUserRDSLevel( m_ulLogonId, &userRDSDefault );
    if( ERROR_SUCCESS != dwStatus )
    {
        hRes = HRESULT_FROM_WIN32( dwStatus );
        goto CLEANUPANDEXIT;
    }

    if( NO_DESKTOP_SHARING != userRDSDefault )
    {
        //
        // Force reset on user session shadow setting only if 
        // user session is allowed remote control.
        //
        dwStatus = ConfigUserSessionRDSLevel( m_ulLogonId, m_pHelpSession->m_SessionRdsSetting );
        hRes = HRESULT_FROM_WIN32( dwStatus );

        DebugPrintf(
                _TEXT("ConfigUserSessionRDSLevel to %d returns 0x%08x\n"),
                (DWORD)m_pHelpSession->m_SessionRdsSetting,
                hRes
            );
    }
    else
    {
        // return S_FALSE and let shadow fail
        hRes = S_FALSE;

        DebugPrintf( _TEXT("TS User session does not remote control\n") );
    }



CLEANUPANDEXIT:

    return hRes;
}

HRESULT
CRemoteDesktopHelpSession::ResetSessionRDSSetting()
{
    HRESULT hRes = S_OK;

    MYASSERT( TRUE == IsSessionValid() );

    //
    // check if user is log on
    //
    if( UNKNOWN_LOGONID == m_ulLogonId )
    {
        hRes = HRESULT_FROM_WIN32( ERROR_VC_DISCONNECTED );
    }

    //
    // We don't do anything since TermSrv will reset shadow
    // config back to original value if shadower is help 
    // assistant.
    //

CLEANUPANDEXIT:

    return hRes;
}


///////////////////////////////////////////////////////////////
//
// Private Function
// 

HRESULT
CRemoteDesktopHelpSession::put_UserLogonId(
    IN long newVal
    )
/*++

Routine Description:

    Set user TS session for current Help Session

Parameters:

    newVal : New TS user session

Returns:

    S_OK

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_HelpSessionLock);
    

    if( FALSE == IsSessionValid() )
    {
        hRes = E_HANDLE;
    }
    else if( NULL != m_pHelpSession )
    {
        //MYASSERT( UNKNOWN_LOGONID == m_ulLogonId );

        //
        // User TS session ID is not persisted to registry
        //
        m_ulLogonId = newVal;
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    // private routine, assert if failed
    MYASSERT( SUCCEEDED(hRes) );

	return hRes;
}

BOOL
CRemoteDesktopHelpSession::IsEqualSid(
    IN const CComBSTR& bstrSid
    )
/*++

Routine Description:

    Compare user's SID.

Parameters:

    bstrSid : SID to be compared.

Returns:

    TRUE/FALSE

--*/
{
    CCriticalSectionLocker l(m_HelpSessionLock);

    if( NULL == m_pHelpSession )
    {
        MYASSERT(FALSE);
        return FALSE;
    }

    return (TRUE == IsSessionValid()) ? ((CComBSTR)m_pHelpSession->m_UserSID == bstrSid) : FALSE;
}


BOOL
CRemoteDesktopHelpSession::VerifyUserSession(
    IN const CComBSTR& bstrUserSid,
    IN const CComBSTR& bstrSessPwd
    )
/*++

Routine Description:

    Verify user help session password.

Parameters:

    bstrUserSid : calling client's user SID.
    bstrSessName : Help session name, not use currently.
    bstrSessPwd : Help Session Password to be verified.

Returns:

    TRUE/FALSE

--*/
{
    DWORD dwStatus;
    BOOL bReturn = FALSE;

    CCriticalSectionLocker l(m_HelpSessionLock);

    if( NULL == m_pHelpSession )
    {
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }


    #if DISABLESECURITYCHECKS 
    if( (CComBSTR)m_pHelpSession->m_SessionName == HELPSESSION_UNSOLICATED )
    {
        // use console session
        m_ulLogonId = 0;
    }
    #endif

    if( FALSE == IsSessionValid() )
    {
        // Help Session is invalid
        goto CLEANUPANDEXIT;
    }

    bReturn = TRUE;

CLEANUPANDEXIT:

    return bReturn;
}


HRESULT
CRemoteDesktopHelpSession::InitInstance(
    IN CRemoteDesktopHelpSessionMgr* pMgr,
    IN CComBSTR& bstrClientSid,
    IN PHELPENTRY pHelpEntry
    )
/*++

Routine Description:

    Initialize a CRemoteDesktopHelpSession object.

Parameters:


Returns:

    S_OK

--*/
{
    HRESULT hRes = S_OK;

    if( NULL != pHelpEntry )
    {
        m_pSessMgr = pMgr;
        m_pHelpSession = pHelpEntry;
        m_bstrClientSid = bstrClientSid;
        m_bstrHelpSessionId = pHelpEntry->m_SessionId;
    }
    else
    {
        hRes = HRESULT_FROM_WIN32( ERROR_INTERNAL_ERROR );
        MYASSERT( SUCCEEDED(hRes) );
    }

    return hRes;
}


HRESULT
CRemoteDesktopHelpSession::CreateInstance(
    IN CRemoteDesktopHelpSessionMgr* pMgr,
    IN CComBSTR& bstrClientSid,
    IN PHELPENTRY pHelpEntry,
    OUT RemoteDesktopHelpSessionObj** ppRemoteDesktopHelpSession
    )
/*++

Routine Description:

    Create an instance of help session.

Parameters:

    pMgr : Pointer to help session manager object.
    ppRemoteDesktopHelpSession : Return a pointer to help session instance.

Returns:

    S_OK
    E_OUTOFMEMORY
    Error code in impersonating client

--*/
{
    HRESULT hRes = S_OK;
    RemoteDesktopHelpSessionObj* p = NULL;

    hRes = RemoteDesktopHelpSessionObj::CreateInstance( &p );
    if( SUCCEEDED(hRes) )
    {
        hRes = p->InitInstance( 
                            pMgr, 
                            bstrClientSid,
                            pHelpEntry
                        );

        if( SUCCEEDED(hRes) )
        {
            p->AddRef();
            *ppRemoteDesktopHelpSession = p;
        }
        else
        {
            p->Release();
        }
    }

    return hRes;
}

HRESULT
CRemoteDesktopHelpSession::BeginUpdate()
{
    HRESULT hRes;

    MYASSERT( NULL != m_pHelpSession );

    if( NULL != m_pHelpSession )
    {
        hRes = m_pHelpSession->BeginUpdate();
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    return hRes;
}

HRESULT
CRemoteDesktopHelpSession::CommitUpdate()
{
    HRESULT hRes;

    //
    // Update all entries.
    //
    MYASSERT( NULL != m_pHelpSession );

    if( NULL != m_pHelpSession )
    {
        hRes = m_pHelpSession->CommitUpdate();
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    return hRes;
}

HRESULT
CRemoteDesktopHelpSession::AbortUpdate()
{
    HRESULT hRes;

    //
    // Update all entries.
    //
    MYASSERT( NULL != m_pHelpSession );
    if( NULL != m_pHelpSession )
    {
        hRes = m_pHelpSession->AbortUpdate();
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    return hRes;
}

BOOL
CRemoteDesktopHelpSession::IsHelpSessionExpired()
{
    MYASSERT( NULL != m_pHelpSession );

    return (NULL != m_pHelpSession) ? m_pHelpSession->IsEntryExpired() : TRUE;
}


BOOL
CRemoteDesktopHelpSession::IsClientSessionCreator()
{
    BOOL bStatus;

    //
    //  NOTE:  This function checks to make sure the caller is the user that
    //         created the Help Session.  For Whistler, we enforce that Help
    //         Sessions only be created by apps running as SYSTEM.  Once
    //         created, the creating app can pass the object to any other app
    //         running in any other context.  This function will get in the
    //         way of this capability so it simply returns TRUE for now.
    //   
    return TRUE;      

    if( m_pHelpSession )
    {
        bStatus = (/* (CComBSTR) */m_pHelpSession->m_UserSID == m_bstrClientSid);
        if( FALSE == bStatus )
        {
            bStatus = (m_pHelpSession->m_UserSID == g_LocalSystemSID);
        }
    }
    else
    {
        bStatus = FALSE;
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\helpsess.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpSess.h 

Abstract:

    Declaration of the CRemoteDesktopHelpSession

Author:

    HueiWang    2/17/2000

--*/
#ifndef __REMOTEDESKTOPHELPSESSION_H_
#define __REMOTEDESKTOPHELPSESSION_H_

#include "resource.h"       // main symbols
#include "policy.h"

class CRemoteDesktopHelpSession;
class CRemoteDesktopHelpSessionMgr;

typedef struct __EventLogInfo {
    CComBSTR bstrNoviceDomain;                  // Ticket owner domain.
    CComBSTR bstrNoviceAccount;                 // Ticket owner account.
    CComBSTR bstrExpertIpAddressFromClient;     // IP address passed from TS client
    CComBSTR bstrExpertIpAddressFromServer;     // Retrieve from TermSrv, IOCTL call.
} EventLogInfo;


//#define ALLOW_ALL_ACCESS_SID _TEXT("bb6e1cb1-7ab3-4596-a7ef-c02f49dc5a90")
#define UNKNOWN_LOGONID 0xFFFFFFFF
#define UNKNOWN_LOGONID_STRING L"0"


#define HELPSESSIONFLAG_UNSOLICITEDHELP   0x80000000


/////////////////////////////////////////////////////////////////////////////
// CRemoteDesktopHelpSession
class ATL_NO_VTABLE CRemoteDesktopHelpSession : 
    public CComObjectRootEx<CComMultiThreadModel>,
    //public CComCoClass<CRemoteDesktopHelpSession, &CLSID_RemoteDesktopHelpSession>,
    public IDispatchImpl<IRemoteDesktopHelpSession, &IID_IRemoteDesktopHelpSession, &LIBID_RDSESSMGRLib>
{
friend class CRemoteDesktopHelpSessionMgr;

public:
    CRemoteDesktopHelpSession();
    ~CRemoteDesktopHelpSession();

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPHELPSESSION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRemoteDesktopHelpSession)
    COM_INTERFACE_ENTRY(IRemoteDesktopHelpSession)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

    HRESULT
    FinalConstruct()
    {
        ULONG count = _Module.AddRef();
        
        m_bDeleted = FALSE;

        DebugPrintf( 
                _TEXT("Module AddRef by CRemoteDesktopHelpSession() %p %d...\n"), 
                this,
                count 
            );

        return S_OK;
    }

    void
    FinalRelease();

        
// IRemoteDesktopHelpSession
public:

    STDMETHOD(get_TimeOut)(
        /*[out, retval]*/ DWORD* Timeout
    );

    STDMETHOD(put_TimeOut)(
        /*[in]*/ DWORD Timeout
    );

    STDMETHOD(get_HelpSessionId)(
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_UserLogonId)(
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(get_AssistantAccountName)(
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_HelpSessionName)(
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(put_HelpSessionName)(
        /*[in]*/ BSTR newVal
    );

    STDMETHOD(put_HelpSessionPassword)(
        /*[in]*/ BSTR newVal
    );

    STDMETHOD(get_HelpSessionDescription)(
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(put_HelpSessionDescription)(
        /*[in]*/ BSTR newVal
    );

    STDMETHOD(get_EnableResolver)(
        /*[out, retval]*/ BOOL* pVal
    );

    STDMETHOD(put_EnableResolver)(
        /*[in]*/ BOOL Val
    );

    STDMETHOD(get_HelpSessionCreateBlob)(
        /*[out, retval]*/ BSTR* pVal
    );

    STDMETHOD(put_HelpSessionCreateBlob)(
        /*[in]*/ BSTR Val
    );

    STDMETHOD(get_ResolverBlob)(
        /*[out, retval]*/ BSTR* pVal
    );

    STDMETHOD(put_ResolverBlob)(
        /*[in]*/ BSTR Val
    );

    STDMETHOD(get_UserHelpSessionRemoteDesktopSharingSetting)(
        /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS* pLevel
    );

    STDMETHOD(put_UserHelpSessionRemoteDesktopSharingSetting)(
        /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS Level
    );

    STDMETHOD(get_UserPolicyRemoteDesktopSharingSetting)(
        /*[out, retval]*/ REMOTE_DESKTOP_SHARING_CLASS* pLevel
        )
    /*++

    --*/
    {
        DWORD dwStatus;

        if( NULL == pLevel )
        {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
        else if( UNKNOWN_LOGONID != m_ulLogonId )
        {
            dwStatus = GetUserRDSLevel( m_ulLogonId, pLevel );
        }

        return HRESULT_FROM_WIN32( dwStatus );
    }

    STDMETHOD(get_AllowToGetHelp)(
        /*[out, retval]*/ BOOL* pVal
    );

    STDMETHOD(get_ConnectParms)(
        /*[out, ret]*/ BSTR* bstrConnectParms
    );


    STDMETHOD(DeleteHelp)();

    STDMETHOD(ResolveUserSession)(
        /*[in]*/ BSTR bstrResolverBlob,
        /*[in]*/ BSTR bstrExpertBlob,
        /*[in]*/ LONG CallerProcessId,
        /*[out]*/ ULONG_PTR* hHelpCtr,
        /*[out]*/ LONG* pResolverErrCode,
        /*[out, retval]*/ long* plUserSession
    );

    STDMETHOD(EnableUserSessionRdsSetting)(
        /*[in]*/ BOOL bEnable
    );

    HRESULT NotifyDisconnect();

    BOOL
    IsHelpSessionExpired();

    void
    SetHelpSessionFlag(
        IN ULONG flags
        )
    /*++

    --*/
    {
        m_ulHelpSessionFlag = flags;
    }

    ULONG
    GetHelpSessionFlag()
    /*++

    --*/
    {
        return m_ulHelpSessionFlag;
    }


    // Create an instance of help session object
    static HRESULT
    CreateInstance(
        IN CRemoteDesktopHelpSessionMgr* pMgr,
        IN CComBSTR& bstrClientSid,
        IN PHELPENTRY pHelp,
        OUT RemoteDesktopHelpSessionObj** ppRemoteDesktopHelpSession
    );

    //
    // Retrieve HelpAssisant session ID which is providing help
    // to this object
    ULONG
    GetHelperSessionId() {
        return m_ulHelperSessionId;
    }

    //
    // Convert ticket owner SID to domain\account
    //
    void
    ResolveTicketOwner();

protected:

    HRESULT
    InitInstance(
        IN CRemoteDesktopHelpSessionMgr* pMgr,
        IN CComBSTR& bstrClientSid,
        IN PHELPENTRY pHelpEntry
    );

private:

    void
    ResolveHelperInformation(
        ULONG HelperSessionId,
        CComBSTR& bstrExpertIpAddressFromClient, 
        CComBSTR& bstrExpertIpAddressFromServer
    );

    HRESULT
    ResolveTicketOwnerInformation(
        CComBSTR& ownerSidString,
        CComBSTR& Domain,
        CComBSTR& UserAcc
    );

    VOID
    SetHelperSessionId( ULONG HelperSessionId ) {
        m_ulHelperSessionId = HelperSessionId;
        return;
    }

    BOOL
    IsClientSessionCreator();

    BOOL 
    IsSessionValid()
    {
        return (FALSE == m_bDeleted && NULL != m_pHelpSession);
    }

    HRESULT
    ActivateSessionRDSSetting();

    HRESULT
    ResetSessionRDSSetting();

    HRESULT
    BeginUpdate();

    HRESULT
    CommitUpdate();

    HRESULT
    AbortUpdate();

    HRESULT
    put_UserLogonId(
        IN long newVal
    );

    HRESULT
    put_ICSPort(
        IN DWORD newVal
    );

    HRESULT
    put_UserSID(
        IN BSTR bstrUserSID
        )
    /*++

    --*/
    {
        HRESULT hRes = S_OK;

        MYASSERT( m_pHelpSession->m_UserSID->Length() == 0 );

        m_pHelpSession->m_UserSID = bstrUserSID;
        if( !((CComBSTR)m_pHelpSession->m_UserSID == bstrUserSID) )
        {
            hRes = E_OUTOFMEMORY;
        }

        return hRes;
    }

    BOOL
    IsEqualSid(
        IN const CComBSTR& bstrSid
    );

    BOOL
    IsCreatedByUserSession(
        IN const long lUserSessionId
        )
    /*++

    --*/
    {
        return m_ulLogonId == lUserSessionId;
    }

    BOOL
    VerifyUserSession(
        IN const CComBSTR& bstrUserSid,
        IN const CComBSTR& bstrSessPwd
    );

    BOOL
    IsUnsolicitedHelp()
    {
        DebugPrintf(
                _TEXT("Help Session Flag : 0x%08x\n"),
                m_ulHelpSessionFlag
            );

        return (m_ulHelpSessionFlag & HELPSESSIONFLAG_UNSOLICITEDHELP);
    }

    //
    // Help Session Object Lock.
    //
    CCriticalSection m_HelpSessionLock;

    //
    // Pointer to Help Entry in registry
    //
    PHELPENTRY m_pHelpSession;

    //
    // TS session ID or 0xFFFFFFFF
    //
    ULONG m_ulLogonId;

    CRemoteDesktopHelpSessionMgr* m_pSessMgr;
    
    BOOL m_bDeleted;

    //
    // calling client SID
    //
    CComBSTR m_bstrClientSid;

    //
    // Following is cached in this object in case our help is
    // expired.
    //
    CComBSTR m_bstrHelpSessionId;
    CComBSTR m_ResolverConnectBlob;
    CComBSTR m_HelpSessionOwnerSid;

    //
    // HelpAssistant session ID that is providing 
    // help to this object or is pending user acceptance on
    // invitation
    //
    ULONG m_ulHelperSessionId;  

    //
    // Cached ticket owner (domain\user account) and 
    // helper information for event logging
    //
    EventLogInfo m_EventLogInfo;

    //
    // Various flag for this session
    //
    ULONG m_ulHelpSessionFlag;
};






#endif //__REMOTEDESKTOPHELPSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\helpacc.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpAcc.h 

Abstract:

    Declaration of the HelpAssistantAccount structure

Author:

    HueiWang    2/17/2000

--*/
#ifndef __HELPASSISTANTACCOUNT_H__
#define __HELPASSISTANTACCOUNT_H__

#include "stdafx.h"
#include <lm.h>

#include <wtsapi32.h>

#include <winsta.h>
#include "helper.h"

#define HELPACCOUNTPROPERLYSETUP \
    _TEXT("20ed87e2-3b82-4114-81f9-5e219ed4c481-SALEMHELPACCOUNT")


#define MAX_USERNAME_LENGTH LM20_UNLEN

//
// Default Help Assistant account name
//
#define HELPASSISTANTACCOUNT_NAME  SALEMHELPASSISTANTACCOUNT_NAME

//
// LSA key to store help assistant account password and SID
//
#define HELPASSISTANTACCOUNT_PASSWORDKEY SALEMHELPASSISTANTACCOUNT_PASSWORDKEY
#define HELPASSISTANTACCOUNT_SIDKEY  SALEMHELPASSISTANTACCOUNT_SIDKEY

#define HELPASSISTANTACCOUNT_EMPTYPASSWORD  L""

#if __WIN9XBUILD__

// pre-define USER SID for Win9x box.
#define WIN9X_USER_SID _TEXT("1-1-1-1-1-1")

#endif


#define RDSADDINEXECNAME _TEXT("rdsaddin.exe")


typedef BOOL (WINAPI* PWTSSetUserConfigW)(
                 IN LPWSTR pServerName,
                 IN LPWSTR pUserName,
                 IN WTS_CONFIG_CLASS WTSConfigClass,
                 IN LPWSTR pBuffer,
                 IN DWORD DataLength
);

#define REGVALUE_PERSONAL_WKS_TSSETTING _TEXT("TS Connection")

typedef struct __HelpAssistantAccount 
{
private:

    static CCriticalSection gm_HelpAccountCS;

    static DWORD gm_dwAccErrCode;

    HRESULT
    GetHelpAccountScript(
        CComBSTR& bstrScript
    );

    HRESULT
    CacheHelpAccountSID();


    HRESULT
    LookupHelpAccountSid(
        IN LPTSTR pszAccName,
        OUT PSID* ppSid,
        OUT DWORD* pcbSid
    );

    HRESULT
    ConfigHelpAccountTSSettings(
        IN LPTSTR pszAccName,
        IN LPTSTR pszInitProgram
    );

    DWORD
    EnableAccountRights(
        BOOL bEnable,
        DWORD dwNumRights,
        LPTSTR* rights
    );

public:

    static CComBSTR gm_bstrHelpAccountPwd;
    static CComBSTR gm_bstrHelpAccountName;

    static PBYTE gm_pbHelpAccountSid;
    static DWORD gm_cbHelpAccountSid;


    ~__HelpAssistantAccount()
    {
        FreeMemory(gm_pbHelpAccountSid);
    } 

    HRESULT
    Initialize(
        BOOL bVerifyPassword = TRUE
    );

    BOOL
    IsValid() 
    { 
        return ERROR_SUCCESS == gm_dwAccErrCode; 
    }

    HRESULT
    DeleteHelpAccount();

    HRESULT
    CreateHelpAccount(
        LPCTSTR pszPassword = NULL
    );

    HRESULT
    SetupHelpAccountTSSettings();

    HRESULT
    SetupHelpAccountTSRights(
        IN BOOL bDel,
        IN BOOL bEnable,
        IN BOOL bDelExisting,
        IN DWORD dwPermissions
    );

    HRESULT
    ResetHelpAccountPassword(
        LPCTSTR pszPassword = NULL
    );

    HRESULT
    GetHelpAccountNameEx( CComBSTR& bstrValue )
    {
        DWORD dwStatus = ERROR_SUCCESS;

        bstrValue = gm_bstrHelpAccountName;
        if( 0 == bstrValue.Length() )
        {
            MYASSERT(0 == bstrValue.Length());
            dwStatus = ERROR_INTERNAL_ERROR;
        }
        return HRESULT_FROM_WIN32( dwStatus );
    }

    BOOL
    IsAccountHelpAccount(
        IN PBYTE pbSid,
        IN DWORD cbSid
    );

    HRESULT
    EnableRemoteInteractiveRight(
        BOOL bEnable
    );

    HRESULT
    EnableHelpAssistantAccount(
        BOOL bEnable
    );

} HelpAssistantAccount;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\helpmgr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpMgr.cpp

Abstract:

    HelpMgr.cpp : Implementation of CRemoteDesktopHelpSessionMgr

Author:

    HueiWang    2/17/2000

--*/
#include "stdafx.h"

#include "global.h"
#include "policy.h"
#include "RemoteDesktopUtils.h"


//
// CRemoteDesktopHelpSessionMgr Static member variable 
//

#define DEFAULT_UNSOLICATED_HELP_TIMEOUT IDLE_SHUTDOWN_PERIOD

CCriticalSection CRemoteDesktopHelpSessionMgr::gm_AccRefCountCS;

// Help Session ID to help session instance cache map
IDToSessionMap CRemoteDesktopHelpSessionMgr::gm_HelpIdToHelpSession;

// Pointer to GIT
LPGLOBALINTERFACETABLE  g_GIT = NULL;
DWORD g_ResolverCookie = 0;
CCriticalSection g_GITLock;

//
// Expert logoff monitor list, this is used for cleanup at
// the shutdown time so we don't have any opened handle.
//
EXPERTLOGOFFMONITORLIST g_ExpertLogoffMonitorList;



VOID CALLBACK
ExpertLogoffCallback(
    PVOID pContext,
    BOOLEAN bTimerOrWaitFired
    )
/*++

Routine Description:

    This routine is invoked by thread pool when handle to rdsaddin is signal.

Parameters:

    pContext : Pointer to user data.
    bTimerOrWaitFired : TRUE if wait timeout, FALSE otherwise.

Return:

    None.

Note :

    Refer to MSDN RegisterWaitForSingleObject() for function parameters.

--*/
{
    PEXPERTLOGOFFSTRUCT pExpertLogoffStruct = (PEXPERTLOGOFFSTRUCT)pContext;
    BSTR bstrHelpedTicketId = NULL;

    WINSTATIONINFORMATION ExpertWinStation;
    DWORD ReturnLength;

    DWORD dwStatus;
    BOOL bSuccess;

    MYASSERT( FALSE == bTimerOrWaitFired );
    MYASSERT( NULL != pContext );

    DebugPrintf(
            _TEXT("ExpertLogoffCallback()...\n")
        );

    // Our wait is forever so can't be timeout.
    if( FALSE == bTimerOrWaitFired )
    {
        if( NULL != pExpertLogoffStruct )
        {
            DebugPrintf(
                    _TEXT("Expert %d has logoff\n"),
                    pExpertLogoffStruct->ExpertSessionId
                );

            MYASSERT( NULL != pExpertLogoffStruct->hWaitObject );
            MYASSERT( NULL != pExpertLogoffStruct->hWaitProcess );
            MYASSERT( pExpertLogoffStruct->bstrHelpedTicketId.Length() > 0 );
            MYASSERT( pExpertLogoffStruct->bstrWinStationName.Length() > 0 );

            if( pExpertLogoffStruct->bstrWinStationName.Length() > 0 )
            {
                //
                // Reset the winstation asap since rdsaddin might get kill
                // and termsrv stuck on waiting for winlogon to exit and
                // shadow won't terminate until termsrv reset the winstation
                //
                ZeroMemory( &ExpertWinStation, sizeof(ExpertWinStation) );

                bSuccess = WinStationQueryInformation( 
                                                SERVERNAME_CURRENT,
                                                pExpertLogoffStruct->ExpertSessionId,
                                                WinStationInformation,
                                                (PVOID)&ExpertWinStation,
                                                sizeof(WINSTATIONINFORMATION),
                                                &ReturnLength
                                            );

                if( TRUE == bSuccess || ERROR_CTX_CLOSE_PENDING == GetLastError() )
                {
                    //
                    // Cases:
                    // 1) Termsrv mark Helper session as close pending and
                    //    function will return FALSE.
                    // 2) If somehow, session ID is re-use, session name
                    //    will change then we compare cached name.
                    // Both cases, we will force a reset, however, only hope
                    // shadow ended and if mobsync still up, session will
                    // take a long time to terminate.  
                    //
                    if( FALSE == bSuccess || pExpertLogoffStruct->bstrWinStationName == CComBSTR(ExpertWinStation.WinStationName) )
                    {
                        DebugPrintf(
                                _TEXT("Resetting winstation name %s, id %d\n"),
                                pExpertLogoffStruct->bstrWinStationName,
                                pExpertLogoffStruct->ExpertSessionId
                            );

                        // don't wait for it to return, can't do much if this fail
                        WinStationReset( 
                                        SERVERNAME_CURRENT,
                                        pExpertLogoffStruct->ExpertSessionId,
                                        FALSE
                                    );


                        DebugPrintf(
                                _TEXT("WinStationReset return %d\n"),
                                GetLastError()
                            );
                    }
                }
                else
                {
                    DebugPrintf(
                            _TEXT("Expert logoff failed to get winstation name %d\n"),
                            GetLastError()
                        );
                }
            }

            if( pExpertLogoffStruct->bstrHelpedTicketId.Length() > 0 )
            {

                //
                // detach pointer from CComBSTR, we will free it after handling 
                // WM_HELPERRDSADDINEXIT, purpose of this is not to duplicate
                // string again.
                //
                bstrHelpedTicketId = pExpertLogoffStruct->bstrHelpedTicketId.Detach();

                DebugPrintf(
                        _TEXT("Posting WM_HELPERRDSADDINEXIT...\n")
                    );

                PostThreadMessage(
                            _Module.dwThreadID,
                            WM_HELPERRDSADDINEXIT,
                            pExpertLogoffStruct->ExpertSessionId,
                            (LPARAM) bstrHelpedTicketId
                        );
            }

            //
            // Remove from monitor list.
            //
            {
                EXPERTLOGOFFMONITORLIST::LOCK_ITERATOR it = g_ExpertLogoffMonitorList.find(pExpertLogoffStruct);

                if( it != g_ExpertLogoffMonitorList.end() )
                {
                    g_ExpertLogoffMonitorList.erase(it);
                }
                else
                {
                    MYASSERT(FALSE);
                }
            }

            // Destructor will take care of closing handle
            delete pExpertLogoffStruct;
        }
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////
DWORD
MonitorExpertLogoff(
    IN LONG pidToWaitFor,
    IN LONG expertSessionId,
    IN BSTR bstrHelpedTicketId
    )
/*++

Routine Description:

    Monitor expert logoff, specifically, we wait on rdsaddin process handle, once 
    signal, we immediately notify resolver that expert has logoff.

Parameters:

    pidToWaitFor : RDSADDIN PID
    expertSessionId : TS session ID that rdsaddin is running.
    bstrHelpedTickerId : Help ticket ID that expert is helping.

Returns:

    ERROR_SUCCESS or error code.


--*/
{
    HANDLE hRdsaddin = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    PEXPERTLOGOFFSTRUCT pExpertLogoffStruct = NULL;

    WINSTATIONINFORMATION ExpertWinStation;
    DWORD ReturnLength;

    DebugPrintf(
            _TEXT("CServiceModule::RegisterWaitForExpertLogoff...\n")
        );

    pExpertLogoffStruct = new EXPERTLOGOFFSTRUCT;
    if( NULL == pExpertLogoffStruct )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }


    ZeroMemory( &ExpertWinStation, sizeof(ExpertWinStation) );

    bSuccess = WinStationQueryInformation( 
                                    SERVERNAME_CURRENT,
                                    expertSessionId,
                                    WinStationInformation,
                                    (PVOID)&ExpertWinStation,
                                    sizeof(WINSTATIONINFORMATION),
                                    &ReturnLength
                                );

    if( FALSE == bSuccess )
    {
        //
        // what do we do, we still need to inform resolver of disconnect,
        // but we will not be able to reset winstation
        //
        dwStatus = GetLastError();
        DebugPrintf(
                _TEXT("WinStationQueryInformation() failed with %d...\n"),
                dwStatus
            );

        MYASSERT(FALSE);
    }
    else
    {
        pExpertLogoffStruct->bstrWinStationName = ExpertWinStation.WinStationName;
        DebugPrintf(
                _TEXT("Helper winstation name %s...\n"),
                pExpertLogoffStruct->bstrWinStationName
            );
    }

    //
    // Open rdsaddin.exe, if failed, bail out and don't continue
    // help.
    //
    pExpertLogoffStruct->hWaitProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, pidToWaitFor );
    if( NULL == pExpertLogoffStruct->hWaitProcess )
    {
        dwStatus = GetLastError();
        DebugPrintf(
                _TEXT( "OpenProcess() on rdsaddin %d failed with %d\n"),
                pidToWaitFor,
                dwStatus
            );

        goto CLEANUPANDEXIT;
    }

    pExpertLogoffStruct->ExpertSessionId = expertSessionId;
    pExpertLogoffStruct->bstrHelpedTicketId = bstrHelpedTicketId;

    //
    // Register wait on rdsaddin process handle.
    //
    bSuccess = RegisterWaitForSingleObject(
                                    &(pExpertLogoffStruct->hWaitObject),
                                    pExpertLogoffStruct->hWaitProcess,
                                    (WAITORTIMERCALLBACK) ExpertLogoffCallback,
                                    pExpertLogoffStruct,
                                    INFINITE,
                                    WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE
                                );

    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();

        DebugPrintf(
                _TEXT("RegisterWaitForSingleObject() failed with %d\n"),
                dwStatus
            );
    }
    else
    {
        // store this into monitor list
        try {
            g_ExpertLogoffMonitorList[pExpertLogoffStruct] = pExpertLogoffStruct;
        }
        catch(...) {
            // Memory allocation failed
            dwStatus = GetLastError();
        }
    }

CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        if( NULL != pExpertLogoffStruct )
        {
            // destructor will take care of closing handle
            delete pExpertLogoffStruct;
        }
    }
    
    DebugPrintf(
            _TEXT( "MonitorExpertLogoff() return %d\n"),
            dwStatus
        );
    
    return dwStatus;
}

VOID
CleanupMonitorExpertList()
/*++

Routine Description:

    Routine to clean up all remaining expert logoff monitor list, this
    should be done right before we shutdown so we don't have any handle
    leak.

Parameters:

    None.

Returns:

    None.

--*/
{
    EXPERTLOGOFFMONITORLIST::LOCK_ITERATOR it = 
                                            g_ExpertLogoffMonitorList.begin();

    DebugPrintf(
            _TEXT("CleanupMonitorExpertList() has %d left\n"),
            g_ExpertLogoffMonitorList.size()
        );

    for(; it != g_ExpertLogoffMonitorList.end(); it++ )
    {
        if( NULL != (*it).second )
        {
            // destructor will take care of closing handle
            delete (*it).second;
            (*it).second = NULL;
        }
    }

    g_ExpertLogoffMonitorList.erase_all();

    return;
}

HRESULT
InitializeGlobalInterfaceTable()
/*++

Routine Description:

    Initialize GIT interface.

Parameters:

    None.

Returns.    

--*/
{
    CCriticalSectionLocker l(g_GITLock);
    HRESULT hRes = S_OK;

    if( NULL == g_GIT )
    {
        //
        // Create global interface table
        //
        hRes = CoCreateInstance(
                        CLSID_StdGlobalInterfaceTable, 
                        NULL, 
                        CLSCTX_INPROC_SERVER,
                        IID_IGlobalInterfaceTable, 
                        (LPVOID*)&g_GIT
                    );
    }

    return hRes;
}

HRESULT
UnInitializeGlobalInterfaceTable()
/*++

Routine Description:

    Initialize GIT interface.

Parameters:

    None.

Returns.    

--*/
{
    CCriticalSectionLocker l(g_GITLock);

    if( NULL != g_GIT )
    {
        g_GIT->Release();
        g_GIT = NULL;
    }

    return S_OK;
}
    

HRESULT
RegisterResolverWithGIT(
    ISAFRemoteDesktopCallback* pResolver
    )
/*++

Routine Description:

    Register Resolver interface with GIT.

Parameter:

    pResolver : Pointer to resolver.

Returns:


--*/
{
    HRESULT hRes;
    CCriticalSectionLocker l(g_GITLock);

    MYASSERT(NULL != g_GIT);

    //
    // register resolver interface with GIT, resolver has some 
    // data structure that depends on single instance.
    //
    IUnknown* pResolveIUnknown = NULL;

    hRes = pResolver->QueryInterface( 
                                IID_IUnknown, 
                                (void **)&pResolveIUnknown 
                            );

    if( SUCCEEDED(hRes) )
    {
        hRes = g_GIT->RegisterInterfaceInGlobal(
                                    pResolveIUnknown,
                                    IID_ISAFRemoteDesktopCallback,
                                    &g_ResolverCookie
                                );

        pResolveIUnknown->Release();
    }

    return hRes;
}

HRESULT
LoadResolverFromGIT( 
    OUT ISAFRemoteDesktopCallback** ppResolver
    )
/*++

Routine Description:

    Load resolver interface from Global Interface Table, Resolver has data that depends
    on single instance.

Parameters:

    ppResolver : Pointer to ISAFRemoteDesktopCallback* to receive Resolver pointer

Returns:

    S_OK or error code.

--*/
{
    HRESULT hr;
    CCriticalSectionLocker l(g_GITLock);


    if( g_GIT != NULL )
    {
        hr = g_GIT->GetInterfaceFromGlobal(
                                    g_ResolverCookie,
                                    IID_ISAFRemoteDesktopCallback,
                                    (LPVOID *)ppResolver
                                );
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        MYASSERT(FALSE);
    }

    return hr;
}

//-----------------------------------------------------------

HRESULT 
ImpersonateClient()
/*

Routine Description:

    Impersonate client

Parameter:

    None.

Returns:

    S_OK or return code from CoImpersonateClient

--*/
{
    HRESULT hRes;

#if __WIN9XBUILD__

    // CoImpersonateClient() on Win9x is not supported.

    hRes = S_OK;

#else

    hRes = CoImpersonateClient();

#endif

    return hRes;
}

//-----------------------------------------------------------

void
EndImpersonateClient()
/*

Routine Description:

    End impersonating client

Parameter:

    None.

Returns:

    S_OK or return code from CoRevertToSelf

--*/
{
#if __WIN9XBUILD__


#else

    HRESULT hRes;

    hRes = CoRevertToSelf();
    MYASSERT( SUCCEEDED(hRes) );

#endif

    return;
}


HRESULT
CRemoteDesktopHelpSessionMgr::AddHelpSessionToCache(
    IN BSTR bstrHelpId,
    IN CComObject<CRemoteDesktopHelpSession>* pIHelpSession
    )
/*++

Routine Description:

    Add help session object to global cache.

Parameters:

    bstrHelpId : Help Session ID.
    pIHelpSession : Pointer to help session object.

Returns:

    S_OK.
    E_UNEXPECTED
    HRESULT_FROM_WIN32( ERROR_FILE_EXITS )

--*/
{
    HRESULT hRes = S_OK;
       
    IDToSessionMap::LOCK_ITERATOR it = gm_HelpIdToHelpSession.find( bstrHelpId );

    if( it == gm_HelpIdToHelpSession.end() )
    {
        try {

            DebugPrintf(
                    _TEXT("Adding Help Session %s to cache\n"),
                    bstrHelpId
                );

            gm_HelpIdToHelpSession[ bstrHelpId ] = pIHelpSession;
        }
        catch(...) {
            hRes = E_UNEXPECTED;
            MYASSERT( SUCCEEDED(hRes) );
            throw;
        }
    }
    else
    {
        hRes = HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
    }

    return hRes;
}


HRESULT
CRemoteDesktopHelpSessionMgr::ExpireUserHelpSessionCallback(
    IN CComBSTR& bstrHelpId,
    IN HANDLE userData
    )
/*++

Routine Description:

    Expire help session call back routine, refer to EnumHelpEntry()

Parameters:

    bstrHelpId : ID of help session.
    userData : Handle to user data.

Returns:

    S_OK.

--*/
{
    HRESULT hRes = S_OK;

    DebugPrintf(
            _TEXT("ExpireUserHelpSessionCallback() on %s...\n"),
            (LPCTSTR)bstrHelpId
        );


    // Load Help Entry.
    RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( NULL, bstrHelpId );

    if( NULL != pObj )
    {
        //
        // LoadHelpSessionObj() will release expired help session.
        //
        pObj->Release();
    }        

    return hRes;
}


HRESULT
CRemoteDesktopHelpSessionMgr::LogoffUserHelpSessionCallback(
    IN CComBSTR& bstrHelpId,
    IN HANDLE userData
    )
/*++

Routine Description:

    Expire help session call back routine, refer to EnumHelpEntry()

Parameters:

    bstrHelpId : ID of help session.
    userData : Handle to user data.

Returns:

    S_OK.

--*/
{
    HRESULT hRes = S_OK;

    DWORD dwLogoffSessionId = PtrToUlong(userData);

    long lHelpSessionUserSessionId;

    DebugPrintf(
            _TEXT("LogoffUserHelpSessionCallback() on %s %d...\n"),
            bstrHelpId, 
            dwLogoffSessionId
        );

    // Load Help Entry.
    RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( NULL, bstrHelpId );

    if( NULL != pObj )
    {
        //
        // LoadHelpSessionObj() will release expired help session.
        //
        hRes = pObj->get_UserLogonId( &lHelpSessionUserSessionId );

        if( SUCCEEDED(hRes) && (DWORD)lHelpSessionUserSessionId == dwLogoffSessionId )
        {
            DebugPrintf(
                    _TEXT("User Session has log off...\n")
                );

            // rely on helpassistant session logoff to notify 
            // resolver.
            hRes = pObj->put_UserLogonId(UNKNOWN_LOGONID);
        }
        else if( pObj->GetHelperSessionId() == dwLogoffSessionId )
        {

            DebugPrintf(
                    _TEXT("Helper has log off...\n")
                );

            // Helper has logoff, invoke disconnect to clean up
            // resolver state.
            hRes = pObj->NotifyDisconnect();
        }

        DebugPrintf(
                _TEXT("hRes = 0x%08x, lHelpSessionUserSessionId=%d\n"),
                hRes,
                lHelpSessionUserSessionId
                );

        pObj->Release();
    }        

    // Always return success to continue on next help session
    return S_OK;
}


HRESULT
CRemoteDesktopHelpSessionMgr::NotifyPendingHelpServiceStartCallback(
    IN CComBSTR& bstrHelpId,
    IN HANDLE userData
    )
/*++

Routine Description:

    Call back for NotifyPendingHelpServiceStartup, refer to EnumHelpEntry()

Parameters:

    bstrHelpId : ID of help session.
    userData : Handle to user data.

Returns:

    S_OK.


-*/
{
    HRESULT hRes = S_OK;

    // DeleteHelp() will try to close the port and since we just startup,
    // port is either invalid or not open, so we need manually delete
    // expired help
    RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( NULL, bstrHelpId, TRUE );
    if( NULL != pObj )
    {
        if( TRUE == pObj->IsHelpSessionExpired() )
        {
            pObj->put_ICSPort( 0 );
            pObj->DeleteHelp();
            ReleaseAssistantAccount();
        }
        else
        {
            DWORD dwICSPort;

            //
            // re-open the port so connection can come in
            //
            dwICSPort = OpenPort( TERMSRV_TCPPORT );
            //dwICSPort = OpenPort( htons(TERMSRV_TCPPORT) );
            pObj->put_ICSPort( dwICSPort );

            // We don't close the port until we are deleted.
        }

        pObj->Release();
    }

    return hRes;
}

void
CRemoteDesktopHelpSessionMgr::NotifyPendingHelpServiceStartup()
/*++

Description:

    Go thru all pending help and notify pending help about
    service startup.

Parameters:

    None.

Returns:

    None

--*/
{
    try {
        g_HelpSessTable.EnumHelpEntry( 
                                NotifyPendingHelpServiceStartCallback, 
                                NULL
                            );
    }
    catch(...) {
        MYASSERT(FALSE);
        throw;
    }

    return;
}
    
void
CRemoteDesktopHelpSessionMgr::TimeoutHelpSesion()
/*++

Routine Description:

    Expire help session that has exceed its valid period.

Parameters:

    None.

Returns:

    None.    

--*/
{
    DebugPrintf(
            _TEXT("TimeoutHelpSesion()...\n")
        );

    try {
        g_HelpSessTable.EnumHelpEntry( 
                                ExpireUserHelpSessionCallback, 
                                (HANDLE)NULL
                            );
    }
    catch(...) {
        MYASSERT(FALSE);
        throw;
    }
    
    return;
}


void
CRemoteDesktopHelpSessionMgr::NotifyHelpSesionLogoff(
    DWORD dwLogonId
    )
/*++

Routine Description:


Parameters:


Returns:

--*/
{
    DebugPrintf(
            _TEXT("NotifyHelpSesionLogoff() %d...\n"),
            dwLogonId
        );

    try {
        g_HelpSessTable.EnumHelpEntry( 
                                LogoffUserHelpSessionCallback, 
                                UlongToPtr(dwLogonId)
                            );
    }
    catch(...) {
        MYASSERT(FALSE);
        throw;
    }
    
    return;
}


HRESULT
CRemoteDesktopHelpSessionMgr::DeleteHelpSessionFromCache(
    IN BSTR bstrHelpId
    )
/*++

Routine Descritpion:

    Delete help session from global cache.

Parameters:

    bstrHelpId : Help session ID to be deleted.

Returns:

    S_OK.
    HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND )
    
--*/
{
    HRESULT hRes = S_OK;

    DebugPrintf(
            _TEXT("DeleteHelpSessionFromCache() - %s\n"),
            bstrHelpId
        );

    IDToSessionMap::LOCK_ITERATOR it = gm_HelpIdToHelpSession.find( bstrHelpId );

    if( it != gm_HelpIdToHelpSession.end() )
    {
        gm_HelpIdToHelpSession.erase( it );
    }
    else
    {
        hRes = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }

    return hRes;
}


RemoteDesktopHelpSessionObj*
CRemoteDesktopHelpSessionMgr::LoadHelpSessionObj(
    IN CRemoteDesktopHelpSessionMgr* pMgr,
    IN BSTR bstrHelpSession,
    IN BOOL bLoadExpiredHelp /* = FALSE */
    )
/*++

Routine Description:

    Find a pending help entry, routine will load from DB if not
    yet loaded.

Parameters:

    pMgr : Pointer to CRemoteDesktopHelpSessionMgr object that wants to
           load this help session.
    bstrHelpSession : Help entry ID interested.

Returns:


--*/
{
    HRESULT hRes = S_OK;
    PHELPENTRY pHelp = NULL;
    RemoteDesktopHelpSessionObj* pHelpSessionObj = NULL;
    IDToSessionMap::LOCK_ITERATOR it = gm_HelpIdToHelpSession.find( bstrHelpSession );

    if( it != gm_HelpIdToHelpSession.end() )
    {
        DebugPrintf(
                _TEXT("LoadHelpSessionObj() %s is in cache ...\n"),
                bstrHelpSession
            );

        pHelpSessionObj = (*it).second;

        // One more reference to this object.
        pHelpSessionObj->AddRef();
    }
    else
    {
        DebugPrintf(
                _TEXT("Loading Help Session %s\n"),
                bstrHelpSession
            );

        //  load from table
        hRes = g_HelpSessTable.OpenHelpEntry(
                                            bstrHelpSession,
                                            &pHelp
                                        );

        if( SUCCEEDED(hRes) )
        {
            //
            // Object return from CreateInstance() has ref. count of 1
            //
            hRes = CRemoteDesktopHelpSession::CreateInstance(
                                                            pMgr,
                                                            (pMgr) ? pMgr->m_bstrUserSid : NULL,
                                                            pHelp,
                                                            &pHelpSessionObj
                                                        );
            if( SUCCEEDED(hRes) )
            {
                if( NULL != pHelpSessionObj )
                {
                    hRes = AddHelpSessionToCache( 
                                            bstrHelpSession, 
                                            pHelpSessionObj 
                                        );

                    if( SUCCEEDED(hRes) )
                    {
                        //m_HelpListByLocal.push_back( bstrHelpSession );
                        it = gm_HelpIdToHelpSession.find( bstrHelpSession );

                        MYASSERT( it != gm_HelpIdToHelpSession.end() );

                        if( it == gm_HelpIdToHelpSession.end() )
                        {
                            hRes = E_UNEXPECTED;
                            MYASSERT( FALSE );
                        }
                    }
                    
                    if( FAILED(hRes) )
                    {
                        // we have big problem here...
                        pHelpSessionObj->Release();
                        pHelpSessionObj = NULL;
                    }
                    else
                    {
                        // ignore error here, it is possible that owner account
                        // got deleted even session is still active, we will let
                        // resolver to fail.
                        pHelpSessionObj->ResolveTicketOwner();
                    }
                }
                else
                {
                    MYASSERT(FALSE);
                    hRes = E_UNEXPECTED;
                }
            }

            if( FAILED(hRes) )
            {
                MYASSERT( FALSE );
                pHelp->Close();
            }
        }
    }
    
    //
    // If automatically delete expired help, check and delete expired help
    //
    if( FALSE == bLoadExpiredHelp && pHelpSessionObj && 
        TRUE == pHelpSessionObj->IsHelpSessionExpired() )
    {
        // If session is in help or pending user response,
        // don't expire it, let next load to delete it.
        if( UNKNOWN_LOGONID == pHelpSessionObj->GetHelperSessionId() )
        {
            // Delete it from data base and in memory cache
            pHelpSessionObj->DeleteHelp();
            ReleaseAssistantAccount();
            pHelpSessionObj->Release();

            pHelpSessionObj = NULL;
        }
    }

    return pHelpSessionObj;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRemoteDesktopHelpSessionMgr
//

STDMETHODIMP 
CRemoteDesktopHelpSessionMgr::DeleteHelpSession(
    IN BSTR HelpSessionID
    )
/*++

Routine Description:

    Delete a user created Help Session from our cached list.

Parameter:

    HelpSessionID : Help Session ID returned from CreateHelpSession() or
                    CreateHelpSessionEx().

Returns:

    S_OK                                        Success.
    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)    Help ID not found.
    HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)     Help does not belong to user

--*/
{
    HRESULT hRes = S_OK;
    BOOL bInCache;

    if( FALSE == _Module.IsSuccessServiceStartup() )
    {
        // service startup problem, return error code.
        hRes = _Module.GetServiceStartupStatus();
        DebugPrintf(
                _TEXT("Service startup failed with 0x%x\n"),
                hRes
            );
        return hRes;
    }
    
    if( NULL == HelpSessionID )
    {
        hRes = E_POINTER;
        MYASSERT(FALSE);

        return hRes;
    }

    DebugPrintf(
            _TEXT("Delete Help Session %s\n"),
            HelpSessionID
        );

    hRes = LoadUserSid();

    MYASSERT( SUCCEEDED(hRes) );

    RemoteDesktopHelpSessionObj* pHelpObj;

    pHelpObj = LoadHelpSessionObj( this, HelpSessionID );
    if( NULL != pHelpObj )
    {
        // Only original creator can delete his/her help session
        //if( TRUE == pHelpObj->IsEqualSid(m_bstrUserSid) )
        //{
            // DeleteHelp will also delete entry in global cache. 
            pHelpObj->DeleteHelp();
            ReleaseAssistantAccount();
        //}
        //else
        //{
        //    hRes = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        //}

        // LoadHelpSessionObj() always AddRef().
        pHelpObj->Release();
    }
    else
    {
        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
   
	return hRes;
}

STDMETHODIMP 
CRemoteDesktopHelpSessionMgr::CreateHelpSession(
    IN BSTR bstrSessName, 
    IN BSTR bstrSessPwd, 
    IN BSTR bstrSessDesc, 
    IN BSTR bstrSessBlob,
    OUT IRemoteDesktopHelpSession **ppIRemoteDesktopHelpSession
    )
/*++

--*/
{
    // No one is using this routine.
    return E_NOTIMPL;
}

HRESULT
CRemoteDesktopHelpSessionMgr::CreateHelpSession(
    IN BOOL bCacheEntry,
    IN BSTR bstrSessName, 
    IN BSTR bstrSessPwd, 
    IN BSTR bstrSessDesc, 
    IN BSTR bstrSessBlob,
    IN LONG UserLogonId,
    IN BSTR bstrClientSid,
    OUT RemoteDesktopHelpSessionObj **ppIRemoteDesktopHelpSession
    )
/*++

Routine Description:

    Create an instantiation of IRemoteDesktopHelpSession object, each instantiation represent
    a RemoteDesktop Help Session.

Parameters:

    bstrSessName : User defined Help Session Name, currently not used.
    bstrSessPwd : User defined Help Session password.
    bstrSessDesc : User defined Help Session Description, currently not used.
    ppIRemoteDesktopHelpSession : return an IRemoteDesktopHelpSession object representing a Help Session

Returns:

    S_OK
    E_UNEXPECTED
    SESSMGR_E_GETHELPNOTALLOW       User not allow to get help
    Other COM error.

Note:

    Caller must check if client is allowed to get help

--*/
{
    HRESULT hRes = S_OK;
    DWORD dwStatus;
    CComBSTR bstrGenSessPwd;
    PHELPENTRY pHelp = NULL;
    CComBSTR bstrHelpSessionId;
    DWORD dwICSPort;
    LONG MaxTicketExpiry;

    CComObject<CRemoteDesktopHelpSession>* pInternalHelpSessionObj = NULL;

    if( NULL == ppIRemoteDesktopHelpSession )
    {
        hRes = E_POINTER;
        return hRes;
    }

    hRes = GenerateHelpSessionId( bstrHelpSessionId );
    if( FAILED(hRes) )
    {
        return hRes;
    }

    DebugPrintf(
            _TEXT("CreateHelpSession %s\n"),
            bstrHelpSessionId
        );

    //
    // Setup assistant account rights and encryption parameters.
    //
    hRes = AcquireAssistantAccount();
    if( FAILED(hRes) )
    {
        return hRes;
    }

    hRes = g_HelpSessTable.CreateInMemoryHelpEntry( 
                                        bstrHelpSessionId, 
                                        &pHelp 
                                    );
    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    MYASSERT( NULL != pHelp );

    //
    // Open ICS port.
    //
    dwICSPort = OpenPort( TERMSRV_TCPPORT );
    //dwICSPort = OpenPort( htons(TERMSRV_TCPPORT) );

    //
    // CRemoteDesktopHelpSession::CreateInstance() will load
    // TS session ID and default RDS settings.
    //
    hRes = CRemoteDesktopHelpSession::CreateInstance( 
                                                    this,
                                                    CComBSTR(bstrClientSid),    // client SID that open this instance
                                                    pHelp,
                                                    &pInternalHelpSessionObj
                                                );

    if( SUCCEEDED(hRes) )
    {
        //
        // Check to see if user define a session password, if 
        // not, generate a random one.
        //
        bstrGenSessPwd.Attach( bstrSessPwd );
        if( 0 == bstrGenSessPwd.Length() )
        {
            LPTSTR pszSessPwd = NULL;

            //
            // Always detach or CComBSTR will try to free it.
            //
            bstrGenSessPwd.Detach();

            GenerateRandomString( MAX_HELPACCOUNT_PASSWORD * sizeof(TCHAR), &pszSessPwd );
            bstrGenSessPwd = pszSessPwd;

            if( NULL != pszSessPwd )
            {
                LocalFree( pszSessPwd );
            }
        }
        else
        {
            //
            // Detach input from CComBSTR and make a copy of it
            // otherwise destructor will free it which will be
            // the inpute BSTR. 
            //
            bstrGenSessPwd.Detach();
            bstrGenSessPwd = bstrSessPwd;
        }

        hRes = pInternalHelpSessionObj->BeginUpdate();
        if( FAILED(hRes) )
        {
            goto CLEANUPANDEXIT;
        }

        //
        // Get default timeout value from registry, not a critical 
        // error, if we failed, we just default to 30 days
        //
        hRes = PolicyGetMaxTicketExpiry( &MaxTicketExpiry );
        if( SUCCEEDED(hRes) && MaxTicketExpiry > 0 )
        {
            pInternalHelpSessionObj->put_TimeOut( MaxTicketExpiry );
        }

        hRes = pInternalHelpSessionObj->put_ICSPort( dwICSPort );

        if( SUCCEEDED(hRes) )
        {
            hRes = pInternalHelpSessionObj->put_UserLogonId(UserLogonId);
        }

        if( SUCCEEDED(hRes) )
        {
            // user SID that created this help session 
            hRes = pInternalHelpSessionObj->put_UserSID(bstrClientSid);
        }
    
        if( SUCCEEDED(hRes) )
        {
            hRes = pInternalHelpSessionObj->put_HelpSessionPassword( 
                                                            bstrGenSessPwd 
                                                        );
        }

        if( SUCCEEDED(hRes) )
        {
            hRes = pInternalHelpSessionObj->put_HelpSessionName( 
                                                            bstrSessName 
                                                        );
        }

        if( SUCCEEDED(hRes) )
        {
            hRes = pInternalHelpSessionObj->put_HelpSessionDescription( 
                                                            bstrSessDesc 
                                                        );
        }

        if( SUCCEEDED(hRes) )
        {
            hRes = pInternalHelpSessionObj->put_HelpSessionCreateBlob( 
                                                            bstrSessBlob 
                                                        );
        }

        if( SUCCEEDED(hRes) )
        {
            hRes = pInternalHelpSessionObj->CommitUpdate();
        }

        if( FAILED(hRes) )
        {
            // ignore error and exit
            (VOID)pInternalHelpSessionObj->AbortUpdate();
            goto CLEANUPANDEXIT;
        }

        //
        // Ignore error, we will let resolver fail.
        pInternalHelpSessionObj->ResolveTicketOwner();
        

        //
        // We are adding entry to table and also our global object
        // cache, to prevent deadlock or timing problem, lock
        // global cache and let MemEntryToStorageEntry() lock table.        
        //
        LockIDToSessionMapCache();
        
        try {
            if( bCacheEntry )
            {
                // convert a in-memory help to persistant help
                hRes = g_HelpSessTable.MemEntryToStorageEntry( pHelp );
            }

            if( SUCCEEDED(hRes) )
            {
                // Add help session to global cache
                hRes = AddHelpSessionToCache(
                                        bstrHelpSessionId,
                                        pInternalHelpSessionObj
                                    );

                if( SUCCEEDED(hRes) )
                {
                    *ppIRemoteDesktopHelpSession = pInternalHelpSessionObj;
                }
                else
                {
                    MYASSERT( hRes != HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) );
                }
            }
        }
        catch(...) {
            hRes = E_UNEXPECTED;
            throw;
        }
    
        UnlockIDToSessionMapCache();
    }

CLEANUPANDEXIT:

    if( FAILED(hRes) )
    {
        ReleaseAssistantAccount();

        ClosePort(dwICSPort);

        if( NULL != pInternalHelpSessionObj )
        {
            // this will also release pHelp.
            pInternalHelpSessionObj->Release();
        }
    }

    return hRes;
}


BOOL
CRemoteDesktopHelpSessionMgr::CheckAccessRights( 
    CComObject<CRemoteDesktopHelpSession>* pIHelpSess 
    )
/*++

--*/
{
    //
    //  NOTE:  This function checks to make sure the caller is the user that
    //         created the Help Session.  For Whistler, we enforce that Help
    //         Sessions only be created by apps running as SYSTEM.  Once
    //         created, the creating app can pass the object to any other app
    //         running in any other context.  This function will get in the
    //         way of this capability so it simply returns TRUE for now.
    //
    return TRUE;

    BOOL bSuccess;

    // only original creator or help assistant can
    // access
    bSuccess = pIHelpSess->IsEqualSid( m_bstrUserSid );

    if( FALSE == bSuccess )
    {
        bSuccess = g_HelpAccount.IsAccountHelpAccount(
                                                    m_pbUserSid, 
                                                    m_cbUserSid
                                                );

        if( FALSE == bSuccess )
        {
            bSuccess = pIHelpSess->IsEqualSid( g_LocalSystemSID );
        }
    }

    #if DISABLESECURITYCHECKS 

    //
    // This is for private testing without using pcHealth, flag is not define
    // in build.
    //

    //
    // For testing only, allow admin to invoke this call
    //
    if( FALSE == bSuccess )
    {
        DWORD dump;

        if( SUCCEEDED(ImpersonateClient()) )
        {
            dump = IsUserAdmin(&bSuccess);
            if( ERROR_SUCCESS != dump )
            {
                bSuccess = FALSE;
            }

            EndImpersonateClient();
        }
    }

    #endif

    return bSuccess;
}


STDMETHODIMP 
CRemoteDesktopHelpSessionMgr::RetrieveHelpSession(
    IN BSTR HelpSessionID, 
    OUT IRemoteDesktopHelpSession **ppIRemoteDesktopHelpSession
    )
/*++

Routine Description:

    Retrieve a help session based on ID.

Parameters:

    HelpSessionID : Help Session ID returned from CreateHelpSession().
    ppIRemoteDesktopHelpSession : Return Help Session Object for the Help Session.

Paramters:

    S_OK                                        Success
    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)    Help Session not found
    HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)     Access Denied
    E_POINTER                                   Invalid argument

--*/
{
    HRESULT hRes = S_OK;

    if( FALSE == _Module.IsSuccessServiceStartup() )
    {
        // service startup problem, return error code.
        hRes = _Module.GetServiceStartupStatus();

        DebugPrintf(
                _TEXT("Service startup failed with 0x%x\n"),
                hRes
            );

        return hRes;
    }

    DebugPrintf(
            _TEXT("RetrieveHelpSession %s\n"),
            HelpSessionID
        );

    if( NULL != ppIRemoteDesktopHelpSession )
    {
        // only user sid when needed
        hRes = LoadUserSid();
        if( SUCCEEDED(hRes) )
        {
            RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( this, HelpSessionID );

            if( NULL != pObj && !pObj->IsHelpSessionExpired() )
            {
                if( TRUE == CheckAccessRights(pObj) )
                {
                    // LoadHelpSessionObj() AddRef() to object
                    *ppIRemoteDesktopHelpSession = pObj;
                }
                else
                {
                    hRes = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                    // LoadHelpSessionObj() AddRef() to object
                    pObj->Release();
                }
            }
            else
            {
                hRes = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
        }
    }
    else
    {
        hRes = E_POINTER;
    }

    DebugPrintf(
        _TEXT("RetrieveHelpSession %s returns 0x%08x\n"),
        HelpSessionID,
        hRes
    );

	return hRes;
}


STDMETHODIMP 
CRemoteDesktopHelpSessionMgr::VerifyUserHelpSession(
    IN BSTR HelpSessionId, 
    IN BSTR bstrSessPwd, 
    IN BSTR bstrResolverConnectBlob,
    IN BSTR bstrExpertBlob,
    IN LONG CallerProcessId,
    OUT ULONG_PTR* phHelpCtr,
    OUT LONG* pResolverErrCode,
    OUT long* plUserTSSession
    )
/*++

Routine Description:

    Verify a user help session is valid and invoke resolver to find the correct
    user help session to provide help.

Parameters:

    HelpSessionId : Help Session ID.
    bstrSessPwd : Password to be compare.
    bstrResolverConnectBlob : Optional parameter to be passed to resolver.
    bstrExpertBlob : Optional blob to be passed to resolver for security check.
    pResolverErrCode : Return code from resolver.
    plUserTSSession : Current logon session.

Returns:

    S_OK

--*/
{
    HRESULT hRes;
    CComBSTR bstrUserSidString;
    BOOL bMatch;
    BOOL bInCache = FALSE;

    if( FALSE == _Module.IsSuccessServiceStartup() )
    {
        // service startup problem, return error code.
        hRes = _Module.GetServiceStartupStatus();

        DebugPrintf(
                _TEXT("Service startup failed with 0x%x\n"),
                hRes
            );

        *plUserTSSession = SAFERROR_SESSMGRERRORNOTINIT;
        return hRes;
    }

    DebugPrintf(
            _TEXT("VerifyUserHelpSession %s\n"),
            HelpSessionId
        );

    if( NULL != plUserTSSession && NULL != pResolverErrCode && NULL != phHelpCtr )
    {
        hRes = LoadUserSid();
        if( SUCCEEDED(hRes) )
        {
            RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( this, HelpSessionId );

            if( NULL != pObj )
            {
                // Allow all user to invoke this call.
                bMatch = pObj->VerifyUserSession( 
                                                CComBSTR(),
                                                CComBSTR(bstrSessPwd)
                                            );

                if( TRUE == bMatch )
                {
                    hRes = pObj->ResolveUserSession( 
                                                bstrResolverConnectBlob, 
                                                bstrExpertBlob, 
                                                CallerProcessId,
                                                phHelpCtr,
                                                pResolverErrCode, 
                                                plUserTSSession 
                                            );
                }
                else
                {
                    hRes = HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD);
                    *pResolverErrCode = SAFERROR_INVALIDPASSWORD;
                }

                // LoadHelpSessionObj() AddRef() to object
                pObj->Release();
            }
            else
            {
                hRes = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                *pResolverErrCode = SAFERROR_HELPSESSIONNOTFOUND;
            }
        }
        else
        {
            *pResolverErrCode = SAFERROR_INTERNALERROR;
        }
    }
    else
    {
        hRes = E_POINTER;
        *pResolverErrCode = SAFERROR_INVALIDPARAMETERSTRING;
    }

	return hRes;
}

STDMETHODIMP
CRemoteDesktopHelpSessionMgr::IsValidHelpSession(
    /*[in]*/ BSTR HelpSessionId,
    /*[in]*/ BSTR HelpSessionPwd
    )
/*++

Description:

    Verify if a help session exists and password match.

Parameters:

    HelpSessionId : Help session ID.
    HelpSessionPwd : Optional help session password 

Returns:


Note:

    Only allow system service and administrator to invoke this
    call.

--*/
{
    HRESULT hRes = S_OK;
    BOOL bPasswordMatch;
    RemoteDesktopHelpSessionObj* pObj;


    if( FALSE == _Module.IsSuccessServiceStartup() )
    {
        // service startup problem, return error code.
        hRes = _Module.GetServiceStartupStatus();

        DebugPrintf(
                _TEXT("Service startup failed with 0x%x\n"),
                hRes
            );

        return hRes;
    }

    DebugPrintf(
            _TEXT("IsValidHelpSession ID %s\n"),
            HelpSessionId
        );

    hRes = LoadUserSid();

    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    hRes = ImpersonateClient();
    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    //
    // Make sure only system service can invoke this call.
    //
    if( !g_pSidSystem || FALSE == IsCallerSystem(g_pSidSystem) )
    {
        #if DISABLESECURITYCHECKS 

        DWORD dump;
        BOOL bStatus;

        //
        // For testing only, allow admin to invoke this call
        //
        dump = IsUserAdmin(&bStatus);
        hRes = HRESULT_FROM_WIN32( dump );
        if( FAILED(hRes) || FALSE == bStatus )
        {
            EndImpersonateClient();

            hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto CLEANUPANDEXIT;
        }

        #else

        EndImpersonateClient();

        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;

        #endif
    }

    // No need to run as client.
    EndImpersonateClient();

    pObj = LoadHelpSessionObj( this, HelpSessionId );
    if( NULL != pObj )
    {
        CComBSTR bstrPassword;

        bstrPassword.Attach(HelpSessionPwd);

        if( bstrPassword.Length() > 0 )
        {
            bPasswordMatch = pObj->VerifyUserSession( 
                                            CComBSTR(),
                                            CComBSTR(HelpSessionPwd)
                                        );

            if( FALSE == bPasswordMatch )
            {
                hRes = HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD);
            }
        }

        bstrPassword.Detach();
        pObj->Release();
    }
    else
    {
        hRes = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

CLEANUPANDEXIT:

	return hRes;
}


/////////////////////////////////////////////////////////////////////////////
//
CRemoteDesktopHelpSessionMgr::CRemoteDesktopHelpSessionMgr() :
    //m_lAccountAcquiredByLocal(0),
    m_pbUserSid(NULL),
    m_cbUserSid(0)
/*++

CRemoteDesktopHelpSessMgr Constructor

--*/
{
}

void
CRemoteDesktopHelpSessionMgr::Cleanup()
/*++

Routine Description:
    
    Cleanup resource allocated in CRemoteDesktopHelpSessionMgr

Parameters:

    None.

Returns:

    None.
--*/
{
    if( m_pbUserSid )
    {
        LocalFree(m_pbUserSid);
        m_pbUserSid = NULL;
    }
}

//--------------------------------------------------------------

HRESULT
CRemoteDesktopHelpSessionMgr::LoadUserSid()
/*++

Routine Description:

    Load client's SID onto class member variable m_pbUserSid,
    m_cbUserSid, and m_bstrUserSid.  We can't load user SID
    at class constructor as COM still haven't retrieve information
    about client's credential yey.

Parameters:

    None.

Returns:

    S_OK
    error code from ImpersonateClient()
    error code from GetTextualSid()

Note:

    On Win9x machine, user SID is 'hardcoded WIN9X_USER_SID

--*/
{
#ifndef __WIN9XBUILD__

    HRESULT hRes = S_OK;

    // check if SID already loaded, if not continue 
    // on loading SID

    if( NULL == m_pbUserSid  || 0 == m_cbUserSid )
    {
        DWORD dwStatus;
        BOOL bSuccess = TRUE;
        LPTSTR pszTextualSid = NULL;
        DWORD dwTextualSid = 0;

        hRes = ImpersonateClient();
        if( SUCCEEDED(hRes) )
        {
            m_LogonId = GetUserTSLogonId();

            // retrieve user SID.
            dwStatus = GetUserSid( &m_pbUserSid, &m_cbUserSid );
            if( ERROR_SUCCESS == dwStatus )
            {
                m_bstrUserSid.Empty();

                // convert SID to string
                bSuccess = GetTextualSid( 
                                    m_pbUserSid, 
                                    NULL, 
                                    &dwTextualSid 
                                );

                if( FALSE == bSuccess && ERROR_INSUFFICIENT_BUFFER == GetLastError() )
                {
                    pszTextualSid = (LPTSTR)LocalAlloc(
                                                    LPTR, 
                                                    (dwTextualSid + 1) * sizeof(TCHAR)
                                                );

                    if( NULL != pszTextualSid )
                    {
                        bSuccess = GetTextualSid( 
                                                m_pbUserSid, 
                                                pszTextualSid, 
                                                &dwTextualSid
                                            );

                        if( TRUE == bSuccess )
                        {
                            m_bstrUserSid = pszTextualSid;
                        }
                    }
                }

                if( 0 == m_bstrUserSid.Length() )
                {
                    hRes = HRESULT_FROM_WIN32(GetLastError());
                }
            }

            if( NULL != pszTextualSid )
            {
                LocalFree(pszTextualSid);
            }

            EndImpersonateClient();
        }
    }

    return hRes;

#else

    m_pbUserSid = NULL;
    m_cbUserSid = 0;
    m_bstrUserSid = WIN9X_USER_SID;

    return S_OK;

#endif
}
    
//---------------------------------------------------------------
HRESULT
CRemoteDesktopHelpSessionMgr::IsUserAllowToGetHelp(
    OUT BOOL* pbAllow
    )
/*++

Routine Description:

    Check if connected user is allowed to GetHelp.

Parameters:

    pbAllow : Return TRUE if user is allowed to GetHelp, FALSE otherwise.

Returns:

    S_OK or error code.

Note:

    GetHelp's priviledge is via group membership.

--*/
{
    HRESULT hRes;

    hRes = ImpersonateClient();

    if( SUCCEEDED(hRes) )
    {
        CComBSTRtoLPTSTR string( m_bstrUserSid );

        *pbAllow = ::IsUserAllowToGetHelp( GetUserTSLogonId(), (LPCTSTR) string );
        hRes = S_OK;
    }
    else
    {
        // can't get help if impersonate failed.
        *pbAllow = FALSE;
    }

    EndImpersonateClient();

    return hRes;
}

//---------------------------------------------------------

HRESULT 
CRemoteDesktopHelpSessionMgr::AcquireAssistantAccount()
/*++

Routine Description:

    "Acquire", increase the reference count of RemoteDesktop Assistant account.   
    Routine creates a 'well-known' assistant account If is not exist or 
    enables/change password if the account is disabled.  

    Help Account Manager will automatically release all reference count 
    acquire by a particular session when user log off to prevent this account 
    been 'locked'.
 
Parameters:

    pvarAccountName

        Pointer to BSTR to receive RemoteDesktop Assistant account name.

    pvarAccountPwd

        Pointer to BSTR to receive RemoteDesktop Assistant account password.

Returns:

    Success or error code.

Note:

    This is also the conference name and conference password 
    when NetMeeting is used to share user desktop.

--*/
{
    HRESULT hRes = S_OK;
    DWORD dwStatus;

    CCriticalSectionLocker l( gm_AccRefCountCS );

#ifndef __WIN9xBUILD__

    //
    // Always enable interactive rights.
    //
    hRes = g_HelpAccount.EnableRemoteInteractiveRight(TRUE);

    if( FAILED(hRes) )
    {
        DebugPrintf(
                _TEXT("Failed in EnableRemoteInteractiveRight() - 0x%08x\n"), 
                hRes 
            );
                
        goto CLEANUPANDEXIT;
    }

    //
    // Always enable the account in case user disable it.
    //
    hRes = g_HelpAccount.EnableHelpAssistantAccount( TRUE );

    if( FAILED(hRes) )
    {
        DebugPrintf( _TEXT("Can't enable help assistant account 0x%x\n"), hRes );
        goto CLEANUPANDEXIT;
    }

    if( g_HelpSessTable.NumEntries() == 0 )
    {
        DebugPrintf(
                _TEXT("Setting encryption parameters...\n")
            );

        dwStatus = TSHelpAssistantBeginEncryptionCycle();
        hRes = HRESULT_FROM_WIN32( dwStatus );
        MYASSERT( SUCCEEDED(hRes) );


        //
        // Setup account TS setting via WTSAPI
        //
        hRes = g_HelpAccount.SetupHelpAccountTSSettings();
        if( SUCCEEDED(hRes) )
        {
            DebugPrintf(
                    _TEXT("SetupHelpAccountTSSettings return 0x%08x\n"),
                    hRes
                );
        }
        else
        {
            DebugPrintf( _TEXT("SetupHelpAccountTSSettings failed with 0x%08x\n"), hRes );
        }
    }

#endif    

CLEANUPANDEXIT:

	return hRes;
}

//----------------------------------------------------------

HRESULT
CRemoteDesktopHelpSessionMgr::ReleaseAssistantAccount()
/*++

Routine Description:

    Release RemoteDesktop assistant account previously 
    acquired with AcquireAssistantAccount(), 
    account will be disabled if the account reference 
    count is 0.  

    Help Account Manager will automatically release all 
    reference count acquire by a particular session when 
    user log off to prevent this account been 'locked'.

Parameters:

    None

Returns:

    Success or error code.

--*/
{
    HRESULT hRes = S_OK;
    DWORD dwStatus;
    CCriticalSectionLocker l( gm_AccRefCountCS );

#ifndef __WIN9XBUILD__

    if( g_HelpSessTable.NumEntries() == 0 )
    {
        // ignore error if we can't reset account password
        (void)g_HelpAccount.ResetHelpAccountPassword();

        dwStatus = TSHelpAssisantEndEncryptionCycle();
        hRes = HRESULT_FROM_WIN32( dwStatus );
        MYASSERT( SUCCEEDED(hRes) );

        //
        // diable HelpAssistant TS 'Connect' right.
        //
        g_HelpAccount.EnableRemoteInteractiveRight(FALSE);

        hRes = g_HelpAccount.EnableHelpAssistantAccount( FALSE );
        if( FAILED(hRes) )
        {
            // not a critical error.
            DebugPrintf( _TEXT("Can't disable help assistant account 0x%x\n"), hRes );
        }

    }
#endif

	return S_OK;
}


STDMETHODIMP
CRemoteDesktopHelpSessionMgr::GetUserSessionRdsSetting(
    OUT REMOTE_DESKTOP_SHARING_CLASS* rdsLevel
    )
/*++


--*/
{
    HRESULT hRes;
    DWORD dwStatus;
    REMOTE_DESKTOP_SHARING_CLASS userRdsDefault;

    if( NULL != rdsLevel )
    {
        hRes = ImpersonateClient();
        if( SUCCEEDED(hRes) )
        {
            hRes = LoadUserSid();

            MYASSERT( SUCCEEDED(hRes) );
        
            dwStatus = GetUserRDSLevel( m_LogonId, &userRdsDefault );
            hRes = HRESULT_FROM_WIN32( dwStatus );

            *rdsLevel = userRdsDefault;

            EndImpersonateClient();
        }
    }
    else
    {
        hRes = E_POINTER;
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSessionMgr::ResetHelpAssistantAccount(
    BOOL bForce
    )
/*++

Routine Description:

    Reset help assistant account password.

Parameters:

    bForce : TRUE if delete all pending help and reset the account password, FALSE
             if reset account password if there is no more pending help session.

Returns:

    S_OK
    HRESULT_FROM_WIN32( ERROR_MORE_DATA )

--*/
{
    HRESULT hRes = S_OK;

    hRes = LoadUserSid();

    MYASSERT( SUCCEEDED(hRes) );

    // Check any help stil pending
    if( g_HelpSessTable.NumEntries() > 0 )
    {
        if( FALSE == bForce )
        {
            hRes = HRESULT_FROM_WIN32( ERROR_MORE_DATA );
        }
        else
        {
            IDToSessionMap::LOCK_ITERATOR it = gm_HelpIdToHelpSession.begin();

            //
            // notify all in cached pending help session that it has been deleted.
            // rest help entry will be deleted via DeleteSessionTable().
            for( ;it != gm_HelpIdToHelpSession.end(); )
            {
                RemoteDesktopHelpSessionObj* pObj = (*it).second;

                // DeleteHelp() will wipe entry from cache.            
                it++;

                // We can't not release this object since client might still
                // holding pointer
                pObj->DeleteHelp();
            }

            g_HelpSessTable.DeleteSessionTable();
        }
    }

    if(SUCCEEDED(hRes))
    {
        hRes = g_HelpAccount.ResetHelpAccountPassword();
    }
    
    return hRes;
}    


HRESULT
CRemoteDesktopHelpSessionMgr::GenerateHelpSessionId(
    CComBSTR& bstrHelpSessionId
    )
/*++

Routine Description:

    Create a unique Help Session ID.

Parameters:

    bstrHelpSessionId : Reference to CComBSTR to receive HelpSessionId.

Returns:

    S_OK
    HRESULT_FROM_WIN32( Status from RPC call UuidCreate() or UuidToString() )
--*/
{
    LPTSTR pszRandomString = NULL;
    DWORD dwStatus;

    dwStatus = GenerateRandomString( 32, &pszRandomString );
    if( ERROR_SUCCESS == dwStatus )
    {
        bstrHelpSessionId = pszRandomString;
        LocalFree( pszRandomString );
    }

    return HRESULT_FROM_WIN32( dwStatus );
}


STDMETHODIMP
CRemoteDesktopHelpSessionMgr::CreateHelpSessionEx(
    /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
    /*[in]*/ BOOL fEnableCallback,
	/*[in]*/ LONG timeOut,
    /*[in]*/ LONG userSessionId,
    /*[in]*/ BSTR userSid,
    /*[in]*/ BSTR bstrUserHelpCreateBlob,
	/*[out, retval]*/ IRemoteDesktopHelpSession** ppIRemoteDesktopHelpSession
    )
/*++

Routine Description:

    Simimar to CreateHelpSession() except it allow caller to assoicate a 
    help session to a specific user, caller must be running in
    system context.

Parameters:

    sharingClass : Level of remote control (shadow setting) needed.
    fEnableCallback : TRUE to enable resolver callback, FALSE otherwise.
    timeOut : Help session timeout value.
    userSessionId : Logon user TS session ID.
    userSid : User SID that help session associated.
    bstrUserHelpCreateBlob : user specific create blob.
    parms: Return connect parm.

Returns:

--*/
{
    HRESULT hRes;
    RemoteDesktopHelpSessionObj* pRemoteDesktopHelpSessionObj = NULL;


    if( NULL == ppIRemoteDesktopHelpSession )
    {
        hRes = E_POINTER;
    }
    else
    {
        hRes = RemoteCreateHelpSessionEx(
                                    TRUE,               // cache entry
                                    fEnableCallback,    // enable resolver ?
                                    sharingClass,
                                    (timeOut == 0) ? EXPIRE_HELPSESSION_PERIOD : timeOut,
                                    userSessionId,
                                    userSid,
                                    bstrUserHelpCreateBlob,
                                    &pRemoteDesktopHelpSessionObj
                                );
        
        //
        // 1) pcHealth resolver interprete salem connection parm, reset help session name to
        // some default string.
        // 2) When resolver invoke helpctr, script will truncate up to first space so 
        // our name can not contain space.
        //
        if( SUCCEEDED(hRes) && pRemoteDesktopHelpSessionObj )
        {
            ULONG flag;
            hRes = pRemoteDesktopHelpSessionObj->put_HelpSessionName( HELPSESSION_NORMAL_RA );

            if( SUCCEEDED(hRes) )
            {
                hRes = pRemoteDesktopHelpSessionObj->put_HelpSessionDescription( HELPSESSION_NORMAL_RA );
            }

            if( FAILED(hRes) )
            {
                pRemoteDesktopHelpSessionObj->Release();
                pRemoteDesktopHelpSessionObj = NULL;
            }

            flag = pRemoteDesktopHelpSessionObj->GetHelpSessionFlag();
            pRemoteDesktopHelpSessionObj->SetHelpSessionFlag( flag & ~HELPSESSIONFLAG_UNSOLICITEDHELP );
        }

        *ppIRemoteDesktopHelpSession = pRemoteDesktopHelpSessionObj;
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSessionMgr::RemoteCreateHelpSession(
    /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
	/*[in]*/ LONG timeOut,
	/*[in]*/ LONG userSessionId,
	/*[in]*/ BSTR userSid,
    /*[in]*/ BSTR bstrHelpCreateBlob,    
	/*[out, retval]*/ BSTR* parms
    )
/*++

Description:

    UNSOLICTED SUPPORT, only invoke by PCHEALTH, differ to CreateHelpSessionEx()
    are help session entry will not cached into registry and resolver callback is
    always enable.

Parameters:

    Refer to CreateHelpSessionEx().

Returns:

--*/
{
    HRESULT hRes;
    RemoteDesktopHelpSessionObj* pIRemoteDesktopHelpSession = NULL;

    // if pcHealth pass unresolve session, cache the entry, set
    // timeout to very short for security reason.
    hRes = RemoteCreateHelpSessionEx(
                                FALSE,      // don't cache entry in registry.
                                TRUE,       // force resolver call.
                                sharingClass,
                                (timeOut == 0) ? DEFAULT_UNSOLICATED_HELP_TIMEOUT : timeOut,
                                userSessionId,
                                userSid,
                                bstrHelpCreateBlob,
                                &pIRemoteDesktopHelpSession
                            );

    if( SUCCEEDED(hRes) && NULL != pIRemoteDesktopHelpSession )
    {
        hRes = pIRemoteDesktopHelpSession->get_ConnectParms( parms );
    }

    return hRes;
}

HRESULT
CRemoteDesktopHelpSessionMgr::RemoteCreateHelpSessionEx(
    /*[in]*/ BOOL bCacheEntry,
    /*[in]*/ BOOL bEnableResolver,
    /*[in]*/ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
	/*[in]*/ LONG timeOut,
	/*[in]*/ LONG userSessionId,
	/*[in]*/ BSTR userSid,
    /*[in]*/ BSTR bstrHelpCreateBlob,    
	/*[out, retval]*/ RemoteDesktopHelpSessionObj** ppIRemoteDesktopHelpSession
    )
/*++

Routine Description:

    Create help ticket and return connection parameters.

Parameters:

    bCacheEntry : Cache help session to registry.
    bEnableCallback : TRUE to enable resolver callback, FALSE otherwise.
    sharingClass : RDS setting requested.
    timeout : Help session expiry period.
    userSessionId : User TS session ID that help session associated with.
    userSid : SID of user on the TS session.
    bstrHelpCreateBlob : User specific help session create blob, meaningless
                         if resolver is not enabled.
    ppIRemoteDesktopHelpSession : Help session created.

Returns:

    S_OK
    S_FALSE     sharingClass violate policy setting.
    other error code.

--*/
{
    HRESULT hRes = S_OK;
    BOOL bStatus;
    RemoteDesktopHelpSessionObj *pIHelpSession = NULL;
    BOOL bAllowGetHelp = FALSE;
    ULONG flag;

#if DBG
    long HelpSessLogonId;
#endif

    if( FALSE == _Module.IsSuccessServiceStartup() )
    {
        // service startup problem, return error code.
        hRes = _Module.GetServiceStartupStatus();

        DebugPrintf(
                _TEXT("Service startup failed with 0x%x\n"),
                hRes
            );

        goto CLEANUPANDEXIT;
    }

    if( 0 == timeOut )
    {
        hRes = E_INVALIDARG;
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

    hRes = LoadUserSid();

    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    // common routine in tsremdsk.lib
    if( FALSE == TSIsMachinePolicyAllowHelp() )
    {
        hRes = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto CLEANUPANDEXIT;
    }

    hRes = ImpersonateClient();
    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    //
    // Make sure only system service can invoke this call.
    //
    if( !g_pSidSystem || FALSE == IsCallerSystem(g_pSidSystem) )
    {

        #if DISABLESECURITYCHECKS 

        DWORD dump;

        //
        // For testing only, allow admin to invoke this call
        //
        dump = IsUserAdmin(&bStatus);
        hRes = HRESULT_FROM_WIN32( dump );
        if( FAILED(hRes) || FALSE == bStatus )
        {
            EndImpersonateClient();

            hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto CLEANUPANDEXIT;
        }

        #else

        EndImpersonateClient();

        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;

        #endif
    }

    // No need to run as client.
    EndImpersonateClient();

    //
    // No ERROR checking on userSessionId and userSid, pcHealth
    // will make sure all parameter is correct
    //

    //
    // Create a Help Session.
    //
    hRes = CreateHelpSession( 
                            bCacheEntry,
                            HELPSESSION_UNSOLICATED,
                            CComBSTR(""),
                            HELPSESSION_UNSOLICATED,
                            bstrHelpCreateBlob,    
                            (userSessionId == -1) ? UNKNOWN_LOGONID : userSessionId,
                            userSid,
                            &pIHelpSession
                        );

    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    if( NULL == pIHelpSession )
    {
        MYASSERT( NULL != pIHelpSession );
        hRes = E_UNEXPECTED;
        goto CLEANUPANDEXIT;
    }

    #if DBG
    hRes = pIHelpSession->get_UserLogonId( &HelpSessLogonId );
    MYASSERT( SUCCEEDED(hRes) );

    if( userSessionId != -1 )
    {
        MYASSERT( HelpSessLogonId == userSessionId );
    }
    else 
    {
        MYASSERT( HelpSessLogonId == UNKNOWN_LOGONID );
    }
    #endif

    //
    // setup help session parms.
    //
    hRes = pIHelpSession->put_EnableResolver(bEnableResolver);
    MYASSERT( SUCCEEDED(hRes) );
    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    hRes = pIHelpSession->put_TimeOut( timeOut );
    if( FAILED(hRes) )
    {
        DebugPrintf(
                _TEXT("put_TimeOut() failed with 0x%08x\n"),
                hRes
            );

        goto CLEANUPANDEXIT;
    }

    //
    // We change default RDS value at the end so we can return error code or S_FALSE
    // from this.
    //
    hRes = pIHelpSession->put_UserHelpSessionRemoteDesktopSharingSetting( sharingClass );
    if( FAILED( hRes) )
    {
        DebugPrintf(
                _TEXT("put_UserHelpSessionRemoteDesktopSharingSetting() failed with 0x%08x\n"),
                hRes
            );
    }

    flag = pIHelpSession->GetHelpSessionFlag();

    pIHelpSession->SetHelpSessionFlag( flag | HELPSESSIONFLAG_UNSOLICITEDHELP );

CLEANUPANDEXIT:

    if( FAILED(hRes) )
    {
        if( NULL != pIHelpSession )
        {
            pIHelpSession->Release();
        }
    }
    else
    {
        MYASSERT( NULL != pIHelpSession );
        *ppIRemoteDesktopHelpSession = pIHelpSession;
    }

    return hRes;
}

HRESULT
LoadLocalSystemSID()
/*

Routine Description:

    Load service account as SID string.

Parameter:

    None.

Returns:

    S_OK or error code

--*/
{
    DWORD dwStatus;
    BOOL bSuccess = TRUE;
    LPTSTR pszTextualSid = NULL;
    DWORD dwTextualSid = 0;


    dwStatus = CreateSystemSid( &g_pSidSystem );
    if( ERROR_SUCCESS == dwStatus )
    {
        // convert SID to string
        bSuccess = GetTextualSid( 
                            g_pSidSystem,
                            NULL, 
                            &dwTextualSid 
                        );

        if( FALSE == bSuccess && ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {
            pszTextualSid = (LPTSTR)LocalAlloc(
                                            LPTR, 
                                            (dwTextualSid + 1) * sizeof(TCHAR)
                                        );

            if( NULL != pszTextualSid )
            {
                bSuccess = GetTextualSid( 
                                        g_pSidSystem,
                                        pszTextualSid, 
                                        &dwTextualSid
                                    );

                if( TRUE == bSuccess )
                {
                    g_LocalSystemSID = pszTextualSid;
                }
            }
        }
        
        if( 0 == g_LocalSystemSID.Length() )
        {
            dwStatus = GetLastError();
        }
    }

    if( NULL != pszTextualSid )
    {
        LocalFree(pszTextualSid);
    }


    return HRESULT_FROM_WIN32(dwStatus);
}


HRESULT
CRemoteDesktopHelpSessionMgr::LogSalemEvent(
    IN long ulEventType,
    IN long ulEventCode,
    IN long numStrings,
    IN LPCTSTR* pszStrings
    )
/*++

Description:

    Log a Salem related event, this is invoked by TermSrv and rdshost to log 
    event related to help assistant connection.

Parameters:

    

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;

    switch( ulEventCode )
    {
        case REMOTEASSISTANCE_EVENTLOG_TERMSRV_INVALID_TICKET:

            if( numStrings >= 3 )
            {
                // this event require three parameters.
                ulEventCode = SESSMGR_E_REMOTEASSISTANCE_CONNECTFAILED;
                _Module.LogEventString(
                                    ulEventType,
                                    ulEventCode,
                                    numStrings,
                                    pszStrings
                                );
            }
            else
            {
                hRes = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            }

            break;

        case REMOTEASSISTANCE_EVENTLOG_TERMSRV_REVERSE_CONNECT:
            // need at least three parameters.
            if( numStrings >= 3 ) 
            {
                //
                // String is in the order of 
                //  expert IP address from client
                //  expert IP address from rdshost.exe
                //  Ticket ID.
                //     
                LPCTSTR pszLogStrings[4];
                ulEventCode = SESSMGR_I_REMOTEASSISTANCE_CONNECTTOEXPERT;
                
                RemoteDesktopHelpSessionObj* pObj;

                //
                // Load expire help session in order to log event, we will let
                // validation catch error
                //
                pObj = LoadHelpSessionObj( NULL, CComBSTR(pszStrings[2]), TRUE );
                if( NULL != pObj )
                {
                    pszLogStrings[0] = (LPCTSTR)pObj->m_EventLogInfo.bstrNoviceDomain;
                    pszLogStrings[1] = (LPCTSTR)pObj->m_EventLogInfo.bstrNoviceAccount;
                    pszLogStrings[2] = pszStrings[0];
                    pszLogStrings[3] = pszStrings[1];
            
                    _Module.LogEventString(
                                        ulEventType,
                                        ulEventCode,
                                        4,
                                        pszLogStrings
                                    );

                    pObj->Release();
                }
                else
                {
                    hRes = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
                }
            }
            else
            {
                hRes = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

                MYASSERT(FALSE);
            }

            break;

        default:
            MYASSERT(FALSE);
            hRes = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    return hRes;
}


STDMETHODIMP
CRemoteDesktopHelpSessionMgr::LogSalemEvent(
    /*[in]*/ long ulEventType,
    /*[in]*/ long ulEventCode,
    /*[in]*/ VARIANT* pEventStrings
    )
/*++

--*/
{
    HRESULT hRes = S_OK;
    BSTR* bstrArray = NULL;
    SAFEARRAY* psa = NULL;
    VARTYPE vt_type;
    DWORD dwNumStrings = 0;

    hRes = ImpersonateClient();
    if( FAILED(hRes) )
    {
        goto CLEANUPANDEXIT;
    }

    //
    // Make sure only system service can invoke this call.
    //
    if( !g_pSidSystem || FALSE == IsCallerSystem(g_pSidSystem) )
    {
        #if DISABLESECURITYCHECKS 

        DWORD dump;
        BOOL bStatus;

        //
        // For testing only, allow admin to invoke this call
        //
        dump = IsUserAdmin(&bStatus);
        hRes = HRESULT_FROM_WIN32( dump );
        if( FAILED(hRes) || FALSE == bStatus )
        {
            EndImpersonateClient();

            hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto CLEANUPANDEXIT;
        }

        #else

        EndImpersonateClient();

        hRes = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto CLEANUPANDEXIT;

        #endif
    }

    // No need to run as client.
    EndImpersonateClient();

    if( NULL == pEventStrings )
    {
        hRes = LogSalemEvent( ulEventType, ulEventCode );
    }
    else
    {
        //
        // we only support BSTR data type.
        if( !(pEventStrings->vt & VT_BSTR) )
        {
            MYASSERT(FALSE);
            hRes = E_INVALIDARG;
            goto CLEANUPANDEXIT;
        }

        //
        // we are dealing with multiple BSTRs
        if( pEventStrings->vt & VT_ARRAY )
        {
            psa = pEventStrings->parray;

            // only accept 1 dim.
            if( 1 != SafeArrayGetDim(psa) )
            {
                hRes = E_INVALIDARG;
                MYASSERT(FALSE);
                goto CLEANUPANDEXIT;
            }

            // only accept BSTR as input type.
            hRes = SafeArrayGetVartype( psa, &vt_type );
            if( FAILED(hRes) )
            {
                MYASSERT(FALSE);
                goto CLEANUPANDEXIT;
            }

            if( VT_BSTR != vt_type )
            {
                DebugPrintf(
                        _TEXT("Unsupported type 0x%08x\n"),
                        vt_type
                    );

                hRes = E_INVALIDARG;
                MYASSERT(FALSE);
                goto CLEANUPANDEXIT;
            }

            hRes = SafeArrayAccessData(psa, (void **)&bstrArray);
            if( FAILED(hRes) )
            {
                MYASSERT(FALSE);
                goto CLEANUPANDEXIT;
            }

            hRes = LogSalemEvent( 
                                    ulEventType, 
                                    ulEventCode,
                                    psa->rgsabound->cElements,
                                    (LPCTSTR *)bstrArray
                                );

            SafeArrayUnaccessData(psa);
        }
        else
        {
            hRes = LogSalemEvent( 
                                    ulEventType, 
                                    ulEventCode,
                                    1,
                                    (LPCTSTR *)&(pEventStrings->bstrVal)
                                );
        }

    }

CLEANUPANDEXIT:

    return hRes;
}

void
CRemoteDesktopHelpSessionMgr::NotifyExpertLogoff( 
    LONG ExpertSessionId,
    BSTR HelpedTicketId
    )
/*++

Routine Description:

    Notify help ticket that helping expert has logoff so
    ticket object can de-associate (mark is not been help) with a 
    particular helper session.

Parameters:

    ExpertSessionId : Expert logon session ID.
    HelpedTicketId : Ticket ID that expert was providing help.

Returns:

    None.

--*/
{
    MYASSERT( NULL != HelpedTicketId );

    if( NULL != HelpedTicketId )
    {
        DebugPrintf(
            _TEXT("NotifyExpertLogoff() on %d %s...\n"),
            ExpertSessionId,
            HelpedTicketId
        );

        //
        // Load Help Entry, we need to inform resolver on disconnect so load
        // expired ticket.
        //
        RemoteDesktopHelpSessionObj* pObj = LoadHelpSessionObj( NULL, HelpedTicketId, TRUE );

        if( NULL != pObj )
        {
            MYASSERT( ExpertSessionId == pObj->GetHelperSessionId() );

            if( ExpertSessionId == pObj->GetHelperSessionId() )
            {
                pObj->NotifyDisconnect();
            }

            pObj->Release();
        }        

        //
        // Free ticket ID
        //
        SysFreeString( HelpedTicketId );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\helptab.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    HelpTab.cpp

Abstract:

    Implementation of __HelpEntry structure and CHelpSessionTable. 

Author:

    HueiWang    06/29/2000

--*/
#include "stdafx.h"
#include <time.h>
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <tchar.h>
#include "helptab.h"
#include "policy.h"
#include "sessmgrmc.h"


//
//
//  __HelpEntry strucutre implementation
//
//
HRESULT
__HelpEntry::LoadEntryValues(
    IN HKEY hKey
    )
/*++

Routine Description:

    Load help session entry from registry key.

Parameters:

    hKey : Handle to registry key containing help entry values.

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus;

    MYASSERT( NULL != hKey );

    if( NULL != hKey )
    {
        dwStatus = m_EntryStatus.DBLoadValue( hKey );
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        if( REGVALUE_HELPSESSION_ENTRY_DELETED == m_EntryStatus )
        {
            // entry already been deleted, no reason to continue loading
            dwStatus = ERROR_FILE_NOT_FOUND;
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessionId.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        if( m_SessionId->Length() == 0 )
        {
            // Help Session ID must exist, no default value.
            dwStatus = ERROR_INVALID_DATA;
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessionName.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessionPwd.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessionDesc.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        //dwStatus = m_SessResolverGUID.DBLoadValue(hKey);
        //if( ERROR_SUCCESS != dwStatus )
        //{
        //    goto CLEANUPANDEXIT;
        //}

        dwStatus = m_EnableResolver.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessResolverBlob.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_UserSID.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_CreationTime.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_ExpirationTime.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessionRdsSetting.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_EntryStatus.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_CreationTime.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_IpAddress.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_ICSPort.DBLoadValue(hKey);
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }

        dwStatus = m_SessionCreateBlob.DBLoadValue(hKey);
    }
    else
    {
        dwStatus = E_UNEXPECTED;
    }

CLEANUPANDEXIT:

    return HRESULT_FROM_WIN32(dwStatus);
}



HRESULT
__HelpEntry::UpdateEntryValues(
    IN HKEY hKey
    )
/*++

Routine Description:

    Update/store help entry value to registry.

Parameters:

    hKey : Handle to registry to save help entry value.

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus;

    MYASSERT( NULL != hKey );
    
    if( NULL == hKey )
    {
        dwStatus = E_UNEXPECTED;
        goto CLEANUPANDEXIT;
    }


    if( REGVALUE_HELPSESSION_ENTRY_DELETED == m_EntryStatus )
    {
        // entry already deleted, error out
        dwStatus = ERROR_FILE_NOT_FOUND;
        goto CLEANUPANDEXIT;
    }

    // New entry value, entry status in registry is set
    // to delete so when we failed to completely writting
    // all value to registry, we can still assume it is 
    // deleted.
    if( REGVALUE_HELPSESSION_ENTRY_NEW != m_EntryStatus )
    {
        // Mark entry dirty.
        m_EntryStatus = REGVALUE_HELPSESSION_ENTRY_DIRTY;
        dwStatus = m_EntryStatus.DBUpdateValue( hKey );
        if( ERROR_SUCCESS != dwStatus )
        {
            goto CLEANUPANDEXIT;
        }
    }

    dwStatus = m_SessionId.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_SessionName.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_SessionPwd.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }
    
    dwStatus = m_SessionDesc.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    //dwStatus = m_SessResolverGUID.DBUpdateValue(hKey);
    //if( ERROR_SUCCESS != dwStatus )
    //{
    //    goto CLEANUPANDEXIT;
    //}

    dwStatus = m_EnableResolver.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_SessResolverBlob.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_UserSID.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_CreationTime.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_ExpirationTime.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_SessionRdsSetting.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_IpAddress.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_ICSPort.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = m_SessionCreateBlob.DBUpdateValue(hKey);
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    // Mark entry normal
    m_EntryStatus = REGVALUE_HELPSESSION_ENTRY_NORMAL;
    dwStatus = m_EntryStatus.DBUpdateValue( hKey );


CLEANUPANDEXIT:

    return HRESULT_FROM_WIN32(dwStatus);
}


HRESULT
__HelpEntry::BackupEntry()
/*++

Routine Description:

    Backup help entry, backup is stored under
    <Help Entry Registry>\\Backup registry key.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    HKEY hKey = NULL;
    DWORD dwStatus;

    MYASSERT( NULL != m_hEntryKey );

    if( NULL != m_hEntryKey )
    {
        //
        // Delete current backup 
        (void)DeleteEntryBackup();

        //
        // Create a backup registry key
        dwStatus = RegCreateKeyEx(
                            m_hEntryKey,
                            REGKEY_HELPENTRYBACKUP,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                        );

        if( ERROR_SUCCESS != dwStatus )
        {
            MYASSERT(FALSE);
        }
        else
        {
            dwStatus = UpdateEntryValues( hKey );
        }
    }
    else
    {
        dwStatus = E_UNEXPECTED;
    }

    if( NULL != hKey )
    {
        RegCloseKey( hKey );
    }

    return HRESULT_FROM_WIN32(dwStatus);
}


    
HRESULT
__HelpEntry::RestoreEntryFromBackup()
/*++

Routine Description:

    Restore help entry from backup, backup is stored under
    <Help Entry Registry>\\Backup registry key.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus;
    HKEY hBackupKey = NULL;

    MYASSERT( NULL != m_hEntryKey );

    if( NULL != m_hEntryKey )
    {
        //
        // check if backup registry exists.
        dwStatus = RegOpenKeyEx(
                            m_hEntryKey,
                            REGKEY_HELPENTRYBACKUP,
                            0,
                            KEY_ALL_ACCESS,
                            &hBackupKey
                        );

        if( ERROR_SUCCESS == dwStatus )
        {
            HELPENTRY backup( m_pHelpSessionTable, hBackupKey, ENTRY_VALID_PERIOD );

            // load backup values
            dwStatus = backup.LoadEntryValues( hBackupKey );

            if( ERROR_SUCCESS == dwStatus )
            {
                if( (DWORD)backup.m_EntryStatus == REGVALUE_HELPSESSION_ENTRY_NORMAL )
                {
                    *this = backup;
                }
                else
                {
                    (void)DeleteEntryBackup();            
                    dwStatus = ERROR_FILE_NOT_FOUND;
                }
            }

            // HELPSESSION destructor will close registry key
        }

        if( ERROR_SUCCESS == dwStatus )
        {
            //
            // update all values.
            dwStatus = UpdateEntryValues( m_hEntryKey );

            if( ERROR_SUCCESS == dwStatus )
            {
                //
                // Already restore entry, delete backup copy
                (void)DeleteEntryBackup();
            }
        }
    }
    else
    {
        dwStatus = E_UNEXPECTED;
    }

    return HRESULT_FROM_WIN32( dwStatus );
}


HRESULT
__HelpEntry::DeleteEntryBackup()
/*++

Routine Description:

    Delete help entry backup from registry.

Parameters:

    None.

Returns:

    always S_OK

--*/
{
    DWORD dwStatus;

    dwStatus = RegDelKey(
                        m_hEntryKey,
                        REGKEY_HELPENTRYBACKUP
                    );

    return HRESULT_FROM_WIN32(dwStatus);
}

BOOL
__HelpEntry::IsEntryExpired()
{

    FILETIME ft;
    ULARGE_INTEGER ul1, ul2;

    GetSystemTimeAsFileTime(&ft);
    ul1.LowPart = ft.dwLowDateTime;
    ul1.HighPart = ft.dwHighDateTime;

    ft = (FILETIME)m_ExpirationTime;

    ul2.LowPart = ft.dwLowDateTime;
    ul2.HighPart = ft.dwHighDateTime;

    #if DBG
    if( ul1.QuadPart >= ul2.QuadPart )
    {
        DebugPrintf(
                _TEXT("Help Entry %s has expired ...\n"),
                (LPCTSTR)(CComBSTR)m_SessionId
            );
    }
    #endif

    return (ul1.QuadPart >= ul2.QuadPart);
}

////////////////////////////////////////////////////////////////////////////////
//
// CHelpSessionTable implementation
//
CHelpSessionTable::CHelpSessionTable() :
    m_hHelpSessionTableKey(NULL), m_NumHelp(0)
{
    HKEY hKey = NULL;
    DWORD dwStatus;
    DWORD dwSize;
    DWORD dwType;

    // 
    // Load entry valid period setting from registry
    //
    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        RDS_MACHINEPOLICY_SUBTREE,
                        0,
                        KEY_READ,
                        &hKey
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        dwSize = sizeof(DWORD);
        dwStatus = RegQueryValueEx(
                                hKey,
                                RDS_HELPENTRY_VALID_PERIOD,
                                NULL,
                                &dwType,
                                (PBYTE) &m_dwEntryValidPeriod,
                                &dwSize
                            );

        if( REG_DWORD != dwType )
        {
            dwStatus = ERROR_FILE_NOT_FOUND;
        }

        RegCloseKey(hKey);
    }

    if(ERROR_SUCCESS != dwStatus )
    {
        // pick default value
        m_dwEntryValidPeriod = ENTRY_VALID_PERIOD;
    }
}


HRESULT 
CHelpSessionTable::RestoreHelpSessionTable(
    IN HKEY hKey,
    IN LPTSTR pszKeyName,
    IN HANDLE userData
    )
/*++

Routine Description:

    Restore help session table.  This routine is callback from RegEnumSubKeys().

Parameters:

    hKey : Handle to registry. 
    pszKeyName : registry sub-key name containing one help session entry
    userData : User defined data.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes;


    if( NULL == userData )
    {
        hRes = E_UNEXPECTED;
        MYASSERT(FALSE);
    }
    else
    {
        CHelpSessionTable* pTable = (CHelpSessionTable *) userData;

        hRes = pTable->RestoreHelpSessionEntry( hKey, pszKeyName );
        if( SUCCEEDED(hRes) )
        {
            pTable->m_NumHelp++;
        }

        hRes = S_OK;
    }

    return hRes;
}

BOOL
CHelpSessionTable::IsEntryExpired(
    IN PHELPENTRY pEntry
    )
/*++

Routine Description:

    Determine if a help entry has expired.

Paramters:

    pEntry : Pointer to help entry.

Returns:

    TRUE if entry has expired, FALSE otherwise.

--*/
{
    MYASSERT( NULL != pEntry );

    return (NULL != pEntry) ? pEntry->IsEntryExpired() : TRUE;
}

    
HRESULT
CHelpSessionTable::RestoreHelpSessionEntry(
    IN HKEY hKey,
    IN LPTSTR pszKeyName
    )
/*++

Routine Description:

    Restore a single help session entry.

Parameters:

    hKey : Handle to help session table.
    pszKeyName : Registry sub-key name containing help entry.

Returns:

    S_OK or error code.

--*/
{
    HKEY hEntryKey = NULL;
    DWORD dwStatus;
    DWORD dwDuplicate = REG_CREATED_NEW_KEY;
    LONG entryStatus;
    BOOL bDeleteEntry = FALSE;
    
    //
    // Open the registry key for session entry
    dwStatus = RegOpenKeyEx(
                        hKey,
                        pszKeyName,
                        0,
                        KEY_ALL_ACCESS,
                        &hEntryKey
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        HELPENTRY helpEntry( *this, hEntryKey, m_dwEntryValidPeriod );

        // load help entry
        dwStatus = helpEntry.Refresh();
        if( dwStatus != ERROR_SUCCESS || helpEntry.m_SessionId->Length() == 0 ||
            REGVALUE_HELPSESSION_ENTRY_DELETEONSTARTUP == helpEntry.m_EntryStatus )
        {
            // Session ID must not be NULL.
            bDeleteEntry = TRUE;
        }
        else
        {
            if( REGVALUE_HELPSESSION_ENTRY_DELETED != helpEntry.m_EntryStatus )
            {
                if( TRUE != IsEntryExpired( &helpEntry ) )
                {
                    if( REGVALUE_HELPSESSION_ENTRY_DIRTY == helpEntry.m_EntryStatus )
                    {
                        // Entry is partially updated, try to restore from backup,
                        // is failed restoring, treat as bad entry.
                        if( FAILED(helpEntry.RestoreEntryFromBackup()) )
                        {
                            bDeleteEntry = TRUE;
                        }
                    }
                }
                else
                {
                    LPCTSTR eventString[1];
                    eventString[0] = (LPCTSTR)(CComBSTR)helpEntry.m_SessionId;

                    _Module.LogEventString(
                                    EVENTLOG_INFORMATION_TYPE,
                                    SESSMGR_I_HELPENTRYEXPIRED,
                                    1,
                                    eventString
                                );

                    DebugPrintf(
                            _TEXT("Help Entry has expired %s\n"),
                            (CComBSTR)helpEntry.m_SessionId
                        );
                }
            }
            else
            {
                bDeleteEntry = TRUE;
            }
        }

    }

    if( TRUE == bDeleteEntry )
    {
        dwStatus = RegDelKey( hKey, pszKeyName );

        //
        // Ignore error
        //
        DebugPrintf(
                _TEXT("RegDelKey on entry %s returns %d\n"),
                pszKeyName,
                dwStatus
            );

        dwStatus = ERROR_FILE_NOT_FOUND;
    }

    return HRESULT_FROM_WIN32( dwStatus );
}

   
HRESULT
CHelpSessionTable::LoadHelpEntry(
    IN HKEY hKey,
    IN LPTSTR pszKeyName,
    OUT PHELPENTRY* ppHelpSession
    )
/*++

Routine description:

    Load a help entry from registry.

Parameters:

    hKey : registry handle to help session table.
    pszKeyName : registry sub-key name (Help session ID).
    ppHelpSession : Pointer to PHELPENTRY to receive loaded help
                    entry.

Returns:

    S_OK or error code.

--*/
{

    PHELPENTRY pSess;
    HRESULT hRes;
    HKEY hEntryKey = NULL;
    DWORD dwStatus;

    MYASSERT( NULL != hKey );
    if( NULL != hKey )
    {
        // open the registry containing help entry
        dwStatus = RegOpenKeyEx(
                            hKey,
                            pszKeyName,
                            0,
                            KEY_ALL_ACCESS,
                            &hEntryKey
                        );

        if( ERROR_SUCCESS == dwStatus )
        {
            pSess = new HELPENTRY( *this, hEntryKey, m_dwEntryValidPeriod );

            if( NULL == pSess )
            {
                hRes = E_OUTOFMEMORY;
            }
            else
            {
                // load help entry, Refresh() will failed if
                // session ID is NULL or emptry string
                hRes = pSess->Refresh();
                if( SUCCEEDED(hRes) )
                {
                    if( (DWORD)pSess->m_EntryStatus == REGVALUE_HELPSESSION_ENTRY_NORMAL )
                    {
                        *ppHelpSession = pSess;
                    }
                    else
                    {
                        dwStatus = ERROR_FILE_NOT_FOUND;
                    }
                }
                
                if( FAILED(hRes) )
                {
                    pSess->Release();
                }
            }
        }
        else
        {
            hRes = HRESULT_FROM_WIN32( dwStatus );
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
    }

    return hRes;
}


HRESULT
CHelpSessionTable::OpenSessionTable(
    IN LPCTSTR pszFileName // reserverd.
    )
/*++

Routine Description:

    Open help session table, routine enumerate all help entry (registry sub-key), 
    and restore/delete help entry if necessary.
    

Parameters:

    pszFileName : reserved parameter, must be NULL.

Returns:

    S_OK or error code.

--*/
{
    DWORD dwStatus;
    CCriticalSectionLocker l(m_TableLock);

    //
    // Go thru all sub-key containing help entry and restore or delete
    // help entry if necessary.
    dwStatus = RegEnumSubKeys(
                            HKEY_LOCAL_MACHINE,
                            REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE,
                            RestoreHelpSessionTable,
                            (HANDLE)this
                        );

    if( ERROR_SUCCESS != dwStatus && ERROR_FILE_NOT_FOUND != dwStatus )
    {
        if( NULL != m_hHelpSessionTableKey )
        {
            // Make sure registry key is not opened.
            RegCloseKey(m_hHelpSessionTableKey);
            m_hHelpSessionTableKey = NULL;
        }

        // If table is bad, delete and re-create again
        dwStatus = RegDelKey( 
                            HKEY_LOCAL_MACHINE, 
                            REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE 
                        );

        if( ERROR_SUCCESS != dwStatus && ERROR_FILE_NOT_FOUND != dwStatus )
        {
            // Critical error 
            MYASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }
    }

    // 
    // Open registry key containing our help session table.
    dwStatus = RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE, 
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &m_hHelpSessionTableKey,
                        NULL
                    );
                        
    if( ERROR_SUCCESS != dwStatus )
    {
        MYASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }
    else
    {
        m_bstrFileName = pszFileName;
    }

CLEANUPANDEXIT:

    return HRESULT_FROM_WIN32(dwStatus);
}

HRESULT
CHelpSessionTable::CloseSessionTable()
/*++

Routine Description:

    Close help session table.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    // no help is opened.
    CCriticalSectionLocker l(m_TableLock);

    //
    // release all cached help entries
    for( HelpEntryCache::LOCK_ITERATOR it = m_HelpEntryCache.begin();
         it != m_HelpEntryCache.end();
         it++
        )
    {
        ((*it).second)->Release();
    }

    m_HelpEntryCache.erase_all();

    MYASSERT( m_HelpEntryCache.size() == 0 );

    if( NULL != m_hHelpSessionTableKey )
    {
        RegCloseKey( m_hHelpSessionTableKey );
        m_hHelpSessionTableKey = NULL;    
    }

    return S_OK;
}

HRESULT
CHelpSessionTable::DeleteSessionTable()
/*++

Routine description:

    Delete entire help session table.

Parameters:

    None.

Returns:

    S_OK or error code.    

--*/
{
    HRESULT hRes;
    DWORD dwStatus;

    CCriticalSectionLocker l(m_TableLock);
    hRes = CloseSessionTable();

    if( SUCCEEDED(hRes) )
    {
        // Recursively delete registry key and its sub-keys.
        dwStatus = RegDelKey( 
                            HKEY_LOCAL_MACHINE, 
                            REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE 
                        );
        if( ERROR_SUCCESS == dwStatus )
        {
            hRes = OpenSessionTable( m_bstrFileName );
        }
        else
        {
            hRes = HRESULT_FROM_WIN32( dwStatus );
        }
    }

    return hRes;
}


HRESULT
CHelpSessionTable::MemEntryToStorageEntry(
    IN PHELPENTRY pEntry
    )
/*++

Routine Description:

    Conver an in-memory help entry to persist help entry.

Parameters:

    pEntry : Pointer to HELPENTRY to be converted.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes;
    CCriticalSectionLocker l(m_TableLock);

    if( NULL != pEntry )
    {
        //
        // Check to see if this is in-memory entry
        //
        if( FALSE == pEntry->IsInMemoryHelpEntry() )
        {
            hRes = E_INVALIDARG;
        }
        else
        {
            DWORD dwStatus;
            HKEY hKey;

            //
            // Create a help entry here
            //
            dwStatus = RegCreateKeyEx(
                                    m_hHelpSessionTableKey,
                                    (LPCTSTR)(CComBSTR)pEntry->m_SessionId,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    NULL
                                );

            if( ERROR_SUCCESS == dwStatus )
            {
                hRes = pEntry->UpdateEntryValues(hKey);

                if( SUCCEEDED(hRes) )
                {
                    pEntry->ConvertHelpEntry( hKey );
                    m_HelpEntryCache[(CComBSTR)pEntry->m_SessionId] = pEntry;
                }
            }
            else
            {
                hRes = HRESULT_FROM_WIN32( dwStatus );
                MYASSERT(FALSE);
            }
        }
    }
    else
    {
        MYASSERT(FALSE);
        hRes = E_UNEXPECTED;
    }

    return hRes;
}


HRESULT
CHelpSessionTable::CreateInMemoryHelpEntry(
    IN const CComBSTR& bstrHelpSession,
    OUT PHELPENTRY* ppHelpEntry
    )
/*++

Routine Description:

    Create an in-memory help entry, this help entry is not
    persisted into registry until MemEntryToStorageEntry() is called.

Paramters:

    bstrHelpSession : Help Session ID.
    ppHelpEntry : Newly created HELPENTRY.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;
    CCriticalSectionLocker l(m_TableLock);

    MYASSERT( NULL != m_hHelpSessionTableKey );

    if( NULL != m_hHelpSessionTableKey )
    {
        DWORD dwStatus;
        HKEY hKey;
        DWORD dwDeposition;
        DWORD dwEntryStatus;

        // Create a key here so we can tell if this is a duplicate
        dwStatus = RegCreateKeyEx(
                            m_hHelpSessionTableKey,
                            bstrHelpSession,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDeposition
                        );

        if( ERROR_SUCCESS == dwStatus )
        {
            if( REG_OPENED_EXISTING_KEY == dwDeposition )
            {
                hRes = HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
            }
            else
            {
                //
                // Mark entry status to be deleted so if we abnormally
                // terminated, this entry will be deleted on startup
                //
                dwEntryStatus = REGVALUE_HELPSESSION_ENTRY_DELETED;

                dwStatus = RegSetValueEx(
                                    hKey,
                                    COLUMNNAME_KEYSTATUS,
                                    0,
                                    REG_DWORD,
                                    (LPBYTE)&dwEntryStatus,
                                    sizeof(dwEntryStatus)
                                );

                if( ERROR_SUCCESS == dwStatus )
                {
                    PHELPENTRY pSess;

                    // Create a in-memory entry
                    pSess = new HELPENTRY( *this, NULL, m_dwEntryValidPeriod );

                    if( NULL != pSess )
                    {
                        pSess->m_SessionId = bstrHelpSession;
                        *ppHelpEntry = pSess;

                        //
                        // In memory help entry should also be counted
                        // since we still write out help session ID to
                        // registry which on delete, will do m_NumHelp--.
                        //
                        m_NumHelp++;
                    }
                    else
                    {
                        hRes = E_OUTOFMEMORY;
                    }
                }
            }

            RegCloseKey(hKey);
        }

        if(ERROR_SUCCESS != dwStatus )
        {
            hRes = HRESULT_FROM_WIN32( dwStatus );
        }
    }
    else
    {
        hRes = E_UNEXPECTED;
    }
    
    return hRes;
}

HRESULT
CHelpSessionTable::OpenHelpEntry(
    IN const CComBSTR& bstrHelpSession,
    OUT PHELPENTRY* ppHelpEntry
    )
/*++

Routine Description:

    Open an existing help entry.

Parameters:

    bstrHelpSession : ID of help entry to be opened.
    ppHelpEntry : Pointer to PHELPENTY to receive loaded
                  help entry.

Returns:

    S_OK or error code.

--*/
{
    CCriticalSectionLocker l(m_TableLock);

    HRESULT hRes = S_OK;

    DebugPrintf(
            _TEXT("OpenHelpEntry() %s\n"),
            bstrHelpSession
        );

    MYASSERT( bstrHelpSession.Length() > 0 );

    // check if entry already exists in cache
    HelpEntryCache::LOCK_ITERATOR it = m_HelpEntryCache.find( bstrHelpSession );
    
    if( it != m_HelpEntryCache.end() )
    {
        *ppHelpEntry = (*it).second;

        //
        // More reference to same object.
        //
        (*ppHelpEntry)->AddRef();

        // Should have one to one between HelpEntry and HelpSession.    
        MYASSERT(FALSE);
    }
    else
    {
        hRes = LoadHelpEntry(
                        m_hHelpSessionTableKey,
                        (LPTSTR)bstrHelpSession,
                        ppHelpEntry
                    );

        DebugPrintf(
                _TEXT("LoadHelpEntry() on %s returns 0x%08x\n"),
                bstrHelpSession,
                hRes
            );

        if( SUCCEEDED(hRes) )
        {
            m_HelpEntryCache[ bstrHelpSession ] = *ppHelpEntry;
        }
    }

    return hRes;
}

HRESULT
CHelpSessionTable::DeleteHelpEntry(
    IN const CComBSTR& bstrHelpSession
    )
/*++

Routine Description:

    Delete a help entry.

Parameters:

    bstrHelpSession : ID of help session entry to be deleted.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;

    CCriticalSectionLocker l(m_TableLock);

    DebugPrintf(
            _TEXT("DeleteHelpEntry() %s\n"),
            bstrHelpSession
        );

    // check if entry already exists in cache
    HelpEntryCache::LOCK_ITERATOR it = m_HelpEntryCache.find( bstrHelpSession );

    if( it != m_HelpEntryCache.end() )
    {
        // mark entry deleted in registry
        hRes = ((*it).second)->DeleteEntry();

        MYASSERT( SUCCEEDED(hRes) );

        // release this entry ref. count.
        ((*it).second)->Release();

        // remove from our cache
        m_HelpEntryCache.erase( it );
    }
    else
    {
        //
        // unsolicited help will not be in our cache.
        //
        hRes = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    {
        DWORD dwStatus;

        dwStatus = RegDelKey( m_hHelpSessionTableKey, bstrHelpSession );
        if( ERROR_SUCCESS == dwStatus )
        {
            m_NumHelp--;    
        }
    }

    return hRes;
}             

CHelpSessionTable::~CHelpSessionTable()
{
    CloseSessionTable();
    return;
}


HRESULT
CHelpSessionTable::EnumHelpEntry(
    IN EnumHelpEntryCallback pFunc,
    IN HANDLE userData
    )
/*++

Routine Description:

    Enumerate all help entries.

Parameters:

    pFunc : Call back function.
    userData : User defined data.

Returns:

    S_OK or error code.

--*/
{
    EnumHelpEntryParm parm;
    HRESULT hRes = S_OK;
    DWORD dwStatus;
    CCriticalSectionLocker l(m_TableLock);

    if( NULL == pFunc )
    {
        hRes = E_POINTER;
    }
    else
    {
        try {
            parm.userData = userData;
            parm.pCallback = pFunc;
            parm.pTable = this;

            dwStatus = RegEnumSubKeys(
                                    HKEY_LOCAL_MACHINE,
                                    REGKEYCONTROL_REMDSK _TEXT("\\") REGKEY_HELPSESSIONTABLE,
                                    EnumOpenHelpEntry,
                                    (HANDLE) &parm
                                );

            if( ERROR_SUCCESS != dwStatus )
            {
                hRes = HRESULT_FROM_WIN32( dwStatus );
            }
        } 
        catch(...) {
            hRes = E_UNEXPECTED;
        }
    }

    return hRes;
}


HRESULT
CHelpSessionTable::ReleaseHelpEntry(
    IN CComBSTR& bstrHelpSessionId
    )
/*++

Routine Description:

    Release/unload a help entry from cached, this help
    entry is not deleted.

Paramters:

    bstrHelpSessionId : ID of help entry to be unloaded from memory.

Returns:

    S_OK or error code

--*/
{
    CCriticalSectionLocker l(m_TableLock);
        

    HRESULT hRes = S_OK;
    HelpEntryCache::LOCK_ITERATOR it = m_HelpEntryCache.find( bstrHelpSessionId );    

    if( it != m_HelpEntryCache.end() )
    {
        (*it).second->Release();
        m_HelpEntryCache.erase( it );
    }
    else
    {
        hRes = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }

    return hRes;   
}

HRESULT
CHelpSessionTable::EnumOpenHelpEntry(
    IN HKEY hKey,
    IN LPTSTR pszKeyName,
    IN HANDLE userData
    )
/*++

Routine Description:

    Call back funtion for EnumHelpEntry() and RegEnumSubKeys().

Parameters:

    hKey : Registry key handle to help session table.
    pszKeyName : help entry id (registry sub-key name).
    userData : User defined data.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;

    PEnumHelpEntryParm pParm = (PEnumHelpEntryParm)userData;

    if( NULL == pParm )
    {
        hRes = E_UNEXPECTED;
    }        
    else
    {
        hRes = pParm->pCallback( CComBSTR(pszKeyName), pParm->userData );
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\server\sessmgr\mktime.cpp ===
#include "stdafx.h"
#include <windows.h>
#include "helper.h"

///////////////////////////////////////////////////////////////////////////////
//
// Portion copy from private\ntos\rtl\time.c
//
///////////////////////////////////////////////////////////////////////////////

//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                     