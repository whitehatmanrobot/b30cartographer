((dd), TRUE, \
            (b), (o), (l))
        
#define USBPORT_WRITE_CONFIG_SPACE(dd, b, o, l) \
        RegistrationPacket.USBPORTSVC_ReadWriteConfigSpace((dd), FALSE, \
            (b), (o), (l))
     
#ifdef _WIN64
#define DUMMY_TD_CONTEXT ((PVOID) 0xABADBABEABADBABE)
#else
#define DUMMY_TD_CONTEXT ((PVOID) 0xABADBABE)
#endif

// note: we must initialize the low 12 bits of the
// buffer page ptr to zero to the last three nipples
// are 0

#define INITIALIZE_TD_FOR_TRANSFER(td, tc) \
        { ULONG i;\
        TRANSFER_CONTEXT_PTR((td)->TransferContext) = (tc);\
        (td)->Flags |= TD_FLAG_XFER; \
        for (i=0; i<5; i++) {\
        (td)->HwTD.BufferPage[i].ul = 0x0bad0000;\
        }\
        (td)->HwTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;\
        (td)->HwTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;\
        (td)->HwTD.Token.ul = 0;\
        (td)->HwTD.Token.ErrorCounter = 3;\
        TRANSFER_DESCRIPTOR_PTR((td)->NextHcdTD) = NULL;\
        }

#define SET_NEXT_TD(dd, linkTd, nextTd) \
    EHCI_ASSERT((dd), linkTd != nextTd);\
    (linkTd)->HwTD.Next_qTD.HwAddress = (nextTd)->PhysicalAddress;\
    TRANSFER_DESCRIPTOR_PTR((linkTd)->NextHcdTD) = (nextTd);

#define SET_ALTNEXT_TD(dd, linkTd, nextTd) \
    EHCI_ASSERT((dd), linkTd != nextTd);\
    (linkTd)->HwTD.AltNext_qTD.HwAddress = (nextTd)->PhysicalAddress;\
    TRANSFER_DESCRIPTOR_PTR((linkTd)->AltNextHcdTD) = nextTd;\


#define SET_NEXT_TD_NULL(linkTd) \
    TRANSFER_DESCRIPTOR_PTR((linkTd)->NextHcdTD) = NULL;\
    TRANSFER_DESCRIPTOR_PTR((linkTd)->AltNextHcdTD) = NULL;\
    (linkTd)->HwTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT; \
    (linkTd)->HwTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;


#ifdef _WIN64
#define FREE_TD_CONTEXT ((PVOID) 0xDEADFACEDEADFACE)
#else
#define FREE_TD_CONTEXT ((PVOID) 0xDEADFACE)
#endif

#define EHCI_FREE_TD(dd, ep, td) \
    (td)->Flags = 0;\
    (td)->HwTD.Next_qTD.HwAddress = 0;\
    (td)->HwTD.AltNext_qTD.HwAddress = 0;\
    (ep)->FreeTds++;\
    LOGENTRY((dd), G, '_fTD', (td), 0, 0);\
    TRANSFER_CONTEXT_PTR((td)->TransferContext) = FREE_TD_CONTEXT;

#define EHCI_ALLOC_TD(dd, ep) EHCI_AllocTd((dd), (ep));


#define TEST_BIT(value, bitNumber) ((value) & (1<<(bitNumber))) ? TRUE : FALSE

#define SET_BIT(value, bitNumber) ((value) |= (1<<(bitNumber)))

#define CLEAR_BIT(value, bitNumber)  ((value) &= ~(1<<(bitNumber)))


// assuming only one bit is set this macro returns that bit
//
#define GET_BIT_SET(d, bit) \
    {   \
        UCHAR tmp = (d);\
        (bit)=0; \
        while (!(tmp & 0x01)) {\
            (bit)++;\
            tmp >>= 1;\
        };\
    }

//
// USBEHCI.C Function Prototypes
//

USB_MINIPORT_STATUS
USBMPFN
EHCI_StartController(
    PDEVICE_DATA DeviceData,
    PHC_RESOURCES HcResources
    );

VOID
USBMPFN
EHCI_StopController(
    PDEVICE_DATA DeviceData,
    BOOLEAN HwPresent
    );

USB_MINIPORT_STATUS
EHCI_ResumeController(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_SuspendController(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
EHCI_OpenEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_CloseEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
EHCI_PokeEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
EHCI_QueryEndpointRequirements(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_REQUIREMENTS EndpointRequirements
    );

VOID
EHCI_PollEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

PHCD_TRANSFER_DESCRIPTOR
EHCI_AllocTd(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_SetEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    MP_ENDPOINT_STATUS Status
    );

MP_ENDPOINT_STATUS
EHCI_GetEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_SetEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    MP_ENDPOINT_STATE State
    );

MP_ENDPOINT_STATE
EHCI_GetEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_PollController(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
EHCI_SubmitTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferUrb,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );

VOID
EHCI_AbortTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext,
    PULONG BytesTransferred
    );

USB_MINIPORT_STATUS
EHCI_PassThru (
    PDEVICE_DATA DeviceData,
    GUID *FunctionGuid,
    ULONG ParameterLength,
    PVOID Parameters
    );

USB_MINIPORT_STATUS
EHCI_RH_UsbprivRootPortStatus(
    PDEVICE_DATA DeviceData,
    ULONG ParameterLength,
    PVOID Parameters
    );

VOID
EHCI_SetEndpointDataToggle(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    ULONG Toggle
    );

//
// ASYNC.C Function Prototypes
//

VOID
EHCI_EnableAsyncList(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_DisableAsyncList(
    PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
EHCI_FlushInterrupts(
    PDEVICE_DATA DeviceData
    );

PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_InitializeQH(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_QUEUEHEAD_DESCRIPTOR Qh,
    HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    );

PHCD_TRANSFER_DESCRIPTOR
EHCI_InitializeTD(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    );

USB_MINIPORT_STATUS
EHCI_ControlTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferUrb,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );

USB_MINIPORT_STATUS
EHCI_BulkTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferUrb,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );

USB_MINIPORT_STATUS
EHCI_OpenBulkOrControlEndpoint(
    PDEVICE_DATA DeviceData,
    BOOLEAN Control,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_InsertQueueHeadInAsyncList(
    PDEVICE_DATA DeviceData,
    PHCD_QUEUEHEAD_DESCRIPTOR Qh
    );

VOID
EHCI_RemoveQueueHeadFromAsyncList(
    PDEVICE_DATA DeviceData,
    PHCD_QUEUEHEAD_DESCRIPTOR Qh
    );

ULONG
EHCI_MapAsyncTransferToTd(
    PDEVICE_DATA DeviceData,
    ULONG MaxPacketSize,
    ULONG LengthMapped,
    PULONG NextToggle,
    PTRANSFER_CONTEXT TransferContext,
    PHCD_TRANSFER_DESCRIPTOR Td,
    PTRANSFER_SG_LIST SgList
    );

VOID
EHCI_SetAsyncEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    MP_ENDPOINT_STATE State
    );

VOID
EHCI_ProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    );

USBD_STATUS
EHCI_GetErrorFromTD(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td
    );

VOID
EHCI_AbortAsyncTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext
    );

//
// INT.C Function Prototypes
//

BOOLEAN
EHCI_InterruptService (
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_InterruptDpc (
    PDEVICE_DATA DeviceData,
    BOOLEAN EnableInterrupts
    );

VOID
USBMPFN
EHCI_DisableInterrupts(
    PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
EHCI_EnableInterrupts(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_RH_DisableIrq(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_RH_EnableIrq(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_InterruptNextSOF(
    PDEVICE_DATA DeviceData
    );

ULONG
EHCI_Get32BitFrameNumber(
    PDEVICE_DATA DeviceData
    );

//
// PERIODIC.C Function Prototypes
//

USB_MINIPORT_STATUS
EHCI_OpenInterruptEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_InsertQueueHeadInPeriodicList(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_RemoveQueueHeadFromPeriodicList(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
EHCI_InterruptTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferUrb,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );

PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_GetQueueHeadForFrame(
    PDEVICE_DATA DeviceData,
    ULONG Frame
    );

VOID
EHCI_InitailizeInterruptSchedule(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_ComputeClassicBudget(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PUCHAR sMask,
    PUCHAR cMask
    );

//
// ROOTHUB.C Function Prototypes
//

VOID
EHCI_RH_GetRootHubData(
    PDEVICE_DATA DeviceData,
    PROOTHUB_DATA HubData
    );

USB_MINIPORT_STATUS
EHCI_RH_GetStatus(
    PDEVICE_DATA DeviceData,
    PUSHORT Status
    );

USB_MINIPORT_STATUS
EHCI_RH_GetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    );

USB_MINIPORT_STATUS
EHCI_RH_GetHubStatus(
     PDEVICE_DATA DeviceData,
    OUT PRH_HUB_STATUS HubStatus
    );


USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
EHCI_RH_PortResetComplete(
    PDEVICE_DATA DeviceData,
    PVOID Context
    );    

USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
EHCI_CheckController(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortEnable(
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortPower(
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortSuspend (
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortSuspendChange (
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortOvercurrentChange (
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
EHCI_OptumtuseratePort(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

//
// SSTOOL.C Function Prototypes
//

USB_MINIPORT_STATUS
USBMPFN
EHCI_StartSendOnePacket(
    PDEVICE_DATA DeviceData,
    PMP_PACKET_PARAMETERS PacketParameters,
    PUCHAR PacketData,
    PULONG PacketLength,
    PUCHAR WorkspaceVirtualAddress,
    HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    ULONG WorkSpaceLength,
    USBD_STATUS *UsbdStatus
    );

USB_MINIPORT_STATUS
USBMPFN
EHCI_EndSendOnePacket(
    PDEVICE_DATA DeviceData,
    PMP_PACKET_PARAMETERS PacketParameters,
    PUCHAR PacketData,
    PULONG PacketLength,
    PUCHAR WorkspaceVirtualAddress,
    HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    ULONG WorkSpaceLength,
    USBD_STATUS *UsbdStatus
    );

USB_MINIPORT_STATUS
EHCI_OpenIsochronousEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_SetIsoEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    MP_ENDPOINT_STATE State
    );

VOID
EHCI_RebalanceEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,        
    PENDPOINT_DATA EndpointData
    ); 

VOID
EHCI_SetAsyncEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    MP_ENDPOINT_STATUS Status
    );    

MP_ENDPOINT_STATUS
EHCI_GetAsyncEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );    

USB_MINIPORT_STATUS
EHCI_SubmitIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    );

VOID
EHCI_PollIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );   

USB_MINIPORT_STATUS
EHCI_AbortIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext
    );

VOID
EHCI_InternalPollHsIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    BOOLEAN Complete
    );

VOID
EHCI_InsertHsIsoTdsInSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PENDPOINT_DATA PrevEndpointData,
    PENDPOINT_DATA NextEndpointData
    ); 

USB_MINIPORT_STATUS
EHCI_OpenHsIsochronousEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );    

VOID
EHCI_EnablePeriodicList(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_RemoveHsIsoTdsFromSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData     
    );   

VOID
EHCI_RebalanceInterruptEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,        
    PENDPOINT_DATA EndpointData
    );    

VOID
EHCI_RebalanceIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,        
    PENDPOINT_DATA EndpointData
    );      

BOOLEAN
EHCI_PastExpirationDate(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
EHCI_PokeAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
EHCI_PokeIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );
    
PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_GetDummyQueueHeadForFrame(
    PDEVICE_DATA DeviceData,
    ULONG Frame
    );

VOID
EHCI_AddDummyQueueHeads(
    PDEVICE_DATA DeviceData
    );    

BOOLEAN
EHCI_HardwarePresent(
    PDEVICE_DATA DeviceData,
    BOOLEAN Notify
    );

VOID
EHCI_LockQueueHead(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh,
     ENDPOINT_TRANSFER_TYPE EpType
     );    

VOID
EHCI_UnlockQueueHead(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh
     );

VOID
EHCI_PollHaltedEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     );

VOID
EHCI_PollAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     );     

VOID
EHCI_PollActiveEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     );
     
VOID
EHCI_AssertQhChk(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     );

VOID
EHCI_LinkTransferToQueue(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR FirstTd
    );  

USB_MINIPORT_STATUS
EHCI_RH_ChirpRootPort(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
USBMPFN
EHCI_TakePortControl(
    PDEVICE_DATA DeviceData
    );    

VOID
EHCI_AsyncCacheFlush(
     PDEVICE_DATA DeviceData
     );    
    
#endif /* __EHCI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\async.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   async.c

Abstract:

   miniport transfer code for control, interrupt and bulk

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    6-26-99 : created, jdunn

--*/

#include "common.h"

//implements the following miniport functions:

//non paged
//OHCI_OpenControlEndpoint
//OHCI_InterruptTransfer
//OHCI_OpenControlEndpoint


USB_MINIPORT_STATUS
OHCI_ControlTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    )
{
    PHCD_TRANSFER_DESCRIPTOR lastTd, td;    
    ULONG lengthMapped, dataTDCount = 0;    
    ULONG toggleForDataPhase = HcTDToggle_Data1;

    // see if we can handle this transfer (put it on the HW)
    // if not return BUSY, port driver will retry later

    ASSERT_TRANSFER(DeviceData, TransferContext);

    // NOTE: we can gate the number of transfers 
    // by a number of methods:
    //  - fixed count
    //  - available TDs
    //  - registry key
    
    // bugbug fixed to one transfer at a time for now

    //if (EndpointData->PendingTransfers == 
    //    EndpointData->MaxPendingTransfers) {
    //    TEST_TRAP();
    //    return USBMP_STATUS_BUSY;
    //}

    // Need one TD for every page of the data buffer, plus one for the SETUP
    // TD and one for the STATUS TD.
    //
    if (TransferSGList->SgCount + 2 > 
        OHCI_FreeTds(DeviceData, EndpointData)) {
        // not enough TDs!
        return USBMP_STATUS_BUSY;
    }        
    
    EndpointData->PendingTransfers++;

    // we have enough tds, program the transfer

    //
    // first prepare a TD for the setup packet
    //
    
    LOGENTRY(DeviceData, G, '_CTR', EndpointData, TransferParameters, 0);

    //        
    // grab the dummy TD from the tail of the queue
    //
    lastTd = td = EndpointData->HcdTailP;
    OHCI_ASSERT(DeviceData, td->Flags & TD_FLAG_BUSY);
    INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
    // count setup TD 
    TransferContext->PendingTds++;
    
    //
    // Move setup data into TD (8 chars long)
    //
    RtlCopyMemory(&td->HwTD.Packet[0],
                  &TransferParameters->SetupPacket[0],
                  8);
            
    td->HwTD.CBP = (ULONG)(((PCHAR) & td->HwTD.Packet[0])
                               - ((PCHAR) &td->HwTD)) + td->PhysicalAddress;
    td->HwTD.BE = td->HwTD.CBP + 7;
    td->HwTD.Control = 0;
    
    td->HwTD.Asy.Direction = HcTDDirection_Setup;
    td->HwTD.Asy.IntDelay = HcTDIntDelay_NoInterrupt;
    td->HwTD.Asy.Toggle = HcTDToggle_Data0;
    td->HwTD.Asy.ConditionCode = HcCC_NotAccessed;
        
                      
    LOGENTRY(DeviceData,
             G, '_set', 
             td, 
             *((PLONG) &TransferParameters->SetupPacket[0]), 
             *((PLONG) &TransferParameters->SetupPacket[4]));

    // allocate another TD       
    lastTd = td;
    td = OHCI_ALLOC_TD(DeviceData, EndpointData);
    INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
    SET_NEXT_TD(lastTd, td);
    
    //
    // now setup the data phase
    //

    lengthMapped = 0;
    while (lengthMapped < TransferParameters->TransferBufferLength) {
    
        //
        // fields for data TD
        //

        dataTDCount++;
        // count this Data TD
        TransferContext->PendingTds++;

        if (IN_TRANSFER(TransferParameters)) {          
            td->HwTD.Asy.Direction = HcTDDirection_In;
        } else {
            td->HwTD.Asy.Direction = HcTDDirection_Out;
        }
        td->HwTD.Asy.IntDelay = HcTDIntDelay_NoInterrupt;
        td->HwTD.Asy.Toggle = toggleForDataPhase;
        td->HwTD.Asy.ConditionCode = HcCC_NotAccessed;

        // after the first TD get the toggle from ED                                     
        toggleForDataPhase = HcTDToggle_FromEd;
        
        LOGENTRY(DeviceData, 
            G, '_dta', td, lengthMapped, TransferParameters->TransferBufferLength);

        lengthMapped = 
            OHCI_MapAsyncTransferToTd(DeviceData,
                                      EndpointData->Parameters.MaxPacketSize,     
                                      lengthMapped,
                                      TransferContext,
                                      td,
                                      TransferSGList);

        // allocate another TD                
        lastTd = td;
        td = OHCI_ALLOC_TD(DeviceData, EndpointData);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

        SET_NEXT_TD(lastTd, td);

    }

    //
    // set the shortxfer OK bit on the last TD only
    //
    if (SHORT_TRANSFER_OK(TransferParameters)) {
        lastTd->HwTD.Asy.ShortXferOk = 1;   
        SET_FLAG(TransferContext->TcFlags, TC_FLAGS_SHORT_XFER_OK);         
    } 
    
    //
    // now do the status phase
    //

    LOGENTRY(DeviceData, G, '_sta', td, 0, dataTDCount);
#if DBG
    if (dataTDCount > 1) {
        TEST_TRAP();
    }
#endif

    // status direction is opposite data direction,
    // specify interrupt on completion
    
    td->HwTD.Control = 0;
    td->HwTD.Asy.IntDelay = HcTDIntDelay_0ms;
    td->HwTD.Asy.Toggle = HcTDToggle_Data1;
    td->HwTD.Asy.ConditionCode = HcCC_NotAccessed;    
    td->HwTD.CBP = 0;
    td->HwTD.BE = 0;

    // status phase moves no data
    td->TransferCount = 0;
    SET_FLAG(td->Flags, TD_FLAG_CONTROL_STATUS);
    
    if (IN_TRANSFER(TransferParameters)) {
        td->HwTD.Asy.Direction = HcTDDirection_Out;
    } else {
        td->HwTD.Asy.Direction = HcTDDirection_In;
        td->HwTD.Asy.ShortXferOk = 1;            
    }

    // count status TD
    TransferContext->StatusTd = td;
    TransferContext->PendingTds++;

    OHCI_ASSERT(DeviceData, TransferContext->PendingTds == dataTDCount+2);
        
    //
    // now put a new dummy TD on the tail of the EP queue
    //

    // allocate the new dummy tail
    lastTd = td;
    td = OHCI_ALLOC_TD(DeviceData, EndpointData);
    SET_NEXT_TD(lastTd, td);
    SET_NEXT_TD_NULL(td);
    
    //
    // Set new TailP in ED
    // note: This is the last TD in the list and the place holder.
    //
    
    EndpointData->HcdTailP = 
        TransferContext->NextXferTd = td;
    
    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, 
            td->PhysicalAddress, EndpointData->HcdEd->HwED.HeadP);
            
    EndpointData->HcdEd->HwED.TailP = td->PhysicalAddress;
    
    // tell the hc we have control transfers available
    OHCI_EnableList(DeviceData, EndpointData);        

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_BulkOrInterruptTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    )
{
    PHCD_TRANSFER_DESCRIPTOR lastTd, td;    
    ULONG lengthMapped;    

    // see if we have enough free TDs to handle this transfer
    // if not return BUSY, port driver will retry later
    
    LOGENTRY(DeviceData, G, '_ITR', EndpointData, TransferParameters, 
        TransferContext);

    ASSERT_TRANSFER(DeviceData, TransferContext);
        
    //if (EndpointData->PendingTransfers == 
    //    EndpointData->MaxPendingTransfers) {
    //   LOGENTRY(DeviceData, G, '_bsy', EndpointData, TransferContext,
    //       TransferParameters);
    //    
    //    return USBMP_STATUS_BUSY;
    //}

    if (TransferSGList->SgCount > 
        OHCI_FreeTds(DeviceData, EndpointData)) {
        // not enough TDs
        
        return USBMP_STATUS_BUSY;
    }   
    
    EndpointData->PendingTransfers++;

    // we have enough tds, program the transfer

    LOGENTRY(DeviceData, G, '_nby', EndpointData, TransferParameters, 
        EndpointData->HcdEd);

    //        
    // grab the dummy TD from the tail of the queue
    //
    lastTd = td = EndpointData->HcdTailP;
    OHCI_ASSERT(DeviceData, td->Flags & TD_FLAG_BUSY);
    
    //
    // now setup the data TDs
    //

    // always build at least one data td
    lengthMapped = 0;
    
    do {

        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
        
        //
        // fields for data TD
        //

        td->HwTD.Control = 0;
        td->HwTD.Asy.IntDelay = HcTDIntDelay_NoInterrupt;
        td->HwTD.Asy.Toggle = HcTDToggle_FromEd;
        td->HwTD.Asy.ConditionCode = HcCC_NotAccessed;

        if (IN_TRANSFER(TransferParameters)) {
            td->HwTD.Asy.Direction = HcTDDirection_In;
        } else {
            // short transfers are OK on out packets.
            // actually I'm not even sure what this does
            // for outbound requests
            td->HwTD.Asy.Direction = HcTDDirection_Out;
            td->HwTD.Asy.ShortXferOk = 1;            
        }
        
        LOGENTRY(DeviceData, 
            G, '_ita', td, lengthMapped, TransferParameters->TransferBufferLength);
        TransferContext->PendingTds++;
        
        if (TransferParameters->TransferBufferLength != 0) {
            lengthMapped = 
                OHCI_MapAsyncTransferToTd(DeviceData,
                                          EndpointData->Parameters.MaxPacketSize,
                                          lengthMapped,
                                          TransferContext,
                                          td,
                                          TransferSGList);
        } else {
            OHCI_ASSERT(DeviceData, TransferSGList->SgCount == 0);

            td->HwTD.CBP = 0; 
            td->HwTD.BE = 0; 
            td->TransferCount = 0;
        }

        // allocate another TD                
        lastTd = td;
        td = OHCI_ALLOC_TD(DeviceData, EndpointData);
        SET_NEXT_TD(lastTd, td);

    } while (lengthMapped < TransferParameters->TransferBufferLength);

    //
    // About ShortXferOk:
    //
    // This bit will trigger the controller to generate an error
    // and halt the ed if it is not set. The client may specify 
    // behavior on short transfers (packets) in the transfersFlags
    // field of the URB.
    //

    // we must not set short transfer OK on split transfers since
    // the next transfer may not be a new transfer
    
    if (SHORT_TRANSFER_OK(TransferParameters) && 
        !TEST_FLAG(TransferParameters->MiniportFlags, MPTX_SPLIT_TRANSFER)) {

        // we can only set this bit in the last TD of the 
        // transfer since that TD points to the next transfer.
        //
        // All other TDs must still generate an error and the
        // ed must be resumed by us.

        lastTd->HwTD.Asy.ShortXferOk = 1;   
        SET_FLAG(TransferContext->TcFlags, TC_FLAGS_SHORT_XFER_OK);  
    }
    
    lastTd->HwTD.Asy.IntDelay = HcTDIntDelay_0ms;
    
    //
    // now put a new dummy TD on the tail of the EP queue
    //

    SET_NEXT_TD(lastTd, td);
    SET_NEXT_TD_NULL(td);

    
    //
    // Set new TailP in ED
    // note: This is the last TD in the list and the place holder.
    //

    TransferContext->NextXferTd = 
        EndpointData->HcdTailP = td;
    
    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds , 
        td->PhysicalAddress, EndpointData->HcdEd->HwED.HeadP);
        
    EndpointData->HcdEd->HwED.TailP = td->PhysicalAddress;

    LOGENTRY(DeviceData, G, '_ego', EndpointData->HcdHeadP,
                 TransferContext->TcFlags, 0);                   

    // tell the hc we have bulk/interrupt transfers available
    OHCI_EnableList(DeviceData, EndpointData);        

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_OpenControlEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, edPhys;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i, available, tdCount;
    
    LOGENTRY(DeviceData, G, '_opC', 0, 0, 0);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    available = EndpointParameters->CommonBufferBytes;

#if DBG
   {
        ULONG offset;
    
        offset = BYTE_OFFSET(buffer);

        // OHCI requires 16 byte alignemnt
        OHCI_ASSERT(DeviceData, (offset % 16) == 0);    
    }
#endif    
   
    // use control list
    EndpointData->StaticEd = 
        &DeviceData->StaticEDList[ED_CONTROL];
        
    // make the Ed
    ed = (PHCD_ENDPOINT_DESCRIPTOR) buffer;
    
    edPhys = phys;
    phys += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    buffer += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    available -= sizeof(HCD_ENDPOINT_DESCRIPTOR);
    
    EndpointData->TdList = (PHCD_TD_LIST) buffer;

    tdCount = available/sizeof(HCD_TRANSFER_DESCRIPTOR);
    LOGENTRY(DeviceData, G, '_tdC', tdCount, TDS_PER_CONTROL_ENDPOINT, 0);
    OHCI_ASSERT(DeviceData, tdCount >= TDS_PER_CONTROL_ENDPOINT);

    EndpointData->TdCount = tdCount;
    for (i=0; i<tdCount; i++) {
        OHCI_InitializeTD(DeviceData,
                             EndpointData,
                             &EndpointData->TdList->Td[i],
                             phys);                                         
                             
        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);    
    }

    EndpointData->HcdEd = 
        OHCI_InitializeED(DeviceData,
                             EndpointData,
                             ed,
                             &EndpointData->TdList->Td[0],
                             edPhys);            

    // control endpoints do not halt
    ed->EdFlags = EDFLAG_CONTROL | EDFLAG_NOHALT;
    
    OHCI_InsertEndpointInSchedule(DeviceData,
                                  EndpointData);
                                      
    return USBMP_STATUS_SUCCESS;            
}


USB_MINIPORT_STATUS
OHCI_OpenInterruptEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, edPhys;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i, bytes, offset;
    // this is an index table that converts the 
    // period to a list index
    UCHAR periodTable[8] = {
                           ED_INTERRUPT_1ms, //period = 1ms
                           ED_INTERRUPT_2ms, //period = 2ms       
                           ED_INTERRUPT_4ms, //period = 4ms       
                           ED_INTERRUPT_8ms, //period = 8ms       
                           ED_INTERRUPT_16ms,//period = 16ms       
                           ED_INTERRUPT_32ms,//period = 32ms       
                           ED_INTERRUPT_32ms,//period = 64ms               
                           ED_INTERRUPT_32ms //period = 128ms    
                           };
                    
    
    // carve up our common buffer
    // TDS_PER_ENDPOINT TDs plus an ED
    
    LOGENTRY(DeviceData, G, '_opI', 0, 0, EndpointParameters->Period);
    

    // select the proper list
    // the period is a power of 2 ie 
    // 32,16,8,4,2,1
    // we just need to find which bit is set
    GET_BIT_SET(EndpointParameters->Period, i);
    OHCI_ASSERT(DeviceData, i < 8);
    OHCI_ASSERT(DeviceData, EndpointParameters->Period < 64);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    bytes = EndpointParameters->CommonBufferBytes;
    offset = EndpointParameters->ScheduleOffset; 
   
    EndpointData->StaticEd = 
        &DeviceData->StaticEDList[periodTable[i]+offset];

    LOGENTRY(DeviceData, G, '_lst', i, periodTable[i], offset);            

    // we found the correct base list 

    EndpointData->StaticEd->AllocatedBandwidth += 
        EndpointParameters->Bandwidth;
        
    // make the Ed
    ed = (PHCD_ENDPOINT_DESCRIPTOR) buffer;
    edPhys = phys;
    phys += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    buffer += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    bytes -= sizeof(HCD_ENDPOINT_DESCRIPTOR); 

    EndpointData->TdList = (PHCD_TD_LIST) buffer;
    EndpointData->TdCount = bytes/sizeof(HCD_TRANSFER_DESCRIPTOR);

    OHCI_ASSERT(DeviceData, 
        EndpointData->TdCount >= TDS_PER_INTERRUPT_ENDPOINT);
    // Bugbug - use what we get
    for (i=0; i<EndpointData->TdCount; i++) {
        OHCI_InitializeTD(DeviceData,
                             EndpointData,
                             &EndpointData->TdList->Td[i],
                             phys);                                         
                             
        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);    
    }

    EndpointData->HcdEd = 
        OHCI_InitializeED(DeviceData,
                             EndpointData,
                             ed,
                             &EndpointData->TdList->Td[0],
                             edPhys);            

    OHCI_InsertEndpointInSchedule(DeviceData,
                                  EndpointData);

    return USBMP_STATUS_SUCCESS;              
}


USB_MINIPORT_STATUS
OHCI_OpenBulkEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, edPhys;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i, bytes;
    
    LOGENTRY(DeviceData, G, '_opB', 0, 0, 0);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    bytes = EndpointParameters->CommonBufferBytes;
   
    // use control list
    EndpointData->StaticEd = 
        &DeviceData->StaticEDList[ED_BULK];
        
    // make the Ed
    ed = (PHCD_ENDPOINT_DESCRIPTOR) buffer;
    
    edPhys = phys;
    phys += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    buffer += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    bytes -= sizeof(HCD_ENDPOINT_DESCRIPTOR); 
    
    EndpointData->TdList = (PHCD_TD_LIST) buffer;
    EndpointData->TdCount = bytes/sizeof(HCD_TRANSFER_DESCRIPTOR);

    OHCI_ASSERT(DeviceData, 
        EndpointData->TdCount >= TDS_PER_BULK_ENDPOINT);
    // Bugbug - use what we get
    for (i=0; i<EndpointData->TdCount; i++) {
        OHCI_InitializeTD(DeviceData,
                             EndpointData,
                             &EndpointData->TdList->Td[i],
                             phys);                                         
                             
        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);    
    }

    EndpointData->HcdEd = 
        OHCI_InitializeED(DeviceData,
                             EndpointData,
                             ed,
                             &EndpointData->TdList->Td[0],
                             edPhys);

    OHCI_InsertEndpointInSchedule(DeviceData,
                                  EndpointData);

    return USBMP_STATUS_SUCCESS;              
}


//
// When the HEADP is set to a new value we risk loosing 
// the current data toggle stored there. 
// This macro resets headp and preserves the flags which
// include the toggle.
//
#define RESET_HEADP(dd, ed, address) \
    {\
    ULONG headp;\
    headp = ((ed)->HwED.HeadP & HcEDHeadP_FLAGS) | (address);\
    LOGENTRY((dd), G, '_rhp', headp, (ed), 0); \
    (ed)->HwED.HeadP = headp; \
    }



VOID
OHCI_PollAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'
    
    The goal here is to determine which TDs, if any, 
    have completed and complete ant associated transfers

Arguments:

Return Value:

--*/

{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i;
    PTRANSFER_CONTEXT transfer;
    BOOLEAN clearHalt = FALSE;
    HW_32BIT_PHYSICAL_ADDRESS headP;
    
    ed = EndpointData->HcdEd;

    LOGENTRY(DeviceData, G, '_pol', ed, EndpointData, 0);        

    // note it is important the the compiler generate a 
    // dword move when reading the queuehead HeadP register 
    // since this location is also accessed by the host
    // hardware
    headP = ed->HwED.HeadP;

    // get the 'currentTD' 
    currentTd = (PHCD_TRANSFER_DESCRIPTOR)
            USBPORT_PHYSICAL_TO_VIRTUAL(headP & ~HcEDHeadP_FLAGS,
                                        DeviceData,
                                        EndpointData);
                                            
    LOGENTRY(DeviceData, G, '_cTD', currentTd, 
        headP & ~HcEDHeadP_FLAGS, 
            TRANSFER_CONTEXT_PTR(currentTd->TransferContext));                 


    if (ed->HwED.HeadP & HcEDHeadP_HALT) {
        // ed is 'halted'
        LOGENTRY(DeviceData, G, '_hlt', ed, EndpointData->HcdHeadP, 0);        

        clearHalt = (BOOLEAN) (ed->EdFlags & EDFLAG_NOHALT);

        // walk the swHeadP to the currentTD this (this will
        // be the first TD after the offending TD)

        td = EndpointData->HcdHeadP;
        while (td != currentTd) {
        
            transfer = TRANSFER_CONTEXT_PTR(td->TransferContext);        
            ASSERT_TRANSFER(DeviceData, transfer);                        

            OHCI_ASSERT(DeviceData, !TEST_FLAG(td->Flags, TD_FLAG_DONE));
            LOGENTRY(DeviceData, G, '_wtd', td, transfer->TcFlags, transfer);        

            if (td->HwTD.Asy.ConditionCode == HcCC_NoError) {
                // not the offending TD,
                // mark this TD done
                SET_FLAG(td->Flags, TD_FLAG_DONE);
                InsertTailList(&EndpointData->DoneTdList,
                               &td->DoneLink);
            } else {
                // some kind of error 
                if (td->HwTD.Asy.ConditionCode == HcCC_NotAccessed) {
                
                    // if the 'current transfer' is DONE because 
                    // of a short packet then the remaining TDs 
                    // need to be flushed out.
                    // current TD should be pointing at the next 
                    // TD to run (next transfer or status for control)
                    
                    SET_FLAG(td->Flags, TD_FLAG_DONE);
                    SET_FLAG(td->Flags, TD_FLAG_SKIP);
                    InsertTailList(&EndpointData->DoneTdList,
                                   &td->DoneLink);
                    
                    LOGENTRY(DeviceData, G, '_fld', td, 0, 0);             
                
                } else if (td->HwTD.Asy.ConditionCode == HcCC_DataUnderrun && 
                    TEST_FLAG(transfer->TcFlags, TC_FLAGS_SHORT_XFER_OK)) {

                    // special case HcCC_DataUnderrun.  this error 
                    // needs to be ignored if shortxferOK is set.

                    // cases handled (HcCC_DataUnderrun):
                    //
                    // 1. control transfer and error before the status phase w/
                    //      short xfer OK 
                    //      we need to advance to the status phase and ignore 
                    //      error and resume ep
                    //
                    // 2. interrupt/bulk with short xfer OK, ignore the error 
                    //      advance to the next transfer resume ep
                    //

                    LOGENTRY(DeviceData, G, '_sok', td, 0, 0);        
                                    

                    // reset the error on the offending Td
                    td->HwTD.Asy.ConditionCode = HcCC_NoError;    
                    // resume the ep
                    clearHalt = TRUE; 

                    // if this is a control transfer bump 
                    // HW headp to the status phase
                    if (!TEST_FLAG(td->Flags, TD_FLAG_CONTROL_STATUS) &&
                        transfer->StatusTd != NULL) {
                        // control transfer data phase, bump 
                        // HW headp to the status phase
                        TEST_TRAP();
                        RESET_HEADP(DeviceData, ed, transfer->StatusTd->PhysicalAddress);
                        currentTd = transfer->StatusTd;
                    } else {

                        // if the current transfer is a split we must flush
                        // all other split elements as well.
                        
                        if (transfer->TransferParameters->MiniportFlags & 
                            MPTX_SPLIT_TRANSFER) {

                            PTRANSFER_CONTEXT tmpTransfer;
                            PHCD_TRANSFER_DESCRIPTOR tmpTd;
                            ULONG seq;
                            
                            TEST_TRAP();

                            seq = transfer->TransferParameters->SequenceNumber;
                            tmpTd = transfer->NextXferTd;
                            tmpTransfer = 
                                TRANSFER_CONTEXT_PTR(tmpTd->TransferContext);

                            // find the first tranfer with a new sequence
                            // number or the tail of the list
                                
                            while (tmpTransfer != FREE_TD_CONTEXT && 
                                   tmpTransfer->TransferParameters->SequenceNumber 
                                       == seq) {

                                // mark all TDs done for this transfer
            
                                tmpTd = tmpTransfer->NextXferTd;
                                tmpTransfer = 
                                    TRANSFER_CONTEXT_PTR(tmpTd->TransferContext);                                           
                            }
                            
                            RESET_HEADP(DeviceData, ed, tmpTd->PhysicalAddress);   
                            currentTd = tmpTd;
                            
                        } else {
                            // bump HW headp to the next transfer
                            RESET_HEADP(DeviceData, ed, transfer->NextXferTd->PhysicalAddress);   
                            currentTd = transfer->NextXferTd;

                        }
                    }
                           
                    SET_FLAG(td->Flags, TD_FLAG_DONE);
                    InsertTailList(&EndpointData->DoneTdList,
                                   &td->DoneLink);
                    
                } else {
                    // general error, mark the TD as completed
                    // update Headp to point to the next transfer
                    LOGENTRY(DeviceData, G, '_ger', td, 0, 0);  
                    
                    SET_FLAG(td->Flags, TD_FLAG_DONE);
                    InsertTailList(&EndpointData->DoneTdList,
                                   &td->DoneLink);
                    RESET_HEADP(DeviceData, ed, transfer->NextXferTd->PhysicalAddress)
                    currentTd = transfer->NextXferTd;
                    
                 }
            }
            // we walk the SW links
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            
        } /* while */

    } else {
    
        // ed is not 'halted'

        // First walk the swHeadP to the current TD (hw headp)               
        // mark all TDs we find as completed
        //
        // NOTE: this step may be skipped if the 
        // done queue is reliable

        td = EndpointData->HcdHeadP;

        LOGENTRY(DeviceData, G, '_nht', td, currentTd, 0);        

        while (td != currentTd) {
            LOGENTRY(DeviceData, G, '_mDN', td, 0, 0); 
            SET_FLAG(td->Flags, TD_FLAG_DONE);
            InsertTailList(&EndpointData->DoneTdList,
                           &td->DoneLink);
                
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
        }            
    }

    // set the sw headp to the new current head
    EndpointData->HcdHeadP = currentTd;
    
    // now flush all completed TDs
    // do this in order of completion

    // now flush all completed TDs. Do it in order of completion.
    while (!IsListEmpty(&EndpointData->DoneTdList)) {
    
        PLIST_ENTRY listEntry;
    
        listEntry = RemoveHeadList(&EndpointData->DoneTdList);
        
        
        td = (PHCD_TRANSFER_DESCRIPTOR) CONTAINING_RECORD(
                     listEntry,
                     struct _HCD_TRANSFER_DESCRIPTOR, 
                     DoneLink);
           

        if ((td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)) ==
            (TD_FLAG_XFER | TD_FLAG_DONE)) {

            OHCI_ProcessDoneAsyncTd(DeviceData,
                                    td,
                                    TRUE);
        }
                                
    }
#if 0    
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if ((td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)) ==
            (TD_FLAG_XFER | TD_FLAG_DONE)) {
            OHCI_ProcessDoneAsyncTd(DeviceData,
                                    td,
                                    TRUE);
        }                                  
    }
#endif
     
    if (clearHalt) {
        // auto clear the halt condition and
        // resume processing on the endpoint
        LOGENTRY(DeviceData, G, '_cht', ed, 0, 0);  
        ed->HwED.HeadP &= ~HcEDHeadP_HALT;       
    }

}


VOID
OHCI_ProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    BOOLEAN CompleteTransfer
    )
/*++

Routine Description:

    process a completed TD

Parameters
    
--*/
{
    PTRANSFER_CONTEXT transferContext;    
    PENDPOINT_DATA endpointData;
    USBD_STATUS usbdStatus;

    transferContext = TRANSFER_CONTEXT_PTR(Td->TransferContext);

    transferContext->PendingTds--;
    endpointData = transferContext->EndpointData;

    LOGENTRY(DeviceData, G, '_Dtd', transferContext, 
                         Td->HwTD.Asy.ConditionCode,
                         Td);       

    if (TEST_FLAG(Td->Flags, TD_FLAG_SKIP)) {

        OHCI_ASSERT(DeviceData, HcCC_NotAccessed == Td->HwTD.Asy.ConditionCode);
        // td was unused, part of short-transfer
        LOGENTRY(DeviceData, G, '_skT', Td, transferContext, 0);
        Td->HwTD.Asy.ConditionCode = HcCC_NoError;
           
    } else {

        if (Td->HwTD.CBP) { 
            //
            // A value of 0 here indicates a zero length data packet
            // or that all bytes have been transfered.
            //
            // A non-zero value means we recieved a short packet and 
            // therefore need to adjust the transferCount to reflect bytes 
            // transferred
            
            //
            // The buffer is only spec'ed for length up to two 4K pages.
            // (BE is the physical address of the last byte in the
            // TD buffer.  CBP is the current byte pointer)
            //
            // TransferCount is intailized to the number of bytes to transfer,
            // we need to subtract the difference between the end and 
            // current ptr (ie end-current = bytes not transferred) and
            // update the TransferCount.

            // transfer count should never go negative
            // TransferCount will be zero on the status 
            // phase of a control transfer so we skip 
            // the calculation

            if (Td->TransferCount) {
                Td->TransferCount -=
                    /* have we gone further than a page? */
                    ((((Td->HwTD.BE ^ Td->HwTD.CBP) & ~OHCI_PAGE_SIZE_MASK)
                      ? OHCI_PAGE_SIZE : 0) +
                    /* minus the data buffer not used */
                    ((Td->HwTD.BE & OHCI_PAGE_SIZE_MASK) - 
                     (Td->HwTD.CBP & OHCI_PAGE_SIZE_MASK)+1));
            }            
            LOGENTRY(DeviceData, G, '_xfB', Td->HwTD.BE & OHCI_PAGE_SIZE_MASK, 
                             Td->HwTD.CBP & OHCI_PAGE_SIZE_MASK,
                             Td->TransferCount);                         
        }            

        if (HcTDDirection_Setup != Td->HwTD.Asy.Direction) {  
            
            // data phase of a control transfer or a bulk/int 
            // data transfer 
            LOGENTRY(DeviceData, G, '_Idt', Td, transferContext, Td->TransferCount);
            
            transferContext->BytesTransferred += Td->TransferCount;
        }
        
        if (HcCC_NoError == Td->HwTD.Asy.ConditionCode) { 

            LOGENTRY(DeviceData, G, '_tOK', Td->HwTD.CBP, 0, 0);    

        } else {
            // map the error to code in USBDI.H

            transferContext->UsbdStatus =
                (Td->HwTD.Asy.ConditionCode | 0xC0000000);
                
            LOGENTRY(DeviceData, G, '_tER', transferContext->UsbdStatus, 0, 0);
        }
    }        

    // mark the TD free
    OHCI_FREE_TD(DeviceData, endpointData, Td);
    
    if (transferContext->PendingTds == 0 && CompleteTransfer) {
        // all TDs for this transfer are done
        // clear the HAVE_TRANSFER flag to indicate 
        // we can teake another
        endpointData->PendingTransfers--;

        LOGENTRY(DeviceData, G, '_cpt', 
            transferContext->UsbdStatus, 
            transferContext, 
            transferContext->BytesTransferred);
            
        USBPORT_COMPLETE_TRANSFER(DeviceData,
                                  endpointData,
                                  transferContext->TransferParameters,
                                  transferContext->UsbdStatus,
                                  transferContext->BytesTransferred);
    }
}

// figure out which sgentry a particular offset in to 
// a client buffer falls
#define GET_SG_INDEX(sg, i, offset)\
    do {\
    for((i)=0; (i) < (sg)->SgCount; (i)++) {\
        if ((offset) >= (sg)->SgEntry[(i)].StartOffset &&\
            (offset) < (sg)->SgEntry[(i)].StartOffset+\
                (sg)->SgEntry[(i)].Length) {\
            break;\
        }\
    }\
    } while (0)

#define GET_SG_OFFSET(sg, i, offset, sgoffset)\
    (sgoffset) = (offset) - (sg)->SgEntry[(i)].StartOffset


ULONG
OHCI_MapAsyncTransferToTd(
    PDEVICE_DATA DeviceData,
    ULONG MaxPacketSize,
    ULONG LengthMapped,
    PTRANSFER_CONTEXT TransferContext,
    PHCD_TRANSFER_DESCRIPTOR Td, 
    PTRANSFER_SG_LIST SgList
    )
/*++

Routine Description:

    Maps a data buffer to TDs according to OHCI rules

    An OHCI TD can cover up to 8k with a single page crossing.

    Each sg entry represents one 4k OHCI 'page' 

x = pagebreak
c = current ptr
b = buffer start
e = buffer end


    {..sg[sgIdx]..}
b...|---
    x--c----
    [  ]
        \ 
         sgOffset
[      ]
        \
         LengthMapped   
    

case 1: (1 sg entry remains)
    (A)- transfer < 4k, no page breaks (if c=b sgOffset = 0)
    
      {.sg0...}     
      | b---->e      
      x-c------x
        [..TD.]

    (B)- last part of a transfer
    
            {..sgN..}
      b.....|.c---->e        
            x--------x    
              [..TD.]

case 2:  (2 sg entries remain)
    (A)- transfer < 8k, one page break (if c=b sgOffset = 0)
         
     {..sg0..}{..sg1..}
     |   b----|----->e
     x---c----x--------x   
         [.....TD....]
         
    (B)- last 8k of transfer

           {.sgN-1.}{..sgN..} 
      b....|--------|---->e
           x-c------x--------x        
           [.....TD.......]

case 3: (3+ sg entries remain)
    (A)- transfer 8k, two page breaks (c=b)

     {..sg0..}{..sg1..}{..sg2..}
         b----|--------|--->e
     x---c----x--------x--------x
         [.....TD...<>]
        <>=<TD length must be multiple of MaxPacketSize>

    (B)- continuation of large tarnsfer

           {.sgN-2.}{.sgN-1.}{..sgN..}
        b..|--------------------->e
           x--c-----x--------x--------x
              [.....TD......]  
        <TD length must be multiple of MaxPacketSize>    

Interesting DMA tests (USBTEST):

    length, offset - cases hit
    
    4096 0 - 1a
    4160 0 - 2a
    4096 512 - 2a
    8192 512 - 3a, 1b
    8192 513 - 3a, 2b
    12288 1 - 3a, 3b, 2b
    
Arguments:

Returns:

    LengthMapped
    
--*/
{
    HW_32BIT_PHYSICAL_ADDRESS logicalStart, logicalEnd;
    ULONG sgIdx, sgOffset;
    ULONG lengthThisTd;
    PTRANSFER_PARAMETERS transferParameters;
    
    // A TD can have up to one page crossing.  This means we 
    // can put two sg entries in to one TD, one for the first 
    // physical page, and one for the second.

    // point to first entry

    LOGENTRY(DeviceData, G, '_Mpr', TransferContext,
        0, LengthMapped); 

    transferParameters = TransferContext->TransferParameters;
    
    OHCI_ASSERT(DeviceData, SgList->SgCount != 0);

    GET_SG_INDEX(SgList, sgIdx, LengthMapped);
    LOGENTRY(DeviceData, G, '_Mpp', SgList, 0, sgIdx); 
    OHCI_ASSERT(DeviceData, sgIdx < SgList->SgCount);

    // check for one special case where the SG entries
    // all map to the same physical page
    if (TEST_FLAG(SgList->SgFlags, USBMP_SGFLAG_SINGLE_PHYSICAL_PAGE)) {
        // in this case we map each sg entry to a single TD
        LOGENTRY(DeviceData, G, '_cOD', SgList, 0, sgIdx);

//        TEST_TRAP();

        // adjust for the amount of buffer consumed by the 
        // previous TD
        logicalStart = 
            SgList->SgEntry[sgIdx].LogicalAddress.Hw32;
            
        lengthThisTd = SgList->SgEntry[sgIdx].Length;
        
        logicalEnd = SgList->SgEntry[sgIdx].LogicalAddress.Hw32; 
        logicalEnd += lengthThisTd;

        OHCI_ASSERT(DeviceData, lengthThisTd <= OHCI_PAGE_SIZE)            

        goto OHCI_MapAsyncTransferToTd_Done;

    }
    
    if ((SgList->SgCount-sgIdx) == 1) {
        // first case, 1 entries left 
        // ie <4k, we can fit this in 
        // a single TD.

#if DBG
        if (sgIdx == 0) {
            // case 1A
            // USBT dma test length 4096, offset 0
            // will hit this case
            // TEST_TRAP();
            LOGENTRY(DeviceData, G, '_c1a', SgList, 0, sgIdx);
        } else {
            // case 1B
            // USBT dma test length 8192 offset 512
            // will hit this case
            LOGENTRY(DeviceData, G, '_c1b', SgList, 0, sgIdx);
            
        }
#endif
        lengthThisTd = 
            transferParameters->TransferBufferLength - LengthMapped;

        // compute offset into this TD
        GET_SG_OFFSET(SgList, sgIdx, LengthMapped, sgOffset);       
        LOGENTRY(DeviceData, G, '_sgO', sgOffset, sgIdx, LengthMapped); 

        // adjust for the amount of buffer consumed by the 
        // previous TD
        logicalStart = 
            SgList->SgEntry[sgIdx].LogicalAddress.Hw32 + sgOffset;
        lengthThisTd -= sgOffset;
        
        logicalEnd = SgList->SgEntry[sgIdx].LogicalAddress.Hw32; 
        logicalEnd += lengthThisTd;

        LOGENTRY(DeviceData, G, '_sg1', logicalStart, 0, logicalEnd); 
        
    } else if ((SgList->SgCount - sgIdx) == 2) {
    
        // second case, 2 entries left 
        // ie <8k we can also fit this in 
        // a single TD.
#if DBG
        if (sgIdx == 0) {
            // case 2A
            // USBT dma test length 4160 offset 0
            // will hit this case
            LOGENTRY(DeviceData, G, '_c2a', SgList, 0, sgIdx);
            
        } else {
            // case 2B
            // USBT dma test length 8192 offset 513
            // will hit this case
            LOGENTRY(DeviceData, G, '_c2b', SgList, 0, sgIdx);
            //TEST_TRAP();
            // bugbug run with DMA test
        }
#endif
        lengthThisTd = 
            transferParameters->TransferBufferLength - LengthMapped;

        // compute offset into first TD
        GET_SG_OFFSET(SgList, sgIdx, LengthMapped, sgOffset);   
        LOGENTRY(DeviceData, G, '_sgO', sgOffset, sgIdx, LengthMapped); 
#if DBG
        if (sgIdx == 0) {
             OHCI_ASSERT(DeviceData, sgOffset == 0);
        }
#endif

        // adjust pointers for amount consumed by previous TD
        logicalStart = SgList->SgEntry[sgIdx].LogicalAddress.Hw32 + 
            sgOffset;
            
        logicalEnd = SgList->SgEntry[sgIdx+1].LogicalAddress.Hw32; 
        logicalEnd += SgList->SgEntry[sgIdx+1].Length;

        LOGENTRY(DeviceData, G, '_sg2', logicalStart, 
            lengthThisTd, logicalEnd); 
        
    } else {
        // third case, more than 2 sg entries.
        //
        ULONG adjust, packetCount;
#if DBG
        if (sgIdx == 0) {
            // case 3A
            // USBT dma test length 8192 offset 512
            // will hit this case
            LOGENTRY(DeviceData, G, '_c3a', SgList, 0, sgIdx);
            
        } else {
            // case 3B
            // USBT dma test length 12288 offset 1
            // will hit this case
            LOGENTRY(DeviceData, G, '_c3b', SgList, 0, sgIdx);
            
        }
#endif        
        // sg offset is the offset in to the current TD to start
        // using
        // ie it is the number of bytes already consumed by the 
        // previous td
        GET_SG_OFFSET(SgList, sgIdx, LengthMapped, sgOffset);   
        LOGENTRY(DeviceData, G, '_sgO', sgOffset, sgIdx, LengthMapped); 
#if DBG
        if (sgIdx == 0) {
             OHCI_ASSERT(DeviceData, sgOffset == 0);
        }
#endif
        //
        // consume the next two sg entrys
        //
        logicalStart = SgList->SgEntry[sgIdx].LogicalAddress.Hw32+
            sgOffset;

        logicalEnd = SgList->SgEntry[sgIdx+1].LogicalAddress.Hw32+
            SgList->SgEntry[sgIdx+1].Length;             
        
        lengthThisTd = SgList->SgEntry[sgIdx].Length +
                       SgList->SgEntry[sgIdx+1].Length -
                       sgOffset;

        // round TD length down to the highest multiple
        // of max_packet size
        
        packetCount = lengthThisTd/MaxPacketSize;
        LOGENTRY(DeviceData, G, '_sg3', logicalStart, packetCount, logicalEnd); 

        adjust = lengthThisTd - packetCount*MaxPacketSize;

        lengthThisTd = packetCount*MaxPacketSize;
        if (adjust) {        
            OHCI_ASSERT(DeviceData, adjust > (logicalEnd & 0x00000FFF));
            logicalEnd-=adjust;
            LOGENTRY(DeviceData, G, '_adj', adjust, lengthThisTd, logicalEnd); 
        }            

        OHCI_ASSERT(DeviceData, lengthThisTd != 0);
        OHCI_ASSERT(DeviceData, lengthThisTd >= SgList->SgEntry[sgIdx].Length);
        
    }

OHCI_MapAsyncTransferToTd_Done:

    Td->HwTD.CBP = logicalStart; 
    Td->HwTD.BE = logicalEnd-1; 
    LengthMapped += lengthThisTd;
    Td->TransferCount = lengthThisTd;
    
    LOGENTRY(DeviceData, G, '_Mp1', LengthMapped, lengthThisTd, Td);  

    return LengthMapped;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\int.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    int.c

Abstract:

    interrupt service routine
    
Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-19-99 : created, jdunn

--*/

#include "common.h"


BOOLEAN
OHCI_InterruptService (
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    BOOLEAN usbInt;
    PHC_OPERATIONAL_REGISTER hc;
    ULONG irqStatus, enabledIrqs, tmp;
    
    hc = DeviceData->HC;

    // assume it is not ours
    usbInt = FALSE;

    // see if we have lost the controller due to 
    // a surprise remove
    if (OHCI_HardwarePresent(DeviceData, FALSE) == FALSE) {
        return FALSE;
    }
    
    // get a mask of possible interrupts
    enabledIrqs = READ_REGISTER_ULONG (&hc->HcInterruptEnable);

    irqStatus = READ_REGISTER_ULONG(&hc->HcInterruptStatus);
    // mask off non-enabled irqs
    irqStatus &= enabledIrqs;

    // irqStatus now possibly contains bits set for any currently 
    // enabled interrupts

    if ((irqStatus != 0) &&
        (enabledIrqs & HcInt_MasterInterruptEnable)) { 

        // check for frame number overflow        
        if (irqStatus & HcInt_FrameNumberOverflow) {
            DeviceData->FrameHighPart
                += 0x10000 - (0x8000 & (DeviceData->HcHCCA->HccaFrameNumber
                                    ^ DeviceData->FrameHighPart));
        }

#if DBG
        if (irqStatus & HcInt_UnrecoverableError) {
            // something has gone terribly wrong
            OHCI_KdPrint((DeviceData, 0, "'HcInt_UnrecoverableError! DD(%x)\n",
                DeviceData));
            //DbgBreakPoint();
        }
#endif        

        // indications are that this came from the USB controller
        usbInt = TRUE;

        // disable interrupts until the DPC for ISR runs
        WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 
                             HcInt_MasterInterruptEnable);

    }        

    return usbInt;
}       


VOID
OHCI_InterruptDpc (
     PDEVICE_DATA DeviceData,
     BOOLEAN EnableInterrupts
    )
/*++

Routine Description:

    process an interrupt

Arguments:

Return Value:

--*/
{
    ULONG irqStatus;
    PHC_OPERATIONAL_REGISTER hc;
    ULONG doneQueue, cf;
    
    hc = DeviceData->HC;
    
    irqStatus = READ_REGISTER_ULONG(&hc->HcInterruptStatus); 

    cf = OHCI_Get32BitFrameNumber(DeviceData);
    // what was the reason for the interrupt?
    if (irqStatus & HcInt_RootHubStatusChange) {
        LOGENTRY(DeviceData, G, '_rhS', DeviceData, 0, 0);  
        USBPORT_INVALIDATE_ROOTHUB(DeviceData);
    }

    if (irqStatus & HcInt_WritebackDoneHead) {

        // controller indicates some done TDs
        doneQueue = DeviceData->HcHCCA->HccaDoneHead;
        LOGENTRY(DeviceData, G, '_dnQ', DeviceData, doneQueue, 
            cf);  

        // we will have a problem if we ever actually use the doneQ.
        // Currently we do not use it so the hydra bug where the doneQ
        // is wriiten back as zero won't hurt us.
        //if (doneQueue == 0) {
        //}

        // write the done head back to zero
        DeviceData->HcHCCA->HccaDoneHead = 0;
        LOGENTRY(DeviceData, G, '_dQZ', DeviceData, doneQueue, 0);  
        
//        if (DoneQueue) {
//            OpenHCI_ProcessDoneQueue(deviceData, (DoneQueue & 0xFFFFfffe));
//            //
//            // BUGBUG (?)  No interrupts can come in while processing
//            // the done queue.  Is this bad?  This might take a while.
//            //
//        } 
        // check all endpoints
        USBPORT_INVALIDATE_ENDPOINT(DeviceData, NULL);        
    }

    if (irqStatus & HcInt_StartOfFrame) {
        // got the SOF we requested, disable it
        WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 
                             HcInt_StartOfFrame);             
    }

    if (irqStatus & HcInt_ResumeDetected) {
        // got the resume, disable it
        WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 
                             HcInt_ResumeDetected);             
    }

    if (irqStatus & HcInt_UnrecoverableError) {
        // host controller is dead, try to recover...
        USBPORT_INVALIDATE_CONTROLLER(DeviceData, UsbMpControllerNeedsHwReset);
    }

    // acknowlege the interrupts we processed --
    // we should have proceesed them all
    WRITE_REGISTER_ULONG(&hc->HcInterruptStatus, irqStatus);

    // see if we need to re-enable ints
    if (EnableInterrupts) {
        // throw the master irq enable to allow more interupts
        WRITE_REGISTER_ULONG(&hc->HcInterruptEnable, 
                             HcInt_MasterInterruptEnable);    
    }                             

}


VOID
OHCI_RH_DisableIrq(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hc;
    
    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 
                         HcInt_RootHubStatusChange);  
}


VOID
OHCI_RH_EnableIrq(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hc;
    
    hc = DeviceData->HC;

    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable, 
                         HcInt_RootHubStatusChange);
}


ULONG
OHCI_Get32BitFrameNumber(
     PDEVICE_DATA DeviceData
    )
{
    ULONG hp, fn, n;
    /*
     * This code accounts for the fact that HccaFrameNumber is updated by the
     * HC before the HCD gets an interrupt that will adjust FrameHighPart. No
     * synchronization is nescisary due to great cleaverness. 
     */
    hp = DeviceData->FrameHighPart;
    fn = DeviceData->HcHCCA->HccaFrameNumber;
    n = ((fn & 0x7FFF) | hp) + ((fn ^ hp) & 0x8000);

    return n;
}


VOID
OHCI_InterruptNextSOF(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hc;
    
    hc = DeviceData->HC;

    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable, 
                         HcInt_StartOfFrame);  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\mpinit.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   mpinit.c

Abstract:

   miniport initialization

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2-19-99 : created, jdunn

--*/

#include "common.h"

// global registration packet for this miniport
USBPORT_REGISTRATION_PACKET RegistrationPacket;

NTSTATUS
DriverEntry(
     PDRIVER_OBJECT DriverObject,
     PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    RegistrationPacket.DeviceDataSize =
        sizeof(DEVICE_DATA);
    RegistrationPacket.EndpointDataSize =
        sizeof(ENDPOINT_DATA);
    RegistrationPacket.TransferContextSize =
        sizeof(TRANSFER_CONTEXT);

    // enough for HCCA plus
    RegistrationPacket.CommonBufferBytes = OHCI_COMMON_BUFFER_SIZE;

    /* miniport Functions */
    RegistrationPacket.MINIPORT_OpenEndpoint =
        OHCI_OpenEndpoint;
    RegistrationPacket.MINIPORT_PokeEndpoint =
        OHCI_PokeEndpoint;
    RegistrationPacket.MINIPORT_QueryEndpointRequirements =
        OHCI_QueryEndpointRequirements;
    RegistrationPacket.MINIPORT_CloseEndpoint =
        OHCI_CloseEndpoint;
    RegistrationPacket.MINIPORT_StartController =
        OHCI_StartController;
    RegistrationPacket.MINIPORT_StopController =
        OHCI_StopController;
    RegistrationPacket.MINIPORT_SuspendController =
        OHCI_SuspendController;
    RegistrationPacket.MINIPORT_ResumeController =
        OHCI_ResumeController;
    RegistrationPacket.MINIPORT_InterruptService =
        OHCI_InterruptService;
    RegistrationPacket.MINIPORT_InterruptDpc =
        OHCI_InterruptDpc;
    RegistrationPacket.MINIPORT_SubmitTransfer =
        OHCI_SubmitTransfer;
    RegistrationPacket.MINIPORT_SubmitIsoTransfer =
        OHCI_SubmitIsoTransfer;
    RegistrationPacket.MINIPORT_AbortTransfer =
        OHCI_AbortTransfer;
    RegistrationPacket.MINIPORT_GetEndpointState =
        OHCI_GetEndpointState;
    RegistrationPacket.MINIPORT_SetEndpointState =
        OHCI_SetEndpointState;
    RegistrationPacket.MINIPORT_PollEndpoint =
        OHCI_PollEndpoint;
    RegistrationPacket.MINIPORT_CheckController =
        OHCI_CheckController;
    RegistrationPacket.MINIPORT_Get32BitFrameNumber =
        OHCI_Get32BitFrameNumber;
    RegistrationPacket.MINIPORT_InterruptNextSOF =
        OHCI_InterruptNextSOF;
    RegistrationPacket.MINIPORT_EnableInterrupts =
        OHCI_EnableInterrupts;
    RegistrationPacket.MINIPORT_DisableInterrupts =
        OHCI_DisableInterrupts;
    RegistrationPacket.MINIPORT_PollController =
        OHCI_PollController;
    RegistrationPacket.MINIPORT_SetEndpointDataToggle =
        OHCI_SetEndpointDataToggle;
    RegistrationPacket.MINIPORT_GetEndpointStatus =
        OHCI_GetEndpointStatus;
    RegistrationPacket.MINIPORT_SetEndpointStatus =
        OHCI_SetEndpointStatus;
    RegistrationPacket.MINIPORT_ResetController =
        OHCI_ResetController;
    RegistrationPacket.MINIPORT_FlushInterrupts =
        OHCI_FlushInterrupts;        

    /* root hub functions */
    RegistrationPacket.MINIPORT_RH_GetRootHubData =
        OHCI_RH_GetRootHubData;
    RegistrationPacket.MINIPORT_RH_GetStatus =
        OHCI_RH_GetStatus;
    RegistrationPacket.MINIPORT_RH_GetPortStatus =
        OHCI_RH_GetPortStatus;
    RegistrationPacket.MINIPORT_RH_GetHubStatus =
        OHCI_RH_GetHubStatus;

    /* root hub port functions */
    RegistrationPacket.MINIPORT_RH_SetFeaturePortReset =
        OHCI_RH_SetFeaturePortReset;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortPower =
        OHCI_RH_SetFeaturePortPower;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortEnable =
        OHCI_RH_SetFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortSuspend =
        OHCI_RH_SetFeaturePortSuspend;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnable =
        OHCI_RH_ClearFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortPower =
        OHCI_RH_ClearFeaturePortPower;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspend =
        OHCI_RH_ClearFeaturePortSuspend;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnableChange =
        OHCI_RH_ClearFeaturePortEnableChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortConnectChange =
        OHCI_RH_ClearFeaturePortConnectChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange =
        OHCI_RH_ClearFeaturePortResetChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspendChange =
        OHCI_RH_ClearFeaturePortSuspendChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortOvercurrentChange =
        OHCI_RH_ClearFeaturePortOvercurrentChange;

    /* optional root hub functions */
    RegistrationPacket.MINIPORT_RH_DisableIrq =
        OHCI_RH_DisableIrq;
    RegistrationPacket.MINIPORT_RH_EnableIrq =
        OHCI_RH_EnableIrq;

    /* OPTIONAL DEBUG SERVICES */
    RegistrationPacket.MINIPORT_StartSendOnePacket =
        OHCI_StartSendOnePacket;
    RegistrationPacket.MINIPORT_EndSendOnePacket =
        OHCI_EndSendOnePacket;

    // OHCI needs both IRQ and memory resources
    RegistrationPacket.OptionFlags =
        USB_MINIPORT_OPT_NEED_IRQ |
        USB_MINIPORT_OPT_NEED_MEMORY |
        USB_MINIPORT_OPT_USB11;

    RegistrationPacket.HciType = USB_OHCI;
    RegistrationPacket.BusBandwidth = USB_11_BUS_BANDWIDTH;

    DriverObject->DriverUnload = OHCI_Unload;

    return USBPORT_RegisterUSBPortDriver(
                DriverObject,
                USB_MINIPORT_HCI_VERSION,
                &RegistrationPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\dbg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros
    
Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

// 
// Structure signatures
//

#define OHCI_TAG          'hymp'        //"HYMP"

// always log
#define DEBUG_LOG

#if DBG

// Triggers a break in the debugger in the registry key
// debugbreakOn is set.  These breakpoins are useful for
// debugging hardware/client software problems
//
 
#define DEBUG_BREAK(dd)  RegistrationPacket.USBPORTSVC_TestDebugBreak;                           

//
// This Breakpoint means we either need to test the code path 
// somehow or the code is not implemented.  ie either case we
// should not have any of these when the driver is finished
//

#define TEST_TRAP()      {\
                            DbgPrint("<OHCI TEST_TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                         }                            
                         
#define ASSERT_TRANSFER(dd, t) OHCI_ASSERT((dd), (t)->Sig == SIG_OHCI_TRANSFER)

ULONG
_cdecl
OHCI_KdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    );

#define   OHCI_KdPrint(_x_) OHCI_KdPrintX _x_

#define OHCI_ASSERT(dd, exp ) \
    if (!(exp)) {\
        RegistrationPacket.USBPORTSVC_AssertFailure( (dd), #exp, __FILE__, __LINE__, NULL );\
    }        


#define OHCI_ASSERT_ED(dd, ed) OHCI_ASSERT((dd), ((ed)->Sig == SIG_HCD_ED || \
                                                  (ed)->Sig == SIG_HCD_DUMMY_ED))

#else 

// debug macros for retail build

#define TEST_TRAP()

#define ASSERT_TRANSFER(dd, t)

#define DEBUG_BREAK(dd) 

#define OHCI_KdPrint(_x_)

#define OHCI_ASSERT_ED(dd, ed)

#define OHCI_ASSERT(dd, exp )

#endif /* DBG */

// retail and debug

#ifdef DEBUG_LOG

#define LOGENTRY(dd, mask, sig, info1, info2, info3)  \
    RegistrationPacket.USBPORTSVC_LogEntry( (dd), (mask), (sig), \
        (ULONG_PTR)(info1), (ULONG_PTR)(info2), (ULONG_PTR)(info3) )

#else

#define LOGENTRY(dd, mask, sig, info1, info2, info3)

#endif


#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\errata.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    errata.c

Abstract:

    documented errata for all of our favorite types of 
    openhci USB controllers.

Environment:

    Kernel mode

Revision History:

    12-31-99 : created jdunn

--*/


#include "common.h"

/* 
    Hydra Errata

    The folllowing code is specific for the COMPAQ Hydra OHCI hardware
    design -- it should not be executed on other controllers
*/

// Hydra HighSpeed/LowSpeed Data Corruption Bug


VOID
InitializeHydraHsLsFix(
    )
/*++

Routine Description:

    Data corruption can occur on the Hydra part when iso transfers 
    follow lowspeed interrupt transfers.  

    The classic repro of this bug is playing 'dance of the surgar 
    plum fairys' on USB speakers while moving the USB mouse. This 
    generates low speed interrupt INs and High speed ISO OUTs.

    The 'fix' is to introduce a 'specific delay before the HS Iso 
    transfers and after teh LS interrupt transfers.


    (31) -\ 
          (15)-\
    (32) -/     \
                (7 )-\
    (33) -\     /     \
          (16)-/       \
    (34) -/   
    
    
Arguments:

Return Value:

    none

--*/
{

    PHCD_ENDPOINT_DESCRIPTOR ed;
    PHCD_DEVICE_DATA deviceData;
    PHCD_TRANSFER_DESCRIPTOR td;
    ULONG i;

    OpenHCI_KdPrint((1, "'*** WARNING: Turning on HS/LS Fix ***\n"));
    //
    // **
    // WARNING:
    /*
        The folllowing code is specific for the COMPAQ OHCI hardware
        design -- it should not be executed on other controllers
    */

    /* Dummy ED must look like this:

    ED->TD->XXX
    XXX is bogus address 0xABADBABE
    (HeadP points to TD)
    (TailP points to XXX)

    TD has CBP=0 and BE=0
    NextTD points to XXX

    TD will never be retired by the hardware

    */

    //
    // create a dummy interrupt ED with period 1
    //
    deviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;

    // Reserve the 17 dummy EDs+TDs
    //
    OpenHCI_ReserveDescriptors(deviceData, 34);

    // add 17 dummy EDs+TDs
    //
    for (i=0; i< 17; i++) {
        ed = InsertEDForEndpoint(deviceData, NULL, ED_INTERRUPT_1ms,
                &td);

        OHCI_ASSERT(td);
        ed->Endpoint = NULL;

        ed->HcED.FunctionAddress = 0;
        ed->HcED.EndpointNumber = 0;
        ed->HcED.Direction = 0;
        ed->HcED.LowSpeed = 0;
        ed->HcED.sKip = 1;
        ed->HcED.Isochronous = 0;
        ed->HcED.MaxPacket = 0;

        //fixup the TD
        td->Canceled = FALSE;
        td->NextHcdTD = (PVOID)-1;
        td->UsbdRequest = MAGIC_SIG;

        td->HcTD.CBP = 0;
        td->HcTD.BE = 0;
        td->HcTD.Control = 0;
        td->HcTD.NextTD = 0xABADBABE;

        // set head/Tail pointers
//        ed->HcED.HeadP = td->PhysicalAddress;
//        ed->HcED.TailP = 0xABADBABE;

        // turn it on
        LOGENTRY(G, 'MagI', 0, ed, td);
        //TEST_TRAP();
        //ed->HcED.sKip = 0;

    }

    return STATUS_SUCCESS;
}



/*
    NEC Errata
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\errata.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    errata.c

Abstract:

    documented errata for all of our favorite types of 
    openhci USB controllers.

Environment:

    Kernel mode

Revision History:

    12-31-99 : created jdunn

--*/


#include "common.h"

/* 
    Hydra Errata

    The folllowing code is specific for the COMPAQ Hydra OHCI hardware
    design -- it should not be executed on other controllers
*/

// Hydra HighSpeed/LowSpeed Data Corruption Bug


ULONG
InitializeHydraHsLsFix(
     PDEVICE_DATA DeviceData,
     PUCHAR CommonBuffer,
     HW_32BIT_PHYSICAL_ADDRESS CommonBufferPhys
    )
/*++

Routine Description:

    Data corruption can occur on the Hydra part when iso and bulk 
    transfers follow lowspeed interrupt transfers.  

    The classic repro of this bug is playing 'dance of the surgar 
    plum fairys' on USB speakers while moving the USB mouse. This 
    generates low speed interrupt INs and High speed ISO OUTs.

    The 'fix' is to introduce a 'specific delay before the HS Iso 
    transfers and after the LS interrupt transfers.

                <Interrupt Schedule>

    staticEd(period)

                 (4) -\ 
                       (2)-\
                 (4) -/     \
                             (1 )-><DELAY>->(Iso)->(Control and Bulk)
                 (4) -\      /     
                        (2)-/       
                 (4) -/   
    
    
    The <DELAY> is a predifined set of dummy EDs and TDs.
    
Arguments:

Return Value:

    returns the ammount of common buffer used for the 'hack'

--*/
{
    PHCD_ENDPOINT_DESCRIPTOR ed, tailEd;
    PHCD_TRANSFER_DESCRIPTOR td;
    PHC_STATIC_ED_DATA static1msEd;   
    ULONG i;
    ULONG bufferUsed = 0;

    static1msEd = &DeviceData->StaticEDList[ED_INTERRUPT_1ms];
    
    /* 

    To achieve the proper timming we must insert 17 dumy EDs 
    each dummy ED must look like this:

    ED->TD->XXX
    XXX is bogus address = 0xABADBABE
    (HeadP points to TD)
    (TailP points to XXX)

    TD has CBP=0 and BE=0
    NextTD points to XXX

    The TD will never be retired by the hardware

    so we end up with:

    staticEd(1ms)->dED(1)->dED(2)....dED(17)->(1ms transferEds)

    NOTE: Since the problem only occurs with low speed, and 
    low speed may not have a period < 8ms we don't need to 
    worry about 1ms interrupt transfers.


    */

    //
    // add 17 dummy ED TD pairs
    //
    
    for (i=0; i< 17; i++) {
    
        ed = (PHCD_ENDPOINT_DESCRIPTOR) CommonBuffer;

        RtlZeroMemory(ed, sizeof(*ed));
        ed->PhysicalAddress = CommonBufferPhys;

        CommonBuffer += sizeof(HCD_TRANSFER_DESCRIPTOR);
        CommonBufferPhys += sizeof(HCD_TRANSFER_DESCRIPTOR);
        bufferUsed += sizeof(HCD_ENDPOINT_DESCRIPTOR);

        td = (PHCD_TRANSFER_DESCRIPTOR) CommonBuffer;

        RtlZeroMemory(td, sizeof(*td));
        td->PhysicalAddress = CommonBufferPhys;

        CommonBuffer += sizeof(HCD_ENDPOINT_DESCRIPTOR);
        CommonBufferPhys += sizeof(HCD_ENDPOINT_DESCRIPTOR);
        bufferUsed += sizeof(HCD_ENDPOINT_DESCRIPTOR);

        LOGENTRY(DeviceData, G, 'hyF', 0, ed, td);

        // initialize the ed and td
        
        ed->Sig = SIG_HCD_DUMMY_ED;
        ed->EdFlags = 0;

        // inint dummy HW ED
        ed->HwED.sKip = 1;
        ed->HwED.HeadP = td->PhysicalAddress;
        ed->HwED.TailP = 0xABADBABE;

        td->Sig = SIG_HCD_TD;
        td->Flags = 0;
        td->HwTD.NextTD = 0xABADBABE;

        // insert in the schedule on the 1ms list

        if (IsListEmpty(&static1msEd->TransferEdList)) { 

            //
            // list is currently empty,
            // link it to the head of the hw queue
            //

            DeviceData->HydraLsHsHackEd = ed;

            InsertHeadList(&static1msEd->TransferEdList, 
                           &ed->SwLink.List);
        
            // PhysicaHead is the address of the 
            // NextED entry in the static HwED for the list list,  
            // (ie &HwED->nextEd == physicalHead)
            // so we end up with
            // StaticEd->TransferHwED->TransferHwED->NextStaticED
            //
                        
            LOGENTRY(DeviceData, G, '_INh', 
                    static1msEd->PhysicalHead, 
                    ed, 
                    static1msEd);
                    
            // tail points to old list head HW ed head
            ed->HwED.NextED = *static1msEd->PhysicalHead;
            // new head is this ed
            *static1msEd->PhysicalHead = ed->PhysicalAddress;
        } else {
        
            //
            // Something already on the list,
            // Link ED into tail of transferEd list
            //
        
            tailEd = CONTAINING_RECORD(static1msEd->TransferEdList.Blink,
                                       HCD_ENDPOINT_DESCRIPTOR,
                                       SwLink);
                                  
            LOGENTRY(DeviceData, G, '_Led', 0, tailEd, static1msEd);
            InsertTailList(&static1msEd->TransferEdList, &ed->SwLink.List);
            ed->HwED.NextED = 0;
            tailEd->HwED.NextED = ed->PhysicalAddress;
        }
    }

    return bufferUsed;
}



/*
    NEC Errata
*/


/*
    AMD Errata
*/

ULONG
OHCI_ReadRhDescriptorA(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    Read the number of downstream ports and other root hub characteristics
    from the HcRhDescriptorA register.
    
    If this register reads as all zero or any of the reserved bits are set
    then try reading the register again.  This is a workaround for some
    early revs of the AMD K7 chipset, which can sometimes return bogus values
    if the root hub registers are read while the host controller is
    performing PCI bus master ED & TD reads.

    Attempt up to ten reads if a reserved bit is set. If a reserved bit is 
    set on or register is zero on purpose we will still return the 
    register after doing penece of ten reads thanks to AMD.

Arguments:

Return Value:

    descrA register (hopefully)

--*/
{
    HC_RH_DESCRIPTOR_A descrA;
    PHC_OPERATIONAL_REGISTER hc;
    ULONG i;

    hc = DeviceData->HC;
    
    for (i = 0; i < 10; i++) {
    
        descrA.ul = READ_REGISTER_ULONG(&hc->HcRhDescriptorA.ul);

        if ((descrA.ul) && (!(descrA.ul & HcDescA_RESERVED))) {
            break;
        } else {
            KeStallExecutionProcessor(5);
        }
        
    }

    return descrA.ul;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\roothub.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   roothub.c

Abstract:

   miniport root hub

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2-19-99 : created, jdunn

implements the following miniport functions:

MINIPORT_RH_GetStatus
MINIPORT_RH_GetPortStatus 
MINIPORT_RH_GethubStatus 

MINIPORT_RH_SetFeaturePortReset
MINIPORT_RH_SetFeaturePortSuspend
MINIPORT_RH_SetFeaturePortPower

MINIPORT_RH_ClearFeaturePortEnable
MINIPORT_RH_ClearFeaturePortSuspend
MINIPORT_RH_ClearFeaturePortPower

MINIPORT_RH_ClearFeaturePortConnectChange
MINIPORT_RH_ClearFeaturePortResetChange
MINIPORT_RH_ClearFeaturePortEnableChange
MINIPORT_RH_ClearFeaturePortSuspendChange
MINIPORT_RH_ClearFeaturePortOvercurrentChange


--*/

#include "common.h"

VOID
OHCI_RH_GetRootHubData(
     PDEVICE_DATA DeviceData,
     PROOTHUB_DATA HubData
    )
/*++
    return info about the root hub
--*/    
{

    HC_RH_DESCRIPTOR_A descrA;
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;

    descrA.ul = OHCI_ReadRhDescriptorA(DeviceData);
    OHCI_ASSERT(DeviceData, (descrA.ul) && (!(descrA.ul & HcDescA_RESERVED)));

    HubData->NumberOfPorts = descrA.s.NumberDownstreamPorts;
    HubData->HubCharacteristics.us = (USHORT)descrA.s.HubChars; 
    HubData->PowerOnToPowerGood = descrA.s.PowerOnToPowerGoodTime;    

    // This may upset the stopwatch fanatics, but it appears that a minimum
    // delay is necessary here in some cases.  One example being resuming from
    // hibernation on a 7800 with a USB IntelliMouse Explorer attached.
    // (The delay happens in the hub driver after powering on each port).
    //
    HubData->PowerOnToPowerGood = max(descrA.s.PowerOnToPowerGoodTime, 25);

    // OHCI controllers generally use the 1.0 USB spec.
    // HubChars were revised in 1.1 so we need to do some 
    // mapping.
    // We will assume it is gang switched unless the port 
    // power switching bit is set
    
    HubData->HubCharacteristics.PowerSwitchType = 
            USBPORT_RH_POWER_SWITCH_GANG;
            
    if (descrA.ul & HcDescA_PowerSwitchingModePort) {  
        HubData->HubCharacteristics.PowerSwitchType = 
            USBPORT_RH_POWER_SWITCH_PORT;
    }                

    // this value is the current consumed by the hub 
    // brains, for the embedded hub this doesn't make
    // much sense.
    // so we report zero.
    //
    HubData->HubControlCurrent = 0;
    
}


USB_MINIPORT_STATUS
OHCI_RH_GetStatus(
     PDEVICE_DATA DeviceData,
     PUSHORT Status
    )
/*++
    get the device status
--*/
{
    // the root hub is self powered
    *Status = USB_GETSTATUS_SELF_POWERED;

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortEnable (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_ClearPortEnable);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortPower (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;

    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_ClearPortPower);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_RH_GetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    )
/*++
    get the status of a partuclar port
--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    PULONG  pulRegister;
    ULONG   statusAsUlong;
    ULONG   i;

    hc = DeviceData->HC;

    // hw array is zero based
    //
    pulRegister = &hc->HcRhPortStatus[PortNumber-1];

    //
    // by coincedence rhStatus register defined in OHCI is an 
    // exact match of the RH_PORT_STATUS define in the USB core
    // spec.
    //

    // If this register reads as all zero or any of the reserved bits are set
    // then try reading the register again.  This is a workaround for some
    // early revs of the AMD K7 chipset, which can sometimes return bogus values
    // if the root hub registers are read while the host controller is
    // performing PCI bus master ED & TD reads.
    //
    for (i = 0; i < 10; i++)
    {
        statusAsUlong = READ_REGISTER_ULONG(pulRegister);

        if ((statusAsUlong) && (!(statusAsUlong & HcRhPS_RESERVED)))
        {
            break;
        }
        else
        {
            KeStallExecutionProcessor(5);
        }
    }

    portStatus->ul = statusAsUlong;

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in reset
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_SetPortReset);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in suspend
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_SetPortSuspend);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_ClearPortSuspend);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortSuspendChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_ClearPortSuspendStatusChange);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortOvercurrentChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;

    if (PortNumber == 0) {
        WRITE_REGISTER_ULONG(&hc->HcRhStatus, HcRhS_ClearOverCurrentIndicatorChange);
    } else {
        WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_ClearPortOverCurrentChange);
    }        
    

    return USBMP_STATUS_SUCCESS;
}     



USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_SetPortPower);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_SetPortEnable);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
   
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], 
        HcRhPS_ClearConnectStatusChange);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], 
        HcRhPS_ClearPortEnableStatusChange);

    return USBMP_STATUS_SUCCESS;
}  


USB_MINIPORT_STATUS
OHCI_RH_GetHubStatus(
     PDEVICE_DATA DeviceData,
     PRH_HUB_STATUS HubStatus
    )
{
    PHC_OPERATIONAL_REGISTER hc;
    ULONG statusAsUlong;
    
    hc = DeviceData->HC;

    // we will never report a localpower change
    HubStatus->LocalPowerLost = 0;
    HubStatus->LocalPowerChange = 0;

    // see if we should reort an overcurrent condition
    // 
    statusAsUlong = 
        READ_REGISTER_ULONG(&hc->HcRhStatus);
    
    HubStatus->OverCurrent = 
        (statusAsUlong & HcRhS_OverCurrentIndicator) ? 1: 0;

    HubStatus->OverCurrentChange = 
        (statusAsUlong & HcRhS_OverCurrentIndicatorChange) ? 1: 0;

    return USBMP_STATUS_SUCCESS;    
}


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], 
        HcRhPS_ClearPortResetStatusChange);

    return USBMP_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\iso.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   iso.c

Abstract:

   miniport transfer code for iso

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    3-1-00 : created, jdunn

--*/

#include "common.h"

//implements the following miniport functions:

USB_MINIPORT_STATUS
OHCI_OpenIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, edPhys;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i, available, tdCount;
        
    LOGENTRY(DeviceData, G, '_opS', 0, 0, 0);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    available = EndpointParameters->CommonBufferBytes;


#if DBG
   {
        ULONG offset;
    
        offset = BYTE_OFFSET(buffer);

        // OHCI requires 16 byte alignemnt
        OHCI_ASSERT(DeviceData, (offset % 16) == 0);    
    }
#endif    
   
    // use control list
    EndpointData->StaticEd = 
        &DeviceData->StaticEDList[ED_ISOCHRONOUS];
        
    // make the Ed
    ed = (PHCD_ENDPOINT_DESCRIPTOR) buffer;
    
    edPhys = phys;
    phys += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    buffer += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    available -= sizeof(HCD_ENDPOINT_DESCRIPTOR);
    
    EndpointData->TdList = (PHCD_TD_LIST) buffer;

    tdCount = available/sizeof(HCD_TRANSFER_DESCRIPTOR);
    LOGENTRY(DeviceData, G, '_tdC', tdCount, TDS_PER_ISO_ENDPOINT, 0);
    OHCI_ASSERT(DeviceData, tdCount >= TDS_PER_ISO_ENDPOINT);

    EndpointData->TdCount = tdCount;
    for (i=0; i<tdCount; i++) {
        OHCI_InitializeTD(DeviceData,
                          EndpointData,
                          &EndpointData->TdList->Td[i],
                          phys);                                         
                             
        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);    
    }

    EndpointData->HcdEd = 
        OHCI_InitializeED(DeviceData,
                             EndpointData,
                             ed,
                             &EndpointData->TdList->Td[0],
                             edPhys);            

    // iso endpoints do not halt
    ed->EdFlags = EDFLAG_NOHALT;
    
    OHCI_InsertEndpointInSchedule(DeviceData,
                                  EndpointData);
                                      
    return USBMP_STATUS_SUCCESS;            
}


USB_MINIPORT_STATUS
OHCI_IsoTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PMINIPORT_ISO_TRANSFER IsoTransfer
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/    
{
    PHCD_TRANSFER_DESCRIPTOR td, lastTd;
    ULONG currentPacket;
    
    EndpointData->PendingTransfers++;

    // we have enough tds, program the transfer

    LOGENTRY(DeviceData, G, '_nby', EndpointData, TransferParameters, 
        EndpointData->HcdEd);

    TransferContext->IsoTransfer = IsoTransfer;
    
    //        
    // grab the dummy TD from the tail of the queue
    //
    td = EndpointData->HcdTailP;
    OHCI_ASSERT(DeviceData, td->Flags & TD_FLAG_BUSY);

    currentPacket = 0;

    LOGENTRY(DeviceData, G, '_iso', EndpointData, TransferContext, 
        td);

    do {
    
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
        TransferContext->PendingTds++;
        
        currentPacket = 
            OHCI_MapIsoTransferToTd(DeviceData,
                                    IsoTransfer,
                                    currentPacket, 
                                    td);              

        // alloc another iso TD
        lastTd = td;
        td = OHCI_ALLOC_TD(DeviceData, EndpointData);
        SET_NEXT_TD(lastTd, td);        
        
    } while (currentPacket < IsoTransfer->PacketCount);

    // td should be the new dummy,
    // now put a new dummy TD on the tail of the EP queue
    //

    SET_NEXT_TD_NULL(td);
    
    //
    // Set new TailP in ED
    // note: This is the last TD in the list and the place holder.
    //

    TransferContext->NextXferTd = 
        EndpointData->HcdTailP = td;
//if (TransferParameters->TransferBufferLength > 128) {
//    TEST_TRAP();
//}
    
    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Til',  TransferContext->PendingTds , 
        td->PhysicalAddress, EndpointData->HcdEd->HwED.HeadP);
    EndpointData->HcdEd->HwED.TailP = td->PhysicalAddress;

    LOGENTRY(DeviceData, G, '_igo', EndpointData->HcdHeadP,
                 TransferContext->TcFlags, 0);                   
                 
//if (TransferParameters->TransferBufferLength > 128) {
//    TEST_TRAP();
//}
    
    return USBMP_STATUS_SUCCESS;
}


ULONG
OHCI_MapIsoTransferToTd(
     PDEVICE_DATA DeviceData,
     PMINIPORT_ISO_TRANSFER IsoTransfer,
     ULONG CurrentPacket,
     PHCD_TRANSFER_DESCRIPTOR Td 
    )
/*++

Routine Description:

    

Arguments:

Returns:

    LengthMapped
    
--*/
{
    HW_32BIT_PHYSICAL_ADDRESS logicalStart, logicalEnd;
    HW_32BIT_PHYSICAL_ADDRESS startPage, endPage;
    PMINIPORT_ISO_PACKET iPacket;
    ULONG packetsThisTd;
    ULONG lengthThisTd, offset;
    USHORT startFrame;

    packetsThisTd = 0;
    lengthThisTd = 0;
    logicalStart = 0;

    LOGENTRY(DeviceData, G, '_mpI', CurrentPacket, 
            IsoTransfer->PacketCount, 0);    
    OHCI_ASSERT(DeviceData, CurrentPacket < IsoTransfer->PacketCount);

    Td->FrameIndex = CurrentPacket;
    
    while (CurrentPacket < IsoTransfer->PacketCount) {
    
        LOGENTRY(DeviceData, G, '_mpC', CurrentPacket, 
            IsoTransfer->PacketCount, 0);    

        iPacket = &IsoTransfer->Packets[CurrentPacket];

        OHCI_ASSERT(DeviceData, iPacket->BufferPointerCount < 3);
        OHCI_ASSERT(DeviceData, iPacket->BufferPointerCount != 0);

        // cases are:
        // case 1 - packet has pagebreak
        //   case 1a we have already filled in part of the current TD
        //      <bail, next pass will be 1b>
        //
        //   case 1b we have not used the current TD yet
        //      <add packet to TD and bail>
        //
        // case 2 - packet has no pagebreak and will fit
        //   case 2a current packet is on different page than previous
        //           packet
        //      <add packet and bail>
        //
        //   case 2b current packet is on same page as previous packet
        //      <add packet and try to add another>
        //
        //   case 2c TD has not been used yet
        //      <add packet and try to add another>
        //
        // case 3 - packet will not fit
        //      <bail>
        
        // does the packet have a page break?
        if (iPacket->BufferPointerCount > 1) {
            // yes,
            // case 1
            
            if (packetsThisTd != 0) {
                // case 1a 
                // we have packets in this TD bail, 
                // leave it for next time
                LOGENTRY(DeviceData, G, '_c1a', 0, 0, lengthThisTd);
                break;
            } 
            
            // case 1b give the packet its own TD
            
            // convert to a 16-bit frame number
            startFrame = (USHORT) iPacket->FrameNumber;

            LOGENTRY(DeviceData, G, '_c1b', iPacket, CurrentPacket, startFrame);

            logicalStart = iPacket->BufferPointer0.Hw32 & ~OHCI_PAGE_SIZE_MASK;
            offset = iPacket->BufferPointer0.Hw32 & OHCI_PAGE_SIZE_MASK;
            
            logicalEnd = iPacket->BufferPointer1.Hw32 + 
                iPacket->BufferPointer1Length;  
                
            lengthThisTd = iPacket->Length;
            packetsThisTd++;

            CurrentPacket++;
            
            Td->HwTD.Packet[0].Offset = (USHORT) offset;
            Td->HwTD.Packet[0].Ones = 0xFFFF;

            break;
        }

        // will this packet fit in the current Td?
        
        if (packetsThisTd < 8 && 
            (lengthThisTd+iPacket->Length < OHCI_PAGE_SIZE * 2)) {

            LOGENTRY(DeviceData, G, '_fit', iPacket, CurrentPacket, 0);

            OHCI_ASSERT(DeviceData, iPacket->BufferPointerCount == 1);
            OHCI_ASSERT(DeviceData, iPacket->Length == 
                iPacket->BufferPointer0Length);
                
            // yes
            // case 2
            if (logicalStart == 0) {
                // first packet, set logical start & end
                // case 2c and frame number
                LOGENTRY(DeviceData, G, '_c2c', iPacket, CurrentPacket, 0);

                startFrame = (USHORT) iPacket->FrameNumber;

                offset = iPacket->BufferPointer0.Hw32 & OHCI_PAGE_SIZE_MASK;
                logicalStart = iPacket->BufferPointer0.Hw32 & ~OHCI_PAGE_SIZE_MASK;
                
                logicalEnd = iPacket->BufferPointer0.Hw32 + 
                    iPacket->BufferPointer0Length;
                lengthThisTd += iPacket->Length; 
                Td->HwTD.Packet[0].Offset = (USHORT) offset;
                Td->HwTD.Packet[0].Ones = 0xFFFF;
                packetsThisTd++;
                    
                CurrentPacket++;
                
            } else {
                // not first packet
                LOGENTRY(DeviceData, G, '_adp', iPacket, CurrentPacket, 
                    packetsThisTd);

                logicalEnd = iPacket->BufferPointer0.Hw32 + 
                    iPacket->Length;
                OHCI_ASSERT(DeviceData, lengthThisTd < OHCI_PAGE_SIZE * 2);                    
                
                Td->HwTD.Packet[packetsThisTd].Offset 
                    = (USHORT) (lengthThisTd + offset);     
                Td->HwTD.Packet[packetsThisTd].Ones = 0xFFFF;                    
                
                lengthThisTd += iPacket->Length;                     
                packetsThisTd++;

                startPage = logicalStart & ~OHCI_PAGE_SIZE_MASK;                     
                endPage = logicalEnd & ~OHCI_PAGE_SIZE_MASK;
                
                CurrentPacket++;
                
                // did we cross a page?
                if (startPage != endPage) {
                    // yes, bail now
                    LOGENTRY(DeviceData, G, '_c2a', Td, CurrentPacket, 0);
                    break;
                }

                LOGENTRY(DeviceData, G, '_c2b', Td, CurrentPacket, 0);

                // no, keep going
            }
        } else {
            // won't fit
            // bail and leave it for next time
            LOGENTRY(DeviceData, G, '_ca3', Td, CurrentPacket, 0);
            break;
        }
    }

    Td->HwTD.CBP = logicalStart; 
    Td->HwTD.BE = logicalEnd-1; 
    Td->TransferCount = lengthThisTd;
    Td->HwTD.Iso.StartingFrame = startFrame;
    Td->HwTD.Iso.FrameCount = packetsThisTd-1;
    Td->HwTD.Iso.Isochronous = 1;
    Td->HwTD.Iso.IntDelay = HcTDIntDelay_0ms;
    LOGENTRY(DeviceData, G, '_iso', Td, 0, CurrentPacket);
    
    return CurrentPacket;
}


VOID
OHCI_ProcessDoneIsoTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    BOOLEAN CompleteTransfer
    )
/*++

Routine Description:

    process a completed Iso TD

Parameters
    
--*/
{
    PTRANSFER_CONTEXT transferContext;    
    PENDPOINT_DATA endpointData;
    USBD_STATUS usbdStatus;
    PMINIPORT_ISO_TRANSFER isoTransfer;
    ULONG frames, n, i;

    transferContext = TRANSFER_CONTEXT_PTR(Td->TransferContext);
    isoTransfer = transferContext->IsoTransfer;

    transferContext->PendingTds--;
    endpointData = transferContext->EndpointData;

    LOGENTRY(DeviceData, G, '_Did', transferContext, 
                         0,
                         Td);       

    // walk the PSWs and fill in the IsoTransfer structure

    frames = Td->HwTD.Iso.FrameCount+1;
    n = Td->FrameIndex;
    
    for (i = 0; i<frames; i++) {
    
        PMINIPORT_ISO_PACKET mpPak;   
        PHC_OFFSET_PSW psw;
        
        mpPak = &isoTransfer->Packets[n+i];
        psw = &Td->HwTD.Packet[i];

        mpPak->LengthTransferred = 0;
        
        if (IN_TRANSFER(transferContext->TransferParameters)) {
            // in transfer                         

            // if we got an error the length may still be
            // valid, so we return it
            if (psw->ConditionCode != HcCC_NotAccessed) {
                mpPak->LengthTransferred = psw->Size;
            }
            LOGENTRY(DeviceData, G, '_isI', 
                    i,
                    mpPak->LengthTransferred, 
                    psw->ConditionCode);

        } else {
            // out transfer 
            
            // assume all data was sent if no error is indicated
            if (psw->ConditionCode == HcCC_NoError) {
                mpPak->LengthTransferred = mpPak->Length;
            }
            LOGENTRY(DeviceData, G, '_isO', 
                    i,
                    mpPak->LengthTransferred, 
                    psw->ConditionCode);
        }

        if (psw->ConditionCode == HcCC_NoError) {
            mpPak->UsbdStatus = USBD_STATUS_SUCCESS;
        } else {
            mpPak->UsbdStatus = psw->ConditionCode;
            mpPak->UsbdStatus |= 0xC0000000;
        }            
    }
    
    // mark the TD free
    OHCI_FREE_TD(DeviceData, endpointData, Td);
    
    if (transferContext->PendingTds == 0 && CompleteTransfer) {
        // all TDs for this transfer are done
        // clear the HAVE_TRANSFER flag to indicate 
        // we can take another
        endpointData->PendingTransfers--;

        transferContext->TransferParameters->FrameCompleted = 
            OHCI_Get32BitFrameNumber(DeviceData);
       

        LOGENTRY(DeviceData, G, '_cpi', 
            transferContext, 
            0,
            0);
            
        USBPORT_COMPLETE_ISO_TRANSFER(DeviceData,
                                      endpointData,
                                      transferContext->TransferParameters,
                                      transferContext->IsoTransfer);
    }
}


VOID
OHCI_PollIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'
    
    The goal here is to determine which TDs, if any, 
    have completed and complete any associated transfers

Arguments:

Return Value:

--*/

{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i;
    PTRANSFER_CONTEXT transfer;
    HW_32BIT_PHYSICAL_ADDRESS headP;
    
    ed = EndpointData->HcdEd;

    LOGENTRY(DeviceData, G, '_pli', ed, 0, 0);        

    // note it is important the the compiler generate a 
    // dword move when reading the queuehead HeadP register 
    // since this location is also accessed by the host
    // hardware
    headP = ed->HwED.HeadP;

    // get the 'currentTD' 
    currentTd = (PHCD_TRANSFER_DESCRIPTOR)
            USBPORT_PHYSICAL_TO_VIRTUAL(headP & ~HcEDHeadP_FLAGS,
                                        DeviceData,
                                        EndpointData);
                                            
    LOGENTRY(DeviceData, G, '_cTD', currentTd, 
        headP & ~HcEDHeadP_FLAGS, 
            TRANSFER_CONTEXT_PTR(currentTd->TransferContext));                 

    // iso endpoints shpuld not halt
    OHCI_ASSERT(DeviceData, (ed->HwED.HeadP & HcEDHeadP_HALT) == 0) 
    
    
    // Walk the swHeadP to the current TD (hw headp)               
    // mark all TDs we find as completed
    //
    // NOTE: this step may be skipped if the 
    // done queue is reliable

    td = EndpointData->HcdHeadP;

    while (td != currentTd) {
        LOGENTRY(DeviceData, G, '_mDN', td, 0, 0); 
        SET_FLAG(td->Flags, TD_FLAG_DONE);
        td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
    }            

    // set the sw headp to the new current head
    EndpointData->HcdHeadP = currentTd;
    
    // now flush all completed TDs
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if ((td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)) ==
            (TD_FLAG_XFER | TD_FLAG_DONE)) {
            OHCI_ProcessDoneIsoTd(DeviceData,
                                  td,
                                  TRUE);
        }                                  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\openhci.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    openhci.h

Abstract:

   Definitions from OPENHCI 1.0 USB specification

Environment:

    Kernel & user mode

Revision History:

    12-28-95 : created jfuller & kenray

--*/


#ifndef OPENHCI_H
#define OPENHCI_H

#include <PSHPACK4.H>
//
// Don't use <PSHPACK1.H> on shared memory data structures that should only
// be accessed using 4-byte load/store instructions (e.g use ld4 instructions
// instead of ld1 instructions on ia64 machines).
//

#define MAXIMUM_OVERHEAD   210

#define OHCI_PAGE_SIZE 0x1000
// #define OHCI_PAGE_SIZE 0x20
#define OHCI_PAGE_SIZE_MASK (OHCI_PAGE_SIZE - 1)


//
// 7.1.1 HcRevision Register
// Definition of Host Controller Revision register
//
typedef union _HC_REVISION {
   ULONG                   ul;
   struct {
      ULONG                Rev:8;
      ULONG                :24;
   };
} HC_REVISION, *PHC_REVISION;

C_ASSERT(sizeof(HC_REVISION) == 4);

//
// 7.1.2 HcControl Register
// Definition of Host Controller Control register
//
typedef union _HC_CONTROL {
   ULONG                   ul;
   struct {
      ULONG                ControlBulkServiceRatio:2;
      ULONG                PeriodicListEnable:1;
      ULONG                IsochronousEnable:1;
      ULONG                ControlListEnable:1;
      ULONG                BulkListEnable:1;
      ULONG                HostControllerFunctionalState:2;
      ULONG                InterruptRouting:1;
      ULONG                RemoteWakeupConnected:1;
      ULONG                RemoteWakeupEnable:1;
      ULONG                :21;
   };
} HC_CONTROL, *PHC_CONTROL;

C_ASSERT(sizeof(HC_CONTROL) == 4);

#define HcCtrl_CBSR_MASK                     0x00000003L
#define HcCtrl_CBSR_1_to_1                   0x00000000L
#define HcCtrl_CBSR_2_to_1                   0x00000001L
#define HcCtrl_CBSR_3_to_1                   0x00000002L
#define HcCtrl_CBSR_4_to_1                   0x00000003L
#define HcCtrl_PeriodicListEnable            0x00000004L
#define HcCtrl_IsochronousEnable             0x00000008L
#define HcCtrl_ControlListEnable             0x00000010L
#define HcCtrl_BulkListEnable                0x00000020L
#define HcCtrl_ListEnableMask                0x00000038L

#define HcCtrl_HCFS_MASK                     0x000000C0L
#define HcCtrl_HCFS_USBReset                 0x00000000L
#define HcCtrl_HCFS_USBResume                0x00000040L
#define HcCtrl_HCFS_USBOperational           0x00000080L
#define HcCtrl_HCFS_USBSuspend               0x000000C0L

#define HcCtrl_InterruptRouting              0x00000100L
#define HcCtrl_RemoteWakeupConnected         0x00000200L
#define HcCtrl_RemoteWakeupEnable            0x00000400L

#define HcHCFS_USBReset                      0x00000000
#define HcHCFS_USBResume                     0x00000001
#define HcHCFS_USBOperational                0x00000002
#define HcHCFS_USBSuspend                    0x00000003

//
// 7.1.3 HcCommandStatus Register
// Definition of Host Controller Command/Status register
//
typedef union _HC_COMMAND_STATUS {
   ULONG                   ul;               // use HcCmd flags below
   struct {
      ULONG                HostControllerReset:1;
      ULONG                ControlListFilled:1;
      ULONG                BulkListFilled:1;
      ULONG                OwnershipChangeRequest:1;
      ULONG                :12;
      ULONG                SchedulingOverrunCount:2;
      ULONG                :14;
   };
} HC_COMMAND_STATUS, *PHC_COMMAND_STATUS;

C_ASSERT(sizeof(HC_COMMAND_STATUS) == 4);

#define HcCmd_HostControllerReset            0x00000001
#define HcCmd_ControlListFilled              0x00000002
#define HcCmd_BulkListFilled                 0x00000004
#define HcCmd_OwnershipChangeRequest         0x00000008
#define HcCmd_SOC_Mask                       0x00030000
#define HcCmd_SOC_Offset                     16
#define HcCmd_SOC_Mask_LowBits               0x00000003

//
// 7.3.1 HcFmInterval Register
// Definition of Host Controller Frame Interval register
//
typedef union _HC_FM_INTERVAL {
   ULONG                   ul;              // use HcFmI flags below
   struct {
      ULONG                FrameInterval:14;
      ULONG                :2;
      ULONG                FSLargestDataPacket:15;
      ULONG                FrameIntervalToggle:1;
   };
} HC_FM_INTERVAL, *PHC_FM_INTERVAL;

C_ASSERT(sizeof(HC_FM_INTERVAL) == 4);

#define HcFmI_FRAME_INTERVAL_MASK            0x00003FFF
#define HcFmI_FS_LARGEST_DATA_PACKET_MASK    0x7FFF0000
#define HcFmI_FS_LARGEST_DATA_PACKET_SHIFT   16
#define HcFmI_FRAME_INTERVAL_TOGGLE          0x80000000

//
// 7.3.2 HcFmRemaining Register
// Definition of Host Controller Frame Remaining register
//
typedef union _HC_FM_REMAINING {
   ULONG                   ul;
   struct {
      ULONG                FrameRemaining:14;
      ULONG                :17;
      ULONG                FrameRemainingToggle:1;
   };
} HC_FM_REMAINING, *PHC_FM_REMAINING;

C_ASSERT(sizeof(HC_FM_REMAINING) == 4);

//
// 7.3.3 HcFmNumber Register
// Definition of Host Controller Frame Number register
//
typedef union _HC_FM_NUMBER {
   ULONG                   ul;
   struct {
      ULONG                FrameNumber:16;
      ULONG                :16;
   };
} HC_FM_NUMBER, *PHC_FM_NUMBER;

C_ASSERT(sizeof(HC_FM_NUMBER) == 4);

#define HcFmNumber_MASK                     0x0000FFFF
#define HcFmNumber_RESERVED                 0xFFFF0000

//
// 7.4.1 HcRhDescriptorA Register
// Definition of Host Controller Root Hub DescriptorA register
//
typedef union _HC_RH_DESCRIPTOR_A {
   ULONG                   ul;
   struct {
        ULONG               NumberDownstreamPorts:8;
        ULONG               HubChars:16;                    
        ULONG               PowerOnToPowerGoodTime:8;
   } s;
} HC_RH_DESCRIPTOR_A, *PHC_RH_DESCRIPTOR_A;

C_ASSERT(sizeof(HC_RH_DESCRIPTOR_A) == 4);

#define HcDescA_PowerSwitchingModePort          0x00000100L
#define HcDescA_NoPowerSwitching                0x00000200L
#define HcDescA_DeviceType                      0x00000400L
#define HcDescA_OvercurrentProtectionMode       0x00000800L
#define HcDescA_NoOvercurrentProtection         0x00001000L

// HcRhDescriptorA reserved bits which should not be set.  Note that although
// the NumberDownstreamPorts field is 8 bits wide, the maximum number of ports
// supported by the OpenHCI specification is 15.
//
#define HcDescA_RESERVED                        0x00FFE0F0L


//
// 7.4.2 HcRhDescriptorB Register
// Definition of Host Controller Root Hub DescritorB register
//
typedef union _HC_RH_DESCRIPTOR_B {
   ULONG                   ul;
   struct {
      USHORT               DeviceRemovableMask;
      USHORT               PortPowerControlMask;
   };
} HC_RH_DESCRIPTOR_B, *PHC_RH_DESCRIPTOR_B;

C_ASSERT(sizeof(HC_RH_DESCRIPTOR_B) == 4);

//
// Host Controler Hardware Registers as accessed in memory
//
typedef struct _HC_OPERATIONAL_REGISTER {
   // 0 0x00 - 0,4,8,c
   HC_REVISION             HcRevision;
   HC_CONTROL              HcControl;
   HC_COMMAND_STATUS       HcCommandStatus;
   ULONG                   HcInterruptStatus;   // use HcInt flags below
   // 1 0x10
   ULONG                   HcInterruptEnable;   // use HcInt flags below
   ULONG                   HcInterruptDisable;  // use HcInt flags below
   ULONG                   HcHCCA;              // physical pointer to Host Controller Communications Area
   ULONG                   HcPeriodCurrentED;   // physical ptr to current periodic ED
   // 2 0x20
   ULONG                   HcControlHeadED;     // physical ptr to head of control list
   ULONG                   HcControlCurrentED;  // physical ptr to current control ED
   ULONG                   HcBulkHeadED;        // physical ptr to head of bulk list
   ULONG                   HcBulkCurrentED;     // physical ptr to current bulk ED
   // 3 0x30
   ULONG                   HcDoneHead;          // physical ptr to internal done queue
   HC_FM_INTERVAL          HcFmInterval;
   HC_FM_REMAINING         HcFmRemaining;
   ULONG                   HcFmNumber;
   // 4 0x40
   ULONG                   HcPeriodicStart;
   ULONG                   HcLSThreshold;
   HC_RH_DESCRIPTOR_A      HcRhDescriptorA;
   HC_RH_DESCRIPTOR_B      HcRhDescriptorB;
   // 5 0x50
   ULONG                   HcRhStatus;          // use HcRhS flags below
   ULONG                   HcRhPortStatus[15];  // use HcRhPS flags below
} HC_OPERATIONAL_REGISTER, *PHC_OPERATIONAL_REGISTER;

C_ASSERT(sizeof(HC_OPERATIONAL_REGISTER) == (0x54 + 4 * 15));

//
// 7.1.4 HcInterrruptStatus Register
// 7.1.5 HcInterruptEnable  Register
// 7.1.6 HcInterruptDisable Register
//
#define HcInt_SchedulingOverrun              0x00000001L
#define HcInt_WritebackDoneHead              0x00000002L
#define HcInt_StartOfFrame                   0x00000004L
#define HcInt_ResumeDetected                 0x00000008L
#define HcInt_UnrecoverableError             0x00000010L
#define HcInt_FrameNumberOverflow            0x00000020L
#define HcInt_RootHubStatusChange            0x00000040L
#define HcInt_OwnershipChange                0x40000000L
#define HcInt_MasterInterruptEnable          0x80000000L

//
// 7.4.3 HcRhStatus Register
//
#define HcRhS_LocalPowerStatus                  0x00000001  // read only
#define HcRhS_OverCurrentIndicator              0x00000002  // read only
#define HcRhS_DeviceRemoteWakeupEnable          0x00008000  // read only
#define HcRhS_LocalPowerStatusChange            0x00010000  // read only
#define HcRhS_OverCurrentIndicatorChange        0x00020000  // read only

#define HcRhS_ClearGlobalPower                  0x00000001  // write only
#define HcRhS_SetRemoteWakeupEnable             0x00008000  // write only
#define HcRhS_SetGlobalPower                    0x00010000  // write only
#define HcRhS_ClearOverCurrentIndicatorChange   0x00020000  // write only
#define HcRhS_ClearRemoteWakeupEnable           0x80000000  // write only

//
// 7.4.4 HcRhPortStatus Register
//

//
// The bits in this register have a double meaning depending 
// on if you read or write them
//

#define HcRhPS_CurrentConnectStatus          0x00000001  // read only
#define HcRhPS_PortEnableStatus              0x00000002  // read only
#define HcRhPS_PortSuspendStatus             0x00000004  // read only
#define HcRhPS_PortOverCurrentIndicator      0x00000008  // read only
#define HcRhPS_PortResetStatus               0x00000010  // read only
#define HcRhPS_PortPowerStatus               0x00000100  // read only
#define HcRhPS_LowSpeedDeviceAttached        0x00000200  // read only
#define HcRhPS_ConnectStatusChange           0x00010000  // read only
#define HcRhPS_PortEnableStatusChange        0x00020000  // read only
#define HcRhPS_PortSuspendStatusChange       0x00040000  // read only
#define HcRhPS_OverCurrentIndicatorChange    0x00080000  // read only
#define HcRhPS_PortResetStatusChange         0x00100000  // read only

#define HcRhPS_ClearPortEnable               0x00000001  // write only
#define HcRhPS_SetPortEnable                 0x00000002  // write only
#define HcRhPS_SetPortSuspend                0x00000004  // write only
#define HcRhPS_ClearPortSuspend              0x00000008  // write only
#define HcRhPS_SetPortReset                  0x00000010  // write only
#define HcRhPS_SetPortPower                  0x00000100  // write only
#define HcRhPS_ClearPortPower                0x00000200  // write only
#define HcRhPS_ClearConnectStatusChange      0x00010000  // write only
#define HcRhPS_ClearPortEnableStatusChange   0x00020000  // write only
#define HcRhPS_ClearPortSuspendStatusChange  0x00040000  // write only
#define HcRhPS_ClearPortOverCurrentChange    0x00080000  // write only
#define HcRhPS_ClearPortResetStatusChange    0x00100000  // write only

#define HcRhPS_RESERVED     (~(HcRhPS_CurrentConnectStatus       | \
                               HcRhPS_PortEnableStatus           | \
                               HcRhPS_PortSuspendStatus          | \
                               HcRhPS_PortOverCurrentIndicator   | \
                               HcRhPS_PortResetStatus            | \
                               HcRhPS_PortPowerStatus            | \
                               HcRhPS_LowSpeedDeviceAttached     | \
                               HcRhPS_ConnectStatusChange        | \
                               HcRhPS_PortEnableStatusChange     | \
                               HcRhPS_PortSuspendStatusChange    | \
                               HcRhPS_OverCurrentIndicatorChange | \
                               HcRhPS_PortResetStatusChange        \
                            ))


typedef struct _HCCA_BLOCK {
   ULONG                     HccaInterruptTable[32]; // physical pointer to interrupt lists
   USHORT                    HccaFrameNumber;        // 16-bit current frame number
   USHORT                    HccaPad1;               // When the HC updates
                                                     // HccaFrameNumber, it sets
                                                     // this word to zero.
   ULONG                     HccaDoneHead;           // pointer to done queue
   ULONG                     Reserved[30];           // pad to 256 bytes
} HCCA_BLOCK, *PHCCA_BLOCK;

// this size is defined in the
// OpenHCI Specification it should always be 256 bytes
C_ASSERT (sizeof(HCCA_BLOCK) == 256);

//
// Host Controller Endpoint Descriptor Control DWORD
//
typedef union _HC_ENDPOINT_CONTROL {
   ULONG                      Control;       // use HcEDControl flags below
   struct {
      ULONG                   FunctionAddress:7;
      ULONG                   EndpointNumber:4;
      ULONG                   Direction:2;   // use HcEDDirection flags below
      ULONG                   LowSpeed:1;
      ULONG                   sKip:1;
      ULONG                   Isochronous:1;
      ULONG                   MaxPacket:11;
      ULONG                   Unused:5;      //available for software use
   };
} HC_ENDPOINT_CONTROL, *PHC_ENDPOINT_CONTROL;

//
// Definitions for HC_ENDPOINT_CONTROL.Control
//
#define HcEDControl_MPS_MASK  0x07FF0000  // Maximum Packet Size field
#define HcEDControl_MPS_SHIFT 16          // Shift Count for MPS
#define HcEDControl_ISOCH     0x00008000  // Bit set for isochronous endpoints
#define HcEDControl_SKIP      0x00004000  // Bit tells hw to skip this endpoint
#define HcEDControl_LOWSPEED  0x00002000  // Bit set if device is a low speed device
#define HcEDControl_DIR_MASK  0x00001800  // Transfer direction field
#define HcEDControl_DIR_DEFER 0x00000000  // Defer direction select to TD (Control Endpoints)
#define HcEDControl_DIR_OUT   0x00000800  // Direction is from host to device
#define HcEDControl_DIR_IN    0x00001000  // Direction is from device to host
#define HcEDControl_EN_MASK   0x00000780  // Endpoint Number field
#define HcEDControl_EN_SHIFT  7           // Shift Count for EN
#define HcEDControl_FA_MASK   0x0000007F  // Function Address field
#define HcEDControl_FA_SHIFT  0           // Shift Count for FA

//
// Definitions for HC_ENDPOINT_CONTROL.Direction
//
#define HcEDDirection_Defer   0           // Defer direction to TD (Control Endpoints)
#define HcEDDirection_Out     1           // Direction from host to device
#define HcEDDirection_In      2           // Direction from device to host

//
// Host Controller Endpoint Descriptor, refer to Section 4.2, Endpoint Descriptor
//

typedef struct _HW_ENDPOINT_DESCRIPTOR {
   HC_ENDPOINT_CONTROL;                    // dword 0
   HW_32BIT_PHYSICAL_ADDRESS      TailP;   //physical pointer to HC_TRANSFER_DESCRIPTOR
   HW_32BIT_PHYSICAL_ADDRESS      HeadP;   //flags + phys ptr to HC_TRANSFER_DESCRIPTOR
   HW_32BIT_PHYSICAL_ADDRESS      NextED;  //phys ptr to HC_ENDPOINT_DESCRIPTOR
} HW_ENDPOINT_DESCRIPTOR, *PHW_ENDPOINT_DESCRIPTOR;

// NOTE: this structure MUST have 16 byte alignment for the hardware
C_ASSERT(sizeof(HW_ENDPOINT_DESCRIPTOR) == 16);

//
// Definitions for HC_ENDPOINT_DESCRIPTOR.HeadP
//
#define HcEDHeadP_FLAGS 0x0000000F  //mask for flags in HeadP
#define HcEDHeadP_HALT  0x00000001  //hardware stopped bit
#define HcEDHeadP_CARRY 0x00000002  //hardware toggle carry bit

//
// HCD Isochronous offset/status words
//
typedef union _HC_OFFSET_PSW {
   struct {
      USHORT      Offset:13;                       // Offset within two pages of packet buffer
      USHORT      Ones:3;                          // should be 111b when in Offset format
   };
   struct {
      USHORT      Size:11;                         // Size of packet received
      USHORT      :1;                              // reserved
      USHORT      ConditionCode:4;                 // use HcCC flags below
   };
   USHORT         PSW;                             // use HcPSW flags below
} HC_OFFSET_PSW, *PHC_OFFSET_PSW;

//
// Definitions for HC_OFFSET_PSW.PSW
//
#define HcPSW_OFFSET_MASK           0x0FFF         // Packet buffer offset field
#define HcPSW_SECOND_PAGE           0x1000         // Is this packet on 2nd page
#define HcPSW_ONES                  0xE000         // The ones for Offset form
#define HcPSW_CONDITION_CODE_MASK   0xF000         // Packet ConditionCode field
#define HcPSW_CONDITION_CODE_SHIFT  12             // shift count for Code
#define HcPSW_RETURN_SIZE           0x07FF         // The size field.

//
// HCD Transfer Descriptor Control DWord
//
typedef union _HC_TRANSFER_CONTROL {
   ULONG                            Control;          // use HcTDControl flags below
   struct _HC_GENERAL_TD_CONTROL{
      ULONG                         :16;              // available for s/w use in GTD
      ULONG                         Isochronous:1;      // should be 0 for GTD, s/w flag
      ULONG                         :1;               // available for s/w use
      ULONG                         ShortXferOk:1;    // if set don't report error on short transfer
      ULONG                         Direction:2;      // use HcTDDirection flags below
      ULONG                         IntDelay:3;       // use HcTDIntDelay flags below
      ULONG                         Toggle:2;         // use HcTDToggle flags below
      ULONG                         ErrorCount:2;
      ULONG                         ConditionCode:4;  // use HcCC flags below
   } Asy;
   struct _HC_ISOCHRONOUS_TD_CONTROL{
      ULONG                         StartingFrame:16;
      ULONG                         Isochronous:1;// should be 1 for ITD, s/w flag
      ULONG                         :1;               // available for s/w use
      ULONG                         :3;               // available for s/w use in ITD
      ULONG                         IntDelay:3;       // IntDelay
      ULONG                         FrameCount:3;     // one less than number of frames described in ITD
      ULONG                         :1;               // available for s/w use in ITD
      ULONG                         :4;               // ConditionCode
   } Iso;
} HC_TRANSFER_CONTROL, *PHC_TRANSFER_CONTROL;

//
// Definitions for HC_TRANSFER_CONTROL.Control
//
#define HcTDControl_STARTING_FRAME        0x0000FFFF  // mask for starting frame (Isochronous)
#define HcTDControl_ISOCHRONOUS           0x00010000  // 1 for Isoch TD, 0 for General TD
#define HcTDControl_SHORT_XFER_OK         0x00040000  // 0 if short transfers are errors
#define HcTDControl_DIR_MASK              0x00180000  // Transfer direction field
#define HcTDControl_DIR_SETUP             0x00000000  // direction is setup packet from host to device
#define HcTDControl_DIR_OUT               0x00080000  // direction is from host to device
#define HcTDControl_DIR_IN                0x00100000  // direction is from device to host
#define HcTDControl_INT_DELAY_MASK        0x00E00000  // Interrupt Delay field
#define HcTDControl_INT_DELAY_0_MS        0x00000000  // Interrupt at end of frame TD is completed
#define HcTDControl_INT_DELAY_1_MS        0x00200000  // Interrupt no later than end of 1st frame after TD is completed
#define HcTDControl_INT_DELAY_2_MS        0x00400000  // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDControl_INT_DELAY_3_MS        0x00600000  // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDControl_INT_DELAY_4_MS        0x00800000  // Interrupt no later than end of 4th frame after TD is completed
#define HcTDControl_INT_DELAY_5_MS        0x00A00000  // Interrupt no later than end of 5th frame after TD is completed
#define HcTDControl_INT_DELAY_6_MS        0x00C00000  // Interrupt no later than end of 6th frame after TD is completed

#ifdef NSC
#define HcTDControl_INT_DELAY_NO_INT      0x00C00000  // Almost infinity but not yet quite.
#elif DISABLE_INT_DELAY_NO_INT
#define HcTDControl_INT_DELAY_NO_INT      0x00000000  // Interrupt at the completion of all packets.
#else
#define HcTDControl_INT_DELAY_NO_INT      0x00E00000  // Do not cause an interrupt for normal completion of this TD
#endif

#define HcTDControl_FRAME_COUNT_MASK      0x07000000  // mask for FrameCount field (Isochronous)
#define HcTDControl_FRAME_COUNT_SHIFT     24          // shift count for FrameCount (Isochronous)
#define HcTDControl_FRAME_COUNT_MAX       8           // Max number of for frame count per TD
#define HcTDControl_TOGGLE_MASK           0x03000000  // mask for Toggle control field
#define HcTDControl_TOGGLE_FROM_ED        0x00000000  // get data toggle from CARRY field of ED
#define HcTDControl_TOGGLE_DATA0          0x02000000  // use DATA0 for data PID
#define HcTDControl_TOGGLE_DATA1          0x03000000  // use DATA1 for data PID
#define HcTDControl_ERROR_COUNT           0x0C000000  // mask for Error Count field
#define HcTDControl_CONDITION_CODE_MASK   0xF0000000  // mask for ConditionCode field
#define HcTDControl_CONDITION_CODE_SHIFT  28          // shift count for ConditionCode

//
// Definitions for HC_TRANSFER_CONTROL.Direction
//
#define HcTDDirection_Setup               0           // setup packet from host to device
#define HcTDDirection_Out                 1           // direction from host to device
#define HcTDDirection_In                  2           // direction from device to host

//
// Definitions for Hc_TRANSFER_CONTROL.IntDelay
//
#define HcTDIntDelay_0ms                  0           // interrupt at end of frame TD is completed
#define HcTDIntDelay_1ms                  1           // Interrupt no later than end of 1st frame after TD is completed
#define HcTDIntDelay_2ms                  2           // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDIntDelay_3ms                  3           // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDIntDelay_4ms                  4           // Interrupt no later than end of 4th frame after TD is completed
#define HcTDIntDelay_5ms                  5           // Interrupt no later than end of 5th frame after TD is completed
#define HcTDIntDelay_6ms                  6           // Interrupt no later than end of 6th frame after TD is completed
#define HcTDIntDelay_NoInterrupt          7           // do not generate interrupt for normal completion of this TD

//
// Definitions for HC_TRANSFER_CONTROL.Toggle
//
#define HcTDToggle_FromEd                 0           // get toggle for Endpoint Descriptor toggle CARRY bit
#define HcTDToggle_Data0                  2           // use Data0 PID
#define HcTDToggle_Data1                  3           // use Data1 PID

//
// Definitions for HC_TRANSFER_CONTROL.ConditionCode and HC_OFFSET_PSW.ConditionCode
//
#define HcCC_NoError                      0x0UL
#define HcCC_CRC                          0x1UL
#define HcCC_BitStuffing                  0x2UL
#define HcCC_DataToggleMismatch           0x3UL
#define HcCC_Stall                        0x4UL
#define HcCC_DeviceNotResponding          0x5UL
#define HcCC_PIDCheckFailure              0x6UL
#define HcCC_UnexpectedPID                0x7UL
#define HcCC_DataOverrun                  0x8UL
#define HcCC_DataUnderrun                 0x9UL
      //                                  0xA         // reserved
      //                                  0xB         // reserved
#define HcCC_BufferOverrun                0xCUL
#define HcCC_BufferUnderrun               0xDUL
#define HcCC_NotAccessed                  0xEUL
      //                                  0xF         // this also means NotAccessed

//
// Host Controller Transfer Descriptor, refer to Section 4.3, Transfer Descriptors
//
typedef struct _HW_TRANSFER_DESCRIPTOR {
   HC_TRANSFER_CONTROL;                            // dword 0
   ULONG                            CBP;           // phys ptr to start of buffer
   ULONG                            NextTD;        // phys ptr to HC_TRANSFER_DESCRIPTOR
   ULONG                            BE;            // phys ptr to end of buffer (last byte)
   HC_OFFSET_PSW                    Packet[8];     // isoch & Control packets
} HW_TRANSFER_DESCRIPTOR, *PHW_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HW_TRANSFER_DESCRIPTOR) == 32));

#include <POPPACK.H>

#endif /* OPENHCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\dbg.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros

Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

// write to one of the reserved operational registers
// we use this to trigger the PCI analyzer
#define PCI_TRIGGER(hcOp)  WRITE_REGISTER_ULONG(&(hcOp)->PciTrigger, 0xABADBABE);

// always log
#define DEBUG_LOG


#if DBG

// Triggers a break in the debugger in the registry key
// debugbreakOn is set.  These breakpoins are useful for
// debugging hardware/client software problems
//

#define DEBUG_BREAK(dd)  RegistrationPacket.USBPORTSVC_TestDebugBreak(dd);

//
// This Breakpoint means we either need to test the code path
// somehow or the code is not implemented.  ie either case we
// should not have any of these when the driver is finished
//

#define TEST_TRAP()      {\
                            DbgPrint("<UHCI TEST_TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                         }


#define TRAP_FATAL_ERROR()      {\
                            DbgPrint("<UHCI FATAL_ERROR> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                         }


#define ASSERT_TRANSFER(dd, t) UHCI_ASSERT((dd), (t)->Sig == SIG_UHCI_TRANSFER)

#define ASSERT_TD(dd, t) UHCI_ASSERT((dd), (t)->Sig == SIG_HCD_TD)

ULONG
_cdecl
UhciKdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    );

#define   UhciKdPrint(_x_) UhciKdPrintX _x_

#define UHCI_ASSERT(dd, exp ) \
    if (!(exp)) {\
        RegistrationPacket.USBPORTSVC_AssertFailure( (dd), #exp, __FILE__, __LINE__, NULL );\
    }


#else

// debug macros for retail build

#define TEST_TRAP()
#define DEBUG_BREAK(dd)
#define TRAP_FATAL_ERROR()

#define ASSERT_TRANSFER(dd, t)

#define ASSERT_TD(dd, t)

#define UHCI_ASSERT(dd, exp )

#define   UhciKdPrint(_x_)

#endif /* DBG */

// retail and debug

#ifdef DEBUG_LOG

#define LOGENTRY(dd, mask, sig, info1, info2, info3)  \
    RegistrationPacket.USBPORTSVC_LogEntry( (dd), (mask), (sig), \
        (ULONG_PTR)(info1), (ULONG_PTR)(info2), (ULONG_PTR)(info3) )

#else

#define LOGENTRY(dd, mask, sig, info1, info2, info3)

#endif


#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\usbohci.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbohci.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    5-10-96 : created

--*/

#ifndef   __OHCI_H__
#define   __OHCI_H__


#define OHCI_COMMON_BUFFER_SIZE (sizeof(HCCA_BLOCK)+\
            NO_ED_LISTS*sizeof(HW_ENDPOINT_DESCRIPTOR) +\
            (17*2)*sizeof(HCD_ENDPOINT_DESCRIPTOR))

/*
    Registry Keys 
*/

// Software Branch PDO Keys 
#define SOF_MODIFY_KEY L"recommendedClocksPerFrame"

// Hardware Branch PDO Keys

/* 
    define resource consumption for endpoints types
*/
#define T_256K          0x40000
#define T_128K          0x20000
#define T_64K           0x10000
#define T_4K            0x1000


// Control:
// largest possible transfer for control is 64k 
// therefore we support up to 2 transfers of this 
// size in HW.  Most control transfers are much 
// smaller than this.
// NOTE: we MUST support at least one 64k transfer in 
// HW since a single control transfer cannot be 
// broken up.
                                            
#define MAX_CONTROL_TRANSFER_SIZE      T_64K 
// worst case 64k control transfer 17 + status and 
// setup TD = 19 (*2 transfers)
#define TDS_PER_CONTROL_ENDPOINT          38


// Bulk:
// The most data we can move in a ms is 1200 bytes. 
// we support two 64k transfers queued to HW at a 
// a time -- we should be able to keep the bus busy 
// with this.
// NOTE: in a memory constrained system we can shrink
// this value, our max transfer size should always be
// at half the # of TDs available
                                                   
#define MAX_BULK_TRANSFER_SIZE         T_256K
// enough for 4 64 xfers, 2 128k or 1 256k
#define TDS_PER_BULK_ENDPOINT             68

// Iso:                                     
#define MAX_ISO_TRANSFER_SIZE          T_64K
#define TDS_PER_ISO_ENDPOINT              64
                                    
// Interrupt:
#define MAX_INTERRUPT_TRANSFER_SIZE     T_4K
#define TDS_PER_INTERRUPT_ENDPOINT         4


#undef PDEVICE_DATA

// Values for DeviceData.Flags
#define HMP_FLAG_SOF_MODIFY_VALUE   0x00000001

//** flags for ED HC_STATIC_ED_DATA & HCD_ENDPOINT_DESCRIPTOR

//* these define the type of ED
#define EDFLAG_CONTROL          0x00000001
#define EDFLAG_BULK             0x00000002
#define EDFLAG_INTERRUPT        0x00000004

//*
// these define ed charateristics and state
#define EDFLAG_NOHALT           0x00000008

#define EDFLAG_REMOVED          0x00000010
#define EDFLAG_REGISTER         0x00000020


typedef struct _HC_STATIC_ED_DATA {
    // virtual address of static ED
    PHW_ENDPOINT_DESCRIPTOR HwED;
    // physical address of next ED
    HW_32BIT_PHYSICAL_ADDRESS  HwEDPhys; 
    // index in the static ED list for the 
    // next ED in the interrupt tree
    CHAR            NextIdx;

    // list of 'real EDs' associated
    // with this static ED
    LIST_ENTRY      TransferEdList;

    // Use EDFLAG_
    ULONG           EdFlags;
    // this is either an HC register or the address of the entry
    // in the HCCA area corresponding to the 'physical address'
    // of the first ed in the list
    //
    // in the case of control and bulk the physical head will be 0
    // or point to timing delay 'dummy EDs'
    //
    // in the case of interrupt the physical head will be a static 
    // ED in the onterrupt 'tree'
    PULONG          PhysicalHead;
    
    ULONG           AllocatedBandwidth;

    ULONG           HccaOffset;
    
} HC_STATIC_ED_DATA, *PHC_STATIC_ED_DATA;


//
// These values index in to the static ED list
//
#define  ED_INTERRUPT_1ms        0
#define  ED_INTERRUPT_2ms        1
#define  ED_INTERRUPT_4ms        3
#define  ED_INTERRUPT_8ms        7
#define  ED_INTERRUPT_16ms       15
#define  ED_INTERRUPT_32ms       31
#define  ED_CONTROL              63
#define  ED_BULK                 64
#define  ED_ISOCHRONOUS          0     // same as 1ms interrupt queue
#define  NO_ED_LISTS             65
#define  ED_EOF                  0xff

//
#define  SIG_HCD_DUMMY_ED       'deYD'
#define  SIG_HCD_ED             'deYH'
#define  SIG_HCD_TD             'dtYH'
#define  SIG_EP_DATA            'peYH'
#define  SIG_OHCI_TRANSFER      'rtYH'
#define  SIG_OHCI_DD            'icho'


typedef struct _DEVICE_DATA {

    ULONG                       Sig;
    ULONG                       Flags;
    PHC_OPERATIONAL_REGISTER    HC; 
    HC_FM_INTERVAL              BIOS_Interval;
    ULONG                       SofModifyValue;
    ULONG                       FrameHighPart;
    PHCCA_BLOCK                 HcHCCA; 
    HW_32BIT_PHYSICAL_ADDRESS   HcHCCAPhys;     
    PUCHAR                      StaticEDs; 
    HW_32BIT_PHYSICAL_ADDRESS   StaticEDsPhys; 

    USB_CONTROLLER_FLAVOR       ControllerFlavor;

    ULONG                       LastDeadmanFrame;

    struct _HCD_ENDPOINT_DESCRIPTOR    *HydraLsHsHackEd;

    HC_STATIC_ED_DATA           StaticEDList[NO_ED_LISTS];

} DEVICE_DATA, *PDEVICE_DATA;

#define TC_FLAGS_SHORT_XFER_OK           0x00000001
#define TC_FLAGS_SHORT_XFER_DONE         0x00000002

typedef struct _TRANSFER_CONTEXT {

    ULONG Sig;
    ULONG BytesTransferred;
    PTRANSFER_PARAMETERS TransferParameters;
    ULONG PendingTds;
    ULONG TcFlags;
    USBD_STATUS UsbdStatus;
    // first TD of the next transfer in the chain
    struct _HCD_TRANSFER_DESCRIPTOR *NextXferTd;
    struct _HCD_TRANSFER_DESCRIPTOR *StatusTd;
    struct _ENDPOINT_DATA *EndpointData;

    PMINIPORT_ISO_TRANSFER IsoTransfer;

} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;


// HCD Endpoint Descriptor (contains the HW descriptor)
//

#define ENDPOINT_DATA_PTR(p) ((struct _ENDPOINT_DATA *) (p).Pointer)

typedef struct _HCD_ENDPOINT_DESCRIPTOR {
   HW_ENDPOINT_DESCRIPTOR     HwED;
   // make Physical Address the same as in HCD_TRANSFER_DESCRIPTOR
   ULONG                      Pad4[4];
   
   HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
   ULONG                      Sig;
   ULONG                      EdFlags;  //use EDFLAG_
   ULONG                      Win64Pad;
   
   MP_HW_POINTER              EndpointData;
   MP_HW_LIST_ENTRY           SwLink;
   
   ULONG                      PadTo128[14];
} HCD_ENDPOINT_DESCRIPTOR, *PHCD_ENDPOINT_DESCRIPTOR;

C_ASSERT((sizeof(HCD_ENDPOINT_DESCRIPTOR) == 128));

//
// HCD Transfer Descriptor (contains the HW descriptor)
//

#define TD_FLAG_BUSY                0x00000001
#define TD_FLAG_XFER                0x00000002
#define TD_FLAG_CONTROL_STATUS      0x00000004
#define TD_FLAG_DONE                0x00000008
#define TD_FLAG_SKIP                0x00000010

#define TRANSFER_CONTEXT_PTR(p) ((struct _TRANSFER_CONTEXT *) (p).Pointer)
#define TRANSFER_DESCRIPTOR_PTR(p) ((struct _HCD_TRANSFER_DESCRIPTOR *) (p).Pointer)
#define HW_TRANSFER_DESCRIPTOR_PTR(p) ((struct _HW_TRANSFER_DESCRIPTOR *) (p).Pointer)
#define HW_DATA_PTR(p) ((PVOID) (p).Pointer)


typedef struct _HCD_TRANSFER_DESCRIPTOR {
   HW_TRANSFER_DESCRIPTOR     HwTD;
   
   HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
   ULONG                      Sig;
   ULONG                      Flags;
   ULONG                      TransferCount;
   
   MP_HW_POINTER              EndpointData;
   MP_HW_POINTER              TransferContext;
   MP_HW_POINTER              NextHcdTD;

   ULONG                      FrameIndex;    

   LIST_ENTRY                 DoneLink;  
#ifdef _WIN64
   ULONG                      PadTo128[8];
#else 
   ULONG                      PadTo128[11];
#endif   
} HCD_TRANSFER_DESCRIPTOR, *PHCD_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) == 128));

typedef struct _SS_PACKET_CONTEXT {
    ULONG PhysHold;
    MP_HW_POINTER Td;
    MP_HW_POINTER Data;
    ULONG PadTo8Dwords[3];
} SS_PACKET_CONTEXT, *PSS_PACKET_CONTEXT;

typedef struct _HCD_TD_LIST {
    HCD_TRANSFER_DESCRIPTOR Td[1];
} HCD_TD_LIST, *PHCD_TD_LIST;

//#define EPF_HAVE_TRANSFER   0x00000001
//#define EPF_REQUEST_PAUSE   0x00000002

typedef struct _ENDPOINT_DATA {

    ULONG Sig;
    ENDPOINT_PARAMETERS Parameters;
    ULONG Flags;
//    USHORT MaxPendingTransfers;
    USHORT PendingTransfers;
    PHC_STATIC_ED_DATA StaticEd;
    PHCD_TD_LIST TdList;
    PHCD_ENDPOINT_DESCRIPTOR HcdEd;
    ULONG TdCount;
    ULONG PendingTds;
    PHCD_TRANSFER_DESCRIPTOR HcdTailP;
    PHCD_TRANSFER_DESCRIPTOR HcdHeadP;

    LIST_ENTRY DoneTdList;
    
} ENDPOINT_DATA, *PENDPOINT_DATA;


/*
    Callouts to port driver services    
*/
extern USBPORT_REGISTRATION_PACKET RegistrationPacket;

#define USBPORT_DBGPRINT(dd, l, f, arg0, arg1, arg2, arg3, arg4, arg5) \
        RegistrationPacket.USBPORTSVC_DbgPrint((dd), (l), (f), (arg0), (arg1), \
            (arg2), (arg3), (arg4), (arg5))

#define USBPORT_GET_REGISTRY_KEY_VALUE(dd, branch, keystring, keylen, data, datalen) \
        RegistrationPacket.USBPORTSVC_GetMiniportRegistryKeyValue((dd), (branch), \
            (keystring), (keylen), (data), (datalen))
            
#define USBPORT_INVALIDATE_ROOTHUB(dd) \
        RegistrationPacket.USBPORTSVC_InvalidateRootHub((dd));

#define USBPORT_COMPLETE_TRANSFER(dd, ep, t, status, length) \
        RegistrationPacket.USBPORTSVC_CompleteTransfer((dd), (ep), (t), \
            (status), (length));        

#define USBPORT_COMPLETE_ISO_TRANSFER(dd, ep, t, iso) \
        RegistrationPacket.USBPORTSVC_CompleteIsoTransfer((dd), (ep), (t), \
            (iso));               

#define USBPORT_INVALIDATE_ENDPOINT(dd, ep) \
        RegistrationPacket.USBPORTSVC_InvalidateEndpoint((dd), (ep));        

#define USBPORT_INVALIDATE_CONTROLLER(dd, s) \
        RegistrationPacket.USBPORTSVC_InvalidateController((dd), (s))

#define USBPORT_PHYSICAL_TO_VIRTUAL(addr, dd, ep) \
        RegistrationPacket.USBPORTSVC_MapHwPhysicalToVirtual((addr), (dd), (ep));        

#define USBPORT_RW_CONFIG_SPACE(dd, read, buffer, offset, length) \
        RegistrationPacket.USBPORTSVC_ReadWriteConfigSpace((dd), (read), \
            (buffer), (offset), (length))

#define USBPORT_BUGCHECK(dd) \
        RegistrationPacket.USBPORTSVC_BugCheck(dd)
            

#define INITIALIZE_TD_FOR_TRANSFER(td, tc) \
        { ULONG i;\
        TRANSFER_CONTEXT_PTR((td)->TransferContext) = (tc);\
        SET_FLAG((td)->Flags, TD_FLAG_XFER); \
        (td)->HwTD.CBP = 0xbaadf00d;\
        (td)->HwTD.BE = 0xf00dbaad;\
        (td)->HwTD.NextTD = 0;\
        (td)->HwTD.Asy.IntDelay = HcTDIntDelay_NoInterrupt;\
        TRANSFER_DESCRIPTOR_PTR((td)->NextHcdTD) = NULL;\
        for (i=0; i<8; i++) {\
        (td)->HwTD.Packet[i].PSW = 0;\
        }\
        }

#define SET_NEXT_TD(linkTd, nextTd) \
    (linkTd)->HwTD.NextTD = (nextTd)->PhysicalAddress;\
    TRANSFER_DESCRIPTOR_PTR((linkTd)->NextHcdTD) = (nextTd);

#define SET_NEXT_TD_NULL(linkTd) \
    TRANSFER_DESCRIPTOR_PTR((linkTd)->NextHcdTD) = NULL;\
    (linkTd)->HwTD.NextTD = 0;    

#ifdef _WIN64
#define FREE_TD_CONTEXT ((PVOID) 0xDEADFACEDEADFACE)
#else
#define FREE_TD_CONTEXT ((PVOID) 0xDEADFACE)
#endif

#define OHCI_FREE_TD(dd, ep, td) \
    (td)->Flags = 0;\
    (td)->HwTD.NextTD = 0;\
    TRANSFER_CONTEXT_PTR((td)->TransferContext) = FREE_TD_CONTEXT;

#define OHCI_ALLOC_TD OHCI_AllocTd

// assuming only one bit is set this macro returns that bit
// 
#define GET_BIT_SET(d, bit) \
    {   \
        UCHAR tmp = (d);\
        (bit)=0; \
        while (!(tmp & 0x01)) {\
            (bit)++;\
            tmp >>= 1;\
        };\
    }

VOID
OHCI_EnableList(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );

PHCD_TRANSFER_DESCRIPTOR
OHCI_AllocTd(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
OHCI_SubmitTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    );

ULONG
OHCI_MapAsyncTransferToTd(
    PDEVICE_DATA DeviceData,
    ULONG MaxPacketSize,
    ULONG LengthMapped,
    PTRANSFER_CONTEXT TransferContext,
    PHCD_TRANSFER_DESCRIPTOR Td, 
    PTRANSFER_SG_LIST SgList
    );    
                        
USB_MINIPORT_STATUS
OHCI_OpenEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );

MP_ENDPOINT_STATE
OHCI_GetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );

VOID
OHCI_SetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATE State
    );       

VOID
OHCI_CheckController(
    PDEVICE_DATA DeviceData
    );    

BOOLEAN
OHCI_HardwarePresent(
    PDEVICE_DATA DeviceData,
    BOOLEAN Notify
    );       

VOID
OHCI_ResetController(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
USBMPFN
OHCI_StartController(
     PDEVICE_DATA DeviceData,
     PHC_RESOURCES HcResources
    );

BOOLEAN
OHCI_InterruptService (
     PDEVICE_DATA DeviceData
    );    

USB_MINIPORT_STATUS
OHCI_RH_GetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    );

USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );    

USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
OHCI_RH_GetRootHubData(
     PDEVICE_DATA DeviceData,
     PROOTHUB_DATA HubData
    );

USB_MINIPORT_STATUS
OHCI_RH_GetStatus(
     PDEVICE_DATA DeviceData,
     PUSHORT Status
    );  

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortEnable(
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortPower(
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    );    

VOID
OHCI_RH_DisableIrq(
     PDEVICE_DATA DeviceData
    );
    
VOID
OHCI_RH_EnableIrq(
     PDEVICE_DATA DeviceData
    );

VOID
OHCI_InterruptDpc (
     PDEVICE_DATA DeviceData,
     BOOLEAN EnableInterrupts
    );   

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_GetHubStatus(
     PDEVICE_DATA DeviceData,
     PRH_HUB_STATUS HubStatus
    );    

USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
OHCI_QueryEndpointRequirements(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_REQUIREMENTS EndpointRequirements
    );    

VOID
OHCI_CloseEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );    

VOID
OHCI_PollEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );    

USB_MINIPORT_STATUS
OHCI_ControlTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    );

VOID
OHCI_ProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    BOOLEAN CompleteTransfer
    );    

USB_MINIPORT_STATUS
OHCI_PokeEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );    

USB_MINIPORT_STATUS
OHCI_BulkOrInterruptTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    );    

USB_MINIPORT_STATUS
OHCI_OpenBulkEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );    

USB_MINIPORT_STATUS
OHCI_OpenControlEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
OHCI_OpenInterruptEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );    

PHCD_TRANSFER_DESCRIPTOR
OHCI_InitializeTD(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    );

PHCD_ENDPOINT_DESCRIPTOR
OHCI_InitializeED(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PHCD_ENDPOINT_DESCRIPTOR Ed,
     PHCD_TRANSFER_DESCRIPTOR DummyTd,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    );

VOID
OHCI_InsertEndpointInSchedule(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );    

VOID
OHCI_PollAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );

VOID
USBMPFN
OHCI_StopController(
     PDEVICE_DATA DeviceData,
     BOOLEAN HwPresent
    );

ULONG
OHCI_Get32BitFrameNumber(
     PDEVICE_DATA DeviceData
    );    

VOID
OHCI_InterruptNextSOF(
     PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
OHCI_EnableInterrupts(
     PDEVICE_DATA DeviceData
    );    

VOID
USBMPFN
OHCI_DisableInterrupts(
     PDEVICE_DATA DeviceData
    );    
    
ULONG
OHCI_FreeTds(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );

VOID
OHCI_AbortTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_CONTEXT TransferContext,
     PULONG BytesTransferred
    );

USB_MINIPORT_STATUS
OHCI_StartSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     USBD_STATUS *UsbdStatus
    );   

USB_MINIPORT_STATUS
OHCI_EndSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     USBD_STATUS *UsbdStatus
    );   
    
VOID
OHCI_PollController(
     PDEVICE_DATA DeviceData
    );

VOID
OHCI_SetEndpointDataToggle(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     ULONG Toggle
    );    

MP_ENDPOINT_STATUS
OHCI_GetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );   

VOID
OHCI_SetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATUS Status
    );       

VOID
OHCI_Unload(
     PDRIVER_OBJECT DriverObject
    );    

USB_MINIPORT_STATUS
OHCI_OpenIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );  

ULONG
OHCI_MapIsoTransferToTd(
     PDEVICE_DATA DeviceData,
     PMINIPORT_ISO_TRANSFER IsoTransfer,
     ULONG CurrentPacket,
     PHCD_TRANSFER_DESCRIPTOR Td 
    );    

USB_MINIPORT_STATUS
OHCI_SubmitIsoTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PMINIPORT_ISO_TRANSFER IsoTransfer
    );

USB_MINIPORT_STATUS
OHCI_IsoTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PMINIPORT_ISO_TRANSFER IsoTransfer
    );    

VOID
OHCI_ProcessDoneIsoTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    BOOLEAN CompleteTransfer
    );

VOID
OHCI_PollIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );    

ULONG
InitializeHydraHsLsFix(
     PDEVICE_DATA DeviceData,
     PUCHAR CommonBuffer,
     HW_32BIT_PHYSICAL_ADDRESS CommonBufferPhys
    );    

VOID
OHCI_SuspendController(
     PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
OHCI_ResumeController(
     PDEVICE_DATA DeviceData
    );    

ULONG
OHCI_ReadRhDescriptorA(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortSuspendChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );    

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortOvercurrentChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );    

VOID
USBMPFN
OHCI_FlushInterrupts(
    PDEVICE_DATA DeviceData
    );    
    
#endif /* __OHCI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\usbohci.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbohci.c

Abstract:

    USB OHCI driver

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2-19-99 : created, jdunn

--*/

#include "common.h"

//implements the following miniport functions:
//OHCI_InitializeHardware
//OHCI_StartController
//OHCI_StopController
//OHCI_OpenEndpoint
//OHCI_QueryEndpointRequirements
//OHCI_PokeEndpoint

USB_MINIPORT_STATUS
OHCI_InitializeHardware(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

   Initializes the hardware registers for the host controller.

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    HC_CONTROL control;
    ULONG reg;
    ULONG sofModifyValue;
    LARGE_INTEGER finishTime, currentTime;

    hc = DeviceData->HC;

    //
    // if we made it here then we now own the HC and can initialize it.
    //

    //
    // Get current frame interval (could account for a known clock error)
    //
    DeviceData->BIOS_Interval.ul = READ_REGISTER_ULONG(&hc->HcFmInterval.ul);

    // If FrameInterval is outside the range of the nominal value of 11999
    // +/- 1% then assume the value is bogus and set it to the nominal value.
    //
    if ((DeviceData->BIOS_Interval.FrameInterval < 11879) ||
        (DeviceData->BIOS_Interval.FrameInterval > 12119)) {
        DeviceData->BIOS_Interval.FrameInterval = 11999; // 0x2EDF
    }

    //
    // Set largest data packet (in case BIOS did not set)
    //
    DeviceData->BIOS_Interval.FSLargestDataPacket =
        ((DeviceData->BIOS_Interval.FrameInterval - MAXIMUM_OVERHEAD) * 6) / 7;
    DeviceData->BIOS_Interval.FrameIntervalToggle ^= 1;

    //
    // do a hardware reset of the controller
    //
    WRITE_REGISTER_ULONG(&hc->HcCommandStatus.ul, HcCmd_HostControllerReset);
    //
    // Wait at least 10 microseconds for the reset to complete
    //
    KeStallExecutionProcessor(20);  

    //
    // Take HC to USBReset state, 
    // NOTE: this generates global reset signaling on the bus
    //
    control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
    control.HostControllerFunctionalState = HcCtrl_HCFS_USBReset;
    WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);


    //
    // Restore original frame interval, if we have a registry override 
    // value we use it instead.
    //

    // check for a registry based SOF modify Value.
    // if we have one override the BIOS value
    if (DeviceData->Flags & HMP_FLAG_SOF_MODIFY_VALUE) {
        DeviceData->BIOS_Interval.FrameInterval =
            DeviceData->SofModifyValue;
    }            

    // for some reason writing this register does not always take on 
    // the hydra so we loop until it sticks

    KeQuerySystemTime(&finishTime);
    // figure when we quit (.5 seconds later)
    finishTime.QuadPart += 5000000; 
    
    do {
    
        WRITE_REGISTER_ULONG(&hc->HcFmInterval.ul, DeviceData->BIOS_Interval.ul);
        reg = READ_REGISTER_ULONG(&hc->HcFmInterval.ul);

        OHCI_KdPrint((DeviceData, 2, "'fi reg = %x set = %x\n", reg,
            DeviceData->BIOS_Interval.ul));

        KeQuerySystemTime(&currentTime);

        if (currentTime.QuadPart >= finishTime.QuadPart) {
            // half a second has elapsed ,give up and fail the hardware        
            OHCI_KdPrint((DeviceData, 0, 
                "'frame interval not set\n"));
                
            LOGENTRY(DeviceData, G, '_fr!', 0, 0, 0);
            return USBMP_STATUS_HARDWARE_FAILURE;
        }            

    } while (reg != DeviceData->BIOS_Interval.ul);

    OHCI_KdPrint((DeviceData, 2, "'fi = %x\n", DeviceData->BIOS_Interval.ul));

    //
    // Set the HcPeriodicStart register to 90% of the FrameInterval
    //
    WRITE_REGISTER_ULONG(&hc->HcPeriodicStart,
                         (DeviceData->BIOS_Interval.FrameInterval * 9 + 5)
                         / 10);

    // set the ptr to the HCCA
    WRITE_REGISTER_ULONG(&hc->HcHCCA, DeviceData->HcHCCAPhys);
                         
    //
    // Enable interrupts, this will not cause the controller 
    // to generate any because master-enable is not set yet.
    //
    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable,
                         HcInt_OwnershipChange |
                         HcInt_SchedulingOverrun |
                         HcInt_WritebackDoneHead |
                         HcInt_FrameNumberOverflow |
                         HcInt_UnrecoverableError);
                         
    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_StopBIOS(
    PDEVICE_DATA DeviceData,
    PHC_RESOURCES HcResources
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    ULONG hcControl;

    hc = DeviceData->HC;

    //
    // Check to see if a System Management Mode driver owns the HC
    //
    
    hcControl = READ_REGISTER_ULONG(&hc->HcControl.ul);

    if (hcControl & HcCtrl_InterruptRouting) {
    
        OHCI_KdPrint((DeviceData, 1, "'detected Legacy BIOS\n"));

        HcResources->DetectedLegacyBIOS = TRUE;

        if ((hcControl == HcCtrl_InterruptRouting) &&
            (READ_REGISTER_ULONG(&hc->HcInterruptEnable) == 0)) {
        
            // Major assumption:  If HcCtrl_InterruptRouting is set but
            // no other bits in HcControl are set, i.e. HCFS==UsbReset,
            // and no interrupts are enabled, then assume that the BIOS
            // is not actually using the host controller.  In this case
            // just clear the erroneously set HcCtrl_InterruptRouting.
            //
            // This assumption appears to be correct on a Portege 3010CT,
            // where HcCtrl_InterruptRouting is set during a Resume from
            // Standby, but the BIOS doesn't actually appear to be using
            // the host controller.  If we were to continue on and set
            // HcCmd_OwnershipChangeRequest, the BIOS appears to wake up
            // and try to take ownership of the host controller instead of
            // giving it up.
            //

            OHCI_KdPrint((DeviceData, 0, 
                "'HcCtrl_InterruptRouting erroneously set\n"));

            WRITE_REGISTER_ULONG(&hc->HcControl.ul, 0);
            
        } else {
        
            LARGE_INTEGER finishTime, currentTime;
            
            //
            // A SMM driver does own the HC, it will take some time to
            // get the SMM driver to relinquish control of the HC.  We
            // will ping the SMM driver, and then wait repeatedly until
            // the SMM driver has relinquished control of the HC.
            //
            // THIS CODE ONLY WORKS IF WE ARE EXECUTING IN THE CONTEXT
            // OF A SYSTEM THREAD.
            //

            // The HAL has disabled interrupts on the HC.  Since
            // interruptrouting is set we assume there is a functional 
            // smm BIOS.  The BIOS will need the master interrupt 
            // enabled to complete the handoff (if it is disabled the 
            // machine will hang).  So we re-enable the master interrupt 
            // here.

            WRITE_REGISTER_ULONG(&hc->HcInterruptEnable,
                                 HcInt_MasterInterruptEnable);

            WRITE_REGISTER_ULONG(&hc->HcCommandStatus.ul,
                                 HcCmd_OwnershipChangeRequest);

            // hack for NEC -- disable the root hub status change 
            // to prevent an unhandled interrupt from being asserted
            // after handoff
            WRITE_REGISTER_ULONG(&hc->HcInterruptDisable,
                                 HcInt_RootHubStatusChange);                                 
// bugbug expose with service
            KeQuerySystemTime(&finishTime);
            // figure when we quit (.5 seconds later)
            finishTime.QuadPart += 5000000; 

            //
            // We told the SMM driver we want the HC, now all we can do is wait
            // for the SMM driver to be done with the HC.
            //
            while (READ_REGISTER_ULONG(&hc->HcControl.ul) &
                   HcCtrl_InterruptRouting) {
                   
                KeQuerySystemTime(&currentTime);

                if (currentTime.QuadPart >= finishTime.QuadPart) {
                
                    OHCI_KdPrint((DeviceData, 0, 
                        "'SMM has not relinquised HC -- this is a HW bug\n"));

                    LOGENTRY(DeviceData, G, '_sm!', 0, 0, 0);
                    return USBMP_STATUS_HARDWARE_FAILURE;
                }
            }

            // we have control, disable master interrupt until we 
            // finish intializing
            WRITE_REGISTER_ULONG(&hc->HcInterruptStatus,
                                 0xffffffff);

            WRITE_REGISTER_ULONG(&hc->HcInterruptDisable,
                                 HcInt_MasterInterruptEnable);

        }
    }
    
    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_InitializeSchedule(
     PDEVICE_DATA DeviceData,
     PUCHAR StaticEDs,
     HW_32BIT_PHYSICAL_ADDRESS StaticEDsPhys,
     PUCHAR EndCommonBuffer
    )
/*++

Routine Description:

    Build the schedule of static Eds 

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    ULONG length;
    ULONG i;
    PHC_OPERATIONAL_REGISTER hc;
    
    //
    // Allocate staticly disabled EDs, and set head pointers for 
    // scheduling lists
    //
    // The static ED list is contains all the static interrupt EDs (64)
    // plus the static ED for bulk and control (2)
    //
    // the array looks like this:
    //  1, 2, 2, 4, 4, 4, 4, 8,
    //  8, 8, 8, 8, 8, 8, 8,16,
    // 16,16,16,16,16,16,16,16,
    // 16,16,16,16,16,16,16,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,
    // CONTROL
    // BULK

    // each static ED points to another static ED 
    // (except for the 1ms ed) the INDEX of the next 
    // ED in the StaticEDList is stored in NextIdx,
    // these values are constent
    CHAR nextIdxTable[63] = {
             // 0  1  2  3  4  5  6  7
     (CHAR)ED_EOF, 0, 0, 1, 1, 2, 2, 3, 
             // 8  9 10 11 12 13 14 15
                3, 4, 4, 5, 5, 6, 6, 7, 
             //16 17 18 19 20 21 22 23               
                7, 8, 8, 9, 9,10,10,11,
             //24 25 26 27 28 29 30 31                 
               11,12,12,13,13,14,14,15,
             //32 33 34 35 36 37 38 39  
               15,16,16,17,17,18,18,19,
             //40 41 42 43 44 45 46 47   
               19,20,20,21,21,22,22,23,
             //48 49 50 51 52 53 54 55               
               23,24,24,25,25,26,26,27,
             //56 57 58 59 60 61 62 63               
               27,28,28,29,29,30,30
    };             

/*
    Numbers are the index into the static ed table

    (31) -\ 
          (15)-\
    (32) -/     \
                (7 )-\
    (33) -\     /     \
          (16)-/       \
    (34) -/             \
                        (3)-\
    (35) -\             /    \
          (17)-\       /      \
    (36) -/     \     /        \
                (8 )-/          \
    (37) -\     /                \
          (18)-/                  \  
    (38) -/                        \
                                   (1)-\
    (39) -\                        /    \
          (19)-\                  /      \
    (40) -/     \                /        \
                (9 )-\          /          \
    (41) -\     /     \        /            \
          (20)-/       \      /              \
    (42) -/             \    /                \
                        (4)-/                  \
    (43) -\             /                       \
          (21)-\       /                         \
    (44) -/     \     /                           \
                (10)-/                             \
    (45) -\     /                                   \ 
          (22)-/                                     \
    (46) -/                                           \
                                                      (0)                          
    (47) -\                                           /
          (23)-\                                     /
    (48) -/     \                                   /
                (11)-\                             /
    (49) -\     /     \                           /
          (24)-/       \                         /
    (50) -/             \                       /
                        (5)-\                  /
    (51) -\             /    \                /
          (25)-\       /      \              /
    (52) -/     \     /        \            /
                (12)-/          \          /
    (53) -\     /                \        /
          (26)-/                  \      /
    (54) -/                        \    /
                                   (2)-/
    (55) -\                        /
          (27)-\                  /
    (56) -/     \                /
                (13)-\          /
    (57) -\     /     \        /
          (28)-/       \      /
    (58) -/             \    /   
                        (6)-/
    (59) -\             /
          (29)-\       /
    (60) -/     \     /
                (14)-/
    (61) -\     /
          (30)-/
    (62) -/
*/

    // corresponding offsets for the 32ms list heads in the 
    // HCCA -- these are entries 31..62
    ULONG used = 0;
    CHAR Hcca32msOffsets[32] = {
                 0, 16,  8, 24,  4, 20, 12, 28, 
                 2, 18, 10, 26,  6, 22, 14, 30,  
                 1, 17,  9, 25,  5, 21, 13, 29,  
                 3, 19, 11, 27,  7, 23, 15, 31
                 };            

    DeviceData->StaticEDs = StaticEDs;
    DeviceData->StaticEDsPhys = StaticEDsPhys;

    hc = DeviceData->HC;
    
    // initailze all interrupt EDs

    for (i=0; i<ED_CONTROL; i++) {
        CHAR n;
        PHW_ENDPOINT_DESCRIPTOR hwED;
        
        //
        // Carve EDs from the common buffer 
        //
        hwED = (PHW_ENDPOINT_DESCRIPTOR) StaticEDs;
        n = nextIdxTable[i];
        
        // initialize the hardware ED
        hwED->TailP = hwED->HeadP = 0xDEAD0000;
        //hwED->TailP = hwED->HeadP = StaticEDsPhys;
        hwED->Control = HcEDControl_SKIP;   // ED is disabled
        
        LOGENTRY(DeviceData, G, '_isc', n, &DeviceData->StaticEDList[0], 0);
     
        if (n == (CHAR)ED_EOF) {
            hwED->NextED = 0;
        } else {
            OHCI_ASSERT(DeviceData, n>=0 && n<31);
            hwED->NextED = DeviceData->StaticEDList[n].HwEDPhys;
        }                

        // initailze the list we use for real EDs
        InitializeListHead(&DeviceData->StaticEDList[i].TransferEdList);
        DeviceData->StaticEDList[i].HwED = hwED;
        DeviceData->StaticEDList[i].HwEDPhys = StaticEDsPhys; 
        DeviceData->StaticEDList[i].NextIdx = n;
        DeviceData->StaticEDList[i].EdFlags = EDFLAG_INTERRUPT;
        
          // store address of hcc table entry
        DeviceData->StaticEDList[i].PhysicalHead = 
            &hwED->NextED;

        // next ED
        StaticEDs += sizeof(HW_ENDPOINT_DESCRIPTOR);
        StaticEDsPhys += sizeof(HW_ENDPOINT_DESCRIPTOR);
    }

    // now set the head pointers in the HCCA
    // the HCCA points to all the 32ms list heads
    for (i=0; i<32; i++) {
    
        ULONG hccaOffset;

        hccaOffset = Hcca32msOffsets[i];
        
        DeviceData->HcHCCA->HccaInterruptTable[hccaOffset] = 
            DeviceData->StaticEDList[i+ED_INTERRUPT_32ms].HwEDPhys;
        DeviceData->StaticEDList[i+ED_INTERRUPT_32ms].HccaOffset = 
            hccaOffset;    

        // physical head for 32ms list point to HCCA
        DeviceData->StaticEDList[i+ED_INTERRUPT_32ms].PhysicalHead = 
            &DeviceData->HcHCCA->HccaInterruptTable[hccaOffset];
            
    }

    //
    // Setup EDList entries for Control & Bulk
    //
    InitializeListHead(&DeviceData->StaticEDList[ED_CONTROL].TransferEdList);
    DeviceData->StaticEDList[ED_CONTROL].NextIdx = (CHAR) ED_EOF;
    DeviceData->StaticEDList[ED_CONTROL].PhysicalHead = &hc->HcControlHeadED;
    DeviceData->StaticEDList[ED_CONTROL].EdFlags = EDFLAG_CONTROL | EDFLAG_REGISTER;
        
    InitializeListHead(&DeviceData->StaticEDList[ED_BULK].TransferEdList);
    DeviceData->StaticEDList[ED_BULK].NextIdx = (CHAR) ED_EOF;
    DeviceData->StaticEDList[ED_BULK].PhysicalHead = &hc->HcBulkHeadED;
    DeviceData->StaticEDList[ED_BULK].EdFlags = EDFLAG_BULK | EDFLAG_REGISTER;

    if (DeviceData->ControllerFlavor == OHCI_Hydra) {
        used = InitializeHydraHsLsFix(DeviceData, StaticEDs, StaticEDsPhys);
    }        

    StaticEDs += used;
    StaticEDsPhys += used;

    OHCI_ASSERT(DeviceData, StaticEDs <= EndCommonBuffer);
    
    mpStatus = USBMP_STATUS_SUCCESS;
    
    return mpStatus;
}


VOID
OHCI_GetRegistryParameters(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    sets the registry based sof modify value

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    ULONG clocksPerFrame;
    
    // get SOF modify value from registry
    mpStatus = 
        USBPORT_GET_REGISTRY_KEY_VALUE(DeviceData,
                                       TRUE, // software branch
                                       SOF_MODIFY_KEY, 
                                       sizeof(SOF_MODIFY_KEY), 
                                       &clocksPerFrame, 
                                       sizeof(clocksPerFrame));

    // if this call fails we just use the default
    
    if (mpStatus == USBMP_STATUS_SUCCESS) {
        SET_FLAG(DeviceData->Flags, HMP_FLAG_SOF_MODIFY_VALUE);
        DeviceData->SofModifyValue = clocksPerFrame;   
        OHCI_KdPrint((DeviceData, 1, "'Recommended Clocks/Frame %d \n", 
                clocksPerFrame));
   
    }
    
}


VOID
USBMPFN
OHCI_StopController(
     PDEVICE_DATA DeviceData,
     BOOLEAN HwPresent
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HC_CONTROL control;
    PHC_OPERATIONAL_REGISTER hc = NULL;
    
    hc = DeviceData->HC;

    control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
    
    control.ul &= ~(HcCtrl_PeriodicListEnable |
                    HcCtrl_IsochronousEnable |
                    HcCtrl_ControlListEnable |
                    HcCtrl_BulkListEnable |
                    HcCtrl_RemoteWakeupEnable);
                    
    control.HostControllerFunctionalState =
        HcHCFS_USBSuspend;
        
    WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);
    WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 0xFFFFffff);
    WRITE_REGISTER_ULONG(&hc->HcInterruptStatus, 0xFFFFffff);

}


USB_MINIPORT_STATUS
USBMPFN
OHCI_StartController(
     PDEVICE_DATA DeviceData,
     PHC_RESOURCES HcResources
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    PHC_OPERATIONAL_REGISTER hc = NULL;
    PUCHAR endCommonBuffer;

    OHCI_KdPrint((DeviceData, 1, "'OPENHCI Miniport\n"));

    // assume success
    mpStatus = USBMP_STATUS_SUCCESS;
    
    OHCI_ASSERT(DeviceData, HcResources->CommonBufferVa != NULL);
    // validate our resources
    if ((HcResources->Flags & (HCR_MEM_REGS | HCR_IRQ)) != 
        (HCR_MEM_REGS | HCR_IRQ)) {
        mpStatus = USBMP_STATUS_INIT_FAILURE;        
    }

    // set up or device data structure
    hc = DeviceData->HC = HcResources->DeviceRegisters;
    DeviceData->Sig = SIG_OHCI_DD;
    DeviceData->ControllerFlavor = 
        HcResources->ControllerFlavor;
    if (DeviceData->ControllerFlavor == OHCI_Hydra) {
        OHCI_KdPrint((DeviceData, 1, "'OPENHCI Hydra Detected\n"));
    }

    OHCI_GetRegistryParameters(DeviceData);

    // init misc fields in the extension

    // attempt to stop the BIOS
    if (mpStatus == USBMP_STATUS_SUCCESS) {
        mpStatus = OHCI_StopBIOS(DeviceData, HcResources);
    }        

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        PUCHAR staticEDs;
        HW_32BIT_PHYSICAL_ADDRESS staticEDsPhys;

        // carve the common buffer block in to HCCA and
        // static EDs
        //
        // set the HCCA and
        // set up the schedule

        DeviceData->HcHCCA = (PHCCA_BLOCK)
            HcResources->CommonBufferVa;
        DeviceData->HcHCCAPhys = 
            HcResources->CommonBufferPhys; 
        endCommonBuffer = HcResources->CommonBufferVa + 
            OHCI_COMMON_BUFFER_SIZE;
            
            
        staticEDs = HcResources->CommonBufferVa + sizeof(HCCA_BLOCK);
        staticEDsPhys = HcResources->CommonBufferPhys + sizeof(HCCA_BLOCK);                
        mpStatus = OHCI_InitializeSchedule(DeviceData,
                                              staticEDs,
                                              staticEDsPhys,
                                              endCommonBuffer);            

    } 
    
    if (mpStatus == USBMP_STATUS_SUCCESS) {
        // got resources and schedule
        // init the controller 
        mpStatus = OHCI_InitializeHardware(DeviceData);
    }      

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        HC_CONTROL control;

        // When the HC is in the operational state, HccaPad1 should be set to
        // zero every time the HC updates HccaFrameNumer.  Preset HccaPad1 to
        // zero before entering the operational state.  OHCI_CheckController()
        // should always find a zero value in HccaPad1 when the HC is in the
        // operational state.
        // 
        DeviceData->HcHCCA->HccaPad1 = 0;

        // activate the controller
        control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
        control.HostControllerFunctionalState = HcHCFS_USBOperational;
        // enable control and bulk interrupt and iso we only disable 
        // them if we need to remove ED or if the controller 
        // is idle.
        control.ControlListEnable = 1;
        control.BulkListEnable = 1;
        control.PeriodicListEnable = 1;
        control.IsochronousEnable = 1;
        
        WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);

        // enable power for the root hub
        // since messing with the 'operatinal state' messes
        // up the root hub we the do the global power set here
        WRITE_REGISTER_ULONG(&hc->HcRhStatus, HcRhS_SetGlobalPower);

    } else {
        
        DEBUG_BREAK(DeviceData);
    }

    return mpStatus;
}


VOID
USBMPFN
OHCI_DisableInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc = NULL;

    // set up or device data structure
    hc = DeviceData->HC;
        
    WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 
                         HcInt_MasterInterruptEnable);
}


VOID
USBMPFN
OHCI_FlushInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    //nop
}

VOID
USBMPFN
OHCI_EnableInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc = NULL;

    // set up or device data structure
    hc = DeviceData->HC;

    // activate the controllers interrupt
    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable, 
                         HcInt_MasterInterruptEnable);

}


VOID
OHCI_InsertEndpointInSchedule(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

   Insert an endpoint into the h/w schedule

Arguments:


--*/
{
    PHC_STATIC_ED_DATA staticEd;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    
    staticEd = EndpointData->StaticEd;
    ed = EndpointData->HcdEd;
    
    //
    // Link endpoint descriptor into HCD tracking queue
    //
    // each static ED stucture conatins a list of real
    // EDs (that are for transfers)
    //
    // the HW list is linear with :
    // TransferHwED->TransferHwED->0

    if (IsListEmpty(&staticEd->TransferEdList)) {

        //
        // list is currently empty,
        // link it to the head of the hw queue
        //

        InsertHeadList(&staticEd->TransferEdList, &ed->SwLink.List);
        if (staticEd->EdFlags & EDFLAG_REGISTER) {

            // control and bulk EDs are linked thru a hw register
            // in the hc
            // 
            // the HW list is linear with :
            // TransferHwED->TransferHwED->0
            //
            // update the hardware register that points to the list head

            LOGENTRY(DeviceData, G, '_IN1', 0, ed, staticEd);
            // next points to static head
            ed->HwED.NextED = READ_REGISTER_ULONG(staticEd->PhysicalHead);
            // new head is this ed
            WRITE_REGISTER_ULONG(staticEd->PhysicalHead, ed->PhysicalAddress);
            
        } else {

            // for interrupt we have two cases
            //
            // case 1:
            // 32ms interrupt, PhysicalHead is the address of the entry
            // in the HCCA that points to the first 32 ms list 
            // (ie &HCCA[n] == physicalHead),
            // so we end up with:
            // HCCA[n]->TransferHwED->TransferHwED->StaticEd(32)->
            //
            // case 2:
            // not 32ms interrupt, PhysicaHead is the address of the 
            // NextED entry in the static HwED for the list list,  
            // (ie &HwED->nextEd == physicalHead)
            // so we end up with
            // StaticEd->TransferHwED->TransferHwED->NextStaticED
            //
            
                        
            LOGENTRY(DeviceData, G, '_IN2', staticEd->PhysicalHead, 
                ed, staticEd);
            // tail points to old list head HW ed head
            ed->HwED.NextED = *staticEd->PhysicalHead;
            // new head is this ed
            *staticEd->PhysicalHead = ed->PhysicalAddress;
        }
    } else {
    
        PHCD_ENDPOINT_DESCRIPTOR tailEd;
        
        //
        // Something already on the list,
        // Link ED into tail of transferEd list
        //
        
        tailEd = CONTAINING_RECORD(staticEd->TransferEdList.Blink,
                                   HCD_ENDPOINT_DESCRIPTOR,
                                   SwLink);
                                  
        LOGENTRY(DeviceData, G, '_Led', 0, tailEd, staticEd);
        //LOGENTRY(G, 'INT1', list, ed, 0);
        InsertTailList(&staticEd->TransferEdList, &ed->SwLink.List);
        ed->HwED.NextED = 0;
        tailEd->HwED.NextED = ed->PhysicalAddress;
    }
}


VOID
OHCI_RemoveEndpointFromSchedule(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

   Remove an endpoint from the h/w schedule

Arguments:


--*/
{
    PHC_STATIC_ED_DATA staticEd;
    PHCD_ENDPOINT_DESCRIPTOR ed, previousEd;

    staticEd = EndpointData->StaticEd;
    ed = EndpointData->HcdEd;
    OHCI_ASSERT_ED(DeviceData, ed);

    LOGENTRY(DeviceData, G, '_Red', EndpointData, staticEd, 0);

    // Unlink the ED from the physical ED list 
    
    // two cases:
    
    if (&staticEd->TransferEdList == ed->SwLink.List.Blink) {
    // case 1, we are at the head of the list
        // make the next guy the head
        LOGENTRY(DeviceData, G, '_yHD', EndpointData, 0, 0);
        if (ed->EdFlags & EDFLAG_REGISTER) {
            WRITE_REGISTER_ULONG(staticEd->PhysicalHead, ed->HwED.NextED);
        } else {
            *staticEd->PhysicalHead = ed->HwED.NextED;
        }
    } else {
    // case 2 we are not at the head
        // use the sw link to get the previus ed
        previousEd =
            CONTAINING_RECORD(ed->SwLink.List.Blink,
                              HCD_ENDPOINT_DESCRIPTOR,
                              SwLink);
        LOGENTRY(DeviceData, G, '_nHD', EndpointData, previousEd, 0);
        OHCI_ASSERT_ED(DeviceData, previousEd); 

        previousEd->HwED.NextED = ed->HwED.NextED;

    }
    // remove ourselves from the software list
    RemoveEntryList(&ed->SwLink.List); 
    // on no list
    EndpointData->StaticEd = NULL;
    
}    


PHCD_ENDPOINT_DESCRIPTOR
OHCI_InitializeED(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PHCD_ENDPOINT_DESCRIPTOR Ed,
     PHCD_TRANSFER_DESCRIPTOR DummyTd,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    )
/*++

Routine Description:

   Initialize an ED for inserting in to the 
   schedule

   returns a ptr to the ED passed in

Arguments:


--*/
{

    RtlZeroMemory(Ed, sizeof(*Ed));
    
    Ed->PhysicalAddress = HwPhysAddress;
    ENDPOINT_DATA_PTR(Ed->EndpointData) = EndpointData;
    Ed->Sig = SIG_HCD_ED;

    // init the hw descriptor
    Ed->HwED.FunctionAddress = EndpointData->Parameters.DeviceAddress;
    Ed->HwED.EndpointNumber = EndpointData->Parameters.EndpointAddress;

    if (EndpointData->Parameters.TransferType == Control) {
        Ed->HwED.Direction = HcEDDirection_Defer;   
    } else if (EndpointData->Parameters.TransferDirection == In) {
        Ed->HwED.Direction = HcEDDirection_In;
    } else {
        Ed->HwED.Direction = HcEDDirection_Out;
    }
    
    Ed->HwED.sKip = 1;

    if (EndpointData->Parameters.DeviceSpeed == LowSpeed) {
        Ed->HwED.LowSpeed = 1;
    } 
    
    if (EndpointData->Parameters.TransferType == Isochronous) {
        Ed->HwED.Isochronous = 1;
    } 
    Ed->HwED.MaxPacket = EndpointData->Parameters.MaxPacketSize;

    // set head tail ptr to point to the dummy TD
    Ed->HwED.TailP = Ed->HwED.HeadP = DummyTd->PhysicalAddress;
    SET_FLAG(DummyTd->Flags, TD_FLAG_BUSY);
    EndpointData->HcdHeadP = EndpointData->HcdTailP = DummyTd;

    return Ed;
}


PHCD_TRANSFER_DESCRIPTOR
OHCI_InitializeTD(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    )
/*++

Routine Description:

   Initialize an ED for insertin in to the 
   schedule

   returns a ptr to the ED passed in

Arguments:


--*/
{
    RtlZeroMemory(Td, sizeof(*Td));
    
    Td->PhysicalAddress = HwPhysAddress;
    ENDPOINT_DATA_PTR(Td->EndpointData) = EndpointData;
    Td->Flags = 0;
    Td->Sig = SIG_HCD_TD;
    TRANSFER_CONTEXT_PTR(Td->TransferContext) = FREE_TD_CONTEXT;

    return Td;
}


USB_MINIPORT_STATUS
OHCI_OpenEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    
    EndpointData->Sig = SIG_EP_DATA;
    // save a copy of the parameters
    EndpointData->Parameters = *EndpointParameters;
    EndpointData->Flags = 0;
    EndpointData->PendingTransfers = 0;
    InitializeListHead(&EndpointData->DoneTdList);
     
    switch (EndpointParameters->TransferType) {
    
    case Control:
        mpStatus = OHCI_OpenControlEndpoint(
                DeviceData,
                EndpointParameters,
                EndpointData);
            
        break;
        
    case Interrupt:
        mpStatus = OHCI_OpenInterruptEndpoint(
                DeviceData,
                EndpointParameters,
                EndpointData);
                
        break;
    case Bulk:
        mpStatus = OHCI_OpenBulkEndpoint(
                DeviceData,
                EndpointParameters,
                EndpointData);
                
        break;        
    case Isochronous:
        mpStatus = OHCI_OpenIsoEndpoint(
                DeviceData,
                EndpointParameters,
                EndpointData);
        
        break;
        
    default:
        mpStatus = USBMP_STATUS_NOT_SUPPORTED;
    }

    return mpStatus;
}


USB_MINIPORT_STATUS
OHCI_PokeEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG oldBandwidth;

    LOGENTRY(DeviceData, G, '_Pok', EndpointData, 
        EndpointParameters, 0);
    
    ed = EndpointData->HcdEd;

    oldBandwidth = EndpointData->Parameters.Bandwidth;
    EndpointData->Parameters = *EndpointParameters;
    
    ed->HwED.FunctionAddress = 
        EndpointData->Parameters.DeviceAddress; 
        
    ed->HwED.MaxPacket = 
        EndpointData->Parameters.MaxPacketSize;

    // adjust bw if necessary
    if (EndpointData->Parameters.TransferType == Isochronous ||
        EndpointData->Parameters.TransferType == Interrupt) {

        // subtract the old bandwidth
        EndpointData->StaticEd->AllocatedBandwidth -= 
            oldBandwidth;
        // add on new bw            
        EndpointData->StaticEd->AllocatedBandwidth += 
            EndpointData->Parameters.Bandwidth;
    }           

    return USBMP_STATUS_SUCCESS;
}


VOID
OHCI_QueryEndpointRequirements(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_REQUIREMENTS EndpointRequirements
    )
/*++

Routine Description:

    compute how much common buffer we will need 
    for this endpoint

Arguments:

Return Value:

--*/
{


    switch (EndpointParameters->TransferType) {
    
    case Control:
    
        EndpointRequirements->MinCommonBufferBytes = 
            sizeof(HCD_ENDPOINT_DESCRIPTOR) + 
                TDS_PER_CONTROL_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

        EndpointRequirements->MaximumTransferSize = 
            MAX_CONTROL_TRANSFER_SIZE;

        break;
        
    case Interrupt:
    
        EndpointRequirements->MinCommonBufferBytes = 
            sizeof(HCD_ENDPOINT_DESCRIPTOR) + 
                TDS_PER_INTERRUPT_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

#ifdef TEST_SPLIT
        EndpointRequirements->MaximumTransferSize = 
            EndpointParameters->MaxPacketSize;

#else 
        EndpointRequirements->MaximumTransferSize = 
            MAX_INTERRUPT_TRANSFER_SIZE; 
#endif
        break;
        
    case Bulk:
        
        EndpointRequirements->MinCommonBufferBytes = 
            sizeof(HCD_ENDPOINT_DESCRIPTOR) + 
                TDS_PER_BULK_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);
#ifdef TEST_SPLIT
        EndpointRequirements->MaximumTransferSize = 4096;

#else 
        EndpointRequirements->MaximumTransferSize = 
            MAX_BULK_TRANSFER_SIZE; 
#endif
        break;

    case Isochronous:

        // BUGBUG NOTE
        // the 1.1 USBDI caped requests at 255 packets per urb 
        EndpointRequirements->MinCommonBufferBytes = 
            sizeof(HCD_ENDPOINT_DESCRIPTOR) + 
                TDS_PER_ISO_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

        EndpointRequirements->MaximumTransferSize = 
            MAX_ISO_TRANSFER_SIZE; 

        break;        
        
    default:
        TEST_TRAP();
    }
    
}


VOID
OHCI_CloseEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // nothing to do here
}


VOID
OHCI_PollEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    switch(EndpointData->Parameters.TransferType) { 
    case Control:
    case Interrupt:
    case Bulk:    
        OHCI_PollAsyncEndpoint(DeviceData, EndpointData);
        break;
    case Isochronous:
        OHCI_PollIsoEndpoint(DeviceData, EndpointData);
        break;
    }        
    
}


VOID
OHCI_PollController(
     PDEVICE_DATA DeviceData
    )     
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    BOOLEAN hcOk = TRUE;
    
    TEST_TRAP();
#if 0
    // see if the controller is still operating

    fn = DeviceData->HcHCCA->HccaFrameNumber;
    if (DeviceData->LastFn && DeviceData->LastFn == fn) {
        hcOk = FALSE;
    } 

    if (hcOK) {
        DeviceData->LastFn = fn;
    } else {
        OHCI_KdPrint((DeviceData, 0, "Controller has crashed\n");
        // bugbug, signal USBPORT to attempt recovery
        TEST_TRAP();
    }
#endif    
}


VOID
OHCI_AbortTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_CONTEXT AbortTransferContext,
     PULONG BytesTransferred
    )
/*++

Routine Description:

    Called when a transfer needs to be removed 
    from the schedule.

    This process is vertually identical regardless 
    of transfer type

Arguments:

Return Value:

--*/

{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd, tmpTd;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i;
    BOOLEAN found = FALSE;
    BOOLEAN iso = FALSE; // assume its async

    if (EndpointData->Parameters.TransferType == Isochronous) {
        iso = TRUE;
    }
    
    ed = EndpointData->HcdEd;

    //
    //  The endpoint should have the skip bit set 
    //  ie 'paused'
    //
    OHCI_ASSERT(DeviceData, ed->HwED.sKip == 1);
    
    LOGENTRY(DeviceData, G, '_abr', ed, AbortTransferContext, 
        EndpointData);        

    // one less pending transfer
    EndpointData->PendingTransfers--;

    // our mission now is to remove all TDs associated with 
    // this transfer

    // get the 'currentTD' 
    currentTd = (PHCD_TRANSFER_DESCRIPTOR)
            USBPORT_PHYSICAL_TO_VIRTUAL(ed->HwED.HeadP & ~HcEDHeadP_FLAGS,
                                        DeviceData,
                                        EndpointData);

    // we have three possible cases to deal with:
    // case 1: the transfer is current, headp points to a TD 
    //            associated with this transfer
    // case 2: transfer is already done, we just need to free 
    //            the TDs  
    // case 3: transfer is not processed, we need to link
    //            the current transfer to the next.
    

    if (TRANSFER_CONTEXT_PTR(currentTd->TransferContext)
        == AbortTransferContext) {
    
        LOGENTRY(DeviceData, G, '_aCU', currentTd, 
            0, 0);                 
    
        // case 1: transfer is current 
      
        found = TRUE;

        // set Headp to next transfer and update sw pointers in ED 
        tmpTd = AbortTransferContext->NextXferTd;
        // preserve the data toggle for whatever the transfer 
        ed->HwED.HeadP = tmpTd->PhysicalAddress | 
            (ed->HwED.HeadP & HcEDHeadP_CARRY);
        EndpointData->HcdHeadP = tmpTd;

        // loop thru all TDs and free the ones for this tarnsfer
        for (i=0; i<EndpointData->TdCount; i++) {
           tmpTd = &EndpointData->TdList->Td[i];

            if (TRANSFER_CONTEXT_PTR(tmpTd->TransferContext)
                == AbortTransferContext) {
                if (iso) {
                    OHCI_ProcessDoneIsoTd(DeviceData,
                                          tmpTd,
                                          FALSE);
                } else {
                    OHCI_ProcessDoneAsyncTd(DeviceData,
                                            tmpTd,
                                            FALSE);
                }
            }                    
        }            
        
    } else {

        // not current, walk the the list of TDs from the 
        // last known HeadP to the current TD if we find it 
        // it is already done (case 2).

        // Issue to investigate:  What if we find some TDs which belong to
        // this transfer but we stop walking the TD list when we hit currentTd
        // and there are still TDs queued which belong to this transfer?  If
        // they stay stuck on the HW and the transfer is freed that would be
        // bad.

        td = EndpointData->HcdHeadP;
        while (td != currentTd) {
        
            PTRANSFER_CONTEXT transfer;    
            
            transfer = TRANSFER_CONTEXT_PTR(td->TransferContext);        
            ASSERT_TRANSFER(DeviceData, transfer);                        

            if (transfer == AbortTransferContext) {
                // case 2 the transfer TDs have already
                // been comlpleted by the hardware
                found = TRUE;

                LOGENTRY(DeviceData, G, '_aDN', currentTd, 
                    td, 0);    

                // free this TD
                tmpTd = td;
                td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);

                // if this TD was the head we need to bump the
                // headp
                if (tmpTd == EndpointData->HcdHeadP) {
                    EndpointData->HcdHeadP = td;
                }

                if (iso) {
                    OHCI_ProcessDoneIsoTd(DeviceData,
                                          tmpTd,
                                          FALSE);
                } else {
                    OHCI_ProcessDoneAsyncTd(DeviceData,
                                            tmpTd,
                                            FALSE);
                }
                
            } else {
            
                // we walk the SW links
                td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            }    
        }           
    }

    if (!found) {
    
        PHCD_TRANSFER_DESCRIPTOR firstTd, lastTd;
        PTRANSFER_CONTEXT prevTransfer;
        
        // case 3 the transfer is not current and not done. 
        // 1. we need to find it.
        // 2. unlink it from the prevoius transfer
        // 3. free the TDs
        // 4. link prev transfer to the next

        
        
        td = EndpointData->HcdHeadP;
        firstTd = NULL;

        LOGENTRY(DeviceData, G, '_abP', EndpointData->HcdHeadP, 
                    EndpointData->HcdTailP, currentTd);    

        // start at the current HeadP and find the first 
        // td for this transfer

        lastTd = td;
        while (td != EndpointData->HcdTailP) {
            PTRANSFER_CONTEXT transfer;
            
            transfer = TRANSFER_CONTEXT_PTR(td->TransferContext);        
            ASSERT_TRANSFER(DeviceData, transfer);                        
            
            if (transfer == AbortTransferContext) {
                // found it 
                LOGENTRY(DeviceData, G, '_fnT', transfer, 
                    td, 0);    

                firstTd = td;
                break;
            } else {
                lastTd = td;
                td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            }
        }

        OHCI_ASSERT(DeviceData, firstTd != NULL);

        // found the first TD, walk to the HcdTailP or the 
        // next transfer and free these TDs
        td = firstTd;
        while (td != EndpointData->HcdTailP) {
            
            tmpTd = td;
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);

            if (iso) {
                OHCI_ProcessDoneIsoTd(DeviceData,
                                      tmpTd,
                                      FALSE);
            } else {
                OHCI_ProcessDoneAsyncTd(DeviceData,
                                        tmpTd,
                                        FALSE);
            }

            if (TRANSFER_CONTEXT_PTR(td->TransferContext) != 
                AbortTransferContext) {
                break;
            }                 
            
        }

        LOGENTRY(DeviceData, G, '_NnT', 0, td, 0);    

        // td should now point to the next Transfer (or the 
        // tail)

        OHCI_ASSERT(DeviceData, 
            TRANSFER_CONTEXT_PTR(td->TransferContext) !=
            AbortTransferContext);        

        // BUGBUG toggle?

        // link last TD of the prev transfer to this TD
        // 
        prevTransfer = TRANSFER_CONTEXT_PTR(lastTd->TransferContext);

        prevTransfer->NextXferTd = td;
        
        TRANSFER_DESCRIPTOR_PTR(lastTd->NextHcdTD) = td;

        lastTd->HwTD.NextTD = td->PhysicalAddress;
    }

    *BytesTransferred = AbortTransferContext->BytesTransferred;

}


USB_MINIPORT_STATUS
OHCI_SubmitIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    )
{
    USB_MINIPORT_STATUS mpStatus;

    // init the context
    RtlZeroMemory(TransferContext, sizeof(*TransferContext));
    TransferContext->Sig = SIG_OHCI_TRANSFER;
    TransferContext->UsbdStatus = USBD_STATUS_SUCCESS;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = TransferParameters;

    OHCI_ASSERT(DeviceData, 
        EndpointData->Parameters.TransferType == Isochronous);         
        
    mpStatus = 
        OHCI_IsoTransfer(DeviceData,
                         EndpointData,
                         TransferParameters,
                         TransferContext,
                         IsoTransfer);           

    return mpStatus;
}            


USB_MINIPORT_STATUS
OHCI_SubmitTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    )
{
    USB_MINIPORT_STATUS mpStatus;

    // init the context
    RtlZeroMemory(TransferContext, sizeof(*TransferContext));
    TransferContext->Sig = SIG_OHCI_TRANSFER;
    TransferContext->UsbdStatus = USBD_STATUS_SUCCESS;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = TransferParameters;

    switch (EndpointData->Parameters.TransferType) {        
    case Control:
        mpStatus = 
            OHCI_ControlTransfer(DeviceData,
                                 EndpointData,
                                 TransferParameters,
                                 TransferContext,
                                 TransferSGList);           
        break;
    case Interrupt:
    case Bulk:
        mpStatus = 
            OHCI_BulkOrInterruptTransfer(DeviceData,
                                         EndpointData,
                                         TransferParameters,
                                         TransferContext,
                                         TransferSGList);
        break;
    default:
        TEST_TRAP();
    }

    return mpStatus;
}


PHCD_TRANSFER_DESCRIPTOR
OHCI_AllocTd(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG i;
    PHCD_TRANSFER_DESCRIPTOR td;    
    
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if (!(td->Flags & TD_FLAG_BUSY)) {
            SET_FLAG(td->Flags, TD_FLAG_BUSY);
            LOGENTRY(DeviceData, G, '_aTD', td, 0, 0);
            return td;
        }                    
    }

    // this is a bug in the miniport -- ohci driver should always 
    // have enough TDs in the event we can't find one we will call
    // the usbport bugcheck routine.

    // USBPORTSVC_BugCheck();
    OHCI_ASSERT(DeviceData, FALSE);
    return USB_BAD_PTR;
}


ULONG
OHCI_FreeTds(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    return the number of free TDs

Arguments:

Return Value:

--*/
{
    ULONG i;
    PHCD_TRANSFER_DESCRIPTOR td;    
    ULONG n=0;
    
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if (!(td->Flags & TD_FLAG_BUSY)) {
            n++;
        }                    
    }

    return n;
}


VOID
OHCI_EnableList(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHC_OPERATIONAL_REGISTER hc;
    ULONG listFilled = 0;
    ULONG temp;
    
    hc = DeviceData->HC;
    
    temp = READ_REGISTER_ULONG(&hc->HcControlHeadED);
    if (temp) {
        SET_FLAG(listFilled, HcCmd_ControlListFilled);
    }
    
    temp = READ_REGISTER_ULONG (&hc->HcBulkHeadED);
    if (temp) {
        SET_FLAG(listFilled, HcCmd_BulkListFilled);
    }
    
    if (EndpointData->Parameters.TransferType == Bulk) {
        SET_FLAG(listFilled, HcCmd_BulkListFilled);
    } else if (EndpointData->Parameters.TransferType == Control) {
        SET_FLAG(listFilled, HcCmd_ControlListFilled);
    }
    
    WRITE_REGISTER_ULONG(&hc->HcCommandStatus.ul,
                         listFilled);
                         
    LOGENTRY(DeviceData, G, '_enL', listFilled, EndpointData, 0); 
            
}    


VOID
OHCI_SetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATUS Status
    )    
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHCD_ENDPOINT_DESCRIPTOR ed;
    PHC_OPERATIONAL_REGISTER hc;
    
    ed = EndpointData->HcdEd;
    
    switch(Status) {
    case ENDPOINT_STATUS_RUN:
        // clear halt bit 
        ed->HwED.HeadP &= ~HcEDHeadP_HALT; 
        OHCI_EnableList(DeviceData, EndpointData);        
        break;
        
    case ENDPOINT_STATUS_HALT:
        TEST_TRAP();
        break;
    }        
}        


MP_ENDPOINT_STATUS
OHCI_GetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )    
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHCD_ENDPOINT_DESCRIPTOR ed;
    PHC_OPERATIONAL_REGISTER hc;
    MP_ENDPOINT_STATUS status = ENDPOINT_STATUS_RUN;
    
    ed = EndpointData->HcdEd;

    if ((ed->HwED.HeadP & HcEDHeadP_HALT) && 
        !TEST_FLAG(ed->EdFlags, EDFLAG_NOHALT)) {
        status = ENDPOINT_STATUS_HALT; 
    }        

    return status;        
}        


VOID
OHCI_SetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATE State
    )    
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHCD_ENDPOINT_DESCRIPTOR ed;
    PHC_OPERATIONAL_REGISTER hc;
    
    ed = EndpointData->HcdEd;
    
    switch(State) {
    case ENDPOINT_ACTIVE:
        // clear the skip bit
        ed->HwED.sKip = 0;
        // if its bulk or control set the 
        // 'list filled' bits
        OHCI_EnableList(DeviceData, EndpointData);        
        break;
        
    case ENDPOINT_PAUSE:
        ed->HwED.sKip = 1;
        break;
        
    case ENDPOINT_REMOVE:
        
        SET_FLAG(ed->EdFlags, EDFLAG_REMOVED);
        ed->HwED.sKip = 1;
        // free the bw
        EndpointData->StaticEd->AllocatedBandwidth -= 
            EndpointData->Parameters.Bandwidth;
            
        OHCI_RemoveEndpointFromSchedule(DeviceData,
                                        EndpointData);

        break;            
        
    default:        
        TEST_TRAP();
    }        
}    


VOID
OHCI_SetEndpointDataToggle(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     ULONG Toggle
    )     
/*++

Routine Description:

Arguments:

    Toggle is 0 or 1

Return Value:

--*/
{ 
    PHCD_ENDPOINT_DESCRIPTOR ed;

    ed = EndpointData->HcdEd;

    if (Toggle == 0) {
        ed->HwED.HeadP &= ~HcEDHeadP_CARRY;
    } else {
        ed->HwED.HeadP |= HcEDHeadP_CARRY; 
    }

    // we should get here unless we are paused or halted or 
    // we have no tranfsers
    OHCI_ASSERT(DeviceData, (ed->HwED.sKip == 1) ||
                            (ed->HwED.HeadP & HcEDHeadP_HALT) || 
                            ((ed->HwED.HeadP & ~HcEDHeadP_FLAGS) == ed->HwED.TailP));
                            
    LOGENTRY(DeviceData, G, '_stg', EndpointData, 0, Toggle); 
}


MP_ENDPOINT_STATE
OHCI_GetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )     
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHCD_ENDPOINT_DESCRIPTOR ed;
    MP_ENDPOINT_STATE state = ENDPOINT_ACTIVE;

    ed = EndpointData->HcdEd;

    if (TEST_FLAG(ed->EdFlags, EDFLAG_REMOVED)) {
        state = ENDPOINT_REMOVE;        
        goto OHCI_GetEndpointState_Done;
    }
    
    if (ed->HwED.sKip == 1) {
        state = ENDPOINT_PAUSE; 
        goto OHCI_GetEndpointState_Done;
    }

OHCI_GetEndpointState_Done:

    LOGENTRY(DeviceData, G, '_eps', EndpointData, 0, state); 
    
    return state;
}


#if 0
VOID
USBMPFN
OHCI_SendGoatPacket(
     PDEVICE_DATA DeviceData,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress
     COMPLETION ROUTINE
    )
/*++

Routine Description:

    Transmit the 'magic' iso packet.

    This is a fire and forget API so 

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    PHW_TRANSFER_DESCRIPTOR hwTD;

    // hang a special ISO td of the static is ED 
    pch = WorkspaceVirtualAddress;
    phys = WorkspacePhysicalAddress;

    hwTD = pch;
    hwTDPhys = phys;

    pch += xxx;
    phys += xxx 

    goatData = pch;
    goatDataPhys = phys;

    pch += sizeof(USB_GOAT_DATA);
    phys += sizeof(USB_GOAT_DATA);
    
    // initialize the goat packet

    strcpy(goatData, USB_GOAT_DATA, 
    
    hwTD->NextTD = 0;    
    hwTD->CBP = goatDataPhys;
    hwTD->BE = dataPhys+sizeof(USB_GOAT_DATA)-1;
    hwTD->ConditionCode = HcCC_NotAccessed;
    hwTD->ErrorCount = 0;
    hwTD->IntDelay = HcTDIntDelay_0ms;
    hwTD->ShortXferOk = 0;
    
    hwTD->Isochrinous = 1;
    hwTD->FrameCount = 0;
    hwTD->StartFrameNumber = xxx;

    // hang the TD on the static ISO ED

    // clear the skip bit
}
#endif

USB_MINIPORT_STATUS
USBMPFN
OHCI_StartSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

    insert structures to transmit a single packet -- this is for debug
    tool purposes only so we can be a little creative here.

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    PUCHAR pch;
    PHW_ENDPOINT_DESCRIPTOR hwED;
    ULONG hwEDPhys, phys;
    PHW_TRANSFER_DESCRIPTOR hwTD, hwDummyTD;
    ULONG hwTDPhys, hwDummyTDPhys, dataPhys; 
    PUCHAR data;
    PHC_STATIC_ED_DATA staticControlEd;
    ULONG i;
    PSS_PACKET_CONTEXT context;

    staticControlEd = &DeviceData->StaticEDList[ED_CONTROL];
    hc = DeviceData->HC;

    // allocate an ED & TD from the scratch space and initialize it
    phys = WorkspacePhysicalAddress;
    pch = WorkspaceVirtualAddress;

    LOGENTRY(DeviceData, G, '_ssS', phys, 0, pch); 

    context = (PSS_PACKET_CONTEXT) pch;
    pch += sizeof(SS_PACKET_CONTEXT);
    phys += sizeof(SS_PACKET_CONTEXT);
  

    // carve out an ED
    hwEDPhys = phys;
    hwED = (PHW_ENDPOINT_DESCRIPTOR) pch;
    pch += sizeof(HW_ENDPOINT_DESCRIPTOR);
    phys += sizeof(HW_ENDPOINT_DESCRIPTOR);

    // carve out a TD
    hwTDPhys = phys;
    hwTD = (PHW_TRANSFER_DESCRIPTOR) pch;
    pch += sizeof(HW_TRANSFER_DESCRIPTOR);
    phys += sizeof(HW_TRANSFER_DESCRIPTOR);

    // carve out a dummy TD
    hwDummyTDPhys = phys;
    hwDummyTD = (PHW_TRANSFER_DESCRIPTOR) pch;
    pch += sizeof(HW_TRANSFER_DESCRIPTOR);
    phys += sizeof(HW_TRANSFER_DESCRIPTOR);
        
    // use the rest for data
    LOGENTRY(DeviceData, G, '_ssD', PacketData, *PacketLength, 0); 

    dataPhys = phys;
    data = pch;
    RtlCopyMemory(data, PacketData, *PacketLength);
    pch+=*PacketLength;
    phys+=*PacketLength;

    // init the hw ed descriptor
    hwED->NextED = 0;
    hwED->FunctionAddress = PacketParameters->DeviceAddress;
    hwED->EndpointNumber = PacketParameters->EndpointAddress;
    hwED->sKip = 0;
    hwED->Direction = HcEDDirection_Defer;
    switch (PacketParameters->Speed) {
    case ss_Low:
        hwED->LowSpeed = 1;
        break;            
    default:        
        hwED->LowSpeed = 0;
    }        
    hwED->MaxPacket = PacketParameters->MaximumPacketSize;
    hwED->HeadP = hwTDPhys;
    hwED->TailP = hwDummyTDPhys;

    // init the TD for this packet
    hwTD->NextTD = hwDummyTDPhys;    
    hwTD->Asy.ConditionCode = HcCC_NotAccessed;
    hwTD->Asy.ErrorCount = 0;
    hwTD->Asy.IntDelay = HcTDIntDelay_0ms;
    hwTD->Asy.ShortXferOk = 1;
    
    if (0 == *PacketLength) {
        hwTD->CBP = 0;
        hwTD->BE = 0;
    }
    else {
       hwTD->CBP = dataPhys;
       hwTD->BE = dataPhys+*PacketLength-1;
    }

    // init the dummy TD
    hwDummyTD->NextTD = 0;
    hwDummyTD->CBP = 0xFFFFFFFF;

    LOGENTRY(DeviceData, G, '_ss2', hwTD, context, hwED); 
    LOGENTRY(DeviceData, G, '_ss3', dataPhys, data, *PacketLength); 

    switch(PacketParameters->Type) {
    case ss_Setup:
        LOGENTRY(DeviceData, G, '_sSU', 0, 0, 0); 
        hwED->Direction = HcEDDirection_Defer;   
        hwED->Isochronous = 0;
        hwTD->Asy.Direction = HcTDDirection_Setup;
        hwTD->Asy.Isochronous = 0;
        break;
    case ss_In: 
        LOGENTRY(DeviceData, G, '_ssI', 0, 0, 0); 
        hwED->Direction = HcEDDirection_Defer;   
        hwED->Isochronous = 0;
        hwTD->Asy.Direction = HcTDDirection_In;
        hwTD->Asy.Isochronous = 0;
        break;
    case ss_Out:
        LOGENTRY(DeviceData, G, '_ssO', 0, 0, 0); 
        hwED->Direction = HcEDDirection_Defer;   
        hwED->Isochronous = 0;
        hwTD->Asy.Direction = HcTDDirection_Out;
        hwTD->Asy.Isochronous = 0;
        break;
    case ss_Iso_In:
        break;
    case ss_Iso_Out:       
        break;
    }

    switch(PacketParameters->Toggle) {
    case ss_Toggle0:
        hwTD->Asy.Toggle = HcTDToggle_Data0; 
        break;
    case ss_Toggle1:
        hwTD->Asy.Toggle = HcTDToggle_Data1; 
        break;
    }        

    //TEST_TRAP();
    
    //
    // Replace the control ED in the list with the ED just created.  
    // Save the old value of both the control and bulk lists so 
    //  they can be replaced when this transfer is complete.
    //
    // NOTE: This will interrupt normal bus operation for at least one ms

    context->PhysHold = READ_REGISTER_ULONG(staticControlEd->PhysicalHead);    
    HW_DATA_PTR(context->Data) = data;
    HW_TRANSFER_DESCRIPTOR_PTR(context->Td) = hwTD;
    
    WRITE_REGISTER_ULONG(staticControlEd->PhysicalHead, hwEDPhys);    
    
    //
    // Enable the control list and disable the bulk list.  Disabling the 
    //  bulk list temporarily will allow the single step transaction to
    //  complete without interfering with bulk data.  In this manner, the
    //  bulk data INs and OUTs can be sent without interfering with bulk
    //  devices currently on the bus.  
    //
    //  NOTE: I think attempting to use this feature without first disabling
    //          the root hub could lead to some problems.  
    //
    
    WRITE_REGISTER_ULONG(&hc->HcCommandStatus.ul, HcCmd_ControlListFilled);
              
    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
USBMPFN
OHCI_EndSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    PUCHAR pch;
    PSS_PACKET_CONTEXT context;
    PHC_STATIC_ED_DATA staticControlEd;
    PHC_STATIC_ED_DATA staticBulkEd;
    ULONG currentBulkEd;

    PHW_TRANSFER_DESCRIPTOR hwTd;
    PUCHAR data;
    ULONG  listFilled;

    staticControlEd = &DeviceData->StaticEDList[ED_CONTROL];
    staticBulkEd    = &DeviceData->StaticEDList[ED_BULK];

    hc = DeviceData->HC;
    context = (PSS_PACKET_CONTEXT) WorkspaceVirtualAddress;
    hwTd = HW_TRANSFER_DESCRIPTOR_PTR(context->Td);
    data = HW_DATA_PTR(context->Data);

    LOGENTRY(DeviceData, G, '_ssE', hwTd, 0, 0); 

    //TEST_TRAP();

    // compute bytes transferred 
    if (hwTd->CBP) {
        // we never have pagebreaks in the single step TD
        *PacketLength = *PacketLength - ((hwTd->BE & OHCI_PAGE_SIZE_MASK) - 
                          (hwTd->CBP & OHCI_PAGE_SIZE_MASK)+1);          
    } 
         
    // return any errors
    if (hwTd->Asy.ConditionCode == HcCC_NoError) {
        *UsbdStatus = USBD_STATUS_SUCCESS;
    } else {
        *UsbdStatus =
                (hwTd->Asy.ConditionCode | 0xC0000000);
    }                

    LOGENTRY(DeviceData, G, '_ssX', hwTd, *PacketLength, 0); 
    
    RtlCopyMemory(PacketData,
                  data,
                  *PacketLength);
                  
    //
    // Restore the previous control structure and enable the control and
    //  bulk lists if they are non-NULL (ie. point to valid EDs.)
    //
          
    listFilled = 0;

    WRITE_REGISTER_ULONG(staticControlEd->PhysicalHead, context->PhysHold); 
    if (context->PhysHold) {
        listFilled |= HcCmd_ControlListFilled;
    }

    currentBulkEd = READ_REGISTER_ULONG(staticBulkEd->PhysicalHead);
    if (currentBulkEd) {
        listFilled |= HcCmd_BulkListFilled;
    }

    WRITE_REGISTER_ULONG(&hc->HcCommandStatus.ul, listFilled);

    return USBMP_STATUS_SUCCESS;
}

VOID
OHCI_SuspendController(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hc;
    HC_CONTROL control;
    
    hc = DeviceData->HC;

    // mask off interrupts that are not appropriate
    WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 0xFFFFffff);    

    // flush any rogue status
    WRITE_REGISTER_ULONG(&hc->HcInterruptStatus, 0xFFFFffff);    

    // put the controller in 'suspend'
    
    control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
    control.HostControllerFunctionalState = HcHCFS_USBSuspend;
    control.RemoteWakeupEnable = 1;

    WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);

        
    // enable the resume interrupt
    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable,
                         HcInt_MasterInterruptEnable |
                         HcInt_RootHubStatusChange | 
                         HcInt_ResumeDetected | 
                         HcInt_UnrecoverableError);
}


USB_MINIPORT_STATUS
OHCI_ResumeController(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    reverse what was done in 'suspend'

Arguments:

Return Value:

    None

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    HC_CONTROL control;
     
    hc = DeviceData->HC;
    
    // is some cases the BIOS trashes the state of the controller,
    // even though we enter suspend.  
    // This is usually platform specific and indicates a broken BIOS
    control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
    if (control.HostControllerFunctionalState == HcHCFS_USBReset) {

        return USBMP_STATUS_HARDWARE_FAILURE;
        
    } else {
    
        // When the HC is in the operational state, HccaPad1 should be set to
        // zero every time the HC updates HccaFrameNumer.  Preset HccaPad1 to
        // zero before entering the operational state.  OHCI_CheckController()
        // should always find a zero value in HccaPad1 when the HC is in the
        // operational state.
        // 
        DeviceData->HcHCCA->HccaPad1 = 0;

        // put the controller in 'operational' state 
    
        control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
        control.HostControllerFunctionalState = HcHCFS_USBOperational;
        
        WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);
    }
    
    // re-enable interrupts
    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable,
                         HcInt_OwnershipChange |
                         HcInt_SchedulingOverrun |
                         HcInt_WritebackDoneHead |
                         HcInt_FrameNumberOverflow |
                         HcInt_UnrecoverableError);

    WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);

    return USBMP_STATUS_SUCCESS;
}


VOID
OHCI_Unload(
     PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

Arguments:

    DriverObject - pointer to a driver object

Return Value:

    None

--*/
{
    // provide an unload routine 

    // we do this just to test the port driver
}


BOOLEAN
OHCI_HardwarePresent(
    PDEVICE_DATA DeviceData,
    BOOLEAN Notify
    )
{
    ULONG tmp;
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;

    tmp = READ_REGISTER_ULONG(&hc->HcCommandStatus.ul);

    if (tmp == 0xffffffff) {
        if (Notify) {
            USBPORT_INVALIDATE_CONTROLLER(DeviceData, UsbMpControllerRemoved);
        }            
        return FALSE;
    }

    return TRUE;
}


VOID
OHCI_CheckController(
    PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER    hc;
    ULONG                       currentDeadmanFrame;
    ULONG                       lastDeadmanFrame;
    ULONG                       frameDelta;

    hc = DeviceData->HC;

    // First make sure it looks like the hardware is still present.  (This
    // will call USBPORT_INVALIDATE_CONTROLLER() if it looks like the hardware
    // is no longer present).
    //
    if (!OHCI_HardwarePresent(DeviceData, TRUE)) {
        return;
    }

    // Don't check any further if the controller is not currently in the
    // operational state.
    //
    if ((READ_REGISTER_ULONG(&hc->HcControl.ul) & HcCtrl_HCFS_MASK) !=
        HcCtrl_HCFS_USBOperational) {
        return;
    }

    // Don't check any further if we already checked once this frame (or in
    // the last few frames).
    //
    currentDeadmanFrame = READ_REGISTER_ULONG(&hc->HcFmNumber);

    lastDeadmanFrame = DeviceData->LastDeadmanFrame;

    frameDelta = (currentDeadmanFrame - lastDeadmanFrame) & HcFmNumber_MASK;

    // Might HcFmNumber erroneously read back as zero under some conditions
    // on some chipsets?  Don't check any further if HcFmNumber is zero,
    // just check later next time around.
    //
    if (currentDeadmanFrame && (frameDelta >= 5)) {

        DeviceData->LastDeadmanFrame = currentDeadmanFrame;

        switch (DeviceData->HcHCCA->HccaPad1)
        {
            case 0:
                //
                // When the HC updates HccaFrameNumber, it is supposed
                // to set HccaPad1 to zero, so this is the expected case.
                // Here we set HccaPad1 to a non-zero value to try to
                // detect situations when the HC is no longer functioning
                // correctly and accessing and updating host memory.
                //
                DeviceData->HcHCCA->HccaPad1 = 0xBAD1;

                break;

            case 0xBAD1:
                //
                // Apparently the HC has not updated the HCCA since the
                // last time the DPC ran.  This is probably not good.
                //
                DeviceData->HcHCCA->HccaPad1 = 0xBAD2;

                LOGENTRY(DeviceData, G, '_BD2', DeviceData,
                         lastDeadmanFrame,
                         currentDeadmanFrame);

                LOGENTRY(DeviceData, G, '_bd2', DeviceData,
                         DeviceData->HcHCCA->HccaFrameNumber,
                         frameDelta);

                break;

            case 0xBAD2:
                //
                // Apparently the HC has not updated the HCCA since the
                // last two times the DPC ran.  This looks even worse.
                // Assume the HC has become wedged.
                //
                DeviceData->HcHCCA->HccaPad1 = 0xBAD3;

                LOGENTRY(DeviceData, G, '_BD3', DeviceData,
                         lastDeadmanFrame,
                         currentDeadmanFrame);

                LOGENTRY(DeviceData, G, '_bd3', DeviceData,
                         DeviceData->HcHCCA->HccaFrameNumber,
                         frameDelta);

                OHCI_KdPrint((DeviceData, 0,
                              "*** Warning: OHCI HC %08X appears to be wedged!\n",
                              DeviceData));

                // Tell USBPORT to please reset the controller.
                //
                USBPORT_INVALIDATE_CONTROLLER(DeviceData,
                                              UsbMpControllerNeedsHwReset);

                break;

            case 0xBAD3:
                break;

            default:
                // Should not hit this case.
                TEST_TRAP();
                break;
        }
    }
}


VOID
OHCI_ResetController(
    PDEVICE_DATA DeviceData
    )
/*++
    Attempt to resurrect the HC after we have determined that it is dead.
--*/
{
    PHC_OPERATIONAL_REGISTER    HC;
    ULONG                       HccaFrameNumber;
    ULONG                       HcControl;
    ULONG                       HcHCCA;
    ULONG                       HcControlHeadED;
    ULONG                       HcBulkHeadED;
    ULONG                       HcFmInterval;
    ULONG                       HcPeriodicStart;
    ULONG                       HcLSThreshold;
    HC_RH_DESCRIPTOR_A          descrA;
    ULONG                       port;

    LOGENTRY(DeviceData, G, '_RHC', 0, 0, 0);

    //
    // Get the pointer to the HC Operational Registers
    //

    HC = DeviceData->HC;

    //
    // Save the last FrameNumber from the HCCA from when the HC froze
    //

    HccaFrameNumber = DeviceData->HcHCCA->HccaFrameNumber;

    //
    // Save current HC operational register values
    //

    // offset 0x04, save HcControl
    //
    HcControl       = READ_REGISTER_ULONG(&HC->HcControl.ul);

    // offset 0x18, save HcHCCA
    //
    HcHCCA          = READ_REGISTER_ULONG(&HC->HcHCCA);

    // offset 0x20, save HcControlHeadED
    //
    HcControlHeadED = READ_REGISTER_ULONG(&HC->HcControlHeadED);

    // offset 0x28, save HcBulkHeadED
    //
    HcBulkHeadED    = READ_REGISTER_ULONG(&HC->HcBulkHeadED);

    // offset 0x34, save HcFmInterval
    //
    HcFmInterval    = READ_REGISTER_ULONG(&HC->HcFmInterval.ul);

    // offset 0x40, save HcPeriodicStart
    //
    HcPeriodicStart = READ_REGISTER_ULONG(&HC->HcPeriodicStart);

    // offset 0x44, save HcLSThreshold
    //
    HcLSThreshold   = READ_REGISTER_ULONG(&HC->HcLSThreshold);


    //
    // Reset the host controller
    //
    WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, HcCmd_HostControllerReset);
    KeStallExecutionProcessor(10);


    //
    // Restore / reinitialize HC operational register values
    //

    // offset 0x08, HcCommandStatus is set to zero on reset

    // offset 0x0C, HcInterruptStatus is set to zero on reset

    // offset 0x10, HcInterruptEnable is set to zero on reset

    // offset 0x14, HcInterruptDisable is set to zero on reset

    // offset 0x18, restore HcHCCA
    //
    WRITE_REGISTER_ULONG(&HC->HcHCCA,           HcHCCA);

    // offset 0x1C, HcPeriodCurrentED is set to zero on reset

    // offset 0x20, restore HcControlHeadED
    //
    WRITE_REGISTER_ULONG(&HC->HcControlHeadED,  HcControlHeadED);

    // offset 0x24, HcControlCurrentED is set to zero on reset

    // offset 0x28, restore HcBulkHeadED
    //
    WRITE_REGISTER_ULONG(&HC->HcBulkHeadED,     HcBulkHeadED);

    // offset 0x2C, HcBulkCurrentED is set to zero on reset

    // offset 0x30, HcDoneHead is set to zero on reset


    // It appears that writes to HcFmInterval don't stick unless the HC
    // is in the operational state.  Set the HC into the operational
    // state at this point, but don't enable any list processing yet
    // by setting any of the BLE, CLE, IE, or PLE bits.
    //
    WRITE_REGISTER_ULONG(&HC->HcControl.ul, HcCtrl_HCFS_USBOperational);


    // offset 0x34, restore HcFmInterval
    //
    WRITE_REGISTER_ULONG(&HC->HcFmInterval.ul,
                         HcFmInterval | HcFmI_FRAME_INTERVAL_TOGGLE);

    // offset 0x38, HcFmRemaining is set to zero on reset

    // offset 0x3C, restore HcFmNumber
    //
    WRITE_REGISTER_ULONG(&HC->HcFmNumber,       HccaFrameNumber);

    // offset 0x40, restore HcPeriodicStart
    //
    WRITE_REGISTER_ULONG(&HC->HcPeriodicStart,  HcPeriodicStart);

    // offset 0x44, restore HcLSThreshold
    //
    WRITE_REGISTER_ULONG(&HC->HcLSThreshold,    HcLSThreshold);

    // Power on downstream ports
    //
    WRITE_REGISTER_ULONG(&HC->HcRhStatus,
                         HcRhS_SetGlobalPower | HcRhS_SetRemoteWakeupEnable);

    descrA.ul = OHCI_ReadRhDescriptorA(DeviceData);
    OHCI_ASSERT(DeviceData, (descrA.ul) && (!(descrA.ul & HcDescA_RESERVED)));

    for (port = 0; port < descrA.s.NumberDownstreamPorts; port++)
    {
        WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[port], HcRhPS_SetPortPower);
    }

    // offset 0x04, restore HcControl
    //
    HcControl &= ~(HcCtrl_HCFS_MASK);
    HcControl |= HcCtrl_HCFS_USBOperational;

    WRITE_REGISTER_ULONG(&HC->HcControl.ul,     HcControl);

    // offset 0x10, restore HcInterruptEnable (just turn everything on!)
    //
    WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                         HcInt_MasterInterruptEnable    |   // 0x80000000
                         HcInt_OwnershipChange          |   // 0x40000000
                         HcInt_RootHubStatusChange      |   // 0x00000040
                         HcInt_FrameNumberOverflow      |   // 0x00000020
                         HcInt_UnrecoverableError       |   // 0x00000010
                         HcInt_ResumeDetected           |   // 0x00000008
                         HcInt_StartOfFrame             |   // 0x00000004
                         HcInt_WritebackDoneHead        |   // 0x00000002
                         HcInt_SchedulingOverrun            // 0x00000001
                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\async.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   async.c

Abstract:

   miniport transfer code for control, bulk and interrupt

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-20-00 : created, jsenior

--*/

#include "pch.h"


//implements the following miniport functions:

// non paged
//UhciInsertQh
//UhciUnlinkQh
//UhciMapAsyncTransferToTds
//UhciQueueTransfer
//UhciControlTransfer
//UhciBulkOrInterruptTransfer
//UhciSetAsyncEndpointState
//UhciProcessDoneAsyncTd
//UhciPollAsyncEndpoint
//UhciAbortAsyncTransfer


VOID
UhciFixDataToggle(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    ULONG Toggle
    )
{
    LOGENTRY(DeviceData, G, '_Fdt', EndpointData, Toggle, 0);

    //
    // Loop through all the remaining TDs for this
    // endpoint and fix the data toggle.
    //
    while (Td) {
        Td->HwTD.Token.DataToggle = Toggle;
        Toggle = !Toggle;
        Td = Td->NextTd;
    }

    EndpointData->Toggle = Toggle;
}


VOID
UhciInsertQh(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR FirstQh,
    IN PHCD_QUEUEHEAD_DESCRIPTOR LinkQh
    )
/*++

Routine Description:

   Insert an aync queue head into the HW list.

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR nextQh;
    QH_LINK_POINTER newLink;

    LOGENTRY(DeviceData, G, '_Ain', 0, FirstQh, LinkQh);
    UHCI_ASSERT(DeviceData, !TEST_FLAG(LinkQh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE));

    // ASYNC QUEUE looks like this:
    //
    //
    //            |- we insert here
    //|static QH|<->|xfer QH|<->|xfer QH|<->
    //     |                              |
    //     ---------------<->--------------

    // link new qh to the current 'head' ie
    // first transfer QH
    nextQh = FirstQh->NextQh;

    LinkQh->HwQH.HLink = FirstQh->HwQH.HLink;
    LinkQh->NextQh = nextQh;
    LinkQh->PrevQh = FirstQh;

    if (nextQh) {
        nextQh->PrevQh = LinkQh;
    } else {

        // This is the last queuehead. I.e. a bulk queuehead.
        UHCI_ASSERT(DeviceData,
                    (LinkQh->HwQH.HLink.HwAddress & ~HW_LINK_FLAGS_MASK) ==
                    DeviceData->BulkQueueHead->PhysicalAddress);
        DeviceData->LastBulkQueueHead = LinkQh;
    }

    // put the new qh at the head of the queue
    newLink.HwAddress = LinkQh->PhysicalAddress;
    newLink.QHTDSelect = 1;
    UHCI_ASSERT(DeviceData, !newLink.Terminate);
    UHCI_ASSERT(DeviceData, !newLink.Reserved);
    FirstQh->HwQH.HLink = newLink;
    FirstQh->NextQh = LinkQh;

    SET_FLAG(LinkQh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE);
}

VOID
UhciUnlinkQh(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR Qh
    )
/*++

Routine Description:

   Remove an async queue head from the HW list.

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR nextQh, prevQh;

    UHCI_ASSERT(DeviceData,
                TEST_FLAG(Qh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE) ||
                ((Qh->PrevQh == Qh) && (Qh->NextQh == Qh)));

    nextQh = Qh->NextQh;
    prevQh = Qh->PrevQh;

    // ASYNC QUEUE looks like this:
    //
    //|static QH|->|xfer QH|->|xfer QH|->
    //     |                            |
    //     -------------<----------------

    //
    // Check if this was the last bulk transfer. If so,
    // turn off the bulk bandwidth reclamation.
    //
    if (DeviceData->LastBulkQueueHead == Qh) {
        DeviceData->LastBulkQueueHead = prevQh;
    }

    // unlink
    LOGENTRY(DeviceData, G, '_Ulk', Qh, prevQh, nextQh);
    prevQh->HwQH.HLink = Qh->HwQH.HLink;
    prevQh->NextQh = nextQh;
    if (nextQh) {
        nextQh->PrevQh = prevQh;
    }

    // Protect ourselves from calling this function twice.
    Qh->NextQh = Qh->PrevQh = Qh;

    //
    // If this was a bulk QH, check if bulk bandwidth reclamation
    // is turned on. If so and there's nothing queued, then turn
    // it off. This is for the case where a device has become
    // unresponsive and the transfer is about to be aborted.
    //
    if (Qh->EndpointData->Parameters.TransferType == Bulk &&
        !DeviceData->LastBulkQueueHead->HwQH.HLink.Terminate) {
        PHCD_QUEUEHEAD_DESCRIPTOR qh;
        BOOLEAN activeBulkTDs = FALSE;

        //
        // This loop skips the td that has been inserted for
        // the PIIX4 problem, since it starts with the qh
        // the bulk queuehead is pointing at.
        // If the bulk queuehead is not pointing at anything,
        // then we're fine too, since it will have been
        // turned off already.
        //
        for (qh = DeviceData->BulkQueueHead->NextQh;
             qh;
             qh = qh->NextQh) {
            if (!qh->HwQH.VLink.Terminate) {
                activeBulkTDs = TRUE;
                break;
            }
        }

        // qh is pointing at either the first queuehead
        // with transfers pending or the bulk queuehead.
        if (!activeBulkTDs) {
            UHCI_ASSERT(DeviceData, !qh)
            DeviceData->LastBulkQueueHead->HwQH.HLink.Terminate = 1;
        }
    }

    CLEAR_FLAG(Qh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE);
}

VOID
UhciQueueTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PHCD_TRANSFER_DESCRIPTOR FirstTd,
    IN PHCD_TRANSFER_DESCRIPTOR LastTd
    )
/*++

Routine Description:

    Links a bunch of TDs into a queuehead.

Arguments:

--*/
{
    UHCI_ASSERT(DeviceData, FirstTd->PhysicalAddress & ~HW_LINK_FLAGS_MASK);
    UHCI_ASSERT(DeviceData, !(FirstTd->PhysicalAddress & HW_LINK_FLAGS_MASK));

    if (EndpointData->HeadTd) {
        PHCD_QUEUEHEAD_DESCRIPTOR qh;
        HW_32BIT_PHYSICAL_ADDRESS curTdPhys;

        // There's other transfer(s) queued. Add this one behind them.
        UHCI_ASSERT(DeviceData, EndpointData->TailTd);
        EndpointData->TailTd->NextTd = FirstTd;
        EndpointData->TailTd->HwTD.LinkPointer.HwAddress =
            FirstTd->PhysicalAddress;

        // Get the qh and current td
        qh = EndpointData->QueueHead;

        curTdPhys = qh->HwQH.VLink.HwAddress & ~HW_LINK_FLAGS_MASK;

        // If there is nothing on this queuehead, then we may have been
        // unsuccessful in queueing the transfer. Checking the active
        // bit on the td will tell us for sure.

        LOGENTRY(DeviceData, G, '_tqa', FirstTd, curTdPhys,
                 FirstTd->HwTD.Control.Active);

        LOGENTRY(DeviceData, G, '_ttd', EndpointData->TailTd,
                 EndpointData->TailTd->PhysicalAddress,
                 EndpointData->TailTd->HwTD.Control.Active);

        if (FirstTd->HwTD.Control.Active) {
            if ((curTdPhys == EndpointData->TailTd->PhysicalAddress &&
                 !EndpointData->TailTd->HwTD.Control.Active)) {
                TD_LINK_POINTER newLink;

                // Since the prior transfer had already completed when
                // we tried to queue the transfer, we need to add this td
                // directly into the hardware queuehead.

                // Note that the HC could be in the middle of updating the
                // queuehead's link pointer. That's what the second part of
                // the if statement above is for.

                // DO NOT call LOGENTRY until we set the queuehead!
                // This would cause a delay that might be bad.

                newLink.HwAddress = FirstTd->PhysicalAddress;
                newLink.Terminate = 0;
                newLink.QHTDSelect = 0;
                qh->HwQH.VLink = newLink;
                LOGENTRY(DeviceData, G, '_nlk', FirstTd, EndpointData,
                         EndpointData->HeadTd);
            }
        }

    } else {

        // There's no other transfers queued currently.
        SET_QH_TD(DeviceData, EndpointData, FirstTd);
    }
    if (EndpointData->Parameters.TransferType == Bulk) {

        // Turn bulk bandwidth reclamation back on.
        DeviceData->LastBulkQueueHead->HwQH.HLink.Terminate = 0;
    }
    EndpointData->TailTd = LastTd;
}

ULONG
UhciMapAsyncTransferToTds(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext,
    PHCD_TRANSFER_DESCRIPTOR *FirstDataTd,
    PHCD_TRANSFER_DESCRIPTOR *LastDataTd,
    PTRANSFER_SG_LIST SgList
    )
/*++

Routine Description:

    Maps an asynchronous transfer into the TDs
    required to complete the transfer, including
    any double buffering necessary for page boundaries.

Arguments:

Return Value:

--*/
{
    // indices and offsets
    ULONG sgIdx, sgOffset, i;
    // lengths
    ULONG lengthThisTd, bytesRemaining, mappedNextSg, lengthMapped = 0;
    USHORT maxPacketSize = EndpointData->Parameters.MaxPacketSize;
    // structure pointers
    PTRANSFER_PARAMETERS tp = TransferContext->TransferParameters;
    PASYNC_TRANSFER_BUFFER buffer = NULL;
    PHCD_TRANSFER_DESCRIPTOR lastTd = NULL, td;
    HW_32BIT_PHYSICAL_ADDRESS address;
    UCHAR pid;

    ULONG toggle;
    BOOLEAN pageCrossing = FALSE;
    BOOLEAN ZeroLengthTransfer = (SgList->SgCount == 0 &&
                                  EndpointData->Parameters.TransferType != Control);

    if (EndpointData->Parameters.TransferType == Control) {

        // Control pipes are bi-directional. Get the direction from the
        // transfer parameters.
        if (TEST_FLAG(tp->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
            pid = InPID;
        } else {
            pid = OutPID;
        }
        // THe setup packet is Toggle 0.
        toggle = DataToggle1;
    } else {

        // All other pipes are uni-directional. Determine
        // the direction from the endpoint address.
        pid = GetPID(EndpointData->Parameters.EndpointAddress);
        // We have to continue the toggle pattern for bulk and interrupt.
        toggle = EndpointData->Toggle;
    }
    // lastTd points to the last data TD or the setup
    // if there was no data.

    for (i = 0; i<SgList->SgCount || ZeroLengthTransfer; i++) {

        LOGENTRY(DeviceData, G, '_sgc', SgList->SgCount, i, 0);

        address = SgList->SgEntry[i].LogicalAddress.Hw32;
        UHCI_ASSERT(DeviceData, address || ZeroLengthTransfer);
        bytesRemaining = SgList->SgEntry[i].Length;
        UHCI_ASSERT(DeviceData, bytesRemaining || ZeroLengthTransfer);

        LOGENTRY(DeviceData, G, '_sgX', SgList->SgEntry[i].Length, i,
            SgList->SgEntry[i].LogicalAddress.Hw32);

        if (pageCrossing) {

            // We have a page crossing here, so this one is double-buffered.
            address += mappedNextSg;
            bytesRemaining -= mappedNextSg;
        }
        mappedNextSg = 0;
        pageCrossing = FALSE;
        while (bytesRemaining || ZeroLengthTransfer) {
            ZeroLengthTransfer = FALSE;
            LOGENTRY(DeviceData, G, '_sg1', bytesRemaining, 0, 0);
            if (bytesRemaining < maxPacketSize) {
                if (i+1 < SgList->SgCount) {

                    // We have to double buffer this TD since it crosses a page
                    // boundary. We will always cross a page boundary now.
                    LOGENTRY(DeviceData, G, '_sg2', bytesRemaining, 0, 0);
                    pageCrossing = TRUE;
                    if (SgList->SgEntry[i+1].Length + bytesRemaining >= maxPacketSize) {
                        mappedNextSg = maxPacketSize - bytesRemaining;
                        lengthThisTd = maxPacketSize;
                    } else {
                        lengthThisTd = SgList->SgEntry[i+1].Length + bytesRemaining;
                        mappedNextSg = SgList->SgEntry[i+1].Length;
                    }

                    buffer = (PASYNC_TRANSFER_BUFFER)
                                UHCI_ALLOC_DB(DeviceData, EndpointData, FALSE);
                    UHCI_ASSERT(DeviceData, buffer);
                    UHCI_ASSERT(DeviceData, buffer->Sig == SIG_HCD_ADB);
                    UHCI_ASSERT(DeviceData, buffer->PhysicalAddress);
                    buffer->SystemAddress = SgList->MdlSystemAddress + lengthMapped;
                    UhciKdPrint((DeviceData, 2, "'Double buffer %x address %x offset %x\n", buffer, buffer->SystemAddress, lengthMapped));
                    buffer->Size = lengthThisTd;
                    UHCI_ASSERT(DeviceData, lengthThisTd <= MAX_ASYNC_PACKET_SIZE);
                    if (OutPID == pid) {
                        RtlCopyMemory(&buffer->Buffer[0],
                                      buffer->SystemAddress,
                                      lengthThisTd);
                    }
                    // Change the address for the TD
                    address = buffer->PhysicalAddress;
                    bytesRemaining = 0;
                } else {

                    // Last TD
                    LOGENTRY(DeviceData, G, '_sg3', bytesRemaining, 0, 0);
                    lengthThisTd = bytesRemaining;
                    bytesRemaining = 0;
                }
            } else {

                // Normal, non-buffered case.
                LOGENTRY(DeviceData, G, '_sg4', bytesRemaining, 0, 0);
                lengthThisTd = maxPacketSize;
                bytesRemaining -= lengthThisTd;

                UHCI_ASSERT(DeviceData, lengthThisTd <= SgList->SgEntry[i].Length);
            }

            TransferContext->PendingTds++;

            //
            // Allocate and initialize an async TD
            //
            td = UHCI_ALLOC_TD(DeviceData, EndpointData);
            INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

            td->HwTD.Token.Pid = pid;
            td->HwTD.Token.MaximumLength = MAXIMUM_LENGTH(lengthThisTd);
            td->HwTD.Token.DataToggle = toggle;
            td->HwTD.Control.ShortPacketDetect = 1;
            td->HwTD.Control.ActualLength = MAXIMUM_LENGTH(0);
            td->HwTD.Buffer = address;
            if (pageCrossing) {
                SET_FLAG(td->Flags, TD_FLAG_DOUBLE_BUFFERED);
                td->DoubleBuffer = (PTRANSFER_BUFFER) buffer;
            }

            address += lengthThisTd;
            lengthMapped += lengthThisTd;

            if (lastTd) {
                SET_NEXT_TD(lastTd, td);
            } else {
                *FirstDataTd = td;
            }
            lastTd = td;
            toggle = !toggle;
        } // while
    }

    *LastDataTd = lastTd;
    EndpointData->Toggle = toggle;

    UHCI_ASSERT(DeviceData, TransferContext->TransferParameters->TransferBufferLength == lengthMapped);

    return lengthMapped;
}

USB_MINIPORT_STATUS
UhciControlTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    )
/*++

Routine Description:

    Initialize a control transfer

Arguments:


--*/
{
    PHCD_TRANSFER_DESCRIPTOR lastDataTd, firstDataTd, setupTd, statusTd;
    PASYNC_TRANSFER_BUFFER setupPacket;
    ULONG lengthMapped, dataTDCount = 0;

    // we have enough tds, program the transfer

    UhciKdPrint((DeviceData, 2, "'Control transfer on EP %x\n", EndpointData));

    LOGENTRY(DeviceData, G, '_CTR', EndpointData, TransferParameters, TransferContext);

    // bugbug should check here in advance to see if there enough
    // TDs if so proceed otherwise return status_busy.
    if (EndpointData->PendingTransfers > 1) {
        DecPendingTransfers(DeviceData, EndpointData);
        return USBMP_STATUS_BUSY;
    }

    // First prepare a TD for the setup packet. Grab the dummy TD from
    // the tail of the queue.
    TransferContext->PendingTds++;
    setupTd = UHCI_ALLOC_TD(DeviceData, EndpointData);
    INITIALIZE_TD_FOR_TRANSFER(setupTd, TransferContext);

    // Move setup data into TD (8 chars long).
    // We use a double buffer for this.
    setupTd->DoubleBuffer = UHCI_ALLOC_DB(DeviceData, EndpointData, FALSE);
    setupPacket = (PASYNC_TRANSFER_BUFFER) setupTd->DoubleBuffer;
    RtlCopyMemory(&setupPacket->Buffer[0],
                  &TransferParameters->SetupPacket[0],
                  8);
    setupTd->HwTD.Buffer = setupPacket->PhysicalAddress;
    SET_FLAG(setupTd->Flags, TD_FLAG_DOUBLE_BUFFERED);

    setupTd->HwTD.Token.MaximumLength = MAXIMUM_LENGTH(8);
    setupTd->HwTD.Token.Pid = SetupPID;
    // setup stage is always toggle 0
    setupTd->HwTD.Token.DataToggle = DataToggle0;

    LOGENTRY(DeviceData,
             G, '_set',
             setupTd,
             *((PLONG) &TransferParameters->SetupPacket[0]),
             *((PLONG) &TransferParameters->SetupPacket[4]));

    // allocate the status phase TD now so we can
    // point the data TDs to it
    TransferContext->PendingTds++;
    statusTd = UHCI_ALLOC_TD(DeviceData, EndpointData);
    INITIALIZE_TD_FOR_TRANSFER(statusTd, TransferContext);

    // now setup the data phase
    lastDataTd = firstDataTd = NULL;
    lengthMapped =
        UhciMapAsyncTransferToTds(DeviceData,
                                  EndpointData,
                                  TransferContext,
                                  &firstDataTd,
                                  &lastDataTd,
                                  TransferSGList);

    if (firstDataTd && firstDataTd) {

        // Join the setup to the front and the status to the end.
        SET_NEXT_TD(setupTd, firstDataTd);
        SET_NEXT_TD(lastDataTd, statusTd);
    } else {

        // Join the setup to the status. No data stage.
        SET_NEXT_TD(setupTd, statusTd);
    }

    // now do the status phase

    // no bufferQueueHead
    statusTd->HwTD.Buffer = 0;
    statusTd->HwTD.Token.MaximumLength = MAXIMUM_LENGTH(0);
    // status stage is always toggle 1
    statusTd->HwTD.Token.DataToggle = DataToggle1;
    statusTd->HwTD.Control.InterruptOnComplete = 1;
    SET_FLAG(statusTd->Flags, TD_FLAG_STATUS_TD);

    // status phase is opposite data dirrection
    if (TEST_FLAG(TransferParameters->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
        statusTd->HwTD.Token.Pid = OutPID;
    } else {
        statusTd->HwTD.Token.Pid = InPID;
    }

    SET_NEXT_TD_NULL(statusTd);

    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, setupTd->PhysicalAddress, setupTd);

    // Attach the setup TD to the queuehead
    UhciQueueTransfer(DeviceData, EndpointData, setupTd, statusTd);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
UhciBulkOrInterruptTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    )
/*++

Routine Description:

    Initialize interrupt or bulk Transfer

Arguments:


--*/
{
    PHCD_TRANSFER_DESCRIPTOR firstTd, lastTd;
    ULONG lengthMapped;
    ULONG maxPacketSize = EndpointData->Parameters.MaxPacketSize;
    ULONG i, numTds;

    UhciKdPrint((DeviceData, 2, "'BIT transfer on EP %x\n", EndpointData));
    UhciKdPrint((DeviceData, 2, "'BIT transfer length %d\n",
        TransferParameters->TransferBufferLength));

    LOGENTRY(DeviceData, G, '_BIT', EndpointData, TransferParameters, TransferContext);

    // Do we have enough free resources?
    for (i = 0, lengthMapped = 0; i < TransferSGList->SgCount; i++) {
        lengthMapped += TransferSGList->SgEntry[i].Length;
    }
    numTds = lengthMapped == 0 ? 1 :
        (lengthMapped + maxPacketSize - 1) / maxPacketSize;
    if (EndpointData->TdCount - EndpointData->TdsUsed < numTds) {

        // Not enough TDs to do this transfer yet.
        // Tell the port driver to wait.
        UhciKdPrint((DeviceData, 2, "'BIT must wait on EP %x. Not enough tds.\n", EndpointData));
        return USBMP_STATUS_BUSY;
    }
    if (TransferSGList->SgCount > 1 &&
        TransferSGList->SgEntry[0].Length % maxPacketSize != 0) {

        // We'll need DBs. Do we have enough?
        if (EndpointData->DbCount - EndpointData->DbsUsed <
            (lengthMapped + PAGE_SIZE - 1)/PAGE_SIZE) {

            // Not enough DBs to do this transfer yet.
            // Tell the port driver to wait.
            UhciKdPrint((DeviceData, 2, "'BIT must wait on EP %x. Not enough dbs.\n", EndpointData));
            return USBMP_STATUS_BUSY;
        }
    }

    // we have enough tds, program the transfer
    // now setup the data phase
    lastTd = firstTd = NULL;
    lengthMapped =
        UhciMapAsyncTransferToTds(DeviceData,
                                  EndpointData,
                                  TransferContext,
                                  &firstTd,
                                  &lastTd,
                                  TransferSGList);

    UHCI_ASSERT(DeviceData, lastTd && firstTd);

    lastTd->HwTD.Control.InterruptOnComplete = 1;

    SET_NEXT_TD_NULL(lastTd);

    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, firstTd->PhysicalAddress, firstTd);

    // Attach the first TD to the queuehead
    UhciQueueTransfer(DeviceData, EndpointData, firstTd, lastTd);

    return USBMP_STATUS_SUCCESS;
}

VOID
UhciSetAsyncEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ENDPOINT_TRANSFER_TYPE epType;
    ULONG interruptQHIndex;

    LOGENTRY(DeviceData, G, '_Sas', EndpointData, State, 0);

    qh = EndpointData->QueueHead;

    epType = EndpointData->Parameters.TransferType;

    switch(State) {
    case ENDPOINT_ACTIVE:
        switch (epType) {
        case Interrupt:
            // put queue head in the schedule
            interruptQHIndex = EndpointData->Parameters.ScheduleOffset +
                QH_INTERRUPT_INDEX(EndpointData->Parameters.Period);
            UhciInsertQh(DeviceData,
                         DeviceData->InterruptQueueHeads[interruptQHIndex],
                         qh);
            break;
        case Control:
            // put queue head in the schedule
            UhciInsertQh(DeviceData, DeviceData->ControlQueueHead, qh);
            break;
        case Bulk:
            // put queue head in the schedule
            UhciInsertQh(DeviceData, DeviceData->BulkQueueHead, qh);
            break;
        default:
            TEST_TRAP()
            break;
        }
        break;

    case ENDPOINT_PAUSE:
        // remove queue head from the schedule
        switch (epType) {
        case Interrupt:
        case Bulk:
        case Control:
            //
            // Just flip the active bits at this point.
            //
            UhciUnlinkQh(DeviceData, qh);
            break;
        default:
            TEST_TRAP()
            break;
        }
        break;

    case ENDPOINT_REMOVE:
        qh->QhFlags |= UHCI_QH_FLAG_QH_REMOVED;

        switch (epType) {
        case Interrupt:
        case Bulk:
        case Control:
            // remove from the schedule and
            // free bandwidth

            // free the bw
    //        EndpointData->StaticEd->AllocatedBandwidth -=
    //            EndpointData->Parameters.Bandwidth;

            UhciUnlinkQh(DeviceData, qh);
            break;
        default:
            TEST_TRAP();
            break;
        }
        break;

    default:

        TEST_TRAP();
    }
}


VOID
UhciProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
/*++

Routine Description:

    process a completed TD

Parameters

--*/
{
    PTRANSFER_CONTEXT transferContext;
    PENDPOINT_DATA endpointData;
    PTRANSFER_PARAMETERS tp;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    ULONG byteCount;

    transferContext = Td->TransferContext;
    ASSERT_TRANSFER(DeviceData, transferContext);

    tp = transferContext->TransferParameters;
    transferContext->PendingTds--;
    endpointData = transferContext->EndpointData;

    if (TEST_FLAG(Td->Flags, TD_FLAG_SKIP)) {
        LOGENTRY(DeviceData, G, '_Ktd', transferContext,
                         0,
                         Td);

        goto free_it;
    }

    if (TEST_FLAG(endpointData->Flags, UHCI_EDFLAG_HALTED)) {

        // completion status for this TD?
        // since the endpoint halts on error and short packet,
        // the error bits should have been written back to the TD
        // we use these bits to dermine the error
        usbdStatus = UhciGetErrorFromTD(DeviceData,
                                        Td);
    }

    LOGENTRY(DeviceData, G, '_Dtd', transferContext,
                         usbdStatus,
                         Td);

    // Only count the bytes transferred if we were successful (as per uhcd).
    byteCount = (usbdStatus == USBD_STATUS_SUCCESS) ? ACTUAL_LENGTH(Td->HwTD.Control.ActualLength) : 0;

    LOGENTRY(DeviceData, G, '_tln', byteCount, 0, 0);

    if (Td->HwTD.Token.Pid != SetupPID) {

        // data or status phase of a control transfer or a bulk/int
        // data transfer
        LOGENTRY(DeviceData, G, '_Idt', Td, transferContext, byteCount);

        transferContext->BytesTransferred += byteCount;

    }

    // For double buffered transfers, we now have to copy back
    // if this was an IN transfer.
    //
    if (Td->HwTD.Token.Pid == InPID &&
        TEST_FLAG(Td->Flags, TD_FLAG_DOUBLE_BUFFERED)) {
        PASYNC_TRANSFER_BUFFER buffer = &Td->DoubleBuffer->Async;
        UHCI_ASSERT(DeviceData, TEST_FLAG(buffer->Flags, DB_FLAG_BUSY));
        UhciKdPrint((DeviceData, 2, "'Copy back %x address %x\n", buffer, buffer->SystemAddress));
        RtlCopyMemory(buffer->SystemAddress,
                      buffer->Buffer,
                      buffer->Size);

        // tell usbport we double buffered so it can
        // triple buffer if necessary
        USBPORT_NOTIFY_DOUBLEBUFFER(DeviceData,
                                    tp,
                                    buffer->SystemAddress,
                                    buffer->Size);
    }

    // note that we only set transferContext->UsbdStatus
    // if we find a TD with an error this will cause us to
    // record the last TD with an error as the error for
    // the transfer.
    if (USBD_STATUS_SUCCESS != usbdStatus) {

        UhciKdPrint((DeviceData, 2, "'Error, usbdstatus %x", usbdStatus));

        // map the error to code in USBDI.H
        transferContext->UsbdStatus = usbdStatus;

        LOGENTRY(DeviceData, G, '_tER', transferContext->UsbdStatus, 0, 0);
    }

free_it:

    // mark the TD free
    UHCI_FREE_TD(DeviceData, endpointData, Td);

    if (transferContext->PendingTds == 0) {

        // all TDs for this transfer are done
        // clear the HAVE_TRANSFER flag to indicate
        // we can take another
        DecPendingTransfers(DeviceData, endpointData);

        LOGENTRY(DeviceData, G, '_Cat',
            transferContext->UsbdStatus,
            transferContext,
            transferContext->BytesTransferred);

        UhciKdPrint((DeviceData, 2, "'Complete transfer w/ usbdstatus %x\n", transferContext->UsbdStatus));

        USBPORT_COMPLETE_TRANSFER(DeviceData,
                                  endpointData,
                                  tp,
                                  transferContext->UsbdStatus,
                                  transferContext->BytesTransferred);
    }
}


VOID
UhciPollAsyncEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'

    The goal here is to determine which TDs, if any,
    have completed and complete any associated transfers.

Arguments:

Return Value:

--*/
{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_QUEUE_ELEMENT_TD overlay;
    HW_32BIT_PHYSICAL_ADDRESS curTdPhys, tmpPhys;
    ULONG i, j;
    PTRANSFER_CONTEXT transferContext, tmp;
    PTRANSFER_PARAMETERS tp;
    ULONG halted, active;
    BOOLEAN processed;

    if (TEST_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED)) {

        // Endpoint is halted. Don't do anything.
        return;
    }

    //  get the queue head and current td
    qh = EndpointData->QueueHead;

    curTdPhys =  qh->HwQH.VLink.HwAddress;

    curTdPhys &= ~HW_LINK_FLAGS_MASK;

    // now convert the physical 'current' to a virtual address
    currentTd = curTdPhys ? (PHCD_TRANSFER_DESCRIPTOR)
        USBPORT_PHYSICAL_TO_VIRTUAL(curTdPhys,
                                    DeviceData,
                                    EndpointData) :
        (PHCD_TRANSFER_DESCRIPTOR) NULL;

    LOGENTRY(DeviceData, G, '_ctd', curTdPhys, currentTd, EndpointData);

    // walk the TD list up to the current TD and complete
    // all those TDs

    for (td = EndpointData->HeadTd; td != currentTd && td; td = td->NextTd) {
        SET_FLAG(td->Flags, TD_FLAG_DONE);
        InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

        // Is the queuehead pointing to nothing, but there are still
        // tds available to be queued?
        if (td->NextTd &&
            td->NextTd->HwTD.Control.Active) {
            if (!curTdPhys) {
                TD_LINK_POINTER newLink;

                // A transfer didn't make it onto the hardware because
                // the queuehead's td field wasn't set properly
                // in UhciQueueTransfer.

                // PERF NOTE: Because we're not making sure that the
                // transfer gets queued immediately, the transfer could
                // be delayed in making it onto the hardware. Better
                // late than never, though...

                EndpointData->HeadTd = currentTd = td->NextTd;

                LOGENTRY(DeviceData, G, '_Dly', currentTd, curTdPhys, qh);

                goto UhciPollAsyncEndpointSetNext;
            } else if (curTdPhys != td->NextTd->PhysicalAddress) {
                LOGENTRY(DeviceData, G, '_QEr', curTdPhys, td->NextTd->PhysicalAddress, td->NextTd);

                UHCI_ASSERT (DeviceData, FALSE);
            }

        }
    }

    EndpointData->HeadTd = currentTd;

    if (currentTd) {
        LOGENTRY(DeviceData, G, '_cTD', currentTd,
                 curTdPhys,
                 currentTd->TransferContext);

        // If active, get out of here.
        if (currentTd->HwTD.Control.Active) {
            ;// fall thru to completing whatever's completed;
        } else if ((currentTd->HwTD.Token.Pid           == InPID) &&
                   (currentTd->HwTD.Control.Stalled         == 1) &&
                   (currentTd->HwTD.Control.BabbleDetected  == 0) &&
                   (currentTd->HwTD.Control.NAKReceived     == 0) &&
                   (currentTd->HwTD.Control.TimeoutCRC      == 1) &&
                   (currentTd->HwTD.Control.BitstuffError   == 0) &&
                   !TEST_FLAG(currentTd->Flags, TD_FLAG_TIMEOUT_ERROR)) {

            // If this is the first time that the device or hc has been
            // unresponsive, cut it a break and try the transfer again.

            // Note that we don't check currentTd->HwTD.Control.DataBufferError
            // since a value of:
            //    1 means host controller did not respond to IN data sent by device
            //    0 means device did not NAK IN request.

            SET_FLAG(currentTd->Flags, TD_FLAG_TIMEOUT_ERROR);

            currentTd->HwTD.Control.ErrorCount = 3;

            currentTd->HwTD.Control.Stalled    = 0;
            currentTd->HwTD.Control.TimeoutCRC = 0;
            currentTd->HwTD.Control.Active     = 1;

        } else if (currentTd->HwTD.Control.Stalled ||
                   currentTd->HwTD.Control.DataBufferError ||
                   currentTd->HwTD.Control.BabbleDetected ||
                   currentTd->HwTD.Control.TimeoutCRC ||
                   currentTd->HwTD.Control.BitstuffError) {

            SET_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED);
            //
            // Error. We need to flush.
            //
            // Flush all completed tds
            //
            // Complete transfer with error.
            // if the endpoint is halted we need to complete
            // the 'current' tarnsfer with an error walk all
            // the tds for the current transfer and mark
            // any that are not done as 'skipped'.

            UhciKdPrint((DeviceData, 2, "'Error on EP %x\n", EndpointData));

            LOGENTRY(DeviceData, G, '_erT', qh, currentTd, currentTd->HwTD.Control.ul);
            transferContext = currentTd->TransferContext;
            tp = transferContext->TransferParameters;

            SET_FLAG(currentTd->Flags, TD_FLAG_DONE);
            InsertTailList(&EndpointData->DoneTdList,
                           &currentTd->DoneLink);
            // Skip all the remaining TDs in this transfer

            UHCI_ASSERT(DeviceData, td->TransferContext == transferContext);
            for (td;
                 td &&
                 td->TransferContext->TransferParameters->SequenceNumber == tp->SequenceNumber;
                 td = td->NextTd) {

                if (!TEST_FLAG(td->Flags, TD_FLAG_DONE)) {

                    LOGENTRY(DeviceData, G, '_skT', qh, 0, td);
                    SET_FLAG(td->Flags, (TD_FLAG_DONE | TD_FLAG_SKIP));
                    InsertTailList(&EndpointData->DoneTdList,
                                   &td->DoneLink);
                }
            }

            if (EndpointData->Parameters.TransferType != Control) {

                // Loop through all the remaining TDs for this
                // endpoint and fix the data toggle.
                UhciFixDataToggle(
                    DeviceData,
                    EndpointData,
                    td,
                    currentTd->HwTD.Token.DataToggle);
            }
            SET_QH_TD(DeviceData, EndpointData, td);

        } else if (ACTUAL_LENGTH(currentTd->HwTD.Control.ActualLength) <
                   ACTUAL_LENGTH(currentTd->HwTD.Token.MaximumLength)) {

            //
            // Short packet. We need to flush.
            //
            // Flush all completed tds
            //
            // we need to walk all the tds for the current
            // transfer and mark any that are not done as
            // 'skipped'. EXCEPT if the last TD is a status
            // phase of a control transfer, in which case
            // we have to queue that one up.
            //
            tp = currentTd->TransferContext->TransferParameters;

            UhciKdPrint((DeviceData, 2, "'Short packet on EP %x\n", EndpointData));

            LOGENTRY(DeviceData, G, '_shP', qh, currentTd, currentTd->HwTD.Control.ul);

            SET_FLAG(currentTd->Flags, TD_FLAG_DONE);
            InsertTailList(&EndpointData->DoneTdList,
                           &currentTd->DoneLink);

            // Skip all the remaining TDs in this transfer up to the status phase
            // If control transfer, queue up the status phase,
            // else go to the next transfer (if there is one).
            for (td;
                 td &&
                 td->TransferContext->TransferParameters->SequenceNumber == tp->SequenceNumber;
                 td = td->NextTd) {

                if (TEST_FLAG(td->Flags, TD_FLAG_STATUS_TD) &&
                    TEST_FLAG(tp->TransferFlags, USBD_SHORT_TRANSFER_OK)) {

                    // Queue up the status phase of the control transfer.
                    UHCI_ASSERT(DeviceData, EndpointData->Parameters.TransferType == Control);
                    break;
                }

                if (!TEST_FLAG(td->Flags, TD_FLAG_DONE)) {
                    LOGENTRY(DeviceData, G, '_skT', qh, 0, td);

                    SET_FLAG(td->Flags, (TD_FLAG_DONE | TD_FLAG_SKIP));

                    InsertTailList(&EndpointData->DoneTdList,
                                   &td->DoneLink);
                }
            }

            if (EndpointData->Parameters.TransferType != Control &&
                currentTd->NextTd) {

                // Loop through all the remaining TDs for this
                // endpoint and fix the data toggle.
                UhciFixDataToggle(
                    DeviceData,
                    EndpointData,
                    td,
                    currentTd->NextTd->HwTD.Token.DataToggle);
            }

            if (!TEST_FLAG(tp->TransferFlags, USBD_SHORT_TRANSFER_OK)) {
                SET_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED);
            }

            // Next transfer or status phase of a control transfer.
            SET_QH_TD(DeviceData, EndpointData, td);

        } else {

            // Current td is not active.
            // If we're still pointing to the same td at this point in time,
            // then we're stuck and I have to manually advance the queuehead
            // to the next td.
            LOGENTRY(DeviceData, G, '_nuT', qh, currentTd, td);
            if (curTdPhys == (qh->HwQH.VLink.HwAddress & ~HW_LINK_FLAGS_MASK)) {

                // HW error. Td pointer for QH is not advancing.
                // Manually advance things.
                SET_FLAG(currentTd->Flags, TD_FLAG_DONE);
                InsertTailList(&EndpointData->DoneTdList,
                               &currentTd->DoneLink);
                                   
                EndpointData->HeadTd = currentTd->NextTd;
                qh->HwQH.VLink.HwAddress = currentTd->HwTD.LinkPointer.HwAddress;

                LOGENTRY(DeviceData, G, '_nu+', qh, currentTd, td);
            }
        }
    } else {

        // All transfers completed normally

UhciPollAsyncEndpointSetNext:
        // Flush all completed tds
        // Complete transfer

        // set the sw headp to the new current head
        // Next transfer or status phase of a control transfer.
        SET_QH_TD(DeviceData, EndpointData, currentTd);
    }
    
    // now flush all completed TDs. Do it in order of completion.

    while (!IsListEmpty(&EndpointData->DoneTdList)) {
    
        PLIST_ENTRY listEntry;
    
        listEntry = RemoveHeadList(&EndpointData->DoneTdList);
        
        
        td = (PHCD_TRANSFER_DESCRIPTOR) CONTAINING_RECORD(
                     listEntry,
                     struct _HCD_TRANSFER_DESCRIPTOR, 
                     DoneLink);
           

        if ((td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)) ==
            (TD_FLAG_XFER | TD_FLAG_DONE)) {

            UhciProcessDoneAsyncTd(DeviceData, td);
        }
                                
    }
#if 0
    // now flush all completed TDs. Do it in order of allocation.
    for (i = (EndpointData->TdsUsed <= (EndpointData->TdLastAllocced+1)) ?
         (EndpointData->TdLastAllocced + 1) - EndpointData->TdsUsed :
         (EndpointData->TdLastAllocced + EndpointData->TdCount + 1) - EndpointData->TdsUsed, j=0;
         j < EndpointData->TdCount;
         j++, i = (i+1 < EndpointData->TdCount) ? i+1 : 0) {
        td = &EndpointData->TdList->Td[i];

        if ((td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)) ==
            (TD_FLAG_XFER | TD_FLAG_DONE)) {

            UhciProcessDoneAsyncTd(DeviceData, td);
        }
    }
#endif
    // certain types of endpoints do not halt eg control
    // we resume these endpoints here
    if (TEST_FLAG(EndpointData->Flags, UHCI_EDFLAG_NOHALT) &&
        TEST_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED)) {

        LOGENTRY(DeviceData, G, '_clH', qh, 0, 0);

        UhciSetEndpointStatus(
            DeviceData,
            EndpointData,
            ENDPOINT_STATUS_RUN);

    }
}


VOID
UhciAbortAsyncTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext,
    OUT PULONG BytesTransferred
    )
/*++

Routine Description:

    Aborts the specified transfer by freeing all the TDs
    associated with said transfer. The queuehead for this
    transfer will have already been removed from the
    hardware queue when a SetEndpointState (paused) was
    sent by the port driver.
    Note that if another transfer is queued on the same
    endpoint, we need to fix up the list structure. We
    will also fix up any toggle issues on bulk endpoints.

Arguments:

Return Value:

--*/

{

    PHCD_TRANSFER_DESCRIPTOR td;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHCD_TRANSFER_DESCRIPTOR joinTd = NULL;
    BOOLEAN updateHead = FALSE;
    ULONG toggle;
    ULONG i;

    UhciKdPrint((DeviceData, 2, "'Abort async transfer on EP %x\n", EndpointData));

    qh = EndpointData->QueueHead;

    // The endpoint should not be in the schedule

    LOGENTRY(DeviceData, G, '_Aat', qh, TransferContext, 0);
    UHCI_ASSERT(DeviceData, !TEST_FLAG(qh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE));

    // our mission now is to remove all TDs associated with
    // this transfer

    // get the last known head, we update the head when we process
    // (AKA poll) the endpoint.

    UHCI_ASSERT(DeviceData, EndpointData->HeadTd);

    // Find the first TD in the transfer to abort
    for (td = EndpointData->HeadTd; td; td = td->NextTd) {
        if (td->TransferContext == TransferContext) {
            break;
        }
        joinTd = td;
    }
    UHCI_ASSERT(DeviceData, td);

    // Gonna have to fix up the toggle for bulk.
    toggle = td->HwTD.Token.DataToggle;

    // Was it the first transfer for this endpoint?
    if (td == EndpointData->HeadTd) {

        // This was the first queued transfer. Need to update the head.
        updateHead = TRUE;
    }

    UHCI_ASSERT(DeviceData, td->TransferContext == TransferContext);
    //
    // Loop through all the TDs for this transfer and free
    // them.
    //
    while (td) {
        if (td->TransferContext == TransferContext) {
            LOGENTRY(DeviceData, G, '_abT', qh, 0, td);

            // if the TD completed we need to track the data
            if (td->HwTD.Control.Active == 0) {
                TEST_TRAP();
                UhciProcessDoneAsyncTd(DeviceData, td);
            } else {
                UHCI_FREE_TD(DeviceData, EndpointData, td);
            }
        } else {
            // We're past the transfer to abort.
            break;
        }
        td = td->NextTd;
    }

    UhciFixDataToggle(DeviceData, EndpointData, td, toggle);

    if (updateHead) {

        // The transfer we removed was the first one.
        SET_QH_TD(DeviceData, EndpointData, td);
    } else {

        // The transfer we removed was not the first one.
        UHCI_ASSERT(DeviceData, joinTd);
        if (td) {

            // This was a middle transfer.
            SET_NEXT_TD(joinTd, td);
        } else {

            // The transfer we removed was the last one.
            EndpointData->TailTd = joinTd;
            SET_NEXT_TD_NULL(joinTd);
        }
    }

    *BytesTransferred = TransferContext->BytesTransferred;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\int.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    int.c

Abstract:

    interrupt service routine

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-26-00 : created, jsenior

--*/



#include "pch.h"


//implements the following miniport functions:

//non paged
//UhciInterruptService
//UhciInterruptDpc
//UhciDisableInterrupts
//UhciEnableInterrupts
//UhciRHDisableIrq
//UhciRHEnableIrq
//UhciInterruptNextSOF

BOOLEAN
UhciInterruptService (
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    BOOLEAN usbInt;
    PHC_REGISTER reg;
//    USBINTR enabledIrqs;
    USBSTS irqStatus;

    reg = DeviceData->Registers;

    // assume it is not ours
    usbInt = FALSE;

    // see if we have lost the controller due to
    // a surprise remove
    if (UhciHardwarePresent(DeviceData) == FALSE) {
        return FALSE;
    }

    // get a mask of possible interrupts
//    enabledIrqs.us = READ_PORT_USHORT(&reg->UsbInterruptEnable.us);

    irqStatus.us = READ_PORT_USHORT(&reg->UsbStatus.us);
    // just look at the IRQ status bits
    irqStatus.us &= HcInterruptStatusMask;

    // irqStatus now possibly contains bits set for any currently
    // enabled interrupts

    if (irqStatus.HostSystemError ||
        irqStatus.HostControllerProcessError) {
        UhciKdPrint((DeviceData, 0, "IrqStatus Error: %x\n", irqStatus.us));
    } else if (irqStatus.us) {
        DeviceData->HCErrorCount = 0;
    }

#if DBG
    // this usually means we have a bad TD in the schedule
    // we will need to debug this since the controller and/or
    // device will not function after this point
    if (irqStatus.HostControllerProcessError) {
        USHORT fn;

        fn = READ_PORT_USHORT(&reg->FrameNumber.us);
        UhciKdPrint((DeviceData, 0, "HostControllerProcessError: %x\n", irqStatus.us));
        UhciKdPrint((DeviceData, 0, "frame[]: %x\n", fn&0x7ff));
        {
        //UhciDumpRegs(DeviceData);
        USHORT tmp;
        tmp = READ_PORT_USHORT(&reg->UsbCommand.us);
        UhciKdPrint((DeviceData, 0, "UsbCommand %x\n", tmp));
        tmp = READ_PORT_USHORT(&reg->UsbStatus.us);
        UhciKdPrint((DeviceData, 0, "UsbStatus %x\n", tmp));
        tmp = READ_PORT_USHORT(&reg->UsbInterruptEnable.us);
        UhciKdPrint((DeviceData, 0, "UsbInterruptEnable %x\n", tmp));
        tmp = READ_PORT_USHORT(&reg->UsbCommand.us);
        UhciKdPrint((DeviceData, 0, "UsbCommand %x\n", tmp));
        }
        TEST_TRAP();
    }
#endif

    // the halted bit alone does not indicate the interrupt
    // came from the controller

    if (irqStatus.UsbInterrupt ||
        irqStatus.ResumeDetect ||
        irqStatus.UsbError ||
        irqStatus.HostSystemError ||
        irqStatus.HostControllerProcessError)  {

        DeviceData->IrqStatus = irqStatus.us;

        // Clear the condition
        WRITE_PORT_USHORT(&reg->UsbStatus.us, irqStatus.us);

#if DBG
#ifndef _WIN64
        if (irqStatus.HostSystemError) {
            // something has gone terribly wrong
            UhciKdPrint((DeviceData, 0, "HostSystemError: %x\n", irqStatus.us));
            TEST_TRAP();
        }
#endif
#endif

        // indications are that this came from the
        // USB controller
        usbInt = TRUE;

        // disable all interrupts until the DPC for ISR runs
        WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us, 0);

    }

    //
    // If bulk bandwidth reclamation is on and there's
    // nothing queued, then turn it off.
    //
    if (irqStatus.UsbInterrupt) {
        UhciUpdateCounter(DeviceData);
        if (!DeviceData->LastBulkQueueHead->HwQH.HLink.Terminate) {
            PHCD_QUEUEHEAD_DESCRIPTOR qh;
            BOOLEAN activeBulkTDs = FALSE;
            // This loop skips the td that has been inserted for
            // the PIIX4 problem, since it starts with the qh
            // the bulk queuehead is pointing at.
            // If the bulk queuehead is not pointing at anything,
            // then we're fine too, since it will have been
            // turned off already.
            for (qh = DeviceData->BulkQueueHead->NextQh;
                 qh;
                 qh = qh->NextQh) {
                if (!qh->HwQH.VLink.Terminate) {
                    activeBulkTDs = TRUE;
                    break;
                }
            }

            //
            // qh is pointing at either the first queuehead
            // with transfers pending or the bulk queuehead.
            //
            if (!activeBulkTDs) {
                UHCI_ASSERT(DeviceData, !qh)
                DeviceData->LastBulkQueueHead->HwQH.HLink.Terminate = 1;
            }
        }
    }

    if (irqStatus.HostControllerProcessError) {
        //
        // Force the schedule clean.
        //
        UhciCleanOutIsoch(DeviceData, TRUE);
    } else if (irqStatus.UsbInterrupt && DeviceData->IsoPendingTransfers) {
        //
        // Something completed.
        //
        UhciCleanOutIsoch(DeviceData, FALSE);
#if 0
    } else if (!DeviceData->IsoPendingTransfers) {
        //
        // Remove the rollover interrupt.
        //
        *( ((PULONG) (DeviceData->FrameListVA)) ) = DeviceData->RollOverTd->HwTD.LinkPointer.HwAddress;
#endif
    }

    if (irqStatus.HostControllerProcessError) {
        if (DeviceData->HCErrorCount++ < UHCI_HC_MAX_ERRORS) {
            USBCMD command;

            // Attempt to recover.
            // It could just be that we overran. If so,
            // the above code that clears the schedule
            // should take care of it.
            command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
            command.RunStop = 1;
            WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);
            UhciKdPrint((DeviceData, 0, "Attempted to recover from error\n"));
        }
    }

    return usbInt;
}


VOID
UhciInterruptDpc (
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN EnableInterrupts
    )
/*++

Routine Description:

    process an interrupt

Arguments:

Return Value:

--*/
{
    PHC_REGISTER reg;
    USBSTS irqStatus, tmp;
    PLIST_ENTRY listEntry;
    PENDPOINT_DATA endpointData;

    reg = DeviceData->Registers;

    // ack all status bits asserted now
    //tmp.us = READ_PORT_USHORT(&reg->UsbStatus.us);
    tmp.us = DeviceData->IrqStatus;
    DeviceData->IrqStatus = 0;

    LOGENTRY(DeviceData, G, '_idp', tmp.us, 0, 0);

    //WRITE_PORT_USHORT(&reg->UsbStatus.us, tmp.us);

    // now process status bits aserted,
    // just look at the IRQ status bits
    irqStatus.us = tmp.us & HcInterruptStatusMask;

    if (irqStatus.UsbInterrupt ||
        irqStatus.UsbError) {
        LOGENTRY(DeviceData, G, '_iEP', irqStatus.us, 0, 0);

        USBPORT_INVALIDATE_ENDPOINT(DeviceData, NULL);
    }

    if (EnableInterrupts) {
        LOGENTRY(DeviceData, G, '_iEE', 0, 0, 0);

        WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us,
                          DeviceData->EnabledInterrupts.us);
    }
}


VOID
USBMPFN
UhciDisableInterrupts(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USHORT legsup;
    PHC_REGISTER reg;

    UhciKdPrint((DeviceData, 2, "Disable interrupts\n"));

    LOGENTRY(DeviceData, G, '_DIn', 0, 0, 0);
    reg = DeviceData->Registers;
    WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us,
        0);

    if (DeviceData->ControllerFlavor != UHCI_Ich2_1 &&
        DeviceData->ControllerFlavor != UHCI_Ich2_2) {
        //
        // change the state of the PIRQD routing bit
        //
        USBPORT_READ_CONFIG_SPACE(
            DeviceData,
            &legsup,
            LEGACY_BIOS_REGISTER,
            sizeof(legsup));

        LOGENTRY(DeviceData, G, '_leg', 0, legsup, 0);
        // clear the PIRQD routing bit
        legsup &= ~LEGSUP_USBPIRQD_EN;

        USBPORT_WRITE_CONFIG_SPACE(
            DeviceData,
            &legsup,
            LEGACY_BIOS_REGISTER,
            sizeof(legsup));
    }
}


VOID
UhciFlushInterrupts(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    used to flush rougue interrupts from the controller
    after power events

Arguments:

Return Value:

--*/
{

    PHC_REGISTER reg;

    LOGENTRY(DeviceData, G, '_FIn', 0, 0, 0);
    UhciKdPrint((DeviceData, 2, "Enable interrupts\n"));

    reg = DeviceData->Registers;

    // before writing the PIRQD register ack any eronious interrupts
    // the controller may be asserting -- it should not be asserting
    // at all but often is
    WRITE_PORT_USHORT(&reg->UsbStatus.us, 0xFFFF);
}


VOID
USBMPFN
UhciEnableInterrupts(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USHORT legsup;
    PHC_REGISTER reg;

    LOGENTRY(DeviceData, G, '_EIn', 0, 0, 0);
    UhciKdPrint((DeviceData, 2, "Enable interrupts\n"));

    reg = DeviceData->Registers;

    //
    // change the state of the PIrQD routing bit
    //

    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &legsup,
        LEGACY_BIOS_REGISTER,
        sizeof(legsup));

    LOGENTRY(DeviceData, G, '_leg', 0, legsup, 0);
    // clear the PIRQD routing bit
    legsup |= LEGSUP_USBPIRQD_EN;

    USBPORT_WRITE_CONFIG_SPACE(
        DeviceData,
        &legsup,
        LEGACY_BIOS_REGISTER,
        sizeof(legsup));

    WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us,
        DeviceData->EnabledInterrupts.us);

}


VOID
UhciRHDisableIrq(
    IN PDEVICE_DATA DeviceData
    )
{
    // Uhci doesn't have this IRQ
}


VOID
UhciRHEnableIrq(
    IN PDEVICE_DATA DeviceData
    )
{
    // Uhci doesn't have this IRQ
}

#define UHCI_SOF_LATENCY 2

VOID
UhciInterruptNextSOF(
    IN PDEVICE_DATA DeviceData
    )
{
    ULONG i, frame, offset, cf;
    PHCD_TRANSFER_DESCRIPTOR td;
    BOOLEAN found = FALSE;

    cf = UhciGet32BitFrameNumber(DeviceData);

    // find a TD
    for (i=0; i<SOF_TD_COUNT; i++) {
        td = &DeviceData->SofTdList->Td[i];

        UHCI_ASSERT(DeviceData, td->Sig == SIG_HCD_SOFTD);
        // use transferconext to hold req frame
        frame = td->RequestFrame;

        if (frame == cf+UHCI_SOF_LATENCY) {
            // There's already one queued
            found = TRUE;
            break;
        }
        if (frame < cf) {

            td->RequestFrame = (cf+UHCI_SOF_LATENCY);

            LOGENTRY(DeviceData, G, '_SOF', td, td->RequestFrame, cf);
            // insert TD
            td->HwTD.LinkPointer.HwAddress = 0;
            INSERT_ISOCH_TD(DeviceData, td, td->RequestFrame);
            found = TRUE;
            break;
        }
    }

    if (!found) {
        TEST_TRAP();
    }

    // recycle any old SOF interrupt TDs
    for (i=0; i<SOF_TD_COUNT; i++) {
        td = &DeviceData->SofTdList->Td[i];

        UHCI_ASSERT(DeviceData, td->Sig == SIG_HCD_SOFTD);
        // use transferconext to hold req frame
        frame = td->RequestFrame;

        if (frame &&
            (frame < cf ||
             frame - cf > UHCI_MAX_FRAME)) {
            td->RequestFrame = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\isoch.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   isoch.c

Abstract:

   miniport transfer code for Isochronous

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    8-1-00 : created, jsenior

--*/

#include "pch.h"


//implements the following miniport functions:

//non paged
//UhciIsochTransfer
//UhciProcessDoneIsochTd
//UhciPollIsochEndpoint
//UhciAbortIsochTransfer


USB_MINIPORT_STATUS
UhciIsochTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PMINIPORT_ISO_TRANSFER IsoTransfer
    )
/*++

Routine Description:

    Initialize all the TDs for an isochronous Transfer.
    Queue up whatever TDs we can in the current schedule.
    Whatever's left may get queued in the poll routine.

Arguments:


--*/
{
    // indices and offsets
    ULONG i, dbCount;
    // lengths
    ULONG lengthThisTd, lengthMapped = 0;
    USHORT maxPacketSize = EndpointData->Parameters.MaxPacketSize;
    // structure pointers
    PTRANSFER_PARAMETERS tp;
    PISOCH_TRANSFER_BUFFER buffer = NULL;
    PHCD_TRANSFER_DESCRIPTOR firstTd, td; //, lastTd = NULL;
    HW_32BIT_PHYSICAL_ADDRESS address;
    PMINIPORT_ISO_PACKET packet;
    BOOLEAN pageCrossing = FALSE;
    USBD_STATUS insertResult;
    USB_MINIPORT_STATUS mpStatus;
    // Isoch pipes are uni-directional. Get the
    // direction from the endpoint address.
    UCHAR pid = GetPID(EndpointData->Parameters.EndpointAddress);

    //
    // Do we have enough free resources?
    //
    if (EndpointData->TdCount - EndpointData->TdsUsed <
        IsoTransfer->PacketCount) {
        // Not enough TDs to do this transfer yet.
        // Tell the port driver to wait.
        return USBMP_STATUS_BUSY;
    }
    // We may need DBs. Do we have enough?
    for (i = 0, dbCount = 0; i < IsoTransfer->PacketCount; i++) {
        if (IsoTransfer->Packets[i].BufferPointerCount == 2) {
            dbCount++;
        }
    }
    if (EndpointData->DbCount - EndpointData->DbsUsed <
        dbCount) {
        // Not enough DBs to do this transfer yet.
        // Tell the port driver to wait.
        return USBMP_STATUS_BUSY;
    }

    UhciCleanOutIsoch(DeviceData, FALSE);

#if DBG
    {
    ULONG cf;
    cf = UhciGet32BitFrameNumber(DeviceData);
    LOGENTRY(DeviceData, G, '_iso', IsoTransfer->PacketCount, cf,
        IsoTransfer->Packets[0].FrameNumber);

    }
#endif
//    UhciKdPrint((DeviceData, 2, "'First packet frame number = %x\n", IsoTransfer->Packets[0].FrameNumber));
    IncPendingTransfers(DeviceData, EndpointData);

    // init the context
    RtlZeroMemory(TransferContext, sizeof(*TransferContext));
    TransferContext->Sig = SIG_UHCI_TRANSFER;
    TransferContext->UsbdStatus = USBD_STATUS_SUCCESS;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = tp = TransferParameters;
    TransferContext->IsoTransfer = IsoTransfer;

    UHCI_ASSERT(DeviceData,
        EndpointData->Parameters.TransferType == Isochronous);

    LOGENTRY(DeviceData, G, '_isT', EndpointData, TransferParameters, IsoTransfer->Packets[0].FrameNumber);

    //
    // One TD per transfer.
    //
    for (i = 0; i < IsoTransfer->PacketCount; i++) {
        packet = &IsoTransfer->Packets[i];
        address = packet->BufferPointer0.Hw32;
        UHCI_ASSERT(DeviceData, address);
        UHCI_ASSERT(DeviceData, packet->BufferPointerCount == 1 ||
                    packet->BufferPointerCount == 2);

        //
        // Is this packet ok to transfer?
        //
        UhciCheckIsochTransferInsertion(DeviceData,
                                        insertResult,
                                        packet->FrameNumber);
        if (USBD_ERROR(insertResult)) {
            // Not ok to transfer. Try the next one.
            packet->UsbdStatus = insertResult;

            lengthMapped +=
                packet->BufferPointer0Length + packet->BufferPointer1Length;
            LOGENTRY(DeviceData, G, '_BSF', UhciGet32BitFrameNumber(DeviceData), IsoTransfer->Packets[i].FrameNumber, i);
            continue;
        }

        if (packet->BufferPointerCount == 1) {
            //
            // Normal, non-buffered case.
            //
            pageCrossing = FALSE;
            lengthThisTd = packet->BufferPointer0Length;
        } else {
            //
            // Page crossing. Must double buffer this transfer.
            //
            lengthThisTd = packet->BufferPointer0Length + packet->BufferPointer1Length;

            buffer = (PISOCH_TRANSFER_BUFFER)
                        UHCI_ALLOC_DB(DeviceData, EndpointData, TRUE);
            UHCI_ASSERT(DeviceData, buffer);
            UHCI_ASSERT(DeviceData, buffer->Sig == SIG_HCD_IDB);
            UHCI_ASSERT(DeviceData, buffer->PhysicalAddress);
            buffer->SystemAddress = IsoTransfer->SystemAddress + lengthMapped;
            buffer->Size = lengthThisTd;
            UHCI_ASSERT(DeviceData, lengthThisTd <= MAX_ISOCH_PACKET_SIZE);
            if (OutPID == pid) {
                RtlCopyMemory(&buffer->Buffer[0],
                              buffer->SystemAddress,
                              lengthThisTd);
            }
            // Change the address for the TD
            pageCrossing = TRUE;
            address = buffer->PhysicalAddress;
        }

        TransferContext->PendingTds++;

        td = UHCI_ALLOC_TD(DeviceData, EndpointData);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

        //
        // Initialize the TD fields
        //
        td->HwTD.Token.Pid = pid;
        td->HwTD.Token.MaximumLength = MAXIMUM_LENGTH(lengthThisTd);
        td->HwTD.Token.DataToggle = DataToggle0;
        td->HwTD.Control.IsochronousSelect = 1;
        td->HwTD.Control.ShortPacketDetect = 0; // Don't care about short packets
        td->HwTD.Control.ActualLength = MAXIMUM_LENGTH(0);
        td->HwTD.Control.ErrorCount = 0;
        td->HwTD.Buffer = address;
        td->IsoPacket = packet;
        if (pageCrossing) {
            SET_FLAG(td->Flags, TD_FLAG_DOUBLE_BUFFERED);
            td->DoubleBuffer = (PTRANSFER_BUFFER) buffer;
        }
//        countIOC = countIOC + 1 == 10 ? 0 : countIOC+1;
        //
        // Request some interrupts near the end of the
        // transfer
        td->HwTD.Control.InterruptOnComplete =
            (i+1 >= IsoTransfer->PacketCount) ? 1 : 0; //!countIOC;

        address += lengthThisTd;
        lengthMapped += lengthThisTd;

        if (USBD_STATUS_SUCCESS == insertResult) {
            //
            // Put the TD in the schedule
            //
            LOGENTRY(DeviceData, G, '_qi1', td, 0, packet->FrameNumber);
            INSERT_ISOCH_TD(DeviceData, td, packet->FrameNumber);
        }
    }

    if (!TransferContext->PendingTds) {
        // Nothing got queued. Complete the transfer.
        DecPendingTransfers(DeviceData, EndpointData);

        LOGENTRY(DeviceData, G, '_cpt',
            packet->UsbdStatus,
            TransferContext,
            TransferContext->BytesTransferred);

        USBPORT_INVALIDATE_ENDPOINT(DeviceData, EndpointData);

        UhciKdPrint((DeviceData, 2, "'No tds queued for isoch tx.\n", EndpointData));
        // return error and port will complete the transfer
        mpStatus = USBMP_STATUS_FAILURE;
    } else {
        mpStatus = USBMP_STATUS_SUCCESS;
    }

    UHCI_ASSERT(DeviceData, TransferContext->TransferParameters->TransferBufferLength == lengthMapped);

    return mpStatus;
}


VOID
UhciProcessDoneIsochTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
/*++

Routine Description:

    process a completed isoch TD

Parameters

--*/
{
    PTRANSFER_CONTEXT transferContext;
    PENDPOINT_DATA endpointData;
    ULONG byteCount;
    PMINIPORT_ISO_PACKET packet;

    transferContext = Td->TransferContext;
    ASSERT_TRANSFER(DeviceData, transferContext);

    transferContext->PendingTds--;
    endpointData = transferContext->EndpointData;
    packet = Td->IsoPacket;
    UHCI_ASSERT(DeviceData, packet);

    if (!TEST_FLAG(Td->Flags, TD_FLAG_ISO_QUEUED)) {
        packet->UsbdStatus = USBD_STATUS_BAD_START_FRAME;
    } else if (Td->HwTD.Control.Active) {
        packet->UsbdStatus = USBD_STATUS_NOT_ACCESSED;
    } else {
        // completion status for this TD/packet?
        packet->UsbdStatus = UhciGetErrorFromTD(DeviceData, Td);
    }

    LOGENTRY(DeviceData, G, '_Dit', transferContext,
                         packet->UsbdStatus,
                         Td);

    byteCount = ACTUAL_LENGTH(Td->HwTD.Control.ActualLength);

    transferContext->BytesTransferred += byteCount;
    packet->LengthTransferred = byteCount;

    //
    // For double buffered transfers, we now have to copy back
    // if this was an IN transfer.
    //
    if (Td->HwTD.Token.Pid == InPID &&
        TEST_FLAG(Td->Flags, TD_FLAG_DOUBLE_BUFFERED)) {
        PISOCH_TRANSFER_BUFFER buffer = (PISOCH_TRANSFER_BUFFER)Td->DoubleBuffer;
        UHCI_ASSERT(DeviceData, TEST_FLAG(buffer->Flags, DB_FLAG_BUSY));
        RtlCopyMemory(buffer->SystemAddress,
                      &buffer->Buffer[0],
                      buffer->Size);
    }

    // mark the TD free
    // This also frees any double buffers.
    UHCI_FREE_TD(DeviceData, endpointData, Td);

    if (transferContext->PendingTds == 0) {
        // all TDs for this transfer are done
        // clear the HAVE_TRANSFER flag to indicate
        // we can take another
        DecPendingTransfers(DeviceData, endpointData);

        LOGENTRY(DeviceData, G, '_cit',
            packet->UsbdStatus,
            transferContext,
            transferContext->BytesTransferred);

        transferContext->TransferParameters->FrameCompleted =
            UhciGet32BitFrameNumber(DeviceData);

        USBPORT_COMPLETE_ISOCH_TRANSFER(
            DeviceData,
            endpointData,
            transferContext->TransferParameters,
            transferContext->IsoTransfer);
    }
}

VOID
UhciPollIsochEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'

    The goal here is to determine which TDs, if any,
    have completed and complete any associated transfers.

Arguments:

Return Value:

--*/
{
    PHCD_TRANSFER_DESCRIPTOR td;
    ULONG i;
    PMINIPORT_ISO_PACKET packet;
    USBD_STATUS insertResult;

    LOGENTRY(DeviceData, G, '_PiE', EndpointData, 0, 0);

    //
    // Cleanup the isoch transfers that haven't completed yet.
    //
    UhciCleanOutIsoch(DeviceData, FALSE);

    //
    // Flush all completed TDs and
    // queue up TDs that were pended.
    //
    // Don't care about errors.
    // Just get 'em out of here.
    //
    for (i = 0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if (TEST_FLAG(td->Flags, TD_FLAG_XFER)) {
            if (td->IsoPacket->FrameNumber < DeviceData->LastFrameProcessed ||
                td->IsoPacket->FrameNumber - DeviceData->LastFrameProcessed > UHCI_MAX_FRAME) {
                //
                // Done, whether we like it or not.
                //
                td->Flags |= TD_FLAG_DONE;
            } else if (!TEST_FLAG(td->Flags, TD_FLAG_ISO_QUEUED)) {
                packet = td->IsoPacket;
                UhciKdPrint((DeviceData, 0, "'Late TD\n"));
                UhciCheckIsochTransferInsertion(DeviceData,
                                                insertResult,
                                                packet->FrameNumber);
                if (USBD_STATUS_SUCCESS == insertResult) {
                    //
                    // Put the TD in the schedule
                    //
                    LOGENTRY(DeviceData, G, '_qi2', td, 0, packet->FrameNumber);
                    INSERT_ISOCH_TD(DeviceData, td, packet->FrameNumber);
                }
            }

            if (TEST_FLAG(td->Flags, TD_FLAG_DONE)) {
                UhciProcessDoneIsochTd(DeviceData, td);
            }
        }
    }
}

VOID
UhciCleanOutIsoch(
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN      ForceClean
    )
{
    ULONG i, currentFrame;

    if (1 != InterlockedIncrement(&DeviceData->SynchronizeIsoCleanup)) {
        InterlockedDecrement(&DeviceData->SynchronizeIsoCleanup);
        return;
    }
    //
    // Clean out the schedule, by pointing the frames
    // back to the interrupt QHs.
    //
    currentFrame = UhciGet32BitFrameNumber(DeviceData);

    if (currentFrame - DeviceData->LastFrameProcessed >= UHCI_MAX_FRAME ||
        ForceClean) {
        //
        // Schedule overrun.
        // Clean out all the frames.
        //
        UhciKdPrint((DeviceData, 2, "'Overrun L %x C %x\n", DeviceData->LastFrameProcessed, currentFrame));
        for (i = 0;
             i < UHCI_MAX_FRAME;
             i++) {
            UhciCleanFrameOfIsochTds (DeviceData, i);
        }
    } else {
        ULONG frameIndex;
        // normal cleanup of frames up to the current frame.
        frameIndex = ACTUAL_FRAME(currentFrame);
        UHCI_ASSERT(DeviceData, frameIndex < UHCI_MAX_FRAME);

        for (i = ACTUAL_FRAME(DeviceData->LastFrameProcessed);
             i != frameIndex;
             i = ACTUAL_FRAME(i+1)) {
            UhciCleanFrameOfIsochTds (DeviceData, i);
        }
    }
    DeviceData->LastFrameProcessed = currentFrame;

    InterlockedDecrement(&DeviceData->SynchronizeIsoCleanup);
}

VOID
UhciAbortIsochTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext
    )
/*++

Routine Description:

    Aborts the specified Isoch transfer by freeing all
    the TDs associated with said transfer. The dequeuing
    of these transfers should have been done in the ISR
    where we clean out the schedule.

Arguments:

Return Value:

--*/

{

    PHCD_TRANSFER_DESCRIPTOR td;
    ULONG i;

    //
    // The endpoint should not be in the schedule
    //
    LOGENTRY(DeviceData, G, '_Ait', EndpointData, TransferContext, 0);

    UhciKdPrint((DeviceData, 2, "'Aborting isoch transfer %x\n", TransferContext));

    //
    // Cleanup the isoch transfers that haven't completed yet.
    //
    UhciCleanOutIsoch(DeviceData, FALSE);

    //
    // Free up all the tds in this transfer.
    //
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];
        if (td->TransferContext == TransferContext) {
            UHCI_FREE_TD(DeviceData, EndpointData, td);
        }
    }
}

VOID
UhciSetIsochEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    LOGENTRY(DeviceData, G, '_Sis', EndpointData, State, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\dbg.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug only functions

Environment:

    kernel mode only

Notes:

Revision History:

    1-1-00 : created

--*/


#include "pch.h"



// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
//EHCI_KdPrintX

#if DBG


ULONG
_cdecl
UhciKdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function. 

    calls the port driver print function

Arguments:

Return Value:


--*/    
{
    va_list list;
    int i;
    int arg[6];
    
    va_start(list, Format);
    for (i=0; i<6; i++) {
        arg[i] = va_arg(list, int);
    }            
    
    USBPORT_DBGPRINT(
        DeviceData, Level, Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\bios.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    hydramp.c

Abstract:

    USB 2.0 UHCI driver

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    8-12-2000 : created, jsenior

--*/



#include "pch.h"


//implements the following miniport functions:
//UhciStopBIOS
//UhciStartBIOS


USB_MINIPORT_STATUS
UhciStopBIOS(
    IN PDEVICE_DATA DeviceData,
    IN PHC_RESOURCES HcResources
    )

/*++

Routine Description:

    This routine steals the USB controller from the BIOS, 
    making sure that it saves all the registers for later.

Arguments:

    DeviceData - DeviceData for this USB controller.
    HcResources - The resources from the pnp start device.

Return Value:

    NT status code.

--*/

{
    USBCMD cmd;
    USBSTS status;
    PHC_REGISTER reg;

    USBSETUP legsup;
    USB_MINIPORT_STATUS mpStatus = USBMP_STATUS_SUCCESS;
    LARGE_INTEGER startTime;
    ULONG sofModifyValue = 0;
    LARGE_INTEGER finishTime;

    UhciKdPrint((DeviceData, 2, "'Stop Bios.\n"));
    
    UHCI_ASSERT(DeviceData, HcResources->CommonBufferVa != NULL);
    // validate our resources
    if ((HcResources->Flags & (HCR_IO_REGS | HCR_IRQ)) != 
        (HCR_IO_REGS | HCR_IRQ)) {
        mpStatus = USBMP_STATUS_INIT_FAILURE;        
    }

    // set up or device data structure
    reg = DeviceData->Registers = 
        (PHC_REGISTER) (HcResources->DeviceRegisters);

    UhciKdPrint((DeviceData, 2, "'UHCI mapped Operational Regs = %x\n", reg));

    //  Disable PIRQD, NOTE: the Hal should have disabled it for us

    //
    // Disable the PIRQD
    //
    
    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &legsup,
        LEGACY_BIOS_REGISTER,     // offset of legacy bios reg
        sizeof(legsup));

#if DBG

    if (legsup & LEGSUP_USBPIRQD_EN) {
        UhciKdPrint((DeviceData, 2, "'PIRQD enabled on StartController (%x)\n", 
            legsup));    
    }
    
#endif

    UhciDisableInterrupts(DeviceData);
    
    //    UhciGetRegistryParameters(DeviceData);

    //
    // Get the SOF modify value. First, retrieve from
    // hardware, then see if we have something in the
    // registry to set it to, then save it away.
    //
/*    sofModifyValue = READ_PORT_UCHAR(&reg->StartOfFrameModify.uc);
    // Grab any SOF ModifyValue indicated in the registry
    // bugbug - todo
//    UHCD_GetSOFRegModifyValue(DeviceObject,
  //                            &sofModifyValue);
    // save the SOF modify for posterity
    DeviceData->BiosStartOfFrameModify.uc = (CHAR) sofModifyValue;
    UHCI_ASSERT(DeviceData, sofModifyValue <= 255);
  */
    
    // IF the host controller is in the global reset state, 
    // clear the bit prior to trying to stop the controller.
    // stop the controller,
    // clear RUN bit and config flag so BIOS won't reinit
    cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    cmd.GlobalReset = 0;
    cmd.RunStop = 0;
    cmd.ConfigureFlag = 0;
    WRITE_PORT_USHORT(&DeviceData->Registers->UsbCommand.us, cmd.us);

    // NOTE: if no BIOS is present
    // halt bit is initially set with PIIX3
    // halt bit is initially clear with VIA

    // now wait for HC to halt
    // Spec'ed to take 10 ms, so that's what we'll wait for
    KeQuerySystemTime(&finishTime); // get current time
    finishTime.QuadPart += 1000000; 

    KeQuerySystemTime(&startTime);
    status.us = READ_PORT_USHORT(&reg->UsbStatus.us);
    while (!status.HCHalted) {
        LARGE_INTEGER sysTime;

        status.us = READ_PORT_USHORT(&reg->UsbStatus.us);
        UhciKdPrint((DeviceData, 2, "'STATUS = %x\n", status.us));

        KeQuerySystemTime(&sysTime);
        if (sysTime.QuadPart >= finishTime.QuadPart) {
            // time out
            UhciKdPrint((DeviceData, 0,
                "'TIMEOUT HALTING CONTROLLER! (contact jsenior)\n"));
            TEST_TRAP();
            break;
        }
    }
    
    WRITE_PORT_USHORT(&reg->UsbStatus.us, 0xff);

    // If a legacy bios, disable it. note that PIRQD is disabled
    if ((legsup & LEGSUP_BIOS_MODE) != 0) {

        UhciKdPrint((DeviceData, 0, "'*** uhci detected a USB legacy BIOS ***\n"));
        HcResources->DetectedLegacyBIOS = TRUE;
        
        //
        // if BIOS mode bits set we have to take over
        //

        USBPORT_READ_CONFIG_SPACE(
            DeviceData,
            &legsup,
            LEGACY_BIOS_REGISTER,     // offset of legacy bios reg
            sizeof(legsup));

        // shut off host controller SMI enable
        legsup = 0x0000;
        USBPORT_WRITE_CONFIG_SPACE(   
            DeviceData,
            &legsup,
            LEGACY_BIOS_REGISTER,     // offset of legacy bios reg
            sizeof(legsup));
    }
        
    UhciKdPrint((DeviceData, 2, "'Legacy support reg = 0x%x\n", legsup));

    UhciKdPrint((DeviceData, 2, "'exit UhciStopBIOS 0x%x\n", mpStatus));

    return mpStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\pch.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled header file.

Environment:

    Kernel & user mode

Revision History:

    1-1-00 : created

--*/

#ifndef   __COMMON_H__
#define   __COMMON_H__

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usb.h"
#include "usbhcdi.h"

#include "uhci.h"
#include "dbg.h"

#include "usbuhci.h"

#endif // __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\usbuhci.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    usbuhci.c

Abstract:

    USB UHCI driver

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-28-2000 : created, jsenior

--*/



#include "pch.h"

typedef struct _SS_PACKET_CONTEXT {
    ULONG OldControlQH;
    MP_HW_POINTER FirstTd;
    MP_HW_POINTER Data;
    ULONG PadTo8Dwords[3];
} SS_PACKET_CONTEXT, *PSS_PACKET_CONTEXT;

//implements the following miniport functions:
//UhciStartController
//UhciStopController
//UhciStartSendOnePacket
//UhciEndSendOnePacket

VOID
UhciFixViaFIFO(
    IN PDEVICE_DATA DeviceData
    )
{
    VIAFIFO fifo;
    //
    // Disable broken fifo management.
    //

    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &fifo,
        VIA_FIFO_MANAGEMENT,
        sizeof(fifo));

    fifo |= VIA_FIFO_DISABLE;

    USBPORT_WRITE_CONFIG_SPACE(
        DeviceData,
        &fifo,
        VIA_FIFO_MANAGEMENT,
        sizeof(fifo));

    UhciKdPrint((DeviceData, 2, "'Fifo management reg = 0x%x\n", fifo));
}

VOID
UhciFixViaBabbleDetect(
    IN PDEVICE_DATA DeviceData
    )
{
    VIABABBLE babble;
    //
    // Disable broken fifo management.
    //

    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &babble,
        VIA_INTERNAL_REGISTER,
        sizeof(babble));

    babble |= VIA_DISABLE_BABBLE_DETECT;

    USBPORT_WRITE_CONFIG_SPACE(
        DeviceData,
        &babble,
        VIA_INTERNAL_REGISTER,
        sizeof(babble));

    UhciKdPrint((DeviceData, 2, "'Babble management reg = 0x%x\n", babble));
}

USB_MINIPORT_STATUS
UhciInitializeHardware(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

   Initializes the hardware registers for the host controller.

Arguments:

Return Value:

--*/
{
    PHC_REGISTER reg;
    USBCMD cmd;
    LARGE_INTEGER finishTime, currentTime;

    reg = DeviceData->Registers;

    if (DeviceData->ControllerFlavor == UHCI_VIA+0xE) {
        UhciFixViaFIFO(DeviceData);
    }

    if (DeviceData->ControllerFlavor <= UHCI_VIA+0x4) {
        UhciFixViaBabbleDetect(DeviceData);
    }

    // Save away the SOF modify for after resets
    DeviceData->SavedSOFModify = READ_PORT_UCHAR(&reg->StartOfFrameModify.uc);

    //
    // This hack is from the SP1 tree the QFE team must have added for some 
    // reason.  I have added to the current source to maintain consistency
    //
    // Delay an experimentally determined amount of time while the root hub port power
    // becomes good before resetting the controller so that the bus is not in reset while
    // devices are powered up.
    //
   
    USBPORT_WAIT(DeviceData, 20);


    // reset the controller
    cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    LOGENTRY(DeviceData, G, '_res', cmd.us, 0, 0);

    cmd.us = 0;
    cmd.GlobalReset = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);

    USBPORT_WAIT(DeviceData, 20);

    cmd.GlobalReset = 0;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);

    //
    // 64 byte reclamation
    //
    cmd.MaxPacket = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);

    //
    // set the SOF modify to whatever we found before
    // the reset.
    UhciKdPrint((DeviceData, 2, "'Setting SOF Modify to %d\n", DeviceData->SavedSOFModify));
    WRITE_PORT_UCHAR(&reg->StartOfFrameModify.uc,
                     DeviceData->SavedSOFModify);

    //
    // set the enabled interrupts cache, we'll enable
    // these interrupts when asked
    //
    DeviceData->EnabledInterrupts.TimeoutCRC = 1;
    DeviceData->EnabledInterrupts.Resume = 1;
    DeviceData->EnabledInterrupts.InterruptOnComplete = 1;
    DeviceData->EnabledInterrupts.ShortPacket = 1;

    return USBMP_STATUS_SUCCESS;
}

VOID
UhciSetNextQh(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR FirstQh,
    IN PHCD_QUEUEHEAD_DESCRIPTOR SecondQh
    )
/*++

Routine Description:

   Insert an aync endpoint (queue head)
   into the HW list

Arguments:


--*/
{
    QH_LINK_POINTER newLink;

    LOGENTRY(DeviceData, G, '_snQ', 0, FirstQh, SecondQh);

    // link new qh to the current 'head' ie
    // first transfer QH
    SecondQh->PrevQh = FirstQh;

    // put the new qh at the head of the queue
    newLink.HwAddress = SecondQh->PhysicalAddress;
    newLink.QHTDSelect = 1;
    UHCI_ASSERT(DeviceData, !newLink.Terminate);
    UHCI_ASSERT(DeviceData, !newLink.Reserved);
    FirstQh->HwQH.HLink = newLink;
    FirstQh->NextQh = SecondQh;

    SET_FLAG(SecondQh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE);
}

VOID
UhciFixPIIX4(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_TRANSFER_DESCRIPTOR Td,
    IN HW_32BIT_PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:


 PIIX4 hack

 we will need a dummy bulk endpoint inserted in the schedule

Arguments:

    DeviceData

Return Value:

    NT status code.

--*/
{
    UhciKdPrint((DeviceData, 2, "'Fix PIIX 4 hack.\n"));
    //
    // Set up the dummy TD.
    //
    Td->Flags = TD_FLAG_XFER;
    Td->HwTD.Buffer = 0x0badf00d;
    // point to ourselves
    Td->HwTD.LinkPointer.HwAddress = Td->PhysicalAddress = PhysicalAddress;
    Td->HwTD.Token.ul = 0;
    Td->HwTD.Token.Endpoint = 1;
    Td->HwTD.Token.DeviceAddress = 0;
    Td->HwTD.Token.MaximumLength = NULL_PACKET_LENGTH;
    Td->HwTD.Token.Pid = OutPID;
    Td->HwTD.Control.ul = 0;
    Td->HwTD.Control.Active = 0;
    Td->HwTD.Control.ErrorCount = 0;
    Td->HwTD.Control.InterruptOnComplete = 0;
    Td->HwTD.Control.IsochronousSelect = 1;
    Td->NextTd = NULL;

    UHCI_ASSERT(DeviceData, DeviceData->BulkQueueHead->HwQH.HLink.Terminate);
    //link the td to the QH
    DeviceData->BulkQueueHead->HwQH.VLink.HwAddress = Td->PhysicalAddress;
}

USB_MINIPORT_STATUS
UhciInitializeSchedule(
    IN PDEVICE_DATA DeviceData,
    IN PUCHAR StaticQHs,
    IN HW_32BIT_PHYSICAL_ADDRESS StaticQHsPhys
    )
/*++

Routine Description:

    Build the schedule of static Eds

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    ULONG length;
    ULONG i;
    PHCD_QUEUEHEAD_DESCRIPTOR controlQh, bulkQh, qh;
    PHCD_TRANSFER_DESCRIPTOR td;
    QH_LINK_POINTER newLink;

    // Allocate staticly disabled QHs, and set head pointers for
    // scheduling lists
    //
    // The static ED list is contains all the static interrupt QHs (64)
    // plus the static ED for bulk and control (2)
    //
    // the array looks like this:
    //  1, 2, 2, 4, 4, 4, 4, 8,
    //  8, 8, 8, 8, 8, 8, 8,16,
    // 16,16,16,16,16,16,16,16,
    // 16,16,16,16,16,16,16,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,
    // CONTROL
    // BULK

    // each static ED points to another static ED
    // (except for the 1ms ed) the INDEX of the next
    // ED in the StaticEDList is stored in NextIdx,
    // these values are constent
/*    CHAR nextIdxTable[63] = {
             // 0  1  2  3  4  5  6  7
     (CHAR)ED_EOF, 0, 0, 1, 1, 2, 2, 3,
             // 8  9 10 11 12 13 14 15
                3, 4, 4, 5, 5, 6, 6, 7,
             //16 17 18 19 20 21 22 23
                7, 8, 8, 9, 9,10,10,11,
             //24 25 26 27 28 29 30 31
               11,12,12,13,13,14,14,15,
             //32 33 34 35 36 37 38 39
               15,16,16,17,17,18,18,19,
             //40 41 42 43 44 45 46 47
               19,20,20,21,21,22,22,23,
             //48 49 50 51 52 53 54 55
               23,24,24,25,25,26,26,27,
             //56 57 58 59 60 61 62 63
               27,28,28,29,29,30,30
    };

/*
    Numbers are the index into the static ed table

    (31) -\
          (15)-\
    (47) -/     \
                (7 )-\
    (39) -\     /     \
          (23)-/       \
    (55) -/             \
                        (3)-\
    (35) -\             /    \
          (19)-\       /      \
    (51) -/     \     /        \
                (11)-/          \
    (43) -\     /                \
          (27)-/                  \
    (59) -/                        \
                                   (1)-\
    (33) -\                        /    \
          (17)-\                  /      \
    (49) -/     \                /        \
                (9 )-\          /          \
    (41) -\     /     \        /            \
          (25)-/       \      /              \
    (57) -/             \    /                \
                        (5)-/                  \
    (37) -\             /                       \
          (21)-\       /                         \
    (53) -/     \     /                           \
                (13)-/                             \
    (45) -\     /                                   \
          (29)-/                                     \
    (61) -/                                           \
                                                      (0)
    (32) -\                                           /
          (16)-\                                     /
    (48) -/     \                                   /
                (8 )-\                             /
    (40) -\     /     \                           /
          (24)-/       \                         /
    (56) -/             \                       /
                        (4)-\                  /
    (36) -\             /    \                /
          (20)-\       /      \              /
    (52) -/     \     /        \            /
                (12)-/          \          /
    (44) -\     /                \        /
          (28)-/                  \      /
    (60) -/                        \    /
                                   (2)-/
    (34) -\                        /
          (18)-\                  /
    (50) -/     \                /
                (10)-\          /
    (42) -\     /     \        /
          (26)-/       \      /
    (58) -/             \    /
                        (6)-/
    (38) -\             /
          (22)-\       /
    (54) -/     \     /
                (14)-/
    (46) -\     /
          (30)-/
    (62) -/
*/

    // corresponding offsets for the 32ms list heads in the
    // HCCA -- these are entries 31..62
    CHAR NextQH[] = {
        0,
        0, 0,
        1, 2, 1, 2,
        3, 4, 5, 6, 3, 4, 5, 6,
        7, 8, 9, 10, 11, 12, 13, 14, 7, 8, 9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30};

    UhciKdPrint((DeviceData, 2, "'Initializing schedule.\n"));

    //
    // initailze all interrupt QHs
    // Step through all the interrupt levels:
    // 1ms, 2ms, 4ms, 8ms, 16ms, 32ms and...
    // Initialize each interrupt queuehead,
    // Set up the tree above.
    //
    for (i=0; i<NO_INTERRUPT_QH_LISTS; i++) {
        //
        // Carve QHs from the common buffer
        //
        qh = (PHCD_QUEUEHEAD_DESCRIPTOR) StaticQHs;

        RtlZeroMemory(qh, sizeof(*qh));
        qh->PhysicalAddress = StaticQHsPhys;
        // this will never point to a TD
        qh->HwQH.VLink.Terminate = 1;
        qh->Sig = SIG_HCD_IQH;

        DeviceData->InterruptQueueHeads[i] = qh;

        UhciSetNextQh(
            DeviceData,
            qh,
            DeviceData->InterruptQueueHeads[NextQH[i]]);

        // next QH
        StaticQHs += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
        StaticQHsPhys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    }

    //
    // allocate a QH for the Control list
    //
    controlQh = (PHCD_QUEUEHEAD_DESCRIPTOR) StaticQHs;

    RtlZeroMemory(controlQh, sizeof(*controlQh));
    controlQh->PhysicalAddress = StaticQHsPhys;

    // this will never point to a TD
    controlQh->HwQH.VLink.Terminate = 1;
    controlQh->Sig = SIG_HCD_CQH;

    // link the 1ms interrupt qh to the control qh
    UhciSetNextQh(
        DeviceData,
        DeviceData->InterruptQueueHeads[0],
        controlQh);

    DeviceData->ControlQueueHead = controlQh;

    StaticQHs += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    StaticQHsPhys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

    //
    // allocate a QH for the Bulk list
    //
    bulkQh = (PHCD_QUEUEHEAD_DESCRIPTOR) StaticQHs;

    RtlZeroMemory(bulkQh, sizeof(*bulkQh));
    bulkQh->PhysicalAddress = StaticQHsPhys;

    // link to ourselves for bandwidth reclamation, but set
    // t-bit on next qh so that we don't spin taking PCI resources
    bulkQh->HwQH.HLink.HwAddress = bulkQh->PhysicalAddress; // points to itself
    bulkQh->HwQH.HLink.QHTDSelect = 1;  // this will always point to a QH
    bulkQh->HwQH.HLink.Terminate = 1;   // Must terminate this so that we don't spin

    bulkQh->Sig = SIG_HCD_BQH;

    // link the control qh to the bulk qh
    UhciSetNextQh(
        DeviceData,
        controlQh,
        bulkQh);

    DeviceData->BulkQueueHead = DeviceData->LastBulkQueueHead = bulkQh;

    //
    // NOTE: For bulk reclamation, we make a loop of all
    // the bulk queueheads, hence it needs to point to
    // itself initially, such that when other queueheads
    // are inserted, the bulkQh will point to the last one.
    //
//    bulkQh->PrevQh = bulkQh->NextQh = bulkQh;

    StaticQHs += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    StaticQHsPhys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

#ifdef FIXPIIX4
    UhciFixPIIX4(DeviceData, (PHCD_TRANSFER_DESCRIPTOR)StaticQHs, StaticQHsPhys);
    StaticQHs += sizeof(HCD_TRANSFER_DESCRIPTOR);
    StaticQHsPhys += sizeof(HCD_TRANSFER_DESCRIPTOR);

#else
    // this will never point to a TD
    bulkQh->HwQH.VLink.Terminate = 1;
#endif

    // Put the interrupt schedule in every frame
    for (i=0; i < UHCI_MAX_FRAME; i++) {
        newLink.HwAddress = DeviceData->InterruptQueueHeads[QH_INTERRUPT_32ms + MAX_INTERVAL_MASK(i)]->PhysicalAddress;
        newLink.QHTDSelect = 1;
        *( ((PULONG) (DeviceData->FrameListVA)+i) ) = newLink.HwAddress;
    }

    //
    // Allocate the rollover td.
    //
    td = (PHCD_TRANSFER_DESCRIPTOR) StaticQHs;
    RtlZeroMemory(td, sizeof(*td));
    td->PhysicalAddress = StaticQHsPhys;

    td->Sig = SIG_HCD_RTD;
    td->HwTD.Control.Active = 0;
    td->HwTD.Control.InterruptOnComplete = 1;
    td->HwTD.LinkPointer.HwAddress = DeviceData->InterruptQueueHeads[QH_INTERRUPT_32ms]->PhysicalAddress;
    td->HwTD.LinkPointer.QHTDSelect = 1;
    td->HwTD.Buffer = 0x0badf00d;

    // VIA Host Controller requires a valid PID even if the TD is inactive
    td->HwTD.Token.Pid = InPID;
    DeviceData->RollOverTd = td;

    StaticQHs += sizeof(HCD_TRANSFER_DESCRIPTOR);
    StaticQHsPhys += sizeof(HCD_TRANSFER_DESCRIPTOR);

    // sof TDs
    length = sizeof(HCD_TRANSFER_DESCRIPTOR)*8;
    DeviceData->SofTdList = (PHCD_TD_LIST) StaticQHs;
    for (i=0; i<SOF_TD_COUNT; i++) {
        td = &DeviceData->SofTdList->Td[i];

        td->Sig = SIG_HCD_SOFTD;
        // use transferconext to hold req frame
        td->RequestFrame = 0;
        td->PhysicalAddress = StaticQHsPhys;
        td->HwTD.Control.Active = 0;
        td->HwTD.Control.InterruptOnComplete = 1;
        td->HwTD.LinkPointer.HwAddress =
            DeviceData->InterruptQueueHeads[QH_INTERRUPT_32ms]->PhysicalAddress;
        td->HwTD.LinkPointer.QHTDSelect = 1;
        td->HwTD.Buffer = 0x0badf00d;

        StaticQHsPhys+=sizeof(HCD_TRANSFER_DESCRIPTOR);
    }
    StaticQHs += length;

    mpStatus = USBMP_STATUS_SUCCESS;

    return mpStatus;
}


VOID
UhciGetRegistryParameters(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // nothing
}


VOID
USBMPFN
UhciStopController(
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN HwPresent
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USBCMD cmd;
    USBSTS status;
    USHORT legsup;
    PHC_REGISTER reg = DeviceData->Registers;
    LARGE_INTEGER finishTime, currentTime;

    UhciKdPrint((DeviceData, 2, "'Stop controller.\n"));
    cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);

    UHCI_ASSERT(DeviceData, DeviceData->SynchronizeIsoCleanup == 0);

    if (cmd.us == UHCI_HARDWARE_GONE) {
        LOGENTRY(DeviceData, G, '_hwG', cmd.us, 0, 0);
        UhciKdPrint((DeviceData, 0, "'Stop controller, hardware gone.\n"));
        return;
    }

    LOGENTRY(DeviceData, G, '_stp', cmd.us, 0, 0);

    if (cmd.GlobalReset) {
        // Some bioses leave the host controller in reset, such that
        // UhciResumeController fails. In response to this, UsbPort
        // stops and restarts the controller. We therefore have to
        // make sure and turn reset off.
        cmd.GlobalReset = 0;
        WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);
    }

    // Set host controller reset, just like on W2K.
    cmd.HostControllerReset = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);

    KeQuerySystemTime(&finishTime);
    // no spec'ed time -- we will graciously grant 0.1 sec.
    //
    // figure when we quit (.1 seconds later)
    finishTime.QuadPart += 100000;

    // wait for reset bit to go to zero
    cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    while (cmd.HostControllerReset) {

        KeQuerySystemTime(&currentTime);

        if (currentTime.QuadPart >= finishTime.QuadPart) {
            // timeout
            UhciKdPrint((DeviceData, 0,
                "'UHCI controller failed to reset in .1 sec!\n"));

            TEST_TRAP();

            break;
        }

        cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);

    }

#if 0
    //
    // change the state of the PIrQD routing bit
    //
    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &legsup,
        LEGACY_BIOS_REGISTER,
        sizeof(legsup));

    LOGENTRY(DeviceData, G, '_leg', 0, legsup, 0);
    // clear the PIRQD routing bit
    legsup &= ~LEGSUP_USBPIRQD_EN;

    USBPORT_WRITE_CONFIG_SPACE(
        DeviceData,
        &legsup,
        LEGACY_BIOS_REGISTER,
        sizeof(legsup));
#endif
}

USB_MINIPORT_STATUS
USBMPFN
UhciStartController(
    IN PDEVICE_DATA DeviceData,
    IN PHC_RESOURCES HcResources
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus = USBMP_STATUS_SUCCESS;
    PHC_REGISTER reg = NULL;
    USBCMD cmd;

    UhciKdPrint((DeviceData, 2, "'Start controller.\n"));

    DeviceData->Sig = SIG_UHCI_DD;
    DeviceData->ControllerFlavor = HcResources->ControllerFlavor;

    // hand over the USB controller.
    mpStatus = UhciStopBIOS(DeviceData, HcResources);

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        // got resources and schedule
        // init the controller
        mpStatus = UhciInitializeHardware(DeviceData);
    }

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        // inialize static Queue Heads
        PUCHAR staticQHs;
        HW_32BIT_PHYSICAL_ADDRESS staticQHsPhys;

        staticQHs = HcResources->CommonBufferVa;
        staticQHsPhys = HcResources->CommonBufferPhys;

        //
        // allocate a frame list
        //
        DeviceData->FrameListVA = (PHW_32BIT_PHYSICAL_ADDRESS) staticQHs;
        DeviceData->FrameListPA = staticQHsPhys;

        // Increment the buffers past the frame list.
        staticQHs += UHCI_MAX_FRAME*sizeof(HW_32BIT_PHYSICAL_ADDRESS);
        staticQHsPhys += UHCI_MAX_FRAME*sizeof(HW_32BIT_PHYSICAL_ADDRESS);

        // set up the schedule
        mpStatus = UhciInitializeSchedule(DeviceData,
                                          staticQHs,
                                          staticQHsPhys);
        DeviceData->SynchronizeIsoCleanup = 0;
    }

    reg = DeviceData->Registers;

    // program the frame list
    WRITE_PORT_ULONG(&reg->FrameListBasePhys.ul, DeviceData->FrameListPA);
    UhciKdPrint((DeviceData, 2, "'FLBA %x\n", DeviceData->FrameListPA));

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        // start the controller
        cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);
        LOGENTRY(DeviceData, G, '_run', cmd.us, 0, 0);
        cmd.RunStop = 1;
        WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);

        // sanity check the port status bits
        // clear the suspend bit if set, sometimes it sticks
        // across a reboot.
        {
        PORTSC port;
        ULONG i;

        for (i=0; i<2; i++) {
            port.us = READ_PORT_USHORT(&reg->PortRegister[i].us);
            //mask the change bits so we don't kill them
            port.PortConnectChange = 0;

            port.Suspend = 0;
            WRITE_PORT_USHORT(&reg->PortRegister[i].us, port.us);
        }
        }

        ActivateRolloverTd(DeviceData);
    } else {

        DEBUG_BREAK(DeviceData);
    }

    return mpStatus;
}

USB_MINIPORT_STATUS
UhciOpenEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG i, numTds;
    ULONG bytes;
    ULONG bufferSize;
    PHCD_TRANSFER_DESCRIPTOR td;

    LOGENTRY(DeviceData, G, '_opC', 0, 0, EndpointParameters);
    UhciKdPrint((DeviceData, 2, "'Open endpoint 0x%x.\n", EndpointData));

    EndpointData->Sig = SIG_EP_DATA;
    // save a copy of the parameters
    EndpointData->Parameters = *EndpointParameters;
    EndpointData->Flags = 0;
    EndpointData->PendingTransfers = 0;

    InitializeListHead(&EndpointData->DoneTdList);
   
    EndpointData->Toggle = DataToggle0;
    // Control and isoch can not halt
    if (EndpointParameters->TransferType == Control ||
        EndpointParameters->TransferType == Isochronous) {
        SET_FLAG(EndpointData->Flags, UHCI_EDFLAG_NOHALT);
    }

    // how much did we get
    bytes = EndpointParameters->CommonBufferBytes;
    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;

    if (EndpointParameters->TransferType != Isochronous) {
        //
        // make the Queue Head for this async endpoint
        //
        EndpointData->QueueHead = qh = (PHCD_QUEUEHEAD_DESCRIPTOR) buffer;

        qh->PhysicalAddress = phys;
        qh->HwQH.VLink.Terminate = 1;
        qh->EndpointData = EndpointData;
        qh->Sig = SIG_HCD_QH;

        qh->NextQh = qh->PrevQh = qh;

        buffer += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
        phys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
        bytes -= sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    }

    //
    // Make the double buffers for page boundary transfers
    //
    EndpointData->DbList = (PDOUBLE_BUFFER_LIST) buffer;
    EndpointData->DbsUsed = 0;

    switch (EndpointParameters->TransferType) {
    case Control:
        UhciQueryControlRequirements(DeviceData,
                                     EndpointParameters,
                                     &numTds,
                                     &EndpointData->DbCount);
        break;
    case Bulk:
        UhciQueryBulkRequirements(DeviceData,
                                  EndpointParameters,
                                  &numTds,
                                  &EndpointData->DbCount);
        break;
    case Interrupt:
        UhciQueryInterruptRequirements(DeviceData,
                                       EndpointParameters,
                                       &numTds,
                                       &EndpointData->DbCount);
        break;
    case Isochronous:
        UhciQueryIsoRequirements(DeviceData,
                                 EndpointParameters,
                                 &numTds,
                                 &EndpointData->DbCount);
        break;
    default:
        TEST_TRAP();
        return USBMP_STATUS_NOT_SUPPORTED;
    }

    bufferSize = (EndpointParameters->TransferType == Isochronous) ?
        sizeof(ISOCH_TRANSFER_BUFFER) :
        sizeof(ASYNC_TRANSFER_BUFFER);
    RtlZeroMemory(&EndpointData->DbList->Async[0],
                  EndpointData->DbCount*bufferSize);

    for (i=0; i<EndpointData->DbCount; i++) {
        if (EndpointParameters->TransferType == Isochronous) {
            EndpointData->DbList->Isoch[i].PhysicalAddress = phys;
            EndpointData->DbList->Isoch[i].Sig = SIG_HCD_IDB;
        } else {
            EndpointData->DbList->Async[i].PhysicalAddress = phys;
            EndpointData->DbList->Async[i].Sig = SIG_HCD_ADB;
        }

        phys += bufferSize;
    }

    buffer += EndpointData->DbCount*bufferSize;
    bytes -= EndpointData->DbCount*bufferSize;

    //
    // Make the transfer descriptors
    //
    EndpointData->TdsUsed = 0;
    EndpointData->TdList = (PHCD_TD_LIST) buffer;
    EndpointData->TdCount = bytes/sizeof(HCD_TRANSFER_DESCRIPTOR);
    RtlZeroMemory(EndpointData->TdList,
                  EndpointData->TdCount*sizeof(HCD_TRANSFER_DESCRIPTOR));
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        td->PhysicalAddress = phys;
        td->Sig = SIG_HCD_TD;
        td->TransferContext = UHCI_BAD_POINTER;

        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);
    }

    // make sure we have enough
    UHCI_ASSERT(DeviceData, EndpointData->TdCount >= numTds);

    // current head, tail are NULL TD
    EndpointData->HeadTd = EndpointData->TailTd = NULL;

    return USBMP_STATUS_SUCCESS;
}


VOID
UhciCloseEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    TEST_TRAP();
}


USB_MINIPORT_STATUS
UhciPokeEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG oldBandwidth;

    LOGENTRY(DeviceData, G, '_Pok', EndpointData,
        EndpointParameters, 0);
    UhciKdPrint((DeviceData, 2, "'Poke Endpoint 0x%x.\n", EndpointData));

    qh = EndpointData->QueueHead;

    oldBandwidth = EndpointData->Parameters.Bandwidth;
    EndpointData->Parameters = *EndpointParameters;

//    qh->HwQH.EpChars.DeviceAddress = EndpointData->Parameters.DeviceAddress;

//    qh->HwQH.EpChars.MaximumPacketLength = EndpointData->Parameters.MaxPacketSize;

    return USBMP_STATUS_SUCCESS;
}


ULONG
UhciQueryControlRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    )
/*++

Routine Description:

    computes requirents and returns the number of
    common buffer bytes required for a control
    endpoint.

Arguments:

Return Value:

    control buffer bytes needed

--*/
{
    ULONG minCommonBufferBytes;

    *NumberOfTDs =
        EndpointParameters->MaxTransferSize/EndpointParameters->MaxPacketSize+2;

    // Add one more double buffer for the setup packet.
    *NumberOfDoubleBuffers = 1 +
        (EndpointParameters->MaxTransferSize + USB_PAGE_SIZE - 1)/USB_PAGE_SIZE;

    minCommonBufferBytes =
        sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
        *NumberOfTDs*sizeof(HCD_TRANSFER_DESCRIPTOR) +
        *NumberOfDoubleBuffers*sizeof(ASYNC_TRANSFER_BUFFER);

    LOGENTRY(DeviceData, G, '_QeC',
        minCommonBufferBytes,
        *NumberOfTDs,
        *NumberOfDoubleBuffers);

    return minCommonBufferBytes;
}


ULONG
UhciQueryIsoRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    )
/*++

Routine Description:

    computes requirents and returns the number of
    common buffer bytes required for an iso
    endpoint.

Arguments:

Return Value:

    iso buffer bytes needed

--*/
{
    ULONG minCommonBufferBytes;

    // we need enough TDs for two transfers of MAX_ISO_PACKETS_PER_TRANSFER
    // our max size will be set a MAX_ISOCH_TRANSFER_SIZE so we will never
    // see a transfer larger than MAX_ISOCH_TRANSFER_SIZE or more packets
    // than MAX_ISO_PACKETS_PER_TRANSFER

    // comput TDs base on number of packets per request
    *NumberOfTDs = MAX_ISO_PACKETS_PER_TRANSFER*2;

    // compute double buffers based on largest transfer
    *NumberOfDoubleBuffers =
        (MAX_ISOCH_TRANSFER_SIZE+USB_PAGE_SIZE-1)/USB_PAGE_SIZE;

    minCommonBufferBytes =
        *NumberOfTDs*sizeof(HCD_TRANSFER_DESCRIPTOR) +
        *NumberOfDoubleBuffers*sizeof(ISOCH_TRANSFER_BUFFER);

    LOGENTRY(DeviceData, G, '_QeI',
        minCommonBufferBytes,
        *NumberOfTDs,
        *NumberOfDoubleBuffers);


    return minCommonBufferBytes;
}


ULONG
UhciQueryBulkRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    )
/*++

Routine Description:

    computes requirents and returns the number of
    common buffer bytes required for an iso
    endpoint.

Arguments:

Return Value:

    iso buffer bytes needed

--*/
{
    ULONG minCommonBufferBytes;

     //
     // Need enough for two transfers on the hardware.
     //

    *NumberOfTDs =
        2*MAX_BULK_TRANSFER_SIZE/EndpointParameters->MaxPacketSize;
    *NumberOfDoubleBuffers =
        2*(MAX_BULK_TRANSFER_SIZE + USB_PAGE_SIZE - 1)/USB_PAGE_SIZE;

    minCommonBufferBytes =
        sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
        *NumberOfTDs*sizeof(HCD_TRANSFER_DESCRIPTOR) +
        *NumberOfDoubleBuffers*sizeof(ASYNC_TRANSFER_BUFFER);

    LOGENTRY(DeviceData, G, '_QeB',
        minCommonBufferBytes,
        *NumberOfTDs,
        *NumberOfDoubleBuffers);

    return minCommonBufferBytes;
}


ULONG
UhciQueryInterruptRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    )
/*++

Routine Description:

    computes requirents and returns the number of
    common buffer bytes required for an interrupt
    endpoint.

Arguments:

Return Value:

    interrupt buffer bytes needed

--*/
{
    ULONG minCommonBufferBytes;

    //
    // Since we now have split transfer support, we don't need to allocate
    // that many tds.
    //

    *NumberOfTDs = 2*MAX_INTERRUPT_TDS_PER_TRANSFER;
    *NumberOfDoubleBuffers =
        2*((EndpointParameters->MaxPacketSize*MAX_INTERRUPT_TDS_PER_TRANSFER) +
           USB_PAGE_SIZE - 1)/USB_PAGE_SIZE;

    minCommonBufferBytes =
        sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
        *NumberOfTDs*sizeof(HCD_TRANSFER_DESCRIPTOR) +
        *NumberOfDoubleBuffers*sizeof(ASYNC_TRANSFER_BUFFER);

    LOGENTRY(DeviceData, G, '_QeI',
        minCommonBufferBytes,
        *NumberOfTDs,
        *NumberOfDoubleBuffers);

    return minCommonBufferBytes;
}


USB_MINIPORT_STATUS
UhciQueryEndpointRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_REQUIREMENTS EndpointRequirements
    )
/*++

Routine Description:

    compute how much common buffer we will need
    for this endpoint

Arguments:

Return Value:

--*/
{
    ULONG numTds, numDbs;

    EndpointRequirements->MaximumTransferSize =
        EndpointParameters->MaxTransferSize;

    LOGENTRY(DeviceData, G, '_Qep',
            EndpointRequirements->MaximumTransferSize,
            EndpointParameters->TransferType, 0);

    switch (EndpointParameters->TransferType) {

    case Control:
        //
        // Need enough for one full transfer.
        //
        EndpointRequirements->MinCommonBufferBytes =
            UhciQueryControlRequirements(DeviceData,
                                         EndpointParameters,
                                         &numTds,
                                         &numDbs);
        break;

    case Interrupt:

        EndpointRequirements->MinCommonBufferBytes =
            UhciQueryInterruptRequirements(DeviceData,
                                           EndpointParameters,
                                           &numTds,
                                           &numDbs);

        EndpointRequirements->MaximumTransferSize =
            EndpointParameters->MaxPacketSize*MAX_INTERRUPT_TDS_PER_TRANSFER;

        break;

    case Bulk:

        EndpointRequirements->MinCommonBufferBytes =
            UhciQueryBulkRequirements(DeviceData,
                                      EndpointParameters,
                                      &numTds,
                                      &numDbs);

        EndpointRequirements->MaximumTransferSize =
            MAX_BULK_TRANSFER_SIZE;
        break;

    case Isochronous:

        EndpointRequirements->MinCommonBufferBytes =
            UhciQueryIsoRequirements(DeviceData,
                                         EndpointParameters,
                                         &numTds,
                                         &numDbs);

        EndpointRequirements->MaximumTransferSize =
            MAX_ISOCH_TRANSFER_SIZE;
        break;

    default:
        TEST_TRAP();
        return USBMP_STATUS_NOT_SUPPORTED;
    }

    LOGENTRY(DeviceData, G, '_QER',
            numTds,
            numDbs,
            EndpointRequirements->MinCommonBufferBytes);

    return USBMP_STATUS_SUCCESS;
}


VOID
UhciPollEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    switch(EndpointData->Parameters.TransferType) {

    case Control:
    case Bulk:
    case Interrupt:
        UhciPollAsyncEndpoint(DeviceData, EndpointData);
        break;

    case Isochronous:
        UhciPollIsochEndpoint(DeviceData, EndpointData);
        break;

    default:
        TEST_TRAP();

    }
}


PHCD_TRANSFER_DESCRIPTOR
UhciAllocTd(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Allocate a TD from an endpoint's pool

Arguments:

Return Value:

--*/
{
    ULONG i,j;
    PHCD_TRANSFER_DESCRIPTOR td;

    for (i=EndpointData->TdLastAllocced, j=0;
         j<EndpointData->TdCount;
         j++, i = (i+1 < EndpointData->TdCount) ? i+1 : 0) {
        td = &EndpointData->TdList->Td[i];

        if (!TEST_FLAG(td->Flags, TD_FLAG_BUSY)) {
            SET_FLAG(td->Flags, TD_FLAG_BUSY);
            LOGENTRY(DeviceData, G, '_aTD', td, 0, 0);
            EndpointData->TdLastAllocced = i;
            EndpointData->TdsUsed++;
            return td;
        }
    }

    // we should always find one
    UHCI_ASSERT(DeviceData, FALSE);
    TRAP_FATAL_ERROR();
    return UHCI_BAD_POINTER;
}

PTRANSFER_BUFFER
UhciAllocDb(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN BOOLEAN Isoch
    )
/*++

Routine Description:

    Allocate a double buffer from an endpoint's pool

Arguments:

Return Value:

--*/
{
    ULONG i,j;
    PISOCH_TRANSFER_BUFFER idb;
    PASYNC_TRANSFER_BUFFER adb;

    for (i=EndpointData->DbLastAllocced, j=0;
         j<EndpointData->DbCount;
         j++, i = (i+1 < EndpointData->DbCount) ? i+1 : 0) {
        if (Isoch) {
            idb = &EndpointData->DbList->Isoch[i];
            if (!TEST_FLAG(idb->Flags, DB_FLAG_BUSY)) {
                SET_FLAG(idb->Flags, DB_FLAG_BUSY);
                LOGENTRY(DeviceData, G, '_iDB', idb, 0, 0);
                EndpointData->DbLastAllocced = i;
                EndpointData->DbsUsed++;
                UHCI_ASSERT(DeviceData, idb->Sig == SIG_HCD_IDB);
                return (PTRANSFER_BUFFER)idb;
            }
        } else {
            adb = &EndpointData->DbList->Async[i];
            if (!TEST_FLAG(adb->Flags, DB_FLAG_BUSY)) {
                SET_FLAG(adb->Flags, DB_FLAG_BUSY);
                LOGENTRY(DeviceData, G, '_aDB', adb, 0, 0);
                EndpointData->DbLastAllocced = i;
                EndpointData->DbsUsed++;
                UHCI_ASSERT(DeviceData, adb->Sig == SIG_HCD_ADB);
                return (PTRANSFER_BUFFER)adb;
            }
        }
    }

    // we should always find one
    UHCI_ASSERT(DeviceData, FALSE);
    TRAP_FATAL_ERROR();
    return UHCI_BAD_POINTER;
}

VOID
UhciSetEndpointStatus(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATUS Status
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_REGISTER hc;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    qh = EndpointData->QueueHead;

    LOGENTRY(DeviceData, G, '_set', EndpointData, Status, 0);
    UhciKdPrint((DeviceData, 2, "'Set Endpoint 0x%x Status %x.\n",
                 EndpointData, Status));

    switch(Status) {
    case ENDPOINT_STATUS_RUN:
        if (TEST_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED)) {
            CLEAR_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED);
            // Next transfer or status phase of a control transfer.
            SET_QH_TD(DeviceData, EndpointData, EndpointData->HeadTd);
        }
        break;

    case ENDPOINT_STATUS_HALT:
        TEST_TRAP();
        break;
    }
}


MP_ENDPOINT_STATUS
UhciGetEndpointStatus(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MP_ENDPOINT_STATUS status;

    UhciKdPrint((DeviceData, 2, "'Get Endpoint status 0x%x.\n", EndpointData));
    status = ENDPOINT_STATUS_RUN;

    if (TEST_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED)) {
        status = ENDPOINT_STATUS_HALT;
    }

    LOGENTRY(DeviceData, G, '_ges', EndpointData, status, 0);

    return status;
}


VOID
UhciSetEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    LOGENTRY(DeviceData, G, '_ses', EndpointData, 0, State);

    UhciKdPrint((DeviceData, 2, "'Set Endpoint 0x%x state %x.\n", EndpointData, State));
    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Bulk:
    case Interrupt:
        UhciSetAsyncEndpointState(DeviceData,
                                  EndpointData,
                                  State);
        break;
    case Isochronous:
        UhciSetIsochEndpointState(DeviceData,
                                  EndpointData,
                                  State);

        break;
    default:
        TRAP_FATAL_ERROR();
    }

}


MP_ENDPOINT_STATE
UhciGetEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MP_ENDPOINT_STATE currentState;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    // assume we are active
    currentState = ENDPOINT_ACTIVE;

    qh = EndpointData->QueueHead;

    // removed from schedule?
    if (!TEST_FLAG(qh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE)) {
        // yes
        currentState = TEST_FLAG(qh->QhFlags, UHCI_QH_FLAG_QH_REMOVED) ?
                ENDPOINT_REMOVE : ENDPOINT_PAUSE;
    }

    UhciKdPrint((DeviceData, 2, "'Get Endpoint 0x%x state %x.\n", EndpointData, currentState));

    LOGENTRY(DeviceData, G, '_ges', EndpointData, 0, currentState);

    return currentState;
}


ULONG
UhciGet32BitFrameNumber(
    IN PDEVICE_DATA DeviceData
    )
{
    ULONG n, fn, hp;
    PHC_REGISTER reg = NULL;

    reg = DeviceData->Registers;
    fn = READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;
    hp = DeviceData->FrameNumberHighPart;
    n = fn | (hp + ((hp ^ fn) & 0x400));

    return n;
}

VOID
UhciUpdateCounter(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    Updates the 32 bit frame counter.

Arguments:

Return Value:

--*/
{
    PHC_REGISTER reg = DeviceData->Registers;
    ULONG fn, hp;

    //
    // This code maintains the 32-bit 1 ms frame counter
    //
    fn = READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;
    hp = DeviceData->FrameNumberHighPart;
    if ((fn & 0x7FF) != fn) {
        UhciKdPrint((DeviceData, 0, "UhciUpdateCounter framenumber gone: %x.\n", fn));
        return;
    }

    // did the sign bit change ?
    if ((hp&0X400) != (fn&0X400)) {
        // Yes
        DeviceData->FrameNumberHighPart += 0x400;
    }
    // remember the last frame number
//    DeviceData->LastFrameCounter = fn;
}

VOID
UhciPollController(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_REGISTER reg = NULL;
    FRNUM frameIndex;
    USHORT i, frame;
    QH_LINK_POINTER newLink;
    PLIST_ENTRY listEntry;
    PENDPOINT_DATA endpointData;


    // this also cleans out the SOF Tds and
    // the rollover Td so we always run it
    UhciCleanOutIsoch(DeviceData, FALSE);

    //
    // Update the 32 bit frame counter here so we don't
    // need a rollover interrupt.
    //
    UhciUpdateCounter(DeviceData);

    //
    // Notify the port driver to check the ports
    // for any connects/disconnects.
    //
    USBPORT_INVALIDATE_ROOTHUB(DeviceData);
}


USB_MINIPORT_STATUS
UhciSubmitTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    )
{
    USB_MINIPORT_STATUS mpStatus = USBMP_STATUS_FAILURE;

    IncPendingTransfers(DeviceData, EndpointData);

    // init the context
    RtlZeroMemory(TransferContext, sizeof(*TransferContext));
    TransferContext->Sig = SIG_UHCI_TRANSFER;
    TransferContext->UsbdStatus = USBD_STATUS_SUCCESS;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = TransferParameters;

    switch (EndpointData->Parameters.TransferType) {
    case Control:
        mpStatus = UhciControlTransfer(
                        DeviceData,
                        EndpointData,
                        TransferParameters,
                        TransferContext,
                        TransferSGList);
        break;
    case Interrupt:
    case Bulk:
        mpStatus = UhciBulkOrInterruptTransfer(
                        DeviceData,
                        EndpointData,
                        TransferParameters,
                        TransferContext,
                        TransferSGList);
        break;
    default:
        TEST_TRAP();
        mpStatus = USBMP_STATUS_SUCCESS;
    }

    return mpStatus;
}


VOID
UhciAbortTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext,
    OUT PULONG BytesTransferred
    )
{
    UhciKdPrint((DeviceData, 2, "'Abort transfer 0x%x for EP 0x%x.\n", TransferContext, EndpointData));

    DecPendingTransfers(DeviceData, EndpointData);

    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Interrupt:
    case Bulk:
        UhciAbortAsyncTransfer(
            DeviceData,
            EndpointData,
            TransferContext,
            BytesTransferred);
        break;
    default:
        UhciAbortIsochTransfer(
            DeviceData,
            EndpointData,
            TransferContext);
    }
}


USB_MINIPORT_STATUS
UhciPassThru (
    IN PDEVICE_DATA DeviceData,
    IN GUID *FunctionGuid,
    IN ULONG ParameterLength,
    IN OUT PVOID Parameters
    )
{
    //TEST_TRAP();
    return USBMP_STATUS_NOT_SUPPORTED;
}


VOID
UhciSetEndpointDataToggle(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN ULONG Toggle
    )
/*++

Routine Description:

Arguments:

    Sent after a pipe reset to reset the toggle.

Return Value:

--*/

{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHCD_TRANSFER_DESCRIPTOR td;

    UhciKdPrint((DeviceData, 2, "'Pipe reset. Set endpoint data toggle. EP %x\n", EndpointData));
//    TEST_TRAP();
    if (EndpointData->Parameters.TransferType == Control ||
        EndpointData->Parameters.TransferType == Isochronous) {

        // nothing to do for control and iso
        return;
    }

    qh = EndpointData->QueueHead;

    UHCI_ASSERT(DeviceData, 0 == Toggle);
    for (td = EndpointData->HeadTd; td; td = td->NextTd) {
        td->HwTD.Token.DataToggle = Toggle;
        Toggle = !Toggle;
    }
    EndpointData->Toggle = Toggle;

    LOGENTRY(DeviceData, G, '_stg', EndpointData, 0, Toggle);
}


USB_MINIPORT_STATUS
USBMPFN
UhciStartSendOnePacket(
    IN PDEVICE_DATA DeviceData,
    IN PMP_PACKET_PARAMETERS PacketParameters,
    IN PUCHAR PacketData,
    IN PULONG PacketLength,
    IN PUCHAR WorkspaceVirtualAddress,
    IN HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    IN ULONG WorkspaceLength,
    IN OUT USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

    insert structures to transmit a single packet -- this is for debug
    tool purposes only so we can be a little creative here.

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR staticControlQH;
    PHW_QUEUE_HEAD hwQH;
    ULONG hwQHPhys;
    PUCHAR pch;
    ULONG phys;
    LONG bytesRemaining;
    ULONG currentToggle;
    PHW_QUEUE_ELEMENT_TD currentTD;
    PUCHAR data;
    ULONG dataPhys;
    ULONG currentTDPhys, nextTDPhys;
    ULONG tdsPhys;
    PHW_QUEUE_ELEMENT_TD tds;
    ULONG neededTDs;
    ULONG neededBytes;
    QH_LINK_POINTER newQHLink;

    PSS_PACKET_CONTEXT context;

    //
    // Divide the workspace buffer into a context, a queuehead,
    //  transfer descriptors and the actual data.  First, calculate
    //  if we'll have enough size.  Assuming for now that all we have is
    //  a page to work with at most.
    //

    ASSERT(WorkspaceLength <= PAGE_SIZE);

    //
    // Calculate the number of transfer descriptors that might be needed.
    //  Similar support in the OHCI driver allows multiple packets to be
    //  sent in one data transmission.  That behavior should be mimiced here.
    //

    if (0 != *PacketLength) {
        neededTDs = *PacketLength/PacketParameters->MaximumPacketSize;

        if (neededTDs*PacketParameters->MaximumPacketSize < *PacketLength) {
            neededTDs++;
        }
    }
    else {
        neededTDs = 1;
    }

    neededBytes = sizeof(SS_PACKET_CONTEXT) + sizeof(HW_QUEUE_HEAD) +
                  neededTDs*sizeof(HW_QUEUE_ELEMENT_TD) + *PacketLength;

    if (neededBytes > WorkspaceLength) {
        return USBMP_STATUS_NO_RESOURCES;
    }

    //
    // Carve up the buffer.  Put the context first, followed by the TDs,
    //  the queuehead, and finally the data.  Put the queuehead after the TDs,
    //  to ensure that the queuehead is 16-byte aligned.  This also always the
    //  data size to be 8 bytes larger.
    //

    phys = WorkspacePhysicalAddress;
    pch  = WorkspaceVirtualAddress;
    bytesRemaining = WorkspaceLength;

    LOGENTRY(DeviceData, G, '_ssS', phys, 0, pch);

    //
    // The context contains any information we need in the end packet
    //  routine.
    //

    context = (PSS_PACKET_CONTEXT) pch;
    phys    += sizeof(SS_PACKET_CONTEXT);
    pch     += sizeof(SS_PACKET_CONTEXT);

    //
    // Next the TDs,
    //

    tdsPhys = phys;
    tds     = (PHW_QUEUE_ELEMENT_TD) pch;
    phys    += neededTDs*sizeof(HW_QUEUE_ELEMENT_TD);
    pch     += neededTDs*sizeof(HW_QUEUE_ELEMENT_TD);

    //
    // Now the QueueHead
    //

    hwQHPhys = phys;
    hwQH     = (PHW_QUEUE_HEAD) pch;
    phys     += sizeof(HW_QUEUE_HEAD);
    pch      += sizeof(HW_QUEUE_HEAD);

    //
    // Get the data buffer pointers if there is data to send
    //

    if (0 != *PacketLength) {
        dataPhys = phys;
        data     = pch;

        RtlCopyMemory(data, PacketData, *PacketLength);
    }
    else {
        data     = NULL;
        dataPhys = 0;
    }

    LOGENTRY(DeviceData, G, '_ssD', PacketData, *PacketLength, 0);

    //
    // Start by setting up the QueueHead.  Set the terminate bit of
    //  the horizontal pointer.  The vertical pointer should point to
    //  the td that is to be used
    //
    //

    RtlZeroMemory(hwQH, sizeof(HW_QUEUE_HEAD));

    hwQH->HLink.Terminate = 1;

    hwQH->VLink.HwAddress  = tdsPhys;
    hwQH->VLink.Terminate  = 0;
    hwQH->VLink.QHTDSelect = 0;
    hwQH->VLink.DepthBreadthSelect = 0;

    //
    // Save pointers to the transfer descriptors and the data
    //  in the context so we can retrieve them when ending this
    //  transfer.
    //

    HW_PTR(context->Data)    = data;
    HW_PTR(context->FirstTd) = (PUCHAR) tds;

    //
    // Now, setup the transfer descriptor to describe this transfer
    //

    currentTDPhys  = tdsPhys;
    currentTD      = tds;
    bytesRemaining = *PacketLength;

    currentToggle = PacketParameters->Toggle;

    LOGENTRY(DeviceData, G, '_ss2', tds, context, hwQH);
    LOGENTRY(DeviceData, G, '_ss3', dataPhys, data, *PacketLength);

    while (1) {

        nextTDPhys = currentTDPhys+sizeof(HW_QUEUE_ELEMENT_TD);

        RtlZeroMemory(currentTD, sizeof(HW_QUEUE_ELEMENT_TD));

        currentTD->Control.Active = 1;
        currentTD->Control.InterruptOnComplete = 0;
        currentTD->Control.IsochronousSelect = 0;
        currentTD->Control.LowSpeedDevice =
                                   (ss_Low == PacketParameters->Speed) ? 1 : 0;
        currentTD->Control.ErrorCount = 3;
        currentTD->Control.ShortPacketDetect = 1;

        currentTD->Token.DeviceAddress = PacketParameters->DeviceAddress;
        currentTD->Token.Endpoint      = PacketParameters->EndpointAddress;
        currentTD->Token.DataToggle    = currentToggle;

        if (bytesRemaining < PacketParameters->MaximumPacketSize) {
            currentTD->Token.MaximumLength = MAXIMUM_LENGTH(bytesRemaining);
        }
        else {
            currentTD->Token.MaximumLength =
                           MAXIMUM_LENGTH(PacketParameters->MaximumPacketSize);
        }

        switch (PacketParameters->Type) {
        case ss_Setup:
            LOGENTRY(DeviceData, G, '_ssU', 0, 0, 0);
            currentTD->Token.Pid = SetupPID;
            break;

        case ss_In:
            LOGENTRY(DeviceData, G, '_ssI', 0, 0, 0);
            currentTD->Token.Pid = InPID;
            break;

        case ss_Out:
            LOGENTRY(DeviceData, G, '_ssO', 0, 0, 0);
            currentTD->Token.Pid = OutPID;
            break;

        case ss_Iso_In:
        case ss_Iso_Out:
            break;
        }

        currentTD->Buffer = dataPhys;

        currentTD->LinkPointer.HwAddress = nextTDPhys;
        currentTD->LinkPointer.QHTDSelect = 0;
        currentTD->LinkPointer.DepthBreadthSelect = 1;

        if (bytesRemaining <= PacketParameters->MaximumPacketSize) {
            currentTD->LinkPointer.Terminate = 1;
            break;
        }
        else {
            currentTD->LinkPointer.Terminate = 0;
        }

        //
        // Setup for the next loop
        //

        currentTD++;
        currentTDPhys = nextTDPhys;
        bytesRemaining -= PacketParameters->MaximumPacketSize;
        dataPhys += PacketParameters->MaximumPacketSize;
        data     += PacketParameters->MaximumPacketSize;
        currentToggle = !currentToggle;
    }

    //
    // The queue head and all TDs have been linked together.  Add it
    //  to the schedule.  To mimic the OHCI behavior, we'll add it to
    //  the front of the control queue, saving off the previous link
    //  value.  By not linking to any other queue heads in the HLink,
    //  we are turning off the bulk transfers as well.
    //
    // In the EndPacket function, the control and bulk queues will be
    //  turned back on.
    //

    //
    //  Grab the static queuehead for the device
    //

    staticControlQH = DeviceData->ControlQueueHead;

    //
    // Create the new HLink pointer that will be needed to add
    //  to the static control queue head's hlink field
    //

    newQHLink.HwAddress = hwQHPhys;
    newQHLink.Terminate = 0;
    newQHLink.QHTDSelect = 1;
    newQHLink.Reserved  = 0;

    //
    // Perform an interlocked exchange to swap the current control list
    //  with the "special" queue list. Also save off the rest of the
    //  info in the context structure.
    //

    context->OldControlQH = InterlockedExchange((PLONG) &staticControlQH->HwQH.HLink,
                                                *((PLONG) &newQHLink));

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
USBMPFN
UhciEndSendOnePacket(
    IN PDEVICE_DATA DeviceData,
    IN PMP_PACKET_PARAMETERS PacketParameters,
    IN PUCHAR PacketData,
    IN PULONG PacketLength,
    IN PUCHAR WorkspaceVirtualAddress,
    IN HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    IN ULONG WorkSpaceLength,
    IN OUT USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR staticControlQH;
    PHW_QUEUE_ELEMENT_TD tdWalk;
    PSS_PACKET_CONTEXT context;
    USBD_STATUS usbdStatus;
    ULONG bytesTransferred;
    PUCHAR  data;
    BOOLEAN walkDone;

    context = (PSS_PACKET_CONTEXT) WorkspaceVirtualAddress;

    //
    // Walk the TDs on our queuehead and looking to see if this transfer is
    //  done.  This would occur if all TDs are complete, a TD had an error,
    //  or a TD completed with a short packet.
    //

    bytesTransferred = 0;
    walkDone = FALSE;
    tdWalk = (PHW_QUEUE_ELEMENT_TD) HW_PTR(context->FirstTd);

    LOGENTRY(DeviceData, G, '_ssE', tdWalk, 0, 0);

    while (!walkDone) {

        if (tdWalk->Control.Active) {
            return (USBMP_STATUS_BUSY);
        }

        usbdStatus = UhciGetErrorFromTD(DeviceData,
                                        (PHCD_TRANSFER_DESCRIPTOR) tdWalk);

        switch (usbdStatus) {
        case USBD_STATUS_ERROR_SHORT_TRANSFER:
            bytesTransferred += ACTUAL_LENGTH(tdWalk->Control.ActualLength);
            usbdStatus = USBD_STATUS_SUCCESS;
            walkDone=TRUE;
            break;

        case USBD_STATUS_SUCCESS:
            bytesTransferred += ACTUAL_LENGTH(tdWalk->Control.ActualLength);
            if (tdWalk->LinkPointer.Terminate) {
                ASSERT(bytesTransferred == *PacketLength);
                walkDone = TRUE;
            }
            break;

        default:
            bytesTransferred += ACTUAL_LENGTH(tdWalk->Control.ActualLength);
            walkDone=TRUE;
            break;
        }

        tdWalk++;
    }

    //
    // Copy the data that was transferred back to the original buffer
    //

    *PacketLength = bytesTransferred;

    if (NULL != HW_PTR(context->Data))
    {
        RtlCopyMemory(PacketData,
                      HW_PTR(context->Data),
                      *PacketLength);
    }
    LOGENTRY(DeviceData, G, '_ssX', tdWalk-1, *PacketLength, 0);

    //
    // Restore the original queue list
    //

    staticControlQH = DeviceData->ControlQueueHead;

    InterlockedExchange((PLONG) &staticControlQH->HwQH.HLink,
                        context->OldControlQH);

    //
    // Set the appropriate usbdStatus and return successful status
    //

    *UsbdStatus = usbdStatus;

    return USBMP_STATUS_SUCCESS;

}


USBD_STATUS
UhciGetErrorFromTD(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
/*++

Routine Description:

    Maps the error bits in the TD to a USBD_STATUS code

Arguments:

Return Value:

--*/

{
    if (Td->HwTD.Control.ul & CONTROL_STATUS_MASK) {
        if (Td->HwTD.Control.Stalled &&
            Td->HwTD.Control.BabbleDetected) {
            LOGENTRY(DeviceData, G, '_bbl', 0, 0, 0);
            return USBD_STATUS_BUFFER_OVERRUN;
        } else if (Td->HwTD.Control.TimeoutCRC &&
                   Td->HwTD.Control.Stalled) {
            LOGENTRY(DeviceData, G, '_dnr', 0, 0, 0);
            return USBD_STATUS_DEV_NOT_RESPONDING;
        } else if (Td->HwTD.Control.TimeoutCRC &&
                   ACTUAL_LENGTH(Td->HwTD.Control.ActualLength) != 0) {
            LOGENTRY(DeviceData, G, '_crc', 0, 0, 0);
            return USBD_STATUS_CRC;
        } else if (Td->HwTD.Control.TimeoutCRC &&
                   ACTUAL_LENGTH(Td->HwTD.Control.ActualLength) == 0) {
            LOGENTRY(DeviceData, G, '_crd', 0, 0, 0);
            return USBD_STATUS_DEV_NOT_RESPONDING;
        } else if (Td->HwTD.Control.DataBufferError) {
            LOGENTRY(DeviceData, G, '_dto', 0, 0, 0);
            return USBD_STATUS_DATA_OVERRUN;
        } else if (Td->HwTD.Control.Stalled) {
            LOGENTRY(DeviceData, G, '_stl', 0, 0, 0);
            return USBD_STATUS_STALL_PID;
        } else {
            LOGENTRY(DeviceData, G, '_inE', 0, 0, 0);
            return USBD_STATUS_INTERNAL_HC_ERROR;
        }
    } else {
        if ((ACTUAL_LENGTH(Td->HwTD.Control.ActualLength) <
            ACTUAL_LENGTH(Td->HwTD.Token.MaximumLength)) &&
            !Td->HwTD.Control.IsochronousSelect) {
            LOGENTRY(DeviceData, G, '_shT', 0, 0, 0);
            return USBD_STATUS_ERROR_SHORT_TRANSFER;
            // not USBD_STATUS_DATA_UNDERRUN?
        }
    }

    return USBD_STATUS_SUCCESS;
}

//////////////////////////////////////////////////////////
//
// Power functions
//
//////////////////////////////////////////////////////////

VOID
UhciSuspendController(
    IN PDEVICE_DATA DeviceData
    )
{
    PHC_REGISTER reg;
    USBCMD command;
    USBSTS status;
    USHORT legsup;
    ULONG i;

    reg = DeviceData->Registers;

    // Check things out before we suspend.
    UhciKdPrint((DeviceData, 2, "'HC regs before suspend\n"));
    UhciKdPrint((DeviceData, 2, "'cmd register = %x\n",
        READ_PORT_USHORT(&reg->UsbCommand.us) ));
    UhciKdPrint((DeviceData, 2, "'status register = %x\n",
        READ_PORT_USHORT(&reg->UsbStatus.us) ));
    UhciKdPrint((DeviceData, 2, "'interrupt enable register = %x\n",
        READ_PORT_USHORT(&reg->UsbInterruptEnable.us) ));
    UhciKdPrint((DeviceData, 2, "'frame list base = %x\n",
        READ_PORT_ULONG(&reg->FrameListBasePhys.ul) ));
    UhciKdPrint((DeviceData, 2, "'port1 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[0].us) ));
    UhciKdPrint((DeviceData, 2, "'port2 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[1].us) ));


    // save volitile regs
    DeviceData->SuspendFrameListBasePhys.ul =
        READ_PORT_ULONG(&reg->FrameListBasePhys.ul) & (~(0x00000FFF));
    DeviceData->SuspendFrameNumber.us =
        READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;

    // Save away the command register
    DeviceData->SuspendCommandReg.us =
        command.us = READ_PORT_USHORT(&reg->UsbCommand.us);

    // Stop the controller
    command.RunStop = 0;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    // Wait for the HC to halt
    for (i = 0; i < 10; i++) {
        status.us = READ_PORT_USHORT(&reg->UsbStatus.us);
        if (status.HCHalted) {
            break;
        }
        USBPORT_WAIT(DeviceData, 1);
    }

    if (!status.HCHalted) {

        // Can't get the HCHalted bit to stick, so reset the controller.
        command.GlobalReset = 1;
        WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

        USBPORT_WAIT(DeviceData, 10);

        command.GlobalReset = 0;
        WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

        // Re-enable interrupts, since they are zero'd out on reset.
        WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us, DeviceData->EnabledInterrupts.us);

    }

    // bugbug - should we reset the frame list current index like uhcd?
/*    WRITE_PORT_USHORT(&reg->FrameNumber, 0);
    // re-initialize internal frame counters.
    DeviceData->FrameNumberHighPart =
        deviceExtension->LastFrame = 0;
*/

    // Finally, suspend the bus
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 0;
    command.EnterGlobalSuspendMode = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

}

USB_MINIPORT_STATUS
UhciResumeController(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    reverse what was done in 'suspend'

Arguments:

Return Value:

    None

--*/
{
    PHC_REGISTER reg;
    USBCMD command;
    USHORT counter, oldCounter;
    USHORT legsup, tmp;
    ULONG i;
    ULONG tmpl;

    reg = DeviceData->Registers;

    // consistency check the controller to see if the BIOS
    // or power management messed us up.


    tmp = READ_PORT_USHORT(&reg->UsbCommand.us);
    if (tmp == UHCI_HARDWARE_GONE) {
        UhciKdPrint((DeviceData, 0, "'Command register is toast.\n"));
        return USBMP_STATUS_HARDWARE_FAILURE;
    }

#if 0
    // This code was added to fix a power management problem on 
    // a particular COMPAQ platform AFTER the source for Windows XP
    // was 'locked down'.  The code worked but COMPAQ
    // opted to put something into their BIOS instead (I think).
    // In any event they never pressed the issue furthur. 
    // 
    // The code restores the state of the port registers if the 
    // command register has been zero'ed out.
    
    if (tmp == 0) {
        PORTSC port;
        ULONG p;

        TEST_TRAP();
        for (p=0; p<2; p++) {
            port.us = READ_PORT_USHORT(&reg->PortRegister[p].us);
            UhciKdPrint((DeviceData, 0, "'1>port %d %x\n", p+1, port.us));
            port.PortConnectChange = 1;
            port.PortEnableChange = 1;
            WRITE_PORT_USHORT(&reg->PortRegister[p].us, port.us);
            port.us = READ_PORT_USHORT(&reg->PortRegister[p].us);
            UhciKdPrint((DeviceData, 0, "'2>port %d %x\n", p+1, port.us));

            port.us = READ_PORT_USHORT(&reg->PortRegister[p].us);
            UhciKdPrint((DeviceData, 0, "'3>port %d %x\n", p+1, port.us));
            if (port.PortConnect) {
                port.PortEnable = 1;
                WRITE_PORT_USHORT(&reg->PortRegister[p].us, port.us);
            }
        }

        command.us = READ_PORT_USHORT(&reg->UsbCommand.us);     
        UhciKdPrint((DeviceData, 0, "'1> cmd %x\n", command.us));
        command.EnterGlobalSuspendMode = 1;
        command.MaxPacket = 1;
        WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);
        UhciKdPrint((DeviceData, 0, "'2> cmd %x\n", command.us));            
    }
#endif    

    // if the controller is not suspended then we'll fail the
    // resume, the BIOS probably reset the controller or the
    // bus may have lost power
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    if (!command.EnterGlobalSuspendMode) {
        UhciKdPrint((DeviceData, 0, "'RESUME> controller is toast (not in suspend).\n"));
        return USBMP_STATUS_HARDWARE_FAILURE;
    }

    //
    // The following is from UHCD_RestoreHCState
    //

    UhciKdPrint((DeviceData, 2, "'<HC regs after suspend>\n"));
    UhciKdPrint((DeviceData, 2, "'cmd register = %x\n",
        READ_PORT_USHORT(&reg->UsbCommand.us) ));
    UhciKdPrint((DeviceData, 2, "'status register = %x\n",
        READ_PORT_USHORT(&reg->UsbStatus.us) ));
    UhciKdPrint((DeviceData, 2, "'interrupt enable register = %x\n",
        READ_PORT_USHORT(&reg->UsbInterruptEnable.us) ));
    UhciKdPrint((DeviceData, 2, "'frame list base = %x\n",
        READ_PORT_ULONG(&reg->FrameListBasePhys.ul) ));

    UhciKdPrint((DeviceData, 2, "'port1 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[0].us) ));
    UhciKdPrint((DeviceData, 2, "'port2 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[1].us) ));

    // usbport will not ask to suspend if power is lost, however,
    // on suspend the chipset may lose the frame number and
    // FLBA (I don't know why) we therefore must save and  restore
    // these across suspend

    // restore the FLBA and frame counter
    UhciKdPrint((DeviceData, 2, "'restoring FLBA\n"));
    WRITE_PORT_USHORT(&reg->FrameNumber.us,
                      DeviceData->SuspendFrameNumber.us);
    WRITE_PORT_ULONG(&reg->FrameListBasePhys.ul,
                     DeviceData->SuspendFrameListBasePhys.ul);
    //WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us, DeviceData->SuspendInterruptEnable.us);

    //
    // The following is from UHCD_Resume
    //
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    // Wait for the spec'd 20 ms so that the controller
    // can resume.
    USBPORT_WAIT(DeviceData, 20);

    // Done with resume.
    // Clear the suspend and resume bits.
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 0;
    command.EnterGlobalSuspendMode = 0;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);


    // Wait for the resume bit to go low.
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    i = 0;
    while (command.ForceGlobalResume && i<10) {
        KeStallExecutionProcessor(50);
        command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
        i++;
    }

    if (command.ForceGlobalResume) {
        TEST_TRAP();
        return USBMP_STATUS_HARDWARE_FAILURE;
    }

    // start the controller
    command = DeviceData->SuspendCommandReg;
    command.RunStop = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    //
    // Make sure that the controller is really running and if not,
    // fail the resume.
    //
    oldCounter = READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;
    USBPORT_WAIT(DeviceData, 5);
    counter = READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;
    if(counter == oldCounter) {
        return USBMP_STATUS_HARDWARE_FAILURE;
    }

    // clear resume bits on the ports
    if (DeviceData->ControllerFlavor != UHCI_Piix4 &&
        !ANY_VIA(DeviceData)) {
        PORTSC port;
        ULONG p;

        for (p=0; p<2; p++) {
            port.us = READ_PORT_USHORT(&reg->PortRegister[p].us);
            if (port.PortConnect == 0 ||
                port.PortEnable == 0) {
                port.Suspend = 0;

                MASK_CHANGE_BITS(port);

                WRITE_PORT_USHORT(&reg->PortRegister[p].us, port.us);
                UhciKdPrint((DeviceData, 1, "'<resume port %d>\n", p));
            }
        }
    }

#if 0
    // Special hack for ICH2_2 + Samsung keyboard
    //
    // resume signalling from this keyboard is not to spec and this
    // causes problems on the ICH2, if resume signalling is generated
    // the root port will be disabled and a connect change will be 
    // indicated.
    // It might be possible to detect this case and correct it although 
    // I'm not sure of the side effects -- the code here is included 
    // for reference.
    
    if (DeviceData->ControllerFlavor == UHCI_Ich2_2) { 
        PORTSC port;
        ULONG p;

        for (p=0; p<2; p++) {
            port.us = READ_PORT_USHORT(&reg->PortRegister[p].us);
            if (port.PortConnect == 1 &&
                port.Suspend == 1 && 
                port.PortEnable == 0) {

                port.PortEnable = 1;

                WRITE_PORT_USHORT(&reg->PortRegister[p].us, port.us);
                UhciKdPrint((DeviceData, 1, "'<resume (ICH2_2) port %d>\n", p));
            }
        }
    }
#endif

    UhciKdPrint((DeviceData, 2, "'<HC regs after resume>\n"));
    UhciKdPrint((DeviceData, 2, "'cmd register = %x\n",
        READ_PORT_USHORT(&reg->UsbCommand.us) ));
    UhciKdPrint((DeviceData, 2, "'status register = %x\n",
        READ_PORT_USHORT(&reg->UsbStatus.us) ));
    UhciKdPrint((DeviceData, 2, "'interrupt enable register = %x\n",
        READ_PORT_USHORT(&reg->UsbInterruptEnable.us) ));
    UhciKdPrint((DeviceData, 2, "'frame list base = %x\n",
        READ_PORT_ULONG(&reg->FrameListBasePhys.ul) ));

    UhciKdPrint((DeviceData, 2, "'port1 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[0].us) ));
    UhciKdPrint((DeviceData, 2, "'port2 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[1].us) ));

     return USBMP_STATUS_SUCCESS;
}


BOOLEAN UhciHardwarePresent(
     PDEVICE_DATA DeviceData
     )
{
    PHC_REGISTER reg;
    USBSTS status;
    // USBCMD command;

    reg = DeviceData->Registers;

    // bits 15:6 must be zero
    status.us = READ_PORT_USHORT(&reg->UsbStatus.us);

    if (status.us == 0xffff) {

        UhciKdPrint((DeviceData, 0, "'Hardware Gone\n"));
        return FALSE;
    }

    return TRUE;

}

VOID
UhciCheckController(
    PDEVICE_DATA DeviceData
    )
{
    if (!UhciHardwarePresent(DeviceData) ||
        (DeviceData->HCErrorCount >= UHCI_HC_MAX_ERRORS)) {
        USBPORT_INVALIDATE_CONTROLLER(DeviceData, UsbMpControllerRemoved);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\roothub.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

   roothub.c

Abstract:

   miniport root hub

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-26-00 : created, jsenior

implements the following miniport functions:

MINIPORT_RH_GetStatus
MINIPORT_RH_GetPortStatus
MINIPORT_RH_GethubStatus

MINIPORT_RH_SetFeaturePortReset
MINIPORT_RH_SetFeaturePortSuspend
MINIPORT_RH_SetFeaturePortPower

MINIPORT_RH_ClearFeaturePortEnable
MINIPORT_RH_ClearFeaturePortSuspend
MINIPORT_RH_ClearFeaturePortPower

MINIPORT_RH_ClearFeaturePortConnectChange
MINIPORT_RH_ClearFeaturePortResetChange
MINIPORT_RH_ClearFeaturePortEnableChange
MINIPORT_RH_ClearFeaturePortSuspendChange
MINIPORT_RH_ClearFeaturePortOvercurrentChange


--*/

#include "pch.h"

typedef struct _UHCI_PORT_RESET_CONTEXT {
    USHORT  PortNumber;
    BOOLEAN Completing;
} UHCI_PORT_RESET_CONTEXT, *PUHCI_PORT_RESET_CONTEXT;

VOID
UhciRHGetRootHubData(
    IN PDEVICE_DATA DeviceData,
    OUT PROOTHUB_DATA HubData
    )
/*++
    return info about the root hub
--*/
{
    HubData->NumberOfPorts = UHCI_NUMBER_PORTS;

    // D0,D1 (11)  - no power switching
    // D2    (0)   - not compund
    // D5, D15 (0)
    HubData->HubCharacteristics.us = 0;
    HubData->HubCharacteristics.PowerSwitchType = 3;
    HubData->HubCharacteristics.CompoundDevice = 0;
    if (DeviceData->ControllerFlavor == UHCI_Piix4) {
        // D3,D4 (01)  - overcurrent reported per port
        HubData->HubCharacteristics.OverCurrentProtection = 1;
    } else {
        // D3,D4 (11)  - no overcurrent reported
        HubData->HubCharacteristics.OverCurrentProtection = 11;
    }

    HubData->PowerOnToPowerGood = 1;
    // this value is the current consumed by the hub
    // brains, for the embeded hub this doesn't make
    // much sense.
    //
    // so we report zero
    HubData->HubControlCurrent = 0;

    LOGENTRY(DeviceData, G, '_hub', HubData->NumberOfPorts,
        DeviceData->PortPowerControl, 0);

}

////////////////////////////////////////////////////////////////////////////////
//
// Hub status
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHGetStatus(
    IN PDEVICE_DATA DeviceData,
    OUT PUSHORT Status
    )
/*++
    get the device status
--*/
{
    // the root hub is self powered
    *Status = USB_GETSTATUS_SELF_POWERED;

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHGetHubStatus(
    IN PDEVICE_DATA DeviceData,
    OUT PRH_HUB_STATUS HubStatus
    )
/*++
--*/
{
    // nothing intersting for the root
    // hub to report
    HubStatus->ul = 0;

    return USBMP_STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//
// Port Enable
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHPortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    USHORT Value
    )
/*++
--*/
{
    PHC_REGISTER reg;
    PORTSC port;

    reg = DeviceData->Registers;

    UHCI_ASSERT(DeviceData, PortNumber <= UHCI_NUMBER_PORTS);

    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    LOGENTRY(DeviceData, G, '_spe', port.us, 0, PortNumber);

    MASK_CHANGE_BITS(port);

    // writing a 1 enables the port
    port.PortEnable = Value;
    WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortEnable (
    IN PDEVICE_DATA DeviceData,
    IN USHORT PortNumber
    )
{
    return UhciRHPortEnable(DeviceData, PortNumber, 0);
}

USB_MINIPORT_STATUS
UhciRHSetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    return UhciRHPortEnable(DeviceData, PortNumber, 1);
}


////////////////////////////////////////////////////////////////////////////////
//
// Port Power
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHClearFeaturePortPower (
    IN PDEVICE_DATA DeviceData,
    IN USHORT PortNumber
    )
{
    // not implemented on uhci

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHSetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    // not implemented on uhci

    return USBMP_STATUS_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////
//
// Port Status
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHGetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    )
/*++
    get the status of a partuclar port
--*/
{
    PHC_REGISTER reg;
    PORTSC port;

    reg = DeviceData->Registers;

    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    portStatus->ul = 0;
    LOGENTRY(DeviceData, G, '_Pp1', PortNumber, port.us, 0);

    // map the bits to the port status structure

    portStatus->Connected           = port.PortConnect;
    portStatus->Enabled             = port.PortEnable;

    // bits 12:2 indicate the true suspend state
    // we only want to indiacte the port is suspended
    // if a device is attached.  If the device is removed
    // during suspend the enable bit will be clear
    if (port.Suspend && port.PortEnable) {
        portStatus->Suspended = 1;
    } else {
        portStatus->Suspended = 0;
    }

    if (DeviceData->ControllerFlavor == UHCI_Piix4) {
        portStatus->OverCurrent         = port.Overcurrent;
        portStatus->OverCurrentChange   = port.OvercurrentChange;
        portStatus->PowerOn             = !port.Overcurrent;
    } else {
        portStatus->OverCurrent         = 0;
        portStatus->OverCurrentChange   = 0;
        portStatus->PowerOn             = 1; // always on
    }

    portStatus->Reset               = port.PortReset;
    portStatus->LowSpeed            = port.LowSpeedDevice;
    portStatus->HighSpeed           = 0; // this is not a 2.0 HC
    portStatus->ConnectChange       = port.PortConnectChange;
    if (TEST_BIT(DeviceData->PortInReset, PortNumber-1)) {
        portStatus->EnableChange = 0;
        portStatus->ConnectChange = 0;
    } else {
        portStatus->EnableChange = port.PortEnableChange;
    }

    // these change bits must be emulated
    if (TEST_BIT(DeviceData->PortSuspendChange, PortNumber-1)) {
        portStatus->SuspendChange   = 1;
    }
    if (TEST_BIT(DeviceData->PortResetChange, PortNumber-1)) {
        portStatus->ResetChange     = 1;
    }

    LOGENTRY(DeviceData, G, '_gps',
        PortNumber, portStatus->ul, port.us);

    return USBMP_STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//
// Port Reset
//
//      First, we have the VIA specific routines for REVs 0 thru 4 of the VIA
//      USB host controller. Then the regular routines follow that are run for
//      all non-broken controllers.
//
////////////////////////////////////////////////////////////////////////////////

VOID
UhciRHSetFeaturePortResetWorker(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    );

VOID
UhciViaRHPortResetComplete(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    VIA specific hack: Restart the controller.
--*/
{
    PHC_REGISTER reg;
    USBCMD command;
    USHORT portNumber;

    reg = DeviceData->Registers;
    portNumber = PortResetContext->PortNumber;

    // This code has been ripped out of the VIA filter driver
    // that works on Win2K.

    // Re-start the controller.
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 0;
    command.RunStop = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    // Continue with the regular port reset completion stuff.
    SET_BIT(DeviceData->PortResetChange, portNumber-1);
    CLEAR_BIT(DeviceData->PortInReset, portNumber-1);

    // indicate the reset change to the hub
    USBPORT_INVALIDATE_ROOTHUB(DeviceData);
}

VOID
UhciViaRHSetFeaturePortResetResume(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    VIA specific hack: Resume the controller.
--*/
{
    PHC_REGISTER reg;
    USBCMD command;
    PMINIPORT_CALLBACK callback;

    reg = DeviceData->Registers;

    // Resume the controller
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 1;
    command.EnterGlobalSuspendMode = 0;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    //
    // Depending on whether we're in the completion case or not,
    // we'll either be starting the controller or putting the port
    // into reset.
    //
    callback = PortResetContext->Completing ?
        UhciViaRHPortResetComplete : UhciRHSetFeaturePortResetWorker;

    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   20, // callback in 20 ms, as in via filter
                                   PortResetContext,
                                   sizeof(UHCI_PORT_RESET_CONTEXT),
                                   callback);
}

VOID
UhciViaRHSetFeaturePortResetSuspend(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    VIA specific hack: Suspend the controller.
--*/
{
    PHC_REGISTER reg;
    USBCMD command;
    USBSTS status;

    reg = DeviceData->Registers;

    status.us = READ_PORT_USHORT(&reg->UsbStatus.us);
    UHCI_ASSERT(DeviceData, status.HCHalted);

    // Suspend the controller
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 0;
    command.EnterGlobalSuspendMode = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   20, // callback in 20 ms, as in via filter
                                   PortResetContext,
                                   sizeof(UHCI_PORT_RESET_CONTEXT),
                                   UhciViaRHSetFeaturePortResetResume);
}

VOID
UhciViaRHSetFeaturePortResetStop(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    VIA specific hack: Stop the controller.
--*/
{
    PHC_REGISTER reg;
    USBCMD command;

    reg = DeviceData->Registers;

    // This code has been ripped out of the VIA filter driver
    // that works on Win2K.

    // Stop the controller
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.RunStop = 0;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    // Wait for the HC to halt
    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   20, // callback in 20 ms, as in via filter
                                   PortResetContext,
                                   sizeof(UHCI_PORT_RESET_CONTEXT),
                                   UhciViaRHSetFeaturePortResetSuspend);
}

////////////////////////////////////////////////////////////////////////////////
//
// Port Reset
//
//      Generic reset routines.
//
////////////////////////////////////////////////////////////////////////////////

VOID
UhciRHPortResetComplete(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    complete a port reset
--*/
{
    PHC_REGISTER reg;
    PORTSC port;
    USHORT portNumber;
    int i;

    reg = DeviceData->Registers;
    portNumber = PortResetContext->PortNumber;

    port.us = READ_PORT_USHORT(&reg->PortRegister[portNumber-1].us);
    LOGENTRY(DeviceData, G, '_prC', port.us,
        DeviceData->PortResetChange, portNumber);

    MASK_CHANGE_BITS(port);
    // writing a 0 stops reset
    port.PortReset = 0;
    WRITE_PORT_USHORT(&reg->PortRegister[portNumber-1].us, port.us);

    // spin for zero
    do {
        //
        // a driver may not spin in a loop waiting for a status bit change
        // without testing for hardware presence inside the loop.
        //
        if (FALSE == UhciHardwarePresent(DeviceData)) {
            return;
        }
        port.us = READ_PORT_USHORT(&reg->PortRegister[portNumber-1].us);
    } while (port.PortReset != 0);

    //
    // Enable the port
    //

    for (i=0; i< 10; i++) {
        //
        // Need a delay between clearing the port reset and setting
        // the port enable.  VIA suggests delaying 64 USB bit times,
        // or 43us if those are low-speed bit times....
        // BUT, we can't wait in the DPC...
        //
        KeStallExecutionProcessor(50);

        port.us = READ_PORT_USHORT(&reg->PortRegister[portNumber-1].us);

        if (port.PortEnable) {
            //
            // port is enabled
            //
            break;
        }

        port.PortEnable = 1;
        WRITE_PORT_USHORT(&reg->PortRegister[portNumber-1].us, port.us);
    }

    // clear port connect & enable change bits
    port.PortEnableChange = 1;
    port.PortConnectChange = 1;
    WRITE_PORT_USHORT(&reg->PortRegister[portNumber-1].us, port.us);

    if (DeviceData->ControllerFlavor >= UHCI_VIA &&
        DeviceData->ControllerFlavor <= UHCI_VIA+0x4) {

        PortResetContext->Completing = TRUE;
        UhciViaRHSetFeaturePortResetSuspend(DeviceData, PortResetContext);

    } else {
        SET_BIT(DeviceData->PortResetChange, portNumber-1);
        CLEAR_BIT(DeviceData->PortInReset, portNumber-1);

        // indicate the reset change to the hub
        USBPORT_INVALIDATE_ROOTHUB(DeviceData);
    }
}

VOID
UhciRHSetFeaturePortResetWorker(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    Do the actual work to put the port in reset
--*/
{
    PHC_REGISTER reg;
    PORTSC port;
    USHORT portNumber = PortResetContext->PortNumber;

    reg = DeviceData->Registers;

    port.us = READ_PORT_USHORT(&reg->PortRegister[portNumber-1].us);

    LOGENTRY(DeviceData, G, '_prw', port.us, 0, portNumber);

    UHCI_ASSERT(DeviceData, !port.PortReset);

    // writing a 1 initiates reset
    LOGENTRY(DeviceData, G, '_nhs', port.us, 0, portNumber);
    MASK_CHANGE_BITS(port);
    port.PortReset = 1;
    WRITE_PORT_USHORT(&reg->PortRegister[portNumber-1].us, port.us);

    // schedule a callback to complete the reset.
    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   10, // callback in 10 ms,
                                   PortResetContext,
                                   sizeof(UHCI_PORT_RESET_CONTEXT),
                                   UhciRHPortResetComplete);
}

USB_MINIPORT_STATUS
UhciRHSetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in reset
--*/
{
    PORTSC port;
    UHCI_PORT_RESET_CONTEXT portResetContext;

    portResetContext.PortNumber = PortNumber;
    portResetContext.Completing = FALSE;

    UHCI_ASSERT(DeviceData, PortNumber <= UHCI_NUMBER_PORTS);

    LOGENTRY(DeviceData, G, '_spr', 0, 0, PortNumber);

    if (!TEST_BIT(DeviceData->PortInReset, PortNumber-1)) {
        SET_BIT(DeviceData->PortInReset, PortNumber-1);

        if (DeviceData->ControllerFlavor >= UHCI_VIA &&
            DeviceData->ControllerFlavor <= UHCI_VIA+0x4) {
            UhciViaRHSetFeaturePortResetStop(DeviceData, &portResetContext);
        } else {
            UhciRHSetFeaturePortResetWorker(DeviceData, &portResetContext);
        }
    } else {
        //
        // the port is already in reset
        //
        UhciKdPrint((DeviceData, 2, "Trying to reset a port already in reset.\n"));
        return USBMP_STATUS_BUSY;
    }

    return USBMP_STATUS_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////
//
// Port Suspend
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHSetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in suspend.
--*/
{
    PHC_REGISTER reg;
    PORTSC port;

    reg = DeviceData->Registers;

    UHCI_ASSERT(DeviceData, PortNumber <= UHCI_NUMBER_PORTS);

    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    LOGENTRY(DeviceData, G, '_sps', port.us, 0, PortNumber);

    if (!port.Suspend) {
        //
        // write the suspend bit
        //
        if (DeviceData->ControllerFlavor == UHCI_Piix4 ||
            ANY_VIA(DeviceData)) {
            // just pretend we did it for the piix4

            LOGENTRY(DeviceData, G, '_spo', port.us, 0, PortNumber);
        } else {
            MASK_CHANGE_BITS(port);

            port.Suspend = 1;
            WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);
        }

        LOGENTRY(DeviceData, G, '_sus', port.us, 0, PortNumber);
    } else {
        //
        // stall if the port is already suspended
        //
        UhciKdPrint((DeviceData, 2, "Trying to suspend an already suspended port.\n"));
    }

    return USBMP_STATUS_SUCCESS;
}

VOID
UhciRHClearFeaturePortSuspendComplete(
    PDEVICE_DATA DeviceData,
    PVOID Context
    )
/*++
    complete a port resume.
--*/
{
    PHC_REGISTER reg;
    PORTSC port;
    PUHCI_PORT_RESET_CONTEXT portResetContext = Context;
    USHORT portNumber;

    reg = DeviceData->Registers;
    portNumber = portResetContext->PortNumber;

    port.us = READ_PORT_USHORT(&reg->PortRegister[portNumber-1].us);
    LOGENTRY(DeviceData, G, '_prC', port.us,
        DeviceData->PortSuspendChange, portNumber);

    MASK_CHANGE_BITS(port);
    // clear the bits.
    port.ResumeDetect = 0;
    port.Suspend = 0;
    WRITE_PORT_USHORT(&reg->PortRegister[portNumber-1].us, port.us);

    SET_BIT(DeviceData->PortSuspendChange, portNumber-1);

    DeviceData->PortResuming[portNumber-1] = FALSE;

    // indicate the resume change to the hub
    USBPORT_INVALIDATE_ROOTHUB(DeviceData);
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Resume a port in suspend
--*/
{
    PHC_REGISTER reg;
    PORTSC port;
    UHCI_PORT_RESET_CONTEXT portResetContext;

    reg = DeviceData->Registers;

    UHCI_ASSERT(DeviceData, PortNumber <= UHCI_NUMBER_PORTS);

    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    LOGENTRY(DeviceData, G, '_rps', port.us, 0, PortNumber);

    if (DeviceData->ControllerFlavor == UHCI_Piix4 ||
        ANY_VIA(DeviceData)) {

        // just pretend we did it for the piix4
        TEST_TRAP();
        LOGENTRY(DeviceData, G, '_rpo', port.us, 0, PortNumber);

    } else {

        if (!DeviceData->PortResuming[PortNumber-1]) {

            DeviceData->PortResuming[PortNumber-1] = TRUE;

            if (!port.ResumeDetect) {

                // write the resume detect bit
                MASK_CHANGE_BITS(port);

                port.ResumeDetect = 1;
                WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);
            }

            // Request to be called back so that we can set the resume to zero
            portResetContext.PortNumber = PortNumber;

            USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                           10, // callback in 10 ms,
                                           &portResetContext,
                                           sizeof(portResetContext),
                                           UhciRHClearFeaturePortSuspendComplete);

        } else {

            // stall if the port is already resuming
            UhciKdPrint((DeviceData, 2, "Trying to resume a port already resuming.\n"));
            return USBMP_STATUS_BUSY;
        }
    }

    LOGENTRY(DeviceData, G, '_res', port.us, 0, PortNumber);
    return USBMP_STATUS_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////
//
// Port Change bits
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_REGISTER reg;
    PORTSC port;

    reg = DeviceData->Registers;

    //
    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    LOGENTRY(DeviceData, G, '_pcc', port.us,
        0, PortNumber);

    // writing a 1 zeros the change bit
    if (port.PortConnectChange == 1) {
        // mask off other change bits
        MASK_CHANGE_BITS(port);
        port.PortConnectChange = 1;

        WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);
    }

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_REGISTER reg;
    PORTSC port;

    LOGENTRY(DeviceData, G, '_cpe', PortNumber, 0, 0);

    reg = DeviceData->Registers;

    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    MASK_CHANGE_BITS(port);
    port.PortEnableChange = 1;

    WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

Clear the port reset condition.

--*/
{
    // UHCI doesn't have this.
    CLEAR_BIT(DeviceData->PortResetChange, PortNumber-1);

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortSuspendChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

Clear the port suspend condition.

--*/
{
    // UHCI doesn't have this.
    CLEAR_BIT(DeviceData->PortSuspendChange, PortNumber-1);

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortOvercurrentChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

Clear the port overcurrent condition.

--*/
{
    if (DeviceData->ControllerFlavor == UHCI_Piix4) {
        PHC_REGISTER reg;
        PORTSC port;

        reg = DeviceData->Registers;

        //
        port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
        LOGENTRY(DeviceData, G, '_cOv', port.us, 0, PortNumber);

        // writing a 1 zeros the change bit
        if (port.OvercurrentChange == 1) {
            // mask off other change bits
            MASK_CHANGE_BITS(port);
            port.OvercurrentChange = 1;

            WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);
        }
    }

    return USBMP_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\uhci.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    uhci.h

Abstract:

   Definitions from USB 1.0 Universal host controller specification

Environment:

    Kernel & user mode

Revision History:

    7-20-00 : created jsenior

--*/


#ifndef __UHCI_H__
#define __UHCI_H__

#include <PSHPACK4.H>
//
// Don't use <PSHPACK1.H> on shared memory data structures that should only
// be accessed using 4-byte load/store instructions (e.g use ld4 instructions
// instead of ld1 instructions on ia64 machines).
//


//
// PCI host controller hardware registers
//

#define VIA_FIFO_MANAGEMENT     0x42    // offset of VIA's fifo management bit
#define VIA_FIFO_DISABLE        0x07    // bit two disables the fifo, and
#define VIA_DISABLE_BABBLE_DETECT 0x40  // Bit to set to disable babble detect
#define VIA_INTERNAL_REGISTER   0x40    // offset of reg that enables detects babble
typedef UCHAR VIAFIFO;
typedef ULONG VIABABBLE;

#define LEGACY_BIOS_REGISTER    0xc0    // offset of legacy bios reg

#define LEGSUP_HCD_MODE     0x2000  // value to put in LEGSUP reg for normal HCD use  JMD
#define LEGSUP_BIOS_MODE    0x00BF  // value to put in LEGSUP reg for BIOS/SMI use  JMD

#define LEGSUP_USBPIRQD_EN  0x2000  // bit 13
#define LEGSUP_SMI_ENABLE   0x0010
typedef USHORT USBSETUP;

//
// Host Controler Hardware Registers as accessed in memory
//

//
// USBCMD - USB Command Register
//

typedef union _USBCMD {

    USHORT                 us;
    struct {
        USHORT              RunStop:1;                  // 0
        USHORT              HostControllerReset:1;      // 1
        USHORT              GlobalReset:1;              // 2
        USHORT              EnterGlobalSuspendMode:1;   // 3
        USHORT              ForceGlobalResume:1;        // 4
        USHORT              SoftwareDebug:1;            // 5
        USHORT              ConfigureFlag:1;            // 6
        USHORT              MaxPacket:1;                // 7
        USHORT              Reserved:8;                 // 8-15
    };

} USBCMD, *PUSBCMD;

C_ASSERT((sizeof(USBCMD) == sizeof(USHORT)));

//
// USBSTS - USB Status Register
//

#define HcInterruptStatusMask                   0x0000003F

typedef union _USBSTS {

    USHORT                  us;
    struct {
        // controller interrupt status bits
        USHORT              UsbInterrupt:1;                 // 0
        USHORT              UsbError:1;                     // 1
        USHORT              ResumeDetect:1;                 // 2
        USHORT              HostSystemError:1;              // 3
        USHORT              HostControllerProcessError:1;   // 4
        USHORT              HCHalted:1;                     // 5
        USHORT              Reserved:10;                    // 6-15

    };

} USBSTS, *PUSBSTS;

C_ASSERT((sizeof(USBSTS) == sizeof(USHORT)));


//
// USBINTR - USB Interrupt Enable Register
//

typedef union _USBINTR {

    USHORT                  us;
    struct {
        USHORT              TimeoutCRC:1;                   // 0
        USHORT              Resume:1;                       // 1
        USHORT              InterruptOnComplete:1;          // 2
        USHORT              ShortPacket:1;                  // 3
        USHORT              Reserved:12;                    // 4-15
    };

} USBINTR, *PUSBINTR;

C_ASSERT((sizeof(USBINTR) == sizeof(USHORT)));

//
// FRNUM - Frame Number Register
//

typedef union _FRNUM {

    USHORT                  us;
    struct {
        USHORT              FrameListCurrentIndex:11;      // 0-10
        USHORT              Reserved:5;                    // 11-15
    };

} FRNUM, *PFRNUM;

C_ASSERT((sizeof(FRNUM) == sizeof(USHORT)));

//
// FLBASEADD - Frame list base address register
//

typedef union _FRBASEADD {

    HW_32BIT_PHYSICAL_ADDRESS ul;
    struct {
        ULONG                 Reserved:12;                // 0-11
        ULONG                 BaseAddress:20;             // 12-31
    };

} FRBASEADD, *PFRBASEADD;

C_ASSERT((sizeof(FRBASEADD) == sizeof(ULONG)));

//
// FRNUM - Frame Number Register
//

typedef union _SOFMOD {

    UCHAR                    uc;
    struct {
        UCHAR                SOFTimingValue:7;              // 0-6
        UCHAR                Reserved:1;                    // 7
    };

} SOFMOD, *PSOFMOD;

C_ASSERT((sizeof(SOFMOD) == sizeof(UCHAR)));

//
// PORTSC - Port Status and Control Register
//

typedef union _PORTSC {

    USHORT                  us;
    struct {
        USHORT              PortConnect:1;          // 0
        USHORT              PortConnectChange:1;    // 1
        USHORT              PortEnable:1;           // 2
        USHORT              PortEnableChange:1;     // 3
        USHORT              LineStatus:2;           // 4-5
        USHORT              ResumeDetect:1;         // 6
        USHORT              Reserved1:1;            // 7
        USHORT              LowSpeedDevice:1;       // 8
        USHORT              PortReset:1;            // 9
        USHORT              Overcurrent:1;          // 10
        USHORT              OvercurrentChange:1;    // 11
        USHORT              Suspend:1;              // 12
        USHORT              Reserved3:3;            // 13-15
    };

} PORTSC, *PPORTSC;

C_ASSERT((sizeof(PORTSC) == sizeof(USHORT)));


// OPERATIONAL REGISTER

typedef struct _HC_REGISTER {

    USBCMD                          UsbCommand;         // 00-01h
    USBSTS                          UsbStatus;          // 02-03h
    USBINTR                         UsbInterruptEnable; // 04-05h
    FRNUM                           FrameNumber;      // 06-07h
    FRBASEADD                       FrameListBasePhys;  // 08-0Bh
    SOFMOD                          StartOfFrameModify; // 0Ch
    UCHAR                           Reserved[3];        // 0D-0Fh
    PORTSC                          PortRegister[2];

} HC_REGISTER, *PHC_REGISTER;


#define HcDTYPE_iTD                 0    // iterative TD
#define HcDTYPE_QH                  1    // queue head
#define HcDTYPE_siTD                2    // isochronousTD

#define HW_LINK_FLAGS_MASK          0x00000007

//
// Queue head
//

typedef union _TD_LINK_POINTER {

   HW_32BIT_PHYSICAL_ADDRESS        HwAddress;
   struct {
        ULONG Terminate:1;                      // 0
        ULONG QHTDSelect:1;                     // 1
        ULONG DepthBreadthSelect:1;             // 2
        ULONG Reserved:1;                       // 3
        ULONG LinkPointer:28;                   // 4-31
   };

} TD_LINK_POINTER, *PTD_LINK_POINTER;

C_ASSERT((sizeof(TD_LINK_POINTER) == sizeof(ULONG)));

typedef union _QH_LINK_POINTER {

   HW_32BIT_PHYSICAL_ADDRESS        HwAddress;
   struct {
        ULONG Terminate:1;                      // 0
        ULONG QHTDSelect:1;                     // 1
        ULONG Reserved:2;                       // 3
        ULONG LinkPointer:28;                   // 4-31
   };

} QH_LINK_POINTER, *PQh_LINK_POINTER;

C_ASSERT((sizeof(QH_LINK_POINTER) == sizeof(ULONG)));

//
// Queue Head Descriptor
//

typedef struct _HW_QUEUE_HEAD {

    QH_LINK_POINTER                 HLink;  // HC horizontal link ptr
                                            // Host Controller Read Only

    TD_LINK_POINTER volatile        VLink;  // HC Element (vertical) link ptr
                                            // Host Controller Read/Write

} HW_QUEUE_HEAD, *PHW_QUEUE_HEAD;

C_ASSERT((sizeof(HW_QUEUE_HEAD) == 8));


//
// Queue Element Transfer Descriptor
//

//
// some USB constants
//

#define InPID       0x69
#define OutPID      0xe1
#define GetPID(ad)  ((ad & 0x80) == 0x80) ? InPID : OutPID
#define SetupPID    0x2d
#define DataToggle0 0
#define DataToggle1 1

typedef ULONG HC_BUFFER_POINTER, *PHC_BUFFER_POINTER;

C_ASSERT((sizeof(HC_BUFFER_POINTER) == sizeof(ULONG)));

#define NULL_PACKET_LENGTH      0x7ff
#define MAXIMUM_LENGTH(l) ((l) == 0 ? NULL_PACKET_LENGTH : (l)-1)
#define ACTUAL_LENGTH(l) ((l) == NULL_PACKET_LENGTH ? 0 : (l)+1)

typedef union _HC_QTD_TOKEN {
    ULONG   ul;
    struct {
        ULONG Pid:8;                    // 0-7
        ULONG DeviceAddress:7;          // 8-14
        ULONG Endpoint:4;               // 15-18
        ULONG DataToggle:1;             // 19
        ULONG Reserved:1;               // 20
        ULONG MaximumLength:11;         // 21-31
    };
} HC_QTD_TOKEN, *PHC_QTD_TOKEN;

C_ASSERT((sizeof(HC_QTD_TOKEN) == sizeof(ULONG)));

#define CONTROL_STATUS_MASK 0x007E0000

typedef union _HC_QTD_CONTROL {
    ULONG   ul;
    struct {
        ULONG ActualLength:11;          // 0-10
        ULONG Reserved1:5;              // 11-15

        // status bits
        ULONG Reserved2:1;              // 16
        ULONG BitstuffError:1;          // 17
        ULONG TimeoutCRC:1;             // 18
        ULONG NAKReceived:1;            // 19
        ULONG BabbleDetected:1;         // 20
        ULONG DataBufferError:1;        // 21
        ULONG Stalled:1;                // 22
        ULONG Active:1;                 // 23

        ULONG InterruptOnComplete:1;    // 24
        ULONG IsochronousSelect:1;      // 25
        ULONG LowSpeedDevice:1;         // 26

        ULONG ErrorCount:2;             // 27-28
        ULONG ShortPacketDetect:1;      // 29
        ULONG Reserved3:2;              // 30-31
    };
} HC_QTD_CONTROL, *PHC_QTD_CONTROL;

C_ASSERT((sizeof(HC_QTD_CONTROL) == sizeof(ULONG)));

typedef struct _HW_QUEUE_ELEMENT_TD {
    TD_LINK_POINTER             LinkPointer;    // Host Controller Read Only
    HC_QTD_CONTROL    volatile  Control;        // Host Controller Read/Write
    HC_QTD_TOKEN                Token;          // Host Controller Read Only
    HC_BUFFER_POINTER           Buffer;         // Host Controller Read Only
} HW_QUEUE_ELEMENT_TD, *PHW_QUEUE_ELEMENT_TD;

C_ASSERT((sizeof(HW_QUEUE_ELEMENT_TD) == 16));

//
// General Transfer Descriptor
//

typedef union _HW_TRANSFER_DESCRIPTOR {
    HW_QUEUE_ELEMENT_TD         qTD;
} HW_TRANSFER_DESCRIPTOR, *PHW_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HW_TRANSFER_DESCRIPTOR) == 16));

#include <POPPACK.H>

#endif /* __UHCI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\openhci\async.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
   async.c

Abstract:
   This module manages interrupts from the HCD
   and contains all Defered Procedure Calls.

Environment:
   kernel mode only

Notes:

Revision History:
   1996-03-14:    created kenray

--*/

#include "openhci.h"

VOID OpenHCI_CancelTDsForED(PHCD_ENDPOINT_DESCRIPTOR ED);
VOID OpenHCI_CompleteUsbdTransferRequest(PHCD_URB, USBD_STATUS, NTSTATUS, 
        BOOLEAN);
VOID OpenHCI_ProcessDoneQueue(PHCD_DEVICE_DATA, ULONG);
BOOLEAN OpenHCI_ProcessDoneAsyncTD(PHCD_DEVICE_DATA,
                                   PHCD_TRANSFER_DESCRIPTOR,
                                   PHCD_ENDPOINT,
                                   PHC_TRANSFER_DESCRIPTOR,
                                   NTSTATUS *,
                                   USBD_STATUS *,
                                   PHCD_URB,
                                   BOOLEAN);
                                   
BOOLEAN OpenHCI_ProcessDoneIsoTD(PHCD_DEVICE_DATA,
                                 PHCD_TRANSFER_DESCRIPTOR,
                                 PHCD_ENDPOINT,
                                 PHC_TRANSFER_DESCRIPTOR,
                                 NTSTATUS *,
                                 USBD_STATUS *,
                                 PHCD_URB,
                                 BOOLEAN);
                                   


BOOLEAN
OpenHCI_InterruptService(
    IN PKINTERRUPT Interrupt,
    IN VOID *ServiceContext
)
/*++
Routine Description:
   Process all interrupts potentially from the USB.
   Stop the Host Controller from signalling interrupt
   and receive all time critical information.
   Currently the master interrupt is disabled (HC will not signal)
   until the DPC is completed.

Arguments:
   Ye old standard interrutp arguments.
   We hope that the service context is really a Device Object.

Return Value:
   Bool :  (Is the interrupt is for us?)

--*/
{
    ULONG ContextInfo, Temp, Frame;
    PDEVICE_OBJECT DeviceObject = (PDEVICE_OBJECT) ServiceContext;
    PHCD_DEVICE_DATA DeviceData;
    PHC_OPERATIONAL_REGISTER HC;

    DeviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    HC = DeviceData->HC;

    if (DeviceData->CurrentDevicePowerState != PowerDeviceD0) {
        // we cannot be generating interrupts unless we are 
        // in D0
        
#ifdef WIN98
        {
        ULONG status;
        
        Temp = READ_REGISTER_ULONG (&HC->HcInterruptEnable);
        
        status = (READ_REGISTER_ULONG(&HC->HcInterruptStatus) & Temp);
        if (DeviceData->CurrentDevicePowerState == PowerDeviceD2 &&
            status & HcInt_ResumeDetected) {
            goto OHCI_ACK_RESUME;
        }
        }
#endif
        return FALSE;
    }

#ifdef WIN98    
OHCI_ACK_RESUME:
#endif

    Temp = READ_REGISTER_ULONG (&HC->HcInterruptEnable);

    ContextInfo = (READ_REGISTER_ULONG (&HC->HcInterruptStatus) & Temp);
    if (0 == ContextInfo) {
        return FALSE;       /* Not our interrupt */
    }            

    if (0xFFFFFFFF == ContextInfo) {
        return FALSE;       /* Our device is not there! */
    }            

    if (! (Temp & HcInt_MasterInterruptEnable)) {
        return FALSE;
    }

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_ISR_NOISE,
                        ("'take interrupt status: 0x%x\n", ContextInfo));

    // any interrupt resets the idle counter
    DeviceData->IdleTime = 0;    

#if 0
    if (DeviceData->HcFlags & HC_FLAG_USE_HYDRA_HACK) {
        //hydra requires us to acknowlege the writeback done queue interrupt 
        //here

        if (ContextInfo & HcInt_WritebackDoneHead) {
            if (ContextInfo & HcInt_StartOfFrame) {

                //TEST_TRAP();
                // don't ack the done queue int 
                ContextInfo &= ~HcInt_WritebackDoneHead;

                OHCI_ASSERT(DeviceData->LastHccaDoneHead == 0);
                DeviceData->LastHccaDoneHead = DeviceData->HCCA->HccaDoneHead;
                OHCI_ASSERT(DeviceData->LastHccaDoneHead != 0);
            
                DeviceData->HCCA->HccaDoneHead = 0;
                WRITE_REGISTER_ULONG(&HC->HcInterruptStatus,
                                     HcInt_WritebackDoneHead);  /* ack inq */

                // enable SOF interrupt
                WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                                     HcInt_StartOfFrame); 
            } else {
                //TEST_TRAP();
                // enable SOF interrupt
                WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                                     HcInt_StartOfFrame); 
                // don't ack the done queue int                                 
                ContextInfo &= ~HcInt_WritebackDoneHead;
            }                                 
        }
    }
#endif

    if (DeviceData->HcFlags & HC_FLAG_IDLE) {
        OpenHCI_KdPrint((1, "'interrupt while controller is idle %x\n", ContextInfo));   
#if DBG        
        // should only see the rh status change
        if ((ContextInfo & ~(HcInt_RootHubStatusChange | HcInt_ResumeDetected))
#if FAKEPORTCHANGE
            && !DeviceData->FakePortChange
#endif
           )
        {
             TEST_TRAP();
        }             
#endif        
    }
        
    /* Our interrupt, prevent HC from doing it to us again til we're finished */
    WRITE_REGISTER_ULONG(&HC->HcInterruptDisable, HcInt_MasterInterruptEnable);

    DeviceData->CurrentHcControl.ul |= DeviceData->ListEnablesAtNextSOF.ul;
    DeviceData->ListEnablesAtNextSOF.ul = 0;
    WRITE_REGISTER_ULONG(&HC->HcControl.ul, DeviceData->CurrentHcControl.ul);

#if 0
    if (HC->HcControlHeadED) {
        WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, HcCmd_ControlListFilled);
    }
    if (HC->HcBulkHeadED) {
        WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, HcCmd_BulkListFilled);
    }
#endif
    // Note: The NEC controller is broken, writing a zero to the 
    // CommandStatus register for  HcCmd_ControlListFilled or 
    // HcCmd_BulkListFilled will disable the list (in violation
    // of the OHCI spec)
    {
    ULONG listFilled = 0;
    
    Temp = READ_REGISTER_ULONG (&HC->HcControlHeadED);
    if (Temp) {
        listFilled |= HcCmd_ControlListFilled;
    }
    Temp = READ_REGISTER_ULONG (&HC->HcBulkHeadED);
    if (Temp) {
        listFilled |= HcCmd_BulkListFilled;
    }
    //LOGENTRY(G, 'ENAL', listFilled, 0, 0); 
    WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, listFilled);
    }
    
    Frame = Get32BitFrameNumber(DeviceData);
    if (ContextInfo & (HcInt_SchedulingOverrun 
                       | HcInt_WritebackDoneHead
                       | HcInt_StartOfFrame
                       | HcInt_FrameNumberOverflow))
        ContextInfo |= HcInt_MasterInterruptEnable; /* flag for EOF irq's */

    // Today we ack but otherwise ignore a SchedulingOverrun interrupt.
    // In the future we may want to do something as suggested in section
    // 5.2.10.1 of the OpenHCI specification.
    //
    if (ContextInfo & HcInt_SchedulingOverrun)
    {
        WRITE_REGISTER_ULONG(&HC->HcInterruptStatus,
                             HcInt_SchedulingOverrun);  /* ack int */
                             
        ContextInfo &= ~HcInt_SchedulingOverrun;
    }

    /* Check for Frame Number Overflow The following insures that the 32 bit
     * frame never runs backward. */

    if (ContextInfo & HcInt_FrameNumberOverflow) {
        DeviceData->FrameHighPart
            += 0x10000 - (0x8000 & (DeviceData->HCCA->HccaFrameNumber
                                    ^ DeviceData->FrameHighPart));
        WRITE_REGISTER_ULONG(&HC->HcInterruptStatus, 
                             HcInt_FrameNumberOverflow);

        ContextInfo &= ~HcInt_FrameNumberOverflow;
#if DBG
        Temp = Get32BitFrameNumber(DeviceData);
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_ISR_NOISE,
                        ("'Frame number advance: 0x%x\n", Temp));
#endif
    }
    /* Construct a DPC with all the goodies and schedule it. */
    DeviceData->IsrDpc_Context.Frame = Frame;
    DeviceData->IsrDpc_Context.ContextInfo = ContextInfo;
    KeInsertQueueDpc(&DeviceData->IsrDPC, NULL, (PVOID) DeviceData);
    return TRUE;
}


VOID
OpenHCI_IsrDPC(
    PKDPC Dpc,
    PVOID DeviceObjectPtr,
    PVOID LaGarbage,
    PVOID DeviceDataPtr
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/               
{
    KIRQL oldIrql;
    PHC_OPERATIONAL_REGISTER HC;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    PHCD_ENDPOINT endpoint;
    ULONG frame, ContextInfo, DoneQueue;
    PHCD_DEVICE_DATA deviceData = DeviceDataPtr;
    ULONG HcDoneHead;

    frame = deviceData->IsrDpc_Context.Frame;
    ContextInfo = deviceData->IsrDpc_Context.ContextInfo;
    HC = deviceData->HC;

    KeAcquireSpinLockAtDpcLevel(&deviceData->HcFlagSpin);
    
#if DBG        
    OHCI_ASSERT((deviceData->HcFlags & HC_FLAG_IN_DPC) == 0);
    deviceData->HcFlags |= HC_FLAG_IN_DPC;
#endif
    
    if (deviceData->HcFlags & HC_FLAG_IDLE) {

        OpenHCI_KdPrint((1, "'controller going off idle\n"));        
        LOGENTRY(G, 'OFFi', deviceData, 0, 0);
        
        // not idle anymore
        deviceData->HcFlags &= ~HC_FLAG_IDLE;
        if (!KeSynchronizeExecution(deviceData->InterruptObject,
                                OpenHCI_StartController,
                                deviceData)) {
           TRAP(); //something has gone terribly wrong
        }
    }
    KeReleaseSpinLockFromDpcLevel(&deviceData->HcFlagSpin);    

    OpenHCI_KdPrintDD(deviceData, OHCI_DBG_ISR_TRACE,
                      ("'OpenHCI_IsrDpc, DD 0x%x, ContextInfo: 0x%x  \n",
                      deviceData, ContextInfo));

    if (ContextInfo & HcInt_UnrecoverableError) {   
        /* 
         * Here the controller is hung!
         */
        OpenHCI_KdPrint((0, "'Controller: Unrecoverable error!\n"));
        
        LOGENTRY(G, 'HC!!', deviceData, HC, ContextInfo);

#if DBG        
        KeAcquireSpinLockAtDpcLevel(&deviceData->HcFlagSpin);
        deviceData->HcFlags &= ~HC_FLAG_IN_DPC;
        KeReleaseSpinLockFromDpcLevel(&deviceData->HcFlagSpin);   
#endif

        // If we're not checking for a hung HC in OpenHCI_DeadmanDPC()
        // go ahead and reset the host controller now.
        //
        if ( !(deviceData->HcFlags & HC_FLAG_HUNG_CHECK_ENABLE) )
        {
            OpenHCI_ResurrectHC(deviceData);
        }

        return;
    }

#if DBG    
    if (ContextInfo & HcInt_ResumeDetected) {
        /* Resume has been requested by a device on the USB. HCD must wait
         * 20ms then put controller in the UsbOperational state. */
//        LARGE_INTEGER time;

//        time.QuadPart = 20 * 10000 * -1;
        /* Time is in units of 100-nanoseconds.  Neg vals are relative time. */

//        KeSetTimer(&deviceData->ResumeTimer, time, &deviceData->ResumeDPC);

        // Note: Nothing to do here accept possibly complete the waitwake irp
        // the root hub will handle resume signalling on the appropriate port

        LOGENTRY(G, 'reHC', deviceData, 0, ContextInfo); 
#ifdef MAX_DEBUG        
        TEST_TRAP();
#endif        
    }
#endif

    /* 
     * Process the Done Queue 
     */
     
    //
    // If the HC froze, first process any TDs that completed during the
    // last frame in which the TD froze.
    //

    HcDoneHead = InterlockedExchange(&deviceData->FrozenHcDoneHead, 0);

    if (HcDoneHead)
    {
        OpenHCI_ProcessDoneQueue(deviceData, HcDoneHead);
    }

#if 0
    if (ContextInfo & HcInt_WritebackDoneHead && 
        !(deviceData->HcFlags & HC_FLAG_USE_HYDRA_HACK)) {

        // should not get here is hydra fix is enabled
        OHCI_ASSERT(!(deviceData->HcFlags & HC_FLAG_USE_HYDRA_HACK));
#else        
    if (ContextInfo & HcInt_WritebackDoneHead) {
#endif
        
        DoneQueue = deviceData->HCCA->HccaDoneHead;
        LOGENTRY(G, 'donQ', deviceData, DoneQueue, ContextInfo);  

        if (DoneQueue == 0)
        {
            //
            // We got an HcInt_WritebackDoneHead but the HCCA->HccaDoneHead
            // was zero.  Apparently the HC failed to properly update the
            // HCCA->HccaDoneHead.  Try to recover the lost done head.
            //
            DoneQueue = FindLostDoneHead(deviceData);
            LOGENTRY(G, 'Lost', deviceData, DoneQueue, ContextInfo);  
            OHCI_ASSERT(DoneQueue != 0);
        }

        deviceData->HCCA->HccaDoneHead = 0;
        LOGENTRY(G, 'dnQZ', deviceData, DoneQueue, ContextInfo);  

        OpenHCI_KdPrintDD(deviceData, 
            OHCI_DBG_ISR_TRACE, ("'Checking WritebackDoneHead\n"));
        
        if (DoneQueue) {
            OpenHCI_ProcessDoneQueue(deviceData, (DoneQueue & 0xFFFFfffe));
            //
            // Note: No interrupts can come in while processing the done queue.
            //
        } 
    }

#if 0
    if (deviceData->LastHccaDoneHead) {
        // should only get here if hydra fix is enabled
//        TEST_TRAP();
        OHCI_ASSERT(deviceData->HcFlags & HC_FLAG_USE_HYDRA_HACK);

        DoneQueue = deviceData->LastHccaDoneHead;
        deviceData->LastHccaDoneHead = 0;

        LOGENTRY(G, 'dnQ2', deviceData, DoneQueue, ContextInfo);  
        OpenHCI_ProcessDoneQueue(deviceData, (DoneQueue & 0xFFFFfffe));

    }        
#endif
    
    /* 
     * Process Root Hub changes 
     */
     
    if (ContextInfo & HcInt_RootHubStatusChange
#if FAKEPORTCHANGE
         || deviceData->FakePortChange
#endif
       ) {

        OpenHCI_KdPrintDD(deviceData, OHCI_DBG_ISR_TRACE, 
                        ("' ROOT HUB STATUS CHANGE ! \n"));
        /* 
         * EmulateRootHubInterruptXfer will complete a
         * HCD_TRANSFER_DESCRIPTOR which we then pass to ProcessDoneQueue to
         * emulate an HC completion. 
         */

        LOGENTRY(G, 'RHxf', deviceData, 0, ContextInfo); 
        if (deviceData->RootHubInterrupt) {
            EmulateRootHubInterruptXfer(deviceData, HC);
        } else {
            // no root hub data, root hub is closed
            // disable the interrupt and ack the change
            WRITE_REGISTER_ULONG(&HC->HcInterruptDisable, 
                                 HcInt_RootHubStatusChange);
            WRITE_REGISTER_ULONG(&HC->HcInterruptStatus, 
                                 HcInt_RootHubStatusChange);                                  
         
        }            
        
        /* 
         * clear the RootHubStatusChange bit in context info
         * we have already cleared the status and/or disabled
         * the interrupt if necessary.
         */
         
        ContextInfo &= ~HcInt_RootHubStatusChange;
    }
    
    if (ContextInfo & HcInt_OwnershipChange) {
        OpenHCI_KdPrintDD(deviceData, OHCI_DBG_ISR_INFO, 
                        ("'OpenHCI_IsrDpc: Ownership CHANGE!\n"));
                        
        LOGENTRY(G, 'OWnr', deviceData, 0, ContextInfo);                         
        /* Only SMM drivers need implement this.  */
        TEST_TRAP();                 // No code path for this.
    }

    
    /* 
     * interrupt for SOF
     */
     
    if (ContextInfo & HcInt_StartOfFrame) {
        
        //LOGENTRY(G, 'SOFi', deviceData, 0, ContextInfo); 

        /*
         * we asked for an interrupt on the next SOF, 
         * now that we've gotten one we can disable again
         */

#if 0
        if (!(deviceData->HcFlags & HC_FLAG_USE_HYDRA_HACK))
#endif
        {
            ContextInfo &= ~HcInt_StartOfFrame;
            WRITE_REGISTER_ULONG(&HC->HcInterruptDisable, HcInt_StartOfFrame);
        }            
    }

    /* 
     * We've complete the actual service of the HC interrupts, now we must
     * deal with the effects. 
     */
     
    
    /* 
     * Look for things on the PausedEDRestart list. 
     *
     * Any ED that is on the pusedRestart list will be removed, its TDs
     * canceled and then restarted.
     * 
     */
     
    frame = Get32BitFrameNumber(deviceData);

    KeAcquireSpinLock(&deviceData->PausedSpin, &oldIrql);

    while (!IsListEmpty(&deviceData->PausedEDRestart))
    {
        OpenHCI_KdPrintDD(deviceData, 
            OHCI_DBG_ISR_TRACE, ("'Checking paused restart list\n"));
        ed = CONTAINING_RECORD(deviceData->PausedEDRestart.Flink,
                               HCD_ENDPOINT_DESCRIPTOR,
                               PausedLink);
        endpoint = ed->Endpoint;
        ASSERT_ENDPOINT(endpoint);
        LOGENTRY(G, 'pasR', deviceData, endpoint, ed); 
        
        if ((LONG) ed->ReclamationFrame - (LONG) frame > 0) {
            /* 
             * Now is the wrong time to remove this entry. but most likely
             * the very next frame will be so we will ask for an interrupt
             * at next SOF
             */
            
            ContextInfo |= HcInt_StartOfFrame;
            break;
        }

        /* 
         * remove the ed from the paused list and reset 
         * the state.
         */
        RemoveEntryList(&ed->PausedLink);

        if ((ed->HcED.HeadP & HcEDHeadP_HALT) || ed->HcED.sKip) { 
            KeReleaseSpinLock(&deviceData->PausedSpin, oldIrql);
        } else {
            // HC has not paused the ep yet, put it back on the list
            TEST_TRAP();
            InsertTailList(&deviceData->PausedEDRestart, &ed->PausedLink);
            
            continue;
        }  
        
        /* 
         * cancel the current transfers queued to this ed
         */
        OpenHCI_CancelTDsForED(ed);

        KeAcquireSpinLock(&deviceData->PausedSpin, &oldIrql);
    }
    KeReleaseSpinLock(&deviceData->PausedSpin, oldIrql);

    /* 
     * This code processed our reclimation lists ie EDs that
     * we need to free
     */
     
    if (ContextInfo & HcInt_MasterInterruptEnable) {
        // Do we have an "end of Frame" type interrupt? //
        
        ULONG newControlED = 0;
        ULONG newBulkED = 0;
        ULONG currentControlED
        = READ_REGISTER_ULONG(&HC->HcControlCurrentED);
        ULONG currentBulkED
        = READ_REGISTER_ULONG(&HC->HcBulkCurrentED);
        KeSynch_HcControl context;

        //
        // If of course either the control or bulk list is not stalled, then
        // the current ED pointer will continue to advance. Here we are
        // making the ASSUMPTION that the only way an ED from either of these
        // two lists made it onto the ReclamationList was by stalling their
        // respective Control or Bulk list. In that case the Current ED
        // pointer will remain quite happily the same number until the
        // control or bulk list is restarted.
        //


        /* Look for things on the StalledEDReclamation list */
        KeAcquireSpinLock(&deviceData->ReclamationSpin, &oldIrql);
        while (!IsListEmpty(&deviceData->StalledEDReclamation)) {
            OpenHCI_KdPrintDD(deviceData, OHCI_DBG_ISR_TRACE,
                            ("'Checking Stalled Reclamation list\n"));
            ed = CONTAINING_RECORD(deviceData->StalledEDReclamation.Flink,
                                   HCD_ENDPOINT_DESCRIPTOR,
                                   Link);

            LOGENTRY(G, 'REcs', deviceData, ed, 0);
            ASSERT(NULL == ed->Endpoint);
            /* 
             * The only way that this ED could have gotten itself on the
             * reclamation list was for it to have been placed there by a
             * RemoveEDForEndpoint call. This would have severed the
             * Endpoint. 
             */

            RemoveEntryList(&ed->Link);
            KeReleaseSpinLock(&deviceData->ReclamationSpin, oldIrql);

            if (ed->PhysicalAddress == currentControlED) {
                newControlED = currentControlED = ed->HcED.NextED;
            } else if (ed->PhysicalAddress == currentBulkED) {
                newBulkED = currentBulkED = ed->HcED.NextED;
            }                

            OpenHCI_Free_HcdED(deviceData, ed);

            // Need to enable SOF interrupts to generate an interrupt
            // so that HcControl is updated with ListEnablesAtNextSOF
            // to turn BLE and CLE back on after the next SOF.
            //
            ContextInfo |= HcInt_StartOfFrame;
            
            KeAcquireSpinLock(&deviceData->ReclamationSpin, &oldIrql);
        }
        KeReleaseSpinLock(&deviceData->ReclamationSpin, oldIrql);

        if (newControlED) {
            LOGENTRY(G, 'nQ1S', deviceData, newControlED, newBulkED);
            WRITE_REGISTER_ULONG(&HC->HcControlCurrentED, newControlED);
        }
        if (newBulkED) {
            LOGENTRY(G, 'nQ2S', deviceData, newControlED, newBulkED);
            WRITE_REGISTER_ULONG(&HC->HcBulkCurrentED, newBulkED);
        }
        /* Restart both queues. */

        context.DeviceData = DeviceDataPtr;
        context.NewHcControl.ul = HcCtrl_ControlListEnable
            | HcCtrl_BulkListEnable;
 
        KeSynchronizeExecution(deviceData->InterruptObject,
                               OpenHCI_ListEnablesAtNextSOF,
                               &context);
    }
    
    frame = Get32BitFrameNumber(deviceData);

    /* Look for things on the runningReclamationList */
    KeAcquireSpinLock(&deviceData->ReclamationSpin, &oldIrql);
    while (!IsListEmpty(&deviceData->RunningEDReclamation)) {
        PHCD_ENDPOINT_DESCRIPTOR ed;
        OpenHCI_KdPrintDD(deviceData, OHCI_DBG_ISR_TRACE,
                        ("'Checking running reclamation list\n"));

        ed = CONTAINING_RECORD(deviceData->RunningEDReclamation.Flink,
                               HCD_ENDPOINT_DESCRIPTOR,
                               Link);
        if ((LONG) ed->ReclamationFrame - (LONG) frame > 0) {
            ContextInfo |= HcInt_StartOfFrame;
            
            /* 
             * We need to remove this ED from the list, but now is not the
             * appropriate time.  Most likely, however, the very next Frame
             * will be the correct time, so reenable the start of frame
             * interrupt. 
             */
            break;
        }

        LOGENTRY(G, 'REcr', deviceData, ed, 0);
        ASSERT(NULL == ed->Endpoint);
        /* The only way that this bad boy could have gotten itself on the
         * reclamation list was for it to have been placed there by a
         * RemoveEDForEndpoint call. THis would have severed the Endpoint. */

        RemoveEntryList(&ed->Link);
        KeReleaseSpinLock(&deviceData->ReclamationSpin, oldIrql);

        OpenHCI_Free_HcdED(deviceData, ed);
        KeAcquireSpinLock(&deviceData->ReclamationSpin, &oldIrql);
    }
    KeReleaseSpinLock(&deviceData->ReclamationSpin, oldIrql);


    // Loop thru the list of active endpoints and see if we have a deferred 
    // work to do.
    
    KeAcquireSpinLock(&deviceData->HcDmaSpin, &oldIrql);

    // attempt to lock out access to ep worker
    deviceData->HcDma++;
    
    //LOGENTRY(G, 'pEPl', 0, 0, deviceData->HcDma);

    if (deviceData->HcDma) {

        // EP worker is busy, bail
        deviceData->HcDma--;
        KeReleaseSpinLock(&deviceData->HcDmaSpin, oldIrql); 
        goto Openhci_ISRDPC_Done;
    }        

    if (IsListEmpty(&deviceData->ActiveEndpointList)) {

        // queue is empty, bail
        //LOGENTRY(G, 'EPmt', 0, 0, deviceData->HcDma);
        deviceData->HcDma--;
        KeReleaseSpinLock(&deviceData->HcDmaSpin, oldIrql); 
        goto Openhci_ISRDPC_Done;
        
    } 

    // at this point we have exclusive access to ep worker
    
    do {
    
        PHCD_ENDPOINT endpoint;
        PLIST_ENTRY entry;

        LOGENTRY(G, 'epLS', &deviceData->ActiveEndpointList, 0, 0);      
        
        entry = RemoveHeadList(&deviceData->ActiveEndpointList);

        // use DMA spin to serialize access to the list
        
        endpoint = CONTAINING_RECORD(entry,
                                     HCD_ENDPOINT,
                                     EndpointListEntry);

        LOGENTRY(G, 'gtEP', endpoint, 0, 0);                                     
        CLR_EPFLAG(endpoint, EP_IN_ACTIVE_LIST);  
        KeReleaseSpinLock(&deviceData->HcDmaSpin, oldIrql); 

        OpenHCI_EndpointWorker(endpoint);  

        KeAcquireSpinLock(&deviceData->HcDmaSpin, &oldIrql);

    } while (!IsListEmpty(&deviceData->ActiveEndpointList));

    LOGENTRY(G, 'pEPd', 0, 0, 0);

    // release ep worker
    deviceData->HcDma--;
    KeReleaseSpinLock(&deviceData->HcDmaSpin, oldIrql); 

Openhci_ISRDPC_Done:

    OpenHCI_KdPrintDD(deviceData, 
        OHCI_DBG_ISR_TRACE, ("'Exit Isr DPC routine\n"));

#if DBG        
    //
    // As soon as interrupts are reenabled, the interrupt service routine
    // may execute and queue another call to the DPC.  This routine must
    // be prepared to be reentered as soon as interrupts are reenabled.
    // So this routine should not do anything that cannot handle being
    // reentered after interrupts are reenabled.
    //
    KeAcquireSpinLockAtDpcLevel(&deviceData->HcFlagSpin);
    deviceData->HcFlags &= ~HC_FLAG_IN_DPC;
    KeReleaseSpinLockFromDpcLevel(&deviceData->HcFlagSpin);   
#endif
    
    // Acknowledge the interrupts we handled and reenable interrupts.
    //
    ContextInfo |= HcInt_MasterInterruptEnable;
    WRITE_REGISTER_ULONG(&HC->HcInterruptStatus, ContextInfo);
    WRITE_REGISTER_ULONG(&HC->HcInterruptEnable, ContextInfo);
}


VOID
OpenHCI_Free_HcdED(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_ENDPOINT_DESCRIPTOR Ed
    )
/*
 * Place the corresponding ED back onto the Free Descriptors list.
 * Presumably the only reason the ED got here was because it was
 * FIRST sent to RemoveEDForEndpoint which freed all of the
 * outstanding TD's, INCLUDING the stub TD.
 *
 * This of course means that the pointers to TD's are invalid.
 * SECOND the ED was placed on the reclamation list and the
 * DPCforIRQ moved it here.

 * This function is only called in the DPC for Irq.  If another
 * function wishes to free an endpoint it must call RemoveEDForEndpoint,
 * which will add the ED to the reclamation list to be freed on the
 * next Start O Frame.
 */

{
    OHCI_ASSERT(Ed);
    OHCI_ASSERT(NULL == Ed->Endpoint);
    OHCI_ASSERT((Ed->HcED.HeadP & ~0X0F) == Ed->HcED.TailP);
    
    LOGENTRY(G, 'frED', DeviceData, Ed, 0);
    
    OHCI_ASSERT((Ed->PhysicalAddress & (PAGE_SIZE-1)) ==
                ((ULONG_PTR)Ed & (PAGE_SIZE-1)));

    OHCI_ASSERT(Ed->Flags == (TD_FLAG_INUSE | TD_FLAG_IS_ED));
    Ed->Flags = 0;

    ExInterlockedPushEntryList(&DeviceData->FreeDescriptorList,
                               (PSINGLE_LIST_ENTRY) Ed,
                               &DeviceData->DescriptorsSpin);
}


VOID
OpenHCI_CancelTDsForED(
    PHCD_ENDPOINT_DESCRIPTOR Ed
)
/*++
Routine Description:
   Given an ED search through the list of TDs and weed out those with
   problems.
   
   It is ASSUMED that if the ED got to this list that either
   it has been paused (the sKip bit is set & a new SOF has occured)
   or it has been halted by the HC.

   It is possible that at the time of cancel of TD's for this endpoint
   that some of the canceled TDs had already made it to the done queue.
   We catch that by setting the TD Status field to .
   That way, when we are processing the DoneQueue, we can skip over those
   TDs.

   Note: This routine was originally called ProcessPausedED.

Aguments:
   ED - the ED that is inspected.

--*/
{
    PHCD_ENDPOINT               endpoint;
    PHCD_DEVICE_DATA            DeviceData;
    PHC_OPERATIONAL_REGISTER    HC;
    PHCD_URB                    urb;
    PHCD_TRANSFER_DESCRIPTOR    td;
    PHCD_TRANSFER_DESCRIPTOR    last = NULL;
    PHCD_TRANSFER_DESCRIPTOR   *previous;
    BOOLEAN                     B4Head = TRUE;
    ULONG                       physicalHeadP;
    KIRQL                       oldIrql;
    LIST_ENTRY                  CancelList;
    PIRP                        AbortIrp;

    endpoint = Ed->Endpoint;
    ASSERT_ENDPOINT(endpoint);
    OHCI_ASSERT(NULL != endpoint);
    OHCI_ASSERT((Ed->HcED.HeadP & HcEDHeadP_HALT) || Ed->HcED.sKip);
    OHCI_ASSERT(Ed->PauseFlag == HCD_ED_PAUSE_NEEDED);

    if (endpoint->TrueTail) {
        LOGENTRY(G, 'cTTl', endpoint->TrueTail, 
            endpoint->HcdTailP, endpoint);
                    
        // Bump the software tail pointer to the true tail for this transfer
        //
        endpoint->HcdTailP = endpoint->TrueTail;
        endpoint->TrueTail = NULL;

        // Bump the hardware tail pointer to the true tail for this transfer
        //
        endpoint->HcdED->HcED.TailP = endpoint->HcdTailP->PhysicalAddress;
    }

    //
    // The endpoint has been stopped, we need to walk thru
    // the list of HW TDs and remove any that are associated 
    // canceled transfers.
    //
    
    DeviceData = endpoint->DeviceData;
    HC = DeviceData->HC;

    InitializeListHead(&CancelList);

    KeAcquireSpinLock(&DeviceData->PausedSpin, &oldIrql);

CancelTDsOneMoreTime:
    
    Ed->PauseFlag = HCD_ED_PAUSE_PROCESSING;

    KeReleaseSpinLock(&DeviceData->PausedSpin, oldIrql);


    // lock down the endpoint
    OpenHCI_LockAndCheckEndpoint(endpoint, 
                                 NULL,
                                 NULL,                         
                                 &oldIrql);
                                 
    LOGENTRY(G, 'xxED', DeviceData, endpoint, Ed); 

    td = endpoint->HcdHeadP;
    previous = &endpoint->HcdHeadP;
    LOGENTRY(G, 'xED1', DeviceData, td, previous); 
    /* aka the location where the previous TD holds the current TD. */

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE,
                    ("'Calling Cancel TD's For ED %x %x hd = %x\n", 
                    endpoint->HcdHeadP, 
                    endpoint->HcdTailP, 
                    &endpoint->HcdHeadP));
                    
    physicalHeadP = (Ed->HcED.HeadP & ~HcEDHeadP_FLAGS);
    while (td != endpoint->HcdTailP) {

        LOGENTRY(G, 'xEDy', td->PhysicalAddress, td, physicalHeadP); 
        if (physicalHeadP == td->PhysicalAddress) {
            // aka is The first TD on the Enpoint list of TD's is the
            // same as the first HC_TD on the Host Controller list
            // of HC_TD's?
            // The HC could have processed some TD's that we have yet to
            // process.
            //
            B4Head = FALSE;
        }

        //
        // get the urb associated with this TD
        //
        
        urb = td->UsbdRequest;
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_NOISE,
                     ("'Endpoint:%x ED:%x TD:%x trans:%x stat:%x abort:%x\n",
                      endpoint, Ed, td,
                      &urb->HcdUrbCommonTransfer,
                      urb->UrbHeader.Status,
                      endpoint->EpFlags));
                      
        LOGENTRY(G, 'xREQ', DeviceData, urb, td);                       

        //
        // either this is a specific request to cancel or 
        // we are aborting all transfers for the ED
        //
        if ((USBD_STATUS_CANCELING == urb->UrbHeader.Status) ||
             endpoint->EpFlags & EP_ABORT) {

            PHC_TRANSFER_DESCRIPTOR hcTD;
            struct _URB_HCD_COMMON_TRANSFER *transfer;
                            
            OpenHCI_KdPrintDD(DeviceData, 
                OHCI_DBG_TD_NOISE, ("'Killing TD\n"));
                
            LOGENTRY(G, 'xxTD', DeviceData, urb, td);  
            OHCI_ASSERT(!td->Canceled);
            
            RemoveEntryList(&td->RequestList);
            td->Canceled = TRUE;
            td->Endpoint = NULL;

            transfer = &urb->HcdUrbCommonTransfer;
            hcTD = &td->HcTD;

            // Only update transfer count if transfer count is non-zero
            //
            if (td->TransferCount)
            {
                td->TransferCount -=
                /* have we gone further than a page? */
                ((((hcTD->BE ^ hcTD->CBP) & ~OHCI_PAGE_SIZE_MASK)
                      ? OHCI_PAGE_SIZE : 0) +
                /* minus the data buffer not used */
                ((hcTD->BE & OHCI_PAGE_SIZE_MASK) - 
                 (hcTD->CBP & OHCI_PAGE_SIZE_MASK)+1));
            
                LOGENTRY(G, 'xfB2', hcTD->BE & OHCI_PAGE_SIZE_MASK, 
                             hcTD->CBP & OHCI_PAGE_SIZE_MASK,
                             td->TransferCount);  
        
                transfer->TransferBufferLength += td->TransferCount;            
            }                
            
            if (IsListEmpty(&urb->HcdUrbCommonTransfer.hca.HcdListEntry2))
            { 
                // AKA all of the TD's for this URB have been delt with.

                OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE,
                                ("'Return canceled off hardware\n"));
                                
                LOGENTRY(G, 'CANu', DeviceData, urb, td);  

                // Put it on the cancel list
                //
                if (!urb->HcdUrbCommonTransfer.hca.HcdListEntry.Flink)
                {
                    LOGENTRY(G, 'canA', DeviceData, urb, td);      

                    InsertTailList(&CancelList, 
                                   &urb->HcdUrbCommonTransfer.hca.HcdListEntry);
                }                        
            }

            *previous = td->NextHcdTD;
            // link around the TD

            if (NULL == last) {
                //
                // For bulk and interrupt endpoints, TDs are queued with a
                // dataToggle == 00b.  After the first data packet is
                // successfully transferred, the MSb of dataToggle is set to
                // indicate that the LSb indicates the next toggle value.
                // The toggleCarry of the ED is only updated with the dataToggle
                // of the TD when the TD makes it to the doneQueue.  Manually
                // update the ED with the toggle of the last TD that transferred
                // data when a transfer is cancelled.
                //
                if (td->HcTD.Toggle == 3) {
                    Ed->HcED.HeadP = (td->HcTD.NextTD & ~HcEDHeadP_FLAGS) |
                                     HcEDHeadP_CARRY;
                } else if (td->HcTD.Toggle == 2) {
                    Ed->HcED.HeadP = (td->HcTD.NextTD & ~HcEDHeadP_FLAGS);
                } else {
                    Ed->HcED.HeadP = ((td->HcTD.NextTD & ~HcEDHeadP_FLAGS) |
                                      (Ed->HcED.HeadP & HcEDHeadP_CARRY));
                }
                LOGENTRY(G, 'BMPh', DeviceData, td->HcTD.Toggle, 0);
                OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_NOISE,
                                ("'cancelTDsForED bumping HeadP\n"));
            } else {
                last->HcTD.NextTD = td->HcTD.NextTD;
                LOGENTRY(G, 'BMPn', DeviceData, 0, 0);     
                OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_NOISE,
                                ("'cancelTDsForED not bumping HeadP\n"));
            }

            //
            // If the TD is not yet on the Done queue,
            // aka the HC has yet to see it, then Free it now.
            // Otherwise flag it so that the Process Done Queue
            // routine can free it later
            //
            if (!B4Head) {
                OpenHCI_Free_HcdTD(DeviceData, td);
            }
        } else {
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_NOISE, 
                ("'TD Spared, next = %x\n", &td->NextHcdTD));
            LOGENTRY(G, 'skTD', DeviceData, td, 0);                  
            
            previous = &td->NextHcdTD;
            if (!B4Head) {
                last = td;
            }                
        }
        td = *previous;
    }
    
    LOGENTRY(G, 'uTal', DeviceData, Ed->HcED.TailP, 
        endpoint->HcdTailP->PhysicalAddress);  

    Ed->HcED.TailP = endpoint->HcdTailP->PhysicalAddress;

    OpenHCI_UnlockEndpoint(endpoint, 
                           oldIrql);

    // Now complete all of the transfers which we put it on the cancel list.
    //
    while (!IsListEmpty(&CancelList))
    { 
        PLIST_ENTRY entry;

        entry = RemoveHeadList(&CancelList);

        urb = CONTAINING_RECORD(entry,
                                HCD_URB,
                                HcdUrbCommonTransfer.hca.HcdListEntry);

        LOGENTRY(G, 'CANq', DeviceData, urb, 0);                                  

        //
        // We may be canceling a request that is still in the
        // cancelable state (if we got here because the abortAll
        // flag was set) in that case we take the cancel spinlock
        // and set the cancel routine
        //

        IoAcquireCancelSpinLock(&oldIrql);
        IoSetCancelRoutine(urb->HcdUrbCommonTransfer.hca.HcdIrp, NULL);
        IoReleaseCancelSpinLock(oldIrql);

        OpenHCI_CompleteUsbdTransferRequest(urb, 
                                            USBD_STATUS_CANCELED,
                                            STATUS_CANCELLED,
                                            TRUE);
    }

    //
    // If we completed any requests above, it might have triggered the
    // cancelling of additional requests on the same endpoint.  Process
    // cancelling the TDs for this ED one more time, if necessary.
    //

    KeAcquireSpinLock(&DeviceData->PausedSpin, &oldIrql);

    if (Ed->PauseFlag == HCD_ED_PAUSE_NEEDED)
    {
        goto CancelTDsOneMoreTime;
    }
    else
    {
        Ed->PauseFlag = HCD_ED_PAUSE_NOT_PAUSED;

        if (endpoint->EpFlags & EP_FREE)
        {
            KeReleaseSpinLock(&DeviceData->PausedSpin, oldIrql);

            RemoveEDForEndpoint(endpoint);
        }
        else
        {
            /* 
             * restart the ED
             */
            Ed->HcED.HeadP = (endpoint->HcdHeadP->PhysicalAddress
                              | (Ed->HcED.HeadP & HcEDHeadP_CARRY))
                             & ~HcEDHeadP_HALT;

            Ed->HcED.sKip = FALSE;

            //
            // tell the HC we have something on the ED lists
            //
            ENABLE_LIST(HC, endpoint)

            KeReleaseSpinLock(&DeviceData->PausedSpin, oldIrql);
        }
    }

    // Complete the abort irp now if we have one   
    //
    KeAcquireSpinLock(&DeviceData->PausedSpin, &oldIrql);
    
    AbortIrp = endpoint->AbortIrp;
            
    endpoint->AbortIrp = NULL;

    CLR_EPFLAG(endpoint, EP_ABORT);

    KeReleaseSpinLock(&DeviceData->PausedSpin, oldIrql);

    if (AbortIrp != NULL)
    {
        LOGENTRY(G, 'cABR', 0, endpoint, AbortIrp); 

        OpenHCI_CompleteIrp(DeviceData->DeviceObject, AbortIrp, STATUS_SUCCESS);        
    }

    LOGENTRY(G, 'xED>', DeviceData, endpoint, 0); 
}


VOID
OpenHCI_CompleteUsbdTransferRequest(
    PHCD_URB Urb,
    USBD_STATUS UsbdStatus,
    NTSTATUS Completion,
    BOOLEAN RequestWasOnHardware
)
/*++

Routine Description:
   This urb in the posible linked list of urbs has finished.
   First return its resources back to the system.
   
   Then (if it is the last of the urbs in the list) inform
   the original caller by completing the IRP.

Arguments:
   The request that will be completed.
   The completion code for the IRP.
--*/
{
    struct _URB_HCD_COMMON_TRANSFER *transfer = 
        &Urb->HcdUrbCommonTransfer;
    PMDL mdl = transfer->TransferBufferMDL;
    PHCD_ENDPOINT endpoint = transfer->hca.HcdEndpoint;
    PHCD_DEVICE_DATA DeviceData = endpoint->DeviceData;
    LONG epStatus;

    ASSERT_ENDPOINT(endpoint);

    LOGENTRY(G, 'cmpt', DeviceData, endpoint, Urb); 
    
    // The transfer only has map registers allocated if it made it through
    // IoAllocateAdapterChannel() to OpenHCI_QueueGeneralRequest(), in which
    // case the status should no longer be HCD_PENDING_STATUS_QUEUED.
    // Don't call IoFlushAdapterBuffers() and IoFreeMapRegisters() if the
    // request has not made it through IoAllocateAdapterChannel() yet.
    //
    if (NULL != mdl &&
        transfer->Status != HCD_PENDING_STATUS_QUEUED)
    {
        ULONG NumberMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES
        (MmGetMdlVirtualAddress(mdl),
         MmGetMdlByteCount(mdl));

        LOGENTRY(G, 'flsh', DeviceData, mdl, NumberMapRegisters);  
        IoFlushAdapterBuffers(
                DeviceData->AdapterObject, // BusMaster card
                transfer->TransferBufferMDL,
                transfer->hca.HcdExtension,  // The MapRegisterBase
                (char *) MmGetMdlVirtualAddress(transfer->TransferBufferMDL),
                transfer->TransferBufferLength,
                (BOOLEAN) ! 
                    (transfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN));
                    
        LOGENTRY(G, 'frmp', DeviceData, mdl, NumberMapRegisters);  
        IoFreeMapRegisters(DeviceData->AdapterObject,
                           transfer->hca.HcdExtension, //MmGetMdlVirtualAddress(mdl),
                           NumberMapRegisters);
    } else {
        LOGENTRY(G, 'frmZ', DeviceData, transfer->Status, 0);  
       // IoFreeMapRegisters(DeviceData->AdapterObject,
       //                    NULL,/* VirtualAddress */
       //                    0);  /* Number of map registers */
    }

    if (RequestWasOnHardware) {
        epStatus = InterlockedDecrement(&endpoint->EndpointStatus);
        LOGENTRY(G, 'dcS1', 0, endpoint, epStatus ); 
#if DBG
        if (endpoint->MaxRequest == 1) {
            // in limit xfer mode we should always be 0 here.
            OHCI_ASSERT(epStatus == 0);
        }
#endif          
        
    } else {
        epStatus = endpoint->EndpointStatus;
        LOGENTRY(G, 'epS1', 0, endpoint, epStatus ); 
    }
    OHCI_ASSERT(epStatus >= 0);
    
    LOGENTRY(G, 'epck', DeviceData, endpoint->MaxRequest, epStatus);  
    if (endpoint->MaxRequest > epStatus) {
        /* 
         * If there is space in the hardware TD queue (There is always room
         * for two entries) then pop whatever is on the top of the software
         * queue and place it and the hardware queue as a TD: aka start it.
         * 
         * EndpointStatus is now zero based, not -1 based so the rest of the
         * comment below is not quite correct...
         *
         * Why not (InterlockedDecrement < 1) as the test you might ask... If
         * there is only one transfer turned into TD's, then EndpointStatus
         * is 0, and the decrement makes it -1.  In this case we know we do
         * not need to call EndpointWorker.  There is nothing on the software
         * queue.  If there were, than when it was actually added to the
         * queue, it would have noticed that there was room to convert it
         * into actual TD's (making EndpointStatus = 1). 
         */

        OpenHCI_ProcessEndpoint(DeviceData, endpoint); 
    } 

    //
    // update the status
    //
    
    ASSERT(transfer->Status == HCD_PENDING_STATUS_SUBMITTED ||
           transfer->Status == HCD_PENDING_STATUS_QUEUED ||
           transfer->Status == USBD_STATUS_CANCELING);

    LOGENTRY(G, 'cmST', DeviceData, transfer, UsbdStatus);            
    transfer->Status = UsbdStatus;
    
    ASSERT(transfer->UrbLink == NULL);

    transfer->Status = UsbdStatus;

    OpenHCI_CompleteIrp(endpoint->DeviceData->DeviceObject,
                        transfer->hca.HcdIrp,
                        Completion);
}


VOID
OpenHCI_CancelTransfer(
    PDEVICE_OBJECT UsbDeviceObject,
    PIRP Irp
)
/*++
Routine Description:
   Remove from the software and hardware queues any and all URB's and TD's
   associated with this Irp.  Mark as cancelling each URB from this Irp, 
   they may be linked, and then put the endpoint into a paused state. The 
   function, Cancel TDs for ED will then remove all TD associated with a 
   cancelling URB.

   STATUS_PENDING_QUEUED means we put it in the endpoint QUEUE
   STATUS_PENDING_SUBMITTED means we programmed it to the hardware

Arguments:
   Device:  The device Object for which the Irp was destined.
   Irp:     The doomed IRP.

--*/
{
    PHCD_DEVICE_DATA    DeviceData;
    PHCD_ENDPOINT       endpoint;
    KIRQL               oldIrql;
    struct _URB_HCD_COMMON_TRANSFER *transfer;
    PDEVICE_OBJECT      deviceObject;
    PUSBD_EXTENSION     de;
    BOOLEAN             wasOnHardware = FALSE;
    BOOLEAN             wasQueued = TRUE;

    //
    // first we need our extension
    //
    
    de = UsbDeviceObject->DeviceExtension;
    if (de->TrueDeviceExtension == de) {
        deviceObject = UsbDeviceObject;
    } else {
        de = de->TrueDeviceExtension;
        deviceObject = de->HcdDeviceObject; 
    }          

    DeviceData = (PHCD_DEVICE_DATA) deviceObject->DeviceExtension;   

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CANCEL_TRACE, 
        ("'Cancel Transfer irp = %x\n", Irp));

    ASSERT(TRUE == Irp->Cancel);

    transfer = &((PHCD_URB) URB_FROM_IRP(Irp))->HcdUrbCommonTransfer;
    
    endpoint = transfer->hca.HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);
    
    LOGENTRY(G, 'CANx', DeviceData, Irp, endpoint);   
    IoSetCancelRoutine(Irp, NULL);

    // lock down the endpoint
    OpenHCI_LockAndCheckEndpoint(endpoint, 
                                 NULL,
                                 NULL,                         
                                 &oldIrql);
                                         
    //
    // now find all transfers linked to this irp and 
    // cancel them, 'transfer' points to the first one.
    //
    
    while (transfer) {
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CANCEL_INFO,
                        ("'Canceling URB trans 0x%x End 0x%x \n",
                         transfer, endpoint));

        LOGENTRY(G, 'CAur', Irp, transfer, endpoint);                            

        ASSERT((URB_FUNCTION_CONTROL_TRANSFER == transfer->Function) ||
          (URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER == transfer->Function) ||
          (URB_FUNCTION_ISOCH_TRANSFER == transfer->Function));                            

        // Here we are assuming that all URBs on a single IRP have are
        // desten for the same endpoint.
        ASSERT(transfer->hca.HcdEndpoint == endpoint);
        
        // 
        // cancel this transfer
        //
        if (transfer->Status == HCD_PENDING_STATUS_QUEUED) {
            //
            // See if the request is still queued and we need to remove it
            //
            if (transfer->hca.HcdListEntry.Flink != NULL)
            {
                // pull it off our queue
                //
                LOGENTRY(G, 'caQR', Irp, transfer, endpoint);  

                OHCI_ASSERT(transfer->hca.HcdListEntry.Blink != NULL);

                RemoveEntryList(&transfer->hca.HcdListEntry);

                transfer->hca.HcdListEntry.Flink = NULL;
                transfer->hca.HcdListEntry.Blink = NULL;
            }                
            else
            {
                // The request no longer appears to be queued on the
                // endpoint.
                //
                LOGENTRY(G, 'caNR', Irp, transfer, endpoint);  

                wasQueued = FALSE;
            }

        } else if (transfer->Status == HCD_PENDING_STATUS_SUBMITTED) {
            //
            // this transfer urb is on the hardware
            //
            LOGENTRY(G, 'caPR', Irp, transfer, endpoint);  
            transfer->Status = USBD_STATUS_CANCELING;

            // put it on the cancel list before we release with
            // the endpoint, onec we release the endpoint
            // CaneclTDsforED can pick it up and cancel it
            wasOnHardware = TRUE;
            
            OHCI_ASSERT(transfer->hca.HcdListEntry.Flink == NULL);
            LOGENTRY(G, 'cXAQ', Irp, transfer, transfer->Status); 

            // CancelTDsFor ED will put this on the cancel list 
            // when the TDS have been removed from the EP
            //InsertTailList(&endpoint->CancelList, 
            //               &transfer->hca.HcdListEntry);
        }

        if (transfer->UrbLink) {
            transfer = &transfer->UrbLink->HcdUrbCommonTransfer;
        } else {
            transfer = NULL;
        }
    }

    OpenHCI_UnlockEndpoint(endpoint, 
                           oldIrql);

    //
    // the transfer is now removed from the endpoint
    // it is safe to let things run now

    LOGENTRY(G, 'Rcsp', DeviceData, Irp, Irp->CancelIrql);           
    IoReleaseCancelSpinLock(Irp->CancelIrql);                           

    // now complete the transfers that were queued

    if (wasOnHardware) {
        // note that if the transfer was on the hardware it may be complet 
        // by now so we cannot touch it
        LOGENTRY(G, 'WAhw', endpoint, 0, 0);              

        // this will cause cancelTDs for ED to pick it up and 
        // cancel it
        OpenHCI_PauseED(endpoint);        
        
    } else if (wasQueued) {
    
        transfer = &((PHCD_URB) URB_FROM_IRP(Irp))->HcdUrbCommonTransfer;

        while (transfer) {       
            
            LOGENTRY(G, 'caDN', Irp, transfer, transfer->Status);  

            if (transfer->Status == HCD_PENDING_STATUS_QUEUED) {
            
                struct _URB_HCD_COMMON_TRANSFER *nextTransfer;
                
                LOGENTRY(G, 'caQD', Irp, transfer, transfer->Status);  

                // check the link before we complete
                if (transfer->UrbLink) {
                   nextTransfer = &transfer->UrbLink->HcdUrbCommonTransfer;
                } else {
                   nextTransfer = NULL;
                }     
                
                OpenHCI_CompleteUsbdTransferRequest((PHCD_URB) transfer, 
                                                    USBD_STATUS_CANCELED,
                                                    STATUS_CANCELLED,
                                                    FALSE);            
                transfer = nextTransfer;
                
            } else if (transfer->Status == USBD_STATUS_CANCELING) {
                //
                // at least one of the urbs for this Irp is on the hardware 
                // so we'll need to stop the ed and remove the TDs.  
                //
                TRAP();
                // sould not get here

            } else {
                // the transfer completed while we were canecling
                //
                // we need to complete it here
                //
                struct _URB_HCD_COMMON_TRANSFER *nextTransfer;


                LOGENTRY(G, 'CALc', 0, transfer, transfer->Status);  
                // check the link before we complete
                if (transfer->UrbLink) {
                   nextTransfer = &transfer->UrbLink->HcdUrbCommonTransfer;
                } else {
                   nextTransfer = NULL;
                }  
                
                OpenHCI_CompleteUsbdTransferRequest((PHCD_URB) transfer, 
                                                    USBD_STATUS_CANCELED,
                                                    STATUS_CANCELLED,
                                                    FALSE);   
                transfer = nextTransfer;                                                
            }

        }        
    }
    
    OpenHCI_KdPrintDD(DeviceData, 
        OHCI_DBG_CANCEL_TRACE, ("'Exit Cancel Trans\n"));
    
}


VOID
OpenHCI_ProcessDoneTD(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    BOOLEAN FreeTD
)
/*++

Routine Description:

Parameters
    
--*/
{
    PHCD_URB urb;
    struct _URB_HCD_COMMON_TRANSFER *transfer;
    PHCD_ENDPOINT endpoint;
    PHC_TRANSFER_DESCRIPTOR hcTD;
    PHC_ENDPOINT_DESCRIPTOR hcED;
    USBD_STATUS usbdStatus;
    BOOLEAN complete = FALSE;
    NTSTATUS status = STATUS_SUCCESS;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    KIRQL oldIrql;
    
    hcTD = &Td->HcTD;

    LOGENTRY(G, 'TDdn', DeviceData, Td, 0);    

    if (Td->Canceled) {     
        // td has been marked canceled -- this means it was 
        // already processed by cancel, all we need to do is
        // free it.
        // (See the CancelTDsForED routine)
        LOGENTRY(G, 'frCA', DeviceData, Td, 0);  
        if (FreeTD) {
            OpenHCI_Free_HcdTD(DeviceData, Td);
        }            
        return;
    }

    OHCI_ASSERT(Td->UsbdRequest != MAGIC_SIG);       
    
    urb = Td->UsbdRequest;
    endpoint = Td->Endpoint;
    transfer = &urb->HcdUrbCommonTransfer;

    LOGENTRY(G, 'TDde', endpoint, urb, transfer);
    
    ASSERT_ENDPOINT(endpoint);
    OHCI_ASSERT(urb);
    OHCI_ASSERT(transfer);
    OHCI_ASSERT(TD_NOREQUEST_SIG != urb);

    // process the completed TD
    
    ed = endpoint->HcdED;
    hcED = &ed->HcED;

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_NOISE,
                    ("'Endpoint: %x ED: %x\n", endpoint, ed));

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE,
                ("'TD Done, code: %x, Directn: %x, addr: %d, end#: %d\n",
                 hcTD->ConditionCode, hcTD->Direction,
                 hcED->FunctionAddress, hcED->EndpointNumber));

    if (endpoint->Type == USB_ENDPOINT_TYPE_ISOCHRONOUS) {
        complete = 
            OpenHCI_ProcessDoneIsoTD(DeviceData,
                                     Td,
                                     endpoint,
                                     hcTD,
                                     &status,
                                     &usbdStatus,
                                     urb,
                                     FreeTD);
    } else {
        complete = 
            OpenHCI_ProcessDoneAsyncTD(DeviceData,
                                       Td,
                                       endpoint,
                                       hcTD,
                                       &status,
                                       &usbdStatus,
                                       urb,
                                       FreeTD);
    }
    
    if (complete) {

        //
        // urb associated with this TD is complete
        //

        IoAcquireCancelSpinLock(&oldIrql);
        
        //
        // now that we have cleared the cancel routine
        // it is safe to modify the status field of 
        // the urb.
        //
            
        IoSetCancelRoutine(transfer->hca.HcdIrp, NULL);
        IoReleaseCancelSpinLock(oldIrql);

        // now comlete the urb
        LOGENTRY(G, 'urbC', urb, status, usbdStatus);
        OpenHCI_CompleteUsbdTransferRequest(urb, 
                                            usbdStatus,
                                            status,
                                            TRUE);
    }
}    


VOID
OpenHCI_ProcessDoneQueue(
    PHCD_DEVICE_DATA DeviceData,
    ULONG physHcTD 
)
/*++

Routine Description:
   Periodically the HC places the list of TD's that is has completed
   on to the DoneList.
   This routine, called by Dpc for ISR, walks that list, which must
   be reversed, and finishes any processing.

   There are packets that completed normally, Ins and outs.
   There are also canceled TDs,

Parameters
    
   physHcTD - Hcca Done Head pointer (logical address) 
   
--*/
{
    PHCD_TRANSFER_DESCRIPTOR td, tdList = NULL;
    PHC_OPERATIONAL_REGISTER HC;
    KIRQL oldIrql;
#if DBG
    //PCHAR Buffer;
#endif
    BOOLEAN complete = FALSE;
    NTSTATUS status = STATUS_SUCCESS;

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_TD_TRACE, ("'Phys TD:%x\n", physHcTD));

    if (0 == physHcTD) {
        //
        // nothing to do
        //
        LOGENTRY(G, 'idle', DeviceData, 0, 0); 
        return;
    }

    // 
    // OK we have some TDs on the list,
    // process them
    
    HC = DeviceData->HC;
    
    KeAcquireSpinLock(&DeviceData->PageListSpin, &oldIrql);
    
    do {
        td = OpenHCI_LogDesc_to_PhyDesc(DeviceData, physHcTD);

        LOGENTRY(G, 'dnTD', DeviceData, td, physHcTD);                                
        OHCI_ASSERT(td);
        //
        // If TD comes back from LogDesc to PhyDesc as zero then
        // this was not a HcTD corresponding to a know HcdTD.
        // The controller has given us a bogus hardware address for HcTD.
        //
        if (td == NULL)
        {
            // Something is not quite right, hope we haven't lost some TDs.
            //
            break;
        }

        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_NOISE,
                        ("'---Virt TD %x from done list: %x\n",
                         td, physHcTD));
        physHcTD = td->HcTD.NextTD;

        //
        // Since the HC places TD's into the done list
        // in the reverse order in which they were processed,
        // we nee to reverse this list.
        //
        // We do this by bastadizing the NextTD which used
        // to hold logical addresses.
        // This ASSUMES that a ULONG is the same size as a pointer.
        //
        LOGENTRY(G, 'dnT1', td, td->SortNext, (ULONG_PTR) tdList);         
        LOGENTRY(G, 'dnTn', td, physHcTD, 0);    
        td->SortNext = (ULONG_PTR) tdList;
        tdList = td;
        
    } while (physHcTD);

    KeReleaseSpinLock(&DeviceData->PageListSpin, oldIrql);   

    // 
    // tdList is now a linked list of completed TDs in the 
    // order of completion, walk the list processing each one

    while (NULL != tdList) {
        td = tdList;

        /* bastardizing */
        tdList = (PHCD_TRANSFER_DESCRIPTOR) td->SortNext; 
           
        OpenHCI_ProcessDoneTD(DeviceData, td, TRUE);
        
    } /* while tdList */
}    


BOOLEAN
OpenHCI_ProcessDoneAsyncTD(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    PHCD_ENDPOINT Endpoint,
    PHC_TRANSFER_DESCRIPTOR HcTD,
    NTSTATUS *NtStatus,
    USBD_STATUS *UsbdStatus,
    PHCD_URB Urb,
    BOOLEAN FreeTD
    )
/*++

Routine Description:

Parameters
    
--*/
{
    BOOLEAN control; 
    struct _URB_HCD_COMMON_TRANSFER *transfer;
    BOOLEAN complete = FALSE;
    PHCD_ENDPOINT_DESCRIPTOR ed;  
    PHCD_TRANSFER_DESCRIPTOR tn, nextTd;
    PLIST_ENTRY entry;
    PHC_OPERATIONAL_REGISTER HC;

    transfer = &Urb->HcdUrbCommonTransfer;
    ed = Endpoint->HcdED;
    HC = DeviceData->HC;

    control = Endpoint->Type == USB_ENDPOINT_TYPE_CONTROL;

    OHCI_ASSERT(USB_ENDPOINT_TYPE_ISOCHRONOUS != Endpoint->Type);

    if (HcTD->CBP) { 
        //
        // A value of 0 here indicates a zero length data packet
        // or that all bytes have been transfered.
        //
        // The buffer is only spec'ed for length up to two 4K pages.
        // (BE is the physical address of the last byte in the
        // TD buffer.  CBP is the current byte pointer)
        //
        // TransferCount is intailized to the number of bytes to transfer,
        // we need to subtract the difference between the end and 
        // current ptr (ie end-current = bytes not transferred) and
        // update the TransferCount.

        // transfer count should never go negative
        // TransferCount will be zero on the status 
        // phase of a control transfer so we skip 
        // the calculation

        if (Td->TransferCount) {
            Td->TransferCount -=
                /* have we gone further than a page? */
                ((((HcTD->BE ^ HcTD->CBP) & ~OHCI_PAGE_SIZE_MASK)
                  ? OHCI_PAGE_SIZE : 0) +
                /* minus the data buffer not used */
                ((HcTD->BE & OHCI_PAGE_SIZE_MASK) - 
                 (HcTD->CBP & OHCI_PAGE_SIZE_MASK)+1));
        }            
        LOGENTRY(G, 'xfrB', HcTD->BE & OHCI_PAGE_SIZE_MASK, 
                         HcTD->CBP & OHCI_PAGE_SIZE_MASK,
                         Td->TransferCount);                         
    }            
    if (!control ||
        HcTDDirection_Setup != HcTD->Direction) {  
        
        // data phase of a control transfer or a bulk/int 
        // data transfer 
        LOGENTRY(G, 'BIdt', Td, transfer, Td->TransferCount);
    
        if (transfer->TransferBufferMDL) {

            transfer->TransferBufferLength += Td->TransferCount;

#if DBG
            if (0 == Td->TransferCount) {
                OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_ERROR,
                     ("'TD no data %x %x\n", Td->HcTD.CBP, Td->HcTD.BE));
            }
#endif                
            //
            // ASSERT (TD->TransferCount);
            // TransferCount could be zero but only if the TD returned in
            // error.
            //
            
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_NOISE,
                     ("'Data Transferred 0x%x bytes \n", Td->TransferCount));
            LOGENTRY(G, 'xfrT', DeviceData, Td->TransferCount, 0);                         
            
#if 0
            {
            PUCHAR buffer = 
                MmGetSystemAddressForMdl(transfer->TransferBufferMDL);

            //
            // Print out contents of buffer received.
            //
            if ((trans->TransferFlags & USBD_TRANSFER_DIRECTION_IN) &&
                (USB_ENDPOINT_TYPE_CONTROL == Endpoint->Type)) {
                ULONG j;
                OpenHCI_KdPrintDD(DeviceData, 
                    OHCI_DBG_TD_NOISE, ("'Buffer: "));
                for (j = 0; 
                    (j < trans->TransferBufferLength) && (j < 16); 
                    j++) {
                    if (DeviceData->DebugLevel & OHCI_DBG_TD_NOISE) {
                        DbgPrint("'%02.2x ", ((unsigned int) *(Buffer + j)));
                    }
                }
                OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_NOISE, ("'\n"));
            }
            }
#endif
        } /* trans->TransferBufferMDL */
    }

    // If EP_ONE_TD is set for the endpoint then the buffer Rounding
    // bit will be set for every TD, regardless of whether or not the
    // USBD_SHORT_TRANSFER_OK is set.  If the buffer Rounding bit is
    // set then the condition code will be NoError even if there is
    // a short transfer.  If there is a short transfer, CBP will be
    // non-zero.  If a short transfer occurs when EP_ONE_TD is set
    // and there isn't any other error, pretend there was a DataUnderrun
    // error so the TD error handling code will remove all of the
    // remaining TDs for the transfer.  If USBD_SHORT_TRANSFER_OK is set,
    // the TD error handling code will then pretend the pretend
    // DataUnderrun error didn't occur.
    //
    if ((Endpoint->EpFlags & EP_ONE_TD) &&
        (HcCC_NoError == HcTD->ConditionCode) &&
        (HcTD->CBP != 0))
    {
        LOGENTRY(G, 'Shrt', HcTD->Control, Td->HcTD.CBP, Td->HcTD.BE);

        ed->HcED.HeadP |= HcEDHeadP_HALT;

        HcTD->ConditionCode = HcCC_DataUnderrun;
    }

    //
    // check for errors
    //

    if (HcCC_NoError == HcTD->ConditionCode) {  

        //
        // TD completed without error, remove it from
        // the USBD_REQUEST list, if USBD_REQUEST list 
        // is now empty, then complete.
        //

        Endpoint->HcdHeadP = Td->NextHcdTD;
        // Remove the TD from the HCD list of TDs
        //
        // Note: Currently we only have one irq DPC routine running
        // at a time.  This means that the CancelTDsForED and
        // ProcessDoneQ cannot run concurrently. For this reason, 
        // we do not need to worry with moving the Endpoint's head 
        // pointer to TD's.
        //
        // If these routines could run concurrently then DoneQ
        // could test for canceled.  The Cancle routine could then
        // notice that a TD was in the DoneQ and mark it for cancel
        // then a canceled TD would be here.  The RemoveListEntry
        // call would fail as would the CompleteUsbdRequest.
        //
        //
        // Note also that because the linked list of SoftwareTD's
        // is only a singly linked list (Endpoint->HcdHeadP = TD->Next)
        // We cannot receive TDs out of order.
        //

        RemoveEntryList(&Td->RequestList);

        if (IsListEmpty(&transfer->hca.HcdListEntry2)) {
            //
            // no more TD's for this URB.
            //
            complete = TRUE;
            *UsbdStatus = USBD_STATUS_SUCCESS;
            *NtStatus = STATUS_SUCCESS;
            LOGENTRY(G, 'xfrC', DeviceData, transfer, 0);
            
            if (Endpoint->TrueTail) {
                // this transfer complete, set true tail ptr to 
                // NULL (trueTail is only used when we limit the 
                // endpoint to one active TD)
                OHCI_ASSERT(Endpoint->TrueTail == Endpoint->HcdHeadP);
                Endpoint->TrueTail = NULL;
            }                

            if (FreeTD) {
                OpenHCI_Free_HcdTD(DeviceData, Td);
            }                

        } else {
            LOGENTRY(G, 'xfrP', DeviceData, transfer, Endpoint->TrueTail);
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE,
                            ("'No Complete IRP more TD pending\n"));

            // see if we need to update the tail ptr
            if (Endpoint->TrueTail) {
                nextTd = Td->NextHcdTD;
                //HcED headp should be pointing to this TD
                OHCI_ASSERT((ed->HcED.HeadP & ~HcEDHeadP_FLAGS) == nextTd->PhysicalAddress);
                LOGENTRY(G, 'upTL', Endpoint->TrueTail, Endpoint, nextTd);                    
                
                // The nextTD should not be the same as the TrueTail TD.
                // If it was, then that should mean that there are no TDs
                // left for this URB and the IsListEmpty() above should
                // have been true and we should not be in this else clause.
                //
                OHCI_ASSERT(nextTd != Endpoint->TrueTail);

                // We have already asserted that the HeadP is the same
                // as nextTD at this point.  Bump nextTD to the next one
                // for the new TailP.
                //
                nextTd = nextTd->NextHcdTD;

                LOGENTRY(G, 'upT2', Endpoint->TrueTail, Endpoint, nextTd);                    
                Endpoint->HcdTailP = nextTd;
                ed->HcED.TailP  = nextTd->PhysicalAddress;
                ENABLE_LIST(HC, Endpoint)
            }

            if (FreeTD) {
                OpenHCI_Free_HcdTD(DeviceData, Td);
            }                
        }
                    
    } else {            
        
        /* 
         * TD completed with an error, remove it and
         * the TDs for the same request, set appropriate 
         * status in USBD_REQUEST and then complete it. 
         *
         * TWO SPECIAL CASES: 
         * (1)
         * DataUnderrun for Bulk or Interrupt and
         * ShortXferOK. do not report error to USBD
         * and restart the endpoint. 
         * (2) 
         * DataUnderrun on Control and ShortXferOK. 
         * The final status TD for the Request should 
         * not be canceled, the Request should not be
         * completed, and the endpoint should be
         * restarted. 
         *
         * NOTE:
         * In all error cases the endpoint
         * has been halted by controller. 
         */

        LOGENTRY(G, 'tERR', DeviceData, Td, Td->HcTD.ConditionCode);

        // The ED better be Halted because we're going to mess with
        // the ED HeadP and TailP pointers
        //
        ASSERT(ed->HcED.HeadP & HcEDHeadP_HALT);

        if (Endpoint->TrueTail) {
            LOGENTRY(G, 'eTTl', Endpoint->TrueTail, 
                     Endpoint->HcdTailP, Endpoint);
                    
            // Bump the software tail pointer to the true tail for this transfer
            //
            Endpoint->HcdTailP = Endpoint->TrueTail;
            Endpoint->TrueTail = NULL;

            // Bump the hardware tail pointer to the true tail for this transfer
            //
            Endpoint->HcdED->HcED.TailP = Endpoint->HcdTailP->PhysicalAddress;
        }
        
        for (tn = Endpoint->HcdHeadP;
             tn != Endpoint->HcdTailP;
             tn = tn->NextHcdTD) {
             LOGENTRY(G, 'bump', DeviceData, Td, tn);
            //
            // We want to flush out to the end of this current URB
            // request since there could still be TD's linked together 
            // for the the current URB.  
            // Move tn until it points to the first TD that we
            // wish to leave ``on the hardware''.
            //
            if ((Urb != tn->UsbdRequest) ||   /* another request */
                ((HcCC_DataUnderrun == Td->HcTD.ConditionCode)
                 && (USBD_SHORT_TRANSFER_OK & transfer->TransferFlags)
                 && (Td->HcTD.Direction != tn->HcTD.Direction))) {
                // ^^^^ Here we have the status TD for a Short
                // control
                // Transfer.  We still need run this last TD.
                LOGENTRY(G, 'stpB', DeviceData, Td, Td->HcTD.ConditionCode);
                
                break;
            }                
        }

        // Bump the software head pointer over all TD's until tn
        //
        Endpoint->HcdHeadP = tn;

        // Bump the hardware head pointer over all TD's until tn, preserving
        // the current ED Halted and toggle Carry bits.
        //
        ed->HcED.HeadP = tn->PhysicalAddress
            | (ed->HcED.HeadP & HcEDHeadP_FLAGS);

        // all TDs unlinked, now we just need to free them
        while (!IsListEmpty(&transfer->hca.HcdListEntry2)) {   
            
            entry = RemoveHeadList(&transfer->hca.HcdListEntry2);
            tn = CONTAINING_RECORD(entry,
                                   HCD_TRANSFER_DESCRIPTOR,
                                   RequestList);
            if ((tn != Td) && 
                (tn != Endpoint->HcdHeadP) &&
                FreeTD) {
                OpenHCI_Free_HcdTD(DeviceData, tn);
            }
        }

        // if we are still pointing to the current Urb
        // then this is a status phase for a short 
        // control transfer (ShortTransferOK).
        if (Endpoint->HcdHeadP->UsbdRequest == Urb) {
            TEST_TRAP();            
            // We should use the status of this last TD (the status td) 
            // to return in the URB, so place this TD back onto the list 
            // for this endpoint and allow things to run normally.

            LOGENTRY(G, 'putB', DeviceData, Td, transfer);
            InsertTailList(&transfer->hca.HcdListEntry2,
                           &Endpoint->HcdHeadP->RequestList);
        } else {
            //
            // This transfer is done 
            //
            // NOTE: we do not modify the status in the urb yet because
            // the cancel routine looks at this value to determine
            // what action to take.
            //

            if (HcCC_DataUnderrun == Td->HcTD.ConditionCode) {
                //
                // Behave the same way here as UHCD does.  If the
                // SHORT_TRANSFER_OK flag is set, ignore the DataUnderrun
                // error and return USBD_STATUS_SUCCESS, else return
                // USBD_STATUS_ERROR_SHORT_TRANSFER.  In either case
                // the endpoint is not left in the Halted state.
                //
                if (USBD_SHORT_TRANSFER_OK & transfer->TransferFlags) {

                    LOGENTRY(G, 'shOK', DeviceData, Td, transfer);

                    *UsbdStatus = USBD_STATUS_SUCCESS;

                } else {

                    LOGENTRY(G, 'shNO', DeviceData, Td, transfer);                          
                                          
                    *UsbdStatus = USBD_STATUS_ERROR_SHORT_TRANSFER;
                }

                // Clear the Halted bit in the ED
                //
                ed->HcED.HeadP &= ~HcEDHeadP_HALT;

                // Tell the HC we have something on the ED lists
                //
                ENABLE_LIST(HC, Endpoint);

            } else {

                *UsbdStatus = (Td->HcTD.ConditionCode | 0xC0000000);

                OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_ERROR,
                     ("'Done queue: TD error: 0x%x CBP: 0x%x BE: 0x%x\n",
                      HcTD->ConditionCode,
                      HcTD->CBP,
                      HcTD->BE));
                      
//#if DBG
//                if (5 != Td->HcTD.ConditionCode) {
//                    TRAP(); // Code trap requested by WDM lab
//                }
//#endif
            }

            if (FreeTD) {
                OpenHCI_Free_HcdTD(DeviceData, Td);
            }                
            complete = TRUE;
            
            *NtStatus = STATUS_SUCCESS;
        }
        

        if ((USB_ENDPOINT_TYPE_CONTROL == Endpoint->Type) &&
            (ed->HcED.HeadP & HcEDHeadP_HALT)) {    
            //
            // For Control Endpoints, we always clear the
            // halt condition automatically.
            //

            LOGENTRY(G, 'clrH', DeviceData, Td, transfer);  
            ed->HcED.HeadP &= ~HcEDHeadP_HALT;

            ENABLE_LIST(HC, Endpoint);
        }
    } // error
        
    return complete;
}      


USBD_STATUS
OpenHCI_ProcessHWPacket(
    struct _URB_ISOCH_TRANSFER *Iso,
    PHCD_TRANSFER_DESCRIPTOR Td,
    ULONG Idx,
    ULONG LastFrame
    )
{
    struct _USBD_ISO_PACKET_DESCRIPTOR *pkt;
    PHC_OFFSET_PSW psw;
    USBD_STATUS err;
    ULONG length;

    pkt = &(Iso->IsoPacket[Idx + Td->BaseIsocURBOffset]);
    psw = &(Td->HcTD.Packet[Idx]);
    //
    // always return whatever size we got
    // unless the error was Not_accessed
    //
    if (Iso->TransferFlags & USBD_TRANSFER_DIRECTION_IN) {
        length = (psw->PSW & HcPSW_RETURN_SIZE);
    } else {
        // compute the length requested
        length = Iso->IsoPacket[Idx + Td->BaseIsocURBOffset].Length;
    }

    err = (psw->PSW & HcPSW_CONDITION_CODE_MASK) 
            >> HcPSW_CONDITION_CODE_SHIFT;

    LOGENTRY(G, 'PKTs', 
             err, 
             (psw->PSW & HcPSW_CONDITION_CODE_MASK) 
                >> HcPSW_CONDITION_CODE_SHIFT,
             length);
                
    switch(err) {
    case HcCC_DataUnderrun :
        // not a full packet,
        // data underrun is OK, we don't fail the
        // urb but we do return the status for the
        // packet.
        //
        pkt->Status = err;
        err = USBD_STATUS_SUCCESS; 
        LOGENTRY(G, 'ISOu', err, Idx, 0);
        break;
    case HcCC_NotAccessed:
        length = 0;
        break;
    } 

    if (err) {
        //
        // we have a legitamate error
        // 
        err |= 0xC0000000;
        pkt->Status = err;
        LOGENTRY(G, 'ISO!', err, Idx, 0);
    }

    // set return length
    
    if (Iso->TransferFlags & USBD_TRANSFER_DIRECTION_IN) {
        // return the length for in transfers
        pkt->Length = length;
    } 

    // update length with whatever we got
    Iso->TransferBufferLength += 
        length;

    LOGENTRY(G, 'isoL', length, Iso->TransferBufferLength, 0);        

    if (err == USBD_STATUS_SUCCESS) {
        pkt->Status = USBD_STATUS_SUCCESS;  
    } else {
        Iso->ErrorCount++; 
    }

    return err;        
}


BOOLEAN
OpenHCI_ProcessDoneIsoTD(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    PHCD_ENDPOINT Endpoint,
    PHC_TRANSFER_DESCRIPTOR HcTD,
    NTSTATUS *NtStatus,
    USBD_STATUS *UsbdStatus,
    PHCD_URB Urb,
    BOOLEAN FreeTD
    )
/*++

Routine Description:

Parameters
    
--*/
{
    struct _URB_HCD_COMMON_TRANSFER *transfer;
    struct _URB_ISOCH_TRANSFER *iso;
    BOOLEAN complete = FALSE;
    PHCD_ENDPOINT_DESCRIPTOR ed;  
    BOOLEAN gotError = FALSE;
    ULONG frames, j, lengthCurrent;
    USBD_STATUS status;


    iso = (PVOID) transfer = (PVOID) &Urb->HcdUrbCommonTransfer;
    ed = Endpoint->HcdED;

    OHCI_ASSERT(USB_ENDPOINT_TYPE_ISOCHRONOUS == Endpoint->Type);

    // Frames is one less than the number of PSW's
    // in this TD.
    frames = (Td->HcTD.Control & HcTDControl_FRAME_COUNT_MASK)
            >> HcTDControl_FRAME_COUNT_SHIFT;
            
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_NOISE,
                      ("'--------Done q: ISO pkt!\n"));
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_NOISE,
                      ("'  Starting Frame: %x Frame Cnt: %x Cur Frame: %x\n",
                       Td->HcTD.StartingFrame,
                       Td->HcTD.FrameCount + 1,
                       Get32BitFrameNumber(DeviceData)));
                       
    LOGENTRY(M, 'IsoD', Td, transfer, 0);

    *NtStatus = STATUS_SUCCESS;
    *UsbdStatus = USBD_STATUS_SUCCESS;

    // Remove the TD from the HCD list of TDs
    Endpoint->HcdHeadP = Td->NextHcdTD;

    // walk through the TD and update the packet entries
    // in the urb
    OHCI_ASSERT(frames <= 7);
    
    for (j = 0; j < frames+1; j++) {
        status = OpenHCI_ProcessHWPacket(iso, Td, j, frames); 
        if (USBD_ERROR(status)) {
            gotError = TRUE;
        }
    }

    if (gotError) {
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_ERROR,
            ("'Done queue: ISOC TD error: 0x%x CBP: 0x%x BE: 0x%x\n",
             HcTD->ConditionCode,
             HcTD->CBP,
             HcTD->BE));
        LOGENTRY(M, 'IsoE', Td->HcTD.ConditionCode,
                         Td->HcTD.CBP,
                         Td->HcTD.BE);      
       // TEST_TRAP();
        //
        // For Isoc and Control Endpoints, we always clear the halt
        // condition automatically.
        //
        if (ed->HcED.HeadP & HcEDHeadP_HALT) {
            ed->HcED.HeadP &= ~HcEDHeadP_HALT;
        }
    }

    //
    // the TD is done
    //

    //
    // flush buffers or this TD, we flush up to the offset+length
    // of the last packet in this TD
    //
    lengthCurrent = iso->IsoPacket[frames + Td->BaseIsocURBOffset].Offset + 
                    iso->IsoPacket[frames + Td->BaseIsocURBOffset].Length;    
        
    OHCI_ASSERT(transfer->TransferBufferMDL);

    RemoveEntryList(&Td->RequestList);
    if (FreeTD) {
        OpenHCI_Free_HcdTD(DeviceData, Td);
    }        

    LOGENTRY(M, 'Iso>', lengthCurrent, 
                     transfer,
                     &transfer->hca.HcdListEntry2);  
                         
    if (IsListEmpty(&transfer->hca.HcdListEntry2)) {
        // AKA no more TD's for this URB.
        if (iso->ErrorCount == iso->NumberOfPackets) {
            // all errors set error code for urb
            *UsbdStatus = USBD_STATUS_ISOCH_REQUEST_FAILED;
        }         
        LOGENTRY(M, 'IsoC', *UsbdStatus, 
                         transfer->TransferBufferLength,
                         iso->ErrorCount);   

        //
        // zero out the length field for OUT transfers
        //
        if (USBD_TRANSFER_DIRECTION(iso->TransferFlags) == 
            USBD_TRANSFER_DIRECTION_OUT) {
            for (j=0; j< iso->NumberOfPackets; j++) {
                 iso->IsoPacket[j].Length = 0;
            }
        }            
        
        *NtStatus = STATUS_SUCCESS;
        complete = TRUE;
    } 

    return complete;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\openhci\dbg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

  dbg.c

Abstract:

   Debug logging code and other debug services

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5-4-96 : created jdunn

--*/

#include "openhci.h"

//
// other debug functions
//

#if DBG

VOID
OpenHCI_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function. 

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
#ifdef NTKERN  
    // this makes the compiler generate a ret
    ULONG stop = 1;
    
assert_loop:
#endif
    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it
#ifdef NTKERN    
    TRAP();
    if (stop) {
        goto assert_loop;
    }        
#endif
    return;
}


ULONG
_cdecl
OHCI_KdPrint2(
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[5];
    ULONG l=2;
    
    if (OHCI_Debug_Trace_Level >= l) {    
        if (l <= 1) {
            DbgPrint("OPENHCI.SYS: ");
            *Format = ' ';
        } else {
            DbgPrint("'OPENHCI.SYS: ");
        }
        va_start(list, Format);
        for (i=0; i<4; i++) {
            arg[i] = va_arg(list, int);
        }            
        
        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3]);    
    } 

    return 0;
}

ULONG
_cdecl
OHCI_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[5];
    
    if (OHCI_Debug_Trace_Level >= l) {    
        if (l <= 1) {
            DbgPrint("OPENHCI.SYS: ");
#ifdef NTKERN            
            *Format = ' ';
#endif            
        } else {
            DbgPrint("'OPENHCI.SYS: ");
        }
        va_start(list, Format);
        for (i=0; i<4; i++) {
            arg[i] = va_arg(list, int);
        }            
        
        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3]);    
    } 

    return 0;
}

#endif // DBG

#ifdef DEBUG_LOG

KSPIN_LOCK OHCILogSpinLock;

struct UHCD_LOG_ENTRY {
    ULONG        le_sig;      // Identifying string
    ULONG_PTR    le_info1;        // entry specific info
    ULONG_PTR    le_info2;        // entry specific info
    ULONG_PTR    le_info3;        // entry specific info
}; /* USBD_LOG_ENTRY */


struct UHCD_LOG_ENTRY *OHCILStart = NULL;    // No log yet
struct UHCD_LOG_ENTRY *OHCILPtr;
struct UHCD_LOG_ENTRY *OHCILEnd;

#ifdef IRP_LOG
    ULONG IrpLogSize = 4096*4;    //4 page of log entries
#endif

#ifdef IRP_LOG
    PULONG OHCIIrpLog;
#endif

ULONG OHCI_LogMask = 0xffffffff;

VOID 
OHCI_Debug_LogEntry(
    IN ULONG Mask,
    IN ULONG Sig, 
    IN ULONG_PTR Info1, 
    IN ULONG_PTR Info2, 
    IN ULONG_PTR Info3
    )
/*++

Routine Description:

    Adds an Entry to USBD log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;
typedef union _SIG {
    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    } b;
    ULONG l;
} SIG, *PSIG;

    SIG sig, rsig;
    

    if (OHCILStart == NULL) {
        return;
    }        

    if ((OHCI_LogMask & Mask) == 0) {
        return;
    }

    irql = KeGetCurrentIrql();
    if (irql < DISPATCH_LEVEL) {
        KeAcquireSpinLock(&OHCILogSpinLock, &irql);
    } else {
        KeAcquireSpinLockAtDpcLevel(&OHCILogSpinLock);
    }        
    
    if (OHCILPtr > OHCILStart) {
        OHCILPtr -= 1;    // Decrement to next entry
    } else {
        OHCILPtr = OHCILEnd;
    }        

//    RtlCopyMemory(OHCILPtr->le_name, Name, 4);
//    LPtr->le_ret = (stk[1] & 0x00ffffff) | (CurVMID()<<24);
    sig.l = Sig;
    rsig.b.Byte0 = sig.b.Byte3;
    rsig.b.Byte1 = sig.b.Byte2;
    rsig.b.Byte2 = sig.b.Byte1;
    rsig.b.Byte3 = sig.b.Byte0;
    
    OHCILPtr->le_sig = rsig.l;
    OHCILPtr->le_info1 = Info1;
    OHCILPtr->le_info2 = Info2;
    OHCILPtr->le_info3 = Info3;

    ASSERT(OHCILPtr >= OHCILStart);

    if (irql < DISPATCH_LEVEL) {
        KeReleaseSpinLock(&OHCILogSpinLock, irql);
    } else {
        KeReleaseSpinLockFromDpcLevel(&OHCILogSpinLock);
    }        

    return;
}


VOID
OHCI_LogInit(
    VOID
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular 
    buffer

Arguments:
    
Return Value:

    None.

--*/
{
#ifdef MAX_DEBUG
    ULONG logSize = 4096*4;    //4 page of log entries
#else 
    ULONG logSize = 4096*8;
#endif

    if (OHCILStart != NULL) {
        return;
    }

#ifdef IRP_LOG
    if (OHCIIrpLog == NULL) {
        OHCIIrpLog = ExAllocatePoolWithTag(NonPagedPool, 
                                           IrpLogSize,
                                           OpenHCI_TAG); 
        if (OHCIIrpLog) {
            RtlZeroMemory(OHCIIrpLog, IrpLogSize);
        }
    }
#endif    

    KeInitializeSpinLock(&OHCILogSpinLock);

    OHCILStart = ExAllocatePoolWithTag(NonPagedPool, 
                                       logSize,
                                       OpenHCI_TAG); 

    if (OHCILStart) {
        OHCILPtr = OHCILStart;

        // Point the end (and first entry) 1 entry from the end of 
        // the segment
        OHCILEnd = OHCILStart + (logSize / sizeof(struct UHCD_LOG_ENTRY)) - 1;
    } else {
        TRAP();
    }

    return;
}


VOID
OHCI_LogFree(
    VOID
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular 
    buffer

Arguments:
    
Return Value:

    None.

--*/
{
    if (OHCILStart) {
        ExFreePool(OHCILStart);
        OHCILStart = NULL;
    }

#ifdef IRP_LOG

    if (OHCIIrpLog) {
        ExFreePool(OHCIIrpLog);
        OHCIIrpLog = NULL;
    }
    
#endif    
    
    return;
}

#ifdef IRP_LOG

VOID
OHCI_LogIrp(
    PIRP Irp,
    ULONG Add
    )
/*++

Routine Description:

Arguments:
    
Return Value:

    None.

--*/
{
    PULONG p;
    PUCHAR end;

    p = OHCIIrpLog;
    end = (PUCHAR) OHCIIrpLog;
    end+=IrpLogSize;

    if (Add) {
    
        while (*p) {
            p++;
        }

        if ((PUCHAR) p > end) {
            // no room
            TEST_TRAP();
        } else {
            *p = (ULONG) Irp;
        }
        
    } else {
        while (*p != (ULONG) Irp) {
            p++;
        }

        if ((PUCHAR) p > end) {
            // no room
            TEST_TRAP();
        } else {
            *p = 0;
        }
    }

    return;
}

#endif

#endif /* DEBUG_LOG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\mpinit.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

   mpinit.c

Abstract:

   miniport initialization

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-17-00 : copied, jsenior

--*/

#include "pch.h"

// global registration packet for this miniport
USBPORT_REGISTRATION_PACKET RegistrationPacket;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    RegistrationPacket.DeviceDataSize = sizeof(DEVICE_DATA);
    RegistrationPacket.EndpointDataSize = sizeof(ENDPOINT_DATA);
    RegistrationPacket.TransferContextSize = sizeof(TRANSFER_CONTEXT);

    // enough for 4k frame list plus 4k of scratch space 

    // enough for 4k frame list and interrupt schdule (63 nodes)
    // + static bulk + static control + pixx4 hack queue heads
    // this ends up being about 3 pages
    RegistrationPacket.CommonBufferBytes = 4096 + 
        ((NO_INTERRUPT_QH_LISTS + 3) * sizeof(HCD_QUEUEHEAD_DESCRIPTOR)) + \
         (SOF_TD_COUNT * sizeof(HCD_TRANSFER_DESCRIPTOR));
        
    RegistrationPacket.MINIPORT_StartController = UhciStartController;
    RegistrationPacket.MINIPORT_StopController = UhciStopController;
    RegistrationPacket.MINIPORT_EnableInterrupts = UhciEnableInterrupts;
    RegistrationPacket.MINIPORT_DisableInterrupts = UhciDisableInterrupts;
    RegistrationPacket.MINIPORT_InterruptService = UhciInterruptService;
    RegistrationPacket.MINIPORT_InterruptDpc = UhciInterruptDpc;
    RegistrationPacket.MINIPORT_SuspendController = UhciSuspendController;
    RegistrationPacket.MINIPORT_ResumeController = UhciResumeController;
        
    //
    // Root hub control entry points
    //
    RegistrationPacket.MINIPORT_RH_DisableIrq = UhciRHDisableIrq;
    RegistrationPacket.MINIPORT_RH_EnableIrq = UhciRHEnableIrq;
    RegistrationPacket.MINIPORT_RH_GetRootHubData = UhciRHGetRootHubData;
    RegistrationPacket.MINIPORT_RH_GetStatus = UhciRHGetStatus;
    RegistrationPacket.MINIPORT_RH_GetHubStatus = UhciRHGetHubStatus;
    RegistrationPacket.MINIPORT_RH_GetPortStatus = UhciRHGetPortStatus;
    
    //
    // Individual root hub port entry points
    //
    RegistrationPacket.MINIPORT_RH_SetFeaturePortReset = UhciRHSetFeaturePortReset;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortEnable = UhciRHSetFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortPower = UhciRHSetFeaturePortPower;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortSuspend = UhciRHSetFeaturePortSuspend;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspend = UhciRHClearFeaturePortSuspend;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnable = UhciRHClearFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortPower = UhciRHClearFeaturePortPower;
    
    // Change bits
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortConnectChange = UhciRHClearFeaturePortConnectChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange = UhciRHClearFeaturePortResetChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnableChange = UhciRHClearFeaturePortEnableChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspendChange = UhciRHClearFeaturePortSuspendChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortOvercurrentChange = UhciRHClearFeaturePortOvercurrentChange;

    
    RegistrationPacket.MINIPORT_SetEndpointStatus = UhciSetEndpointStatus;
    RegistrationPacket.MINIPORT_GetEndpointStatus = UhciGetEndpointStatus;
    RegistrationPacket.MINIPORT_SetEndpointDataToggle = UhciSetEndpointDataToggle;
    RegistrationPacket.MINIPORT_OpenEndpoint = UhciOpenEndpoint;
    RegistrationPacket.MINIPORT_PokeEndpoint = UhciPokeEndpoint;
    RegistrationPacket.MINIPORT_QueryEndpointRequirements = UhciQueryEndpointRequirements;
    RegistrationPacket.MINIPORT_CloseEndpoint = UhciCloseEndpoint;
    RegistrationPacket.MINIPORT_PollEndpoint = UhciPollEndpoint;
    RegistrationPacket.MINIPORT_SetEndpointState = UhciSetEndpointState;
    RegistrationPacket.MINIPORT_GetEndpointState = UhciGetEndpointState;
    RegistrationPacket.MINIPORT_Get32BitFrameNumber = UhciGet32BitFrameNumber;
    RegistrationPacket.MINIPORT_PollController = UhciPollController;
    RegistrationPacket.MINIPORT_CheckController = UhciCheckController;
    RegistrationPacket.MINIPORT_InterruptNextSOF = UhciInterruptNextSOF;
    RegistrationPacket.MINIPORT_SubmitTransfer = UhciSubmitTransfer;
    RegistrationPacket.MINIPORT_SubmitIsoTransfer = UhciIsochTransfer;
    RegistrationPacket.MINIPORT_AbortTransfer = UhciAbortTransfer;
    RegistrationPacket.MINIPORT_StartSendOnePacket = UhciStartSendOnePacket;
    RegistrationPacket.MINIPORT_EndSendOnePacket = UhciEndSendOnePacket;
    RegistrationPacket.MINIPORT_PassThru = UhciPassThru;
    RegistrationPacket.MINIPORT_FlushInterrupts = UhciFlushInterrupts;
        
    RegistrationPacket.OptionFlags = USB_MINIPORT_OPT_NEED_IRQ | 
                                     USB_MINIPORT_OPT_NEED_IOPORT |
                                     USB_MINIPORT_OPT_NO_IRQ_SYNC |
                                     USB_MINIPORT_OPT_POLL_IN_SUSPEND |
                                     USB_MINIPORT_OPT_POLL_CONTROLLER;   

    //
    // UHCI controller
    //
    RegistrationPacket.HciType = USB_UHCI;
    RegistrationPacket.BusBandwidth = USB_11_BUS_BANDWIDTH;

    DriverObject->DriverUnload = NULL;
    
    return USBPORT_RegisterUSBPortDriver(
                DriverObject,    
                USB_MINIPORT_HCI_VERSION,
                &RegistrationPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbuhci\usbuhci.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    usbuhci.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    1-1-00 : created

--*/

#ifndef   __USBUHCI_H__
#define   __USBUHCI_H__

#define FIXPIIX4

#define SOF_TD_COUNT    8

#define ANY_VIA(dd) ((dd)->ControllerFlavor >= UHCI_VIA)

#define MASK_CHANGE_BITS(p)\
    do {\
    (p).PortEnableChange = 0;\
    (p).PortConnectChange = 0;\
    } while (0);

/*
    define resource consumption for endpoints types
*/

#define T_64K           0x10000
#define T_16K           0x4000
#define T_4K            0x1000


// Control:
// largest possible transfer for control is 64k
// therefore we support up to 2 transfers of this
// size in HW.  Most control transfers are much
// smaller than this.
// NOTE: we MUST support at least one 64k transfer in
// HW since a single control transfer cannot be
// broken up.


//#define MAX_CONTROL_TRANSFER_SIZE       T_4K
#define MAX_ASYNC_PACKET_SIZE         64
//#define MAX_CONTROL_DOUBLE_BUFFERS      MAX_CONTROL_TRANSFER_SIZE/PAGE_SIZE
//#define TDS_PER_CONTROL_ENDPOINT        (MAX_CONTROL_TRANSFER_SIZE/MAX_CONTROL_PACKET_SIZE+2) // 2 EXTRA FOR SETUP AND STATUS


// Bulk:

// bugbug temprarily set to 64k
#define MAX_BULK_TRANSFER_SIZE          T_4K
//#define MAX_BULK_TRANSFER_SIZE          T_4K // T_16K // T_64K
//#define MAX_BULK_PACKET_SIZE            64
#define MAX_BULK_DOUBLE_BUFFERS         MAX_BULK_TRANSFER_SIZE/PAGE_SIZE
#define TDS_PER_BULK_ENDPOINT           (MAX_BULK_TRANSFER_SIZE/MAX_BULK_PACKET_SIZE)

// Interrupt:

//#define MAX_INTERRUPT_TRANSFER_SIZE     T_4K // T_16K
//#define MAX_INTERRUPT_PACKET_SIZE       64
//#define MAX_INTERRUPT_DOUBLE_BUFFERS    MAX_INTERRUPT_TRANSFER_SIZE/PAGE_SIZE
//#define TDS_PER_INTERRUPT_ENDPOINT      (MAX_INTERRUPT_TRANSFER_SIZE/MAX_INTERRUPT_PACKET_SIZE)
#define MAX_INTERRUPT_TDS_PER_TRANSFER  8

// Isochronous:
#define MAX_ISOCH_TRANSFER_SIZE     T_64K
#define MAX_ISOCH_PACKET_SIZE       1023
//#define MAX_ISOCH_DOUBLE_BUFFERS    MAX_ISOCH_TRANSFER_SIZE/PAGE_SIZE
//#define TDS_PER_ISOCH_ENDPOINT      1024

// Maximum Polling Interval we support for interrupt (ms)
#define MAX_INTERVAL                32
#define MAX_INTERVAL_MASK(i)        (i&0x1f)

// default size of frame list
#define UHCI_MAX_FRAME               1024
#define ACTUAL_FRAME(f)         ((f)&0x000003FF)

//
// These values index in to the interrupt QH list
//
#define  QH_INTERRUPT_1ms        0
#define  QH_INTERRUPT_2ms        1
#define  QH_INTERRUPT_4ms        3
#define  QH_INTERRUPT_8ms        7
#define  QH_INTERRUPT_16ms       15
#define  QH_INTERRUPT_32ms       31
#define  QH_INTERRUPT_INDEX(x) (x)-1

#define  NO_INTERRUPT_INTERVALS  6
#define  NO_INTERRUPT_QH_LISTS   63

// debug signatures
#define  SIG_HCD_IQH            'qi01'
#define  SIG_HCD_CQH            'qa01'
#define  SIG_HCD_BQH            'qb01'
#define  SIG_HCD_QH             'hq01'
#define  SIG_HCD_DQH            'qd01'
#define  SIG_HCD_TD             'dt01'
#define  SIG_HCD_RTD            'dtlr'
#define  SIG_HCD_SOFTD          'dtos'
#define  SIG_HCD_ADB            'bd01'
#define  SIG_HCD_IDB            'id01'
#define  SIG_EP_DATA            'pe01'
#define  SIG_UHCI_TRANSFER      'rt01'
#define  SIG_UHCI_DD            'ichu'

// What gets returned by READ_PORT_USHORT when hardware is surprise removed.
#define UHCI_HARDWARE_GONE 0xffff

#undef PDEVICE_DATA

typedef struct _TRANSFER_CONTEXT {

    ULONG Sig;
    ULONG PendingTds;
    PTRANSFER_PARAMETERS TransferParameters;
    USBD_STATUS UsbdStatus;
    ULONG BytesTransferred;
    struct _ENDPOINT_DATA *EndpointData;
    PMINIPORT_ISO_TRANSFER IsoTransfer;

} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;


// HCD Endpoint Descriptor (contains the HW descriptor)

// values for HCD_QUEUEHEAD_DESCRIPTOR.Flags
#define UHCI_QH_FLAG_IN_SCHEDULE        0x00000001
#define UHCI_QH_FLAG_QH_REMOVED         0x00000002

struct _ENDPOINT_DATA;

typedef struct _HCD_QUEUEHEAD_DESCRIPTOR {
   HW_QUEUE_HEAD                    HwQH;     // 2 dwords
   HW_32BIT_PHYSICAL_ADDRESS        PhysicalAddress;
   ULONG                            Sig;
   ULONG                            QhFlags;
   struct _HCD_QUEUEHEAD_DESCRIPTOR *NextQh;
   struct _HCD_QUEUEHEAD_DESCRIPTOR *PrevQh;
   struct _ENDPOINT_DATA            *EndpointData;

#ifdef _WIN64
   ULONG                            PadTo64[4];
#else
   ULONG                            PadTo64[8];
#endif
} HCD_QUEUEHEAD_DESCRIPTOR, *PHCD_QUEUEHEAD_DESCRIPTOR;

C_ASSERT((sizeof(HCD_QUEUEHEAD_DESCRIPTOR) == 64));

//
// HCD Transfer Descriptor (contains the HW descriptor)
//

#define ENDPOINT_DATA_PTR(p) ((struct _ENDPOINT_DATA *) (p).Pointer)
#define TRANSFER_CONTEXT_PTR(p) ((struct _TRANSFER_CONTEXT *) (p).Pointer)
#define TRANSFER_DESCRIPTOR_PTR(p) ((struct _HCD_TRANSFER_DESCRIPTOR *) (p).Pointer)
#define QH_DESCRIPTOR_PTR(p) ((struct _HCD_QUEUEHEAD_DESCRIPTOR *) (p).Pointer)
#define HW_PTR(p) ((UCHAR * ) (p).Pointer)


#define DB_FLAG_BUSY                0x00000001

typedef struct _TRANSFER_BUFFER_HEADER {
    HW_32BIT_PHYSICAL_ADDRESS   PhysicalAddress;
    PUCHAR                      SystemAddress;
    ULONG                       Sig;
    ULONG                       Flags;
    ULONG                       Size;
#ifdef _WIN64
    ULONG                       PadTo32[1];
#else
    ULONG                       PadTo32[3];
#endif
} TRANSFER_BUFFER_HEADER, *PTRANSFER_BUFFER_HEADER;

C_ASSERT((sizeof(TRANSFER_BUFFER_HEADER) == 32));

//
// NOTE: The buffer must go first, since the physical address
// depends on it. If not, you must change the init code.
//
typedef struct _ASYNC_TRANSFER_BUFFER {
    UCHAR Buffer[MAX_ASYNC_PACKET_SIZE];
    TRANSFER_BUFFER_HEADER;
} ASYNC_TRANSFER_BUFFER, *PASYNC_TRANSFER_BUFFER;

C_ASSERT((sizeof(ASYNC_TRANSFER_BUFFER) == 64+32));

typedef struct _ISOCH_TRANSFER_BUFFER {
    UCHAR Buffer[MAX_ISOCH_PACKET_SIZE+1]; // bump it to 1024
    TRANSFER_BUFFER_HEADER;
} ISOCH_TRANSFER_BUFFER, *PISOCH_TRANSFER_BUFFER;

C_ASSERT((sizeof(ISOCH_TRANSFER_BUFFER) == 1024+32));

typedef union _TRANSFER_BUFFER {
    ISOCH_TRANSFER_BUFFER Isoch;
    ASYNC_TRANSFER_BUFFER Async;
} TRANSFER_BUFFER, *PTRANSFER_BUFFER;

typedef struct _DOUBLE_BUFFER_LIST {
    union {
        ASYNC_TRANSFER_BUFFER  Async[1];
        ISOCH_TRANSFER_BUFFER  Isoch[1];
    };
} DOUBLE_BUFFER_LIST, *PDOUBLE_BUFFER_LIST;

// values for HCD_TRANSFER_DESCRIPTOR.Flags

#define TD_FLAG_BUSY                0x00000001
#define TD_FLAG_XFER                0x00000002
//#define TD_FLAG_CONTROL_STATUS      0x00000004
#define TD_FLAG_DONE                0x00000008
#define TD_FLAG_SKIP                0x00000010
#define TD_FLAG_DOUBLE_BUFFERED     0x00000020
#define TD_FLAG_ISO_QUEUED          0x00000040
#define TD_FLAG_SETUP_TD            0x00000100
#define TD_FLAG_DATA_TD             0x00000200
#define TD_FLAG_STATUS_TD           0x00000400
#define TD_FLAG_TIMEOUT_ERROR       0x00000800

typedef struct _HCD_TRANSFER_DESCRIPTOR {
    HW_QUEUE_ELEMENT_TD             HwTD;
    HW_32BIT_PHYSICAL_ADDRESS       PhysicalAddress;
    ULONG                           Sig;
    union {
    PTRANSFER_CONTEXT               TransferContext;
    ULONG                           RequestFrame;
    };
    PMINIPORT_ISO_PACKET            IsoPacket;
    ULONG                           Flags;
    struct _HCD_TRANSFER_DESCRIPTOR *NextTd;
    PTRANSFER_BUFFER                DoubleBuffer;
    LIST_ENTRY                      DoneLink;
#ifdef _WIN64
    ULONG                           PadTo128[12];
#else
    ULONG                           PadTo64[3];
#endif
} HCD_TRANSFER_DESCRIPTOR, *PHCD_TRANSFER_DESCRIPTOR;

#ifdef _WIN64
C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) == 128));
#else
C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) == 64));
#endif

typedef struct _HCD_TD_LIST {
    HCD_TRANSFER_DESCRIPTOR Td[1];
} HCD_TD_LIST, *PHCD_TD_LIST;

#define UHCI_EDFLAG_HALTED          0x00000001
#define UHCI_EDFLAG_SHORT_PACKET    0x00000002
#define UHCI_EDFLAG_NOHALT          0x00000004

typedef struct _ENDPOINT_DATA {

    ULONG                       Sig;
    ULONG                       Flags;
    ENDPOINT_PARAMETERS         Parameters;
    PHCD_QUEUEHEAD_DESCRIPTOR   QueueHead;
    ULONG                       PendingTransfers;
    ULONG                       MaxPendingTransfers;

    PHCD_TRANSFER_DESCRIPTOR    TailTd;
    PHCD_TRANSFER_DESCRIPTOR    HeadTd;

    //
    // Transfer descriptor cache.
    //
    PHCD_TD_LIST                TdList;
    ULONG                       TdCount;
    ULONG                       TdLastAllocced;
    ULONG                       TdsUsed;

    //
    // Double buffer cache.
    //
    PDOUBLE_BUFFER_LIST         DbList;
    ULONG                       DbCount;
    ULONG                       DbLastAllocced;
    ULONG                       DbsUsed;

    ULONG                       MaxErrorCount;

    ULONG                       Toggle;

    LIST_ENTRY                  DoneTdList;
    
} ENDPOINT_DATA, *PENDPOINT_DATA;

#define UHCI_NUMBER_PORTS               2

#define UHCI_DDFLAG_USBBIOS     0X00000001

#define UHCI_HC_MAX_ERRORS      0x10

typedef struct _DEVICE_DATA {

    ULONG                       Sig;
    ULONG                       Flags;
    PHC_REGISTER                Registers;
    ULONG                       HCErrorCount;

    // Save the command register thru power downs
    USBCMD                      SuspendCommandReg;
    FRNUM                       SuspendFrameNumber;
    FRBASEADD                   SuspendFrameListBasePhys;
    USBINTR                     SuspendInterruptEnable;

    USBINTR                     EnabledInterrupts;
    ULONG                       IsoPendingTransfers;

    //
    // Base queue head that we link all control/bulk transfer
    // queues to.
    //
    USB_CONTROLLER_FLAVOR       ControllerFlavor;

//    ULONG                       LastFrameCounter;
    ULONG                       FrameNumberHighPart;
    ULONG                       LastFrameProcessed;
    ULONG                       SynchronizeIsoCleanup;

    ULONG                       PortInReset;
    ULONG                       PortResetChange;
    ULONG                       PortSuspendChange;
    ULONG                       PortOvercurrentChange;
    BOOLEAN                     PortResuming[UHCI_NUMBER_PORTS];

    USHORT                      IrqStatus;

    USHORT                      PortPowerControl;

    PHW_32BIT_PHYSICAL_ADDRESS  FrameListVA;
    HW_32BIT_PHYSICAL_ADDRESS   FrameListPA;

    // Virtual Addresses for the control and bulk queue heads in the
    // schedule.

    PHCD_QUEUEHEAD_DESCRIPTOR   ControlQueueHead;
    PHCD_QUEUEHEAD_DESCRIPTOR   BulkQueueHead;
    PHCD_QUEUEHEAD_DESCRIPTOR   LastBulkQueueHead;

    // Virtual Addresses for the interrupt queue heads in the
    // schedule.

    PHCD_QUEUEHEAD_DESCRIPTOR   InterruptQueueHeads[NO_INTERRUPT_QH_LISTS];

    // Virtual Address for the TD that gives us an interrupt at the end
    // of every frame, so that things don't get stuck in the schedule.

    PHCD_TRANSFER_DESCRIPTOR    RollOverTd;

    UCHAR                       SavedSOFModify;

    PHCD_TD_LIST                SofTdList;

} DEVICE_DATA, *PDEVICE_DATA;


/*
    Callouts to port driver services
*/
extern USBPORT_REGISTRATION_PACKET RegistrationPacket;

#define USBPORT_DBGPRINT(dd, l, f, arg0, arg1, arg2, arg3, arg4, arg5) \
        RegistrationPacket.USBPORTSVC_DbgPrint((dd), (l), (f), (arg0), (arg1), \
            (arg2), (arg3), (arg4), (arg5))

#define USBPORT_GET_REGISTRY_KEY_VALUE(dd, branch, keystring, keylen, data, datalen) \
        RegistrationPacket.USBPORTSVC_GetMiniportRegistryKeyValue((dd), (branch), \
            (keystring), (keylen), (data), (datalen))

#define USBPORT_INVALIDATE_ROOTHUB(dd) \
        RegistrationPacket.USBPORTSVC_InvalidateRootHub((dd))

#define USBPORT_COMPLETE_TRANSFER(dd, ep, tp, status, length) \
        RegistrationPacket.USBPORTSVC_CompleteTransfer((dd), (ep), (tp), \
            (status), (length))

#define USBPORT_COMPLETE_ISOCH_TRANSFER(dd, ep, tp, iso) \
        RegistrationPacket.USBPORTSVC_CompleteIsoTransfer((dd), (ep), (tp), (iso))

#define USBPORT_INVALIDATE_ENDPOINT(dd, ep) \
        RegistrationPacket.USBPORTSVC_InvalidateEndpoint((dd), (ep))

#define USBPORT_PHYSICAL_TO_VIRTUAL(addr, dd, ep) \
        RegistrationPacket.USBPORTSVC_MapHwPhysicalToVirtual((addr), (dd), (ep))

#define USBPORT_REQUEST_ASYNC_CALLBACK(dd, t, c, cl, f) \
        RegistrationPacket.USBPORTSVC_RequestAsyncCallback((dd), (t), \
            (c), (cl), (f))

#define USBPORT_READ_CONFIG_SPACE(dd, b, o, l) \
        RegistrationPacket.USBPORTSVC_ReadWriteConfigSpace((dd), TRUE, \
            (b), (o), (l))

#define USBPORT_WRITE_CONFIG_SPACE(dd, b, o, l) \
        RegistrationPacket.USBPORTSVC_ReadWriteConfigSpace((dd), FALSE, \
            (b), (o), (l))

#define USBPORT_INVALIDATE_CONTROLLER(dd, s) \
        RegistrationPacket.USBPORTSVC_InvalidateController((dd), (s))

#define USBPORT_WAIT(dd, t) \
        RegistrationPacket.USBPORTSVC_Wait((dd), (t))

#define USBPORT_NOTIFY_DOUBLEBUFFER(dd, tp, addr, length) \
        RegistrationPacket.USBPORTSVC_NotifyDoubleBuffer((dd), (tp), \
            (addr), (length))


#ifdef _WIN64
#define DUMMY_TD_CONTEXT ((PVOID) 0xABADBABEABADBABE)
#else
#define DUMMY_TD_CONTEXT ((PVOID) 0xABADBABE)
#endif


#define UhciCheckIsochTransferInsertion(dd, r, df) {\
        ULONG cf = UhciGet32BitFrameNumber((dd));\
        if ((df) > (cf)) {\
            if ((df) < (dd)->LastFrameProcessed + UHCI_MAX_FRAME) \
                r = USBD_STATUS_SUCCESS;\
            else\
                r = USBD_STATUS_PENDING;\
        } else {\
            if ((df)-(cf) < UHCI_MAX_FRAME )\
                r = USBD_STATUS_SUCCESS;\
            else \
                r = USBD_STATUS_BAD_START_FRAME;}}

//
// This macro is protected from double queueing the TD, by using
// interlocked function. Unless the HwAddress is NULL, it won't
// replace the value.
//
#define INSERT_ISOCH_TD(dd, td, fn) \
        (td)->Flags |= TD_FLAG_ISO_QUEUED;\
        InterlockedCompareExchange(&(td)->HwTD.LinkPointer.HwAddress,\
            *( ((PULONG) ((dd)->FrameListVA)+ACTUAL_FRAME(fn)) ), 0);\
        *( ((PULONG) ((dd)->FrameListVA)+ACTUAL_FRAME(fn)) ) = \
            (td)->PhysicalAddress;

//
// Must account for both the regular and overflow cases:
//
/*#define CAN_INSERT_ISOCH_TD(fr, cfr) \
        ((fr - cfr < USBUHCI_MAX_FRAME) ||\
        ((fr + cfr < USBUHCI_MAX_FRAME) && fr < USBUHCI_MAX_FRAME))

#define INSERT_ISOCH_TD(dd, td, ep) \
        (td)->PrevTd = (PHCD_TRANSFER_DESCRIPTOR)((PULONG) ((dd)->FrameListVA) + \
            ACTUAL_FRAME((td)->IsoPacket->FrameNumber)); \
        (td)->HwTD.LinkPointer.HwAddress = (td)->PrevTd->HwTD.LinkPointer.HwAddress; \
        if (!(td)->HwTD.LinkPointer.QHTDSelect) {\
            PHCD_TRANSFER_DESCRIPTOR rtd = (PHCD_TRANSFER_DESCRIPTOR)\
                USBPORT_PHYSICAL_TO_VIRTUAL((td)->HwTD.LinkPointer.HwAddress, \
                                            (dd), \
                                            (ep));\
            rtd->PrevTd = (td);\
        }\
        (td)->PrevTd->HwTD.LinkPointer.HwAddress = td->PhysicalAddress;

#define REMOVE_ISOCH_TD(td) \
        (td)->PrevTd->HwTD.LinkPointer.HwAddress = (td)->HwTD.LinkPointer.HwAddress;
*/

// We must set the frame to the highest ULONG prior to setting the
// TD_FLAG_XFER flag, so that this TD doesn't get completed before
// we've had chance to queue it.
#define INITIALIZE_TD_FOR_TRANSFER(td, tc) \
        (td)->TransferContext = (tc);\
        (td)->Flags |= TD_FLAG_XFER; \
        (td)->HwTD.LinkPointer.HwAddress = 0;\
        (td)->HwTD.Control.ul = 0;\
        (td)->HwTD.Control.LowSpeedDevice = ((tc)->EndpointData->Parameters.DeviceSpeed == LowSpeed);\
        (td)->HwTD.Control.Active = 1;\
        (td)->HwTD.Control.ErrorCount = 3;\
        (td)->HwTD.Token.ul = 0;\
        (td)->HwTD.Token.Endpoint = (tc)->EndpointData->Parameters.EndpointAddress;\
        (td)->HwTD.Token.DeviceAddress = (tc)->EndpointData->Parameters.DeviceAddress;\
        (td)->NextTd = NULL;

#define SET_QH_TD(dd, ed, td) {\
    TD_LINK_POINTER newLink;\
    if ((td)) {\
        (ed)->HeadTd = (td);\
    } else {\
        (ed)->HeadTd = (ed)->TailTd = NULL;\
    }\
    if (!(td) || TEST_FLAG((ed)->Flags, UHCI_EDFLAG_HALTED)) {\
        newLink.HwAddress = 0;\
        newLink.Terminate = 1;\
    } else {\
        newLink.HwAddress = (td)->PhysicalAddress;\
        newLink.Terminate = 0;\
    }\
    newLink.QHTDSelect = 0;\
    LOGENTRY((dd), G, '_sqt', (td), (ed), 0);\
    (ed)->QueueHead->HwQH.VLink = newLink;}

/*#define SET_QH_TD_NULL(qh) \
    { TD_LINK_POINTER newLink;\
    newLink.HwAddress = 0;\
    newLink.Terminate = 1;\
    newLink.QHTDSelect = 0;\
    (qh)->HwQH.VLink = newLink;\
    }
  */
#define SET_NEXT_TD(linkTd, nextTd) \
    (linkTd)->HwTD.LinkPointer.HwAddress = (nextTd)->PhysicalAddress;\
    (linkTd)->HwTD.LinkPointer.Terminate = 0;\
    (linkTd)->HwTD.LinkPointer.QHTDSelect = 0;\
    (linkTd)->HwTD.LinkPointer.DepthBreadthSelect = 0;\
    (linkTd)->NextTd = (nextTd);

#define SET_NEXT_TD_NULL(linkTd) \
    (linkTd)->NextTd = NULL;\
    (linkTd)->HwTD.LinkPointer.HwAddress = 0;\
    (linkTd)->HwTD.LinkPointer.Terminate = 1;

#define PAGE_CROSSING(PhysicalAddress, length) \
    ((PhysicalAddress+length)%PAGE_SIZE < length && (PhysicalAddress+length)%PAGE_SIZE != 0)

#ifdef _WIN64
#define UHCI_BAD_POINTER ((PVOID) 0xDEADFACEDEADFACE)
#else
#define UHCI_BAD_POINTER ((PVOID) 0xDEADFACE)
#endif
#define UHCI_BAD_HW_POINTER 0x0BADF00D

// Note how we free any double buffering in here instead of relying
// on the c code to do it.
#define UHCI_FREE_TD(dd, ep, td) \
    if (TEST_FLAG((td)->Flags, TD_FLAG_DOUBLE_BUFFERED)) { \
        UHCI_FREE_DB((dd), (ep), (td)->DoubleBuffer);}\
    (ep)->TdsUsed--;\
    (td)->HwTD.LinkPointer.HwAddress = UHCI_BAD_HW_POINTER;\
    LOGENTRY((dd), G, '_fTD', (td), (ep), 0);\
    (td)->TransferContext = UHCI_BAD_POINTER;\
    (td)->Flags = 0;

#define UHCI_ALLOC_TD(dd, ep) UhciAllocTd((dd), (ep));

#define UHCI_FREE_DB(dd, ep, db) \
    LOGENTRY((dd), G, '_fDB', (db), (ep), 0);\
    (ep)->DbsUsed--;\
    if ((ep)->Parameters.TransferType == Isochronous) { (db)->Isoch.Flags = 0; }\
    else { (db)->Async.Flags = 0; }

#define UHCI_ALLOC_DB(dd, ep, i) UhciAllocDb((dd), (ep), (i));

 //  bugbug  UHCI_ASSERT((dd), (ed)->PendingTransfers);
#define DecPendingTransfers(dd, ed) \
    InterlockedDecrement(&(ed)->PendingTransfers);\
    if ((ed)->Parameters.TransferType == Isochronous)\
        InterlockedDecrement(&(dd)->IsoPendingTransfers);

#define ActivateRolloverTd(dd) \
    *( ((PULONG) ((dd)->FrameListVA)) ) = (dd)->RollOverTd->PhysicalAddress;

//#define IncPendingTransfers(dd, ed) \
//    InterlockedIncrement(&(ed)->PendingTransfers);\
//    if ((ed)->Parameters.TransferType == Isochronous) {\
//        if (1 == InterlockedIncrement(&(dd)->IsoPendingTransfers)) {\
//            //*( ((PULONG) ((dd)->FrameListVA)) ) = (dd)->RollOverTd->PhysicalAddress; \
//            (dd)->LastFrameProcessed = UhciGet32BitFrameNumber((dd));\
//    }}
//    bugbug UHCI_ASSERT((dd), (ed)->PendingTransfers);

#define IncPendingTransfers(dd, ed) \
    InterlockedIncrement(&(ed)->PendingTransfers);\
    if ((ed)->Parameters.TransferType == Isochronous) {\
        if (1 == InterlockedIncrement(&(dd)->IsoPendingTransfers)) {\
            (dd)->LastFrameProcessed = UhciGet32BitFrameNumber((dd));\
    }}
//    bugbug UHCI_ASSERT((dd), (ed)->PendingTransfers);


#define UhciCleanFrameOfIsochTds(dd, i)\
    if ((i) == 0) {\
        *( ((PULONG) ((dd)->FrameListVA)) ) = (dd)->RollOverTd->PhysicalAddress;\
    } else {\
        QH_LINK_POINTER newLink;\
        newLink.HwAddress = (dd)->InterruptQueueHeads[QH_INTERRUPT_32ms + MAX_INTERVAL_MASK((i))]->PhysicalAddress;\
        newLink.QHTDSelect = 1;\
        *( ((PULONG) ((dd)->FrameListVA)+(i)) ) = newLink.HwAddress;\
    }


#define TEST_BIT(value, bitNumber) ((value) & (1<<(bitNumber))) ? TRUE : FALSE

#define SET_BIT(value, bitNumber) ((value) |= (1<<(bitNumber)))

#define CLEAR_BIT(value, bitNumber)  ((value) &= ~(1<<(bitNumber)))


//
// Controller functions
//

USB_MINIPORT_STATUS
USBMPFN
UhciStartController(
    IN PDEVICE_DATA DeviceData,
    IN PHC_RESOURCES HcResources
    );

VOID
USBMPFN
UhciStopController(
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN HwPresent
    );

VOID
USBMPFN
UhciSuspendController(
    IN PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
USBMPFN
UhciResumeController(
    IN PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
UhciPollController(
    IN PDEVICE_DATA DeviceData
    );

ULONG
USBMPFN
UhciGet32BitFrameNumber(
    IN PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
UhciInterruptNextSOF(
    IN PDEVICE_DATA DeviceData
    );

VOID
UhciUpdateCounter(
    IN PDEVICE_DATA DeviceData
    );

VOID
UhciDisableAsyncList(
    IN PDEVICE_DATA DeviceData
    );

VOID
UhciInitailizeInterruptSchedule(
    IN PDEVICE_DATA DeviceData
    );

VOID
UhciEnableAsyncList(
    IN PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
USBMPFN
UhciPassThru (
    IN PDEVICE_DATA DeviceData,
    IN GUID *FunctionGuid,
    IN ULONG ParameterLength,
    IN OUT PVOID Parameters
    );


//
// Root hub functions
//

VOID
USBMPFN
UhciRHGetRootHubData(
    IN PDEVICE_DATA DeviceData,
    OUT PROOTHUB_DATA HubData
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHGetStatus(
    IN PDEVICE_DATA DeviceData,
    OUT PUSHORT Status
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHGetHubStatus(
    IN PDEVICE_DATA DeviceData,
    OUT PRH_HUB_STATUS HubStatus
    );

VOID
USBMPFN
UhciRHDisableIrq(
    IN PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
UhciRHEnableIrq(
    IN PDEVICE_DATA DeviceData
    );


//
// Root hub port functions
//
USB_MINIPORT_STATUS
USBMPFN
UhciRHSetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHSetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHSetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortPower(
    IN PDEVICE_DATA DeviceData,
    IN USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHSetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortEnable(
    IN PDEVICE_DATA DeviceData,
    IN USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHGetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    );

//
// Clear change bits for hub ports
//
USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortSuspendChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortOvercurrentChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );


//
// Interrupt functions
//

BOOLEAN
USBMPFN
UhciInterruptService (
    IN PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
UhciEnableInterrupts(
    IN PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
UhciInterruptDpc (
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN EnableInterrupts
    );

VOID
USBMPFN
UhciDisableInterrupts(
    IN PDEVICE_DATA DeviceData
    );


//
// Endpoint functions
//

USB_MINIPORT_STATUS
USBMPFN
UhciOpenEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
USBMPFN
UhciPokeEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
USBMPFN
UhciQueryEndpointRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_REQUIREMENTS EndpointRequirements
    );

VOID
USBMPFN
UhciCloseEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

VOID
USBMPFN
UhciAbortTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext,
    OUT PULONG BytesTransferred
    );

USB_MINIPORT_STATUS
USBMPFN
UhciStartSendOnePacket(
    IN PDEVICE_DATA DeviceData,
    IN PMP_PACKET_PARAMETERS PacketParameters,
    IN PUCHAR PacketData,
    IN PULONG PacketLength,
    IN PUCHAR WorkspaceVirtualAddress,
    IN HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    IN ULONG WorkSpaceLength,
    IN OUT USBD_STATUS *UsbdStatus
    );

USB_MINIPORT_STATUS
USBMPFN
UhciEndSendOnePacket(
    IN PDEVICE_DATA DeviceData,
    IN PMP_PACKET_PARAMETERS PacketParameters,
    IN PUCHAR PacketData,
    IN PULONG PacketLength,
    IN PUCHAR WorkspaceVirtualAddress,
    IN HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    IN ULONG WorkSpaceLength,
    IN OUT USBD_STATUS *UsbdStatus
    );

VOID
USBMPFN
UhciSetEndpointStatus(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATUS Status
    );

MP_ENDPOINT_STATUS
USBMPFN
UhciGetEndpointStatus(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

PHCD_QUEUEHEAD_DESCRIPTOR
UhciInitializeQH(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR Qh,
    IN HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    );

VOID
USBMPFN
UhciSetEndpointDataToggle(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN ULONG Toggle
    );

VOID
USBMPFN
UhciPollEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

MP_ENDPOINT_STATE
USBMPFN
UhciGetEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

VOID
USBMPFN
UhciSetEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    );

VOID
UhciSetAsyncEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    );

USB_MINIPORT_STATUS
USBMPFN
UhciSubmitTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferUrb,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    );

//
// Async
//

VOID
UhciProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    );

VOID
UhciPollAsyncEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
UhciBulkOrInterruptTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    );

VOID
UhciUnlinkQh(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR Qh
    );

VOID
UhciAbortAsyncTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext,
    OUT PULONG BytesTransferred
    );

VOID
UhciInsertQh(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR FirstQh,
    IN PHCD_QUEUEHEAD_DESCRIPTOR LinkQh
    );

USB_MINIPORT_STATUS
UhciControlTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferUrb,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    );

//
// Isoch
//

USB_MINIPORT_STATUS
USBMPFN
UhciIsochTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PMINIPORT_ISO_TRANSFER IsoTransfer
    );

VOID
UhciPollIsochEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

VOID
UhciAbortIsochTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext
    );

VOID
UhciSetIsochEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    );

VOID
UhciCleanOutIsoch(
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN      ForceClean
    );

//
// Utility
//

USBD_STATUS
UhciGetErrorFromTD(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    );

PHCD_TRANSFER_DESCRIPTOR
UhciAllocTd(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

PTRANSFER_BUFFER
UhciAllocDb(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN BOOLEAN Isoch
    );

//
// Bios handoff and handback
//
USB_MINIPORT_STATUS
UhciStopBIOS(
    IN PDEVICE_DATA DeviceData,
    IN PHC_RESOURCES HcResources
    );

ULONG
UhciQueryControlRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    );

ULONG
UhciQueryBulkRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    );

ULONG
UhciQueryIsoRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    );

ULONG
UhciQueryInterruptRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    );

BOOLEAN
UhciHardwarePresent(
    PDEVICE_DATA DeviceData
    );

VOID
UhciCheckController(
    PDEVICE_DATA DeviceData
    );

VOID
UhciFlushInterrupts(
    IN PDEVICE_DATA DeviceData
    );
/*
USB_MINIPORT_STATUS
UhciStartBIOS(
    IN PDEVICE_DATA DeviceData
    );
  */

#endif /* __USBUHCI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\openhci\openhci.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   OpenHCI.c

Abstract:

   The OpenHCI driver for USB, this module contains the initialization code.

Environment:

   kernel mode only

Notes:

Revision History:

   12-28-95 : created  jfuller
   3-1-96 : modified kenray


--*/

#include "openhci.h"
#include <windef.h>
#include <unknown.h>
#ifdef DRM_SUPPORT
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>
#include <ksdrmhlp.h>
#endif

#ifdef MAX_DEBUG
ULONG OHCI_Debug_Trace_Level = 2;
#else
#ifdef NTKERN
ULONG OHCI_Debug_Trace_Level = 1;
#else
ULONG OHCI_Debug_Trace_Level 
#ifdef JD
    = 1;
#else    
    = 0;
#endif /* JD */    
#endif /* NTKERN */
#endif /* MAX_DEBUG */


#define OHCI_WAIT(ms) {\
    LARGE_INTEGER t;\
    t.QuadPart = (((LONG)KeQueryTimeIncrement()-1) + (ms) * 10000) * -1;\
    KeDelayExecutionThread(KernelMode, FALSE, &t);\
    }


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

   Installable driver initialization entry point.
   This entry point is called directly by the I/O system.

Arguments:

   DriverObject - pointer to the driver object

   RegistryPath - pointer to a unicode string representing the path
                  to driver-specific key in the registry

Return Value:

   NT status code

--*/
{
    PDEVICE_OBJECT deviceObject = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    OpenHCI_KdPrint((2, "'entering DriverEntry\n"));

    OpenHCI_KdPrint ((1, "'HCD using USBDI version %x\n", USBDI_VERSION));        

    if (NT_SUCCESS(ntStatus)) {

        //
        // Create dispatch points for device control, create, close.
        //

        DriverObject->MajorFunction[IRP_MJ_CREATE] =
            DriverObject->MajorFunction[IRP_MJ_CLOSE] =
            DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] =
            DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
            DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =
            DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]
            = OpenHCI_Dispatch;

        DriverObject->MajorFunction[IRP_MJ_PNP] = OpenHCI_Dispatch;
        DriverObject->MajorFunction[IRP_MJ_POWER] = OpenHCI_Dispatch;
        DriverObject->DriverExtension->AddDevice = OpenHCI_PnPAddDevice;

        DriverObject->DriverUnload = OpenHCI_Unload;

    }
    OpenHCI_KdPrint((2, "'exit DriverEntry %x\n", ntStatus));

    return ntStatus;
}


#ifdef DRM_SUPPORT


NTSTATUS
OpenHCI_PreUSBD_SetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
)
 /* ++
  *
  * Description:
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PVOID Handlers[1];
    ULONG ContentId;

    PAGED_CODE();

    ASSERT(irp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    ContentId = pvData->ContentId;
    Handlers[0] = USBD_Dispatch;
    return pKsProperty->DrmAddContentHandlers(ContentId, Handlers, SIZEOF_ARRAY(Handlers));
}

NTSTATUS
OpenHCI_PostUSBD_SetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
)
 /* ++
  *
  * Description:
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    NTSTATUS ntStatus;

    PAGED_CODE();

    ASSERT(irp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    // ioStackLocation = IoGetCurrentIrpStackLocation(irp);
    // deviceExtension = ioStackLocation->DeviceObject->DeviceExtension;
    // Context = pKsProperty->Context;
    // ContentId = pvData->ContentId;;

    return STATUS_SUCCESS;
}

#endif


NTSTATUS
OpenHCI_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Process the IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object

   Irp          - pointer to an I/O Request Packet

Return Value:

      NT status code

--*/
{

    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHCD_DEVICE_DATA DeviceData;
    PDEVICE_OBJECT hcdDeviceObject, topOfStackPhysicalDeviceObject;
    BOOLEAN touchHardware = TRUE;

#ifdef DRM_SUPPORT

    //
    // Need to check DRM request before passing to USBD and advise DRM of
    // the USBD entry point.  Otherwise, a rogue USBD could circumvent DRM.
    //
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    if (IRP_MJ_DEVICE_CONTROL == irpStack->MajorFunction && IOCTL_KS_PROPERTY == irpStack->Parameters.DeviceIoControl.IoControlCode) {
        NTSTATUS ntStatus;
        ntStatus = KsPropertyHandleDrmSetContentId(Irp, OpenHCI_PreUSBD_SetContentId);
        if (!NT_SUCCESS(ntStatus) && ntStatus != STATUS_PROPSET_NOT_FOUND) {
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return ntStatus;
        }
    }

#endif

    //
    // see if USBD will handle this request
    //

    //
    // First we pass the irp to USBD
    //
    if (!USBD_Dispatch(DeviceObject,
                       Irp,
                       &hcdDeviceObject,
                       &ntStatus)) {
        //
        // Irp was completed by USBD just exit our dispatch
        // routine.
        //
        DeviceData = (PHCD_DEVICE_DATA) hcdDeviceObject->DeviceExtension;
        goto OpenHCI_Dispatch_Done;
    }

    IRP_IN(Irp);

    DeviceData = (PHCD_DEVICE_DATA) hcdDeviceObject->DeviceExtension;
    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_CALL_TRACE, ("'enter OHCI_Dispatch\n"));

    //
    // use the extension from our FDO, note the USBD function returns us
    // our FDO.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (irpStack->MajorFunction) {

    case IRP_MJ_CREATE:

        OpenHCI_KdPrintDD(DeviceData,
            OHCI_DBG_CALL_TRACE, ("'IRP_MJ_CREATE\n"));
        OpenHCI_CompleteIrp(hcdDeviceObject, Irp, ntStatus);

        break;

    case IRP_MJ_CLOSE:

        OpenHCI_KdPrintDD(DeviceData,
            OHCI_DBG_CALL_TRACE, ("'IRP_MJ_CLOSE\n"));
        OpenHCI_CompleteIrp(hcdDeviceObject, Irp, ntStatus);

        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:

        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_INTERNAL_USB_SUBMIT_URB:
            OpenHCI_KdPrintDD(DeviceData,
                OHCI_DBG_CALL_TRACE, ("'Process URB\n"));
            ntStatus = OpenHCI_URB_Dispatch(hcdDeviceObject, Irp);
            break;

        default:
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CALL_ERROR,
                ("'Unhandled Internal IOCTL IoCtl: %x, min: %x\n",
                 irpStack->Parameters.DeviceIoControl.IoControlCode,
                 irpStack->MinorFunction));

            TEST_TRAP();
            ntStatus = STATUS_NOT_IMPLEMENTED;
            OpenHCI_CompleteIrp(hcdDeviceObject, Irp, ntStatus);
        }

        break;

    case IRP_MJ_DEVICE_CONTROL:

        OpenHCI_KdPrintDD(DeviceData,
            OHCI_DBG_CALL_TRACE, ("'IRP_MJ_DEVICE_CONTROL\n"));

        switch (irpStack->Parameters.DeviceIoControl.IoControlCode)
        {

#ifdef DRM_SUPPORT

            case IOCTL_KS_PROPERTY:
            {
                ntStatus = KsPropertyHandleDrmSetContentId(Irp, OpenHCI_PostUSBD_SetContentId);
                OpenHCI_CompleteIrp(hcdDeviceObject, Irp, ntStatus);
                break;
            }
#endif

#if FAKEPORTCHANGE
            case IOCTL_USB_HCD_DISABLE_PORT:
            case IOCTL_USB_HCD_ENABLE_PORT:
            {
                ULONG                       portIndex;
                PHC_OPERATIONAL_REGISTER    HC;

                HC = DeviceData->HC;

                if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(ULONG))
                {
                    ntStatus = STATUS_BUFFER_TOO_SMALL;
                }
                else
                {
                    // Get the zero-based port number.
                    //
                    portIndex = *(PULONG)Irp->AssociatedIrp.SystemBuffer;

                    if (portIndex >= DeviceData->NumberOfPorts)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        LOGENTRY(G, 'FAKE', DeviceData->FakePortChange,
                                 DeviceData->FakePortDisconnect, portIndex);

                        DeviceData->FakePortChange |= (1 << portIndex);

                        if (irpStack->Parameters.DeviceIoControl.IoControlCode ==
                            IOCTL_USB_HCD_DISABLE_PORT)
                        {
                            DeviceData->FakePortDisconnect |= (1 << portIndex);
                        }
                        else
                        {
                            DeviceData->FakePortDisconnect &= ~(1 << portIndex);
                        }

                        LOGENTRY(G, 'fake', DeviceData->FakePortChange,
                                 DeviceData->FakePortDisconnect, portIndex);

                        // Can't trigger an HcInt_RootHubStatusChange interrupt
                        // so just trigger an SOF interrupt and OpenHCI_IsrDPC()
                        // will call EmulateRootHubInterruptXfer() since we just
                        // set a bit in DeviceData->FakePortChange.
                        //
                        WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                                             HcInt_StartOfFrame);

                        ntStatus = STATUS_SUCCESS;
                    }
                }

                OpenHCI_CompleteIrp(hcdDeviceObject, Irp, ntStatus);

                break;
            }

#endif // FAKEPORTCHANGE

            default:
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                OpenHCI_CompleteIrp(hcdDeviceObject, Irp, ntStatus);
                break;
        }

        break;

    //
    // Process PnP messages
    //
    case IRP_MJ_PNP:

        OpenHCI_KdPrintDD(DeviceData,
            OHCI_DBG_CALL_TRACE, ("'IRP_MJ_PNP\n"));

        topOfStackPhysicalDeviceObject =
            DeviceData->TopOfStackPhysicalDeviceObject;

        switch (irpStack->MinorFunction) {
        case IRP_MN_START_DEVICE:

            OpenHCI_KdPrintDD(DeviceData,
                OHCI_DBG_PNP_TRACE, ("'IRP_MN_START_DEVICE\n"));
            OpenHCI_KdTrap(("'should not see start\n"));
            break;

        //
        // STOP & REMOVE messages unload the driver.
        // When we get a STOP message it is still possible touch the
        // hardware,
        // When we get a REMOVE message we assume that the hardware is
        // gone.
        //

        case IRP_MN_STOP_DEVICE:

            OpenHCI_KdPrintDD(DeviceData,
                OHCI_DBG_PNP_TRACE, ("'IRP_MN_STOP_DEVICE\n"));

            ntStatus = OpenHCI_StopDevice(hcdDeviceObject, TRUE);

            // The documentation says to set the status before passing the
            // Irp down the stack
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;

            break;

        case IRP_MN_SURPRISE_REMOVAL:
            touchHardware = FALSE;

            // Stop assert failure in OpenHCI_StopDevice() by clearing these
            //
            DeviceData->RootHubAddress = 0;
            DeviceData->RootHubConfig = 0;

            // Fall Through!

        case IRP_MN_REMOVE_DEVICE:

            OpenHCI_KdPrintDD(DeviceData,
                OHCI_DBG_PNP_TRACE, ("'IRP_MN_REMOVE_DEVICE\n"));

            // Currently we touch the hardware registers suring a remove
            // the reason is that during shutdown to DOS mode in Win95
            // we only get a remove messages.
            //
            // this code may need some modifiaction in the event we see
            // a PC-CARD version of the OHCI host controller

            ntStatus = OpenHCI_StopDevice(hcdDeviceObject, touchHardware);

            USBD_FreeDeviceName(DeviceData->DeviceNameHandle);

            IoDetachDevice(DeviceData->TopOfStackPhysicalDeviceObject);
            IoDeleteDevice(hcdDeviceObject);

            break;

        default:
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_PNP_ERROR,
                              ("'PNP MESSAGE NOT HANDLED 0x%x\n",
                              irpStack->MinorFunction));
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CALL_TRACE,
                              ("'exit OpenHCI_Dispatch\n"));

            //
            // PnP messages not handled are passed on to the PDO
            //

        } // switch (irpStack->MinorFunction), PNP

        //
        // All PNP messages are passed on to the lower levels.
        // aka the PhysicalDeviceObject
        //

        IRP_OUT(Irp);
        IoDecrementStackLocation(Irp);
        ntStatus = IoCallDriver(topOfStackPhysicalDeviceObject,
                                Irp);

        break; // IRP_MJ_PNP

    //
    // Process Power messages
    //
    case IRP_MJ_POWER:

        OpenHCI_KdPrintDD(DeviceData,
            OHCI_DBG_CALL_TRACE, ("'IRP_MJ_POWER\n"));
        // should not get here, USBD should handle all power irps
        OpenHCI_KdTrap(("'power message to HCD?\n"));
        TRAP();

        break;  // IRP_MJ_POWER

    default:
        OpenHCI_KdBreak(("'unrecognized IRP_MJ_ function (%x)\n",
                        irpStack->MajorFunction));

        ntStatus = STATUS_INVALID_PARAMETER;
        OpenHCI_CompleteIrp(hcdDeviceObject, Irp, ntStatus);
    } /* case */

OpenHCI_Dispatch_Done:

    OpenHCI_KdPrint((2, "'exit OpenHCI_Dispatch\n", ntStatus));

    return ntStatus;
}


NTSTATUS
OpenHCI_PowerIrpComplete(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
Routine Description:

   This routine is called when the BUS a completes IRP_MJ_POWER
   Irp.

Arguments:

   DeviceObject - Pointer to the OpenHCI device object

   Irp - The IPR_MJ_POWER Irp, which was just sent down to the PDO.

   Context - The OpenHCI DeviceObject (FDO).

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = NULL;
    PDEVICE_OBJECT deviceObject = (PDEVICE_OBJECT) Context;
    PHCD_DEVICE_DATA DeviceData = deviceObject->DeviceExtension;

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_PNP_TRACE, ("'PowerIrpComplete"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    if (TRUE == Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    OHCI_ASSERT(IRP_MJ_POWER == irpStack->MajorFunction);
    OHCI_ASSERT(IRP_MN_SET_POWER == irpStack->MinorFunction);
    OHCI_ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);
    OHCI_ASSERT(irpStack->Parameters.Power.State.DeviceState ==
        PowerDeviceD0);

    DeviceData->CurrentDevicePowerState = PowerDeviceD0;
    OpenHCI_KdPrint((1, "'Host Controller entered (D0)\n"));

    Irp->IoStatus.Status = ntStatus;
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_PNP_TRACE,
                      ("'exit PowerIrpComplete 0x%x\n", ntStatus));
    return ntStatus;
}


VOID
OpenHCI_Unload(
    IN PDRIVER_OBJECT Driver
    )
/*++

Routine Description:

   Free all the global allocated resources, etc.

Arguments:

   DriverObject - pointer to a driver object

Return Value:

   None

--*/
{
    OpenHCI_KdPrint((2, "'unloading\n"));

    OHCI_LogFree();
}


NTSTATUS

OpenHCI_CreateDeviceObject(
    IN PDRIVER_OBJECT       DriverObject,
    IN OUT PDEVICE_OBJECT * DeviceObject,
    IN PUNICODE_STRING      DeviceNameUnicodeString
    )
/*++

Routine Description:

      This routine is called to create a new instance of a USB host
      controller.

Arguments:

   DriverObject - pointer to the driver object for USBD.

   *DeviceObject - ptr to DeviceObject ptr to be filled
                   in with the device object we create.

   Configuration - ptr to configuration data to be stored
                   in the device extension.

   AdpatersFound - zero based index for this adapter, used to
                   create a unique device name.

Return Value:

   NT status code

--*/
{
    NTSTATUS ntStatus;
    PHCD_DEVICE_DATA DeviceData;

    OpenHCI_KdPrint((2,
        "'enter OpenHCI_CreateDeviceObject\n"));

    ASSERT((PDEVICE_OBJECT *) NULL != DeviceObject);

    if (DeviceNameUnicodeString) {
        OpenHCI_KdPrint((2, "'CreateDeviceObject: device object named %ws\n",
                             DeviceNameUnicodeString->Buffer));
    } else {
        OpenHCI_KdPrint((2, "'CreateDeviceObject w/ no name\n"));
    }

    ntStatus = IoCreateDevice(DriverObject,
                              sizeof(HCD_DEVICE_DATA),
                              DeviceNameUnicodeString,
                              FILE_DEVICE_CONTROLLER,
                              0,
                              FALSE,
                              DeviceObject);

    if (NT_SUCCESS(ntStatus)) {
        DeviceData = (PHCD_DEVICE_DATA) ((*DeviceObject)->DeviceExtension);

        //
        // Zero / NULL initialize all fields of the DeviceData structure.
        //
        RtlZeroMemory(DeviceData, sizeof(HCD_DEVICE_DATA));

        //
        // link configuration info to the DeviceData
        //

        DeviceData->DeviceObject = *DeviceObject;

        //
        // Initialize various objects in DeviceData
        //
        KeInitializeSpinLock(&DeviceData->InterruptSpin);

        KeInitializeSpinLock(&DeviceData->EDListSpin);
        InitializeListHead(&DeviceData->StalledEDReclamation);
        InitializeListHead(&DeviceData->RunningEDReclamation);
        InitializeListHead(&DeviceData->PausedEDRestart);
        DeviceData->DebugLevel = OHCI_DEFAULT_DEBUG_OUTPUT_LEVEL;

        DeviceData->AvailableBandwidth = 10280;
        DeviceData->HcDma = -1;

        KeInitializeSpinLock(&DeviceData->HcDmaSpin);
        KeInitializeSpinLock(&DeviceData->DescriptorsSpin);
        KeInitializeSpinLock(&DeviceData->ReclamationSpin);
        KeInitializeSpinLock(&DeviceData->PausedSpin);
        KeInitializeSpinLock(&DeviceData->HcFlagSpin);
        KeInitializeSpinLock(&DeviceData->PageListSpin);

        // Initialize our deadman timer
        //
        KeInitializeDpc(&DeviceData->DeadmanTimerDPC,
                        OpenHCI_DeadmanDPC,
                        *DeviceObject);

        KeInitializeTimer(&DeviceData->DeadmanTimer);

#if DBG
        // will roll over in < 6 minutes
        DeviceData->FrameHighPart = 0xFFFB0000;
        // noone is in open or close Endpoint.
        DeviceData->OpenCloseSync = -1;
#endif
    }
    OpenHCI_KdPrint((2, "'exit CreateDevObject %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
OpenHCI_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
jd
Routine Description:

   This routine creates a new instance of a USB host controller

Arguments:

   DriverObject - pointer to the driver object for this instance of ohcd

   PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

   STATUS_SUCCESS if successful,
   STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject = NULL;
    PHCD_DEVICE_DATA DeviceData;
    UNICODE_STRING deviceNameUnicodeString;
    ULONG deviceNameHandle;

    OpenHCI_KdPrint((2, "'enter OpenHCI_PnPAddDevice\n"));

    deviceNameHandle = USBD_AllocateDeviceName(&deviceNameUnicodeString);

    ntStatus = OpenHCI_CreateDeviceObject(DriverObject,
                                          &deviceObject,
                                          &deviceNameUnicodeString);
    if (NT_SUCCESS(ntStatus)) {
        DeviceData = deviceObject->DeviceExtension;
        DeviceData->DeviceNameHandle = deviceNameHandle;

        DeviceData->RealPhysicalDeviceObject = PhysicalDeviceObject;
        DeviceData->TopOfStackPhysicalDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
        //
        // We need to keep track of BOTH the pdo and any filter drivers
        // that might have attaced to the top of the pdo.  We cannot use
        // IoAttachDevice, and we must have another variable.
        //

        if (NT_SUCCESS(ntStatus)) {
            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
            deviceObject->Flags |= DO_POWER_PAGABLE;

            //
            // The device is ready for requests.
            //

            USBD_RegisterHostController(PhysicalDeviceObject,
                                        deviceObject,
                                        DeviceData->
                                            TopOfStackPhysicalDeviceObject,
                                        DriverObject,
                                        OpenHCI_DeferredStartDevice,
                                        OpenHCI_SetDevicePowerState,
                                        OpenHCI_ExternalGetCurrentFrame,
#ifndef WIN98
                                        OpenHCI_ExternalGetConsumedBW,
#endif
                                        NULL, // fast iso entry point
                                        deviceNameHandle);
            // A great little function that JD put together to do the PnP
            // magic.
            RtlFreeUnicodeString(&deviceNameUnicodeString);

#ifdef DEBUG_LOG
            OHCI_LogInit();
#endif
        }
    }

    OpenHCI_KdPrint((2, "'exit OpenHCI_PnPAddDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
OpenHCI_ExternalGetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG CurrentFrame
    )

/*++

Routine Description:


Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    *CurrentFrame = Get32BitFrameNumber(DeviceObject->DeviceExtension);

    return STATUS_SUCCESS;
}

ULONG
OpenHCI_ExternalGetConsumedBW(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:


Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    PHCD_DEVICE_DATA deviceData;
    deviceData = DeviceObject->DeviceExtension;

    // bits/ms

    return deviceData->MaxBandwidthInUse;
}


NTSTATUS
OpenHCI_Shutdown(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

   Stops an instance of a USB controller, by shutting down the
   controller and removing the resources.

Arguments:

   DeviceObject - DeviceObject of the controller to stop
   TouchTheHardware - should we access the device.

Return Value:

   NT status code.

--*/

{
    PHCD_DEVICE_DATA DeviceData =
        (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    PHC_OPERATIONAL_REGISTER hC;

    LOGENTRY(G, 'SHTd', DeviceData, 0, 0);

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_SS_TRACE, ("'enter OpenHCI_ShutDown \n"));

    DeviceData->HcFlags |= HC_FLAG_SHUTDOWN;

    if (DeviceData->InterruptObject) {

        hC = DeviceData->HC;
        WRITE_REGISTER_ULONG(&hC->HcInterruptDisable, 0xFFFFFFFF);

        if (!KeSynchronizeExecution(DeviceData->InterruptObject,
                                    OpenHCI_StopController,
                                    DeviceData)) {
            return STATUS_UNSUCCESSFUL;
        }

        IoDisconnectInterrupt(DeviceData->InterruptObject);
        DeviceData->InterruptObject = NULL;

#ifdef NTKERN

        // now we do any BIOS handback that is necessary

        OpenHCI_StartBIOS(DeviceObject);
#endif
    }


    return STATUS_SUCCESS;
}


NTSTATUS
OpenHCI_StopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN TouchTheHardware
    )
/*++

Routine Description:

   Stops an instance of a USB controller, by shutting down the
   controller and removing the resources.

Arguments:

   DeviceObject - DeviceObject of the controller to stop
   TouchTheHardware - should we access the device.

Return Value:

   NT status code.

--*/

{
    PHCD_DEVICE_DATA DeviceData =
        (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    PPAGE_LIST_ENTRY pageList;

    LOGENTRY(G, 'STPc', DeviceData, 0, 0);

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_SS_TRACE, ("'enter OHCI_StopDevice \n"));

    if (!(DeviceData->HcFlags & HC_FLAG_DEVICE_STARTED)) {
        OpenHCI_KdPrintDD(DeviceData,
            OHCI_DBG_SS_INFO, ("'Already Stopped !!!\n"));
        return STATUS_SUCCESS;
    }

    // stop idle checking
    DeviceData->HcFlags |= HC_FLAG_DISABLE_IDLE_CHECK;

    // Stop our deadman timer
    //
    KeCancelTimer(&DeviceData->DeadmanTimer);

    if (TouchTheHardware && DeviceData->InterruptObject) {
        if (!KeSynchronizeExecution(DeviceData->InterruptObject,
                                    OpenHCI_StopController,
                                    DeviceData)) {
            return STATUS_UNSUCCESSFUL;
        }
    }
    if (DeviceData->InterruptObject) {
        IoDisconnectInterrupt(DeviceData->InterruptObject);
        DeviceData->InterruptObject = NULL;
    }

    OHCI_ASSERT(DeviceData->FrozenHcDoneHead == 0);

    //
    // free our common buffer pool
    //
    while (pageList = (PPAGE_LIST_ENTRY)ExInterlockedPopEntryList(
                          (PSINGLE_LIST_ENTRY) &DeviceData->PageList,
                            &DeviceData->DescriptorsSpin))
    {
        HalFreeCommonBuffer(DeviceData->AdapterObject,
                            pageList->BufferSize,
                            pageList->PhysAddr,
                            pageList->VirtAddr,
                            CacheCommon);

        ExFreePool(pageList);
    }

    OHCI_ASSERT(DeviceData->PageList == NULL);

    DeviceData->FreeDescriptorCount = 0;

    // no root hub address should be assigned
    OHCI_ASSERT(DeviceData->RootHubAddress == 0);
    // root hub should no longer be configured
    OHCI_ASSERT(DeviceData->RootHubConfig == 0);

    // Free the (HalGetAdapter call)
    (DeviceData->AdapterObject->DmaOperations->PutDmaAdapter)
        (DeviceData->AdapterObject);
    DeviceData->AdapterObject = NULL;

    // unmap device registers here

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_SS_TRACE, ("'exit OHCI_StopDevice \n"));

    DeviceData->HcFlags &= ~HC_FLAG_DEVICE_STARTED;

    return STATUS_SUCCESS;
}


BOOLEAN
OpenHCI_StopController(
    IN PVOID Context
    )
/*++

Routine Description:

   Stops an OpenHCI host controller by putting it into USBReset
   StopController is run from KeSynchronizeExecution

Arguments:

   Context - DeviceData of the controller to stop

Return Value:

   TRUE.

--*/

{
#define DeviceData   ((PHCD_DEVICE_DATA) Context)
    PHC_OPERATIONAL_REGISTER HC = DeviceData->HC;

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_SS_TRACE, ("'enter OHCI_StopContr \n"));

    //
    // There is no need to call OpenHCI_HcControl_AND as we are
    // already in a KeSynch situation.
    //
    DeviceData->CurrentHcControl.ul &= ~(HcCtrl_PeriodicListEnable |
                                         HcCtrl_IsochronousEnable |
                                         HcCtrl_ControlListEnable |
                                         HcCtrl_BulkListEnable |
                                         HcCtrl_RemoteWakeupEnable);
    DeviceData->CurrentHcControl.HostControllerFunctionalState =
        HcHCFS_USBSuspend;
    WRITE_REGISTER_ULONG(&HC->HcControl.ul, DeviceData->CurrentHcControl.ul);
    WRITE_REGISTER_ULONG(&HC->HcInterruptDisable, 0xFFFFffff);
    WRITE_REGISTER_ULONG(&HC->HcInterruptStatus, 0xFFFFffff);

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_SS_TRACE, ("'exit OHCI_StopContr \n"));

    return TRUE;
#undef DeviceData
}


NTSTATUS
OpenHCI_InitializeSchedule(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

   Initializes the schedule structures for the HCD

Arguments:

   DeviceObject - DeviceObject for this USB controller.

Return Value:

   NT Status code.

--*/
{
    PHCD_DEVICE_DATA            DeviceData;
    PHC_OPERATIONAL_REGISTER    HC;
    PCHAR                       PageVirt;
    PHYSICAL_ADDRESS            PagePhys;
    PHCCA_BLOCK                 HCCA;
    PHC_ENDPOINT_DESCRIPTOR     HcED;
    PHC_ENDPOINT_DESCRIPTOR     StaticED[ED_INTERRUPT_32ms];
    ULONG                       reserveLength;
    ULONG                       i, j, k;
    NTSTATUS                    ntStatus;

    // See section 5.2.7.2 of the OpenHCI spec
    //
    static UCHAR Balance[16] = {
        0x0, 0x8, 0x4, 0xC, 0x2, 0xA, 0x6, 0xE,
        0x1, 0x9, 0x5, 0xD, 0x3, 0xB, 0x7, 0xF
    };


    DeviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;

    HC = DeviceData->HC;

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
                    ("'enter OpenHCI_InitializeSchedule\n"));

#ifdef MAX_DEBUG
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE, ("'HC = %x\n", HC));
    TRAP();
#endif

    if (DeviceData->AdapterObject == NULL) {
        //
        // We need to get the AdapterObject for the host adapter
        //
        DEVICE_DESCRIPTION DeviceDescription;

        RtlZeroMemory(&DeviceDescription, sizeof(DEVICE_DESCRIPTION));
        DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
        DeviceDescription.Master = TRUE;
        DeviceDescription.ScatterGather = TRUE;
        DeviceDescription.Dma32BitAddresses = TRUE;
        DeviceDescription.InterfaceType = PCIBus;
        DeviceDescription.MaximumLength = (ULONG) -1;
        DeviceData->AdapterObject =
            IoGetDmaAdapter(DeviceData->RealPhysicalDeviceObject,
                            &DeviceDescription,
                            &DeviceData->NumberOfMapRegisters);
        if (DeviceData->AdapterObject == NULL) {
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_ERROR,
             ("'exit OpenHCI_InitializeSchedule: Insufficient Resources\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Allocate the first page of common buffer for TDs and EDs, reserving
    // space at the beginning of the page for the HCCA plus the statically
    // disabled ED for the interrupt polling tree
    //

    reserveLength = sizeof(HCCA_BLOCK) +
                    sizeof(HC_ENDPOINT_DESCRIPTOR) * ED_INTERRUPT_32ms;

    ntStatus = OpenHCI_GrowDescriptorPool(DeviceData,
                                          reserveLength,
                                          &PageVirt,
                                          &PagePhys);

    if (!NT_SUCCESS(ntStatus))
    {
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_ERROR,
                        ("'exit OpenHCI_InitializeSchedule: No Memory\n"));
        return ntStatus;
    }

    //
    // In theory the Host Controller Communications Area (HCCA) has alignment
    // requirements that must be determined by examining the HcHCCA register;
    // but the best alignment we can provide is page alignment, so that is what
    // we do.  Right now, we just set our virtual pointer, we'll get the
    // hardware's physical pointer set later.
    //

    DeviceData->HCCA = HCCA = (PHCCA_BLOCK) PageVirt;

    // Advance past the HCCA to the space reserved for the statically
    // disabled EDs for the interrupt polling tree.
    //
    PageVirt += sizeof(HCCA_BLOCK);
    PagePhys.LowPart += sizeof(HCCA_BLOCK);

    //
    // Allocate sataticly disabled EDs, and set head pointers for scheduling
    // lists
    //
    for (i = 0; i < ED_INTERRUPT_32ms; i++)
    {
        //
        // Carve next ED from our common memory (assume appropriate boundries)
        // 
        HcED = (PHC_ENDPOINT_DESCRIPTOR) PageVirt;
        HcED->TailP = PagePhys.LowPart; // store self physical address in TailP
        HcED->HeadP = 0xDEADBEAF;

        DeviceData->EDList[i].PhysicalHead = &HcED->NextED;
        HcED->Control = HcEDControl_SKIP;   // mark ED as disabled
        InitializeListHead(&DeviceData->EDList[i].Head);
        StaticED[i] = HcED;

        if (i > 0) {
            DeviceData->EDList[i].Next = (char) (i - 1) / 2;
            HcED->NextED = StaticED[(i - 1) / 2]->TailP;
        } else {
            DeviceData->EDList[i].Next = ED_EOF;
            HcED->NextED = 0;
        }

        // Advance pointers to next ED
        //
        PageVirt += sizeof(HC_ENDPOINT_DESCRIPTOR);
        PagePhys.LowPart += sizeof(HC_ENDPOINT_DESCRIPTOR);
    }

    //
    // Set head pointers for 32ms scheduling lists which start from HCCA
    //
    for (i = 0, j = ED_INTERRUPT_32ms;
         i < 32;
         i++, j++)
    {
        DeviceData->EDList[j].PhysicalHead = &HCCA->HccaInterruptTable[i];
        InitializeListHead(&DeviceData->EDList[j].Head);
        k = Balance[i & 0xF] + ED_INTERRUPT_16ms;
        DeviceData->EDList[j].Next = (char) k;
        HCCA->HccaInterruptTable[i] = StaticED[k]->TailP;
    }

    //
    // Setup EDList entries for Control & Bulk
    //
    InitializeListHead(&DeviceData->EDList[ED_CONTROL].Head);
    DeviceData->EDList[ED_CONTROL].PhysicalHead = &HC->HcControlHeadED;
    DeviceData->EDList[ED_CONTROL].Next = ED_EOF;
    DeviceData->EDList[ED_CONTROL].HcRegister = TRUE;

    InitializeListHead(&DeviceData->EDList[ED_BULK].Head);
    DeviceData->EDList[ED_BULK].PhysicalHead = &HC->HcBulkHeadED;
    DeviceData->EDList[ED_BULK].Next = ED_EOF;
    DeviceData->EDList[ED_BULK].HcRegister = TRUE;

    // our list of active endpoints
    InitializeListHead(&DeviceData->ActiveEndpointList);

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
                    ("'exit OpenHCI_InitializeSchedule: Success\n"));

    return STATUS_SUCCESS;
}


NTSTATUS
OpenHCI_StopBIOS(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

   Takes control from legacy BIOS.

Arguments:

   DeviceObject - DeviceObject for this USB controller.

Return Value:

--*/
{
    PHCD_DEVICE_DATA            DeviceData;
    PHC_OPERATIONAL_REGISTER    HC;
    LARGE_INTEGER               finishTime;
    LARGE_INTEGER               currentTime;
    ULONG                       HcControl;

    DeviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
                    ("'OpenHCI_StopBIOS\n"));

    HC = DeviceData->HC;

    //
    // Check to see if a System Management Mode driver owns the HC
    //
    HcControl = READ_REGISTER_ULONG(&HC->HcControl.ul);

    if (HcControl & HcCtrl_InterruptRouting)
    {
        OpenHCI_KdPrint((1, "'OpenHCI detected Legacy BIOS\n"));

        if ((HcControl == HcCtrl_InterruptRouting) &&
            (READ_REGISTER_ULONG(&HC->HcInterruptEnable) == 0))
        {
            // Major assumption:  If HcCtrl_InterruptRouting is set but
            // no other bits in HcControl are set, i.e. HCFS==UsbReset,
            // and no interrupts are enabled, then assume that the BIOS
            // is not actually using the host controller.  In this case
            // just clear the erroneously set HcCtrl_InterruptRouting.
            //
            // This assumption appears to be correct on a Portege 3010CT,
            // where HcCtrl_InterruptRouting is set during a Resume from
            // Standby, but the BIOS doesn't actually appear to be using
            // the host controller.  If we were to continue on and set
            // HcCmd_OwnershipChangeRequest, the BIOS appears to wake up
            // and try to take ownership of the host controller instead of
            // giving it up.
            //

            OpenHCI_KdPrint((0, "'OpenHCI_StopBIOS: HcCtrl_InterruptRouting erroneously set\n"));

            WRITE_REGISTER_ULONG(&HC->HcControl.ul, 0);
        }
        else
        {
            //
            // A SMM driver does own the HC, it will take some time to
            // get the SMM driver to relinquish control of the HC.  We
            // will ping the SMM driver, and then wait repeatedly until
            // the SMM driver has relinquished control of the HC.
            //
            // THIS CODE ONLY WORKS IF WE ARE EXECUTING IN THE CONTEXT
            // OF A SYSTEM THREAD.
            //

            WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul,
                                 HcCmd_OwnershipChangeRequest);

            KeQuerySystemTime(&finishTime); // get current time
            finishTime.QuadPart += 5000000; // figure when we quit (.5 seconds
                                            // later)

            //
            // We told the SMM driver we want the HC, now all we can do is wait
            // for the SMM driver to be done with the HC.
            //
            while (READ_REGISTER_ULONG(&HC->HcControl.ul) &
                   HcCtrl_InterruptRouting)
            {
                KeQuerySystemTime(&currentTime);

                if (currentTime.QuadPart >= finishTime.QuadPart)
                {
                    OpenHCI_KdPrint((0, "'OpenHCI_StopBIOS: SMM has not relinquised HC -- this is a bug\n"));

                return STATUS_UNSUCCESSFUL;
                }

                OHCI_WAIT(1); // wait 1 ms
            }
        }

        DeviceData->HcFlags |= HC_FLAG_LEGACY_BIOS_DETECTED;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
OpenHCI_StartBIOS(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

   Returns control to legacy BIOS.

Arguments:

   DeviceObject - DeviceObject for this USB controller.

Return Value:

--*/
{
    PHCD_DEVICE_DATA DeviceData;
    PHC_OPERATIONAL_REGISTER HC;
    LARGE_INTEGER finishTime, currentTime;

    DeviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
                    ("'enter OpenHCI_StartBIOS\n"));

    HC = DeviceData->HC;

    if (DeviceData->HcFlags & HC_FLAG_LEGACY_BIOS_DETECTED) {

        // hand back control
        WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, HcCmd_OwnershipChangeRequest);
        WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                         HcInt_OwnershipChange);

        // enable interrupts
        WRITE_REGISTER_ULONG(&DeviceData->HC->HcInterruptEnable,
                         HcInt_MasterInterruptEnable);

        KeQuerySystemTime(&finishTime); // get current time
        finishTime.QuadPart += 5000000; // figure when we quit (.5 seconds
                                        // later)

        //
        // Wait for SMM driver to take control back
        //

        while (READ_REGISTER_ULONG(&HC->HcControl.ul) & HcCtrl_InterruptRouting) {
            KeQuerySystemTime(&currentTime);
            if (currentTime.QuadPart >= finishTime.QuadPart) {
                OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_ERROR,
                                ("'OpenHCI_InitializeHardware: SMM has not relinquised HC.\n"));
                return STATUS_UNSUCCESSFUL;
            }
            OHCI_WAIT(1); // wait 1 ms
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
OpenHCI_InitializeHardware(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

   Initializes the hardware registers in the host controller.

Arguments:

   DeviceObject - DeviceObject for this USB controller.

Return Value:

   NT Status code.

   Note: This routine is written assuming that it is called in the
   context of a system thread.

--*/
{
    PHCD_DEVICE_DATA DeviceData;
    PHC_OPERATIONAL_REGISTER HC;
    HC_RH_DESCRIPTOR_A descA;
    ULONG reg;
    NTSTATUS ntStatus;
    ULONG sofModifyValue;

    DeviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
                    ("'enter OpenHCI_InitializeHardware\n"));

    HC = DeviceData->HC;

    ntStatus = OpenHCI_StopBIOS(DeviceObject);

    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    //
    // If we made it here then we now own the HC and can initialize it.
    //

    //
    // Get current frame interval (could account for a known clock error)
    //
    DeviceData->OriginalInterval.ul = READ_REGISTER_ULONG(&HC->HcFmInterval.ul);

    // If FrameInterval is outside the range of the nominal value of 11999
    // +/- 1% then assume the value is bogus and set it to the nomial value.
    //
    if ((DeviceData->OriginalInterval.FrameInterval < 11879) ||
        (DeviceData->OriginalInterval.FrameInterval > 12119))
    {
        DeviceData->OriginalInterval.FrameInterval = 11999; // 0x2EDF
    }

    reg =  READ_REGISTER_ULONG(&HC->HcControl.ul);

    // Always enable for now
    //
    DeviceData->HcFlags |= HC_FLAG_REMOTE_WAKEUP_CONNECTED;

    if (reg & HcCtrl_RemoteWakeupConnected) {
        DeviceData->HcFlags |= HC_FLAG_REMOTE_WAKEUP_CONNECTED;
        OpenHCI_KdPrint((1, "'controller is wakeup enabled.\n"));
    }

    //
    // Set largest data packet (in case BIOS did not set)
    //
    DeviceData->OriginalInterval.FSLargestDataPacket =
        ((DeviceData->OriginalInterval.FrameInterval - MAXIMUM_OVERHEAD) * 6) / 7;
    DeviceData->OriginalInterval.FrameIntervalToggle ^= 1;

    //
    // Reset the controller
    //
    WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, HcCmd_HostControllerReset);
    //
    // Wait at least 10 microseconds for the reset to complete
    //
    KeStallExecutionProcessor(20);  

    //
    // Setup our copy of HcControl, and take HC to USBReset state
    //
    DeviceData->CurrentHcControl.ul
        = (READ_REGISTER_ULONG(&HC->HcControl.ul) & ~HcCtrl_HCFS_MASK)
        | HcCtrl_HCFS_USBReset;
    WRITE_REGISTER_ULONG(&HC->HcControl.ul, DeviceData->CurrentHcControl.ul);

    //
    // Restore original frame interval
    //

    // check for a registry based SOF modify Value
    sofModifyValue = DeviceData->OriginalInterval.FrameInterval;
    OpenHCI_GetSOFRegModifyValue(DeviceObject,
                                 &sofModifyValue);

    DeviceData->OriginalInterval.FrameInterval =
        sofModifyValue;

    do {
        WRITE_REGISTER_ULONG(&HC->HcFmInterval.ul, DeviceData->OriginalInterval.ul);
        reg = READ_REGISTER_ULONG(&HC->HcFmInterval.ul);

        OpenHCI_KdPrint((2, "'fi reg = %x\n", reg));

    } while (reg != DeviceData->OriginalInterval.ul);

    OpenHCI_KdPrint((2, "'fi = %x\n", DeviceData->OriginalInterval.ul));

    OpenHCI_GetRegFlags(DeviceObject,
                        &sofModifyValue);

    //
    // Set the HcPeriodicStart register to 90% of the FrameInterval
    //
    WRITE_REGISTER_ULONG(&HC->HcPeriodicStart,
                         (DeviceData->OriginalInterval.FrameInterval * 9 + 5)
                         / 10);

    descA.ul = READ_REGISTER_ULONG(&HC->HcRhDescriptorA.ul);
    DeviceData->NumberOfPorts = (UCHAR) descA.NumberDownstreamPorts;

    // Maximum number of ports supported by the OpenHCI specification is 15
    //
    ASSERT(DeviceData->NumberOfPorts);
    ASSERT(DeviceData->NumberOfPorts <= 15);

    //
    // Enable some interrupts, but don't hit the master enable yet, wait
    // until the interrupt is connected.
    //


    WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                         HcInt_OwnershipChange |
                         HcInt_SchedulingOverrun |
                         HcInt_WritebackDoneHead |
                         HcInt_FrameNumberOverflow |
                         HcInt_ResumeDetected |
                         HcInt_UnrecoverableError);

    //
    // Tell the HC where the HCCA is, we know that OpenHCI_InitializeSchedule
    // has
    // just run and that the only entry in the PageList begins with the HCCA
    // so we just pick it up and use it without any checks.
    //
    WRITE_REGISTER_ULONG(&HC->HcHCCA, DeviceData->PageList->PhysAddr.LowPart);

    // **
    //
    // Due to a problem with the CMD controller we need to ensure that an ED
    // list always points to a valid ED so we will insert a dummy ED on each
    // list here.
    //
    //
    // Reserve the two dummy EDs+TDs
    //
    OpenHCI_ReserveDescriptors(DeviceData, 4);
    //
    // Insert the two dummy EDs+TDs
    //
    InsertEDForEndpoint(DeviceData, NULL, ED_CONTROL, NULL);
    InsertEDForEndpoint(DeviceData, NULL, ED_BULK, NULL);

// Bulk and control Lists initialized with DUMMY ED
    {
//    WRITE_REGISTER_ULONG(&HC->HcControlHeadED, 0);
    WRITE_REGISTER_ULONG(&HC->HcControlCurrentED, 0);
//    WRITE_REGISTER_ULONG(&HC->HcBulkHeadED, 0);
    WRITE_REGISTER_ULONG(&HC->HcBulkCurrentED, 0);
    }

/**/
    if (DeviceData->HcFlags & HC_FLAG_USE_HYDRA_HACK) {
        ULONG len;

        OpenHCI_KdPrint((1, "'Initialize Hs/Ls fix\n"));
        OpenHCI_InsertMagicEDs(DeviceObject);

        len = PENDING_TD_LIST_SIZE * sizeof(PVOID);

        DeviceData->LastHccaDoneHead = 0;
    }
/**/

    //
    // Wait USB specified time for reset signaling.
    //

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
                 ("'exit OpenHCI_InitializeHardware -- (STATUS_SUCCESS)\n"));

    return STATUS_SUCCESS;
}


BOOLEAN
OpenHCI_IdleController(
    IN PVOID Context
    )
/*++

Routine Description:

   Starts the USB host controller executing the schedule.
   Start Controller is called in by KeSynchronizeExecution.

Arguments:

   Context - DeviceData for this USB controller.

Return Value:

   TRUE

--*/
{
#define DeviceData   ((PHCD_DEVICE_DATA) Context)
    PHC_OPERATIONAL_REGISTER HC;

    OpenHCI_KdPrint((1, "'HC-->suspend state\n"));

    HC = DeviceData->HC;

    //
    // put the controller in 'suspend'
    //

#if DBG
    // double check that the ports are idle
    OHCI_ASSERT(OpenHCI_RhPortsIdle(DeviceData));
#endif

    // disable some interrupts while idle
//    WRITE_REGISTER_ULONG(&HC->HcInterruptDisable,
//                         HcInt_StartOfFrame |
//                         HcInt_OwnershipChange |
//                         HcInt_SchedulingOverrun |
//                         HcInt_WritebackDoneHead |
//                         HcInt_FrameNumberOverflow |
//                         HcInt_UnrecoverableError);

    DeviceData->CurrentHcControl.ul &= ~(HcCtrl_HCFS_MASK);
    DeviceData->CurrentHcControl.ul |= HcCtrl_HCFS_USBSuspend;
    if (DeviceData->HcFlags & HC_FLAG_REMOTE_WAKEUP_CONNECTED) {
        DeviceData->CurrentHcControl.ul |=
            (HcCtrl_RemoteWakeupConnected | HcCtrl_RemoteWakeupEnable);
        OpenHCI_KdPrint((1, "'enable control reg for wakeup\n"));
    }

    WRITE_REGISTER_ULONG(&HC->HcControl.ul, DeviceData->CurrentHcControl.ul);

    //
    // we are already in a KeSynch routine, so these last two accesses to
    // CurrentHcControl need no additional deadlocks (I mean protection).
    //

    // do a global power on for all ports, if the root hub is switched
    // this command should have no effect

    return TRUE;
}


BOOLEAN
OpenHCI_StartController(
    IN PVOID Context
    )
/*++

Routine Description:

   Starts the USB host controller executing the schedule.
   Start Controller is called in by KeSynchronizeExecution.

Arguments:

   Context - DeviceData for this USB controller.

Return Value:

   TRUE

--*/
{
#define DeviceData   ((PHCD_DEVICE_DATA) Context)
    PHC_OPERATIONAL_REGISTER HC;

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE, ("'enter OHCI_StartContr \n"));

    HC = DeviceData->HC;

    //
    // Start the controller schedule
    //

    // When the HC is in the operational state, HccaPad1 should be set to
    // zero every time the HC updates HccaFrameNumer.  Preset HccaPad1 to zero
    // before entering the operational state.  OpenHCI_DeadmanDPC() should
    // always find a zero value in HccaPad1 when the HC is in the operational
    // state.
    // 
    DeviceData->HCCA->HccaPad1 = 0;

    DeviceData->CurrentHcControl.ul &= ~(HcCtrl_HCFS_MASK);
    DeviceData->CurrentHcControl.ul |= HcCtrl_HCFS_USBOperational;
    if (DeviceData->HcFlags & HC_FLAG_REMOTE_WAKEUP_CONNECTED) {
        DeviceData->CurrentHcControl.ul |=
            (HcCtrl_RemoteWakeupConnected | HcCtrl_RemoteWakeupEnable);
        OpenHCI_KdPrint((1, "'enable control reg for wakeup\n"));
    }
    DeviceData->ListEnablesAtNextSOF.ul =
          HcCtrl_PeriodicListEnable
        | HcCtrl_ControlListEnable
        | HcCtrl_BulkListEnable
        | HcCtrl_IsochronousEnable;

    WRITE_REGISTER_ULONG(&HC->HcControl.ul, DeviceData->CurrentHcControl.ul);

    //
    // we are already in a KeSynch routine, so these last two accesses to
    // CurrentHcControl need no additional deadlocks (I mean protection).
    //

    // do a global power on for all ports, if the root hub is switched
    // this command should have no effect

    WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                         HcInt_StartOfFrame |
                         HcInt_OwnershipChange |
                         HcInt_SchedulingOverrun |
                         HcInt_WritebackDoneHead |
                         HcInt_FrameNumberOverflow |
                         HcInt_ResumeDetected |
                         HcInt_UnrecoverableError);

#if DBG
    {
    ULONG reg;
    reg = READ_REGISTER_ULONG(&HC->HcRhStatus);
    OpenHCI_KdPrint((1, "rhStatus reg = %x\n", reg));
    if (reg & HcRhS_DeviceRemoteWakeupEnable) {
        OpenHCI_KdPrint((1, "Connect changes are wakeup events\n"));
    }
    }
#endif

    WRITE_REGISTER_ULONG(&HC->HcRhStatus, HcRhS_SetGlobalPower |
                                          HcRhS_SetRemoteWakeupEnable);

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE, ("'exit OHCI_StartContr \n"));

    return TRUE;
#undef DeviceData
}


NTSTATUS
OpenHCI_Suspend(
    PDEVICE_OBJECT Device
    )
/*++
    jd
 Routine Description:

    Put the HC in the global suspeneded state as a result of a
    D1 message to the root hub PDO, the hub driver has already
    suspended or powered off the ports if necessary.

    This function saves whatever state is necessary to recover
    from the off state as well

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KeSynch_HcControl context;
    PHCD_DEVICE_DATA deviceData;
    PHC_OPERATIONAL_REGISTER HC;
    KIRQL oldIrql;

    deviceData = (PHCD_DEVICE_DATA) ((PDEVICE_OBJECT) Device)->DeviceExtension;
    OpenHCI_KdPrint((1, "'suspending host controller (Root Hub)\n"));
    LOGENTRY(G, 'HsuI', deviceData, 0, 0);

    KeAcquireSpinLock(&deviceData->HcFlagSpin, &oldIrql);
    deviceData->HcFlags |= HC_FLAG_DISABLE_IDLE_CHECK;
    // ounce we resume we will have to re-enter idle mode
    deviceData->HcFlags &= ~HC_FLAG_IDLE;
    KeReleaseSpinLock(&deviceData->HcFlagSpin, oldIrql);

    HC = deviceData->HC;
    OpenHCI_KdPrint((2, "'Enter Suspend HC:%x\n", HC));

    //
    // Disable the enpoint lists.
    //
    context.NewHcControl.ul = (ULONG) ~ (HcCtrl_PeriodicListEnable |
                                         HcCtrl_IsochronousEnable |
                                         HcCtrl_ControlListEnable |
                                         HcCtrl_BulkListEnable);

    context.DeviceData = deviceData;

    KeSynchronizeExecution(deviceData->InterruptObject,
                           OpenHCI_HcControl_AND,
                           &context);

    OHCI_WAIT(5);

    // is it only necessary to enter the suspend state to detect remote
    // wakeup requests?

    context.NewHcControl.ul = HcCtrl_HCFS_USBSuspend;
    context.DeviceData = deviceData;
    KeSynchronizeExecution(deviceData->InterruptObject,
                           OpenHCI_HcControl_SetHCFS,
                           &context);

    OpenHCI_KdPrint((2, "'Exit and Suspended\n"));

    return ntStatus;
}


NTSTATUS
OpenHCI_Resume(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN LostPower
    )
/*++
    Put the device in the working state.

    This function is called when the root hub is transitioned
    to the working state

    NOTE:
    We must stay in suspend for at least 5 miliseconds.
    We must stay in resume (once we go to resume) for at least 20 ms.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHCD_DEVICE_DATA DeviceData;
    PHC_OPERATIONAL_REGISTER HC;
    ULONG i;
    KIRQL oldIrql;

    DeviceData = (PHCD_DEVICE_DATA) ((PDEVICE_OBJECT) DeviceObject)->DeviceExtension;
    HC = DeviceData->HC;

    OpenHCI_KdPrint((2, "'Enter Resume HC:%x\n", HC));

    // be sure th controller stays in suspend for at leaset 5 ms
    // time is in units of 100-nanoseconds.  Neg vals are relative time.
    OHCI_WAIT(5);

    // resume signalling is driven by the hub driver
    // so we will just reset here

    //
    // Start the resume signalling to all down stream ports;
    //
//    context.NewHcControl.ul = HcCtrl_HCFS_USBResume;
//    context.DeviceData = DeviceData;
//    KeSynchronizeExecution(DeviceData->InterruptObject,
//                           OpenHCI_HcControl_SetHCFS,
//                           &context);

    if (READ_REGISTER_ULONG(&HC->HcRevision.ul) == 0xFFFFFFFF)
    {
        OpenHCI_KdPrint((0, "'Resume HC, controller not there!\n"));

        // The return value of OpenHCI_Resume() is propagated back
        // up to USBHUB, but if we we don't return success here,
        // USBH_PowerIrpCompletion() won't handle it correctly,
        // causing a hang.
        //
        // Just return success for now until USBHUB can handle an error
        // being propagate back up.
        //
        return STATUS_SUCCESS;
    }

    //
    // start the controller
    //

    if (!KeSynchronizeExecution(DeviceData->InterruptObject,
                                OpenHCI_StartController,
                                DeviceData)) {
        TRAP(); //something has gone terribly wrong
    }

    //
    // Fire up the HC
    //
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_NOISE, ("'Set Master Int Enable.\n"));
    WRITE_REGISTER_ULONG(&DeviceData->HC->HcInterruptEnable, HcInt_MasterInterruptEnable);
    WRITE_REGISTER_ULONG(&DeviceData->HC->HcInterruptStatus, HcInt_StartOfFrame);
    WRITE_REGISTER_ULONG(&DeviceData->HC->HcInterruptEnable, HcInt_StartOfFrame);

    if (LostPower) {
        // if power was lost we need to turn the ports back on
        for (i = 0; i < DeviceData->NumberOfPorts; i++) {
            WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[i], HcRhPS_SetPortPower);
        }
    }

    // enable idle checking
    KeAcquireSpinLock(&DeviceData->HcFlagSpin, &oldIrql);
    DeviceData->HcFlags &= ~HC_FLAG_DISABLE_IDLE_CHECK;
    KeReleaseSpinLock(&DeviceData->HcFlagSpin, oldIrql);

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_PNP_TRACE, ("'Exit Resume\n"));

    return ntStatus;
}


NTSTATUS
OpenHCI_SaveHCstate(
    PHCD_DEVICE_DATA DeviceData
    )
/*++
    Save the the HC state in case we lose power

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHC_OPERATIONAL_REGISTER HC;

    OpenHCI_KdPrint((1, "'Save HC state\n"));
    LOGENTRY(G, 'SAVs', 0, 0, 0);

    HC = DeviceData->HC;
    DeviceData->BulkSav = READ_REGISTER_ULONG(&HC->HcBulkHeadED);
    DeviceData->ControlSav = READ_REGISTER_ULONG(&HC->HcControlHeadED);
    DeviceData->HcHCCASav = READ_REGISTER_ULONG(&HC->HcHCCA);


    return ntStatus;
}


NTSTATUS
OpenHCI_RestoreHCstate(
    PHCD_DEVICE_DATA DeviceData,
    PBOOLEAN LostPower
    )
/*++

    Restore the HC state in case we lost power

--*/
{
    PHC_OPERATIONAL_REGISTER HC;
    ULONG       hcca;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    ULONG       i;
    ULONG       ulRegVal; 


    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
       ("'enter OpenHCI_RestoreHardware\n"));

    *LostPower = FALSE;
    HC = DeviceData->HC;
    DeviceData->FrameHighPart = 0;
    LOGENTRY(G, 'RESs', 0, 0, 0);

    if (READ_REGISTER_ULONG(&HC->HcRevision.ul) == 0xFFFFFFFF)
    {
        OpenHCI_KdPrint((0, "'Restore HC state, controller not there!\n"));

        // Nothing currently checks the return value of OpenHCI_RestoreHCstate()
        // Just return success for now.
        //
        return STATUS_SUCCESS;
    }

    hcca = READ_REGISTER_ULONG(&HC->HcHCCA);
    if (hcca == DeviceData->HcHCCASav &&
        !(DeviceData->HcFlags & HC_FLAG_LOST_POWER)) {
        return STATUS_SUCCESS;
    }

    DeviceData->HcFlags &= ~HC_FLAG_LOST_POWER;

    *LostPower = TRUE;
    OpenHCI_KdPrint((1, "'Restore HC state\n"));

    //
    // Stop the legacy BIOS if it is active
    //
    ntStatus = OpenHCI_StopBIOS(DeviceData->DeviceObject);

    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    //
    // Disable/clear all interrupts in case a legacy BIOS left some enabled.
    //
    WRITE_REGISTER_ULONG(&HC->HcInterruptDisable, 0xFFFFFFFF);

    //
    // Take the host controller to the UsbSuspend state
    //
    WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, HcCmd_HostControllerReset);
    KeStallExecutionProcessor(10);

    //
    // Take the host controller to the UsbReset state
    //
    WRITE_REGISTER_ULONG(&HC->HcControl.ul, 0);

    //
    // Restore original frame interval.  There is something funky about
    // this register.  Sometimes writing a value to it does not always
    // take.  If it doesn't take and FSLargestDataPacket ends up being
    // zero, no transfers will work and SchedulingOverrun will occur.
    //
    for (i = 0; i < 10; i++)
    {
        WRITE_REGISTER_ULONG(&HC->HcFmInterval.ul,
                             DeviceData->OriginalInterval.ul);

        ulRegVal = READ_REGISTER_ULONG(&HC->HcFmInterval.ul);

        if (ulRegVal == DeviceData->OriginalInterval.ul)
        {
            break;
        }

        KeStallExecutionProcessor(5);
    }

    LOGENTRY(G, 'HcFm', ulRegVal, DeviceData->OriginalInterval.ul, i);

    //
    // Set the HcPeriodicStart register to 90% of the FrameInterval
    //
    WRITE_REGISTER_ULONG(&HC->HcPeriodicStart,
                         (DeviceData->OriginalInterval.FrameInterval * 9 + 5)
                         / 10);


    //
    // Enable some interrupts, but don't hit the master enable yet, wait
    // until the interrupt is connected.
    //


    WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                         HcInt_OwnershipChange |
                         HcInt_SchedulingOverrun |
                         HcInt_WritebackDoneHead |
                         HcInt_FrameNumberOverflow |
                         HcInt_ResumeDetected |
                         HcInt_UnrecoverableError);

    //
    // Tell the HC where the HCCA is, we know that OpenHCI_InitializeSchedule
    // has
    // just run and that the only entry in the PageList begins with the HCCA
    // so we just pick it up and use it without any checks.
    //
    //WRITE_REGISTER_ULONG(&HC->HcHCCA, DeviceData->PageList->PhysAddr.LowPart);
    WRITE_REGISTER_ULONG(&HC->HcHCCA, DeviceData->HcHCCASav);

    // **
    //
    // Due to a problem with the CMD controller we need to ensure that an ED
    // list always points to a valid ED so we will insert a dummy ED on each
    // list here.
    //

    //InsertEDForEndpoint(DeviceData, NULL, ED_CONTROL);
    //InsertEDForEndpoint(DeviceData, NULL, ED_BULK);
    WRITE_REGISTER_ULONG(&HC->HcControlHeadED, DeviceData->ControlSav);
    WRITE_REGISTER_ULONG(&HC->HcBulkHeadED, DeviceData->BulkSav);

// Bulk and control Lists initialized with DUMMY ED
    {
//    WRITE_REGISTER_ULONG(&HC->HcControlHeadED, 0);
    WRITE_REGISTER_ULONG(&HC->HcControlCurrentED, 0);
//    WRITE_REGISTER_ULONG(&HC->HcBulkHeadED, 0);
    WRITE_REGISTER_ULONG(&HC->HcBulkCurrentED, 0);
    }

    //
    // Wait USB specified time for reset signaling.
    //

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
                 ("'exit OpenHCI_RestoreHardware -- (STATUS_SUCCESS)\n"));

    return STATUS_SUCCESS;
}


NTSTATUS
OpenHCI_SetDevicePowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE DeviceState
    )
/*++
Routine Description:

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    DeviceState - Device specific power state to set the device in to.

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHCD_DEVICE_DATA deviceData;
    BOOLEAN hookIt = FALSE;
    PIO_STACK_LOCATION irpStack;
    PHC_OPERATIONAL_REGISTER HC;
    PUSBD_EXTENSION usbdExtension;
    PDEVICE_CAPABILITIES hcDeviceCapabilities;
    BOOLEAN bIsSuspend;

    deviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    HC = deviceData->HC;

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    if (irpStack->Parameters.Power.Type ==
            SystemPowerState) {

        switch (irpStack->Parameters.Power.State.SystemState) {
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:

            // suspend coming thru
            OpenHCI_KdPrint((1, "'Shutdown (Suspend) Host Controller\n"));
            deviceData->HcFlags |= HC_FLAG_SUSPEND_NEXT_D3;

            ntStatus = STATUS_SUCCESS;
            break;

        case PowerSystemShutdown:

            //
            // this is a shutdown request
            //

            OpenHCI_KdPrint((1, "'Shutdown Host Controller\n"));

            ntStatus = OpenHCI_Shutdown(DeviceObject);
            break;

        default:
            // should not get here
            TRAP();
            break;
        }

    } else {
        bIsSuspend = (deviceData->HcFlags & HC_FLAG_SUSPEND_NEXT_D3) ? 1:0;
        deviceData->HcFlags &= ~HC_FLAG_SUSPEND_NEXT_D3;

        switch (DeviceState) {
        case PowerDeviceD3:
            //
            // Request for HC to power off
            //

            // save HC state if the Root hub is disabled
            if (deviceData->RootHubControl == NULL)
            {
                KeCancelTimer(&deviceData->DeadmanTimer);

                OpenHCI_SaveHCstate(deviceData);
            }

            LOGENTRY(G, 'Coff', deviceData, 0, 0);

            // In the NT power management model, D3 is not necessarily "OFF".
            // What governs this is the DeviceWake setting in the DeviceCaps
            // structure.  If DeviceWake for our controller device is D3, then
            // we know that it is possible for the controller to wake the
            // machine from this power level.  The controller must have power
            // to be able to do so, therefore, we suppress setting the
            // HCFLAG_LOST_POWER flag in this case.  Setting it actually has
            // the undesired effect of causing us to reset the controller on
            // resume, which in turn causes the hub to fail and the devices to
            // be surprise removed/reenumerated unnecessarily when the hub is
            // reinitialized.  This normally isn't more than a minor annoyance
            // (e.g. slow resume time), except in the case where one of these
            // devices is a USB mass storage device.  Surprise removal is
            // dangerous for mass storage devices, and the user is presented
            // with the annoying "don't surprise remove this device" dialog
            // when the system is resumed, even though the user himself did not
            // directly cause the device removal.
            //
            // Note that the case where the host controller really does lose
            // power could result in the same problem, but that will have to
            // be addressed in the hub driver.

            usbdExtension = DeviceObject->DeviceExtension;
            hcDeviceCapabilities = &usbdExtension->HcDeviceCapabilities;
            if (!bIsSuspend ||
                DeviceState > hcDeviceCapabilities->DeviceWake) {
                deviceData->HcFlags |= HC_FLAG_LOST_POWER;
            }

            // disable interrupts
            WRITE_REGISTER_ULONG(&HC->HcInterruptDisable, 0xFFFFFFFF);
            deviceData->CurrentDevicePowerState = DeviceState;

            OpenHCI_KdPrint((1, "'Host Controller entered (D3)\n"));
            // pass on to PDO
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
            //
            // power states D1,D2 translate to USB suspend
            //
            // Note, we should not get here unless all the children of the HC
            // have been suspended.
            //
            LOGENTRY(G, 'CD12', deviceData, 0, 0);

            // disable interrupts
            WRITE_REGISTER_ULONG(&HC->HcInterruptDisable, 0xFFFFFFFF);
            deviceData->CurrentDevicePowerState = DeviceState;
#ifdef WIN98
            // this is necessary to make remote wakeup work
            // on the TECRA 750
            // having interrupts enabled in D1/D2 is not
            // valid (to my knowlege) on Win2k
            WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                                        HcInt_MasterInterruptEnable |
                                        HcInt_ResumeDetected);
#endif

            OpenHCI_KdPrint((1, "'Host Controller entered (D%d)\n", DeviceState-1));
            // pass on to PDO
            break;

        case PowerDeviceD0:

            //
            // Request for HC to go to resume
            //

            OpenHCI_KdPrint((2, "'PowerDeviceD0 (ON)\n"));
            LOGENTRY(G, 'CgD0', deviceData, 0, 0);

            //
            // finish the rest in the completion routine
            //

            hookIt = TRUE;

            // pass on to PDO
            break;

        default:

            TRAP(); //Bogus DeviceState;
        }

        if (hookIt) {
            OpenHCI_KdPrintDD(deviceData, OHCI_DBG_CALL_TRACE, ("'Set PowerIrp Completion Routine\n"));
            IoSetCompletionRoutine(Irp,
                   OpenHCI_PowerIrpComplete,
                   // always pass FDO to completion routine
                   DeviceObject,
                   hookIt,
                   hookIt,
                   hookIt);
        }
    }

    return ntStatus;
}



NTSTATUS
OpenHCI_GetRegistryKeyValue(
                            IN PHCD_DEVICE_DATA DeviceData,
                            IN HANDLE Handle,
                            IN PWCHAR KeyNameString,
                            IN ULONG KeyNameStringLength,
                            IN PVOID Data,
                            IN ULONG DataLength
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_NO_MEMORY;
    UNICODE_STRING keyName;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    RtlInitUnicodeString(&keyName, KeyNameString);

    length = sizeof(KEY_VALUE_FULL_INFORMATION) +
        KeyNameStringLength + DataLength;

    fullInfo = ExAllocatePoolWithTag(PagedPool, length,  OpenHCI_TAG);
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
                    (" GetRegistryKeyValue buffer = 0x%x\n", fullInfo));

    if (fullInfo) {
        ntStatus = ZwQueryValueKey(Handle,
                                   &keyName,
                                   KeyValueFullInformation,
                                   fullInfo,
                                   length,
                                   &length);

        if (NT_SUCCESS(ntStatus)) {
            ASSERT(DataLength == fullInfo->DataLength);
            RtlCopyMemory(Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, DataLength);
        }
        ExFreePool(fullInfo);
    }
    return ntStatus;
}

NTSTATUS
OpenHCI_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
jd
Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}

NTSTATUS
OpenHCI_DeferPoRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    SetState - TRUE for set, FALSE for query.

    DevicePowerState - The Dx that we are in/tagetted.

    Context - Driver defined context.

    IoStatus - The status of the IRP.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
OpenHCI_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    )

/*++
jd
Routine Description:

    This routine reads or write config space.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    PAGED_CODE();

    RtlZeroMemory(DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = -1;
    DeviceCapabilities->UINumber = -1;

    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!irp) {
        TRAP(); //"failed to allocate Irp
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           OpenHCI_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    ntStatus = IoCallDriver(PdoDeviceObject,
                            irp);

//    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_PNP_TRACE, ("'ntStatus from IoCallDriver to PCI = 0x%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete

       KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

       ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    return ntStatus;
}


NTSTATUS
OpenHCI_RootHubPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
Routine Description:

    This function handles power messages to the root hub, note that
    we save the stae of the HC here instead of when the HC itself is
    powered down.  The reason for this is for compatibility with APM
    systems that cut power to the HC during a suspend.  On these
    systems WDM never sends a power state change mesage to the HC ie
    the HC is assumed to always stay on.

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHCD_DEVICE_DATA deviceData;
    BOOLEAN lostPower;

    OpenHCI_KdPrint((2, "'OpenHCI_RootHubPower\n"));

    deviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    switch (irpStack->MinorFunction) {
    case IRP_MN_WAIT_WAKE:
        OpenHCI_KdPrintDD(deviceData, OHCI_DBG_SS_TRACE, ("'IRP_MN_WAIT_WAKE\n"));
        //
        // someone is enabling us for wakeup
        //
        TEST_TRAP();  // never seen this before?
        break;

    case IRP_MN_SET_POWER:

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
            // should not get here
            TRAP(); //(("RootHubPower -- SystemState\n"));
            break;

        case DevicePowerState:

            switch(irpStack->Parameters.Power.State.DeviceState) {
            case PowerDeviceD0:
#ifdef JD
                TEST_TRAP();
#endif
                OpenHCI_RestoreHCstate(deviceData, &lostPower);

                ntStatus = OpenHCI_Resume(DeviceObject, lostPower);

                KeSetTimerEx(&deviceData->DeadmanTimer,
                             RtlConvertLongToLargeInteger(-10000),
                             10,
                             &deviceData->DeadmanTimerDPC);

                break;

            case PowerDeviceD1:
            case PowerDeviceD3:
            case PowerDeviceD2:

                KeCancelTimer(&deviceData->DeadmanTimer);

                OpenHCI_SaveHCstate(deviceData);

                ntStatus = OpenHCI_Suspend(DeviceObject);

                break;
            }
            break;
        }
    }

    return ntStatus;
}


NTSTATUS
OpenHCI_StartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN POHCI_RESOURCES Resources
    )
/*++
Routine Description:

   This routine initializes the DeviceObject for a given instance
   of a USB host controller.

Arguments:

   DeviceObject        - DeviceObject for this USB controller.

   PartialResourceList - Resources for this controller.

Return Value:

   NT status code.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHCD_DEVICE_DATA DeviceData;
    DEVICE_CAPABILITIES deviceCapabilities;

    DeviceData = DeviceObject->DeviceExtension;

    LOGENTRY(G, 'STRc', DeviceData, Resources, 0);

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
        ("'e: OpenHCI_StartDevice\n"));

    if (DeviceData->HcFlags & HC_FLAG_DEVICE_STARTED) {
        OpenHCI_KdPrintDD(DeviceData,
            OHCI_DBG_SS_INFO, ("'already started !!\n"));
        return STATUS_SUCCESS;
    }

#if 0
    // get the device & vendor id
    {
        UCHAR revisionId;
        USHORT vendorId, deviceId;

        OpenHCI_KdPrint((2, "'Get the version\n"));

        OpenHCI_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                             TRUE,
                             &vendorId,
                             0,
                             sizeof(vendorId));

        OpenHCI_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                             TRUE,
                             &deviceId,
                             2,
                             sizeof(deviceId));

        OpenHCI_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                             TRUE,
                             &revisionId,
                             8,
                             sizeof(revisionId));

        OpenHCI_KdPrint((1, "'vendor = (%x) device = (%x) rev = (%x)\n",
                vendorId, deviceId, revisionId));


    }
#endif
    //
    // We found a host controller or a host controller found us, do the final
    // stages of initilalization.
    // Setup state variables for the host controller
    //

    ntStatus = OpenHCI_InitializeSchedule(DeviceObject);

    if (!NT_SUCCESS(ntStatus)) {
        goto OpenHCI_InitializeDeviceExit;
    }

    //
    // Initialize the controller registers
    //

    ntStatus = OpenHCI_InitializeHardware(DeviceObject);

    if (!NT_SUCCESS(ntStatus)) {
        goto OpenHCI_InitializeDeviceExit;
    }

    // During a STOP_DEVICE / START_DEVICE rebalance cycle, it is possible
    // for an endpoint to be left on the StalledEDReclamation list and not
    // be removed by OpenHCI_IsrDPC() before the STOP_DEVICE completes.  Make
    // sure START_DEVICE restarts with an empty StalledEDReclamation list.
    // Note that no resources are leaked if we just throw away anything
    // that might be left on the StalledEDReclamation list since all of the
    // common buffer pages containing EDs are freed during STOP_DEVICE
    // regardless of whether or not OpenHCI_Free_HcdED() is called for
    // all EDs.
    //
    InitializeListHead(&DeviceData->StalledEDReclamation);


    //
    // initialization all done, last step is to connect the interrupt & DPCs.
    //

    KeInitializeDpc(&DeviceData->IsrDPC,
                    OpenHCI_IsrDPC,
                    DeviceObject);

    //
    // our initial state is 'ON'
    //

    DeviceData->CurrentDevicePowerState = PowerDeviceD0;

    //
    // Initialize and connect the interrupt object for the controller.
    //


    ntStatus = IoConnectInterrupt(&(DeviceData->InterruptObject),
                                  (PKSERVICE_ROUTINE) OpenHCI_InterruptService,
                                  (PVOID) DeviceObject,
                                  &DeviceData->InterruptSpin,
                                  Resources->InterruptVector,
                                  Resources->InterruptLevel,
                                  Resources->InterruptLevel,
                                  Resources->InterruptMode,
                                  Resources->ShareIRQ,
                                  Resources->Affinity,
                                  FALSE);

    if (!NT_SUCCESS(ntStatus)) {
        goto OpenHCI_InitializeDeviceExit;
    }

    //
    // get our capabilities
    //
    ntStatus = OpenHCI_QueryCapabilities(DeviceData->TopOfStackPhysicalDeviceObject,
                                         &deviceCapabilities);

    if (!NT_SUCCESS(ntStatus)) {
        goto OpenHCI_InitializeDeviceExit;
    }
#if DBG
    {
        ULONG i;
        OpenHCI_KdPrint((1, "'HCD Device Caps returned from PCI:\n"));
        OpenHCI_KdPrint((1, "'\tSystemWake = S%d\n", deviceCapabilities.SystemWake-1));
        OpenHCI_KdPrint((1, "'\tDeviceWake = D%d\n", deviceCapabilities.DeviceWake-1));
        OpenHCI_KdPrint((1, "'\tDevice State Map:\n"));

        for (i=0; i< PowerSystemHibernate; i++) {
             OpenHCI_KdPrint((1, "'\t-->S%d = D%d\n", i-1,
                 deviceCapabilities.DeviceState[i]-1));
        }
    }
#endif

    USBD_RegisterHcDeviceCapabilities(DeviceObject,
                                      &deviceCapabilities,
                                      OpenHCI_RootHubPower);

    if (!NT_SUCCESS(ntStatus)) {
        goto OpenHCI_InitializeDeviceExit;
    }

    //
    // **
    // SUCCESS!!
    // **
    //

    // init the idle counter
    KeQuerySystemTime(&DeviceData->LastIdleTime);
    DeviceData->IdleTime = 100000000;

    OHCI_WAIT(10);

    if (!KeSynchronizeExecution(DeviceData->InterruptObject,
                                OpenHCI_StartController,
                                DeviceData)) {
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    OHCI_WAIT(10);

    WRITE_REGISTER_ULONG(&DeviceData->HC->HcInterruptStatus, HcInt_StartOfFrame);
    WRITE_REGISTER_ULONG(&DeviceData->HC->HcInterruptEnable, HcInt_StartOfFrame);
    WRITE_REGISTER_ULONG(&DeviceData->HC->HcInterruptEnable, HcInt_ResumeDetected);
    WRITE_REGISTER_ULONG(&DeviceData->HC->HcInterruptEnable, HcInt_MasterInterruptEnable);

    // For debugging only.
    // WRITE_REGISTER_ULONG(&DeviceData->HC->HcRhPortStatus[0],
    // HcRhPS_SetPortEnable);
    // WRITE_REGISTER_ULONG(&DeviceData->HC->HcRhPortStatus[1],
    // HcRhPS_SetPortEnable);

     if (NT_SUCCESS(ntStatus)) {
        // enable idle checking
        DeviceData->HcFlags &= ~HC_FLAG_DISABLE_IDLE_CHECK;
     }

#if DBG
     if (!(DeviceData->HcFlags & HC_FLAG_REMOTE_WAKEUP_CONNECTED)) {
        // this controller probably won't do idle properly
        OpenHCI_KdPrint((1, "'This Controller won't support idle\n"));
     }
#endif

OpenHCI_InitializeDeviceExit:

    DeviceData->HcFlags |= HC_FLAG_DEVICE_STARTED;

    if (!NT_SUCCESS(ntStatus))
    {
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE, ("'Init Failed \n"));

        //
        // The initialization failed.  Cleanup resources before exiting.
        //
        // Note:  No need/way to undo the KeInitializeDpc or
        // KeInitializeTimer calls.
        //

        OpenHCI_StopDevice(DeviceObject, TRUE);
    }
    else
    {
        // Start our deadman timer
        //
        KeSetTimerEx(&DeviceData->DeadmanTimer,
                     RtlConvertLongToLargeInteger(-10000),
                     10,
                     &DeviceData->DeadmanTimerDPC);

        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
                        ("'Init Passed extension 0x%x\n",
                         sizeof(USBD_EXTENSION)));
    }

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_TRACE,
                    ("'exit StartDevice (%x)\n", ntStatus));

    LOGENTRY(G, 'STRd', DeviceData, 0, ntStatus);

    return ntStatus;
}


NTSTATUS
OpenHCI_GetResources(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PCM_RESOURCE_LIST    ResourceList,
    IN OUT POHCI_RESOURCES  Resources
    )
/*++

Routine Description:

    This routines parses the resources for the controller

Arguments:

   DeviceObject        - DeviceObject for this USB controller.

   PartialResourceList - Resources for this controller.

Return Value:

   NT status code.

--*/

{
    PHCD_DEVICE_DATA                DeviceData;
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       PartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR interrupt;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR memory;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR port;
    ULONG                           i;
    NTSTATUS                        ntStatus = STATUS_SUCCESS;

    DeviceData = DeviceObject->DeviceExtension;

    if (ResourceList == NULL) {
        return STATUS_NONE_MAPPED;
    }

    fullResourceDescriptor = &ResourceList->List[0];
    PartialResourceList    = &fullResourceDescriptor->PartialResourceList;

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_SS_TRACE, ("'e: OpenHCI_GetResources\n"));

    interrupt = NULL;
    memory    = NULL;
    port      = NULL;

    for (i = 0; i < PartialResourceList->Count; i++)
    {
        switch (PartialResourceList->PartialDescriptors[i].Type) {

            case CmResourceTypeInterrupt:
                if (interrupt == NULL)
                {
                    interrupt = &PartialResourceList->PartialDescriptors[i];
                }
                break;

            case CmResourceTypeMemory:
                if (memory == NULL)
                {
                    memory = &PartialResourceList->PartialDescriptors[i];
                }
                break;

            case CmResourceTypePort:
                if (port == NULL)
                {
                    port = &PartialResourceList->PartialDescriptors[i];
                }
                break;
        }
    }

    if (interrupt == NULL)
    {
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_ERROR,
                          ("'Host Controller interrupt resource not found.\n"));

        ntStatus = STATUS_NONE_MAPPED;

        goto OpenHCI_GetResourcesExit;
    }

    if (memory == NULL && port == NULL)
    {
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_ERROR,
                          ("'Host Controller memory/port resource not found.\n"));

        ntStatus = STATUS_NONE_MAPPED;

        goto OpenHCI_GetResourcesExit;
    }

    //
    // Get Vector, level, and affinity information for the interrupt
    //
    OpenHCI_KdPrint((1,
                     "'Interrupt Resources Found!  Level = %x Vector = %x\n",
                     interrupt->u.Interrupt.Level,
                     interrupt->u.Interrupt.Vector
                    ));

    Resources->InterruptVector = interrupt->u.Interrupt.Vector;
    Resources->InterruptLevel  = (KIRQL)interrupt->u.Interrupt.Level;
    Resources->Affinity        = interrupt->u.Interrupt.Affinity,

    Resources->InterruptMode = interrupt->Flags == CM_RESOURCE_INTERRUPT_LATCHED
                               ? Latched
                               : LevelSensitive;

    Resources->ShareIRQ = interrupt->ShareDisposition == CmResourceShareShared
                          ? TRUE
                          : FALSE;

    if (memory != NULL)
    {
        //
        // Set up AddressSpace to be of type Memory mapped I/O
        //
        OpenHCI_KdPrint((1,
                         "'Memory Resources Found @ %x, Length = %x\n",
                         memory->u.Memory.Start.LowPart,
                         memory->u.Memory.Length
                        ));

        DeviceData->HClength    = memory->u.Memory.Length;

        DeviceData->cardAddress = memory->u.Memory.Start;

        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_INFO,
                          ("'Card address 0x%x\n", DeviceData->cardAddress.LowPart));

        DeviceData->HC = MmMapIoSpace(DeviceData->cardAddress,
                                      DeviceData->HClength,
                                      FALSE);

        if (DeviceData->HC == NULL)
        {
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_ERROR,
                              ("'Host Controller memory window not mapped.\n"));

            ntStatus = STATUS_NONE_MAPPED;
        }
    }
    else
    {
        //
        // Set up AddressSpace to be of type Port I/O
        //

        // port resources are equiv to adressSpace 1
        // ie don't call mmMapIoSpace

        OpenHCI_KdPrint((0,
                         "'Port Resources Found @ %x, %d Ports Available\n",
                         port->u.Port.Start.LowPart,
                         port->u.Port.Length
                        ));

        DeviceData->HC       = (PVOID)(ULONG_PTR)port->u.Port.Start.QuadPart;

        DeviceData->HClength = port->u.Port.Length;
    }

    //
    // Check host controller register window length and
    // host controller revision register value.
    //

    if (NT_SUCCESS(ntStatus)) {

        HC_REVISION revision;

        OHCI_ASSERT(DeviceData->HC);
        LOGENTRY(G, 'HCrr', DeviceData, DeviceData->HC, 0);

        if (DeviceData->HClength < sizeof(HC_OPERATIONAL_REGISTER)) {
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_ERROR,
                            ("'Controller memory len short.\n"));
            ntStatus = STATUS_NONE_MAPPED;
            goto OpenHCI_GetResourcesExit;
        }

        revision.ul = READ_REGISTER_ULONG(&DeviceData->HC->HcRevision.ul);
        if (revision.Rev != 0x10) {
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_ERROR,
                       ("'Unknown Rev of OHCI Controller: 0x%02x.\n",
                        revision.Rev));
            ntStatus = STATUS_UNKNOWN_REVISION;
            goto OpenHCI_GetResourcesExit;
        }
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_SS_INFO,
                        ("'Mapped device memory registers to 0x%x.\n",
                         DeviceData->HC));
    }

OpenHCI_GetResourcesExit:

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_SS_INFO,
        ("'OpenHCI_GetResources %x.\n", ntStatus));

    return ntStatus;
}


NTSTATUS
OpenHCI_DeferredStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT Status code.

--*/
{
    NTSTATUS ntStatus;
    OHCI_RESOURCES resources;
    PIO_STACK_LOCATION irpStack;
    PHCD_DEVICE_DATA deviceData;

    PAGED_CODE();

    deviceData = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    ntStatus = OpenHCI_GetResources(DeviceObject,
                                    irpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
                                    &resources);

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = OpenHCI_StartDevice(DeviceObject,
                                       &resources);
    }

//#if PREALLOCATE_DESCRIPTOR_MEMORY
//    if (NT_SUCCESS(ntStatus)) {
//        ULONG k;
//        for (k = 0; k < PREALLOCATE_DESCRIPTOR_MEMORY_NUM_PAGES; k++) {
//            OpenHCI_ReserveDescriptors(deviceData);
//        }
//    }
//#endif

    Irp->IoStatus.Status = ntStatus;

    return ntStatus;
}


NTSTATUS
OpenHCI_GetRegFlags(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG SofModifyValue
    )
/*++

Routine Description:

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT Status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    static WCHAR slowBulkEnableKey[]    = L"SlowBulkEnable";
    static WCHAR hydraHackEnableKey[]   = L"HydraFixEnable";
    static WCHAR idleEnableKey[]        = L"IdleEnable";
    static WCHAR listFixEnableKey[]     = L"ListFixEnable";
    static WCHAR hungCheckEnableKey[]   = L"HungCheckEnable";
    PHCD_DEVICE_DATA deviceData;
    ULONG enable;

    PAGED_CODE();

    deviceData = DeviceObject->DeviceExtension;


    enable = 0;
    ntStatus = USBD_GetPdoRegistryParameter(deviceData->RealPhysicalDeviceObject,
                                            &enable,
                                            sizeof(enable),
                                            slowBulkEnableKey,
                                            sizeof(slowBulkEnableKey));

    if (NT_SUCCESS(ntStatus) && enable) {
        deviceData->HcFlags |= HC_FLAG_SLOW_BULK_ENABLE;
        OpenHCI_KdPrint((1, "'Slow bulk enabled for HC\n"));
    }

    //
    // check for HYDRA
    //

    enable = 0;
    ntStatus = USBD_GetPdoRegistryParameter(deviceData->RealPhysicalDeviceObject,
                                            &enable,
                                            sizeof(enable),
                                            hydraHackEnableKey,
                                            sizeof(hydraHackEnableKey));

    if (NT_SUCCESS(ntStatus) && enable) {
        deviceData->HcFlags |= HC_FLAG_USE_HYDRA_HACK;
        OpenHCI_KdPrint((1, "'Hydra fixes enabled for HC\n"));
    }

    //
    // check for Idle support
    //

    enable = 0;
    ntStatus = USBD_GetPdoRegistryParameter(deviceData->RealPhysicalDeviceObject,
                                            &enable,
                                            sizeof(enable),
                                            idleEnableKey,
                                            sizeof(idleEnableKey));

    // default is no idle mode
    deviceData->HcFlags |= HC_FLAG_DISABLE_IDLE_MODE;
    if (NT_SUCCESS(ntStatus) && enable) {
        deviceData->HcFlags &= ~HC_FLAG_DISABLE_IDLE_MODE;
        OpenHCI_KdPrint((1, "'Enable idle mode for HC\n"));
    }


    //
    // check for BulkListFilled / ControllListFilled hack
    //

    enable = 0;
    ntStatus = USBD_GetPdoRegistryParameter(deviceData->RealPhysicalDeviceObject,
                                            &enable,
                                            sizeof(enable),
                                            listFixEnableKey,
                                            sizeof(listFixEnableKey));

    if (NT_SUCCESS(ntStatus) && enable) {
        deviceData->HcFlags |= HC_FLAG_LIST_FIX_ENABLE;
        OpenHCI_KdPrint((1, "'BLF/CLF fixes enabled for HC\n"));
    }

    //
    // check for Hung Host Controller Check enable
    //

    enable = 0;
    ntStatus = USBD_GetPdoRegistryParameter(deviceData->RealPhysicalDeviceObject,
                                            &enable,
                                            sizeof(enable),
                                            hungCheckEnableKey,
                                            sizeof(hungCheckEnableKey));

    if (NT_SUCCESS(ntStatus) && enable) {
        deviceData->HcFlags |= HC_FLAG_HUNG_CHECK_ENABLE;
        OpenHCI_KdPrint((1, "'Hung check enabled for HC\n"));
    }

    return ntStatus;
}


NTSTATUS
OpenHCI_GetSOFRegModifyValue(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG SofModifyValue
    )
/*++

Routine Description:

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT Status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    WCHAR clocksPerFrameKey[] = L"timingClocksPerFrame";
    WCHAR recClocksPerFrameKey[] = L"recommendedClocksPerFrame";
    LONG recClocksPerFrame = 0;
    PHCD_DEVICE_DATA deviceData;

    PAGED_CODE();

    deviceData = DeviceObject->DeviceExtension;

    //ntStatus = USBD_GetPdoRegistryParameter(deviceExtension->PhysicalDeviceObject,
    //                             &clocksPerFrame,
    //                             sizeof(clocksPerFrame),
    //                             clocksPerFrameKey,
    //                             sizeof(clocksPerFrameKey));

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBD_GetPdoRegistryParameter(deviceData->RealPhysicalDeviceObject,
                                     &recClocksPerFrame,
                                     sizeof(recClocksPerFrame),
                                     recClocksPerFrameKey,
                                     sizeof(recClocksPerFrameKey));
    }

    if (NT_SUCCESS(ntStatus) && recClocksPerFrame) {
        *SofModifyValue = recClocksPerFrame;
    }

    OpenHCI_KdPrint((1,
        "'Recommended Clocks/Frame %d sofModify = %d\n", recClocksPerFrame,
            *SofModifyValue));

    return ntStatus;
}

VOID
OpenHCI_ReadWriteConfig(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  BOOLEAN Read,
    IN  PVOID Buffer,
    IN  ULONG Offset,
    IN  ULONG Length
)

/*++

Routine Description:

    This routine reads or write config space.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

    Read                - TRUE if read, FALSE if write.

    Buffer              - The info to read or write.

    Offset              - The offset in config space to read or write.

    Length              - The length to transfer.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;
    PHCD_DEVICE_DATA deviceData;

    PAGED_CODE();

    deviceData = DeviceObject->DeviceExtension;

    if (Read) {
        memset(Buffer, '\0', Length);
    }

    irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (!irp) {
        OpenHCI_KdTrap(("'failed to allocate Irp\n"));
        return;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           OpenHCI_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);


    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= Read ? IRP_MN_READ_CONFIG : IRP_MN_WRITE_CONFIG;
    nextStack->Parameters.ReadWriteConfig.Buffer = Buffer;
    nextStack->Parameters.ReadWriteConfig.Buffer = Buffer;
    nextStack->Parameters.ReadWriteConfig.Offset = Offset;
    nextStack->Parameters.ReadWriteConfig.Length = Length;

    ntStatus = IoCallDriver(DeviceObject,
                            irp);

    OpenHCI_KdPrint((2, "'ntStatus from IoCallDriver to PCI = 0x%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete

       TEST_TRAP(); // first time we hit this

       KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
    }

    if (!NT_SUCCESS(ntStatus)) {
        // failed? this is probably a bug
        OpenHCI_KdTrap(("ReadWriteConfig failed, why?\n"));
    }

    IoFreeIrp(irp);
}


VOID
OpenHCI_FixLists(
    PHCD_DEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER HC;
    ULONG Temp, Temp0, Temp1;

    // this hack is required to work around problems with certain
    // revs of the NEC controller
    OpenHCI_KdPrint((2, "'Fix Bulk/Control Lists\n"));

    HC = DeviceData->HC;

	Temp  = READ_REGISTER_ULONG(&HC->HcCommandStatus.ul);
	Temp0 = Temp & ~(HcCmd_ControlListFilled | HcCmd_BulkListFilled);
	Temp1 = Temp | (HcCmd_ControlListFilled | HcCmd_BulkListFilled);

    WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, Temp0);
    WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, Temp1);
}


BOOLEAN
OpenHCI_RhPortsIdle(
    PHCD_DEVICE_DATA DeviceData
    )

/*++

Routine Description:

Arguments:

    DeviceObject - DeviceObject of the controller to stop

Return Value:

    NT status code.

--*/

{
    ULONG   i;
    BOOLEAN idle = TRUE;

    // don't log in here, this function can be called
    // in a kesync situation

    // Note always return false if the root hub is disabled --
    // we don't want to go idle with no root hub to control the
    // ports.

    if (DeviceData->RootHubControl == NULL) {
        idle = FALSE;
    }

    for (i = 0; idle && i < DeviceData->NumberOfPorts; i++)
    {
        ULONG currentStatus;

        currentStatus = ReadPortStatusFix(DeviceData, i);

        //LOGENTRY(G, 'idPS', currentStatus, i, 0);
        if (currentStatus & (HcRhPS_ConnectStatusChange |
                             HcRhPS_CurrentConnectStatus)) {

            idle = FALSE;
        }
    }
    return idle;
}


VOID
OpenHCI_CheckIdle(
    PHCD_DEVICE_DATA DeviceData
    )

/*++

Routine Description:

    If the controllers hub ports are not connected this function
    stops the host controller

    If there are no iso enpoints open then this function
    disables the rollover interrupt

Arguments:

    DeviceObject - DeviceObject of the controller to stop

Return Value:

    NT status code.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN portsIdle = TRUE;
    LARGE_INTEGER timeNow;
    PHC_OPERATIONAL_REGISTER HC;

    OpenHCI_KdPrint((3, "'Check Idle\n"));
    HC = DeviceData->HC;

    if (DeviceData->HcFlags &
        (HC_FLAG_DISABLE_IDLE_CHECK | HC_FLAG_IDLE | HC_FLAG_DISABLE_IDLE_MODE)) {
        // no idle checking until we are started and the root hub
        // is operational
        return;
    }

    KeAcquireSpinLockAtDpcLevel(&DeviceData->HcFlagSpin);

    portsIdle = OpenHCI_RhPortsIdle(DeviceData);

    if (portsIdle) {

        // if ports are idle turn off sof int
        WRITE_REGISTER_ULONG(&HC->HcInterruptDisable,
                             HcInt_StartOfFrame);

        KeQuerySystemTime(&timeNow);


        // we are not idle,

        // see how long ports have been idle if it
        // is longer then 10 seconds stop the
        // controller

        if (DeviceData->IdleTime == 0) {
            KeQuerySystemTime(&DeviceData->LastIdleTime);
            DeviceData->IdleTime = 1;
        }

        DeviceData->IdleTime +=
            (LONG) (timeNow.QuadPart -
            DeviceData->LastIdleTime.QuadPart);

        LOGENTRY(G, 'idlT', DeviceData->IdleTime, 0, 0);

        // ports are idle stop the controller
        if (// 10 seconds in 100ns units
            DeviceData->IdleTime > 100000000) {

            LOGENTRY(G, 'sOFF', DeviceData, 0, 0);

            OpenHCI_KdPrint((2, "'HC stopped\n"));

            // attempt to move the controller to the suspend state
            OpenHCI_KdPrint((1, "'controller going idle\n"));

            if (!KeSynchronizeExecution(DeviceData->InterruptObject,
                            OpenHCI_IdleController,
                            DeviceData)) {
               TRAP(); //something has gone terribly wrong
            }
            DeviceData->HcFlags |= HC_FLAG_IDLE;
            OpenHCI_KdPrint((1, "'controller idle\n"));
        }

        DeviceData->LastIdleTime = timeNow;
    } else {
        DeviceData->IdleTime = 0;
    }

    KeReleaseSpinLockFromDpcLevel(&DeviceData->HcFlagSpin);
}


VOID
OpenHCI_DeadmanDPC(
    PKDPC Dpc,
    PVOID DeviceObject,
    PVOID Context1,
    PVOID Context2
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_DEVICE_DATA            deviceData;
    PHC_OPERATIONAL_REGISTER    HC;
    ULONGLONG                   lastDeadmanTime;

    deviceData =
        (PHCD_DEVICE_DATA) ((PDEVICE_OBJECT) DeviceObject)->DeviceExtension;

    HC = deviceData->HC;

    lastDeadmanTime = deviceData->LastDeadmanTime;

    deviceData->LastDeadmanTime = KeQueryInterruptTime();

    ASSERT(deviceData->CurrentDevicePowerState == PowerDeviceD0);
    ASSERT(deviceData->HcFlags & HC_FLAG_DEVICE_STARTED);

    {
        // If the HC is in the operational state, try to determine if it
        // is still alive and updating the HCCA.
        //
        if ((deviceData->HcFlags & HC_FLAG_HUNG_CHECK_ENABLE) &&
            ((READ_REGISTER_ULONG(&HC->HcControl.ul) & HcCtrl_HCFS_MASK) ==
             HcCtrl_HCFS_USBOperational) &&
            (lastDeadmanTime != deviceData->LastDeadmanTime))
        {
#if DBG
            ULONG HcFmNumber;

            HcFmNumber = READ_REGISTER_ULONG(&HC->HcFmNumber);
#endif
            switch (deviceData->HCCA->HccaPad1)
            {
                case 0:
                    //
                    // When the HC updates HccaFrameNumber, it is supposed
                    // to set HccaPad1 to zero, so this is the expected case.
                    // Here we set HccaPad1 to a non-zero value to try to
                    // detect situations when the HC is no longer functioning
                    // correctly and accessing and updating host memory.
                    //
                    deviceData->HCCA->HccaPad1 = 0xBAD1;

                    break;

                case 0xBAD1:
                    //
                    // Apparently the HC has not updated the HCCA since the
                    // last time the DPC ran.  This is probably not good.
                    //
                    deviceData->HCCA->HccaPad1 = 0xBAD2;

                    LOGENTRY(G, 'BAD2', deviceData, HcFmNumber,
                             deviceData->LastDeadmanTime);

                    LOGENTRY(G, 'bad2', deviceData,
                             deviceData->HCCA->HccaFrameNumber, 0);

                    break;

                case 0xBAD2:
                    //
                    // Apparently the HC has not updated the HCCA since the
                    // last two times the DPC ran.  This looks even worse.
                    // Assume the HC has become wedged.
                    //
                    deviceData->HCCA->HccaPad1 = 0xBAD3;

                    LOGENTRY(G, 'BAD3', deviceData, HcFmNumber,
                             deviceData->LastDeadmanTime);

                    LOGENTRY(G, 'bad3', deviceData,
                             deviceData->HCCA->HccaFrameNumber, 0);

                    OpenHCI_KdPrint((0,
                                     "*** Warning: HC %08X appears to be wedged!\n",
                                     DeviceObject));

                    OpenHCI_ResurrectHC(deviceData);

                    return;

                case 0xBAD3:
                    break;

                default:
                    TEST_TRAP();
                    break;
            }
        }

        if (deviceData->HcFlags & HC_FLAG_LIST_FIX_ENABLE)
        {
            // fix NEC bulk and control lists
            OpenHCI_FixLists(deviceData);
        }

        // see if we can go idle
        OpenHCI_CheckIdle(deviceData);
    }
}


NTSTATUS
OpenHCI_InsertMagicEDs(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

   DeviceObject - DeviceObject for this USB controller.

Return Value:

   NT Status code.

--*/
{

    PHCD_ENDPOINT_DESCRIPTOR ed;
    PHCD_DEVICE_DATA deviceData;
    PHCD_TRANSFER_DESCRIPTOR td;
    ULONG i;

    OpenHCI_KdPrint((1, "'*** WARNING: Turning on HS/LS Fix ***\n"));
    //
    // **
    // WARNING:
    /*
        The folllowing code is specific for the COMPAQ OHCI hardware
        design -- it should not be executed on other controllers
    */

    /* Dummy ED must look like this:

    ED->TD->XXX
    XXX is bogus address 0xABADBABE
    (HeadP points to TD)
    (TailP points to XXX)

    TD has CBP=0 and BE=0
    NextTD points to XXX

    TD will never be retired by the hardware

    */

    //
    // create a dummy interrupt ED with period 1
    //
    deviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;

    // Reserve the 17 dummy EDs+TDs
    //
    OpenHCI_ReserveDescriptors(deviceData, 34);

    // add 17 dummy EDs+TDs
    //
    for (i=0; i< 17; i++) {
        ed = InsertEDForEndpoint(deviceData, NULL, ED_INTERRUPT_1ms,
                &td);

        OHCI_ASSERT(td);
        ed->Endpoint = NULL;

        ed->HcED.FunctionAddress = 0;
        ed->HcED.EndpointNumber = 0;
        ed->HcED.Direction = 0;
        ed->HcED.LowSpeed = 0;
        ed->HcED.sKip = 1;
        ed->HcED.Isochronous = 0;
        ed->HcED.MaxPacket = 0;

        //fixup the TD
        td->Canceled = FALSE;
        td->NextHcdTD = (PVOID)-1;
        td->UsbdRequest = MAGIC_SIG;

        td->HcTD.CBP = 0;
        td->HcTD.BE = 0;
        td->HcTD.Control = 0;
        td->HcTD.NextTD = 0xABADBABE;

        // set head/Tail pointers
//        ed->HcED.HeadP = td->PhysicalAddress;
//        ed->HcED.TailP = 0xABADBABE;

        // turn it on
        LOGENTRY(G, 'MagI', 0, ed, td);
        //TEST_TRAP();
        //ed->HcED.sKip = 0;

    }

    return STATUS_SUCCESS;
}


NTSTATUS
OpenHCI_ResurrectHC(
    PHCD_DEVICE_DATA DeviceData
    )
/*++
    Attempt to resurrect the HC after we have determined that it is dead.
--*/
{
    PHC_OPERATIONAL_REGISTER    HC;
    ULONG                       HccaFrameNumber;
    ULONG                       HcControl;
    ULONG                       HcHCCA;
    ULONG                       HcControlHeadED;
    ULONG                       HcBulkHeadED;
    ULONG                       HcDoneHead;
    ULONG                       HcFmInterval;
    ULONG                       HcPeriodicStart;
    ULONG                       HcLSThreshold;
    ULONG                       port;

    OpenHCI_KdPrint((1, "Resurrecting HC\n"));


    // For diagnostic purposes, keep track of how many times the
    // HC appears to have hung;
    //
    DeviceData->ResurrectHCCount++;

    LOGENTRY(G, 'RHC!', DeviceData, DeviceData->ResurrectHCCount, 0);

    //
    // Get the pointer to the HC Operational Registers
    //

    HC = DeviceData->HC;

    //
    // Save the last FrameNumber from the HCCA from when the HC froze
    //

    HccaFrameNumber = DeviceData->HCCA->HccaFrameNumber;

    //
    // Read the HcDoneHead in case some TDs completed during the frame
    // in which the HC froze.
    //

    HcDoneHead = READ_REGISTER_ULONG(&HC->HcDoneHead);

#if DBG
    {
        PPAGE_LIST_ENTRY            pageList;
        PHCD_TRANSFER_DESCRIPTOR    td;
        ULONG                       nullcount;

        // Some TDs might have completed during the frame in which the
        // HC froze.  If that happened, one and only one TD should have
        // a NULL NextTD pointer, and the HC->HcDoneHead register should
        // still be pointing to the head of done queue.
        //
        // Assert that the current hardware state matches our assumptions.
        //

        nullcount = 0;

        pageList = DeviceData->PageList;

        while (pageList)
        {
            for (td = pageList->FirstTDVirt; td <= pageList->LastTDVirt; td++)
            {
                if (td->Flags == TD_FLAG_INUSE)
                {
                    if (td->HcTD.NextTD == 0)
                    {
                        nullcount++;
                    }
                }
            }

            pageList = pageList->NextPage;
        }

        OpenHCI_KdPrint((0, "Resurrecting HC, nullcount %d, HcDoneHead %08X\n",
                        nullcount, HcDoneHead));

        OHCI_ASSERT(nullcount <= 1);

        OHCI_ASSERT((nullcount != 0) == (HcDoneHead != 0));

    }
#endif

    //
    // If the HcDoneHead is non-zero, the TDs which completed during the
    // frame in which the HC froze will be processed the next time the
    // ISR DPC runs.
    //

    HcDoneHead = InterlockedExchange(&DeviceData->FrozenHcDoneHead, HcDoneHead);
    OHCI_ASSERT(HcDoneHead == 0);


    //
    // Save current HC operational register values
    //

    // offset 0x04, save HcControl
    //
    HcControl       = READ_REGISTER_ULONG(&HC->HcControl.ul);

    // offset 0x18, save HcHCCA
    //
    HcHCCA          = READ_REGISTER_ULONG(&HC->HcHCCA);

    // offset 0x20, save HcControlHeadED
    //
    HcControlHeadED = READ_REGISTER_ULONG(&HC->HcControlHeadED);

    // offset 0x28, save HcBulkHeadED
    //
    HcBulkHeadED    = READ_REGISTER_ULONG(&HC->HcBulkHeadED);

    // offset 0x34, save HcFmInterval
    //
    HcFmInterval    = READ_REGISTER_ULONG(&HC->HcFmInterval.ul);

    // offset 0x40, save HcPeriodicStart
    //
    HcPeriodicStart = READ_REGISTER_ULONG(&HC->HcPeriodicStart);

    // offset 0x44, save HcLSThreshold
    //
    HcLSThreshold   = READ_REGISTER_ULONG(&HC->HcLSThreshold);


    //
    // Reset the host controller
    //
    WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, HcCmd_HostControllerReset);
    KeStallExecutionProcessor(10);


    //
    // Restore / reinitialize HC operational register values
    //

    // offset 0x08, HcCommandStatus is set to zero on reset

    // offset 0x0C, HcInterruptStatus is set to zero on reset

    // offset 0x10, HcInterruptEnable is set to zero on reset

    // offset 0x14, HcInterruptDisable is set to zero on reset

    // offset 0x18, restore HcHCCA
    //
    WRITE_REGISTER_ULONG(&HC->HcHCCA,           HcHCCA);

    // offset 0x1C, HcPeriodCurrentED is set to zero on reset

    // offset 0x20, restore HcControlHeadED
    //
    WRITE_REGISTER_ULONG(&HC->HcControlHeadED,  HcControlHeadED);

    // offset 0x24, HcControlCurrentED is set to zero on reset

    // offset 0x28, restore HcBulkHeadED
    //
    WRITE_REGISTER_ULONG(&HC->HcBulkHeadED,     HcBulkHeadED);

    // offset 0x2C, HcBulkCurrentED is set to zero on reset

    // offset 0x30, HcDoneHead is set to zero on reset


    // It appears that writes to HcFmInterval don't stick unless the HC
    // is in the operational state.  Set the HC into the operational
    // state at this point, but don't enable any list processing yet
    // by setting any of the BLE, CLE, IE, or PLE bits.
    //
    WRITE_REGISTER_ULONG(&HC->HcControl.ul, HcCtrl_HCFS_USBOperational);


    // offset 0x34, restore HcFmInterval
    //
    WRITE_REGISTER_ULONG(&HC->HcFmInterval.ul,
                         HcFmInterval | HcFmI_FRAME_INTERVAL_TOGGLE);

    // offset 0x38, HcFmRemaining is set to zero on reset

    // offset 0x3C, restore HcFmNumber
    //
    WRITE_REGISTER_ULONG(&HC->HcFmNumber,       HccaFrameNumber);

    // offset 0x40, restore HcPeriodicStart
    //
    WRITE_REGISTER_ULONG(&HC->HcPeriodicStart,  HcPeriodicStart);

    // offset 0x44, restore HcLSThreshold
    //
    WRITE_REGISTER_ULONG(&HC->HcLSThreshold,    HcLSThreshold);

    // Power on downstream ports
    //
    WRITE_REGISTER_ULONG(&HC->HcRhStatus,
                         HcRhS_SetGlobalPower | HcRhS_SetRemoteWakeupEnable);

    for (port = 0; port < DeviceData->NumberOfPorts; port++)
    {
        WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[port], HcRhPS_SetPortPower);
    }

    // offset 0x04, restore HcControl
    //
    HcControl &= ~(HcCtrl_HCFS_MASK);
    HcControl |= HcCtrl_HCFS_USBOperational;

    WRITE_REGISTER_ULONG(&HC->HcControl.ul,     HcControl);

    // offset 0x10, restore HcInterruptEnable (just turn everything on!)
    //
    WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                         HcInt_MasterInterruptEnable    |   // 0x80000000
                         HcInt_OwnershipChange          |   // 0x40000000
                         HcInt_RootHubStatusChange      |   // 0x00000040
                         HcInt_FrameNumberOverflow      |   // 0x00000020
                         HcInt_UnrecoverableError       |   // 0x00000010
                         HcInt_ResumeDetected           |   // 0x00000008
                         HcInt_StartOfFrame             |   // 0x00000004
                         HcInt_WritebackDoneHead        |   // 0x00000002
                         HcInt_SchedulingOverrun            // 0x00000001
                        );

    return STATUS_SUCCESS;
}


ULONG
FindLostDoneHead (
    IN PHCD_DEVICE_DATA DeviceData
)
/*++
    Attempt to find the lost head of the done TD queue.
--*/
{
    PHC_OPERATIONAL_REGISTER    HC;
    PPAGE_LIST_ENTRY            PageList;
    PHCD_TRANSFER_DESCRIPTOR    Td;
    ULONG                       TdList1;
    ULONG                       TdList2;
    ULONG                       HcDoneHead;
    BOOLEAN                     updated;
    

    // For diagnostic purposes, keep track of how many times the
    // HCCA->HccaDoneHead update appears to have been lost.
    //
    DeviceData->LostDoneHeadCount++;

    LOGENTRY(G, 'FLst', DeviceData, DeviceData->LostDoneHeadCount, 0);

    HC = DeviceData->HC;

    TdList1     = 0;
    TdList2     = 0;
    HcDoneHead  = 0;

    //
    // Scan the TD pool looking for TDs with a NULL NextTD pointer.
    // A TD should only have NULL NextTD pointer if it is the tail of
    // a done TD list.  There might be two such lists:  the list of TDs
    // that were completed the last time the HC should have updated the
    // HCCA->HccaDoneHead, and the list of TDs that have completed since
    // then.
    //

    PageList = DeviceData->PageList;

    while (PageList)
    {
        for (Td = PageList->FirstTDVirt; Td <= PageList->LastTDVirt; Td++)
        {
            if (Td->Flags == TD_FLAG_INUSE)
            {
                if (Td->HcTD.NextTD == 0)
                {
                    // This TD has a NULL NextTD pointer.  Save it as the
                    // tail of either TdList1 or TdList2.
                    //
                    if (TdList1 == 0)
                    {
                        TdList1 = Td->PhysicalAddress;
                    }
                    else
                    {
                        // We expect to find at most two TDs with NULL
                        // NextTD pointers.
                        //
                        OHCI_ASSERT(TdList2 == 0);

                        TdList2 = Td->PhysicalAddress;
                    }
                }
            }
        }

        PageList = PageList->NextPage;
    }

    if (TdList1 == 0)
    {
        // We found no TDs with NULL NextTD pointers.
        //
        return 0;
    }

    if (TdList2 != 0)
    {
        // There are two lists of completed TDs.  One list should be
        // pointed to by HCCA->HccaDoneHead, and the other list should be
        // pointed to by HC->HcDoneHead.  Read HC->HcDoneHead so we can
        // determine which list is pointed to (or should have been pointed
        // to) by HCCA->HccaDoneHead and which list is pointed to by
        // HC->HcDoneHead.
        //
        HcDoneHead = READ_REGISTER_ULONG(&HC->HcDoneHead);

        // If HC->HcDoneHead is NULL, then something is does not match our
        // expectations.
        //
        OHCI_ASSERT(HcDoneHead != 0);
    }

    do
    {
        updated = FALSE;

        if (HcDoneHead)
        {
            if (HcDoneHead == TdList1)
            {
                // TdList1 is pointed to by HC->HcDoneHead.  Toss TdList1
                // and keep TdList2
                //
                TdList1 = TdList2;
                TdList2 = 0;
            }
            else if (HcDoneHead == TdList2)
            {
                // TdList2 is pointed to by HC->HcDoneHead.  Toss TdList2
                // and keep TdList1
                //
                TdList2 = 0;
            }
        }

        //
        // Scan the TD pool looking for TDs with NextTD pointers that
        // point to the head of either TdList1 or TdList2.  If such a TD
        // is found, it becomes the new head of the appropriate list, and
        // loop around at least one more time.  If no such TD is found, then
        // the current heads of the lists must be the true heads and we can
        // quit looping.
        //

        PageList = DeviceData->PageList;

        while (PageList)
        {
            for (Td = PageList->FirstTDVirt; Td <= PageList->LastTDVirt; Td++)
            {
                if ((Td->Flags == TD_FLAG_INUSE) && (Td->HcTD.NextTD != 0))
                {
                    if (Td->HcTD.NextTD == TdList1)
                    {
                        TdList1 = Td->PhysicalAddress;
                        updated = TRUE;
                    }
                    else if (Td->HcTD.NextTD == TdList2)
                    {
                        TdList2 = Td->PhysicalAddress;
                        updated = TRUE;
                    }
                }
            }

            PageList = PageList->NextPage;
        }

    } while (updated);


    OHCI_ASSERT(TdList1 != 0);
    OHCI_ASSERT(TdList2 == 0);

    return TdList1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\openhci\dbg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

   debug macros.

Environment:

    Kernel & user mode

Revision History:

    6-6-97 : created jdunn

--*/

//
// masks fo rdebug trace level
//

#define OHCI_DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define OHCI_DBG_SS_NOISE               0x00000001
#define OHCI_DBG_SS_TRACE               0x00000002
#define OHCI_DBG_SS_INFO                0x00000004
#define OHCI_DBG_SS_ERROR               0x00000008

#define OHCI_DBG_CALL_MASK              0x000000F0
#define OHCI_DBG_CALL_NOISE             0x00000010
#define OHCI_DBG_CALL_TRACE             0x00000020
#define OHCI_DBG_CALL_INFO              0x00000040
#define OHCI_DBG_CALL_ERROR             0x00000080

#define OHCI_DBG_ENDPOINT_MASK          0x00000F00
#define OHCI_DBG_END_NOISE              0x00000100
#define OHCI_DBG_END_TRACE              0x00000200
#define OHCI_DBG_END_INFO               0x00000400
#define OHCI_DBG_END_ERROR              0x00000800

#define OHCI_DBG_TRANSFER_DESC_MASK     0x0000F000
#define OHCI_DBG_TD_NOISE               0x00001000
#define OHCI_DBG_TD_TRACE               0x00002000
#define OHCI_DBG_TD_INFO                0x00004000
#define OHCI_DBG_TD_ERROR               0x00008000

#define OHCI_DBG_ISR_MASK               0x000F0000
#define OHCI_DBG_ISR_NOISE              0x00010000
#define OHCI_DBG_ISR_TRACE              0x00020000
#define OHCI_DBG_ISR_INFO               0x00040000
#define OHCI_DBG_ISR_ERROR              0x00080000

#define OHCI_DBG_ROOT_HUB_MASK          0x00F00000
#define OHCI_DBG_RH_NOISE               0x00100000
#define OHCI_DBG_RH_TRACE               0x00200000
#define OHCI_DBG_RH_INFO                0x00400000
#define OHCI_DBG_RH_ERROR               0x00800000

#define OHCI_DBG_PNP_MASK               0x0F000000
#define OHCI_DBG_PNP_NOISE              0x01000000
#define OHCI_DBG_PNP_TRACE              0x02000000
#define OHCI_DBG_PNP_INFO               0x04000000
#define OHCI_DBG_PNP_ERROR              0x08000000

#define OHCI_DBG_CANCEL_MASK            0xF0000000
#define OHCI_DBG_CANCEL_NOISE           0x10000000
#define OHCI_DBG_CANCEL_TRACE           0x20000000
#define OHCI_DBG_CANCEL_INFO            0x40000000
#define OHCI_DBG_CANCEL_ERROR           0x80000000

#define SIG_EP            0x70655045        //'EPep' signature for endpoint

//
// debug log masks
#define M                 0x00000001
#define G                 0x00000002

#ifdef _WIN64
#define TD_NOREQUEST_SIG    ((PVOID) 0xDEADFACEDEADFACE)
#define MAGIC_SIG           ((PVOID) 0x4d4147694d414769)
#else
#define TD_NOREQUEST_SIG    ((PVOID) 0xDEADFACE)
#define MAGIC_SIG           ((PVOID) 0x4d414769)
#endif


#if DBG

// Assert Macros
//
// We define our own assert function because ntkern will 
// not stop in the debugger on assert failures in our own 
// code.
//

VOID
OHCI_LogIrp(
    PIRP Irp,
    ULONG Add
    );

VOID
OpenHCI_Assert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

ULONG
_cdecl
OHCI_KdPrint2(
    PCH Format,
    ...
    );    

ULONG
_cdecl
OHCI_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    );     

#define OHCI_ASSERT( exp ) \
    if (!(exp)) {\
        OpenHCI_Assert( #exp, __FILE__, __LINE__, NULL );\
    }                

#define OHCI_ASSERTMSG( msg, exp ) \
    if (!(exp)) {\
        OpenHCI_Assert( #exp, __FILE__, __LINE__, msg );\
    }        


extern ULONG OHCI_Debug_Trace_Level; 

#define OpenHCI_KdPrintDD(_d_, _l_, _x_) \
            if (((_d_)->DebugLevel & (_l_)) || \
                OHCI_Debug_Trace_Level > 0) { \
                OHCI_KdPrint2 _x_;\
            }

#define OpenHCI_KdPrint(_x_) OHCI_KdPrintX _x_
            
#ifdef NTKERN
#define TRAP() _asm {int 3}   
#else
#define TRAP() DbgBreakPoint()
#endif //NTKERN

#define TEST_TRAP() { \
    DbgPrint ("'OpenHCI.SYS: Code Coverage %s, %d\n", __FILE__, __LINE__);\
    TRAP(); \
    }

#define OpenHCI_KdTrap(_x_) \
            { \
            DbgPrint("OpenHCI.SYS: "); \
            DbgPrint _x_; \
            TRAP(); \
            }

#define DEBUG_LOG
//#define IRP_LOG


#ifdef MAX_DEBUG
#define OpenHCI_KdBreak(_x_) \
            { \
            DbgPrint ("'OpenHCI.SYS: "); \
            DbgPrint _x_; \
            TRAP();\
            }
#else
#define OpenHCI_KdBreak(_x_) \
            { \
            DbgPrint ("'OpenHCI.SYS: "); \
            DbgPrint _x_; \
            }
#endif //MAX_DEBUG


#define ASSERT_ENDPOINT(ep)     OHCI_ASSERT((ep)->Sig == SIG_EP)

#else // not DBG

#define OpenHCI_KdPrintDD(_d_, _l_, _x_)
#define OpenHCI_KdPrint(_x_)
#define OpenHCI_KdTrap(_x_)
#define TRAP()
#define TEST_TRAP()
#define OpenHCI_KdBreak(_x_)
#define OHCI_ASSERT(exp)

#define ASSERT_ENDPOINT(ep)    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\openhci\ohciroot.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   OHCIroot.c

Abstract:

   The module manages the Root Hub of the OpenHCI controller.

Environment:

   kernel mode only

Notes:

Revision History:

   03-22-96 : created   jfuller
   05-25-96 : reworked  kenray

--*/

#include "OpenHCI.h"

// This is the data packet that the upper levels of the stack believe
// are sending to a real hub.  We intercept and interpret this packet.
typedef struct _SETUP_PACKET {
    union {
        struct {
 UCHAR Recipient:
             5;                 // entity to recieve command
 UCHAR Type:
             2;                 // type of command
 UCHAR DirectionIn:
             1;                 // data transfer direction
        };
        struct {
            UCHAR RequestType;  // request type code
        };
    };
    UCHAR Request;              // command code
    USHORT wValue;              // parameter
    USHORT wIndex;              // another parameter
    USHORT wLength;             // transfer length (same as
                                // TransferBufferLength?)
} SETUP_PACKET, *PSETUP_PACKET;

#define SPrequest_GetStatus         0x0
#define SPrequest_ClearFeature      0x1
#define SPrequest_SetFeature        0x3
#define SPrequest_SetAddress        0x5
#define SPrequest_GetDescriptor     0x6
#define SPrequest_SetDescriptor     0x7
#define SPrequest_GetConfiguration  0x8
#define SPrequest_SetConfiguration  0x9
#define SPrequest_GetInterface      0xA
#define SPrequest_SetInterface      0xB
#define SPrequest_SyncFrame         0xC

#define SPrecipient_Device          0
#define SPrecipient_Interface       1
#define SPrecipient_Endpoint        2
#define SPrecipient_Other           3

#define SPtype_Standard             0
#define SPtype_Class                1
#define SPtype_Vendor               2

#define SPbmrt_In_Standard_Device      0x80     // 1000 0000
#define SPbmrt_In_Standard_Interface   0x81     // 1000 0001
#define SPbmrt_In_Standard_Endpoint    0x82     // 1000 0010
#define SPbmrt_Out_Standard_Device     0x00     // 0000 0000
#define SPbmrt_Out_Standard_Interface  0x01     // 0000 0001
#define SPbmrt_Out_Standard_Endpoint   0x02     // 0000 0010
#define SPbmrt_In_Class_Device         0xA0     // 1010 0000
#define SPbmrt_In_Class_Other          0xA3     // 1010 0011
#define SPbmrt_Out_Class_Device        0x20     // 0010 0000
#define SPbmrt_Out_Class_Other         0x23     // 0010 0011                 


// 
// Hub Class Feature Selectors, see Table 11-13 in the
// Universal Serial Bus Specification Revision 1.0
//
//
// Recipient Hub
//
#define C_HUB_LOCAL_POWER           0
#define C_HUB_OVER_CURRENT          1
//
// Recipient Port
//
#define PORT_CONNECTION             0
#define PORT_ENABLE                 1
#define PORT_SUSPEND                2
#define PORT_OVER_CURRENT           3
#define PORT_RESET                  4
#define PORT_POWER                  8
#define PORT_LOW_SPEED              9
#define C_PORT_CONNECTION           16
#define C_PORT_ENABLE               17
#define C_PORT_SUSPEND              18
#define C_PORT_OVER_CURRENT         19
#define C_PORT_RESET                20

// default descriptors for root hub

UCHAR RH_DeviceDescriptor[] = {0x12, //bLength
                               0x01, //bDescrpitorType
                               0x00, 0x01, //bcdUSB
                               0x09, //bDeviceClass
                               0x01, //bDeviceSubClass
                               0x00, //bDeviceProtocol
                               0x08, //bMaxPacketSize0
                               0x00, 0x00, //idVendor
                               0x00, 0x00, //idProduct
                               0x00, 0x00, //bcdDevice
                               0x00, //iManufacturer
                               0x00, //iProduct
                               0x00, //iSerialNumber
                               0x01};//bNumConfigurations

UCHAR RH_ConfigurationDescriptor[] = 
                         /* Config Descriptor   */
                        {0x09, //bLength
                         0x02, //bDescriptorType
                         0x19, 0x00, //wTotalLength
                         0x01, //bNumInterfaces
                         0x01, //iConfigurationValue
                         0x00, //iConfiguration
                         0x40, //bmAttributes
                         0x00, //MaxPower  
                         
                         /* Interface Descriptor */
                         0x09, //bLength
                         0x04, //bDescriptorType
                         0x00, //bInterfaceNumber
                         0x00, //bAlternateSetting
                         0x01, //bNumEndpoints
                         0x09, //bInterfaceClass
                         0x01, //bInterfaceSubClass
                         0x00, //bInterfaceProtocol
                         0x00, //iInterface  
                         
                         /* Endpoint Descriptor  */                                       
                         0x07, //bLength
                         0x05, //bDescriptorType
                         0x81, //bEndpointAddress
                         0x03, //bmAttributes
                         0x08, 0x00, //wMaxPacketSize
                         0x0a};//bInterval                                             

UCHAR RH_HubDescriptor[] = 
                      {0x09,  //bLength
                       0x29,  //bDescriptorType
                       0x02,  //bNbrPorts
                       0x00, 0x00, //wHubCharacteristics
                       0x00,  // bPwrOn2PwrGood
                       0x00};  // bHubContrCurrent

void OpenHCI_CancelRootInterrupt(PDEVICE_OBJECT, PIRP);


NTSTATUS
OpenHCI_RootHubStartXfer(
                         PDEVICE_OBJECT DeviceObject,
                         PHCD_DEVICE_DATA DeviceData,
                         PIRP Irp,
                         PHCD_URB UsbRequest,
                         PHCD_ENDPOINT Endpoint
)
{
    PSETUP_PACKET Pkt;
    PCHAR Buffer;
    KIRQL oldIrql;
    PHC_OPERATIONAL_REGISTER HC = DeviceData->HC;
    struct _URB_HCD_COMMON_TRANSFER *trans = 
        &UsbRequest->HcdUrbCommonTransfer;

    ASSERT(NULL == Endpoint->HcdED);

    if (Endpoint->Type == USB_ENDPOINT_TYPE_CONTROL
        && Endpoint->EndpointNumber == 0) {
        //
        // This is the default endpoint of the root hub
        //
        Pkt = (PSETUP_PACKET) & trans->Extension.u.SetupPacket[0];

        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_RH_TRACE,
                        ("'RootHub emulation: %02x %02x %04x %04x %04x\n",
                         Pkt->RequestType, Pkt->Request,
                         Pkt->wValue, Pkt->wIndex,
                         Pkt->wLength));

        ASSERT(trans->TransferBufferLength == Pkt->wLength);
        if (trans->TransferBufferLength) {
            // This is cause an exception if any of the upper levels of the
            // USB stack (those that created this MDL) are misbehaving.
            Buffer = MmGetSystemAddressForMdl(trans->TransferBufferMDL);
        } else {
            Buffer = NULL;
        }

        switch (Pkt->Request) {
        case SPrequest_GetStatus:
            switch (Pkt->RequestType) {
            case SPbmrt_In_Class_Device:
                //
                // GetHubStatus
                //
                if (4 != trans->TransferBufferLength) {
                    TRAP();
                    break;
                }
                *((PULONG) Buffer) = ~HcRhS_DeviceRemoteWakeupEnable
                    & READ_REGISTER_ULONG(&HC->HcRhStatus);
                trans->Status = USBD_STATUS_SUCCESS;
                return STATUS_SUCCESS;
            case SPbmrt_In_Class_Other:
                //
                // GetPortStatus
                //
                if (4 != trans->TransferBufferLength) {
                    TRAP();
                    break;
                }

                *((PULONG) Buffer) = ReadPortStatusFix(DeviceData,
                                                       Pkt->wIndex - 1);

                LOGENTRY(G, 'gPRT', Pkt->wIndex, trans->TransferBufferLength, *((PULONG) Buffer));
                trans->TransferBufferLength = 4;
                trans->Status = USBD_STATUS_SUCCESS;
                return STATUS_SUCCESS;
            case SPbmrt_In_Standard_Device:
                if (0 == Pkt->wIndex && 2 == trans->TransferBufferLength) {
                    Buffer[0] = 3;  // Remote Wakeup & Self Powered
                    Buffer[1] = 0;
                    return STATUS_SUCCESS;
                }
                break;
            case SPbmrt_In_Standard_Interface:
                if (0 == Pkt->wIndex && 2 == trans->TransferBufferLength) {
                    Buffer[0] = Buffer[0] = 0;
                    return STATUS_SUCCESS;
                }
                break;

            case SPbmrt_In_Standard_Endpoint:
                if ((2 == trans->TransferBufferLength)
                    && ((1 == Pkt->wIndex) || (0 == Pkt->wIndex))) {
                    Buffer[0] = Buffer[0] = 0;
                    return STATUS_SUCCESS;
                }
                break;
            }
            break;

        case SPrequest_ClearFeature:
            if (SPbmrt_Out_Class_Other == Pkt->RequestType) {
                //
                // clear port feature
                //
                OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_RH_TRACE,
                    ("'Clear Feature wValue = %x index = %x\n",
                    Pkt->wValue, Pkt->wIndex));
                    
                switch (Pkt->wValue) {
                case PORT_ENABLE:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_ClearPortEnable);
                    break;
                case PORT_SUSPEND:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_ClearPortSuspend);
                    break;
                case PORT_POWER:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_ClearPortPower);
                    break;
                case C_PORT_CONNECTION:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_ClearConnectStatusChange);
#if FAKEPORTCHANGE
                    DeviceData->FakePortChange &= ~(1 << (Pkt->wIndex - 1));
#endif
                    break;
                case C_PORT_ENABLE:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_ClearPortEnableStatusChange);
                    break;
                case C_PORT_SUSPEND:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                       HcRhPS_ClearPortSuspendStatusChange);
                    break;
                case C_PORT_OVER_CURRENT:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_ClearPortOverCurrentChange);
                    break;
                case C_PORT_RESET:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_ClearPortResetStatusChange);
                    break;
                default:
                    break;
                }
                trans->TransferBufferLength = 0;
                trans->Status = USBD_STATUS_SUCCESS;
                return STATUS_SUCCESS;
            } else if (SPbmrt_Out_Class_Device == Pkt->RequestType) {
                //
                // clear hub feature
                //
                switch (Pkt->wValue) {
                case C_HUB_LOCAL_POWER:
                    // The OpenHCI Root Hub does not support the local power
                    // status feature.  The Local Power Status Change bit is
                    // always read as '0'.  See section 7.4.3 hcRhStatus in
                    // the OpenHCI specification.
                    break;
                case C_HUB_OVER_CURRENT:
                    WRITE_REGISTER_ULONG(&HC->HcRhStatus, HcRhS_ClearOverCurrentIndicatorChange);
                    break;
                default:
                    break;
                }
                trans->TransferBufferLength = 0;
                trans->Status = USBD_STATUS_SUCCESS;
                return STATUS_SUCCESS;
            }
            break;

        case SPrequest_SetFeature:
            if (SPbmrt_Out_Class_Other == Pkt->RequestType) {
                //
                // set port feature
                //
                switch (Pkt->wValue) {
                case PORT_ENABLE:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_SetPortEnable);
                    break;
                case PORT_SUSPEND:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_SetPortSuspend);
                    break;
                case PORT_RESET:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_SetPortReset);
                    break;
                case PORT_POWER:
                    WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[Pkt->wIndex - 1],
                                         HcRhPS_SetPortPower);
                    break;
                }
                trans->TransferBufferLength = 0;
                trans->Status = USBD_STATUS_SUCCESS;
                return STATUS_SUCCESS;
            } else if (SPbmrt_Out_Class_Device == Pkt->RequestType) {
                //
                // set hub feature (no hub features can be set)
                //
                switch (Pkt->wValue) {
                default:
                    break;
                }
                trans->TransferBufferLength = 0;
                trans->Status = USBD_STATUS_SUCCESS;
                return STATUS_SUCCESS;
            }
            break;

        case SPrequest_SetAddress:
            ;
            if (SPbmrt_Out_Standard_Device == Pkt->RequestType) {
                if (DeviceData->RootHubAddress != (char) Pkt->wValue) {
                    
                    Endpoint->EpFlags &= ~EP_ROOT_HUB;
                    ASSERT(NULL == DeviceData->RootHubInterrupt);
                    //
                    // If you change the address while there is an open
                    // endpoint
                    // to the root hub interrupt than you strand that
                    // endpoint.
                    // You really should close this endpoint before changing
                    // the
                    // address.
                    //
                    // if (DeviceData->RootHubInterrupt)
                    // {
                    // ExFreePool (DeviceData->RootHubInterrupt);
                    // DeviceData->RootHubInterrupt = 0;
                    // }
                }
                DeviceData->RootHubAddress = (char) Pkt->wValue;
                trans->TransferBufferLength = 0;
                trans->Status = USBD_STATUS_SUCCESS;
                return STATUS_SUCCESS;
            }
            break;

        case SPrequest_GetDescriptor:
            {
                union {
                    UCHAR rc[4];
                    ULONG rl;
                    USHORT rs;
                } ports;
                
                ULONG length;

                switch (Pkt->RequestType) {

                case SPbmrt_In_Class_Device:
                    {
                    UCHAR scratch[100];  
                    PUSB_HUB_DESCRIPTOR hubDescriptor;
                    HC_RH_DESCRIPTOR_A descrA;
                    
                    //
                    // Get Descriptor, Hub
                    //

                    OHCI_ASSERT(sizeof(scratch)>sizeof(RH_HubDescriptor));
                    
                    hubDescriptor = (PUSB_HUB_DESCRIPTOR) scratch;
                    RtlCopyMemory(scratch, 
                                  RH_HubDescriptor, 
                                  sizeof(RH_DeviceDescriptor));                    

                    descrA.ul = 
                        READ_REGISTER_ULONG(&HC->HcRhDescriptorA.ul);

                    // this will set              
                    // bNumberOfPorts, wHubCharacteristics & bPowerOnToPowerGood
                    RtlCopyMemory(&hubDescriptor->bNumberOfPorts, 
                                  &descrA,
                                  sizeof(descrA));
                                      
                    LOGENTRY(G, 'rhCH', DeviceData, descrA.ul, 0);    

                    hubDescriptor->bHubControlCurrent = 0;
                    
                    ports.rl = READ_REGISTER_ULONG(&HC->HcRhDescriptorB.ul);
                    
                    if (hubDescriptor->bNumberOfPorts < 8) {
                        hubDescriptor->bDescriptorLength = 9;
                        hubDescriptor->bRemoveAndPowerMask[0] = ports.rc[0];
                        hubDescriptor->bRemoveAndPowerMask[1] = ports.rc[2];
                    } else {
                        hubDescriptor->bDescriptorLength = 11;
                        RtlCopyMemory(&hubDescriptor->bRemoveAndPowerMask[0], 
                                      &ports,
                                      sizeof(ports));    
                    }

                    trans->TransferBufferLength
                        = MIN(hubDescriptor->bDescriptorLength, trans->TransferBufferLength);

                    RtlCopyMemory(Buffer, scratch, trans->TransferBufferLength);
                    trans->Status = USBD_STATUS_SUCCESS;
                    return STATUS_SUCCESS;
                    }
                    
                case SPbmrt_In_Standard_Device:
                    {

                    PUSB_DEVICE_DESCRIPTOR deviceDescriptor;
                    PUSB_CONFIGURATION_DESCRIPTOR configDescriptor;
                    UCHAR scratch[100];

                    OHCI_ASSERT(sizeof(scratch)>sizeof(RH_DeviceDescriptor));
                    OHCI_ASSERT(sizeof(scratch)>sizeof(RH_ConfigurationDescriptor));
                    
                    //
                    // Get Descriptor
                    //

                    switch(Pkt->wValue) {
                    case 0x100: 
                        { // Device Descriptor

                        deviceDescriptor = (PUSB_DEVICE_DESCRIPTOR) scratch;
                        RtlCopyMemory(scratch, 
                                      RH_DeviceDescriptor, 
                                      sizeof(RH_DeviceDescriptor));
                                      
                        length = 
                            MIN(sizeof(RH_DeviceDescriptor), Pkt->wLength);

                        deviceDescriptor->idVendor = 
                            DeviceData->VendorID;

                        deviceDescriptor->idProduct = 
                            DeviceData->DeviceID;
                            
//                        deviceDescriptor->bcdDevice = 
//                            DeviceData->RevisionID;
                        }
                        break;
                        
                    case 0x200:
                        { // Configuration Descriptor
                        configDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR) scratch;
                        RtlCopyMemory(scratch, 
                                      RH_ConfigurationDescriptor, 
                                      sizeof(RH_ConfigurationDescriptor));
                        length = MIN(sizeof(RH_ConfigurationDescriptor), 
                                     Pkt->wLength);

                        }
                        break;
                        
                    default:
                        TRAP(); // should not get here, if we do then
                                // it is probably a bug in the hub driver

                        trans->Status = USBD_STATUS_STALL_PID;
                        trans->TransferBufferLength = 0;    // No data transferred
                        return STATUS_IO_DEVICE_ERROR;
                    }

                    RtlCopyMemory(Buffer, scratch, length);
                    trans->TransferBufferLength = length;
                    trans->Status = USBD_STATUS_SUCCESS;
                    return STATUS_SUCCESS;
                    }
                    
                default:
                    ;
                }
                break;
            }

        case SPrequest_GetConfiguration:
            if (SPbmrt_In_Standard_Device == Pkt->RequestType &&
                1 == trans->TransferBufferLength) {
                *Buffer = (CHAR) DeviceData->RootHubConfig;
                trans->Status = USBD_STATUS_SUCCESS;
                return STATUS_SUCCESS;
            }
            break;

        case SPrequest_SetConfiguration:
            if (SPbmrt_Out_Standard_Device == Pkt->RequestType &&
                0 == trans->TransferBufferLength &&
                0 == (Pkt->wValue & ~1)) {  // Only configs of 0 and 1
                                            // supported.
                                            
                DeviceData->RootHubConfig = (char) Pkt->wValue;
                trans->Status = USBD_STATUS_SUCCESS;
                return STATUS_SUCCESS;
            }
        case SPrequest_SetDescriptor:
        case SPrequest_GetInterface:    // We support only one interface.
        case SPrequest_SetInterface:    // We support only one interface.
        case SPrequest_SyncFrame:
        default:
            ;
        }
        trans->Status = USBD_STATUS_STALL_PID;
        trans->TransferBufferLength = 0;    // No data transferred
        return STATUS_IO_DEVICE_ERROR;

    } else if (Endpoint->Type == USB_ENDPOINT_TYPE_INTERRUPT
               && Endpoint->EndpointNumber == 1
               && DeviceData->RootHubConfig != 0) {

        NTSTATUS status;               
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_RH_TRACE,
                        ("'***** Insert REQUEST for Interrupt \n\n"));

        ASSERT(DeviceData->RootHubInterrupt == Endpoint);

        status = CheckRootHub(DeviceData,
                              HC,
                              UsbRequest);
                      
        if (status == STATUS_PENDING) {
            KeAcquireSpinLock(&Endpoint->QueueLock, &oldIrql);
            trans->Status = HCD_PENDING_STATUS_QUEUED;
            InsertTailList(&Endpoint->RequestQueue, &trans->hca.HcdListEntry);
            KeReleaseSpinLock(&Endpoint->QueueLock, oldIrql);

            if (NULL == trans->UrbLink) {
                Irp->IoStatus.Status = STATUS_PENDING;
                IoMarkIrpPending(Irp);
                IoSetCancelRoutine(Irp, OpenHCI_CancelRootInterrupt);
                if (Irp->Cancel) {
                    struct _URB_HCD_COMMON_TRANSFER *nextTrans;
                    if (IoSetCancelRoutine(Irp, NULL)) {
                        while (trans) {
                            nextTrans = &trans->UrbLink->HcdUrbCommonTransfer;
                            KeAcquireSpinLock(&Endpoint->QueueLock, &oldIrql);
                            RemoveEntryList(&trans->hca.HcdListEntry);
                            trans->Status = USBD_STATUS_CANCELED;
                            KeReleaseSpinLock(&Endpoint->QueueLock, oldIrql);
                            trans = nextTrans;
                        }
                        OpenHCI_CompleteIrp(DeviceObject, Irp, STATUS_CANCELLED);
                        return STATUS_CANCELLED;
                    } else {
                        return STATUS_CANCELLED;
                    }
                }
            }
            WRITE_REGISTER_ULONG(&HC->HcInterruptEnable, HcInt_RootHubStatusChange);
        }        
        return status;
    }
    //
    // Unknown transfer to root hub
    //
    trans->Status = USBD_STATUS_DEV_NOT_RESPONDING;
    trans->TransferBufferLength = 0;
    return STATUS_IO_DEVICE_ERROR;
}

ULONG
OpenHCI_BuildRootHubStatusChange(
    PHCD_DEVICE_DATA            DeviceData,
    PHC_OPERATIONAL_REGISTER    HC
)
/*++
Routine Description:
    Builds and returns a bitmap of the current root hub status changes.
   
    Bit 0 = Hub change detected
    Bit N = Port N change detected, where port N is one-based, not zero-based
--*/
{
    ULONG   changes;
    ULONG   portIndex;
    ULONG   mask;
    ULONG   portStatus;

    // Loop over the ports and build a status change mask for each
    // each port that has a current status change.
    //
    changes = 0;

    for (portIndex = 0, mask = (1 << 1);
         portIndex < DeviceData->NumberOfPorts;
         portIndex++, mask <<= 1)
    {
        // Read the current port status
        //
        portStatus = ReadPortStatusFix(DeviceData, portIndex);

        // Keep only the current port status change bits
        //
        portStatus &= (HcRhPS_ConnectStatusChange |
                       HcRhPS_PortEnableStatusChange |
                       HcRhPS_PortSuspendStatusChange |
                       HcRhPS_OverCurrentIndicatorChange |
                       HcRhPS_PortResetStatusChange);

        if (portStatus)
        {
            changes |= mask;
        }

        LOGENTRY(G, 'prtS', changes, portStatus, portIndex);
    }

    // Read the current status of the hub itself
    //
    portStatus = READ_REGISTER_ULONG(&HC->HcRhStatus);

    // Keep only the current hub status change bits
    //
    portStatus &= (HcRhS_LocalPowerStatusChange |
                   HcRhS_OverCurrentIndicatorChange);

    if (portStatus)
    {
        changes |= 1;   // Bit 0 is for the hub itself.
    }

    return changes;
}


void
EmulateRootHubInterruptXfer(
    PHCD_DEVICE_DATA DeviceData,
    PHC_OPERATIONAL_REGISTER HC
)
/*++
Routine Description:
   Emulates an interupt pipe to the Root Hubs #1 Endpoint.
   
   We Pop an entry off of the URB request queue and satisfy 
   it with the current state of the Root hub status registers.
   If there is no outstanding request then disable this 
   interrupt.

--*/
{
    PHCD_ENDPOINT Endpoint = DeviceData->RootHubInterrupt;
    PLIST_ENTRY entry;
    KIRQL oldIrql;
    PHCD_URB UsbRequest;
    ULONG changes;
    PCHAR buffer;
    PDRIVER_CANCEL oldCancel;
    struct _URB_HCD_COMMON_TRANSFER *trans;

    // mask off the interrupt status change
    WRITE_REGISTER_ULONG(&HC->HcInterruptStatus, HcInt_RootHubStatusChange);

    // Get a bitmap of the current root hub status changes
    //
    changes = OpenHCI_BuildRootHubStatusChange(DeviceData, HC);

    if (0 == changes) {
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_RH_TRACE,
                        ("'RH Interrupt no change \n\n"));
        return;
    }
    KeAcquireSpinLock(&Endpoint->QueueLock, &oldIrql);
    if (IsListEmpty(&Endpoint->RequestQueue)) {
    
        // disable interrupts for rh status change
        
        WRITE_REGISTER_ULONG(&HC->HcInterruptDisable, 
                             HcInt_RootHubStatusChange);
                             
        KeReleaseSpinLock(&Endpoint->QueueLock, oldIrql);

        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_RH_ERROR,
                        ("'*******WARNING*****\n"));
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_RH_ERROR,
                        ("'!!! RH Interrupt no IRP QUEUED \n"));
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_RH_ERROR,
                        ("'Disable RH interrupt\n"));
        return;
    }
    entry = RemoveHeadList(&Endpoint->RequestQueue);
    KeReleaseSpinLock(&Endpoint->QueueLock, oldIrql);

    UsbRequest = CONTAINING_RECORD(entry,
                                   HCD_URB,
                                   HcdUrbCommonTransfer.hca.HcdListEntry);
    trans = &UsbRequest->HcdUrbCommonTransfer;

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_RH_TRACE,
                    ("'RH Interrupt completing URB %x\n", UsbRequest));

    if (trans->TransferBufferLength &&
        (buffer = MmGetSystemAddressForMdl(trans->TransferBufferMDL)) != NULL)
    {
        RtlCopyMemory(buffer, &changes, trans->TransferBufferLength);
    }
    else
    {
        ASSERT(0);
    }
    trans->Status = USBD_STATUS_SUCCESS;
    if (0 == trans->UrbLink) {
        oldCancel = IoSetCancelRoutine(trans->hca.HcdIrp, NULL);
        if (oldCancel) {
            OpenHCI_CompleteIrp(DeviceData->DeviceObject,
                                trans->hca.HcdIrp,
                                USBD_STATUS_SUCCESS);
        }
    }
}


NTSTATUS
CheckRootHub(PHCD_DEVICE_DATA DeviceData,
             PHC_OPERATIONAL_REGISTER HC,
             PHCD_URB UsbRequest
)
/*++
Routine Description:
    before an interrupt transfer is queued this function checks the change
    bits in the root hub registers, if any are set the it processes the request 
    immediately.
--*/
{
    PHCD_ENDPOINT Endpoint = DeviceData->RootHubInterrupt;
    ULONG changes;
    PCHAR buffer;
    PDRIVER_CANCEL oldCancel;
    struct _URB_HCD_COMMON_TRANSFER *trans;

    // Get a bitmap of the current root hub status changes
    //
    changes = OpenHCI_BuildRootHubStatusChange(DeviceData, HC);

    if (0 == changes) {
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_RH_TRACE,
                        ("'RH Interrupt no change \n\n"));
                                
        return STATUS_PENDING;
    }
    
    trans = &UsbRequest->HcdUrbCommonTransfer;

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_RH_TRACE,
                    ("'RH Interrupt completing URB %x\n", UsbRequest));

    if (trans->TransferBufferLength &&
        (buffer = MmGetSystemAddressForMdl(trans->TransferBufferMDL)) != NULL)
    {
        RtlCopyMemory(buffer, &changes, trans->TransferBufferLength);
    } 
    else
    {
        ASSERT(0);
    }
    trans->Status = USBD_STATUS_SUCCESS;
    if (0 == trans->UrbLink) {
        oldCancel = IoSetCancelRoutine(trans->hca.HcdIrp, NULL);
        // complete the request
        return STATUS_SUCCESS;
    }

    return STATUS_PENDING;
}


void
OpenHCI_CancelRootInterrupt(
                            PDEVICE_OBJECT DeviceObject,
                            PIRP Irp
)
/*++
Routine Description:
   cancel an Irp queued for Interrupt Transfer.

Args:
   DeviceObject the object to which the irp was originally directed.
   Irp the poor doomed packet.

--*/
{
    PHCD_DEVICE_DATA DeviceData;
    PHCD_ENDPOINT Endpoint;
    KIRQL oldIrql;
    BOOLEAN lastURB;
    struct _URB_HCD_COMMON_TRANSFER *Trans;

    DeviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    ASSERT(TRUE == Irp->Cancel);

    Trans = &((PHCD_URB) URB_FROM_IRP(Irp))->HcdUrbCommonTransfer;
    ASSERT(URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER == Trans->Function);

    LOGENTRY(G, 'rCan', Irp, Trans, Trans->Status);

    Endpoint = Trans->hca.HcdEndpoint;
    ASSERT(Endpoint->EpFlags & EP_ROOT_HUB);

    ASSERT(URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER == Trans->Function);
    ASSERT(Trans->hca.HcdEndpoint == Endpoint);

    ASSERT(Trans->UrbLink == NULL);

    ASSERT(USBD_STATUS_CANCELING != Trans->Status);
    
    if (USBD_STATUS_CANCELED != Trans->Status)
    {
        KeAcquireSpinLock(&Endpoint->QueueLock, &oldIrql);

        // the item may have already been removed 
        if (Trans->hca.HcdListEntry.Flink != NULL)
        {
            OHCI_ASSERT(Trans->hca.HcdListEntry.Blink != NULL);
            RemoveEntryList(&Trans->hca.HcdListEntry);
        }

        Trans->Status = USBD_STATUS_CANCELED;

        KeReleaseSpinLock(&Endpoint->QueueLock, oldIrql);
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    OpenHCI_CompleteIrp(DeviceObject, Irp, STATUS_CANCELLED);
}


ULONG
ReadPortStatusFix(
    PHCD_DEVICE_DATA    DeviceData,
    ULONG               PortIndex
)
/*++
Routine Description:

   Reads a HcRhPortStatus register, working around some known hardware
   bugs in early revs of the AMD K7 chipset.

   When a Port Status read is performed while Viper is mastering the PCI
   bus during ED & TD reads, the Port Status read may return either all
   '0's or an address of an ED or TD (upper bits will match the HcHCCA
   base address).

   Quick & Dirty fix:

   If a Port status read data has '1's in its upper reserved bits, the
   read is invalid and should be discarded.  If a Port status read
   returns all '0's, then it is safe to read it a few more times, and if
   the status is truly 00h, then the reads should all return 00h.
   Otherwise, the 00h was an invalid read and the data which is
   subsequently returned (with '0's in its reserved bits) is valid.

--*/
{
    PULONG  pulRegister;
    ULONG   ulRegVal; 
    int     x;

    pulRegister = &DeviceData->HC->HcRhPortStatus[PortIndex];

    for (x = 0; x < 10; x++)
    {
        ulRegVal = READ_REGISTER_ULONG(pulRegister);

        if ((ulRegVal) && (!(ulRegVal & HcRhPS_RESERVED)))
        {
            break;
        }
        else
        {
            KeStallExecutionProcessor(5);
        }
    }


#if FAKEPORTCHANGE

#pragma message("NOTE: enabling fake port change hack")

    if (DeviceData->FakePortChange & (1 << PortIndex))
    {
        ulRegVal |= HcRhPS_ConnectStatusChange;
    }

    if (DeviceData->FakePortDisconnect & (1 << PortIndex))
    {
        ulRegVal &= ~HcRhPS_CurrentConnectStatus;
    }

#endif

    return ulRegVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\openhci\ohcixfer.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   ohcixfer.c

Abstract:

   The module manages transactions on the USB.

Environment:

   kernel mode only

Notes:

Revision History:

   03-07-96 : created   jfuller
   03-20-96 : rewritten kenray

--*/

#include "openhci.h"
#define abs(x) ( (0 < (x)) ? (x) : (0 - (x)))

IO_ALLOCATION_ACTION 
OpenHCI_QueueGeneralRequest(PDEVICE_OBJECT,     
                            PIRP, 
                            PVOID, 
                            PVOID);


VOID
OpenHCI_LockAndCheckEndpoint(
    PHCD_ENDPOINT Endpoint,
    PBOOLEAN QueuedTransfers,
    PBOOLEAN ActiveTransfers,
    PKIRQL OldIrql
    )   
/*++

Routine Description:

Arguments:

   Endpoint - pointer to the endpoint for which to perform action                          

Return Value:

   None.

--*/
{
    ASSERT_ENDPOINT(Endpoint);

    LOGENTRY(G, 'lkEP', Endpoint, 0, 0);  
    // see if there are any pending transfers
    KeAcquireSpinLock(&Endpoint->QueueLock, OldIrql);

    if (QueuedTransfers) {
        *QueuedTransfers = !IsListEmpty(&Endpoint->RequestQueue);
    }

    // EndpointStatus is initialized to 0 when the endpoint is opened,
    // incremented every time a request is queued on the hardware, and
    // decremented every time a request is completed off of the hardware.
    // If it is greater than 0 then a request is currently on the
    // hardware.
    //
    if (ActiveTransfers) {
        *ActiveTransfers = Endpoint->EndpointStatus > 0;
    }        

    LOGENTRY(G, 'lkEP', Endpoint, 
        QueuedTransfers ? *QueuedTransfers : 0,
        ActiveTransfers ? *ActiveTransfers : 0);  
    
}


VOID
OpenHCI_UnlockEndpoint(
    PHCD_ENDPOINT Endpoint,
    KIRQL Irql
    )   
/*++

Routine Description:

Arguments:

   Endpoint - pointer to the endpoint for which to perform action

Return Value:

   None.

--*/
{
    ASSERT_ENDPOINT(Endpoint);
    
    // see if there are any pending transfers
    KeReleaseSpinLock(&Endpoint->QueueLock, Irql);

    LOGENTRY(G, 'ukEP', Endpoint, 0, 0);  
}


VOID
OpenHCI_ProcessEndpoint(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_ENDPOINT Endpoint
    )   
/*++

Routine Description:

    Either calls ep worker or puts the ep on a list
    to be processed later

Arguments:

   Endpoint - pointer to the endpoint for which to perform action

Return Value:

   None.

--*/
{
    KIRQL irql;

    KeAcquireSpinLock(&DeviceData->HcDmaSpin, &irql);
    DeviceData->HcDma++;        

    if (DeviceData->HcDma) {
        // ep worker is busy
        LOGENTRY(G, 'wkBS', Endpoint, 0, 0);

        // put the ep in the list only once
        if (!(Endpoint->EpFlags & EP_IN_ACTIVE_LIST)) {
            InsertTailList(&DeviceData->ActiveEndpointList, 
                           &Endpoint->EndpointListEntry);
            SET_EPFLAG(Endpoint, EP_IN_ACTIVE_LIST);                       
        }            
        KeReleaseSpinLock(&DeviceData->HcDmaSpin, irql);     
    } else {
        LOGENTRY(G, 'wkNB', Endpoint, 0, 0);
        KeReleaseSpinLock(&DeviceData->HcDmaSpin, irql);  

        OpenHCI_EndpointWorker(Endpoint);        
    }

    KeAcquireSpinLock(&DeviceData->HcDmaSpin, &irql);
    DeviceData->HcDma--;        
    KeReleaseSpinLock(&DeviceData->HcDmaSpin, irql); 
}
                            

VOID
OpenHCI_EndpointWorker(
    PHCD_ENDPOINT Endpoint
    )   
/*++

Routine Description:

   formerly "StartEndpoint"
   
   Worker function that drives an endpoint...
   Dequeues a URB from an endpoint's queue and programs the DMA transfer
   on the controller thru Qgeneral request.

Arguments:

   Endpoint - pointer to the endpoint for which to perform action

Return Value:

   None.

--*/
{
    PHCD_DEVICE_DATA DeviceData;
    PHCD_URB urb;
    KIRQL oldIrql;
    NTSTATUS ntStatus;
    ULONG numberOfMapEntries;
    PLIST_ENTRY entry;
    LONG endpointStatus = 0;
    struct _URB_HCD_COMMON_TRANSFER *transfer;
    PIRP irp;
    BOOLEAN queuedTransfers;

    DeviceData = Endpoint->DeviceData;
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE, ("'enter EW\n"));

    LOGENTRY(G, 'EPwk', Endpoint, Endpoint->EndpointStatus, Endpoint->MaxTransfer);
    LOGIRQL();

    if (Endpoint->MaxRequest == Endpoint->EndpointStatus) {
        // if > 0 then we have programmed all the requests possible
        // to the hardare
        LOGENTRY(G, 'EPbs', Endpoint, Endpoint->EndpointStatus, 0);       
        OpenHCI_KdPrintDD(DeviceData, 
                          OHCI_DBG_TD_NOISE, ("' Endpoint busy!\n"));
    } else {

        //
        // endpoint not busy, see if we can queue a tranfer to the controller
        //
    
        do {
            OpenHCI_LockAndCheckEndpoint(Endpoint, 
                                         &queuedTransfers,
                                         NULL,                         
                                         &oldIrql);
                                         
            if (!queuedTransfers) {
                LOGENTRY(G, 'EQmt', Endpoint, 0, 0);
                OpenHCI_KdPrintDD(DeviceData, 
                                  OHCI_DBG_TD_NOISE, ("'queue empty\n"));
                
                OpenHCI_UnlockEndpoint(Endpoint, oldIrql);
                
                // nothing to do
                break;
            } 
            
            entry = RemoveHeadList(&Endpoint->RequestQueue);
            urb = CONTAINING_RECORD(entry,
                                   HCD_URB,
                                   HcdUrbCommonTransfer.hca.HcdListEntry);
                                   
            transfer = &urb->HcdUrbCommonTransfer;
            transfer->hca.HcdListEntry.Flink = NULL;
            transfer->hca.HcdListEntry.Blink = NULL;
            // one more request to the hardware
            endpointStatus = InterlockedIncrement(&Endpoint->EndpointStatus);   
            OpenHCI_UnlockEndpoint(Endpoint, oldIrql);

            LOGENTRY(G, 'dQTR', transfer, endpointStatus, Endpoint);
            LOGIRQL();
            irp = transfer->hca.HcdIrp;

            //
            // check for a canceled irp, this handles the case where
            // the irp is canceled after being removed from the endpoint
            // queue but before we get a chance to program it to the
            // hardawre
            //
            
            IoAcquireCancelSpinLock(&oldIrql);

            if (irp->Cancel)
            {
                //
                // If we got the URB here, then it was poped off the request
                // list. Therefore it must have been cancelled right after it 
                // was poped.
                // (If it was canceled before than then the cancel routine
                // would have removed it from the queue.)
                //
                // Therefore, the cancel routine did not complete the IRP so
                // we must do it now.
                //
                
                OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE,
                                  ("' Removing cancelled URB %x\n", urb));
                LOGENTRY(G, 'Ican', irp, transfer, Endpoint);                                  
                ASSERT(urb->UrbHeader.Status == HCD_PENDING_STATUS_QUEUED);
                transfer->Status = USBD_STATUS_CANCELED;

                //
                // complete the irp
                //

                IoSetCancelRoutine(transfer->hca.HcdIrp, NULL);
                
                IoReleaseCancelSpinLock(oldIrql);
                if (0 == transfer->UrbLink) {
                    OpenHCI_CompleteIrp(Endpoint->DeviceData->DeviceObject,
                                        irp,
                                        STATUS_CANCELLED);
                }
                
                endpointStatus = 
                    InterlockedDecrement(&Endpoint->EndpointStatus);
                LOGENTRY(G, 'dcS2', 0, Endpoint, endpointStatus);                     
                OHCI_ASSERT(endpointStatus >= 0);
#if DBG
                if (Endpoint->MaxRequest == 1) {
                    // in limit xfer mode we should  always be 0 here.
                    OHCI_ASSERT(endpointStatus == 0);
                }
#endif                
                continue;
            }
            else
            {
                urb->UrbHeader.Status = HCD_PENDING_STATUS_SUBMITTING;

                // The request needs to pass through IoAllocateAdapterChannel()
                // before it gets to OpenHCI_QueueGeneralRequest().  Until the
                // request makes it through to OpenHCI_QueueGeneralRequest(), we
                // can't cancel the request so clear the cancel routine.
                //
                IoSetCancelRoutine(transfer->hca.HcdIrp, NULL);

                IoReleaseCancelSpinLock(oldIrql);
            }

            //
            // map the transfer
            //
            LOGENTRY(G, 'MAPt', transfer, transfer->TransferBufferLength, 0); 
            if (transfer->TransferBufferLength != 0) {
                numberOfMapEntries = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                    MmGetMdlVirtualAddress(transfer->TransferBufferMDL),
                                           transfer->TransferBufferLength);
            } else {
                numberOfMapEntries = 0; // no data ==> no map registers, no
                                        // MDL
                ASSERT(NULL == transfer->TransferBufferMDL);
            }
            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE,
                              ("'EW: submitting URB %08x\n", urb));
            LOGENTRY(G, 'MAPr', urb, numberOfMapEntries, 0);                            

            KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
            ntStatus = IoAllocateAdapterChannel(DeviceData->AdapterObject,
                                                DeviceData->DeviceObject,
                                                numberOfMapEntries,
                                                OpenHCI_QueueGeneralRequest,
                                                urb);
            KeLowerIrql(oldIrql);

            LOGENTRY(G, 'ALch', urb, ntStatus, oldIrql);
            
            if (!NT_SUCCESS(ntStatus)) {
                // FUTURE ISSUE:
                // Figure out what to do when IoAllocateAdapterChannel fails.
                // This should only happen when NumberOfMapRegisters is too big,
                // which should only happen when "map registers" actually do
                // anything.  This should only ever be an issue on >4GB PAE
                // machines.
                //
                // To really address this possible issue, when starting a
                // request compare the number of map registers needed for the
                // request against the number of map registers returned by
                // IoGetDmaAdapter.  If more than the available number are
                // necessary then the request needs to be split up somehow.
                //
                OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_ERROR,
                                  ("'EW: IoAllocateAdapterChannel: %d\n", 
                                  ntStatus));
                TRAP();          // Failed IoAdapter Channel
            }
        } while (Endpoint->MaxRequest > endpointStatus);
        
        //
        // EndpointStatus is now zero based, not -1 based so the rest of the
        // comment below is not quite correct...
        //
        // We allow for two outstanding transfers on the endpoint at a time.
        // These are accounted by EndpointStatus = -1 and = 0.  When
        // we have two transfers actually turned into TD's (via the
        // Queue General Request) then we stop until EndpointWorker is
        // called again.
        //
    }

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE, ("'exit EW\n"));
    LOGENTRY(G, 'EPw>', Endpoint, 0, 0);
    LOGIRQL();
}


VOID
OpenHCI_SetTranferError(
    PHCD_URB Urb,
    USBD_STATUS usbdStatus
    )
{    
    struct _URB_HCD_COMMON_TRANSFER *transfer;
    
    transfer = &Urb->HcdUrbCommonTransfer;
    while (Urb != NULL) {
        Urb->UrbHeader.Status = usbdStatus;
        transfer->TransferBufferLength = 0;
        // 0 => nothing xfered
        Urb = transfer->UrbLink;
        transfer = &Urb->HcdUrbCommonTransfer;
    }
    
}


NTSTATUS
OpenHCI_QueueTransfer(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
/*++

Routine Description:

   formerly "StartTransfer" 
   Queues transfers to endpoint, called from the process URB function.

Arguments:

   DeviceObject - pointer to a device object

   Irp - pointer to an I/O Request Packet with transfer type URB

Return Value:

   returns STATUS_PENDING if the request is succesfully queued otherwise
    an error is returned.

    NOTE: if an error is returned we expect the IRP to be completed by the 
        caller

--*/
    PHCD_DEVICE_DATA DeviceData;
    PHC_OPERATIONAL_REGISTER HC;
    PHCD_URB urb;
    PHCD_ENDPOINT endpoint;
    NTSTATUS ntStatus = STATUS_PENDING;
    KIRQL oldIrql, oldIrql2;
    struct _URB_HCD_COMMON_TRANSFER *transfer;

    DeviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    OpenHCI_KdPrintDD(DeviceData, 
                      OHCI_DBG_TD_TRACE, ("'enter StartTransfer\n"));

    urb = (PHCD_URB) URB_FROM_IRP(Irp);
    transfer = &urb->HcdUrbCommonTransfer;

    transfer->hca.HcdIrp = Irp;
    endpoint = transfer->hca.HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);
    LOGENTRY(G, 'Xfer', transfer, endpoint, Irp);
    LOGIRQL();

    HC = DeviceData->HC;

    if (READ_REGISTER_ULONG(&HC->HcRevision.ul) == 0xFFFFFFFF)
    {
        OpenHCI_KdPrint((0, "'QueueTransfer, controller not there!\n"));

        ntStatus = STATUS_DEVICE_DOES_NOT_EXIST;

        OpenHCI_SetTranferError(urb, USBD_STATUS_REQUEST_FAILED);

        goto OpenHCI_QueueTransfer_Done;
    }

    //
    // Check for Root Hub transfers
    //
    if (endpoint->EpFlags & EP_ROOT_HUB) {

        ntStatus = OpenHCI_RootHubStartXfer(DeviceObject,
                                            DeviceData,
                                            Irp,
                                            urb,
                                            endpoint);

        ASSERT(urb->HcdUrbCommonTransfer.UrbLink == NULL);
            
        goto OpenHCI_QueueTransfer_Done;
    }

    
    //
    // This is an ordinary transfer
    //

    // first some parameter validation
    
    if (USB_ENDPOINT_TYPE_ISOCHRONOUS == endpoint->Type) {
    
        // Test to make sure that the start of Frame is within a
        // #define 'd range.

        if (USBD_START_ISO_TRANSFER_ASAP &
            urb->UrbIsochronousTransfer.TransferFlags) {
            OpenHCI_KdPrintDD(DeviceData, 
                OHCI_DBG_TD_TRACE, ("'ASAP ISO\n"));
            LOGENTRY(G, 'qASA', transfer, endpoint, Irp);
            
        } else if (abs((LONG) (urb->UrbIsochronousTransfer.StartFrame
                       - Get32BitFrameNumber(DeviceData)))
                   > USBD_ISO_START_FRAME_RANGE) {  

            OpenHCI_KdPrintDD(DeviceData, 
                              OHCI_DBG_TD_ERROR, ("'Bad start Frame\n"));
            LOGENTRY(G, 'BADs', transfer, endpoint, Irp);
            OpenHCI_KdBreak(("Bad Start Frame\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            OpenHCI_SetTranferError(urb, USBD_STATUS_BAD_START_FRAME);
            
            goto OpenHCI_QueueTransfer_Done;
        }
    }
    
    // We were told during open what the largest number of bytes transfered 
    // per URB were going to be.  Fail if this transfer is greater than that
    // given number.
    
    if (transfer->TransferBufferLength > endpoint->MaxTransfer) { 
    
        OpenHCI_KdPrintDD(DeviceData, 
                          OHCI_DBG_TD_ERROR, ("'Max Trans exceeded\n"));
        LOGENTRY(G, 'BADt', transfer, transfer->TransferBufferLength, Irp);

        ntStatus = STATUS_INVALID_PARAMETER;
        OpenHCI_SetTranferError(urb, USBD_STATUS_INVALID_PARAMETER);
        
        goto OpenHCI_QueueTransfer_Done;            
    }

    //
    // OK to queue the transfer, grab the queue lock and queue 
    // the transfer to the endpoint.
    //

    // Must acquire spinlocks in the same order as OpenHCI_CancelTransfer(),
    // which is called with the cancel spinlock already held and then it
    // acquires the endpoint QueueLock spinlock.
    //
    IoAcquireCancelSpinLock(&oldIrql2);

    KeAcquireSpinLock(&endpoint->QueueLock, &oldIrql);

    if (Irp->Cancel) {
        // cancel it now
        ntStatus = STATUS_CANCELLED;
        IoSetCancelRoutine(Irp, NULL); 
        OpenHCI_SetTranferError(urb, USBD_STATUS_CANCELED);
        LOGENTRY(G, 'Qcan', transfer, endpoint, Irp);
        
    } else if (endpoint->EpFlags & EP_CLOSED) {
    
        // we should not see this,
        // it means we got a transfer after the 
        // endpoint was closed
        
        TEST_TRAP();
        ntStatus = STATUS_TRANSACTION_ABORTED;
        IoSetCancelRoutine(Irp, NULL); 
        OpenHCI_SetTranferError(urb, USBD_STATUS_CANCELED);
        LOGENTRY(G, 'epcl', transfer, endpoint, Irp);
        
    } else {
        //
        // not closed, queue the transfer
        //

        while (urb != NULL) {

            LOGENTRY(G, 'qURB', urb, endpoint, Irp);
            ASSERT(endpoint == transfer->hca.HcdEndpoint);
            
            InitializeListHead(&transfer->hca.HcdListEntry2);
            urb->UrbHeader.Status = HCD_PENDING_STATUS_QUEUED;
            InsertTailList(&endpoint->RequestQueue, 
                           &transfer->hca.HcdListEntry);
            
            urb = transfer->UrbLink;
            transfer = &urb->HcdUrbCommonTransfer;
            
        }

        Irp->IoStatus.Status = STATUS_PENDING;
        IoMarkIrpPending(Irp);

        ASSERT(Irp->Cancel == FALSE);
        LOGENTRY(G, 'IPRX', urb, endpoint, Irp);
        IoSetCancelRoutine(Irp, OpenHCI_CancelTransfer); 
        
    }

    KeReleaseSpinLock(&endpoint->QueueLock, oldIrql);

    IoReleaseCancelSpinLock(oldIrql2);

    //
    // attempt to start this transfer
    //
    OpenHCI_ProcessEndpoint(DeviceData, endpoint);

OpenHCI_QueueTransfer_Done:
    LOGENTRY(G, 'XfrD', transfer, endpoint, Irp);
    LOGIRQL();

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE,
                      ("'exit OpenHCI_StartTransfer with status = %x\n",
                      ntStatus));

    return ntStatus;
}

#define INITIALIZE_TD(td, ep, urb) \
    {\
    td->UsbdRequest = (PHCD_URB)(urb);\
    td->Endpoint = (ep);\
    td->Canceled = FALSE;\
    td->TransferCount = 0; \
    td->HcTD.Control = 0; \
    td->HcTD.CBP = 0;\
    td->HcTD.BE = 0;\
    }

#define OHCI_PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(OHCI_PAGE_SIZE - 1)))    


ULONG
GetLengthToMap(
    PUCHAR BaseVa,
    ULONG StartOffset,
    ULONG RequestLength
    )
{
    ULONG pgBreakOffset, length;
    
    //
    // see how far it is to the next page boundry
    //

    LOGENTRY(G, 'GLM0', BaseVa, StartOffset, RequestLength);

    pgBreakOffset = (ULONG)(((PUCHAR) OHCI_PAGE_ALIGN(BaseVa+StartOffset) + \
        OHCI_PAGE_SIZE) - (BaseVa));
        
    //
    // compute length to map 
    //
    
    if (StartOffset + RequestLength > pgBreakOffset) {
        length = pgBreakOffset - StartOffset;
    } else {
        length = RequestLength;
    }

    LOGENTRY(G, 'GLM1', pgBreakOffset, length, 0);

    return length;
}    


PVOID
OpenHCI_MapTransferToTD(
    PHCD_DEVICE_DATA DeviceData,
    PMAP_CONTEXT MapContext,
    ULONG TotalLength,
    PUCHAR BaseVa,
    PHCD_ENDPOINT Endpoint,
    PHCD_TRANSFER_DESCRIPTOR Td,
    struct _URB_HCD_COMMON_TRANSFER *Transfer,
    PUCHAR CurrentVa,
    PULONG LengthMapped1stPage,
    PULONG LengthMapped
    )
/*++

Routine Description:

    Maps a data buffer to TDs according to OHCI rules

    An OHCI TD can cover up to 8k with a single page crossing.


Arguments:

   DeviceObject - pointer to a device object

   Irp - pointer to an I/O Request Packet (ignored)

   LengthMapped - how much is mapped so far
   
   CurrentVa - current virtual address of buffer described by MDL

   returns
   LengthMapped1stPage - number of bytes in the first mapped page

   LengthMapped - total data mapped so far

Return Value:

    updated CurrentVa


--*/
{
    PVOID mapRegisterBase;
    BOOLEAN input;
    PHYSICAL_ADDRESS logicalStart;
    PHYSICAL_ADDRESS logicalEnd;
    ULONG length, lengthThisTD, lengthToMap, remainder;
#if DBG
    ULONG requestLength;
#endif
    
    mapRegisterBase = Transfer->hca.HcdExtension;
    input = (BOOLEAN) (Transfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);
    lengthToMap = Transfer->TransferBufferLength - (*LengthMapped);

    OHCI_ASSERT(lengthToMap > 0);

    // A TD can have up to one page crossing.  This means we need
    // to call IoMapTransfer twice, once for the first physical
    // page, and once for the second.

    // Also
    // IoMapTransfer may return us more than one page if the
    // buffer if physically contiguous we need to make sure 
    // we only call IoMapTranfer for enough bytes up to the next 
    // page boundry
    
    //
    // map first page

    length = GetLengthToMap(BaseVa,
                            *LengthMapped,
                            lengthToMap);
                            
    LOGENTRY(G, 'Mp1r', Transfer, length, CurrentVa); 

#if DBG
    requestLength = length;
#endif

    logicalStart = OpenHCI_IoMapTransfer(
                                 MapContext,
                                 DeviceData->AdapterObject,
                                 Transfer->TransferBufferMDL,
                                 mapRegisterBase,
                                 CurrentVa,
                                 &length,
                                 TotalLength,
                                 (BOOLEAN) !input);

#if DBG
    // since we always compute the length to start on or before 
    // the next page break we should always get what we ask for
    OHCI_ASSERT(requestLength == length);
#endif

    // length is how much we mapped
    
    CurrentVa += length;
    (*LengthMapped) += length;
    lengthThisTD = length;
    lengthToMap -= length;
    if (LengthMapped1stPage) {
        *LengthMapped1stPage = length;
    }
    
    LOGENTRY(G, 'Mp1d', Transfer, length, logicalStart.LowPart);  

    // see if we have more buffer to map
   
    if (lengthToMap) {

        // yes,
        // map second page

        length = GetLengthToMap(BaseVa,
                                *LengthMapped,
                                lengthToMap);

        LOGENTRY(G, 'Mp2r', Transfer, length, CurrentVa); 

        // if this is not the last TD of the transfer then we need
        // to ensure that this TD ends on a max packet boundry.
        //
        // ie we may map more than we can use, we will adjust 
        // the length  
        //
        // lengthToMap will be zero if this is the last TD

        lengthThisTD += length;
        lengthToMap -= length;
        remainder = lengthThisTD % Endpoint->MaxPacket;
        
        if (remainder > 0 && lengthToMap) {
            // make the adjustment
            lengthThisTD -= remainder;
            length -= remainder;
            lengthToMap += remainder;
            LOGENTRY(G, 'Mrem', Transfer, length, remainder);  
        }

#if DBG
        requestLength = length;
#endif
        logicalEnd = OpenHCI_IoMapTransfer(
                                   MapContext,
                                   DeviceData->AdapterObject, 
                                   Transfer->TransferBufferMDL,
                                   mapRegisterBase,
                                   CurrentVa,
                                   &length,
                                   TotalLength,
                                   (BOOLEAN)!input);

#if DBG
        // since we always compute the length to start on or before 
        // the next page break we should always get what we ask for
        OHCI_ASSERT(requestLength == length);
#endif
        CurrentVa += length;
        (*LengthMapped) += length;                                    

        LOGENTRY(G, 'Mp2d', Transfer, length, logicalEnd.LowPart);  

    } else {
        logicalEnd = logicalStart;
    }

    LOGENTRY(G, 'MpT1', Transfer, *LengthMapped, lengthToMap); 
    
    ASSERT(*LengthMapped + lengthToMap == Transfer->TransferBufferLength);

    logicalEnd.LowPart += length;

    // now we check to see if the mapped length is a multiple of
    // maxpacket size

    // buffer has been mapped, now set up the TD
    Td->HcTD.CBP = logicalStart.LowPart; 
    // buffer end points to last byte in the buffer
    Td->HcTD.BE = logicalEnd.LowPart-1; 
    Td->TransferCount = lengthThisTD;
    
    LOGENTRY(G, 'MpTD', Td->HcTD.CBP, Td->HcTD.BE, lengthThisTD); 
    LOGENTRY(G, 'MPTD', Td, 0, 0); 

    return CurrentVa;
}


VOID
OpenHCI_ControlTransfer(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_ENDPOINT Endpoint,
    PHCD_URB Urb,
    struct _URB_HCD_COMMON_TRANSFER *Transfer
    )
/*++

Routine Description:


Arguments:

Return Value:


--*/
{
    PHCD_TRANSFER_DESCRIPTOR td, lastTD = NULL;
    MAP_CONTEXT mapContext;
//    PHCD_TRANSFER_DESCRIPTOR tailTD;
    ULONG lengthMapped;
    PUCHAR currentVa, baseVa;
    // first data packet is always data1
    ULONG toggleForDataPhase = HcTDControl_TOGGLE_DATA1;
    ULONG dataTDcount = 0;
    
    //
    // first prepare a TD for the setup packet
    //
    LOGENTRY(G, 'CTRp', Endpoint, Transfer, Transfer->hca.HcdIrp);
    RtlZeroMemory(&mapContext, sizeof(mapContext));

    if (Transfer->TransferBufferLength) {
        baseVa = currentVa = MmGetMdlVirtualAddress(Transfer->TransferBufferMDL);
    }        
    
    // grab the dummy TD from the tail of the queue
    lastTD = td = Endpoint->HcdTailP;
    
    OHCI_ASSERT(td);
    INITIALIZE_TD(td, Endpoint, Urb);
    InsertTailList(&Transfer->hca.HcdListEntry2, &td->RequestList);
    
    //
    // Move setup data into TD (8 chars long)
    //
    *((PLONGLONG) &td->HcTD.Packet[0])
            = *((PLONGLONG) &Transfer->Extension.u.SetupPacket[0]);
            
    td->HcTD.CBP = (ULONG)(((PCHAR) & td->HcTD.Packet[0])
                               - ((PCHAR) &td->HcTD)) + td->PhysicalAddress;
    td->HcTD.BE = td->HcTD.CBP + 7;
    td->HcTD.Control = 
        HcTDControl_DIR_SETUP |
        HcTDControl_TOGGLE_DATA0 |
        HcTDControl_INT_DELAY_NO_INT |
        (HcCC_NotAccessed << HcTDControl_CONDITION_CODE_SHIFT);
        
    OpenHCI_KdPrintDD(DeviceData, 
                      OHCI_DBG_TD_NOISE, ("'SETUP TD 0x%x \n", td));
    LOGENTRY(G, 'setP', 
             td, 
             *((PLONG) &Transfer->Extension.u.SetupPacket[0]), 
             *((PLONG) &Transfer->Extension.u.SetupPacket[4]));

    // allocate another TD       
    lastTD = td;
    td = OpenHCI_Alloc_HcdTD(DeviceData);
    OHCI_ASSERT(td);
    INITIALIZE_TD(td, Endpoint, Urb);
    InsertTailList(&Transfer->hca.HcdListEntry2, &td->RequestList);
    
    lastTD->NextHcdTD = td;
    lastTD->HcTD.NextTD = td->PhysicalAddress;

    //
    // now setup the data phase
    //

    lengthMapped = 0;
    while (lengthMapped < Transfer->TransferBufferLength) {
        //
        // fields for data TD
        //

        dataTDcount++;
        
        td->HcTD.Control = 
            HcTDControl_INT_DELAY_NO_INT |
            (HcCC_NotAccessed << HcTDControl_CONDITION_CODE_SHIFT) |
            ((Transfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN) ?
                HcTDControl_DIR_IN :
                HcTDControl_DIR_OUT);

        td->HcTD.Control |= toggleForDataPhase;                 

        //after the first TD get the toggle from ED                                     
        toggleForDataPhase = HcTDControl_TOGGLE_FROM_ED;
        
        LOGENTRY(G, 'data', td, lengthMapped, Transfer->TransferBufferLength);

        currentVa = OpenHCI_MapTransferToTD(DeviceData,   
                                            &mapContext,
                                            Transfer->TransferBufferLength,
                                            baseVa,
                                            Endpoint,
                                            td,
                                            Transfer,
                                            currentVa,
                                            NULL,
                                            &lengthMapped);

        // allocate another TD                
        lastTD = td;
        td = OpenHCI_Alloc_HcdTD(DeviceData);
        OHCI_ASSERT(td);
        INITIALIZE_TD(td, Endpoint, Urb);
        InsertTailList(&Transfer->hca.HcdListEntry2, &td->RequestList);
    
        lastTD->NextHcdTD = td;
        lastTD->HcTD.NextTD = td->PhysicalAddress;
    }

    //
    // set the shortxfer OK bit on the last TD only
    //
    if (USBD_SHORT_TRANSFER_OK & Transfer->TransferFlags) {
        lastTD->HcTD.ShortXferOk = 1;   
    } 
    
    //
    // now do the status phase
    //

    LOGENTRY(G, 'staP', td, 0, dataTDcount);
#if DBG
    if (dataTDcount > 1) {
        TEST_TRAP();
    }
#endif

    // status direction is opposite data direction,
    // specify interrupt on completion
    
    if (Transfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN) {
        td->HcTD.Control = HcTDControl_DIR_OUT
            | HcTDControl_INT_DELAY_0_MS
            | HcTDControl_TOGGLE_DATA1
            | (HcCC_NotAccessed << HcTDControl_CONDITION_CODE_SHIFT);
    } else {
        td->HcTD.Control = HcTDControl_DIR_IN
            | HcTDControl_INT_DELAY_0_MS
            | HcTDControl_TOGGLE_DATA1
            | (HcCC_NotAccessed << HcTDControl_CONDITION_CODE_SHIFT);
        td->HcTD.ShortXferOk = 1;            
    }
        
    //
    // now put a new dummy TD on the tail of the EP queue
    //

    OpenHCI_KdPrintDD(DeviceData, 
                      OHCI_DBG_TD_NOISE, ("'STATUS TD 0x%x \n", td));
     
    // allocate a new tail
    lastTD = td;
    td = OpenHCI_Alloc_HcdTD(DeviceData);
    OHCI_ASSERT(td);
    INITIALIZE_TD(td, Endpoint, Urb);
    
    lastTD->NextHcdTD = td;
    lastTD->HcTD.NextTD = td->PhysicalAddress;

    //
    // Set new TailP in ED
    // note: This is the last TD in the list and the place holder.
    //
    
    td->UsbdRequest = TD_NOREQUEST_SIG;

     // zero bytes transferred so far
    Transfer->TransferBufferLength = 0;

    Endpoint->HcdTailP = td;
    // put the request on the hardware queue
    LOGENTRY(G, 'cTal',  Endpoint->HcdED->HcED.TailP , td->PhysicalAddress, 0);
    Endpoint->HcdED->HcED.TailP = td->PhysicalAddress;

    // tell the hc we have control transfers available
    ENABLE_LIST(DeviceData->HC, Endpoint);        
}


VOID
OpenHCI_BulkOrInterruptTransfer(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_ENDPOINT Endpoint,
    PHCD_URB Urb,
    struct _URB_HCD_COMMON_TRANSFER *Transfer
    )
/*++

Routine Description:


Arguments:

Return Value:


--*/
{
    PHCD_TRANSFER_DESCRIPTOR td, lastTD = NULL;
    PHCD_TRANSFER_DESCRIPTOR tailTD = NULL;
    ULONG lengthMapped;
    PUCHAR currentVa = NULL, baseVa = NULL;
    MAP_CONTEXT mapContext;
    // first data packet is always data1
    ULONG dataTDcount = 0;

    OHCI_ASSERT(Endpoint->TrueTail == NULL);
    RtlZeroMemory(&mapContext, sizeof(mapContext));
    //
    // first prepare a TD for the setup packet
    //
    LOGENTRY(G, 'BITp', Endpoint, Transfer, Transfer->hca.HcdIrp);

    if (Transfer->TransferBufferLength) {
        baseVa = currentVa = MmGetMdlVirtualAddress(Transfer->TransferBufferMDL);
    }        
    
    // grab the dummy TD from the tail of the queue
    lastTD = td = Endpoint->HcdTailP;
    LOGENTRY(G, 'bitT', lastTD, Endpoint->HcdED->HcED.TailP, 0);
    
    OHCI_ASSERT(td);
    INITIALIZE_TD(td, Endpoint, Urb);
    
    // map the transfer
    
    lengthMapped = 0;
    do  {

        LOGENTRY(G, 'qTR_', Endpoint, Transfer, td);
        InsertTailList(&Transfer->hca.HcdListEntry2, &td->RequestList);
        
        //
        // fields for data TD
        //

        dataTDcount++;
        
        td->HcTD.Control = 
            HcTDControl_INT_DELAY_NO_INT |
            (HcCC_NotAccessed << HcTDControl_CONDITION_CODE_SHIFT) |
            ((Transfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN) ?
                HcTDControl_DIR_IN :
                HcTDControl_DIR_OUT);

        // always interrupt
        td->HcTD.IntDelay = 0;        
        
        // use toggle from ED
        td->HcTD.Control |= HcTDControl_TOGGLE_FROM_ED;                 
        
        LOGENTRY(G, 'datA', td, lengthMapped, Transfer->TransferBufferLength);

        if (Transfer->TransferBufferLength) {
            currentVa = OpenHCI_MapTransferToTD(DeviceData, 
                                                &mapContext,
                                                Transfer->TransferBufferLength,
                                                baseVa,
                                                Endpoint,
                                                td,
                                                Transfer,
                                                currentVa,
                                                NULL,
                                                &lengthMapped);
        }                                                

        // allocate another TD                
        lastTD = td;
        td = OpenHCI_Alloc_HcdTD(DeviceData);
        OHCI_ASSERT(td);
        INITIALIZE_TD(td, Endpoint, Urb);

        if (Endpoint->EpFlags & EP_ONE_TD) {
            LOGENTRY(G, 'limT', td, Endpoint, tailTD);

            lastTD->HcTD.IntDelay = 0;      // interrupt on completion

            lastTD->HcTD.ShortXferOk = 1;   // make sure NEC ACKs short packets  

            if (tailTD == NULL) {
               tailTD = td;                 // next TD after the first TD
            }    
        }
    
        // Set the next pointer of the previous TD to the one we just allocated.
        //
        lastTD->NextHcdTD = td;
        lastTD->HcTD.NextTD = td->PhysicalAddress;
        
    } while (lengthMapped < Transfer->TransferBufferLength);

    //
    // set the shortxfer OK bit on the last TD only
    //
    if (USBD_SHORT_TRANSFER_OK & Transfer->TransferFlags) {
        lastTD->HcTD.ShortXferOk = 1;   
    }        

#ifdef  MAX_DEBUG
    if (dataTDcount > 1) {
        TEST_TRAP();
    }
#endif

    lastTD->HcTD.IntDelay = 0;  // interrupt on completion of last packet

    //
    // now put a new dummy TD on the tail of the EP queue
    //

    //
    // Set new TailP in ED
    // note: This is the last TD in the list and the place holder.
    //
    
    td->UsbdRequest = TD_NOREQUEST_SIG;

    // zero bytes transferred so far
    Transfer->TransferBufferLength = 0;

    if (tailTD != NULL) {
        LOGENTRY(G, 'truT', td, Endpoint->TrueTail, tailTD);
        
        Endpoint->TrueTail = td;            // dummy TD at end of transfer

        td = tailTD;                        // next TD after the first TD
    }

    // Update the software tail pointer
    //
    Endpoint->HcdTailP = td;

    LOGENTRY(G, 'aTAL', td, Endpoint->HcdED->HcED.TailP, td->PhysicalAddress);
    LOGENTRY(G, 'aTL2', td, Endpoint->HcdED->HcED.HeadP, 0);

    // Update hardware tail pointer, putting the request on the hardware queue
    //
    Endpoint->HcdED->HcED.TailP = td->PhysicalAddress;

    // tell the hc we have transfers available
    //
    ENABLE_LIST(DeviceData->HC, Endpoint);        
}

//////////////////////////////////////////////////////////////////////
//                                                                  //
//               START OF ISOCHRONOUS TD BUILDING CODE              //
//                                                                  //
//////////////////////////////////////////////////////////////////////

// These defines are bitmasks of frame case conditions, which are OR'd
// together to enumerate 12 different frame cases.  There are not 16 different
// frame cases since FRAME_CASE_END_AT_PAGE and FRAME_CASE_END_NEXT_PAGE are
// mutually exclusive.

// FRAME_CASE_LAST_FRAME is TRUE if the current frame will fill the eigth and
// final Offset/PSW slot in the current TD.
//
#define FRAME_CASE_LAST_FRAME           1

// FRAME_CASE_START_SECOND_PAGE is TRUE if the current frame starts in the
// second physical page spanned by the current TD.
//
#define FRAME_CASE_START_SECOND_PAGE    2

// FRAME_CASE_END_AT_PAGE is TRUE if the current frame ends exactly at a
// physical page boundary, excluding the case where a zero length frame
// starts and ends at the same physyical page boundary.
//
#define FRAME_CASE_END_AT_PAGE          4

// FRAME_CASE_END_NEXT_PAGE is TRUE if the current frame starts in one physical
// page and ends in another physical page.
//
#define FRAME_CASE_END_NEXT_PAGE        8


//
//                               +-------+                      +-------+
//                            9: | i = 7 |                  11: | i = 7 |
//                               +-------+                      +-------+
//
//                               +-------+                      +-------+
//                            8: | i < 7 |                  10: | i < 7 |
//                               +-------+                      +-------+
//
//            +-------+      +-------+       +-------+      +-------+
//         1: | i = 7 |   5: | i = 7 |    3: | i = 7 |   7: | i = 7 |
//            +-------+      +-------+       +-------+      +-------+
//
//            +-------+      +-------+       +-------+      +-------+
//         0: | i < 7 |   4: | i < 7 |    2: | i < 7 |   6: | i < 7 |
//            +-------+      +-------+       +-------+      +-------+
//
//    +------------------------------+------------------------------+
//    |        First TD Page         |      Second TD Page          |
//    +------------------------------+------------------------------+
//

typedef struct _FRAME_CASE_ACTIONS
{
    // AddFrameToTD == 1, Add frame to TD during first pass
    // AddFrameToTD == 2, Add frame to TD during second pass
    // AddFrameToTD == 3, Add frame to TD during third pass
    //
    UCHAR   AddFrameToTD;

    // AllocNextTD == 0, Don't allocate next TD
    // AllocNextTD == 1, Allocate next TD during first pass
    // AllocNextTD == 2, Allocate next TD during second pass
    //
    UCHAR   AllocNextTD;

    // MapNextPage == 0, Don't map next physical page
    // MapNextPage == 1, Map next physical page during first pass
    // MapNextPage == 2, Map next physical page during second pass
    //
    UCHAR   MapNextPage;

} FRAME_CASE_ACTIONS;


FRAME_CASE_ACTIONS FrameCaseActions[12] =
{
    // AddFrameToTD, AllocNextTD, MapNextPage
    {1,              0,           0},  // case 0
    {1,              1,           0},  // case 1
    {1,              0,           0},  // case 2
    {1,              1,           0},  // case 3
    {1,              0,           1},  // case 4
    {1,              1,           1},  // case 5
    {1,              1,           1},  // case 6
    {1,              1,           1},  // case 7
    {2,              0,           1},  // case 8
    {2,              2,           1},  // case 9
    {3,              1,           2},  // case 10
    {3,              1,           2}   // case 11
};


PHCD_TRANSFER_DESCRIPTOR
OpenHCI_Alloc_IsoTD(
    PHCD_DEVICE_DATA            DeviceData,
    PHCD_ENDPOINT               Endpoint,
    PHCD_TRANSFER_DESCRIPTOR    LastTD
    )
{
    PHCD_TRANSFER_DESCRIPTOR    td;

    td = OpenHCI_Alloc_HcdTD(DeviceData);

    OHCI_ASSERT(td);

    INITIALIZE_TD(td, Endpoint, TD_NOREQUEST_SIG);

    LastTD->NextHcdTD   = td;
    LastTD->HcTD.NextTD = td->PhysicalAddress;

    return td;
}


VOID
OpenHCI_IsoTransfer(
    PHCD_DEVICE_DATA    DeviceData,
    PHCD_ENDPOINT       Endpoint,
    PHCD_URB            Urb,
    struct _URB_HCD_COMMON_TRANSFER *Transfer
    )
{
    PADAPTER_OBJECT     adapterObject;
    PMDL                mdl;
    PVOID               mapRegisterBase;
    PUCHAR              currentVa;
    ULONG               lengthToMap;
    BOOLEAN             writeToDevice;
    ULONG               lengthMapped;
    ULONG               lengthMappedRemaining;
    PHYSICAL_ADDRESS    physAddr;

    struct _URB_ISOCH_TRANSFER  *iso;
    ULONG                       packetIndex;
    ULONG                       frameIndex;
    ULONG                       frameOffset;
    ULONG                       frameLength;
    ULONG                       frameCase;
    ULONG                       framePass;
    ULONG                       framePassNext;
    PHCD_TRANSFER_DESCRIPTOR    td;

    LOGENTRY(G, 'ITRN', Endpoint, Transfer, Transfer->hca.HcdIrp);

    //
    // These values are static across every call to IoMapTranfer()
    //

    adapterObject = DeviceData->AdapterObject;

    mdl = Transfer->TransferBufferMDL;

    mapRegisterBase = Transfer->hca.HcdExtension;

    writeToDevice = !(Transfer->TransferFlags & USBD_TRANSFER_DIRECTION_IN);

    //
    // These values are updated after every call to IoMapTransfer()
    //
    currentVa = MmGetMdlVirtualAddress(mdl);

    lengthToMap = Transfer->TransferBufferLength;

    //
    // select a start frame for the transfer
    //

    iso = (struct _URB_ISOCH_TRANSFER *)Transfer;

    if (USBD_START_ISO_TRANSFER_ASAP & iso->TransferFlags)
    {
        //
        // If the iso packet is set for start asap:
        //
        // If we have had no transfers (ie virgin) then use currentframe + 2,
        // otherwise use the current next frame value from the endpoint.
        //
        if (Endpoint->EpFlags & EP_VIRGIN)
        {
            iso->StartFrame =
                Endpoint->NextIsoFreeFrame =
                Get32BitFrameNumber(DeviceData) + 2;
        }
        else
        {
            iso->StartFrame = Endpoint->NextIsoFreeFrame;
        }
    }
    else
    {
        //
        // absolute frame start specified
        //
        Endpoint->NextIsoFreeFrame = iso->StartFrame;
    }

    if (USBD_TRANSFER_DIRECTION(iso->TransferFlags) ==
        USBD_TRANSFER_DIRECTION_OUT)
    {
        // preset the length fields for OUT transfers
        //
        for (packetIndex=0; packetIndex<iso->NumberOfPackets-1; packetIndex++)
        {
            iso->IsoPacket[packetIndex].Length =
                iso->IsoPacket[packetIndex+1].Offset -
                iso->IsoPacket[packetIndex].Offset;
        }
        iso->IsoPacket[iso->NumberOfPackets-1].Length =
            iso->TransferBufferLength -
            iso->IsoPacket[iso->NumberOfPackets-1].Offset;
    }

    Endpoint->NextIsoFreeFrame += iso->NumberOfPackets;

    CLR_EPFLAG(Endpoint, EP_VIRGIN);


    //
    // Grab the current tail TD from the endpoint to use as the first TD
    // for the transfer.
    //

    td = Endpoint->HcdTailP;

    OHCI_ASSERT(td);

    INITIALIZE_TD(td, Endpoint, TD_NOREQUEST_SIG);

    //
    // Map the initial physically contiguous page(s) of the tranfer
    //

    currentVa   += iso->IsoPacket[0].Offset;
    lengthToMap -= iso->IsoPacket[0].Offset;

    lengthMapped = lengthToMap;

    LOGENTRY(G, 'IMP1', currentVa, lengthToMap, iso->IsoPacket[0].Offset);

    physAddr = IoMapTransfer(adapterObject,
                             mdl,
                             mapRegisterBase,
                             currentVa,
                             &lengthMapped,
                             writeToDevice);

    LOGENTRY(G, 'imp1', physAddr.LowPart, lengthMapped, 0);

    lengthMappedRemaining = lengthMapped;

    currentVa   += lengthMapped;
    lengthToMap -= lengthMapped;

    frameOffset = physAddr.LowPart & HcPSW_OFFSET_MASK;

    packetIndex = 0;
    frameIndex  = 0;
    framePass   = 1;

    //
    // Loop building TDs and mapping pages until the entire transfer
    // buffer has been mapped and built into TDs.
    //

    while (1)
    {
        if (td->HcTD.CBP == 0)
        {
            td->HcTD.CBP = physAddr.LowPart & ~HcPSW_OFFSET_MASK;

            // This is a new TD, so initialize the BaseIsocURBOffset field
            // to the current packet index, and initialize the HcTD.Control
            // with the starting frame number.  The frame count will be
            // filled in later.

            td->BaseIsocURBOffset = (UCHAR)packetIndex;

            td->HcTD.Control = HcTDControl_ISOCHRONOUS |
                               ((iso->StartFrame + packetIndex) &
                                HcTDControl_STARTING_FRAME);

            LOGENTRY(G, 'ITD1', td, td->HcTD.CBP, packetIndex);
            LOGENTRY(G, 'itd1', td->HcTD.StartingFrame, 0, 0);

            // Add this TD to the list of TDs for this request

            InsertTailList(&Transfer->hca.HcdListEntry2,
                           &td->RequestList);

            td->UsbdRequest = (PHCD_URB)Transfer;
        }
        else
        {
            // This is not a new TD, so store the physical address in the
            // second physical address slot of the TD.

            td->HcTD.BE = physAddr.LowPart;

            LOGENTRY(G, 'ITD2', td, td->HcTD.CBP, td->HcTD.BE);
            LOGENTRY(G, 'itd2', packetIndex, td->HcTD.StartingFrame, framePass);

            if (framePass == 1)
            {
                // We are starting a new frame in the second physical page
                // of the current TD.  The second physical page select bit
                // (bit 12) better be set in the current frameOffset.
                //
                OHCI_ASSERT((frameOffset & ~HcPSW_OFFSET_MASK) != 0);
            }
            else
            {
                // We are finishing a frame in the second physical page
                // of the current TD, but the frame started in the first
                // physical page of the current TD.  The second physical
                // page select bit (bit 12) better not be set in the
                // current frameOffset.
                //
                OHCI_ASSERT((frameOffset & ~HcPSW_OFFSET_MASK) == 0);
            }
        }

NextFrame:

        if (framePass == 1)
        {
            // The curent frame length is the difference between the current
            // frame offset and the next frame offset, or between the current
            // frame offset and the transfer buffer length if this is the last
            // frame.

            if (packetIndex == iso->NumberOfPackets - 1)
            {
                frameLength = iso->TransferBufferLength -
                              iso->IsoPacket[packetIndex].Offset;
            }
            else
            {
                frameLength = iso->IsoPacket[packetIndex + 1].Offset -
                              iso->IsoPacket[packetIndex].Offset;
            }

            //
            // Determine which of the twelve cases the current frame is
            // for the current TD.
            //

            frameCase = 0;

            if (frameIndex == 7)
            {
                // The current frame will fill the eigth and final
                // Offset/PSW slot in the current TD.

                frameCase |= FRAME_CASE_LAST_FRAME;
            }

            if (td->HcTD.BE != 0)
            {
                // The current frame starts in the second physical page
                // spanned by the current TD.

                frameCase |= FRAME_CASE_START_SECOND_PAGE;
            }

            if ((frameOffset & ~HcPSW_OFFSET_MASK) !=
                ((frameOffset + frameLength) & ~HcPSW_OFFSET_MASK))
            {
                if (((frameOffset + frameLength) & HcPSW_OFFSET_MASK) == 0)
                {
                    // The current frame ends exactly at a physical page
                    // boundary, excluding the case where a zero length
                    // frame starts and ends at the same physyical page
                    // boundary.

                    frameCase |= FRAME_CASE_END_AT_PAGE;
                }
                else
                {
                    // The current frame starts in one physical page and
                    // ends in another physical page.

                    frameCase |= FRAME_CASE_END_NEXT_PAGE;
                }
            }
        }

        LOGENTRY(G, 'IFM1', packetIndex, frameIndex, frameOffset);

        LOGENTRY(G, 'IFM2', frameLength, frameCase, framePass);

        LOGENTRY(G, 'IFM3', lengthMappedRemaining, 0, 0);

        //
        // Add the current frame to the current TD, if appropriate at this
        // point.
        //

        if (FrameCaseActions[frameCase].AddFrameToTD == framePass)
        {
            // Add the current frame starting offset to the current frame
            // offset slot in the current TD.

            td->HcTD.Packet[frameIndex].PSW = (USHORT)(HcPSW_ONES | frameOffset);

            // Advance past the current frame to the starting offset of the
            // next frame.

            frameOffset += frameLength;

            // Advance to the next frame offset slot in the current TD.

            frameIndex++;

            // Advance to the next frame in the Iso Urb.

            packetIndex++;

            // Decrement the remaining length of the currently mapped chunk
            // of the transfer buffer by the amount we just consumed for the
            // current frame.

            lengthMappedRemaining -= frameLength;

            // Indicate that if the next page is mapped after adding the
            // curent frame to the current TD that IoMapTransfer() should
            // be called only if lengthMappedRemaining is now zero.
            //
            frameLength = 0;

            framePassNext = 1;
        }
        else
        {
            // The current frame will be added after the next page is mapped.
            // The current frame will be added to either the current TD or to
            // a newly allocated TD.  When the next page is mapped before
            // adding the current frame, IoMapTransfer() should be called
            // only if the current frameLength is greater than the current
            // lengthMappedRemaining.

            framePassNext = framePass + 1;
        }

        //
        // Finish off the current TD and allocate the next TD, if appropriate
        // at this point.
        //

        if ((FrameCaseActions[frameCase].AllocNextTD == framePass) ||
            ((lengthMappedRemaining == 0) && (lengthToMap == 0)))
        {
            // If the second physical page of the current TD is not in use,
            // the buffer end physical page is the same as the first physical
            // page of the TD, else the buffer end physical page is the
            // second physical page currently in use.

            if (td->HcTD.BE == 0)
            {
                td->HcTD.BE = td->HcTD.CBP +
                              ((frameOffset - 1) & HcPSW_OFFSET_MASK);
            }
            else
            {
                td->HcTD.BE += (frameOffset - 1) & HcPSW_OFFSET_MASK;
            }

            // The zero-based frameIndex was already incremented after the
            // last frame was added to the current TD, so the zero-based
            // FrameCount for current TD is one less than the current
            // frameIndex.

            td->HcTD.FrameCount = frameIndex - 1;

            LOGENTRY(G, 'ITD3', td->HcTD.CBP, td->HcTD.BE, td->HcTD.FrameCount);

            // Reset the current frameIndex back to zero since we are starting
            // a new TD.

            frameIndex = 0;

            // Wrap the current frameOffset back to the first page since we
            // are starting a new TD.

            frameOffset &= HcPSW_OFFSET_MASK;

            // Allocate another TD

            td = OpenHCI_Alloc_IsoTD(DeviceData, Endpoint, td);
        }

        //
        // If the entire transfer buffer has been mapped and built into TDs,
        // we are done.  This is the exit condition of the while loop.
        //

        if ((lengthMappedRemaining == 0) && (lengthToMap == 0))
        {
            break;  // All Done!
        }

        //
        // Map the next physical page, if appropriate at this point.
        //

        if (FrameCaseActions[frameCase].MapNextPage == framePass)
        {
            if (((frameLength == 0) && (lengthMappedRemaining == 0)) ||
                (frameLength > lengthMappedRemaining))
            {
                // The currently mapped chunk of transfer buffer was either
                // exactly exhausted by the current frame which was already
                // added to a TD, or the remaining currently mapped chunk of
                // the transfer buffer is not sufficient for the current TD
                // and the next chunk of the transfer buffer needs to be
                // mapped before the current frame can be added to a TD.

                lengthMapped = lengthToMap;

                LOGENTRY(G, 'IMP2', currentVa, lengthToMap, lengthMappedRemaining);

                physAddr = IoMapTransfer(adapterObject,
                                         mdl,
                                         mapRegisterBase,
                                         currentVa,
                                         &lengthMapped,
                                         writeToDevice);

                LOGENTRY(G, 'imp2', physAddr.LowPart, lengthMapped, 0);

                lengthMappedRemaining += lengthMapped;

                currentVa   += lengthMapped;
                lengthToMap -= lengthMapped;
            }
            else
            {
                // The currently mapped chunk of the transfer buffer contains
                // the next page.  Advance physAddr to the next page boundary.

                physAddr.LowPart &= ~HcPSW_OFFSET_MASK;
                physAddr.LowPart += HcPSW_OFFSET_MASK + 1;
            }

            // The next physical page address better start on a page
            // boundary.
            //
            OHCI_ASSERT((physAddr.LowPart & HcPSW_OFFSET_MASK) == 0);
        }

        // If we allocated the next TD or mapped the next page, we need
        // to go up to the top of the loop again and initialize the new
        // TD, or set the second physical page of the current TD.
        //
        // If we didn't allocate a new TD or map the next page, we just
        // need to go back up to NextFrame: and finish the current frame
        // or start a new frame

        if ((FrameCaseActions[frameCase].AllocNextTD == framePass) ||
            (FrameCaseActions[frameCase].MapNextPage == framePass))
        {
            framePass = framePassNext;
        }
        else
        {
            framePass = framePassNext;

            goto NextFrame;
        }
    }

    LOGENTRY(G, 'itrn', Transfer, packetIndex, iso->NumberOfPackets);

    //
    // We broke out of the while loop when the entire transfer buffer was
    // mapped and built into TDs.
    //

    // We better have used all of the packets in the Iso Urb
    //
    OHCI_ASSERT(packetIndex == iso->NumberOfPackets);

    iso->ErrorCount = 0;

    // zero bytes transferred so far
    //
    Transfer->TransferBufferLength = 0;

    // Set new TailP in ED
    //
    Endpoint->HcdTailP = td;

    // put the request on the hardware queue
    //
    Endpoint->HcdED->HcED.TailP = td->PhysicalAddress;
}

//////////////////////////////////////////////////////////////////////
//                                                                  //
//                END OF ISOCHRONOUS TD BUILDING CODE               //
//                                                                  //
//////////////////////////////////////////////////////////////////////


IO_ALLOCATION_ACTION
OpenHCI_QueueGeneralRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Invalid,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )
/*++

Routine Description:

   Queues transfers to endpoint, this is an Adapter Control routine
   NOTE: for a given AdapterObject only one instance of an Adapter Control
         routine may be active at any time

   Our mission here is to turn the transfer in to TDs and put them on the 
   controllers queues.

Arguments:

   DeviceObject - pointer to a device object

   Irp - pointer to an I/O Request Packet (ignored)

   MapRegisterBase - handle to system map registers to use

   Context - pointer to URB

Return Value:

   IO_ALLOCATION_ACTION DeallocateObjectKeepRegisters


--*/
{
    PHCD_ENDPOINT endpoint;
    PHCD_DEVICE_DATA DeviceData;
    struct _URB_HCD_COMMON_TRANSFER *transfer;
    PHCD_URB urb;
    KIRQL oldIrql;
    PIRP irp;

    transfer = &((PHCD_URB) Context)->HcdUrbCommonTransfer;
    endpoint = transfer->hca.HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);
    DeviceData = endpoint->DeviceData;
    urb = Context;
    irp = transfer->hca.HcdIrp;
    
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE,
                      ("'e: QueueGeneralRequest urb: %x\n", Context));
    LOGENTRY(G, 'qGEN', urb, endpoint, irp);        

    // remember this value for IoFreeMapRegisters
    transfer->hca.HcdExtension = MapRegisterBase;

    ASSERT(transfer->Status == HCD_PENDING_STATUS_SUBMITTING);

    // **
    // program the transfer
    // NOTE: these functions actually start the transfer on the 
    //  adapter
    // **
    switch(endpoint->Type) {
    case USB_ENDPOINT_TYPE_ISOCHRONOUS:
        OpenHCI_IsoTransfer(DeviceData,
                            endpoint,
                            urb,
                            transfer);
        break;
    case USB_ENDPOINT_TYPE_CONTROL:        
        OpenHCI_ControlTransfer(DeviceData,
                                endpoint,
                                urb,
                                transfer);
        break;
    case USB_ENDPOINT_TYPE_BULK:
    case USB_ENDPOINT_TYPE_INTERRUPT:
        OpenHCI_BulkOrInterruptTransfer(DeviceData,
                                        endpoint,
                                        urb,
                                        transfer);
        break;
    default:
        TRAP();
    }
    

    //
    // for cancel:
    //
    // it is possible for the transfer to be canceled before we complete
    // this operation, we handle this case by checking one last time
    // before we set the urb to STATUS_PENDING_SUBMITTED
    //
    // ie the status is HCD_PENDING_STATUS_QUEUED but the transfer is 
    // not on the queue ao the cancel routine will have taken
    // no action.

    IoAcquireCancelSpinLock(&oldIrql);

    if (irp->Cancel)
    {
       
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_TRACE,
                          ("' Removing cancelled URB %x\n", urb));
        LOGENTRY(G, 'Mcan', irp, transfer, 0);                                  

        transfer->Status = HCD_PENDING_STATUS_SUBMITTED;

        // we will need to call the cancel routine ourselves
        // now that the tranfser has been fully programmed

        // set cancel irql so that we release the cancel spinlock
        // at the proper level
        irp->CancelIrql = oldIrql;
        OpenHCI_CancelTransfer(DeviceObject,
                               irp);
        // NOTE: cancel routine will release the spinlock
        
    }
    else
    {
        // cancel routine will know what to do
        transfer->Status = HCD_PENDING_STATUS_SUBMITTED;

        // The request made it through IoAllocateAdapterChannel() and
        // now we own it again.  Set the cancel routine again.
        //
        IoSetCancelRoutine(irp, OpenHCI_CancelTransfer); 

        IoReleaseCancelSpinLock(oldIrql);
    }

    OpenHCI_KdPrintDD(DeviceData, 
                      OHCI_DBG_TD_TRACE, ("'exit QueueGenRequest\n"));
    
    return (DeallocateObjectKeepRegisters);
}


NTSTATUS
OpenHCI_AbortEndpoint(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PHCD_DEVICE_DATA DeviceData,
    PHCD_URB Urb
    )
/*++
Routine Description:
   Cancel all URB's associated with this Endpoint.


--*/
{
    NTSTATUS ntStatus;
    PHCD_ENDPOINT endpoint;
    PLIST_ENTRY entry;
    struct _URB_HCD_COMMON_TRANSFER *transfer;
    PHCD_URB urb;
    KIRQL oldIrq;
    PHC_OPERATIONAL_REGISTER HC;
    LIST_ENTRY QueuedListHead;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    endpoint = Urb->HcdUrbAbortEndpoint.HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);

    OpenHCI_KdPrintDD(DeviceData, 
                      OHCI_DBG_CANCEL_TRACE, ("'Abort Endpoint \n"));
    LOGENTRY(G, '>ABR', endpoint, 0, 0);         
    
    HC = DeviceData->HC;

    if (READ_REGISTER_ULONG(&HC->HcRevision.ul) == 0xFFFFFFFF)
    {
        OpenHCI_KdPrint((0, "'AbortEndpoint, controller not there!\n"));

        // The assumption here is that if the controller disappeared,
        // it disappeared while the machine was suspended and no transfers
        // should have been queued at that time.  Also, all transfers that
        // were submitted after the machine resumed without the controller
        // were immediately failed.  If those assumptions are true, we
        // don't have to do anything except complete the Abort Irp.
        //
        // If we want to handle the general case of surprise removing the
        // host controller, there might actually be queued transfers we
        // need to cleanup somehow.
        //
        OpenHCI_CompleteIrp(DeviceObject, Irp, STATUS_SUCCESS);

        return STATUS_SUCCESS;
    }

    // Remove all of the transfers which are queued on the software queue
    // for this endpoint and which are not yet active on the hardware.
    //
    InitializeListHead(&QueuedListHead);

    IoAcquireCancelSpinLock(&oldIrq);

    KeAcquireSpinLockAtDpcLevel(&endpoint->QueueLock);

    while (!IsListEmpty(&endpoint->RequestQueue))
    {
        entry = RemoveHeadList(&endpoint->RequestQueue);
        
        InsertTailList(&QueuedListHead, entry);

        urb = CONTAINING_RECORD(entry,
                                HCD_URB,
                                HcdUrbCommonTransfer.hca.HcdListEntry);

        transfer = &urb->HcdUrbCommonTransfer;

        IoSetCancelRoutine(transfer->hca.HcdIrp, NULL);

        LOGENTRY(G, 'rABR', urb, transfer, transfer->hca.HcdIrp);                 

        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CANCEL_NOISE,
                        ("'URB 0x%x on endpoint 0x%x\n", urb, endpoint));
    }

    KeReleaseSpinLockFromDpcLevel(&endpoint->QueueLock);

    IoReleaseCancelSpinLock(oldIrq);

    // Now complete all of the transfers which were queued on the software
    // queue.
    //
    while (!IsListEmpty(&QueuedListHead))
    {
        entry = RemoveHeadList(&QueuedListHead);
        
        urb = CONTAINING_RECORD(entry,
                                HCD_URB,
                                HcdUrbCommonTransfer.hca.HcdListEntry);

        transfer = &urb->HcdUrbCommonTransfer;

        transfer->hca.HcdListEntry.Flink = NULL;
        transfer->hca.HcdListEntry.Blink = NULL;

        transfer->Status = USBD_STATUS_CANCELED;

        transfer->TransferBufferLength = 0;

        LOGENTRY(G, 'qABR', urb, transfer, transfer->hca.HcdIrp);                 

        OpenHCI_CompleteIrp(DeviceObject,
                            transfer->hca.HcdIrp,
                            STATUS_CANCELLED);
    }

    // Now pause the endpoint, which will cause OpenHCI_IsrDPC() to call
    // OpenHCI_CancelTDsForED() to complete all of the transfer which were
    // active on the hardware.
    //
    KeAcquireSpinLock(&DeviceData->PausedSpin, &oldIrq);

    if (endpoint->EpFlags & EP_ROOT_HUB) {

        ntStatus = STATUS_SUCCESS;

        LOGENTRY(G, 'cAbr', Irp, endpoint, 0);

        KeReleaseSpinLock(&DeviceData->PausedSpin, oldIrq);

        OpenHCI_CompleteIrp(DeviceObject, Irp, STATUS_SUCCESS);

    } else {

        SET_EPFLAG(endpoint, EP_ABORT);

        LOGENTRY(G, 'pAbr', Irp, endpoint, 0);

        IoMarkIrpPending(Irp);

        ntStatus =             
            Irp->IoStatus.Status = STATUS_PENDING;     

        endpoint->AbortIrp = Irp;               

        KeReleaseSpinLock(&DeviceData->PausedSpin, oldIrq);

        OpenHCI_PauseED(endpoint);     
    }
    
    return ntStatus;
}


PHYSICAL_ADDRESS
OpenHCI_IoMapTransfer(
    IN PMAP_CONTEXT MapContext,
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN ULONG TotalLength,
    IN BOOLEAN WriteToDevice
    )
/*++
Routine Description:
    Our goal here is to call IoMapTransfer once for the whole
    buffer, subsequent calls just return offsets to the mapped 
    buffer.

    

--*/
{
    PHYSICAL_ADDRESS PhysAddress;    
    
    if (!MapContext->Mapped) {
        // first call attempts to map the
        // entire buffer
        LOGENTRY(G, 'mpIT', TotalLength, *Length, MapContext->Flags);     

        if (MapContext->Flags & OHCI_MAP_INIT) {
            MapContext->LengthMapped = 
                MapContext->TotalLength;                   
             LOGENTRY(G, 'mIT2', MapContext->TotalLength, *Length, MapContext->Flags);                  
        } else {
            MapContext->Flags |= OHCI_MAP_INIT;
            MapContext->MapRegisterBase = 
                MapRegisterBase;
            MapContext->LengthMapped = 
                MapContext->TotalLength = TotalLength;
            LOGENTRY(G, 'mIT1', MapContext->TotalLength, *Length, MapContext->Flags);                  
        }
        
        MapContext->CurrentVa = CurrentVa;            

        LOGENTRY(G, 'cIOM', Mdl, MapContext->MapRegisterBase, MapContext->CurrentVa);
        
        MapContext->PhysAddress = 
            IoMapTransfer(DmaAdapter,    
                          Mdl,
                          MapContext->MapRegisterBase,
                          MapContext->CurrentVa,
                          &MapContext->LengthMapped,
                          WriteToDevice);

        MapContext->Mapped = TRUE;      
        MapContext->TotalLength -= 
            MapContext->LengthMapped;
        
        LOGENTRY(G, 'mped', MapContext->LengthMapped, 
                MapContext->CurrentVa, *Length);     

        // OK, we mapped it, the caller will may have requested less
        // if so adjust the values and prepare for the next call

        if (*Length < MapContext->LengthMapped) {
            // caller requested less
            LOGENTRY(G, 'mpls', MapContext->LengthMapped, 
                MapContext->CurrentVa, *Length);        

            MapContext->LengthMapped -= *Length;         
            MapContext->CurrentVa = CurrentVa;
            MapRegisterBase = MapContext->MapRegisterBase;
            PhysAddress = MapContext->PhysAddress; 
            MapContext->PhysAddress.QuadPart += *Length;
            
            //TEST_TRAP();
        } else {
            // we mapped exactly what the caller asked for
            LOGENTRY(G, 'mpxa', MapContext->LengthMapped, 
                MapContext->CurrentVa, *Length);        
            OHCI_ASSERT(*Length == MapContext->LengthMapped);
            
            MapContext->Mapped = FALSE;       
            CurrentVa = MapContext->CurrentVa;
            MapRegisterBase = MapContext->MapRegisterBase;
            PhysAddress = MapContext->PhysAddress;     
        }

    } else {
        // we can satisfy this request based on the last call,
        // just bump currentVa and return parms.

        LOGENTRY(G, 'mpco', CurrentVa, *Length, MapContext->LengthMapped);
        
        MapContext->CurrentVa = CurrentVa;
        MapRegisterBase = MapContext->MapRegisterBase;
        MapContext->LengthMapped -= *Length;
        // adjust the Phys Address
        PhysAddress = MapContext->PhysAddress; 
        MapContext->PhysAddress.QuadPart += *Length;
        
        //TEST_TRAP();

        if (MapContext->LengthMapped == 0) {
            // we have used everything we mapped,
            // next time in call IoMapTransfer again
            LOGENTRY(G, 'mall', 0, *Length, MapContext->LengthMapped);
            MapContext->Mapped = FALSE; 
            //TEST_TRAP();
        }            
    }

    LOGENTRY(G, 'mpDN', MapContext, PhysAddress.HighPart, PhysAddress.LowPart);        

    return PhysAddress; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\openhci\openhci.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    openhci.h

Abstract:

    This module contains the PRIVATE definitions for the
    code that implements the OpenHCI Host Controller Driver for USB.

Environment:

    Kernel & user mode

Revision History:

    12-28-95 : created jfuller

--*/

#include "stdarg.h"
#include "wdm.h"

#include "usbdi.h"
#include "hcdi.h"
#include "usbdlibi.h"
#include "usbdlib.h"

#include "dbg.h"

#ifndef OPENHCI_H
#define OPENHCI_H
// #define COMPAQ
// #define NEC
// #define CMD
// #define NSC //National Semiconductor
#define NEC_XXX
#define DISABLE_INT_DELAY_NO_INT 0
#define PREALLOCATE_DESCRIPTOR_MEMORY 1
#define PREALLOCATE_DESCRIPTOR_MEMORY_NUM_PAGES 2

#define RESOURCES_NOT_ON_IRP_STACK 0

#ifdef PNP_POWER
#define PnPEnabled() TRUE
#else
#define PnPEnabled() FALSE
#endif /* PNP_POWER */

#define HCD_PENDING_STATUS_SUBMITTING   0x40404001
#define HCD_PENDING_STATUS_SUBMITTED    0x40404002
#define HCD_PENDING_STATUS_QUEUED       0x40404003

//
// OpenHCI PCI Identification values
//
#define OpenHCI_PCI_BASE_CLASS   0x0C        // base class is serial bus
#define OpenHCI_PCI_SUB_CLASS    0x03        // sub class is USB
#define OpenHCI_PCI_PROG_IF      0x10        // programming interface is OpenHCI

//
// Tag for memory allocations: 'OHCI'
//
#define OpenHCI_TAG     0x4943484F

//
// Eventually CacheCommon should determine if the platform snoops i/o cycles;
// for now, just cache memory allocated by HalAllocateCommonBuffer

#define CacheCommon  TRUE

//
// Maximum length of name strings used in initialization code
//

#define NAME_MAX 256
#define NAME_STRING L"\\Device\\USB#"
/*                  0 1234567 89012345 */
#define NAME_NO_POS 11


//
// highest physical address we can use
//
#define OpenHCI_HIGHEST_ADDRESS            0x000000FFFFFFFF;

//
// Maximum frame and packet overhead
//
#define MAXIMUM_OVERHEAD   210

#define OHCI_PAGE_SIZE 0x1000
// #define OHCI_PAGE_SIZE 0x20
#define OHCI_PAGE_SIZE_MASK (OHCI_PAGE_SIZE - 1)


#if DBG
#if !defined(FAKEPORTCHANGE)
#define FAKEPORTCHANGE 1
#endif
#else
#if !defined(FAKEPORTCHANGE)
#define FAKEPORTCHANGE 0
#endif
#endif


#ifdef MAX_DEBUG
#define OHCI_DEFAULT_DEBUG_OUTPUT_LEVEL 0xFFFFFFFF
#else
//#define OHCI_DEFAULT_DEBUG_OUTPUT_LEVEL 0xFEAAFFEE // 0xF8A8888E
#define OHCI_DEFAULT_DEBUG_OUTPUT_LEVEL 0x00000000
#endif

#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))

#define IoDecrementStackLocation(IRP) \
         (IRP)->CurrentLocation++; \
         (IRP)->Tail.Overlay.CurrentStackLocation++;

#define IoCopyStackToNextStack(IRP) \
        {  \
           PIO_STACK_LOCATION now, later; \
           now = IoGetCurrentIrpStackLocation (IRP); \
           later = IoGetNextIrpStackLocation (IRP); \
           later->Parameters = now->Parameters; \
           later->MajorFunction = now->MajorFunction; \
           later->MinorFunction = now->MinorFunction; \
           later->Flags = now->Flags; \
        }


//
// 7.1.1 HcRevision Register
// Definition of Host Controller Revision register
//
typedef union _HC_REVISION {
   ULONG                   ul;
   struct {
      ULONG                Rev:8;
      ULONG                :24;
   };
} HC_REVISION, *PHC_REVISION;


//
// 7.1.2 HcControl Register
// Definition of Host Controller Control register
//
typedef union _HC_CONTROL {
   ULONG                   ul;
   struct {
      ULONG                ControlBulkServiceRatio:2;
      ULONG                PeriodicListEnable:1;
      ULONG                IsochronousEnable:1;
      ULONG                ControlListEnable:1;
      ULONG                BulkListEnable:1;
      ULONG                HostControllerFunctionalState:2;
      ULONG                InterruptRouting:1;
      ULONG                RemoteWakeupConnected:1;
      ULONG                RemoteWakeupEnable:1;
      ULONG                :21;
   };
} HC_CONTROL, *PHC_CONTROL;

#define HcCtrl_CBSR_MASK                     0x00000003L
#define HcCtrl_CBSR_1_to_1                   0x00000000L
#define HcCtrl_CBSR_2_to_1                   0x00000001L
#define HcCtrl_CBSR_3_to_1                   0x00000002L
#define HcCtrl_CBSR_4_to_1                   0x00000003L
#define HcCtrl_PeriodicListEnable            0x00000004L
#define HcCtrl_IsochronousEnable             0x00000008L
#define HcCtrl_ControlListEnable             0x00000010L
#define HcCtrl_BulkListEnable                0x00000020L
#define HcCtrl_ListEnableMask                0x00000038L

#define HcCtrl_HCFS_MASK                     0x000000C0L
#define HcCtrl_HCFS_USBReset                 0x00000000L
#define HcCtrl_HCFS_USBResume                0x00000040L
#define HcCtrl_HCFS_USBOperational           0x00000080L
#define HcCtrl_HCFS_USBSuspend               0x000000C0L

#define HcCtrl_InterruptRouting              0x00000100L
#define HcCtrl_RemoteWakeupConnected         0x00000200L
#define HcCtrl_RemoteWakeupEnable            0x00000400L

#define HcHCFS_USBReset                      0x00000000
#define HcHCFS_USBResume                     0x00000001
#define HcHCFS_USBOperational                0x00000002
#define HcHCFS_USBSuspend                    0x00000003

//
// 7.1.3 HcCommandStatus Register
// Definition of Host Controller Command/Status register
//
typedef union _HC_COMMAND_STATUS {
   ULONG                   ul;               // use HcCmd flags below
   struct {
      ULONG                HostControllerReset:1;
      ULONG                ControlListFilled:1;
      ULONG                BulkListFilled:1;
      ULONG                OwnershipChangeRequest:1;
      ULONG                :12;
      ULONG                SchedulingOverrunCount:2;
      ULONG                :14;
   };
} HC_COMMAND_STATUS, *PHC_COMMAND_STATUS;

#define HcCmd_HostControllerReset            0x00000001
#define HcCmd_ControlListFilled              0x00000002
#define HcCmd_BulkListFilled                 0x00000004
#define HcCmd_OwnershipChangeRequest         0x00000008
#define HcCmd_SOC_Mask                       0x00030000
#define HcCmd_SOC_Offset                     16
#define HcCmd_SOC_Mask_LowBits               0x00000003

//
// 7.3.1 HcFmInterval Register
// Definition of Host Controller Frame Interval register
//
typedef union _HC_FM_INTERVAL {
   ULONG                   ul;              // use HcFmI flags below
   struct {
      ULONG                FrameInterval:14;
      ULONG                :2;
      ULONG                FSLargestDataPacket:15;
      ULONG                FrameIntervalToggle:1;
   };
} HC_FM_INTERVAL, *PHC_FM_INTERVAL;

#define HcFmI_FRAME_INTERVAL_MASK            0x00003FFF
#define HcFmI_FS_LARGEST_DATA_PACKET_MASK    0x7FFF0000
#define HcFmI_FS_LARGEST_DATA_PACKET_SHIFT   16
#define HcFmI_FRAME_INTERVAL_TOGGLE          0x80000000

//
// 7.3.2 HcFmRemaining Register
// Definition of Host Controller Frame Remaining register
//
typedef union _HC_FM_REMAINING {
   ULONG                   ul;
   struct {
      ULONG                FrameRemaining:14;
      ULONG                :17;
      ULONG                FrameRemainingToggle:1;
   };
} HC_FM_REMAINING, *PHC_FM_REMAINING;

//
// 7.4.1 HcRhDescriptorA Register
// Definition of Host Controller Root Hub DescriptorA register
//
typedef union _HC_RH_DESCRIPTOR_A {
   ULONG                   ul;
   struct {
      ULONG                NumberDownstreamPorts:8;
      ULONG                PowerSwitchingMode:1;
      ULONG                NoPowerSwitching:1;
      ULONG                :1;
      ULONG                OverCurrentProtectionMode:1;
      ULONG                NoOverCurrentProtection:1;
      ULONG                :11;
      ULONG                PowerOnToPowerGoodTime:8;
   };
} HC_RH_DESCRIPTOR_A, *PHC_RH_DESCRIPTOR_A;

//
// 7.4.2 HcRhDescriptorB Register
// Definition of Host Controller Root Hub DescritorB register
//
typedef union _HC_RH_DESCRIPTOR_B {
   ULONG                   ul;
   struct {
      USHORT               DeviceRemovableMask;
      USHORT               PortPowerControlMask;
   };
} HC_RH_DESCRIPTOR_B, *PHC_RH_DESCRIPTOR_B;

//
// Host Controler Hardware Registers as accessed in memory
//
typedef struct _HC_OPERATIONAL_REGISTER {
   // 0 0x00 - 0,4,8,c
   HC_REVISION             HcRevision;
   HC_CONTROL              HcControl;
   HC_COMMAND_STATUS       HcCommandStatus;
   ULONG                   HcInterruptStatus;   // use HcInt flags below
   // 1 0x10
   ULONG                   HcInterruptEnable;   // use HcInt flags below
   ULONG                   HcInterruptDisable;  // use HcInt flags below
   ULONG                   HcHCCA;              // physical pointer to Host Controller Communications Area
   ULONG                   HcPeriodCurrentED;   // physical ptr to current periodic ED
   // 2 0x20
   ULONG                   HcControlHeadED;     // physical ptr to head of control list
   ULONG                   HcControlCurrentED;  // physical ptr to current control ED
   ULONG                   HcBulkHeadED;        // physical ptr to head of bulk list
   ULONG                   HcBulkCurrentED;     // physical ptr to current bulk ED
   // 3 0x30
   ULONG                   HcDoneHead;          // physical ptr to internal done queue
   HC_FM_INTERVAL          HcFmInterval;
   HC_FM_REMAINING         HcFmRemaining;
   ULONG                   HcFmNumber;
   // 4 0x40
   ULONG                   HcPeriodicStart;
   ULONG                   HcLSThreshold;
   HC_RH_DESCRIPTOR_A      HcRhDescriptorA;
   HC_RH_DESCRIPTOR_B      HcRhDescriptorB;
   // 5 0x50
   ULONG                   HcRhStatus;          // use HcRhS flags below
   ULONG                   HcRhPortStatus[15];  // use HcRhPS flags below
} HC_OPERATIONAL_REGISTER, *PHC_OPERATIONAL_REGISTER;

//
// 7.1.4 HcInterrruptStatus Register
// 7.1.5 HcInterruptEnable  Register
// 7.1.6 HcInterruptDisable Register
//
#define HcInt_SchedulingOverrun              0x00000001L
#define HcInt_WritebackDoneHead              0x00000002L
#define HcInt_StartOfFrame                   0x00000004L
#define HcInt_ResumeDetected                 0x00000008L
#define HcInt_UnrecoverableError             0x00000010L
#define HcInt_FrameNumberOverflow            0x00000020L
#define HcInt_RootHubStatusChange            0x00000040L
#define HcInt_OwnershipChange                0x40000000L
#define HcInt_MasterInterruptEnable          0x80000000L

//
// 7.4.3 HcRhStatus Register
//
#define HcRhS_LocalPowerStatus                  0x00000001  // read only
#define HcRhS_OverCurrentIndicator              0x00000002  // read only
#define HcRhS_DeviceRemoteWakeupEnable          0x00008000  // read only
#define HcRhS_LocalPowerStatusChange            0x00010000  // read only
#define HcRhS_OverCurrentIndicatorChange        0x00020000  // read only

#define HcRhS_ClearGlobalPower                  0x00000001  // write only
#define HcRhS_SetRemoteWakeupEnable             0x00008000  // write only
#define HcRhS_SetGlobalPower                    0x00010000  // write only
#define HcRhS_ClearOverCurrentIndicatorChange   0x00020000  // write only
#define HcRhS_ClearRemoteWakeupEnable           0x80000000  // write only

//
// 7.4.4 HcRhPortStatus Register
//
#define HcRhPS_CurrentConnectStatus          0x00000001  // read only
#define HcRhPS_PortEnableStatus              0x00000002  // read only
#define HcRhPS_PortSuspendStatus             0x00000004  // read only
#define HcRhPS_PortOverCurrentIndicator      0x00000008  // read only
#define HcRhPS_PortResetStatus               0x00000010  // read only
#define HcRhPS_PortPowerStatus               0x00000100  // read only
#define HcRhPS_LowSpeedDeviceAttached        0x00000200  // read only
#define HcRhPS_ConnectStatusChange           0x00010000  // read only
#define HcRhPS_PortEnableStatusChange        0x00020000  // read only
#define HcRhPS_PortSuspendStatusChange       0x00040000  // read only
#define HcRhPS_OverCurrentIndicatorChange    0x00080000  // read only
#define HcRhPS_PortResetStatusChange         0x00100000  // read only

#define HcRhPS_ClearPortEnable               0x00000001  // write only
#define HcRhPS_SetPortEnable                 0x00000002  // write only
#define HcRhPS_SetPortSuspend                0x00000004  // write only
#define HcRhPS_ClearPortSuspend              0x00000008  // write only
#define HcRhPS_SetPortReset                  0x00000010  // write only
#define HcRhPS_SetPortPower                  0x00000100  // write only
#define HcRhPS_ClearPortPower                0x00000200  // write only
#define HcRhPS_ClearConnectStatusChange      0x00010000  // write only
#define HcRhPS_ClearPortEnableStatusChange   0x00020000  // write only
#define HcRhPS_ClearPortSuspendStatusChange  0x00040000  // write only
#define HcRhPS_ClearPortOverCurrentChange    0x00080000  // write only
#define HcRhPS_ClearPortResetStatusChange    0x00100000  // write only

#define HcRhPS_RESERVED     (~(HcRhPS_CurrentConnectStatus       | \
                               HcRhPS_PortEnableStatus           | \
                               HcRhPS_PortSuspendStatus          | \
                               HcRhPS_PortOverCurrentIndicator   | \
                               HcRhPS_PortResetStatus            | \
                               HcRhPS_PortPowerStatus            | \
                               HcRhPS_LowSpeedDeviceAttached     | \
                               HcRhPS_ConnectStatusChange        | \
                               HcRhPS_PortEnableStatusChange     | \
                               HcRhPS_PortSuspendStatusChange    | \
                               HcRhPS_OverCurrentIndicatorChange | \
                               HcRhPS_PortResetStatusChange        \
                            ))

//
// Host Controller Communications Area
//
typedef struct _HCCA_BLOCK {
   ULONG                     HccaInterruptTable[32]; // physical pointer to interrupt lists
   USHORT                    HccaFrameNumber;        // 16-bit current frame number
   USHORT                    HccaPad1;               // When the HC updates
                                                     // HccaFrameNumber, it sets
                                                     // this word to zero.
   ULONG                     HccaDoneHead;           // pointer to done queue
   ULONG                     Reserved[30];           // pad to 256 bytes
} HCCA_BLOCK, *PHCCA_BLOCK;

C_ASSERT(sizeof(HCCA_BLOCK) == 256);

#define HCCADoneHead_INT_FLAG    0x00000001              // bit set if other ints pending

//
// Host Controller Endpoint Descriptor Control DWORD
//
typedef union _HC_ENDPOINT_CONTROL {
   ULONG                      Control;       // use HcEDControl flags below
   struct {
      ULONG                   FunctionAddress:7;
      ULONG                   EndpointNumber:4;
      ULONG                   Direction:2;   // use HcEDDirection flags below
      ULONG                   LowSpeed:1;
      ULONG                   sKip:1;
      ULONG                   Isochronous:1;
      ULONG                   MaxPacket:11;
      ULONG                   Unused:5;      //available for software use
   };
} HC_ENDPOINT_CONTROL, *PHC_ENDPOINT_CONTROL;

//
// Definitions for HC_ENDPOINT_CONTROL.Control
//
#define HcEDControl_MPS_MASK  0x07FF0000  // Maximum Packet Size field
#define HcEDControl_MPS_SHIFT 16          // Shift Count for MPS
#define HcEDControl_ISOCH     0x00008000  // Bit set for isochronous endpoints
#define HcEDControl_SKIP      0x00004000  // Bit tells hw to skip this endpoint
#define HcEDControl_LOWSPEED  0x00002000  // Bit set if device is a low speed device
#define HcEDControl_DIR_MASK  0x00001800  // Transfer direction field
#define HcEDControl_DIR_DEFER 0x00000000  // Defer direction select to TD (Control Endpoints)
#define HcEDControl_DIR_OUT   0x00000800  // Direction is from host to device
#define HcEDControl_DIR_IN    0x00001000  // Direction is from device to host
#define HcEDControl_EN_MASK   0x00000780  // Endpoint Number field
#define HcEDControl_EN_SHIFT  7           // Shift Count for EN
#define HcEDControl_FA_MASK   0x0000007F  // Function Address field
#define HcEDControl_FA_SHIFT  0           // Shift Count for FA

//
// Definitions for HC_ENDPOINT_CONTROL.Direction
//
#define HcEDDirection_Defer   0           // Defer direction to TD (Control Endpoints)
#define HcEDDirection_Out     1           // Direction from host to device
#define HcEDDirection_In      2           // Direction from device to host

//
// Host Controller Endpoint Descriptor, refer to Section 4.2, Endpoint Descriptor
//
typedef struct _HC_ENDPOINT_DESCRIPTOR {
   HC_ENDPOINT_CONTROL;                // dword 0
   ULONG                      TailP;   //physical pointer to HC_TRANSFER_DESCRIPTOR
   volatile ULONG             HeadP;   //flags + phys ptr to HC_TRANSFER_DESCRIPTOR
   ULONG                      NextED;  //phys ptr to HC_ENDPOINT_DESCRIPTOR
} HC_ENDPOINT_DESCRIPTOR, *PHC_ENDPOINT_DESCRIPTOR;

C_ASSERT(sizeof(HC_ENDPOINT_DESCRIPTOR) == 16);

//
// Definitions for HC_ENDPOINT_DESCRIPTOR.HeadP
//
#define HcEDHeadP_FLAGS 0x0000000F  //mask for flags in HeadP
#define HcEDHeadP_HALT  0x00000001  //hardware stopped bit
#define HcEDHeadP_CARRY 0x00000002  //hardware toggle carry bit

//
// HCD Isochronous offset/status words
//
typedef union _HC_OFFSET_PSW {
   struct {
      USHORT      Offset:13;                       // Offset within two pages of packet buffer
      USHORT      Ones:3;                          // should be 111b when in Offset format
   };
   struct {
      USHORT      Size:11;                         // Size of packet received
      USHORT      :1;                              // reserved
      USHORT      ConditionCode:4;                 // use HcCC flags below
   };
   USHORT         PSW;                             // use HcPSW flags below
} HC_OFFSET_PSW, *PHC_OFFSET_PSW;

//
// Definitions for HC_OFFSET_PSW.PSW
//
#define HcPSW_OFFSET_MASK           0x0FFF         // Packet buffer offset field
#define HcPSW_SECOND_PAGE           0x1000         // Is this packet on 2nd page
#define HcPSW_ONES                  0xE000         // The ones for Offset form
#define HcPSW_CONDITION_CODE_MASK   0xF000         // Packet ConditionCode field
#define HcPSW_CONDITION_CODE_SHIFT  12             // shift count for Code
#define HcPSW_RETURN_SIZE           0x07FF         // The size field.

//
// HCD Transfer Descriptor Control DWord
//
typedef union _HC_TRANSFER_CONTROL {
   ULONG                            Control;          // use HcTDControl flags below
   struct _HC_GENERAL_TD_CONTROL{
      ULONG                         :16;              // available for s/w use in GTD
      ULONG                         IsochFlag:1;      // should be 0 for GTD, s/w flag
      ULONG                         :1;               // available for s/w use
      ULONG                         ShortXferOk:1;    // if set don't report error on short transfer
      ULONG                         Direction:2;      // use HcTDDirection flags below
      ULONG                         IntDelay:3;       // use HcTDIntDelay flags below
      ULONG                         Toggle:2;         // use HcTDToggle flags below
      ULONG                         ErrorCount:2;
      ULONG                         ConditionCode:4;  // use HcCC flags below
   };
   struct _HC_ISOCHRONOUS_TD_CONTROL{
      ULONG                         StartingFrame:16;
      ULONG                         Isochronous:1;    // should be 1 for ITD, s/w flag
      ULONG                         :1;               // available for s/w use
      ULONG                         :3;               // available for s/w use in ITD
      ULONG                         :3;               // IntDelay
      ULONG                         FrameCount:3;     // one less than number of frames described in ITD
      ULONG                         :1;               // available for s/w use in ITD
      ULONG                         :4;               // ConditionCode
   };
} HC_TRANSFER_CONTROL, *PHC_TRANSFER_CONTROL;

//
// Definitions for HC_TRANSFER_CONTROL.Control
//
#define HcTDControl_STARTING_FRAME        0x0000FFFF  // mask for starting frame (Isochronous)
#define HcTDControl_ISOCHRONOUS           0x00010000  // 1 for Isoch TD, 0 for General TD
#define HcTDControl_SHORT_XFER_OK         0x00040000  // 0 if short transfers are errors
#define HcTDControl_DIR_MASK              0x00180000  // Transfer direction field
#define HcTDControl_DIR_SETUP             0x00000000  // direction is setup packet from host to device
#define HcTDControl_DIR_OUT               0x00080000  // direction is from host to device
#define HcTDControl_DIR_IN                0x00100000  // direction is from device to host
#define HcTDControl_INT_DELAY_MASK        0x00E00000  // Interrupt Delay field
#define HcTDControl_INT_DELAY_0_MS        0x00000000  // Interrupt at end of frame TD is completed
#define HcTDControl_INT_DELAY_1_MS        0x00200000  // Interrupt no later than end of 1st frame after TD is completed
#define HcTDControl_INT_DELAY_2_MS        0x00400000  // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDControl_INT_DELAY_3_MS        0x00600000  // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDControl_INT_DELAY_4_MS        0x00800000  // Interrupt no later than end of 4th frame after TD is completed
#define HcTDControl_INT_DELAY_5_MS        0x00A00000  // Interrupt no later than end of 5th frame after TD is completed
#define HcTDControl_INT_DELAY_6_MS        0x00C00000  // Interrupt no later than end of 6th frame after TD is completed

#ifdef NSC
#define HcTDControl_INT_DELAY_NO_INT      0x00C00000  // Almost infinity but not yet quite.
#elif DISABLE_INT_DELAY_NO_INT
#define   HcTDControl_INT_DELAY_NO_INT      0x00000000  // Interrupt at the completion of all packets.
#else
#define HcTDControl_INT_DELAY_NO_INT      0x00E00000  // Do not cause an interrupt for normal completion of this TD
#endif

#define HcTDControl_FRAME_COUNT_MASK      0x07000000  // mask for FrameCount field (Isochronous)
#define HcTDControl_FRAME_COUNT_SHIFT     24          // shift count for FrameCount (Isochronous)
#define HcTDControl_FRAME_COUNT_MAX       8           // Max number of for frame count per TD
#define HcTDControl_TOGGLE_MASK           0x03000000  // mask for Toggle control field
#define HcTDControl_TOGGLE_FROM_ED        0x00000000  // get data toggle from CARRY field of ED
#define HcTDControl_TOGGLE_DATA0          0x02000000  // use DATA0 for data PID
#define HcTDControl_TOGGLE_DATA1          0x03000000  // use DATA1 for data PID
#define HcTDControl_ERROR_COUNT           0x0C000000  // mask for Error Count field
#define HcTDControl_CONDITION_CODE_MASK   0xF0000000  // mask for ConditionCode field
#define HcTDControl_CONDITION_CODE_SHIFT  28          // shift count for ConditionCode

//
// Definitions for HC_TRANSFER_CONTROL.Direction
//
#define HcTDDirection_Setup               0           // setup packet from host to device
#define HcTDDirection_Out                 1           // direction from host to device
#define HcTDDirection_In                  2           // direction from device to host

//
// Definitions for Hc_TRANSFER_CONTROL.IntDelay
//
#define HcTDIntDelay_0ms                  0           // interrupt at end of frame TD is completed
#define HcTDIntDelay_1ms                  1           // Interrupt no later than end of 1st frame after TD is completed
#define HcTDIntDelay_2ms                  2           // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDIntDelay_3ms                  3           // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDIntDelay_4ms                  4           // Interrupt no later than end of 4th frame after TD is completed
#define HcTDIntDelay_5ms                  5           // Interrupt no later than end of 5th frame after TD is completed
#define HcTDIntDelay_6ms                  6           // Interrupt no later than end of 6th frame after TD is completed
#define HcTDIntDelay_NoInterrupt          7           // do not generate interrupt for normal completion of this TD

//
// Definitions for HC_TRANSFER_CONTROL.Toggle
//
#define HcTDToggle_FromEd                 0           // get toggle for Endpoint Descriptor toggle CARRY bit
#define HcTDToggle_Data0                  2           // use Data0 PID
#define HcTDToggle_Data1                  3           // use Data1 PID

//
// Definitions for HC_TRANSFER_CONTROL.ConditionCode and HC_OFFSET_PSW.ConditionCode
//
#define HcCC_NoError                      0x0UL
#define HcCC_CRC                          0x1UL
#define HcCC_BitStuffing                  0x2UL
#define HcCC_DataToggleMismatch           0x3UL
#define HcCC_Stall                        0x4UL
#define HcCC_DeviceNotResponding          0x5UL
#define HcCC_PIDCheckFailure              0x6UL
#define HcCC_UnexpectedPID                0x7UL
#define HcCC_DataOverrun                  0x8UL
#define HcCC_DataUnderrun                 0x9UL
      //                                  0xA         // reserved
      //                                  0xB         // reserved
#define HcCC_BufferOverrun                0xCUL
#define HcCC_BufferUnderrun               0xDUL
#define HcCC_NotAccessed                  0xEUL
      //                                  0xF         // this also means NotAccessed

//
// Host Controller Transfer Descriptor, refer to Section 4.3, Transfer Descriptors
//
typedef struct _HC_TRANSFER_DESCRIPTOR {
   HC_TRANSFER_CONTROL;                            // dword 0
   ULONG                            CBP;           // phys ptr to start of buffer
   ULONG                            NextTD;        // phys ptr to HC_TRANSFER_DESCRIPTOR
   ULONG                            BE;            // phys ptr to end of buffer (last byte)
   HC_OFFSET_PSW                    Packet[8];     // isoch & Control packets
} HC_TRANSFER_DESCRIPTOR, *PHC_TRANSFER_DESCRIPTOR;

//
// HCD Endpoint Descriptor
//
typedef struct _HCD_ENDPOINT_DESCRIPTOR {
   HC_ENDPOINT_DESCRIPTOR     HcED;
   ULONG                      Pad[4];              // make Physical Address the same as in HCD_TRANSFER_DESCRIPTOR
   ULONG                      PhysicalAddress;

   UCHAR                      ListIndex;
   UCHAR                      PauseFlag;
   UCHAR                      Flags;
   UCHAR                      Reserved[1];         // fill out to 64 bytes

   LIST_ENTRY                 Link;
   struct _HCD_ENDPOINT       *Endpoint;
   ULONG                      ReclamationFrame;
   LIST_ENTRY                 PausedLink;

#ifdef _WIN64
   ULONG                      Pad24[9];            // file out to 128 bytes
#endif
} HCD_ENDPOINT_DESCRIPTOR, *PHCD_ENDPOINT_DESCRIPTOR;

C_ASSERT((sizeof(HCD_ENDPOINT_DESCRIPTOR) == 64) ||
         (sizeof(HCD_ENDPOINT_DESCRIPTOR) == 128));

// Values for HCD_ENDPOINT_DESCRIPTOR->PauseFlag
//
// Used by:
//
//  OpenHCI_CancelTDsForED()
//  OpenHCI_PauseED()
//  OpenHCI_CloseEndpoint()
//

// Normal state.  If the endpoint is in this state, OpenHCI_PauseED()
// will set the endpoint sKip bit, else the sKip bit is already set.
//
#define HCD_ED_PAUSE_NOT_PAUSED     0

// Set when OpenHCI_PauseED() is called, which is called either by
// OpenHCI_CancelTransfer() or by OpenHCI_AbortEndpoint().
//
#define HCD_ED_PAUSE_NEEDED         1

// Set when OpenHCI_CancelTDsForED() starts running.  If the endpoint is
// still in this state after OpenHCI_CancelTDsForED() has made a pass through
// all of the requests queued on the endpoint, the pause is complete and
// the state is set back to HCD_ED_PAUSE_NOT_PAUSED and the sKip is cleared.
// Else the state is set back to HCD_ED_PAUSE_PROCESSING again and another
// pass is made through all of the requests queued on the endpoints.
//
#define HCD_ED_PAUSE_PROCESSING     2


//
// HCD Transfer Descriptor
//

//
// HCD_TRANSFER_DESCRIPTOR and HCD_ENDPOINT_DESCRIPTOR structures are
// allocated from a common pool and share the Flags field.
//

#define TD_FLAG_INUSE       0x01    // Indicates that the structure is allocated
#define TD_FLAG_IS_ED       0x80    // Indicates that the structure is an ED


// This structure MUST be exactly 64 or 128 bytes long
// we use 128 byte EDs for the 64 bit platform

typedef struct _HCD_TRANSFER_DESCRIPTOR {
    HC_TRANSFER_DESCRIPTOR           HcTD;        /* first 16 bytes */
    ULONG                            PhysicalAddress;

    UCHAR                            BaseIsocURBOffset;
    BOOLEAN                          Canceled;
    UCHAR                            Flags;
    UCHAR                            Reserved[1];   // fill out to 64 bytes

    LIST_ENTRY                       RequestList; /* list of TDs for a req */
    struct _HCD_TRANSFER_DESCRIPTOR  *NextHcdTD;
    PHCD_URB                         UsbdRequest;
    struct _HCD_ENDPOINT             *Endpoint;
    ULONG                            TransferCount;

#ifdef _WIN64
    ULONG64                          _SortNext;
    ULONG                            Pad22[8];      // fill out to 128 bytes
#endif
} HCD_TRANSFER_DESCRIPTOR, *PHCD_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) == 64) ||
         (sizeof(HCD_TRANSFER_DESCRIPTOR) == 128));

C_ASSERT(sizeof(HCD_ENDPOINT_DESCRIPTOR) == sizeof(HCD_TRANSFER_DESCRIPTOR));

C_ASSERT(FIELD_OFFSET(HCD_ENDPOINT_DESCRIPTOR, PhysicalAddress) ==
         FIELD_OFFSET(HCD_TRANSFER_DESCRIPTOR, PhysicalAddress));

C_ASSERT(FIELD_OFFSET(HCD_ENDPOINT_DESCRIPTOR, Flags) ==
         FIELD_OFFSET(HCD_TRANSFER_DESCRIPTOR, Flags));



#ifdef _WIN64
#define SortNext _SortNext
#else
#define SortNext HcTD.NextTD
#endif

//
// HCD Endpoint control structure
//

// set when ep is closed successfully
#define EP_CLOSED                       0x00000001
// set to if the root hub code owns this ep
#define EP_ROOT_HUB                     0x00000002
// need to abort all transfers for this endpoint
#define EP_ABORT                        0x00000004
// endpoint needs to be freed
#define EP_FREE                         0x00000008
// endpoint has had no transfers submitted,
// restored on reset
#define EP_VIRGIN                       0x00000020
// limit endpoint to one outstanding TD
#define EP_ONE_TD                       0x00000040
// in active list
#define EP_IN_ACTIVE_LIST               0x00000080


#define SET_EPFLAG(ep, flag)    ((ep)->EpFlags |= (flag))
#define CLR_EPFLAG(ep, flag)    ((ep)->EpFlags &= ~(flag))

typedef struct _HCD_ENDPOINT {
    ULONG                       Sig;
    PHCD_ENDPOINT_DESCRIPTOR    HcdED;
    PHCD_TRANSFER_DESCRIPTOR    HcdHeadP;
    PHCD_TRANSFER_DESCRIPTOR    HcdTailP;

    ULONG                       EpFlags;
    UCHAR                       Pad[3];
    UCHAR                       Rate;

    LIST_ENTRY                  RequestQueue;   // Protected by QueueLock
    LIST_ENTRY                  EndpointListEntry;
    LONG                        EndpointStatus; // Requests currently on HW
    LONG                        MaxRequest;     // Max requests allowed on HW

    UCHAR                       Type;
    UCHAR                       ListIndex;
    USHORT                      Bandwidth;

    struct _HCD_DEVICE_DATA     *DeviceData;

    HC_ENDPOINT_CONTROL;        // copy of control that is/will be in

    ULONG                       DescriptorsReserved;
    KSPIN_LOCK                  QueueLock;      // QueueLock protects RequestQueue

    ULONG                       NextIsoFreeFrame;
    ULONG                       MaxTransfer;
    PVOID                       TrueTail;
    PIRP                        AbortIrp;
} HCD_ENDPOINT, *PHCD_ENDPOINT;

//
// Each Host Controller Endpoint Descriptor is also doubly linked into a list tracked by HCD.
// Each ED queue is managed via an HCD_ED_LIST
//
typedef struct _HCD_ED_LIST {
   LIST_ENTRY        Head;
   PULONG            PhysicalHead;
   USHORT            Bandwidth;
   UCHAR             Next;
   BOOLEAN           HcRegister;                // PhysicalHead is in a Host Controller register
} HCD_ED_LIST, *PHCD_ED_LIST;

//
// The different ED lists are as follows.
//
#define  ED_INTERRUPT_1ms        0
#define  ED_INTERRUPT_2ms        1
#define  ED_INTERRUPT_4ms        3
#define  ED_INTERRUPT_8ms        7
#define  ED_INTERRUPT_16ms       15
#define  ED_INTERRUPT_32ms       31
#define  ED_CONTROL              63
#define  ED_BULK                 64
#define  ED_ISOCHRONOUS          0     // same as 1ms interrupt queue
#define  NO_ED_LISTS             65
#define  ED_EOF                  0xff

//
// HCD Descriptor Page List Entry data structure.
// 
// These entries are used to link together the common buffer pages that are
// allocated to hold TD and ED data structures.  In addition, the HCCA and the
// static EDs for the interrupt endpoint polling interval tree are contained
// in the first common buffer page that is allocated.
//

typedef struct _PAGE_LIST_ENTRY *PPAGE_LIST_ENTRY;

typedef struct _PAGE_LIST_ENTRY {
    PPAGE_LIST_ENTRY            NextPage;       // NULL terminated list
    ULONG                       BufferSize;     // Allocated buffer size
    PHYSICAL_ADDRESS            PhysAddr;       // Base phys address of page
    PHYSICAL_ADDRESS            FirstTDPhys;    // Phys addr of the first TD
    PHYSICAL_ADDRESS            LastTDPhys;     // Phys addr of the last TD
    PCHAR                       VirtAddr;       // Base virt address of page
    PHCD_TRANSFER_DESCRIPTOR    FirstTDVirt;    // Virt addr of the first TD
    PHCD_TRANSFER_DESCRIPTOR    LastTDVirt;     // Virt Addr of the last TD
} PAGE_LIST_ENTRY, *PPAGE_LIST_ENTRY;


//values for HcFlags
#define HC_FLAG_REMOTE_WAKEUP_CONNECTED     0x00000001
#define HC_FLAG_LEGACY_BIOS_DETECTED        0x00000002
#define HC_FLAG_SLOW_BULK_ENABLE            0x00000004
#define HC_FLAG_SHUTDOWN                    0x00000008  // not really used
#define HC_FLAG_MAP_SX_TO_D3                0x00000010
#define HC_FLAG_IDLE                        0x00000020
#define HC_FLAG_DISABLE_IDLE_CHECK          0x00000040
#define HC_FLAG_DEVICE_STARTED              0x00000080
#define HC_FLAG_LOST_POWER                  0x00000100
#define HC_FLAG_DISABLE_IDLE_MODE           0x00000200
#define HC_FLAG_USE_HYDRA_HACK              0x00000400
#define HC_FLAG_IN_DPC                      0x00000800
#define HC_FLAG_SUSPEND_NEXT_D3             0x00001000
#define HC_FLAG_LIST_FIX_ENABLE             0x00002000
#define HC_FLAG_HUNG_CHECK_ENABLE           0x00004000

#define PENDING_TD_LIST_SIZE                1000

//
// HCD Device Data == Device Extention data
//
typedef struct _HCD_DEVICE_DATA {
   UCHAR                               UsbdWorkArea[sizeof(USBD_EXTENSION)];

   ULONG                               DebugLevel;
   ULONG                               DeviceNameHandle;    // handle passed to USBD to generate device name
   ULONG                               HcFlags;
   KSPIN_LOCK                          InterruptSpin;       // Spinlock for interrupt

   PDEVICE_OBJECT                      DeviceObject;        // point back to device object
   PDMA_ADAPTER                        AdapterObject;       // point to our adapter object
   ULONG                               NumberOfMapRegisters;// max number of map registers per transfer
   PKINTERRUPT                         InterruptObject;     // Pointer to interrupt object.

   KDPC                                IsrDPC;
   PHC_OPERATIONAL_REGISTER            HC;                  // pointer to hw registers
   ULONG                               HClength;            // save length for MmUnmapIoSpace
   PHCCA_BLOCK                         HCCA;                // pointer to shared memory
   KSPIN_LOCK                          EDListSpin;

    // our pool of descriptors
   SINGLE_LIST_ENTRY                   FreeDescriptorList;
   ULONG                               FreeDescriptorCount;
   PPAGE_LIST_ENTRY                    PageList;            // pages aquired for descriptors
   LIST_ENTRY                          StalledEDReclamation;
   LIST_ENTRY                          RunningEDReclamation;
   LIST_ENTRY                          PausedEDRestart;
   LIST_ENTRY                          ActiveEndpointList;  // list of
                                                            // endpoints that
                                                            // processing
   LONG                                HcDma;
   HCD_ED_LIST                         EDList[NO_ED_LISTS];

   HC_CONTROL                          CurrentHcControl;
   HC_CONTROL                          ListEnablesAtNextSOF;

   HC_FM_INTERVAL                      OriginalInterval;
   ULONG                               FrameHighPart;
   ULONG                               AvailableBandwidth;
   ULONG                               MaxBandwidthInUse;

   ULONG                               ControlSav;
   ULONG                               BulkSav;
   ULONG                               HcHCCASav;

   ULONG                               LostDoneHeadCount;   // Diagnostic aid
   ULONG                               ResurrectHCCount;    // Diagnostic aid
   ULONG                               FrozenHcDoneHead;
   ULONG                               LastHccaDoneHead;
   ULONGLONG                           LastDeadmanTime;

   KSPIN_LOCK                          DescriptorsSpin;
   KSPIN_LOCK                          ReclamationSpin;
   KSPIN_LOCK                          PausedSpin;
   KSPIN_LOCK                          HcFlagSpin;
   KSPIN_LOCK                          PageListSpin;
   KSPIN_LOCK                          HcDmaSpin;

   LARGE_INTEGER                       LastIdleTime;
   LONG                                IdleTime;

   struct
   {  /* A context structure between Isr and Dpc */
      ULONG ContextInfo;
      ULONG Frame;
   } IsrDpc_Context;

   BOOLEAN                             InterruptShare;
   UCHAR                               Pad3[3];

   PHYSICAL_ADDRESS                    cardAddress;
   PHCD_ENDPOINT                       RootHubControl;
   PHCD_ENDPOINT                       RootHubInterrupt;    // root hub interrupt endpoint (EP 1)
   UCHAR                               RootHubAddress;      // device address of root hub (starts as 0)
   ULONG                               PortsSuspendedAtSuspend;
   ULONG                               PortsEnabledAtSuspend;

   DEVICE_POWER_STATE                  CurrentDevicePowerState;
// When we suspend, the states of the ports are not kept by the host
// controller through the resume.  We have to find out what the states
// are and put them back.  These are bit masks of the ports that are
// either set enabled or suspended.
//
   UCHAR                               RootHubConfig;
   UCHAR                               NumberOfPorts;
   UCHAR                               Pad2[1];
   UCHAR                               ZeroLoadEndpoint_AddrHolder;

   USHORT                              VendorID;
   USHORT                              DeviceID;

   UCHAR                               RevisionID;
   UCHAR                               Pad[3];

   PDEVICE_OBJECT                      RealPhysicalDeviceObject;
   PDEVICE_OBJECT                      TopOfStackPhysicalDeviceObject;

   KTIMER                              DeadmanTimer;
   KDPC                                DeadmanTimerDPC;

#define ZERO_LOAD_ENDPOINT(DeviceData) \
        ((PVOID) (&(DeviceData)->ZeroLoadEndpoint_AddrHolder))
   //
   // We need a memory location that will not be used by any other
   // pointer so that we can uniquely identify an endpoint on which there
   // is a max packet size of zero.  AKA one with no load.
   //

   LONG OpenCloseSync; // Debugging tool to insure serial
                       // _OpenEndpoint and _CloseEndpoint

   ULONG                                FakePortChange;     // Per port bitmap
   ULONG                                FakePortDisconnect; // Per port bitmap


} HCD_DEVICE_DATA, *PHCD_DEVICE_DATA;


typedef struct _OHCI_RESOURCES {
    ULONG InterruptVector;
    KIRQL InterruptLevel;
    KAFFINITY Affinity;
    BOOLEAN ShareIRQ;
    KINTERRUPT_MODE InterruptMode;
} OHCI_RESOURCES, *POHCI_RESOURCES;


#define OHCI_MAP_INIT   0x01

typedef struct _MAP_CONTEXT {
    BOOLEAN Mapped;
    UCHAR Flags;
    UCHAR Pad[2];
    PHYSICAL_ADDRESS PhysAddress;
    ULONG LengthMapped;
    PVOID CurrentVa;
    PVOID MapRegisterBase;
    ULONG TotalLength;
} MAP_CONTEXT, *PMAP_CONTEXT;



typedef struct _KeSync_HcControl
{
   PHCD_DEVICE_DATA   DeviceData;
   HC_CONTROL         NewHcControl;

} KeSynch_HcControl, *PKeSynch_HcControl;

#ifdef DEBUG_LOG

#ifdef IRP_LOG
#define IRP_IN(i) OHCI_LogIrp((i), 1)
#define IRP_OUT(i) OHCI_LogIrp((i), 0)
#else
#define IRP_IN(i)
#define IRP_OUT(i)
#endif

#define LOGENTRY(m, sig, info1, info2, info3)     \
    OHCI_Debug_LogEntry(m, sig, (ULONG_PTR)info1, \
                        (ULONG_PTR)info2,         \
                        (ULONG_PTR)info3)

#define LOGIRQL() LOGENTRY(G, 'IRQL', KeGetCurrentIrql(), 0, 0);

VOID
OHCI_Debug_LogEntry(
    IN ULONG Mask,
    IN ULONG Sig,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
    );

VOID
OHCI_LogInit(
    );

VOID
OHCI_LogFree(
    VOID
    );

#else

#define LOGENTRY(mask, sig, info1, info2, info3)
#define OHCI_LogInit()
#define OHCI_LogFree()
#define LOGIRQL()
#define IRP_IN(i)
#define IRP_OUT(i)

#endif



#define ENABLE_LIST(hc, ep) \
    { \
    ULONG listFilled = 0;\
    ULONG temp;\
    ASSERT_ENDPOINT(ep);\
    \
    temp = READ_REGISTER_ULONG (&(hc)->HcControlHeadED);\
    if (temp) {\
        listFilled |= HcCmd_ControlListFilled;\
    }\
    temp = READ_REGISTER_ULONG (&(hc)->HcBulkHeadED);\
    if (temp) {\
        listFilled |= HcCmd_BulkListFilled;\
    }\
    if (USB_ENDPOINT_TYPE_BULK == (ep)->Type) {\
        listFilled |= HcCmd_BulkListFilled;\
    } else if (USB_ENDPOINT_TYPE_CONTROL == (ep)->Type) {\
        listFilled |= HcCmd_ControlListFilled;\
    }\
    WRITE_REGISTER_ULONG(&(hc)->HcCommandStatus.ul,\
                         listFilled);\
    LOGENTRY(G, 'enaL', listFilled, ep, 0); \
    };

//
// Function Prototypes
//

BOOLEAN OpenHCI_InterruptService (IN PKINTERRUPT Interrupt,
                                  IN void * ServiceContext);
NTSTATUS OpenHCI_URB_Dispatch (IN PDEVICE_OBJECT, IN PIRP);
ULONG    Get32BitFrameNumber (PHCD_DEVICE_DATA);
PHCD_ENDPOINT_DESCRIPTOR InsertEDForEndpoint (IN PHCD_DEVICE_DATA, IN PHCD_ENDPOINT, IN UCHAR,
            IN PHCD_TRANSFER_DESCRIPTOR *);

PHCD_TRANSFER_DESCRIPTOR
OpenHCI_Alloc_HcdTD(
    PHCD_DEVICE_DATA DeviceData
    );

VOID
OpenHCI_Free_HcdTD(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    );

PHCD_ENDPOINT_DESCRIPTOR
OpenHCI_Alloc_HcdED(
    PHCD_DEVICE_DATA DeviceData
    );

VOID
OpenHCI_Free_HcdED(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_ENDPOINT_DESCRIPTOR Ed
    );

PHCD_TRANSFER_DESCRIPTOR
OpenHCI_LogDesc_to_PhyDesc (PHCD_DEVICE_DATA, ULONG);

void     OpenHCI_PauseED (PHCD_ENDPOINT);

BOOLEAN  OpenHCI_InterruptService (PKINTERRUPT, void *);
void     OpenHCI_IsrDPC (PKDPC, PVOID, PVOID, PVOID);

void     OpenHCI_CompleteIrp(PDEVICE_OBJECT, PIRP, NTSTATUS);
BOOLEAN OpenHCI_StartController (PVOID context);

void     OpenHCI_StartEndpoint (PHCD_ENDPOINT);
NTSTATUS OpenHCI_StartTransfer (PDEVICE_OBJECT, PIRP);
NTSTATUS OpenHCI_RootHubStartXfer (PDEVICE_OBJECT, PHCD_DEVICE_DATA, PIRP, PHCD_URB, PHCD_ENDPOINT);
BOOLEAN  OpenHCI_HcControl_OR  (PVOID);
BOOLEAN  OpenHCI_HcControl_AND (PVOID);
BOOLEAN  OpenHCI_HcControl_SetHCFS (PVOID);
BOOLEAN  OpenHCI_ListEnablesAtNextSOF (PVOID);
void     OpenHCI_CancelTransfer (PDEVICE_OBJECT, PIRP);
NTSTATUS OpenHCI_AbortEndpoint(PDEVICE_OBJECT, PIRP, PHCD_DEVICE_DATA, PHCD_URB);
void  EmulateRootHubInterruptXfer(PHCD_DEVICE_DATA, PHC_OPERATIONAL_REGISTER);
NTSTATUS CheckRootHub(PHCD_DEVICE_DATA , PHC_OPERATIONAL_REGISTER HC, PHCD_URB);

//jd
VOID
RemoveEDForEndpoint(
    IN PHCD_ENDPOINT
    );

NTSTATUS
OpenHCI_SetDevicePowerState(
    IN PDEVICE_OBJECT,
    IN PIRP,
    IN DEVICE_POWER_STATE
    );

NTSTATUS
OpenHCI_DeferredStartDevice(
    IN PDEVICE_OBJECT,
    IN PIRP
    );

NTSTATUS
OpenHCI_DeferIrpCompletion(
    PDEVICE_OBJECT,
    PIRP,
    PVOID
    );

NTSTATUS
OpenHCI_StartDevice(
    IN PDEVICE_OBJECT,
    IN POHCI_RESOURCES
    );

NTSTATUS
OpenHCI_QueryCapabilities(
    PDEVICE_OBJECT,
    PDEVICE_CAPABILITIES
    );

NTSTATUS
OpenHCI_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
OpenHCI_SaveHCstate(
    PHCD_DEVICE_DATA
    );

NTSTATUS
OpenHCI_RestoreHCstate(
    PHCD_DEVICE_DATA,
    PBOOLEAN
    );

NTSTATUS
OpenHCI_DeferPoRequestCompletion(
    IN PDEVICE_OBJECT,
    IN UCHAR,
    IN POWER_STATE,
    IN PVOID,
    IN PIO_STATUS_BLOCK
    );

NTSTATUS
OpenHCI_RootHubPower(
    IN PDEVICE_OBJECT,
    IN PIRP
    );

NTSTATUS
OpenHCI_ReserveDescriptors(
    IN PHCD_DEVICE_DATA,
    IN ULONG
    );

NTSTATUS
OpenHCI_QueueTransfer(
    PDEVICE_OBJECT ,
    PIRP
    );

NTSTATUS
OpenHCI_Dispatch(
    IN PDEVICE_OBJECT ,
    IN PIRP
    );

VOID
OpenHCI_Unload(
    IN PDRIVER_OBJECT
    );

VOID
OpenHCI_SetTranferError(
    PHCD_URB,
    NTSTATUS
    );

VOID
OpenHCI_EndpointWorker(
    PHCD_ENDPOINT
    );

NTSTATUS
OpenHCI_GrowDescriptorPool (
    IN PHCD_DEVICE_DATA     DeviceData,
    IN ULONG                ReserveLength,
    OUT PCHAR               *VirtAddr OPTIONAL,
    OUT PHYSICAL_ADDRESS    *PhysAddr OPTIONAL
    );

VOID
OpenHCI_LockAndCheckEndpoint(
    PHCD_ENDPOINT ,
    PBOOLEAN ,
    PBOOLEAN ,
    PKIRQL
    );

VOID
OpenHCI_UnlockEndpoint(
    PHCD_ENDPOINT ,
    KIRQL
    );

BOOLEAN
OpenHCI_StopController(
    IN PVOID
    );

NTSTATUS
OpenHCI_StopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN TouchTheHardware
    );

NTSTATUS
OpenHCI_Shutdown(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
OpenHCI_StartBIOS(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
OpenHCI_StopBIOS(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
OpenHCI_GetSOFRegModifyValue(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG SofModifyValue
    );

NTSTATUS
OpenHCI_GetRegFlags(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG SofModifyValue
    );

VOID
OpenHCI_DeadmanDPC(
    PKDPC Dpc,
    PVOID DeviceObject,
    PVOID Context1,
    PVOID Context2
    );

NTSTATUS
OpenHCI_InsertMagicEDs(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
OpenHCI_ResurrectHC(
    PHCD_DEVICE_DATA DeviceData
    );

ULONG
FindLostDoneHead (
    IN PHCD_DEVICE_DATA DeviceData
    );


PHYSICAL_ADDRESS
OpenHCI_IoMapTransfer(
    IN PMAP_CONTEXT MapContext,
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN ULONG TotalLength,
    IN BOOLEAN WriteToDevice
    );

NTSTATUS
OpenHCI_ExternalGetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG CurrentFrame
    );

ULONG
OpenHCI_ExternalGetConsumedBW(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
OpenHCI_RhPortsIdle(
    PHCD_DEVICE_DATA DeviceData
    );

VOID
OpenHCI_ProcessEndpoint(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_ENDPOINT Endpoint
    );

NTSTATUS
OpenHCI_Resume(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN LostPower
    );

ULONG
ReadPortStatusFix(
    PHCD_DEVICE_DATA    DeviceData,
    ULONG               PortIndex
    );


#endif /* OPENHCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\openhci\ohciurb.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   ohciurb.c

Abstract:

   The module manages transactions on the USB.

Environment:

   kernel mode only

Notes:

Revision History:

   02-07-96:   created  jfuller
   03-05-96:   in work  kenray

--*/

#include "openhci.h"

/*
    Private functions to this module
*/
NTSTATUS
OpenHCI_OpenEndpoint(
    IN PDEVICE_OBJECT,
    IN PIRP,
    PHCD_DEVICE_DATA,
    PHCD_URB);

NTSTATUS
OpenHCI_CloseEndpoint(
    IN PDEVICE_OBJECT,
    IN PIRP,
    PHCD_DEVICE_DATA,
    PHCD_URB);

VOID
OpenHCI_CompleteIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS ntStatus
    )
/*++

Routine Description:

    Completes an I/O Request

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet to complete

    ntStatus - status code to set int the IRP when completed

Return Value:


--*/
{
    PHCD_DEVICE_DATA DeviceData;

    DeviceData = DeviceObject->DeviceExtension;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    //
    // call IoCompleteRequest thru USBD to give it a chance to do
    // cleanup and error mapping
    //

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CALL_TRACE,
                      ("'Completing IRP %x (%x)\n", Irp, ntStatus));

    IRP_OUT(Irp);
    LOGENTRY(G, 'Cirp', Irp, 0, ntStatus);
    USBD_CompleteRequest(Irp, IO_NO_INCREMENT);
}


NTSTATUS
OpenHCI_URB_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Process URBs from the dispatch routine.

Arguments:

   DeviceObject - pointer to a device object

   Irp - pointer to an I/O Request Packet

Return Value:


--*/
{
    PHCD_URB urb;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHCD_DEVICE_DATA DeviceData;
    PHCD_ENDPOINT endpoint;
    struct _URB_HCD_ENDPOINT_STATE *state;
    PHC_OPERATIONAL_REGISTER HC;

    DeviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;
    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_CALL_TRACE, ("'enter URB_Dispatch \n"));

    HC = DeviceData->HC;

    urb = (PHCD_URB) URB_FROM_IRP(Irp);

    switch (urb->UrbHeader.Function) {

        //
        // Open Endpoint and Close Endpoint IRPs are serialized
        // within USBD so we can execute them now.
        //
    case URB_FUNCTION_HCD_OPEN_ENDPOINT:
        ntStatus = OpenHCI_OpenEndpoint(DeviceObject, Irp, DeviceData, urb);
        OpenHCI_CompleteIrp(DeviceObject, Irp, ntStatus);
        break;

    case URB_FUNCTION_HCD_CLOSE_ENDPOINT:
        ntStatus = OpenHCI_CloseEndpoint(DeviceObject, Irp, DeviceData, urb);
        OpenHCI_CompleteIrp(DeviceObject, Irp, ntStatus);
        break;

    case URB_FUNCTION_CONTROL_TRANSFER:
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
    case URB_FUNCTION_ISOCH_TRANSFER:

        endpoint = urb->HcdUrbCommonTransfer.hca.HcdEndpoint;

        ntStatus = OpenHCI_QueueTransfer(DeviceObject, Irp);

        if (ntStatus != STATUS_PENDING) {
            OpenHCI_CompleteIrp(DeviceObject, Irp, ntStatus);
        }
        break;

    case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
        urb->UrbGetCurrentFrameNumber.FrameNumber
            = Get32BitFrameNumber(DeviceData);
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CALL_INFO,
                          ("'Get32BitFrameNumber: %x",
                          Get32BitFrameNumber(DeviceData)));
        urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
        OpenHCI_CompleteIrp(DeviceObject, Irp, ntStatus);
        break;

    case URB_FUNCTION_SET_FRAME_LENGTH:
        {
        HC_FM_INTERVAL interval;

        //get the current value
        interval.ul =
             READ_REGISTER_ULONG(&HC->HcFmInterval.ul);

        interval.FrameInterval +=
            (CHAR) urb->UrbSetFrameLength.FrameLengthDelta;

        WRITE_REGISTER_ULONG(&HC->HcFmInterval.ul,
            interval.ul);

        urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
        OpenHCI_CompleteIrp(DeviceObject, Irp, ntStatus);
        }
        break;

     case URB_FUNCTION_GET_FRAME_LENGTH:
        {
        HC_FM_INTERVAL interval;

        //get the current value
        interval.ul =
             READ_REGISTER_ULONG(&HC->HcFmInterval.ul);

        urb->UrbGetFrameLength.FrameNumber =
            Get32BitFrameNumber(DeviceData);
        urb->UrbGetFrameLength.FrameLength =
            interval.FrameInterval;

        urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
        OpenHCI_CompleteIrp(DeviceObject, Irp, ntStatus);
        }
        break;


    case URB_FUNCTION_HCD_GET_ENDPOINT_STATE:
        {
        KIRQL irql;
        BOOLEAN queuedTransfers, activeTransfers;

        state = &urb->HcdUrbEndpointState;
        endpoint = state->HcdEndpoint;

        LOGENTRY(G, 'gEPS', Irp, endpoint, 0);

        if (endpoint == ZERO_LOAD_ENDPOINT(DeviceData)) {
            state->HcdEndpointState = 0;
        } else {

            ASSERT_ENDPOINT(endpoint);

            OpenHCI_LockAndCheckEndpoint(endpoint,
                                         &queuedTransfers,
                                         &activeTransfers,
                                         &irql);

            if (endpoint->EpFlags & EP_ROOT_HUB) {
                 state->HcdEndpointState =
                     (queuedTransfers | activeTransfers)
                        ? HCD_ENDPOINT_TRANSFERS_QUEUED : 0;
            } else {
                state->HcdEndpointState =
                    ((endpoint->HcdED->HcED.HeadP & HcEDHeadP_HALT)
                     ? HCD_ENDPOINT_HALTED : 0)
                    | ((queuedTransfers | activeTransfers)
                       ? HCD_ENDPOINT_TRANSFERS_QUEUED : 0);
            }

            OpenHCI_UnlockEndpoint(endpoint,
                                   irql);

        }
        urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
        LOGENTRY(G, 'GETs', Irp, endpoint, state->HcdEndpointState);
        OpenHCI_CompleteIrp(DeviceObject, Irp, ntStatus);
        }
        break;

    case URB_FUNCTION_HCD_SET_ENDPOINT_STATE:
        {
        PHC_ENDPOINT_DESCRIPTOR hcED;

        state = &urb->HcdUrbEndpointState;
        endpoint = state->HcdEndpoint;
        ASSERT_ENDPOINT(endpoint);

        hcED = &endpoint->HcdED->HcED;
        LOGENTRY(G, 'SETs', Irp, endpoint, state->HcdEndpointState);

        // reset some endpoint flags
        SET_EPFLAG(endpoint, EP_VIRGIN);

        // need to reset data toggle on clear halt
        if (state->HcdEndpointState & HCD_ENDPOINT_RESET_DATA_TOGGLE) {
            //OHCI_ASSERT(hcED->sKip ||
            //            (hcED->HeadP & HcEDHeadP_HALT));
            hcED->HeadP = (endpoint->HcdHeadP->PhysicalAddress
                              & ~HcEDHeadP_CARRY);
        }

        if (!(state->HcdEndpointState & HCD_ENDPOINT_HALTED)) {

            LOGENTRY(G, 'CLRh', Irp, endpoint, state->HcdEndpointState);

            if (hcED->HeadP & HcEDHeadP_HALT) {
                // If the endpoint is indeed halted than the hardware will
                // not be touching the ED. So we should be able to set this
                // flag with impunity.
                hcED->HeadP &= ~HcEDHeadP_HALT;
                LOGENTRY(G, 'HLTn', Irp, endpoint, state->HcdEndpointState);
            }

            ENABLE_LIST(DeviceData->HC, endpoint);
        }
        }
        urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
        OpenHCI_CompleteIrp(DeviceObject, Irp, ntStatus);
        break;

    case URB_FUNCTION_HCD_ABORT_ENDPOINT:

        endpoint = urb->HcdUrbAbortEndpoint.HcdEndpoint;
        LOGENTRY(G, 'Abrt', Irp, endpoint, 0);
        if (ZERO_LOAD_ENDPOINT(DeviceData) == endpoint) {
            ntStatus = STATUS_SUCCESS;
        } else {
            KIRQL oldIrq;

            KeAcquireSpinLock(&DeviceData->PausedSpin, &oldIrq);
#if DBG
            if (endpoint->EpFlags & EP_ROOT_HUB) {
                OHCI_ASSERT(endpoint->AbortIrp == NULL);
            }
#endif
            if (endpoint->AbortIrp != NULL) {
                // if we get an abort while we still have an abort irp
                // pending then the driver has a bug, we will just fail
                // the request
                TRAP();
                ntStatus = STATUS_UNSUCCESSFUL;
                KeReleaseSpinLock(&DeviceData->PausedSpin, oldIrq);
                OpenHCI_CompleteIrp(DeviceObject, Irp, ntStatus);
            } else {
                KeReleaseSpinLock(&DeviceData->PausedSpin, oldIrq);
                ntStatus = OpenHCI_AbortEndpoint(DeviceObject,
                                                 Irp,
                                                 DeviceData,
                                                 urb);
            }
        }

        break;

    default:
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CALL_ERROR,
            ("'OpenHCI_URB_Dispatch -- invalid URB function (%x)\n",
            urb->UrbHeader.Function));
        urb->UrbHeader.Status = USBD_STATUS_INVALID_URB_FUNCTION;
        OpenHCI_CompleteIrp(DeviceObject, Irp, ntStatus);
    }

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CALL_TRACE,
                      ("'exit OpenHCI_URB_Dispatch (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
OpenHCI_GrowDescriptorPool (
    IN PHCD_DEVICE_DATA     DeviceData,
    IN ULONG                ReserveLength,
    OUT PCHAR               *VirtAddr OPTIONAL,
    OUT PHYSICAL_ADDRESS    *PhysAddr OPTIONAL
)
/*++

Routine Description:

    Reserve Transfer/Endpoint Descriptors.

    This function allocates a block of common buffer memory for
    Transfer and Endpoint Descriptors and puts it on a tracking
    list in the device extension.

Arguments:

    DeviceData - pointer to a device extension

    ReserveLength - amount of space to reserve at the beginning
    of the common buffer

    VirtAddr - virtual address of space reserved at the beginning
    of the common buffer

    PhysAddr - physical address of space reserved at the beginning
    of the common buffer

Return Value:

    NT Status code

--*/
{
    ULONG                       allocLength;
    PCHAR                       pageVirt;
    PHYSICAL_ADDRESS            pagePhys;
    PPAGE_LIST_ENTRY            pageList;
    PHCD_TRANSFER_DESCRIPTOR    td;

    // Assert that sizeof(HCD_TRANSFER_DESCRIPTOR) is a power of 2
    //
    C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) &
              sizeof(HCD_TRANSFER_DESCRIPTOR) - 1) == 0);

    // Round up ReserveLength to the next multiple of the
    // sizeof(HCD_TRANSFER_DESCRIPTOR).
    // 
    ReserveLength += sizeof(HCD_TRANSFER_DESCRIPTOR) - 1;
    ReserveLength &= ~(sizeof(HCD_TRANSFER_DESCRIPTOR) - 1);

    // Round up allocLength to the next multiple of PAGE_SIZE
    //
    allocLength = ReserveLength + PAGE_SIZE;
    allocLength &= ~(PAGE_SIZE - 1);

    // Now allocate the common buffer
    //
    pageVirt = HalAllocateCommonBuffer(DeviceData->AdapterObject,
                                       allocLength,
                                       &pagePhys,
                                       CacheCommon);

    if (pageVirt == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Zero initialize the whole page
    //
    RtlZeroMemory(pageVirt, allocLength);

    // Allocate a PAGE_LIST_ENTRY to track the page of commom buffer.
    //
    pageList = ExAllocatePoolWithTag(NonPagedPool,
                                     sizeof(PAGE_LIST_ENTRY),
                                     OpenHCI_TAG);

    if (pageList == NULL)
    {
        HalFreeCommonBuffer(DeviceData->AdapterObject,
                            allocLength,
                            pagePhys,
                            pageVirt,
                            CacheCommon);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    LOGENTRY(G, 'GROW', DeviceData, pageList, pagePhys.LowPart);

    // Initialize the PAGE_LIST_ENTRY to track the page of commom buffer.
    //
    pageList->BufferSize = allocLength;

    pageList->VirtAddr = pageVirt;

    pageList->PhysAddr = pagePhys;

    pageList->FirstTDVirt = (PHCD_TRANSFER_DESCRIPTOR)(pageVirt + ReserveLength);

    pageList->LastTDVirt  = (PHCD_TRANSFER_DESCRIPTOR)(pageVirt + allocLength) - 1;

    pageList->FirstTDPhys = pagePhys;
    pageList->FirstTDPhys.LowPart += ReserveLength;

    pageList->LastTDPhys  = pagePhys;
    pageList->LastTDPhys.LowPart  += allocLength - sizeof(PHCD_TRANSFER_DESCRIPTOR);;


    // Add the PAGE_LIST_ENTRY to the device extension
    //
    ExInterlockedPushEntryList((PSINGLE_LIST_ENTRY)&DeviceData->PageList,
                               (PSINGLE_LIST_ENTRY)pageList,
                               &DeviceData->PageListSpin);

    // Add all of the TDs in the page of common buffer to the
    // Free Descriptor list.
    //
    pagePhys = pageList->FirstTDPhys;
    
    for (td = pageList->FirstTDVirt; td <= pageList->LastTDVirt; td++)
    {
        // Initialize the TD PhysicalAddress field to point back to the TD
        //
        td->PhysicalAddress = pagePhys.LowPart;

        pagePhys.LowPart += sizeof(HCD_TRANSFER_DESCRIPTOR);

        ExInterlockedPushEntryList(&DeviceData->FreeDescriptorList,
                                   (PSINGLE_LIST_ENTRY)td,
                                   &DeviceData->DescriptorsSpin);

        InterlockedIncrement(&DeviceData->FreeDescriptorCount);
    }

    // Return pointers to the reserved space if desired
    //
    if (VirtAddr)
    {
        *VirtAddr = pageList->VirtAddr;
    }
    if (PhysAddr)
    {
        *PhysAddr = pageList->PhysAddr;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
OpenHCI_ReserveDescriptors(
    IN PHCD_DEVICE_DATA DeviceData,
    IN ULONG DescriptorCount
    )
/*++

Routine Description:

    Reserve Transfer/Endpoint Descriptors.

    NOTE:
    This routine is called only by openendpoint so it will never be
    rentered.

Arguments:

    DeviceData - pointer to a device extension
    DescriptorCount - number of descriptors to reserve

Return Value:

    NT Status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    while (DeviceData->FreeDescriptorCount < DescriptorCount &&
           NT_SUCCESS(ntStatus))
    {
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CALL_TRACE,
                          ("'grow pool by one page\n"));

        ntStatus = OpenHCI_GrowDescriptorPool(DeviceData,
                                              0,
                                              NULL,
                                              NULL);
    }

    if (NT_SUCCESS(ntStatus))
    {
        DeviceData->FreeDescriptorCount -= DescriptorCount;
    }

    LOGENTRY(G, 'rsDS',
        DescriptorCount, DeviceData->FreeDescriptorCount, ntStatus);

    return ntStatus;
}


NTSTATUS
OpenHCI_UnReserveDescriptors(
    IN PHCD_DEVICE_DATA DeviceData,
    IN ULONG DescriptorCount
    )
/*++

Routine Description:

    Free reserved Transfer/Endpoint Descriptors.

    NOTE:
    This routine is called only by closeendpoint so it will never be
    rentered.


Arguments:

    DeviceData - pointer to a device extension
    DescriptorCount - number of descriptors to reserve

Return Value:

    NT Status code

--*/
{
    DeviceData->FreeDescriptorCount += DescriptorCount;
    LOGENTRY(G, 'urDS', DescriptorCount, DeviceData->FreeDescriptorCount, 0);

    return STATUS_SUCCESS;
}


PHCD_TRANSFER_DESCRIPTOR
OpenHCI_Alloc_HcdTD(
    PHCD_DEVICE_DATA DeviceData
    )
/*++

Routine Description:

    allocate a reserved desriptor, this routine can be called at
    IRQL >= DISPATCH_LEVEL

Arguments:

    DeviceData - pointer to a device extension

Return Value:

    NT Status code

--*/
{
    PHCD_TRANSFER_DESCRIPTOR td;

    td = (PHCD_TRANSFER_DESCRIPTOR)
         ExInterlockedPopEntryList(&DeviceData->FreeDescriptorList,
                                   &DeviceData->DescriptorsSpin);

    LOGENTRY(G, 'alTD', &DeviceData->FreeDescriptorList, td, DeviceData->FreeDescriptorCount);

    OHCI_ASSERT(td != NULL);
    OHCI_ASSERT(td->Flags == 0);

    OHCI_ASSERT((td->PhysicalAddress & (PAGE_SIZE-1)) ==
                ((ULONG_PTR)td & (PAGE_SIZE-1)));

    // Initialize the TD NextTD pointer to a non-zero value before setting
    // the TD_FLAG_INUSE flag.  The only time a TD NextTD pointer should be
    // zero when the TD_FLAG_INUSE flag is set is when the TD is the tail
    // end of a done list.
    //
    td->HcTD.NextTD = 0x2BAD2BAD;

    td->Flags = TD_FLAG_INUSE;

    //
    // if we fail to get a td we have a bug since we always reserve
    // enough for the worst case scenario when an endpoint is opened
    //

    return td;
}


VOID
OpenHCI_Free_HcdTD(
    PHCD_DEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
{
    LOGENTRY(G, 'frTD', &DeviceData->FreeDescriptorList, Td, DeviceData->FreeDescriptorCount);

    OHCI_ASSERT((Td->PhysicalAddress & (PAGE_SIZE-1)) ==
                ((ULONG_PTR)Td & (PAGE_SIZE-1)));

    OHCI_ASSERT(Td->Flags == TD_FLAG_INUSE);

    Td->Flags = 0;

    ExInterlockedPushEntryList(&DeviceData->FreeDescriptorList,
                               (PSINGLE_LIST_ENTRY) Td,
                               &DeviceData->DescriptorsSpin);
}


PHCD_ENDPOINT_DESCRIPTOR
OpenHCI_Alloc_HcdED(
    PHCD_DEVICE_DATA DeviceData
    )
/*++

Routine Description:

    allocate a reserved desriptor, this routine can be called at
    IRQL >= DISPATCH_LEVEL

Arguments:

    DeviceData - pointer to a device extension

Return Value:

    NT Status code

--*/
{
    PHCD_ENDPOINT_DESCRIPTOR ed;

    ed = (PHCD_ENDPOINT_DESCRIPTOR)
         ExInterlockedPopEntryList(&DeviceData->FreeDescriptorList,
                                   &DeviceData->DescriptorsSpin);

    LOGENTRY(G, 'alED', &DeviceData->FreeDescriptorList, ed, DeviceData->FreeDescriptorCount);

    OHCI_ASSERT(ed != NULL);
    OHCI_ASSERT(ed->Flags == 0);

    OHCI_ASSERT((ed->PhysicalAddress & (PAGE_SIZE-1)) ==
                ((ULONG_PTR)ed & (PAGE_SIZE-1)));

    ed->Flags = TD_FLAG_INUSE | TD_FLAG_IS_ED;

    //
    // if we fail to get a td we have a bug since we always reserve
    // enough for the worst case scenario when an endpoint is opened
    //

    return ed;
}


PHCD_TRANSFER_DESCRIPTOR
OpenHCI_LogDesc_to_PhyDesc(
    PHCD_DEVICE_DATA    DeviceData,
    ULONG               LogDesc
)
/*++

Routine Description:
   This routine scans the list of pages allocated by
   HalAllocateCommonBuffer into the list DeviceData->PageList
   for the storage of Descriptors.
   The first entries describe the virtual and logical
   addresses of those pages.

Arguments:
   LogDesc is the logical address of a HcTD structure in memory.

Returned Value:
   The virtual address of the HCD_Descriptor the (logical) HC_descriptor.
   Note that the virtual address of the HC_TRANSFER_DESCRIPTOR
   is the same as HCD_TRANSFER_DESCRIPTOR as well as
   the HC_ENDPOINT_DESCRIPTOR the same as HCD_TRANSFER_DESCRIPTOR.

   If no translation is found this will return NULL.

   There are concurrent writes to DeviceData->PageList, but throughout
   the life of DeviceData, only new pages will be pushed onto the list.
   If these pages are added to the list while this function is running,
   these pages cannot contain the logical address for which we are
   searching.
--*/
{
    PPAGE_LIST_ENTRY            PageList;
    PHCD_TRANSFER_DESCRIPTOR    td;

    if (LogDesc & (sizeof(HCD_TRANSFER_DESCRIPTOR)-1))
    {
        // The address is not properly aligned to be a TD.
        // Something bad has happened.  Try our best not to
        // fault processing a bogus TD.
        //

        LOGENTRY(G, 'Phy1', DeviceData, LogDesc, 0);

        //TEST_TRAP();

        return NULL;
    }

    PageList = (PPAGE_LIST_ENTRY)DeviceData->PageList;

    while (PageList)
    {
        if (LogDesc >= PageList->FirstTDPhys.LowPart &&
            LogDesc <= PageList->LastTDPhys.LowPart)
        {
            td = (PHCD_TRANSFER_DESCRIPTOR)((PCHAR)PageList->FirstTDVirt +
                    LogDesc - PageList->FirstTDPhys.LowPart);

            if (td->Flags == TD_FLAG_INUSE)
            {
                // Appears to be a valid TD
                //
                return td;
            }
            else
            {
                // The TD is not marked as an in-use TD.  Something
                // bad has happened.  Try our best not to fault
                // processing a bogus TD.
                //

                LOGENTRY(G, 'Phy2', DeviceData, LogDesc, 0);

                //TEST_TRAP();

                return NULL;
            }
        }

        PageList = PageList->NextPage;
    }

    return NULL;
}


ULONG
OpenHCI_CheckBandwidth(
    IN PHCD_DEVICE_DATA DeviceData,
    IN UCHAR List,
    OUT PCHAR BestList
    )
/*++

Routine Description:

   This routine scans all the scheduling lists of frequency
   determined by the base List passed in and returns the worst
   bandwidth found (i.e., max in use by any given scheduling
   list) and the list which had the least bandwidth in use.

   All lists of the appropriate frequency are checked

Arguments:

   DeviceData - pointer to this controller's data area

   List - must be a base scheduling list.
          I.e., it must be one of ED_INTERRUPT_1ms, ED_INTERRUPT_2ms,
          ED_INTERRUPT_4ms, ..., ED_INTERRUPT_32ms.

   BestList - Pointer to a ULONG that recieves the list number of the
              list with least bandwidth in use.

Returned Value:

   The maximum bandwidth in use by any of the selected lists.

--*/
{
    ULONG LastList, Index;
    ULONG BestBandwidth, WorstBandwidth, Bandwidth;

    WorstBandwidth = 0;
    BestBandwidth = ~(ULONG) 0;

    for (LastList = List + List; List <= LastList; List++) {

        //
        // Sum bandwidth in use in this scheduling time
        //
        Bandwidth = 0;
        for (Index = List;
             Index != ED_EOF;
             Index = DeviceData->EDList[Index].Next) {
            Bandwidth += DeviceData->EDList[Index].Bandwidth;
        }

        //
        // Remember best and worst
        //
        if (Bandwidth < BestBandwidth) {
            BestBandwidth = Bandwidth;
            if (BestList != NULL) {
                *BestList = List;
            }
        }
        if (Bandwidth > WorstBandwidth) {
            WorstBandwidth = Bandwidth;
        }
    }

    LOGENTRY(G, 'ckBW', Bandwidth, 0, WorstBandwidth);

    return WorstBandwidth;
}


PHCD_ENDPOINT_DESCRIPTOR
InsertEDForEndpoint(
    IN PHCD_DEVICE_DATA DeviceData,
    IN PHCD_ENDPOINT Endpoint,
    IN UCHAR ListIndex,
    IN PHCD_TRANSFER_DESCRIPTOR *TailTd
    )
/*++

Routine Description:

   Insert an endpoint into the h/w schedule, optionally this will
   allocate an endpoint descriptor and/or a dummy transfer descriptor.

Arguments:

   Endpoint - pointer to the endpoint to be included in schedule
              if this parameter is NULL then we are inserting a dummy ED
              that has no associted endpoint.


--*/
{
    PHCD_ED_LIST list;
    PHCD_ENDPOINT_DESCRIPTOR tailED, ed;
    PHCD_TRANSFER_DESCRIPTOR td;
    KIRQL oldIrql;
    UCHAR endpointType;

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CALL_TRACE,
                      ("'InsertEDForEndpoint %x\n", Endpoint));

    list = &DeviceData->EDList[ListIndex];

    LOGENTRY(G, 'inED', Endpoint, ListIndex, list);

    if (Endpoint == NULL) {
        // this is a dummy ED
        td = NULL;
        ed = NULL;
    } else {
        // we have an endpoint

        td = Endpoint->HcdHeadP;
        ed = Endpoint->HcdED;
    }

    if (td == NULL) {
        //
        // no TD,
        // get a dummy TD and attach to the endpoint
        //
        if (td = OpenHCI_Alloc_HcdTD(DeviceData)) {

            td->UsbdRequest = TD_NOREQUEST_SIG;
            // if an endpoint is specified then we want this TD to be
            // the dummy TD that the haed & tail point to for a real
            // endpoint
            if (Endpoint != NULL) {
                 Endpoint->HcdHeadP = Endpoint->HcdTailP = td;
            }

            // return the tail td if asked
            if (TailTd) {
                *TailTd = td;
            }
        }
        LOGENTRY(G, 'dyTD', Endpoint, td, list);
    }


    if (ed == NULL) {
        //
        // Need an ED,
        // Get an ED, attach it to endpoint if we have one
        //
        ed = OpenHCI_Alloc_HcdED(DeviceData);

        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_CALL_TRACE,
                          ("'InsertEDForEndpoint ED = %x\n", ed));

        if (Endpoint && ed) {
            Endpoint->HcdED = ed;
        }

        LOGENTRY(G, 'dyED', Endpoint, ed, 0);
    }

    OHCI_ASSERT(td != 0);
    OHCI_ASSERT(ed != 0);

    if (ed == NULL || td == NULL) {
        // we are probably screwed
        OpenHCI_KdTrap(("'failed to alloc dummy TD/ED\n"));
        return NULL;
    }

    //
    // Initialize an endpoint descriptor for this endpoint
    //

    if (Endpoint != NULL) {
        //
        // This is for a real endpoint
        //
        ed->HcED.Control = Endpoint->Control;
        endpointType = Endpoint->Type;
    } else {
        //
        // no real endpoint exists, this is a dummy ED
        // used to work around a hardware bug, we set the skip
        // bit so the HC does not process it.
        //
        ed->HcED.Control = HcEDControl_SKIP;
        if (ListIndex == ED_BULK) {
            endpointType = USB_ENDPOINT_TYPE_BULK;
        } else if (ListIndex == ED_CONTROL) {
            endpointType = USB_ENDPOINT_TYPE_CONTROL;
        } else if (ListIndex == ED_ISOCHRONOUS) {
            endpointType = USB_ENDPOINT_TYPE_ISOCHRONOUS;
        } else {
            endpointType = USB_ENDPOINT_TYPE_INTERRUPT;
        }
    }

    ed->Endpoint = Endpoint;
    ed->ListIndex = ListIndex;
    ed->PauseFlag = HCD_ED_PAUSE_NOT_PAUSED;
    ed->HcED.TailP = ed->HcED.HeadP = td->PhysicalAddress;

    KeAcquireSpinLock(&DeviceData->EDListSpin, &oldIrql);

    //
    // Link endpoint descriptor into HCD tracking queue
    //

    if (endpointType != USB_ENDPOINT_TYPE_ISOCHRONOUS ||
        IsListEmpty(&list->Head)) {

        //
        // if it is not an iso ED or there are no EDs in the list
        // then link it to the head of the hw queue
        //

        InsertHeadList(&list->Head, &ed->Link);
        if (list->HcRegister) {
            // update the hardware register that points to the list head

            LOGENTRY(G, 'INH1', list, ed, list->PhysicalHead);
            // tail points to old head
            ed->HcED.NextED = READ_REGISTER_ULONG(list->PhysicalHead);
            // new head is this ed
            WRITE_REGISTER_ULONG(list->PhysicalHead, ed->PhysicalAddress);
        } else {
            LOGENTRY(G, 'INH2', list, ed, list->PhysicalHead);
            // tail points to old head
            ed->HcED.NextED = *list->PhysicalHead;
            // new head is this ed
            *list->PhysicalHead = ed->PhysicalAddress;
        }
    } else {
        //
        // Something already on the list,
        // Link ED into tail of ED list
        //


        tailED = CONTAINING_RECORD(list->Head.Blink,
                                   HCD_ENDPOINT_DESCRIPTOR,
                                   Link);

        LOGENTRY(G, 'INT1', list, ed, 0);
        InsertTailList(&list->Head, &ed->Link);
        ed->HcED.NextED = 0;
        tailED->HcED.NextED = ed->PhysicalAddress;
    }

    KeReleaseSpinLock(&DeviceData->EDListSpin, oldIrql);

    return (ed);
}


VOID
RemoveEDForEndpoint(
    IN PHCD_ENDPOINT Endpoint
    )
/*++

   Routine Description:
      Remove an endpoint from the hardware schedule.

   Arguments:
      Endpouint  - the endpoint assocaited with the ED to remove.


      An Endpoint pointing to the Endpoint Descriptor to be removed.
      if breakEDLink then the link between the Endpoint Descriptor and its
      corresponding endpoint is severed.

      If this link is severed then the Endpoint Descriptor will be returned
      to the descriptor free pool during the next interrupt.
--*/
{
    PHCD_DEVICE_DATA DeviceData;
    PHCD_ED_LIST list;
    PHCD_ENDPOINT_DESCRIPTOR previousED, ed = Endpoint->HcdED;
    ULONG listDisable;
    KIRQL oldIrql;
    UCHAR tmp;
    PHC_OPERATIONAL_REGISTER HC;

    ASSERT_ENDPOINT(Endpoint);
    DeviceData = Endpoint->DeviceData;
    list = &DeviceData->EDList[Endpoint->ListIndex];

    LOGENTRY(G, 'RMed', Endpoint, ed, list);

    // if we are in the active list we need to remove ourselves
    KeAcquireSpinLock(&DeviceData->HcDmaSpin, &oldIrql);
    if (Endpoint->EpFlags & EP_IN_ACTIVE_LIST) {
        RemoveEntryList(&Endpoint->EndpointListEntry);
        CLR_EPFLAG(Endpoint, EP_IN_ACTIVE_LIST);
    }
    KeReleaseSpinLock(&DeviceData->HcDmaSpin, oldIrql);

    /* Prevent the Host Controller from processing this ED */
    ed->HcED.sKip = TRUE;

    KeAcquireSpinLock(&DeviceData->EDListSpin, &oldIrql);

    {
        /* Unlink the ED from the physical ED list */
        LOGENTRY(G, 'ULed', Endpoint, ed, list);
        if (&list->Head == ed->Link.Blink) {
            if (list->HcRegister) {
                WRITE_REGISTER_ULONG(list->PhysicalHead, ed->HcED.NextED);
            } else {
                *list->PhysicalHead = ed->HcED.NextED;
            }
            previousED = NULL;
        } else {
            previousED =
                CONTAINING_RECORD(ed->Link.Blink,
                                  HCD_ENDPOINT_DESCRIPTOR,
                                  Link);
            previousED->HcED.NextED = ed->HcED.NextED;
        }

        /* Unlink the ED from HCD list */
        RemoveEntryList(&ed->Link);
        ed->ListIndex = ED_EOF;
    }
    KeReleaseSpinLock(&DeviceData->EDListSpin, oldIrql);

    /* Break the Endpoint / ED connection. This descriptor is now heading for
     * the slaughter. */
    Endpoint->HcdED = NULL;
    ed->Endpoint = NULL;


    OHCI_ASSERT(Endpoint->HcdHeadP == Endpoint->HcdTailP);
    OHCI_ASSERT((ed->HcED.HeadP & ~15) == ed->HcED.TailP);
    /* AKA there are no transfers on this queue. The HC will not touch any of
     * these TD's. We can free the 'sentinel' TD here, but we CANNOT actually
     * zero out the head and tail pointers, because the HC could still be
     * looking at this descriptor. Later, in the irq, when we take this
     * endpoint off the reclamation list, we much free the ED, and ignore the
     * non zero values of HeadP and TailP. */
    OpenHCI_Free_HcdTD(DeviceData, Endpoint->HcdHeadP);

    /*
     * The control and bulk lists are round robbin. Therefore we need to
     * disable these lists to insure that the 'current ED' pointer is not
     * pointing to that which we are removing.
     */
    switch (Endpoint->ListIndex) {
    case ED_CONTROL:
        listDisable = ~(ULONG) HcCtrl_ControlListEnable;
        break;
    case ED_BULK:
        listDisable = ~(ULONG) HcCtrl_BulkListEnable;
        break;
    default:
        list->Bandwidth -= Endpoint->Bandwidth;
        DeviceData->MaxBandwidthInUse
            = OpenHCI_CheckBandwidth(DeviceData,
                                     ED_INTERRUPT_32ms,
                                     &tmp);
        listDisable = 0;
    }

    HC = DeviceData->HC;
    WRITE_REGISTER_ULONG(&HC->HcInterruptStatus, HcInt_StartOfFrame);
    /* Clear the SOF interrupt pending status */

    {
        if (listDisable) {
            KeSynch_HcControl context;
            context.NewHcControl.ul = listDisable;
            context.DeviceData = DeviceData;
            KeSynchronizeExecution(DeviceData->InterruptObject,
                                   OpenHCI_HcControl_AND,
                                   &context);

            KeAcquireSpinLock(&DeviceData->ReclamationSpin, &oldIrql);
            InsertTailList(&DeviceData->StalledEDReclamation, &ed->Link);
        } else {
            KeAcquireSpinLock(&DeviceData->ReclamationSpin, &oldIrql);
            InsertTailList(&DeviceData->RunningEDReclamation, &ed->Link);
        }

        ed->ReclamationFrame = Get32BitFrameNumber(DeviceData) + 1;
        WRITE_REGISTER_ULONG(&HC->HcInterruptEnable, HcInt_StartOfFrame);
    }
    KeReleaseSpinLock(&DeviceData->ReclamationSpin, oldIrql);

    // free our descriptors and endpoint
    OpenHCI_UnReserveDescriptors(DeviceData, Endpoint->DescriptorsReserved);

    // now free the endpoint

    Endpoint->Sig = 0;
    ExFreePool(Endpoint);
}


NTSTATUS
OpenHCI_OpenEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHCD_DEVICE_DATA DeviceData,
    IN OUT PHCD_URB urb
    )
/*++

Routine Description:

   Create a OpenHCI endpoint, this function is called from
   OpenHCI_URB_Dispatch to create a new endpoint structure.

   There are three things that can cause this routine to fail:
   1) ExAllocatePool may fail to allocate an HCD_ENDPOINT,
   2) OpenHCI_ReserveDescriptors may not be able to find enough
      descriptors, and
   3) OpenHCI_ReserveBandwidth may not be able to find bandwidth
      in the schedule.

   This routine is simplified because USBD serializes OpenEndpoint
   and CloseEndpoint URBs

Arguments:

   DeviceObject - pointer to a device object

   Irp - pointer to an I/O Request Packet

Return Value:

   NT Status code


--*/
{
    PHCD_ENDPOINT endpoint;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor;
    UCHAR WhichList;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG tdsNeeded;

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_END_TRACE, ("'enter OpenEndpoint\n"));

#if DBG
    /*
     * We are assuming that the caller of _OpenEndpoint and _Close endpoint
     * make only serial calls.  For this reason we will protect ourselves. If
     * this is violated we return STATUS_DEVICE_BUSY.
     */

    if (0 < InterlockedIncrement(&DeviceData->OpenCloseSync)) {
        OpenHCI_KdTrap(("'ohciurb.c: _OpenEndpoint: Non serial call! %d",
            DeviceData->OpenCloseSync));
        TEST_TRAP();
        return STATUS_DEVICE_BUSY;
    }
#endif // DBG

    //
    // make sure the length of the urb is what we expect
    //

    if (urb->HcdUrbOpenEndpoint.Length !=
            sizeof(struct _URB_HCD_OPEN_ENDPOINT)) {
        urb->UrbHeader.Status = USBD_STATUS_INVALID_PARAMETER;
        return STATUS_INVALID_PARAMETER;
    }

    urb->UrbHeader.Status = USBD_STATUS_SUCCESS;

    //
    // information about the endpoint comes from the USB endpoint
    // descriptor passed in the URB.
    //

    endpointDescriptor = urb->HcdUrbOpenEndpoint.EndpointDescriptor;
    urb->HcdUrbOpenEndpoint.HcdEndpoint = NULL;

    // How does one transmit to an endpoint that does not have
    // a positive max packet size?
    // A: this is an error

    if (endpointDescriptor->wMaxPacketSize == 0) {
        endpoint =
            ZERO_LOAD_ENDPOINT(DeviceData);

        urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
        ntStatus = STATUS_SUCCESS;
        goto OpenHCI_OpenEndpoint_Done;
    }

    //
    // Allocate resources for the endpoint, this includes an endpoint
    // handle that will be passed to us in subsequent transfer requests
    //

    endpoint = (PHCD_ENDPOINT)
        ExAllocatePoolWithTag(NonPagedPool,
                              sizeof(HCD_ENDPOINT),
                              OpenHCI_TAG);

    if (endpoint == NULL) {
        urb->UrbHeader.Status = USBD_STATUS_NO_MEMORY;
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto OpenHCI_OpenEndpoint_Done;
    }
    //
    // Start initializing the endpoint structure
    //
    InitializeListHead(&endpoint->RequestQueue);
    endpoint->Sig = SIG_EP;
    endpoint->EpFlags = 0;
    endpoint->LowSpeed = FALSE;
    endpoint->Isochronous = FALSE;
    endpoint->Rate = endpointDescriptor->bInterval;

    // Initial conditon:
    //     No active transfers
    //     Max of two active transfers
    //
    endpoint->EndpointStatus = 0;
    endpoint->MaxRequest     = 2;

    endpoint->AbortIrp = NULL;

    endpoint->Type =
        endpointDescriptor->bmAttributes & USB_ENDPOINT_TYPE_MASK;

    if (DeviceData->HcFlags & HC_FLAG_SLOW_BULK_ENABLE &&
        endpoint->Type == USB_ENDPOINT_TYPE_BULK) {
        endpoint->MaxRequest = 1; // limit to only one transfer
        SET_EPFLAG(endpoint, EP_ONE_TD);
    }

    endpoint->ListIndex = ED_EOF;   // not on a list yet
    endpoint->Bandwidth = 0;    // assume bulk or control
    endpoint->DeviceData = DeviceData;
    endpoint->Control = 0;
    endpoint->HcdED = NULL;
    endpoint->HcdHeadP = endpoint->HcdTailP = NULL;
    endpoint->DescriptorsReserved = 0;
    endpoint->TrueTail = NULL;
    KeInitializeSpinLock(&endpoint->QueueLock);

    SET_EPFLAG(endpoint, EP_VIRGIN);
    endpoint->FunctionAddress = urb->HcdUrbOpenEndpoint.DeviceAddress;
    endpoint->EndpointNumber = endpointDescriptor->bEndpointAddress;

    if (endpoint->Type == USB_ENDPOINT_TYPE_CONTROL) {
        endpoint->Direction = HcEDDirection_Defer;
    } else if (endpointDescriptor->bEndpointAddress & 0x80) {
        endpoint->Direction = HcEDDirection_In;
    } else {
        endpoint->Direction = HcEDDirection_Out;
    }

    if (urb->HcdUrbOpenEndpoint.HcdEndpointFlags & USBD_EP_FLAG_LOWSPEED) {
        endpoint->LowSpeed = TRUE;
    }        
    
    if (endpoint->Type == USB_ENDPOINT_TYPE_ISOCHRONOUS) {
        endpoint->Isochronous = TRUE;
    }
    endpoint->MaxPacket = endpointDescriptor->wMaxPacketSize;
    //
    // Figure out how many descriptors we need to reserve
    //
    endpoint->MaxTransfer = urb->HcdUrbOpenEndpoint.MaxTransferSize;
    if (endpoint->FunctionAddress != DeviceData->RootHubAddress) {
        //
        // This is an ordinary device endpoint...
        //

        // the goal here is to reserve enough TDs so that we can
        // program the largest transfer to the hardware
        //
        if (endpoint->Type == USB_ENDPOINT_TYPE_ISOCHRONOUS)
        {
            ULONG   packetSize;
            ULONG   maxTransfer;
            ULONG   msPerTransfer;
            ULONG   packetsPerTD;

            maxTransfer     = endpoint->MaxTransfer;
            packetSize      = endpoint->MaxPacket;

            // Assume that the client driver sized the MaxTransferSize by
            // multiplying the MaxPacketSize by the maximum number of frames
            // the client driver would submit in a single request, so compute
            // the maximun number of frames per request by dividing the
            // MaxTransferSize by the MaxPacketSize.
            //
            msPerTransfer   = maxTransfer / packetSize;

            // Isoch transfers are limited to 255 packets per transfer.
            //
            if (msPerTransfer > 255)
            {
                msPerTransfer = 255;
            }

            // A TD can only span one page crossing.  In the worst cast we
            // can only fit a page worth of packets into a single TD to
            // guarantee that there is only one page crossing.
            //
            //  packetSize   packetsPerTD (worst case)
            //    1 -  512       8
            //  513 -  585       7
            //  586 -  682       6
            //  683 -  819       5
            //  820 - 1023       4
            //
            packetsPerTD = OHCI_PAGE_SIZE / packetSize;

            // Regardless of the MaxPacketSize, a single TD is limited to
            // eight packets.
            //
            if (packetsPerTD > 8)
            {
                packetsPerTD = 8;
            }
           
            // Calculate the number of TDs needed by dividing the maximum
            // number of frames per transfer (rounded up) by the worst case
            // miminum number of frames that will fit in a TD
            //
            tdsNeeded = (msPerTransfer + packetsPerTD - 1) / packetsPerTD;

            LOGENTRY(G, 'rISO', tdsNeeded, packetSize, maxTransfer);

            OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_END_TRACE,
                ("'reserve desc for iso ep (%d) pct siz = %d, max xfer = %d\n",
                 tdsNeeded, packetSize, maxTransfer));

            // If the magic endpoint flag is set bump the MaxRequests
            // all the way up to 32.
            //
            if (urb->HcdUrbOpenEndpoint.HcdEndpointFlags &
                USBD_EP_FLAG_MAP_ADD_IO)
            {
                endpoint->MaxRequest = 32;
            }

        } else {
            // we will need a TD for each page of data to transfer,
            // worst case
            tdsNeeded = (endpoint->MaxTransfer / (OHCI_PAGE_SIZE+1)) + 1;

            // we need an xtra TD for the setup/status packet
            if (endpoint->Type == USB_ENDPOINT_TYPE_CONTROL) {
                tdsNeeded+=2;
            }
        }

        // We need enough TDs to queue MaxRequest transfers plus:
        // two EDs (why two EDs instead of one?), a dummy TD for the
        // tail TD, and a spare (why?)
        //
        tdsNeeded = (tdsNeeded * endpoint->MaxRequest) + 4;

        //
        // pre-allocate the number of descriptors we will need
        // for this endpoint
        //
        ntStatus = OpenHCI_ReserveDescriptors(DeviceData, tdsNeeded);
        LOGENTRY(G, 'rTDS', endpoint, tdsNeeded, 0);

        if (!NT_SUCCESS(ntStatus)) {
            TEST_TRAP();
            urb->UrbHeader.Status = USBD_STATUS_NO_MEMORY;
            goto OpenHCI_OpenEndpoint_Done;
        }
        endpoint->DescriptorsReserved = tdsNeeded;

        endpoint->Bandwidth =
            (USHORT) USBD_CalculateUsbBandwidth(endpoint->MaxPacket,
                                                endpoint->Type,
                                                (BOOLEAN)endpoint->LowSpeed);

        LOGENTRY(G, 'ndBW', endpoint, endpoint->Bandwidth, 0);

        switch(endpoint->Type) {
        case USB_ENDPOINT_TYPE_ISOCHRONOUS:
            WhichList = ED_ISOCHRONOUS;

            DeviceData->EDList[ED_ISOCHRONOUS].Bandwidth +=
                endpoint->Bandwidth;
            DeviceData->MaxBandwidthInUse += endpoint->Bandwidth;
            break;
        case USB_ENDPOINT_TYPE_INTERRUPT:
             //
            // Determine the scheduling period.
            //
            WhichList = ED_INTERRUPT_32ms;
            while (WhichList >= endpoint->Rate && (WhichList >>= 1)) {
                //
                // Keep decrementing the schedule list until, the list
                // chosen
                // meets or exceeds the rate required by the endpoint.
                //
                continue;
            }

            //
            // Determine which scheduling list has the least bandwidth
            //
            OpenHCI_CheckBandwidth(DeviceData, WhichList, &WhichList);
            DeviceData->EDList[WhichList].Bandwidth += endpoint->Bandwidth;

            //
            // Recalculate the max bandwidth  which is in use. This
            // allows 1ms (isoc) pipe opens to occur with few calculation
            //
            DeviceData->MaxBandwidthInUse =
                OpenHCI_CheckBandwidth(DeviceData,
                                       ED_INTERRUPT_32ms,
                                       NULL);
            break;
        case USB_ENDPOINT_TYPE_BULK:
            WhichList = ED_BULK;
            break;
        case USB_ENDPOINT_TYPE_CONTROL:
            WhichList = ED_CONTROL;
            break;
        }

        endpoint->ListIndex = WhichList;
        urb->HcdUrbOpenEndpoint.ScheduleOffset = WhichList;

        //
        // Verify the new max has not overcomitted the USB
        //
        LOGENTRY(G, 'vrBW', endpoint, DeviceData->MaxBandwidthInUse,
            DeviceData->AvailableBandwidth);

        if (DeviceData->MaxBandwidthInUse > DeviceData->AvailableBandwidth) {
            //
            // Too much, back this bandwidth out and fail the request
            //
            DeviceData->EDList[WhichList].Bandwidth -= endpoint->Bandwidth;
            DeviceData->MaxBandwidthInUse =
                OpenHCI_CheckBandwidth(DeviceData,
                                       ED_INTERRUPT_32ms,
                                       NULL);

            //
            // return a CAN_NOT_COMMIT_BANDWIDTH error.
            urb->UrbHeader.Status = USBD_STATUS_NO_BANDWIDTH;
            ntStatus = STATUS_UNSUCCESSFUL;

            goto OpenHCI_OpenEndpoint_Done;
        }

        //
        // Add to Host Controller schedule processing
        //

        // if lowspeed control and Hs/ls hack enabled
        // put control transfers on the periodic list

        if (endpoint->LowSpeed &&
            DeviceData->HcFlags & HC_FLAG_USE_HYDRA_HACK &&
            endpoint->ListIndex == ED_CONTROL) {

            OpenHCI_KdPrint((1, "'*** do hs/ls fix for control ep\n"));
            // put control on the interrupt list
            endpoint->ListIndex = ED_INTERRUPT_1ms;

        }

        InsertEDForEndpoint(endpoint->DeviceData,
                            endpoint,
                            endpoint->ListIndex,
                            NULL);

        OpenHCI_KdPrintDD(DeviceData,
            OHCI_DBG_END_TRACE, ("'Open Endpoint:\n"));

    } else {
        //
        // note that if the controller has lost power
        // before the RH is started we need to restore the HC state
        // before initializing the root hub.
        //

        if (DeviceData->HcFlags & HC_FLAG_LOST_POWER) {
            BOOLEAN lostPower;
            PHC_OPERATIONAL_REGISTER HC;

            HC = DeviceData->HC;

            // should only get here in the case where the
            // HC looses power
            //
            OpenHCI_RestoreHCstate(DeviceData, &lostPower);

            OHCI_ASSERT(lostPower == TRUE);

            OpenHCI_Resume(DeviceObject, lostPower);

            KeSetTimerEx(&DeviceData->DeadmanTimer,
                         RtlConvertLongToLargeInteger(-10000),
                         10,
                         &DeviceData->DeadmanTimerDPC);
        }

        //
        // This is an emulated Root Hub endpoint
        //
        SET_EPFLAG(endpoint, EP_ROOT_HUB);

        if (endpoint->EndpointNumber == 1 &&
            endpoint->Type == USB_ENDPOINT_TYPE_INTERRUPT) {
            DeviceData->RootHubInterrupt = endpoint;
            /*
             * Note: if you open up two endpoints to the Interrupt endpoint
             * of the root hub then the first one stops responding.  But this
             * is only fare as you should not open up two pipes to the same
             * device and endpoint number.
             */
        } else {
             DeviceData->RootHubControl = endpoint;
        }
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_END_INFO,
                          ("'Open Endp (Root Hub Emulation)\n"));
    }

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_END_INFO,
          ("'ED: Type %d, Dir %d Addr %d FUNC Address %d LowSpeed %d\n",
          endpoint->Type,
          endpoint->Direction,
          endpoint->EndpointNumber,
          endpoint->FunctionAddress,
          endpoint->LowSpeed));

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_END_INFO,
          ("' MaxPacket %x Interval Requested %d List Selected %d\n",
          endpoint->MaxPacket,
          endpointDescriptor->bInterval,
          endpoint->ListIndex));
    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_END_INFO,
          ("'*****HCD_ENDPOINT addr: 0x%08x HcdED: 0x%08x\n\n\n",
          endpoint, endpoint->HcdED));

OpenHCI_OpenEndpoint_Done:

    //
    // Complete the IRP, status is in the status field of the URB
    //

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_END_TRACE,
                      ("'exit OpenHCI_OpenEndpoint (URB STATUS = %x)\n",
                      urb->UrbHeader.Status));

    if (NT_SUCCESS(ntStatus)) {
        urb->HcdUrbOpenEndpoint.HcdEndpoint = endpoint;
    } else {
        ASSERT(endpoint != ZERO_LOAD_ENDPOINT(DeviceData));
        if (endpoint) {
            OpenHCI_UnReserveDescriptors(DeviceData,
                                         endpoint->DescriptorsReserved);
            OHCI_ASSERT(!(endpoint->EpFlags & EP_IN_ACTIVE_LIST));
            ExFreePool(endpoint);
        }
    }

#if DBG
    InterlockedDecrement(&DeviceData->OpenCloseSync);
#endif //DBG
    LOGENTRY(G, 'opEP', endpoint, urb, ntStatus);

    return ntStatus;
}



NTSTATUS
OpenHCI_CloseEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHCD_DEVICE_DATA DeviceData,
    IN OUT PHCD_URB urb
    )
/*++
  Routine Description:
     Free a OpenHCI endpoint, if there are any pending transfers for this
     endpoint this routine should fail.

  Arguments:
     DeviceObject - pointer to a device object
     Irp - pointer to an I/O Request Packet

  Return Value:
     If out of synchronous call with close and open
     then return STATUS_DEVICE_BUSY otherwise
     return STATUS_SUCCESS

--*/
{
    PHCD_ENDPOINT endpoint = urb->HcdUrbCloseEndpoint.HcdEndpoint;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    BOOLEAN outstandingTransfers, activeTransfers;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN freeEP = TRUE;
  //  LARGE_INTEGER time;

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_END_TRACE, ("'enter CloseEndpoint\n"));

    LOGENTRY(G, 'rcEP', endpoint, urb, 0);

#if DBG

    /* We are assuming that the caller of _OpenEndpoint and _Close endpoint
     * make only serial calls.  For this reason we will protect ourselves. If
     * this is violated we return STATUS_DEVICE_BUSY. */

    if (0 < InterlockedIncrement(&DeviceData->OpenCloseSync)) {
        OpenHCI_KdTrap(("'ohciurb.c: _OpenEndpoint: Non serial call! %d",
                        DeviceData->OpenCloseSync));
        urb->UrbHeader.Status = USBD_STATUS_INTERNAL_HC_ERROR;
        ntStatus = STATUS_UNSUCCESSFUL;
        goto CloseEndpoint_Done;
    }
#endif  // DBG

    if (endpoint == ZERO_LOAD_ENDPOINT(DeviceData)) {
        urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
        ntStatus = STATUS_SUCCESS;
        goto CloseEndpoint_Done;
    }

    ASSERT_ENDPOINT(endpoint);

    // mark the endpoint as closed -- this prevents any more transers from
    // being queued, if we fail the close we can clear the close flag.
    // NOTE: if someone is sending transfers while we are closing they have a
    // problem anyway this will just let us finish the close.

    SET_EPFLAG(endpoint, EP_CLOSED);

    OpenHCI_LockAndCheckEndpoint(endpoint,
                                 &outstandingTransfers,
                                 &activeTransfers,
                                 &irql);

    OpenHCI_UnlockEndpoint(endpoint, irql);

    if (outstandingTransfers ||
        activeTransfers) {

        //
        // fail if we have pending transfers,
        // note: USBD should prevent this
        //

        // if we get here we probably have a problem somewhere
        TRAP();

        urb->UrbHeader.Status = USBD_STATUS_INTERNAL_HC_ERROR;
        OpenHCI_KdPrintDD(DeviceData,
                          OHCI_DBG_END_ERROR,
                          ("'exit OutstandingTRANS OpenHCI_CloseEndpoint\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
        goto CloseEndpoint_Done;
    }

    ed = endpoint->HcdED;

    OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_END_INFO,
                      ("'Closing Endpoint: %x\n", endpoint));

    if (ed) {
        KeAcquireSpinLock(&DeviceData->PausedSpin, &irql);

        if (ed->PauseFlag != HCD_ED_PAUSE_NOT_PAUSED)
        {
            // This endpoint is paused.
            //
            // we are waiting for the CancelTDsForED to complete, we set a
            // flag here that tells CancelTDsForED to call the remove ED
            // function.
            //
            LOGENTRY(G, 'cle1', endpoint, ed, 0);
            SET_EPFLAG(endpoint, EP_FREE);

            KeReleaseSpinLock(&DeviceData->PausedSpin, irql);

            OpenHCI_KdPrintDD(DeviceData,
                OHCI_DBG_END_ERROR, ("'closing paused \n"));

            freeEP = FALSE;

        } else {

            LOGENTRY(G, 'cle2', endpoint, ed, 0);
            KeReleaseSpinLock(&DeviceData->PausedSpin, irql);
            if (ED_EOF != endpoint->ListIndex) {
                RemoveEDForEndpoint(endpoint);
                freeEP = FALSE;
            }
        }
    }

    //
    // we return our BW in RemoveEDForEndpoint
    //

    if (freeEP) {
        ASSERT_ENDPOINT(endpoint);
        // free our descriptors and endpoint
        OpenHCI_UnReserveDescriptors(DeviceData, endpoint->DescriptorsReserved);

        if (DeviceData->RootHubInterrupt == endpoint) {
            DeviceData->RootHubInterrupt = NULL;
            OpenHCI_KdPrintDD(DeviceData,
                OHCI_DBG_END_TRACE, ("'closed RH interrupt\n"));
        }

        if (DeviceData->RootHubControl == endpoint) {
            DeviceData->RootHubControl = NULL;
            // root hub is no longer configured
            DeviceData->RootHubConfig = 0;
            OpenHCI_KdPrintDD(DeviceData,
                OHCI_DBG_END_TRACE, ("'closed RH control\n"));

            if (endpoint->FunctionAddress != 0) {
                DeviceData->RootHubAddress = 0;
            }
        }

        endpoint->Sig = 0;
        OHCI_ASSERT(!(endpoint->EpFlags & EP_IN_ACTIVE_LIST));
        ExFreePool(endpoint);
    }

    urb->UrbHeader.Status = USBD_STATUS_SUCCESS;

CloseEndpoint_Done:

#if DBG
    InterlockedDecrement(&DeviceData->OpenCloseSync);

    if (!NT_SUCCESS(ntStatus)) {
        // check why we are failing the close
        TEST_TRAP();
    }
#endif

    LOGENTRY(G, 'clEP', 0, urb, ntStatus);
    return ntStatus;
}


ULONG
Get32BitFrameNumber(
    PHCD_DEVICE_DATA DeviceData
    )
{
    ULONG hp, fn, n;
    /* This code accounts for the fact that HccaFrameNumber is updated by the
     * HC before the HCD gets an interrupt that will adjust FrameHighPart. No
     * synchronization is nescisary due to great cleaverness. */
    hp = DeviceData->FrameHighPart;
    fn = DeviceData->HCCA->HccaFrameNumber;
    n = ((fn & 0x7FFF) | hp) + ((fn ^ hp) & 0x8000);

    // Note: we can't log here because this function is called from the ISR

    return n;
}


VOID
OpenHCI_PauseED(
    IN PHCD_ENDPOINT Endpoint
    )
/*++
Routine Description:
   Processing of an endpoint by the HC must be paused before any
   maintenance is performend on the TD list.  This function first
   sets the skip bit and then places the ED on a separate paused
   list.  At the next Start of Frame this ED can then be worked on.
   Presumably the irq function will call CancelTDsForED on this
   endpoint at that time.

Arguments:
   Endpoint - then endpoint that need pausing.

--*/
{
    PHCD_DEVICE_DATA DeviceData;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    KIRQL oldirq;
    PHC_OPERATIONAL_REGISTER HC;

    ASSERT_ENDPOINT(Endpoint);
    DeviceData = Endpoint->DeviceData;
    HC = DeviceData->HC;
    ed = Endpoint->HcdED;

    OpenHCI_KdPrintDD(DeviceData,
        OHCI_DBG_TD_NOISE, ("'Pausing Endpoint\n"));
    LOGENTRY(G, 'Rpau', DeviceData, Endpoint, ed);

    KeAcquireSpinLock(&DeviceData->PausedSpin, &oldirq);

    // Are we already pasued?
    //
    if (ed->PauseFlag == HCD_ED_PAUSE_NOT_PAUSED)
    {
        // No, pause this endpoint

        ed->HcED.sKip = TRUE;

        // Clear any currently pending SOF interrupt
        //
        WRITE_REGISTER_ULONG(&HC->HcInterruptStatus, HcInt_StartOfFrame);

        // It will be safe to operate on the endpoint in the next frame
        //
        ed->ReclamationFrame = Get32BitFrameNumber(DeviceData) + 1;

        // Put this endpoint on the list of endpoints that OpenHCI_IsrDPC()
        // should pass to OpenHCI_CancelTDsForED()
        //
        InsertTailList(&DeviceData->PausedEDRestart, &ed->PausedLink);

        // Make sure SOF interrupts are enabled
        //
        WRITE_REGISTER_ULONG(&HC->HcInterruptEnable, HcInt_StartOfFrame);

        LOGENTRY(G, 'paus', DeviceData, Endpoint, ed);
    }
#if DBG
      else {
        OpenHCI_KdPrintDD(DeviceData, OHCI_DBG_TD_ERROR,
                          ("'Warning Endpoint already paused!\n"));
    }
#endif

    // Indicate that OpenHCI_CancelTDsForED() needs to make a pass through
    // the requests queued on this endpoint.
    //
    ed->PauseFlag = HCD_ED_PAUSE_NEEDED;

    KeReleaseSpinLock(&DeviceData->PausedSpin, oldirq);

    return;
}


BOOLEAN
OpenHCI_HcControl_OR(
    IN OUT PVOID Context
    )
/*++
Routine Description:
   This function is used in connection with KeSynchronizeExecution
   to set the bits of the HcControl register which is accessed by
   all function including the interrupt routine (not just the IsrDPC).
   This function reads the CurrentHcControl field of the device
   extension and ORs in the bits given by NewHcControl.  It then
   writes the results to the register.
   Reads of the register take a long time so the value is cached.

Results:
   This function modifies the input pointer to HC_CONTROL field
   (PNewHcControl) to the result of the OR operation.

--*/
{
    PHC_CONTROL newControl = &((PKeSynch_HcControl) Context)->NewHcControl;
    PHCD_DEVICE_DATA DeviceData = ((PKeSynch_HcControl) Context)->DeviceData;

    DeviceData->CurrentHcControl.ul
        = READ_REGISTER_ULONG(&DeviceData->HC->HcControl.ul);
    newControl->ul = (DeviceData->CurrentHcControl.ul |= newControl->ul);
    WRITE_REGISTER_ULONG(&DeviceData->HC->HcControl.ul, newControl->ul);
    return TRUE;
}

BOOLEAN
OpenHCI_HcControl_AND(
    PVOID Context
)
/**
Routine Description:
   OpenHCI_HcControl_OR with a twist.
--*/
{
    PHC_CONTROL newControl = &((PKeSynch_HcControl) Context)->NewHcControl;
    PHCD_DEVICE_DATA DeviceData = ((PKeSynch_HcControl) Context)->DeviceData;

    DeviceData->CurrentHcControl.ul
        = READ_REGISTER_ULONG(&DeviceData->HC->HcControl.ul);
    newControl->ul = (DeviceData->CurrentHcControl.ul &= newControl->ul);
    WRITE_REGISTER_ULONG(&DeviceData->HC->HcControl.ul, newControl->ul);
    return TRUE;
}

BOOLEAN
OpenHCI_HcControl_SetHCFS(
                          PVOID Context
)
/**
Routine Description:
   Mask out the Functional State in the HcControl register
   and in its place put the ulong.
--*/
{
    PHC_CONTROL newControl = &((PKeSynch_HcControl) Context)->NewHcControl;
    PHCD_DEVICE_DATA DeviceData = ((PKeSynch_HcControl) Context)->DeviceData;

    DeviceData->CurrentHcControl.ul
        = READ_REGISTER_ULONG(&DeviceData->HC->HcControl.ul);

    newControl->ul &= HcCtrl_HCFS_MASK;
    DeviceData->CurrentHcControl.ul &= ~HcCtrl_HCFS_MASK;
    newControl->ul = (DeviceData->CurrentHcControl.ul |= newControl->ul);

    WRITE_REGISTER_ULONG(&DeviceData->HC->HcControl.ul, newControl->ul);
    return TRUE;
}


BOOLEAN
OpenHCI_ListEnablesAtNextSOF(
    PVOID Context
)
/**
Routine Description:
   Set the ListEnablesAtNextSOF value in DeviceData so that when the
   interrupt comes those lists will be enabled.
--*/
{
    ((PKeSynch_HcControl) Context)->DeviceData->ListEnablesAtNextSOF.ul
        = HcCtrl_ListEnableMask & ((PKeSynch_HcControl) Context)->
            NewHcControl.ul;

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\async.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    async.c

Abstract:

    This module manages bulk, interrupt & control type 
    transactions on the USB.

Environment:

    kernel mode only

Notes:

Revision History:

    11-01-95 : created

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"

// handle control transfers with this code
#define CONTROL     1

#define CONTROL_TRANSFER(ep)  ((ep)->Type == USB_ENDPOINT_TYPE_CONTROL)

// true if we'll need more TDs than are available to setup this 
// request
#define ASYNC_TRANSFER_OVERFLOW(needed, ep, xtra)     (BOOLEAN)(needed > ep->TDCount - xtra)

#define UHCD_RESET_TD_LIST(ep) \
      { \
           HW_DESCRIPTOR_PHYSICAL_ADDRESS td;  \
           td = (ep)->TDList->TDs[0].PhysicalAddress; \
           SET_T_BIT(td); \
           (ep)->QueueHead->HW_VLink = td; \
      }                    

USBD_STATUS
UHCD_MapTDError(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG Td_Status,
    ULONG ActualLength
    )
/*++

Routine Description:

   Maps Error from TD.

    1. STALL+BABBLE indicates that the td buffer was too small to 
        hold all the data ie buffer overrun.
    2. STALL if onlt stall bit is set then we recieved a stall PID
    3. CRC_TIMEOUT+STALL indicates the device is not responding
    4. CRC_TIMEOUT with no data indicates no response
    5. CRC_TIMEOUT with data indicates CRC error

Arguments:

Return Value:

    usb status will be returned if transfer is complete.

--*/
{
    USBD_STATUS status;
    // Translate the TD status field to a USBD error code

    if (Td_Status == 0x3f) {
        // all bits on means software error
        status = USBD_STATUS_NO_MEMORY;   
        UHCD_KdBreak((2, "'no mem\n"));    
        DeviceExtension->Stats.SWErrorCount++;                
        goto UHCD_MapTDError_Done;
    }

    if (Td_Status & TD_STATUS_BABBLE) {
        UHCD_KdBreak((2, "'babble\n"));        
        DeviceExtension->FrameBabbleRecoverTD->Active = 1;
    }        

    if (Td_Status == (TD_STATUS_STALL | TD_STATUS_BABBLE)) {
        status = USBD_STATUS_BUFFER_OVERRUN;
        DeviceExtension->Stats.BufferOverrunErrorCount++;                
    } else if (Td_Status == TD_STATUS_STALL) {
        // if only the the stall bit is set in the TD then            
        // we have a stall pid
        UHCD_KdBreak((2, "'stall 1\n"));         
        DeviceExtension->Stats.StallPidCount++;                
        status = USBD_STATUS_STALL_PID;
    } else if (Td_Status == (TD_STATUS_CRC_TIMEOUT | TD_STATUS_STALL)) {
        // stall and timeout bit indicates device not responding
        UHCD_KdBreak((2, "'stall 2\n"));          
        DeviceExtension->Stats.TimeoutErrorCount++;                
        status = USBD_STATUS_DEV_NOT_RESPONDING;
    } else if (Td_Status == TD_STATUS_CRC_TIMEOUT &&
        ActualLength != 0) {        
        status = USBD_STATUS_CRC;
        DeviceExtension->Stats.CrcErrorCount++;                
    } else if (Td_Status == TD_STATUS_CRC_TIMEOUT &&
        ActualLength == 0) {
        status = USBD_STATUS_DEV_NOT_RESPONDING;
        DeviceExtension->Stats.TimeoutErrorCount++;                
    } else if (Td_Status == TD_STATUS_FIFO) {
        status = USBD_STATUS_DATA_OVERRUN;     
        DeviceExtension->Stats.DataOverrunErrorCount++;                
    } else {        
        status = USBD_STATUS_INTERNAL_HC_ERROR;
        DeviceExtension->Stats.InternalHcErrorCount++;                
    }

UHCD_MapTDError_Done:

    LOGENTRY(LOG_MISC, 'MAPe', Td_Status, status, 0);
    
    return status;        
}

//
// queue is busy if the T bit is not set in the HW link pointed to by the queue head
//

__inline VOID
UHCD_InitializeAsyncTD(
    IN PUHCD_ENDPOINT Endpoint,
    IN PHW_TRANSFER_DESCRIPTOR TransferDescriptor
    )
/*++

Routine Description:

    Initialize a TD for transfer use, initializes all
    fields possibly changed by execution of the TD.

Arguments:

    TransferDescriptor  - TD to recycle

Return Value:

    None.

--*/
{
        TransferDescriptor->PID = 0;
        TransferDescriptor->Isochronous = 0;
        TransferDescriptor->InterruptOnComplete = 0;
        TransferDescriptor->Active = 1;
        TransferDescriptor->ActualLength = 0;
        TransferDescriptor->StatusField = 0; 
        // set based on field in endpoint
        TransferDescriptor->LowSpeedControl = 
            (Endpoint->EndpointFlags & EPFLAG_LOWSPEED) ? 1 : 0; 
        TransferDescriptor->ReservedMBZ = 0;
        // All bits on
        TransferDescriptor->ErrorCounter = 3;
        CLEAR_T_BIT(TransferDescriptor->HW_Link);
}   


__inline
BOOLEAN 
UHCD_QueueBusy(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    OUT PULONG QueueTD
    )
/*++

Routine Description:

    Determine if a particular queue head is 'busy' ie 
    still processing TDs

Arguments:

Return Value:

    TRUE if busy, FALSE otherwise.

--*/
{
    BOOLEAN busy = FALSE;
    ULONG i, active;
    HW_DESCRIPTOR_PHYSICAL_ADDRESS currentLink, vLink;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;

//    slot = urbWork->Slot;
//    UHCD_ASSERT(Endpoint->TDList == Endpoint->SlotTDList[slot]);

    vLink = Endpoint->QueueHead->HW_VLink;
    
    LOGENTRY(LOG_MISC, 'QBSY', vLink, 0, 0);
    
    if (!(vLink & UHCD_CF_TERMINATE)) {
        // T-bit not set see if the current TD has errored out

        //
        // locate the TD that the queue head is currently 
        // pointing to.
        //
        currentLink = 
            vLink & UHCD_DESCRIPTOR_PTR_MASK;
        
        for (i=0; i<Endpoint->TDCount; i++) {
            active = Endpoint->TDList->TDs[i].Active;
            if (currentLink ==
                (Endpoint->TDList->TDs[i].PhysicalAddress & 
                 UHCD_DESCRIPTOR_PTR_MASK)) {  
                break;
            }
        }
                
        LOGENTRY(LOG_MISC, 'Qlnk', Endpoint, currentLink, i);
        LOGENTRY(LOG_MISC, 'Qlk2', Endpoint->QueueHead->HW_VLink, 0, 0);
        UHCD_ASSERT(currentLink == (Endpoint->TDList->TDs[i].PhysicalAddress & 
                         UHCD_DESCRIPTOR_PTR_MASK));
        
        //
        // Check the queue head, if it is busy then no processing
        // will be performed at this time.
        //

        busy = TRUE;

        if (!active) { 

            //
            // Queue head points to an inactive TD we need to check 
            // for one of the follwing cases
            //
            // 1. Short packet detected on an IN with a B0 stepping
            //    version of the host controller.
            //
            // 2. The TD completed with an error.
            //
            // 3. Queue header update problem.
            //

            LOGENTRY(LOG_MISC, 'Qsts', deviceExtension->SteppingVersion, 
                             UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(Endpoint->TDList->TDs[i].ActualLength), 
                             &Endpoint->TDList->TDs[i]);        

                // check error
            if ((Endpoint->TDList->TDs[i].StatusField != 0) ||
                // check short packet
                  (UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(Endpoint->TDList->TDs[i].ActualLength) < 
                   UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(Endpoint->TDList->TDs[i].MaxLength) 
                   && Endpoint->TDList->TDs[i].PID == USB_IN_PID &&
                  deviceExtension->SteppingVersion >= UHCD_B0_STEP)) {            

//                (UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(Endpoint->TDList->TDs[i].ActualLength) < 
//                 Endpoint->MaxPacketSize && Endpoint->TDList->TDs[i].PID == USB_IN_PID &&
//                 deviceExtension->SteppingVersion >= UHCD_B0_STEP)) {            

                UHCD_ASSERT((Endpoint->QueueHead->HW_VLink &
                    UHCD_DESCRIPTOR_PTR_MASK) == 
                    (Endpoint->TDList->TDs[i].PhysicalAddress & 
                    UHCD_DESCRIPTOR_PTR_MASK));

#if DBG                 
                if (Endpoint->TDList->TDs[i].StatusField) {
                    LOGENTRY(LOG_MISC, 'Qerr', 0, 
                              Endpoint->TDList->TDs[i].StatusField, 
                              &Endpoint->TDList->TDs[i]);  
                
                    // TEST_TRAP();
                } else {
                    // TEST_TRAP();

                    LOGENTRY(LOG_MISC, 'Qsh2', Endpoint->MaxPacketSize, 
                              UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(Endpoint->TDList->TDs[i].ActualLength), 
                              &Endpoint->TDList->TDs[i]);  
                }                              
#endif
                //
                // queue head is stopped
                //
                busy = FALSE;
            } else {
                HW_DESCRIPTOR_PHYSICAL_ADDRESS linkNow;
                // the td we are point to is not active and
                // has no error status, now we check for            
                // queue header update problem ie is the queue
                // stuck?
                //
                linkNow = Endpoint->QueueHead->HW_VLink;

                LOGENTRY(LOG_MISC, 'QHp?', 
                                vLink, 
                                linkNow, 
                                Endpoint->TDList->TDs[i].HW_Link);     

                if (linkNow & UHCD_CF_TERMINATE) {
                    // pointing at a descriptor with the T bit, 
                    // indicate the queue is not busy
                    busy = FALSE;
                } else if ((linkNow & UHCD_DESCRIPTOR_PTR_MASK) == 
                           (vLink  & UHCD_DESCRIPTOR_PTR_MASK)) {

                    // bump the current TD int the queue head to the next TD 
                    // manually

                    LOGENTRY(LOG_MISC, 'QHp!', 
                                vLink, 
                                linkNow, 
                                Endpoint->TDList->TDs[i].HW_Link);     

                    UHCD_ASSERT((linkNow & UHCD_DESCRIPTOR_PTR_MASK)
                        == (Endpoint->TDList->TDs[i].PhysicalAddress & UHCD_DESCRIPTOR_PTR_MASK));
                    
                    Endpoint->QueueHead->HW_VLink = 
                        Endpoint->TDList->TDs[i].HW_Link;
                }                            
            }                    
        }
    } 

    if (QueueTD) {
        *QueueTD = i;
    }
    return busy;
}

    
__inline
BOOLEAN 
UHCD_PrepareAsyncDataPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHW_TRANSFER_DESCRIPTOR TransferDescriptor,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb,
    IN BOOLEAN TransferOverflow,
    IN BOOLEAN ZeroLengthTransfer,
    IN BOOLEAN InitializeTransfer
    )
/*++

Routine Description:

    Prepare a data packet for an async transfer.

Arguments:

    TransferDescriptor - 

    Endpoint - endpoint associated with this transfer.    

    Urb - pointer to URB Request for this transfer.

    Status - pointer to USBD status, will be filled in if transfer
             is complete.

    TransferOverflow - boolean flag indicates that we needed more
                TDs than we have.

Return Value:

    None.

--*/
{
    PHCD_EXTENSION urbWork = HCD_AREA(Urb).HcdExtension;
    BOOLEAN status = FALSE;
    BOOLEAN setToggle = TRUE;
    USHORT packetSize;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // tracks the nth packet in this transfer
    //

    if (InitializeTransfer && 
        // if this is init for multiple
        // slot endpoint then don't
        // mess with the data toggle 
        // until the xfer is active
        
        Endpoint->MaxRequests > 1) {
        setToggle = FALSE;            
    }        
    
    urbWork->PacketsProcessed++;

    LOGENTRY(LOG_MISC, 'Pasy', urbWork->TransferOffset, urbWork, TransferDescriptor);

#if DBG
    if (!ZeroLengthTransfer) {
        UHCD_ASSERT(urbWork->TransferOffset < Urb->HcdUrbCommonTransfer.TransferBufferLength);
    }        
#endif    
    //
    // possibly re-using this TD
    //

    UHCD_InitializeAsyncTD(Endpoint, TransferDescriptor);

    if (setToggle) {
        urbWork->Flags |= UHCD_TOGGLE_READY;
        TransferDescriptor->RetryToggle = Endpoint->DataToggle;
        Endpoint->DataToggle ^=1;
    }        

#if DBG
    // Use this field to detect if we 
    // process the same TD twice
    TransferDescriptor->Frame = 0;
#endif

    TransferDescriptor->PID = DATA_DIRECTION_IN(Urb) ? USB_IN_PID : USB_OUT_PID;
            
    if (DATA_DIRECTION_IN(Urb)) {
        
        if (deviceExtension->SteppingVersion < UHCD_B0_STEP) {

            //
            // Direction is IN, we'll need an interrupt an T bit
            // set on every packet to check for short packet. 
            //
            // The B0 step does not have this problem
            //

            TransferDescriptor->InterruptOnComplete = 1;
            SET_T_BIT(TransferDescriptor->HW_Link);
        } else {
            // TEST_TRAP();
            TransferDescriptor->ShortPacketDetect = 1;
        }
    } 
    
    if (TransferOverflow) {
    
        //
        // if we need more descriptors than we
        // have then so we'll set an interrupt on a middle packet to 
        // give us a chance to prepare more.
        //

        // lets try every 4th packet
        if (urbWork->PacketsProcessed % 4 == 0) {
            TransferDescriptor->InterruptOnComplete = 1;
        }            
    }

    // get the part of the buffer this TD represents

    // The urbWork structure contains a list of logical addresses we got 
    // from IoMapTransfer -- these are the valid physical addresses we will
    // give to the host controller.

    //
    // compute the packet size for this packet
    //
    
    if (urbWork->TransferOffset + Endpoint->MaxPacketSize 
            <= Urb->HcdUrbCommonTransfer.TransferBufferLength) {                                        
        packetSize = Endpoint->MaxPacketSize;        
    } else {
        packetSize = (USHORT)(Urb->HcdUrbCommonTransfer.TransferBufferLength - 
                                urbWork->TransferOffset);
    }

    if (ZeroLengthTransfer) {
        TransferDescriptor->PacketBuffer = 
            urbWork->LogicalAddressList[0].LogicalAddress;    
        TransferDescriptor->MaxLength = 
                UHCD_SYSTEM_TO_USB_BUFFER_LENGTH(packetSize);              
        LOGENTRY(LOG_MISC, 'zpak', TransferDescriptor->PacketBuffer, 
                packetSize, 0);  
        status = TRUE;                
    } else if (TransferDescriptor->PacketBuffer = 
        UHCD_GetPacketBuffer(DeviceObject, 
                             Endpoint, 
                             Urb, 
                             urbWork, 
                             urbWork->TransferOffset, 
                             packetSize)) {
        urbWork->TransferOffset += packetSize; 

        LOGENTRY(LOG_MISC, 'Pbuf', TransferDescriptor->PacketBuffer, packetSize, urbWork->TransferOffset);
        UHCD_ASSERT(urbWork->TransferOffset <= Urb->HcdUrbCommonTransfer.TransferBufferLength);
        
        TransferDescriptor->MaxLength = 
                UHCD_SYSTEM_TO_USB_BUFFER_LENGTH(packetSize);        
        status = TRUE;
    } 

    LOG_TD('daTD', TransferDescriptor);

    UHCD_KdPrint((2, "'**TD for BULK/INT/CONTROL DATA packet\n"));
    UHCD_Debug_DumpTD(TransferDescriptor);

    return status;
}


USBD_STATUS
UHCD_InitializeAsyncTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    This routine initializes the TDs needed by the hardware
    to process this request, called from Transfer_StartIo.  
    The transfer list for this URB should be ready for
    processing before returning from this routine.

Arguments:

    DeviceObject - pointer to a device object.
    
    Endpoint - Endpoint associated with this Urb.

    Urb - pointer to URB Request Packet for this transfer.

Return Value:

    Usbd status code.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    SHORT i, xtra, slot;
    USBD_STATUS usbStatus = USBD_STATUS_SUCCESS;
    PUHCD_TD_LIST tDList;
#if DBG 
    SHORT count;
#endif
    USHORT dataDescriptorsNeeded;
    PHCD_EXTENSION urbWork = HCD_AREA(Urb).HcdExtension;
    PHW_QUEUE_HEAD queueHead;

    UHCD_KdPrint((2, "'enter UHCD_InitializeAsyncTransfer\n"));

    ASSERT_ENDPOINT(Endpoint);
    UHCD_ASSERT(Endpoint == HCD_AREA(Urb).HcdEndpoint);

    //
    // if we have already been initialized or the queue
    // is in use then just exit.
    //

    queueHead = Endpoint->QueueHead;    
    if ((urbWork->Flags & UHCD_TRANSFER_INITIALIZED ||
         queueHead->Flags) && 
        !(urbWork->Flags & UHCD_TRANSFER_DEFER)) {
        goto UHCD_InitializeAsyncTransfer_Done;
    } 

    //
    // note that we have initialized
    //
    
    urbWork->Flags |= UHCD_TRANSFER_INITIALIZED;
    queueHead->Flags |= UHCD_QUEUE_IN_USE;

    LOGENTRY(LOG_MISC, 'Iasx', Endpoint, Urb, DeviceObject);

#ifdef CONTROL
    if (CONTROL_TRANSFER(Endpoint)) {
        LOGENTRY(LOG_MISC, 'Ctrl', Endpoint, Urb, DeviceObject);        
        // data toggle must be 0 for setup
        // BUGBUG reset data toggle in ENDPOINT
        Endpoint->DataToggle = 0;
    }
#endif

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Set up the TDs we will need to do this transfer    
    //

    // do some general init stuff first,
    // TDs form a circular list
    slot = urbWork->Slot;
    tDList = Endpoint->SlotTDList[slot];
    
    for (i=0; i < Endpoint->TDCount; i++) {
        tDList->TDs[i].Endpoint = Endpoint->EndpointAddress;
        tDList->TDs[i].Address = Endpoint->DeviceAddress;        
        tDList->TDs[i].HW_Link = 
            tDList->TDs[(i+1) % Endpoint->TDCount].PhysicalAddress;    
        UHCD_InitializeAsyncTD(Endpoint, &tDList->TDs[i]);
    } 

    // current descriptor is first packet
    Endpoint->CurrentTDIdx[slot] = 0;

    // No tail descriptor yet
    Endpoint->LastTDInTransferIdx[slot] = -1;

    // if we have data to send or receive break it up into TDs,
    // do this until we run out of TDs or we finish the buffer

    // first, calculate how many data descriptors we will need
    // based on the transfer buffer length
    dataDescriptorsNeeded = (USHORT) (Urb->HcdUrbCommonTransfer.TransferBufferLength / 
                                        Endpoint->MaxPacketSize);  

    if ((ULONG)(dataDescriptorsNeeded)*Endpoint->MaxPacketSize < Urb->HcdUrbCommonTransfer.TransferBufferLength) {
        dataDescriptorsNeeded++;        
    }
    
    // Initialize some endpoint fields

    urbWork->TransferOffset = 0;
    urbWork->BytesTransferred = 0;
    urbWork->PacketsProcessed = 0;

    //points to first available TD
    Endpoint->LastTDPreparedIdx[slot] = 0;

    LOGENTRY(LOG_MISC, 'XfrB', Urb, dataDescriptorsNeeded, Urb->HcdUrbCommonTransfer.TransferBufferLength);    

#ifdef CONTROL
    if (CONTROL_TRANSFER(Endpoint)) {
        // note that we'll need two extra TDs (for setup and status).
        xtra = 2;        

        // Build a setup packet if necessary.

        UHCD_ASSERT(Endpoint->MaxRequests == 1);
        UHCD_PrepareSetupPacket(&tDList->TDs[Endpoint->LastTDPreparedIdx[slot]], 
                                Endpoint, 
                                Urb);

        // point to next available TD

        Endpoint->LastTDPreparedIdx[slot]++;
 
    } else {
#endif        

        xtra = 0;
#ifdef CONTROL
    }
#endif

    LOGENTRY(LOG_MISC, 'LBuf', 0, 0, urbWork->LogicalAddressList[0].LogicalAddress);  

    //
    // Begin preparing Data TDs, Endpoint->LastTDPreparedIdx points
    // to the first available TD.  Loop until we use up all the available 
    // TDs or we finish off the client buffer.
    //
#if DBG
    count = 0;
#endif

    // remember the data toggle when we set up
    urbWork->DataToggle = Endpoint->DataToggle;

    while (Endpoint->LastTDPreparedIdx[slot]<Endpoint->TDCount) {

        if (Urb->HcdUrbCommonTransfer.TransferBufferLength == 0 && 
            !CONTROL_TRANSFER(Endpoint)) {
            //
            // special case the zero transfer
            //
            TEST_TRAP();
            dataDescriptorsNeeded = 1;
            if (!UHCD_PrepareAsyncDataPacket(DeviceObject,
                                             &tDList->TDs[Endpoint->LastTDPreparedIdx[slot]], 
                                             Endpoint, 
                                             Urb, 
                                             // no overflow
                                             FALSE,
                                             TRUE,
                                             // init
                                             TRUE)) {
                // an error occurred forming the packet
                // bail out now                                             
                TEST_TRAP();
                usbStatus = USBD_STATUS_NO_MEMORY;
                goto UHCD_InitializeAsyncTransfer_Done;
            }            
            Endpoint->LastTDPreparedIdx[slot]++; 
            break;
        }
        
        if (urbWork->TransferOffset < Urb->HcdUrbCommonTransfer.TransferBufferLength ) {
            
            if (!UHCD_PrepareAsyncDataPacket(DeviceObject,
                                             &tDList->TDs[Endpoint->LastTDPreparedIdx[slot]], 
                                             Endpoint, 
                                             Urb, 
                                             ASYNC_TRANSFER_OVERFLOW(dataDescriptorsNeeded, Endpoint, xtra),
                                             FALSE,
                                             // init
                                             TRUE)) {
                // an error occurred forming the packet
                // bail out now                                             
                TEST_TRAP();
                usbStatus = USBD_STATUS_NO_MEMORY;
                goto UHCD_InitializeAsyncTransfer_Done;
            }                                             
                                                         
            Endpoint->LastTDPreparedIdx[slot]++;    
#if DBG            
            count++;
#endif            
        } else {
            break;
        }            
    }

#if DBG
    LOGENTRY(LOG_MISC, 'dTDs', Endpoint, count, dataDescriptorsNeeded);    
#endif

    //
    // We have more data than descriptors, save some state information 
    // so we can continue the process later.
    //

    if (ASYNC_TRANSFER_OVERFLOW(dataDescriptorsNeeded, Endpoint, xtra)) {
        // set the T-bit for the last TD we were able to set up
        // set the interrupt bit so we can prepare more TDs

        LOGENTRY(LOG_MISC, 'Ovrf', Endpoint, dataDescriptorsNeeded, xtra);        

        // LastTDPreparedIdx points to the last TD in the set
        Endpoint->LastTDPreparedIdx[slot] = Endpoint->TDCount-1;
        Endpoint->TDList->TDs[Endpoint->LastTDPreparedIdx[slot]].InterruptOnComplete = 1;
        SET_T_BIT(tDList->TDs[Endpoint->LastTDPreparedIdx[slot]].HW_Link);
    } else {
        // All the data fit, mark the tail so we know
        // when we are done.
#ifdef CONTROL
        if (CONTROL_TRANSFER(Endpoint)) {
            Endpoint->LastTDPreparedIdx[slot] =
                Endpoint->LastTDInTransferIdx[slot] = dataDescriptorsNeeded+1;

            UHCD_PrepareStatusPacket(&tDList->TDs[Endpoint->LastTDInTransferIdx[slot]], 
                                     Endpoint, 
                                     Urb);
            
        } else {
#endif
            Endpoint->LastTDPreparedIdx[slot] =
                Endpoint->LastTDInTransferIdx[slot] = dataDescriptorsNeeded-1;

#ifdef CONTROL
        }
#endif

        //    
        // Set the IOC bit for this and T bit for the last TD in the
        // transfer
        //
        
        UHCD_KdPrint((2, "'IOC bit set for TD %x\n", 
            &tDList->TDs[Endpoint->LastTDInTransferIdx[slot]]));
        
        tDList->TDs[Endpoint->LastTDInTransferIdx[slot]].InterruptOnComplete = 1;
        SET_T_BIT(tDList->TDs[Endpoint->LastTDInTransferIdx[slot]].HW_Link);        
    }

    //
    // at this point...
    // LastTDPreparedIdx points to the last TD we set up for this transfer
    // LastTDInTransferIdx points to the last TD in the set or -1 if the transfer
    // required more TDs than we had.
    // CurrentTDIdx points to the first active TD in the set
    //

UHCD_InitializeAsyncTransfer_Done:

    UHCD_KdPrint((2, "'exit UHCD_InitializeAsyncTransfer\n"));

    return usbStatus;
}


USBD_STATUS
UHCD_ProcessAsyncTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint, 
    IN PHCD_URB Urb,
    IN OUT PBOOLEAN Completed
    )
/*++

Routine Description:

    Checks to see if an async transfer is complete.

Arguments:

    DeviceObject - pointer to a device object.

    Endpoint - endpoint to check for completed transfers.

    Urb - ptr to URB to process.

    Completed -  TRUE if this transfer is complete, Status set to proper
                error code.

Return Value:

    usb status will be returned if transfer is complete.
--*/
{
    BOOLEAN resumed = FALSE;
    LONG i, queueTD, slot;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor;
    BOOLEAN prepareMoreTDs = FALSE;
    PHCD_EXTENSION urbWork = HCD_AREA(Urb).HcdExtension;
    USBD_STATUS usbStatus = Urb->HcdUrbCommonTransfer.Status;
    PHW_QUEUE_HEAD queueHead;
    PDEVICE_EXTENSION deviceExtension;

    STARTPROC("Pas+");
//    UHCD_KdPrint((2, "'enter UHCD_ProcessAsyncTransfer\n"));

    ASSERT_ENDPOINT(Endpoint);
    *Completed = FALSE;
    queueHead = Endpoint->QueueHead;
    slot = urbWork->Slot;

    // can only process one TD list at a time
    LOGENTRY(LOG_MISC, 'Pasx', Endpoint->LastPacketDataToggle, slot, Urb);
    LOGENTRY(LOG_MISC, 'Pas1', Endpoint->TDList, slot, Endpoint->SlotTDList[slot]);
    LOGENTRY(LOG_MISC, 'PaEO', Endpoint, Endpoint->EndpointFlags, queueHead);
#if DBG
    switch(Endpoint->Type) {
    case USB_ENDPOINT_TYPE_CONTROL:
        LOGENTRY(LOG_MISC, 'Pctr', 0, 0, queueHead);
        break;
    case USB_ENDPOINT_TYPE_BULK:
        LOGENTRY(LOG_MISC, 'Pblk', 0, 0, queueHead);
        break;
    }        
#endif

    deviceExtension=DeviceObject->DeviceExtension;

    //
    // if we marked the transfer canceling the go ahead
    // and completed it now.
    //
    
    if (Urb->HcdUrbCommonTransfer.Status == UHCD_STATUS_PENDING_CANCELING) {

        // set the data toggle based on the last packet completed
        Endpoint->DataToggle = 
            Endpoint->LastPacketDataToggle ^1;            
        
        LOGENTRY(LOG_MISC, 'PxxC', 
            Endpoint->LastPacketDataToggle, Endpoint->DataToggle, Urb);
        *Completed = TRUE;
        usbStatus = USBD_STATUS_CANCELED;
        
        goto UHCD_ProcessAsyncTransfer_done;  
    }

    //
    // see if the endpoint has been aborted, if so stop this transfer and 
    // wait unitl the next frame to complete it.
    //
    
    if ((Endpoint->EndpointFlags & EPFLAG_ABORT_ACTIVE_TRANSFERS) ||
        Urb->HcdUrbCommonTransfer.Status == UHCD_STATUS_PENDING_XXX) {
        LOGENTRY(LOG_MISC, 'Pxxx', 0, slot, Urb);
        UHCD_RESET_TD_LIST(Endpoint);
        UHCD_RequestInterrupt(DeviceObject, -2);
        Urb->HcdUrbCommonTransfer.Status = 
            UHCD_STATUS_PENDING_CANCELING;
        usbStatus = Urb->HcdUrbCommonTransfer.Status;            
        goto UHCD_ProcessAsyncTransfer_done;  
    }

    //
    // if queue is busy or endpoint stalled then no processing will be performed
    // at this time
    //
    
    if (Endpoint->EndpointFlags & EPFLAG_HOST_HALTED) {
        goto UHCD_ProcessAsyncTransfer_done;      
    }   

    // process an active transfer, only one can be current
    
    UHCD_ASSERT(Endpoint->TDList == Endpoint->SlotTDList[slot]);
        
    if (UHCD_QueueBusy(DeviceObject, Endpoint, &queueTD)) {
//#if 0    
        LOGENTRY(LOG_MISC, 'PRqh', Endpoint, queueTD, 0);

        // **
        // Code to process a queue head that the hardware is
        // currently accessing.
        // **
        //
        // Queue head is busy but we can still process and 
        // set up more TDs
        //

        // attempt some processing now...
        //
        // scan through the retired TDs between current TD and the TD
        // that the queue head is pointing at, we should only encounter 
        // IN and OUT TDs that have completed successfully

        i = Endpoint->CurrentTDIdx[slot];    
        // currently pointed to by the queue head
        
        while (i != queueTD) {
        
            LOGENTRY(LOG_MISC, 'QuTD', Endpoint->CurrentTDIdx[slot], i, queueTD);

            if (i == Endpoint->LastTDInTransferIdx[slot]) {
                // if this is the last TD let the 
                // process routine handle it.
                break;
            }
        
            transferDescriptor = &Endpoint->TDList->TDs[i];
            
            UHCD_ASSERT(transferDescriptor->Active == 0);
            UHCD_ASSERT(transferDescriptor->StatusField == 0);            

            if (transferDescriptor->PID == USB_IN_PID ||
                transferDescriptor->PID == USB_OUT_PID) {
                urbWork->BytesTransferred += UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(transferDescriptor->ActualLength);            
                LOGENTRY(LOG_MISC, 'reTD', transferDescriptor, 
                    transferDescriptor->Frame, Urb->HcdUrbCommonTransfer.TransferBufferLength);
                Endpoint->LastPacketDataToggle = 
                    (UCHAR)transferDescriptor->RetryToggle;                    
                UHCD_ASSERT(transferDescriptor->Frame == 0);
#if DBG
                transferDescriptor->Frame = 1;
#endif
                UHCD_ASSERT(urbWork->BytesTransferred <= 
                        Urb->HcdUrbCommonTransfer.TransferBufferLength);
            }

            i = NEXT_TD(i, Endpoint);            
        }

        //Endpoint->CurrentTDIdx = queueTD;        
        Endpoint->CurrentTDIdx[slot] = (SHORT)i;
//#endif                            
        if (Endpoint->LastTDInTransferIdx[slot] == -1) {

            //
            // This was an OVERFLOW transfer
            // ie we didn't have enough TDs to satisfy the request.
            //
            usbStatus = UHCD_PrepareMoreAsyncTDs(DeviceObject,
                                                 Endpoint,
                                                 Urb, 
                                                 TRUE);        
            if (USBD_ERROR(usbStatus)) {
                //
                // if we get an error preparing more TDs
                // then we'll need to abort the transfer
                //
                TEST_TRAP();
                UHCD_RESET_TD_LIST(Endpoint);
                UHCD_RequestInterrupt(DeviceObject, -2);
                Urb->HcdUrbCommonTransfer.Status = 
                    UHCD_STATUS_PENDING_CANCELING;
            }
        }
        
        goto UHCD_ProcessAsyncTransfer_done;      
    }     

    LOGENTRY(LOG_MISC, 'Pasx', Endpoint, Endpoint->CurrentTDIdx[slot], DeviceObject);

    //
    // If we get here the queue is not busy.
    //
    //
    // Scan our active TDs starting with 'CurrentTDIdx' stop as soon as we find
    // a TD that is still active or we find that the STATUS TD is complete
    //
    //

    // Start at the last TD that had not completed
    i = Endpoint->CurrentTDIdx[slot];
    for (;;) {



        //
        // This loop terminates on the following conditions:
        // 1. An active TD is encountered. 
        // 2. The last TD in the transfer is processed.
        // 3. An non-zero status value is encountered on
        //    a completed TD.
        // 4. The last TD that had been set up for the
        //    transfer is complete.

        transferDescriptor = &Endpoint->TDList->TDs[i];
        
        LOGENTRY(LOG_MISC, 'ckTD', i, transferDescriptor, 
            Endpoint->CurrentTDIdx[slot]);
        
        //
        // Did this TD complete?
        //
        
        UHCD_KdPrint((2, "'checking TD  %x\n", transferDescriptor));
        
        if (transferDescriptor->Active == 0) {

            LOG_TD('acTD', (PULONG) transferDescriptor);

            UHCD_KdPrint((2, "'TD  %x completed\n", transferDescriptor));
            UHCD_Debug_DumpTD(transferDescriptor);

            Endpoint->LastPacketDataToggle = (UCHAR)transferDescriptor->RetryToggle;
            LOGENTRY(LOG_MISC, 'LPdt', Endpoint, 
                 Endpoint->LastPacketDataToggle, 0); 
        
            //
            // Yes, TD completed figure out what to do
            //

            if (transferDescriptor->StatusField != 0) {
                // we got an error, map the status code and retire 
                // this transfer
                *Completed = TRUE;
                usbStatus = UHCD_MapTDError(deviceExtension, transferDescriptor->StatusField,
                    UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(transferDescriptor->ActualLength));
                                    
                // Point the queue head at the first TD with the T-Bit set.
                // NOTE: we won't get here if the TD is marked with status NAK
                // because the active bit is still set.

                UHCD_ASSERT_QSTOPPED(DeviceObject, Endpoint, NULL);
                UHCD_RESET_TD_LIST(Endpoint);

                LOGENTRY(LOG_MISC, 'Stal', Endpoint, transferDescriptor->StatusField, usbStatus); 

                UHCD_KdBreak((2, "'Stall\n"));
                break;
            }             

            //
            //  No Error, update bytes transferred for this 
            //  packet if it was data.
            // 
            if (transferDescriptor->PID == USB_IN_PID ||
                transferDescriptor->PID == USB_OUT_PID) {
                urbWork->BytesTransferred += UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(transferDescriptor->ActualLength);            
                UHCD_ASSERT(transferDescriptor->Frame == 0);
#if DBG
                transferDescriptor->Frame = 1;
#endif
                UHCD_ASSERT(urbWork->BytesTransferred <= 
                        Urb->HcdUrbCommonTransfer.TransferBufferLength);
            }                        

            //            
            // Check to see if we are done with the transfer.
            //

            if (i == Endpoint->LastTDInTransferIdx[slot])    {

                // 
                // This is the last TD in the transfer, complete now.
                // 

                // point the queue head at the first TD with the T-Bit set
                UHCD_ASSERT_QSTOPPED(DeviceObject, Endpoint, NULL);
                UHCD_RESET_TD_LIST(Endpoint);
                *Completed = TRUE;
                usbStatus = USBD_STATUS_SUCCESS;
                break;                
            }    

            //
            // Short packets cause the transfer to complete.
            //

            if (transferDescriptor->ActualLength != transferDescriptor->MaxLength) {

                //
                // We have a short transfer. 
                //
                
                LOGENTRY(LOG_MISC, 'Shrt', 
                          transferDescriptor, 
                          transferDescriptor->ActualLength, 
                          transferDescriptor->MaxLength);

#ifdef CONTROL
#if DBG
                //
                // test handling short transfer_ok with control transfer
                //
                if (CONTROL_TRANSFER(Endpoint) &&
                    !(Urb->HcdUrbCommonTransfer.TransferFlags & USBD_SHORT_TRANSFER_OK)) {
                    TEST_TRAP();
                }
#endif //DBG
                if (CONTROL_TRANSFER(Endpoint) &&
                    Urb->HcdUrbCommonTransfer.TransferFlags & USBD_SHORT_TRANSFER_OK) {

                    //
                    // If this is a control transfer then we need to advance 
                    // to the status phase
                    //
                    
                    if (Endpoint->LastTDInTransferIdx[slot] == -1) {
                        // status phase has not been set up yet
                        // do it now
                    
                        Endpoint->LastTDInTransferIdx[slot] = (SHORT) NEXT_TD(i, Endpoint);

                        UHCD_PrepareStatusPacket(&Endpoint->TDList->TDs[Endpoint->LastTDInTransferIdx[slot]],
                                                 Endpoint, 
                                                 Urb);

                        SET_T_BIT(Endpoint->TDList->TDs[Endpoint->LastTDInTransferIdx[slot]].HW_Link);                                                     
                    } 

                    // make the status p hase the current TD                    
                    i = Endpoint->CurrentTDIdx[slot] = 
                        Endpoint->LastTDInTransferIdx[slot];

                    // just point the queue head at the status packet
                    // and go!                    
                    queueHead->HW_VLink = 
                        Endpoint->TDList->TDs[Endpoint->LastTDInTransferIdx[slot]].PhysicalAddress;
                        
                    LOGENTRY(LOG_MISC, 'ShSt', 
                               queueHead, 
                               &Endpoint->TDList->TDs[Endpoint->LastTDInTransferIdx[slot]], 
                               0);    
                    // Go to the top of the loop in case it completed, 
                    // we'll still get the interrupt but we may be able 
                    // to finish the transfer sooner.

                    // note that we resumed the queue head
                    // so we don't resume it agian.
                    resumed = TRUE;
                    continue;
                } else {
#endif
                    //
                    // Short packet and not a control transfer or control transfer 
                    // and short transfer is to be treated as an error, just complete
                    // the transfer now.
                    //

                    UHCD_ASSERT_QSTOPPED(DeviceObject, Endpoint, NULL);
                    UHCD_RESET_TD_LIST(Endpoint);
                    // adjust data toggle
                    Endpoint->DataToggle = 
                        (UCHAR)transferDescriptor->RetryToggle;
                    Endpoint->DataToggle ^=1;

                    
                    *Completed = TRUE;
                    //check the SHORT_TRANSFER_OK flag
                    if (Urb->HcdUrbCommonTransfer.TransferFlags & USBD_SHORT_TRANSFER_OK) {
                        usbStatus = USBD_STATUS_SUCCESS;
                    } else {
                        TEST_TRAP();
                        usbStatus = USBD_STATUS_ERROR_SHORT_TRANSFER;
                    }    
                    break;                                        
#ifdef CONTROL
                }
#endif
                //
                // end of short packet detection. 
                //
            } 
        
            // 
            // Done with the TD but not with the transfer, advance our 
            // index to the current TD.
            //
                
            Endpoint->CurrentTDIdx[slot] = NEXT_TD(Endpoint->CurrentTDIdx[slot], Endpoint);

            //
            // see if we need to prepare more TDs
            //

            LOGENTRY(LOG_MISC, 'chkM', i, Endpoint->LastTDPreparedIdx[slot], 
                Endpoint->LastTDInTransferIdx[slot]);

            if (i == Endpoint->LastTDPreparedIdx[slot] && 
                Endpoint->LastTDInTransferIdx[slot] == -1) {
                //
                // This was the last TD prepared for an OVERLOW transfer
                // ie we didn't have enough TDs to satifsy the request.
                // 
                // This is when we prepare more TDs.
                //
                usbStatus = UHCD_PrepareMoreAsyncTDs(DeviceObject,
                                                     Endpoint,
                                                     Urb,
                                                     FALSE);
                if (USBD_ERROR(usbStatus)) {
                    // an error occurred preparing more TDs
                    // terminate the transfer now
                    TEST_TRAP();
                     // assert that the T-BIT is still set in the QH.
                    UHCD_ASSERT_QSTOPPED(DeviceObject, Endpoint, NULL);
                    UHCD_RESET_TD_LIST(Endpoint);
                    *Completed = TRUE;
                    goto UHCD_ProcessAsyncTransfer_done;       
                }                                                     
                
            }
        // end active == 0
        } else {

            //                
            // This TD is still active, stop processing TDs now.
            //

            break;     
        }

        //
        // advance to the next TD in the list
        //

        i = NEXT_TD(i, Endpoint);

    } // end for (;;) 

    if (!*Completed && !resumed) {
        // NOTE that if the QH is busy we 
        // should not get here

        // make sure the queue head is still stopped
        UHCD_ASSERT_QSTOPPED(DeviceObject, Endpoint, NULL);
        
        LOGENTRY(LOG_MISC, 'rsum', Endpoint,  Endpoint->CurrentTDIdx[slot], 
            &Endpoint->TDList->TDs[Endpoint->CurrentTDIdx[slot]]);    
            
        //
        // We get here if the transfer has not completed yet but the
        // queue head is stopped, this is caused by one of the following 
        // conditions:
        //
        // 1. The last TD that could be set up for a transfer completed
        //    and we had to set up more.
        //
        // 2. An IN Transfer completed for BULK or INT and it was not a 
        //    short packet and it was not the last TD in the transfer and
        //    short packet detection is not enabled on the HC.
        // 
        // In any case we'll need to resume the Queue head, we point
        // the queue head at the current TD and go.
    
        queueHead->HW_VLink = 
            Endpoint->TDList->TDs[Endpoint->CurrentTDIdx[slot]].PhysicalAddress;
                            
    }
    
UHCD_ProcessAsyncTransfer_done:

    if (*Completed) {
    
        queueHead->Flags &= ~UHCD_QUEUE_IN_USE;

        // note that we don't activate the next transfer if we 
        // are in an abort scenario
        if (Endpoint->MaxRequests > 1) {
    
            //
            // transfer completed, so queue is no longer in use
            // try to start the next transfer here.
            //

            UHCD_ASSERT_QSTOPPED(DeviceObject, Endpoint, NULL);

            //
            // BUGBUG if MaxRequets is > 2 then we'll need some kind of sequence 
            // number so we can start the transfers in the right order.
            // Since we have only two now the one that we are not completing
            // is the next one to start.
            //

            // get the next ready transfer based on seq number
            for (i=0; i< Endpoint->MaxRequests; i++) {
                PHCD_URB localUrb;
                PHCD_EXTENSION localWork;
                UCHAR nextXfer = Endpoint->CurrentXferId+1;

                localUrb = Endpoint->ActiveTransfers[i];
                
                if (localUrb) {
                    localWork = HCD_AREA(localUrb).HcdExtension;
                    
                    LOGENTRY(LOG_MISC, 'Cnxt', Endpoint->CurrentXferId, nextXfer, 
                        localWork->XferId);    

                    if (nextXfer == localWork->XferId) {
                        // this is the next transfer
                        LOGENTRY(LOG_MISC, 'NXTx', localUrb, nextXfer, i);   
                        break;
                    }                        
                }
            }                

            if (i == Endpoint->MaxRequests) {
                // no xfers available
                LOGENTRY(LOG_MISC, 'NoXF', 0, Endpoint->CurrentXferId, i);    
                        
            } else {
                PHCD_EXTENSION localWork;
                PHCD_URB localUrb;
                 
                //
                // This will start the next active transfer
                // for the endpoint.
                //
                
                UHCD_ASSERT(Endpoint->ActiveTransfers[i]); 

                localUrb = Endpoint->ActiveTransfers[i];
                localWork = HCD_AREA(localUrb).HcdExtension;
                
                UHCD_ASSERT(i == localWork->Slot);                    
#if DBG                
                if (Urb->HcdUrbCommonTransfer.Status != UHCD_STATUS_PENDING_CANCELING) {
                    UHCD_ASSERT(localWork->Flags & UHCD_TRANSFER_DEFER);
                }                    
#endif                

                // now we need to set up the queue head
                // BUGBUG -- we currently don't handle look ahead 
                // ie if this transfer was already linked
                //
                //  This is where we would check.

                // before linking in this transfer we
                // need to fixup the data toggle based
                // on the current toggle for the ED
                
                    
                UHCD_FixupDataToggle(DeviceObject,
                                     Endpoint,
                                     localUrb);

                //UHCD_ASSERT((Endpoint->CurrentXferId+(UCHAR)1) == localWork->XferId);

                // update the endpoints TDList
                // slot id corresponds to TD list
                LOGENTRY(LOG_MISC, 'mkC2', Endpoint->CurrentXferId, localWork->Slot, 
                         localWork->XferId);

                Endpoint->TDList = 
                     Endpoint->SlotTDList[i];
                         
                LOGENTRY(LOG_MISC, 'NXgo', Endpoint->TDList, localWork->Slot, 
                         Endpoint->TDList->TDs[0].PhysicalAddress);                     

                Endpoint->QueueHead->HW_VLink = 
                     Endpoint->TDList->TDs[0].PhysicalAddress;                            

                // this enables the xfer to be processed
                localWork->Flags &= ~UHCD_TRANSFER_DEFER;                     
            }                
            
        } 
// NOT USED        
#if 0        
          else {

            //
            // Low speed control endpoints share a single queue head.
            // 
            // If the endpoint is lowspeed control then we need to start
            // the next control transfer on this queue head.
            //
            // If another low speed control queue head is waiting we will 
            // pick it up when we process the rest of the endpoint list 
            // for this interrupt.  If the next control queue head is before 
            // us in the endpoint list then we will ask for an interrupt next 
            // frame so that we can start it.
            //

            if (Endpoint->LowSpeed) {
                TEST_TRAP();
                UHCD_RequestInterrupt(DeviceObject, -2);           
            }                
        }
#endif        
    }

//    UHCD_KdPrint((2, "'exit UHCD_ProcessAsyncTransfer %d status = %x\n', completed, *Status));

    ENDPROC("Pas-");
    
    return usbStatus;
}


USBD_STATUS 
UHCD_PrepareMoreAsyncTDs(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint, 
    IN PHCD_URB Urb,
    IN BOOLEAN Busy
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to a device object.

    Endpoint - endpoint to check for completed transfers.

    Urb - ptr to URB to process.
    
    Status - pointer to USBD status, will be filled in if transfer
             is complete.

    Busy - indicates the stae of the queue head             

Return Value:

    TRUE if this transfer is complete, Status set to proper
    error code.

--*/
{
    ULONG count = 0;
    SHORT i, slot;
    SHORT start, oldLastTDPreparedIdx;
    PHCD_EXTENSION urbWork = HCD_AREA(Urb).HcdExtension;
    USBD_STATUS usbStatus = USBD_STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;

    STARTPROC("Mas+");
    //
    // One of two conditions get us in to this routine:
    //
    // 1. The queue is stopped, waiting for us to prepare 
    //      more TDs for an overflow transfer: Busy = FALSE
    //      && CurrentTDIdx is pointing at the first TD after
    //      the last TD prepared.
    //
    // 2. The queue is not stopped but we may be able to set
    //      up some more TDs
    // 

    
    // can only process one TD list at a time
    slot = urbWork->Slot;
    UHCD_ASSERT(Endpoint->TDList == Endpoint->SlotTDList[slot]);
    

    UHCD_KdPrint((2, "'enter UHCD_PrepareMoreAsyncTDs\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    
    //
    // Pick up where we left off, keep building TDs until we 
    // use up the client buffer or run out of TDs.
    //

    //
    // Start at the first TD available after the last one prepared.
    //
    oldLastTDPreparedIdx = Endpoint->LastTDPreparedIdx[slot];
    i = NEXT_TD(Endpoint->LastTDPreparedIdx[slot], Endpoint);
    // Remember where we started...
    start = i;

    LOGENTRY(LOG_MISC, 'pmTD', Endpoint->LastTDPreparedIdx[slot], 
        Endpoint->LastTDInTransferIdx[slot], Busy);

    if (Busy) {
    
        // We want to avoid doing this if the number of free TDs is not worth
        // the effort -- otherwise we'll end up with the T-Bit and ioc bit set
        // for every packet.
        // -- 
        // Do a quick scan of the TDs if we have at least 4 inactive then go
        // ahead and try
        
        SHORT j, x = 0;
        
        for (j=0; j<Endpoint->TDCount; j++) {
            if (!Endpoint->TDList->TDs[j].Active) {
                x++;
            }
        }    

        //
        // x = the most TDs we can set up
        //
        if (x <= 3) {
            goto UHCD_PrepareMoreAsyncTDs_Done;
        }            

        LOGENTRY(LOG_MISC, 'frTD', x, Endpoint->QueueHead->HW_VLink, 0); 
    } 
#if DBG 
      else {
        UHCD_ASSERT(i == Endpoint->CurrentTDIdx[slot]);
        // if we are not Busy then we got here because the T-bit was set
        // this means that currentTD should be the first new TD we set 
        // up, and all TDs for this transfer have been processed.
        
        // assert that the T-bit is set on the queue head
    }
#endif
        
    do  {

        LOGENTRY(LOG_MISC, 'mrTD', i, Endpoint->CurrentTDIdx, 
            Endpoint->LastTDPreparedIdx[slot]); 
        // 
        // If the Busy flag is set then the currentTD has not been 
        // processed yet so we need to stop if we hit it.
        //

        if (Busy && i == Endpoint->CurrentTDIdx[slot]) {
            break;
        }
        
        //
        // we should never encounter an active TD
        //
        UHCD_ASSERT(Endpoint->TDList->TDs[i].Active == 0);
        
        //
        // See if we have consumed the client buffer, if so then we are 
        // done, mark this TD as the last one and stop preparing TDs.
        //

        if (urbWork->TransferOffset < Urb->HcdUrbCommonTransfer.TransferBufferLength ) {
            UHCD_KdPrint((2, "'offset = %x\n", urbWork->TransferOffset));
            if (UHCD_PrepareAsyncDataPacket(DeviceObject,
                                            &Endpoint->TDList->TDs[i], 
                                            Endpoint, 
                                            Urb, 
                                            TRUE,
                                            FALSE,
                                            // not init
                                            FALSE)) { 
                                                        
                Endpoint->LastTDPreparedIdx[slot] = i;
                count++;        
            } else {
                //
                // error occurred forming packet, this will 
                // complete the transfer.
                //
                TEST_TRAP();
                usbStatus = USBD_STATUS_NO_MEMORY;
                goto UHCD_PrepareMoreAsyncTDs_Done;
            }    
        } else {
#ifdef CONTROL

            //
            // Done with client buffer, if this is a control 
            // transfer then we'll need to do the status packet
            //
                
            if (CONTROL_TRANSFER(Endpoint)) {
                UHCD_PrepareStatusPacket(&Endpoint->TDList->TDs[i], 
                                         Endpoint, 
                                         Urb); 

                Endpoint->LastTDPreparedIdx[slot] = i;
                count++;
            } 
#endif    
            //
            // Last TD in the transfer is the last one we set up,
            // the current TD should be set to the first one we set up.
            //
            
            Endpoint->LastTDInTransferIdx[slot] = 
                Endpoint->LastTDPreparedIdx[slot];

            //
            // Set the T-bit and the IOC bit for the last TD in the transfer
            //
            // NOTE: for non-B0 systems the IOC bit and T-bit will be set on every 
            // packet for IN transfers.
            //
            
            SET_T_BIT(Endpoint->TDList->TDs[Endpoint->LastTDInTransferIdx[slot]].HW_Link);
            Endpoint->TDList->TDs[Endpoint->LastTDInTransferIdx[slot]].InterruptOnComplete = 1;
            
            if (!Busy) {
                // if the queue head was stopped resume at the first TD we 
                // set up.
                Endpoint->CurrentTDIdx[slot] = start;
            }                
            break;
#ifdef CONTROL
        }
#endif
        
        i = NEXT_TD(Endpoint->LastTDPreparedIdx[slot], Endpoint);

        //
        // stop when we get to the TD we started at or we hit
        // the current TD.
        //
        // if we were called to set up TDs while the endpoint is still busy
        // then it is possible we'll run in to the current TD. 
        //
            
    } while (i != start && i !=  Endpoint->CurrentTDIdx[slot]);

    //
    // We may not have finished setting up all the TDs for the transfer,
    // if this is the case we'll need to set the T-Bit and IOC bit on the
    // last TD we were able to prepare.
    //

    if (count && Endpoint->LastTDInTransferIdx[slot] == -1) {
        SET_T_BIT(Endpoint->TDList->TDs[Endpoint->LastTDPreparedIdx[slot]].HW_Link);
        Endpoint->TDList->TDs[Endpoint->LastTDPreparedIdx[slot]].InterruptOnComplete = 1;

        // check to see if we finished the client buffer
        // ie client buffer finished with the last TD we prepared.
        if (urbWork->TransferOffset == Urb->HcdUrbCommonTransfer.TransferBufferLength &&
                !CONTROL_TRANSFER(Endpoint)) {
            Endpoint->LastTDInTransferIdx[slot] = Endpoint->LastTDPreparedIdx[slot];
        }
    }
            
 
    if (Busy && count) {
        // attempt to clear the old T-bit from the lastTD prepared
        // we may not get it in time but if we do we'll avoid stopping
        // the queue.

        if (deviceExtension->SteppingVersion >= UHCD_B0_STEP || 
            DATA_DIRECTION_OUT(Urb)) {
            CLEAR_T_BIT(Endpoint->TDList->TDs[oldLastTDPreparedIdx].HW_Link);
            // hit this if we ever actually set up more TDs while the Queue head
            // is busy
        } 
    }
    
    //
    // NOTE:
    // Caller is responsible for resuming the QH at currentTDIdx.
    //
UHCD_PrepareMoreAsyncTDs_Done:

    UHCD_KdPrint((2, "'exit UHCD_PrepareMoreAsyncTDs\n"));
    ENDPROC("Mas-");
    
    return usbStatus;
}


HW_DESCRIPTOR_PHYSICAL_ADDRESS
UHCD_GetPacketBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb,
    IN PHCD_EXTENSION UrbWork,
    IN ULONG Offset,
    IN ULONG PacketSize
    )
/*++

Routine Description:

    Compute the packet buffer physical address we will give to the 
    host controller based on the current offset in the transfer.  
    We also check if the packet crosses a page boundry if so this
    routine returns an address of a region of memory used to 
    double-buffer the packet.

Arguments:

    PacketSize - size of the packet we are dealing with

    Offset - is the start position in the transfer for this
            packet

Return Value:

    Physical address of a packet buffer we can give to the UHC hardware.
    If the packet requires double buffering and no memory is available
    the 0 is returned for the hw_address.
    
--*/
{
    ULONG i, start = 0, end = 0;
    HW_DESCRIPTOR_PHYSICAL_ADDRESS hw_address = 0;

    STARTPROC("Gpb+");

    ASSERT_ENDPOINT(Endpoint);
    //
    // Offset is the start position in the transfer
    // buffer of the packet we must prepare.
    //
    LOGENTRY(LOG_MISC, 'GPBx', UrbWork,
             UrbWork->NumberOfLogicalAddresses,  
             0);    
            
    for (i=0; i< UrbWork->NumberOfLogicalAddresses; i++) {
    
        // first find the base logical address associated with 
        // this packet

        LOGENTRY(LOG_MISC, 'GPBf', &UrbWork->LogicalAddressList[i],
            Offset,  
            UrbWork->LogicalAddressList[i].Length);    
       
        start = end;
        end += UrbWork->LogicalAddressList[i].Length;
        if (Offset < end) {
            //
            // found the logical address range that this packet 
            // starts in.
            //
            LOGENTRY(LOG_MISC, 'GPBm', end, PacketSize, Offset);  
            
            if (Offset + PacketSize <= end) {
                //
                // if the whole packet fits within the 
                // region associated with this logical 
                // address then we are OK -- just return the
                // physical address.
                //

                hw_address = 
                    UrbWork->LogicalAddressList[i].LogicalAddress +     
                        Offset - start;                        

                UHCD_ASSERT(UrbWork->LogicalAddressList[i].PacketMemoryDescriptor == NULL);
            } else {

                //
                // packet crosses page boundry, get one of our
                // packet buffers
                //
                LOGENTRY(LOG_MISC, 'PAK!', 0, Offset, PacketSize);

                UrbWork->LogicalAddressList[i].PacketMemoryDescriptor = 
                    UHCD_AllocateCommonBuffer(DeviceObject,
                                              Endpoint->MaxPacketSize);  
                                             
                if (UrbWork->LogicalAddressList[i].PacketMemoryDescriptor) {
                    // if this is an out then we need to copy the data in
                    // to the packet buffer  
                    UrbWork->LogicalAddressList[i].PacketOffset = Offset;
                    if (DATA_DIRECTION_OUT(Urb)) {
                        //TEST_TRAP();
                        
                        LOGENTRY(LOG_MISC, 'DBpk', UrbWork->LogicalAddressList[i].PacketMemoryDescriptor->VirtualAddress,
                                         (PUCHAR)UrbWork->SystemAddressForMdl + 
                                             UrbWork->LogicalAddressList[i].PacketOffset,
                                         PacketSize);  
                        RtlCopyMemory(UrbWork->LogicalAddressList[i].PacketMemoryDescriptor->VirtualAddress,
                                      (PUCHAR) UrbWork->SystemAddressForMdl + 
                                        UrbWork->LogicalAddressList[i].PacketOffset,
                                      PacketSize);                       
                    }
                    hw_address = 
                        UrbWork->LogicalAddressList[i].PacketMemoryDescriptor->LogicalAddress;                       
                } 
#if DBG                
                  else {
                    // NOTE:
                    // failure here should cause the transfer to be completed with error, 
                    // we will return 0 for the hw_address;
                    TEST_TRAP();
                }                    
#endif //DBG                                         
            }
            break;
        }
    }

    UHCD_ASSERT(i < UrbWork->NumberOfLogicalAddresses);

    LOGENTRY(LOG_MISC, 'GPB0', hw_address, 0, 0);

    ENDPROC("Gpb-");
    
    return hw_address;
}


VOID
UHCD_FixupDataToggle(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    Given a TDList that is already set up, fxuo the data toggle 
    based of the current EP data toggle

Arguments:

    DeviceObject - pointer to a device object.
    
    Endpoint - Endpoint associated with this Urb.

    Urb - pointer to URB Request Packet for this transfer.

Return Value:

    Usbd status code.

--*/
{
//    PDEVICE_EXTENSION deviceExtension;
    SHORT i, slot, start;
    PUHCD_TD_LIST tDList;
    PHCD_EXTENSION urbWork = HCD_AREA(Urb).HcdExtension;
    
    UHCD_KdPrint((2, "'enter UHCD_FixupDataToggle\n"));

    ASSERT_ENDPOINT(Endpoint);
    UHCD_ASSERT(Endpoint == HCD_AREA(Urb).HcdEndpoint);
    UHCD_ASSERT(!(urbWork->Flags & UHCD_TOGGLE_READY));
    
       // do some general init stuff first,
    // TDs form a circular list
    slot = urbWork->Slot;
    tDList = Endpoint->SlotTDList[slot];

    //UHCD_ASSERT(urbWork->Flags & UHCD_TRANSFER_DEFER);
    UHCD_ASSERT(urbWork->Flags & UHCD_TRANSFER_INITIALIZED);

    start = i = Endpoint->CurrentTDIdx[slot]; 
    do {

        tDList->TDs[i].RetryToggle = Endpoint->DataToggle;
        Endpoint->DataToggle ^=1;

        if (i == Endpoint->LastTDInTransferIdx[slot]) {
            // if this is the last TD the we are done 
            break;
        }

        i = NEXT_TD(i, Endpoint);                    
    } while (i != start); 

    urbWork->Flags |= UHCD_TOGGLE_READY;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\bandwdth.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    bandwdth.c

Abstract:

    This module contains code to calculate 
    bandwidth usage.

Environment:

    kernel mode only

Notes:

Revision History:

    2-15-95 : created

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"


VOID
UHCD_InitBandwidthTable(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initialize our array that tracks the bw in use.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    None.
    
--*/
{
    ULONG i;
    PDEVICE_EXTENSION deviceExtension;     

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Note: BwTable stores bytes per frame
    //

    for (i=0; i<MAX_INTERVAL; i++) {
        //
        // max bytes per frame - bw reaerved for bulk and control
        //
        deviceExtension->BwTable[i] = 
            UHCD_TOTAL_USB_BW - UHCD_BULK_CONTROL_BW;  
    }
}

#if DBG
    ULONG UHCD_PnpTest = 0;
#endif

BOOLEAN
UHCD_ManageBandwidth(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN ULONG Offset,
    IN BOOLEAN AllocateFlag
    )
/*++

Routine Description:

    Calculate bandwidth required to open an endpoint
    with the given input characteristics.

Arguments:

    DeviceObject - pointer to a device object

    Offset - offset in to table to start, allows load balancing
            for interrupt endpoints.

    Interval - interval for endoint (1 for iso).            

    AllocateFlag - TRUE if we are requesting BW, false if we 
            are releasing it.               

Return Value:

    TRUE if enough bandwidth available open the 
    endpoint.

--*/
{
    ULONG i;
    PDEVICE_EXTENSION deviceExtension;   
    BOOLEAN ok=TRUE;
    ULONG interval, need;

    ASSERT_ENDPOINT(Endpoint);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //UHCD_KdPrint((2, "BWTable = %x\n", &deviceExtension->BwTable[0]));
    //UHCD_KdBreak();
    
    //
    // claculate what we'll need based on endpoint
    // type and max packet size
    //
    
    need = 
        USBD_CalculateUsbBandwidth(Endpoint->MaxPacketSize,
                                   Endpoint->Type,
                                   (BOOLEAN) (Endpoint->EndpointFlags & EPFLAG_LOWSPEED)); 
    
    interval = Endpoint->Interval;
    
    LOGENTRY(LOG_MISC, 'aBW1', 
              interval, 
              Offset, 
              need);

    UHCD_ASSERT(interval<=MAX_INTERVAL);
    UHCD_ASSERT(Offset<interval);
    UHCD_ASSERT(MAX_INTERVAL % interval == 0);

    if (AllocateFlag) {
        for (i=Offset; i<MAX_INTERVAL; i+=interval) {              
            if (deviceExtension->BwTable[i] < need) {
                ok = FALSE;
                break;
            }
        }
    }

#if DBG
    if (UHCD_PnpTest == 1) {
        ok = FALSE;    
    }
#endif
    
    if (ok) {
    
        //
        // there is enough, go ahead and allocate
        //

        Endpoint->Offset = (USHORT) Offset;
        
        for (i=Offset; i<MAX_INTERVAL; i+=interval) {
        
            if (AllocateFlag) {
                deviceExtension->BwTable[i] -= need;
            } else {
                deviceExtension->BwTable[i] += need;
            }

            UHCD_ASSERT(deviceExtension->BwTable[i] <= 
                UHCD_TOTAL_USB_BW - UHCD_BULK_CONTROL_BW);
        }        
    }

    LOGENTRY(LOG_MISC, 'aBW2', 
              AllocateFlag, 
              ok, 
              &deviceExtension->BwTable[0]);

#ifdef MAX_DEBUG    
    if (!ok) {
        UHCD_KdBreak((2, "'no bandwidth\n"));  
    }
#endif    
            
    return ok;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\control.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    control.c

Abstract:

    The module contains functions specific to control type 
    transactions on the USB.

Environment:

    kernel mode only

Notes:

Revision History:

    11-01-95 : created

--*/
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"


// BUBUG inline?
VOID
UHCD_PrepareStatusPacket(
    IN PHW_TRANSFER_DESCRIPTOR TransferDescriptor,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    Prepare the status phase for an control transfer.

Arguments:

    TransferDescriptor - TransferDescriptor for status phase.

    Endpoint - endpoint associated with this transfer.    

    Urb - pointer to URB Request for control transfer.

Return Value:

    None.

--*/
{
    PHCD_EXTENSION urbWork = HCD_AREA(Urb).HcdExtension;
    
    ASSERT_ENDPOINT(Endpoint);    

    // since we may be using a recycled TD, we will re-init now
    UHCD_InitializeAsyncTD(Endpoint, TransferDescriptor);

    //
    // tracks the nth packet in this transfer
    //
    
    urbWork->PacketsProcessed++;

    // Status phase is a null packet
    // in the opposite direction
    
    TransferDescriptor->InterruptOnComplete = 1;

    //data toggle must be 1 for status phase
    Endpoint->DataToggle = 1;
    TransferDescriptor->RetryToggle = Endpoint->DataToggle;
    Endpoint->DataToggle ^=1;

#if DBG
    // bugbug use this field to detect if we 
    // process the same TD twice
    TransferDescriptor->Frame = 0;
#endif    

    TransferDescriptor->MaxLength = NULL_PACKET_LENGTH;

    if (DATA_DIRECTION_IN(Urb)) 
        TransferDescriptor->PID = USB_OUT_PID;
    else 
        TransferDescriptor->PID = USB_IN_PID;            

    //
    // NOTE: 
    // for status phase -- set the t bit in the HW_Link
    // field, this is done by the caller.
    //

    LOG_TD('stTD', TransferDescriptor);

    UHCD_KdPrint((2, "'**TD for STATUS PHASE\n"));
    UHCD_Debug_DumpTD(TransferDescriptor);

}


// BUBUG inline?
VOID
UHCD_PrepareSetupPacket(
    IN PHW_TRANSFER_DESCRIPTOR TransferDescriptor,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB    Urb
    )
/*++

Routine Description:

    Prepare the status phase for an control transfer.

Arguments:

    TransferDescriptor - TransferDescriptor for setup phase.

    Endpoint - endpoint associated with this transfer.    

    Urb - pointer to URB Request for control transfer.

Return Value:

    None.

--*/
{
    PUHCD_HARDWARE_DESCRIPTOR_LIST hwDescriptorList;
    PHCD_EXTENSION urbWork = HCD_AREA(Urb).HcdExtension;

    ASSERT_ENDPOINT(Endpoint);    

    //
    // tracks the nth packet in this transfer
    //
    
    urbWork->PacketsProcessed++;

    // BUGBUG only one request for control
    UHCD_ASSERT(Endpoint->MaxRequests == 1);
    hwDescriptorList = Endpoint->HardwareDescriptorList[0];    
    // since we may be using a recycled TD, we will re-init now
    UHCD_InitializeAsyncTD(Endpoint, TransferDescriptor);

    //data toggle must be 0 for setup
    //BUGBUG reset data toggle in ENDPOINT
    Endpoint->DataToggle = 0;
    TransferDescriptor->RetryToggle = Endpoint->DataToggle;
    Endpoint->DataToggle ^=1;
    
    TransferDescriptor->PID = USB_SETUP_PID;

    TransferDescriptor->MaxLength = 
        UHCD_SYSTEM_TO_USB_BUFFER_LENGTH(sizeof(Urb->HcdUrbCommonTransfer.Extension.u.SetupPacket));

    // Copy the setup packet in to the scratch buffer
    RtlCopyMemory(hwDescriptorList->ScratchBufferVirtualAddress, 
                  &Urb->HcdUrbCommonTransfer.Extension.u.SetupPacket[0], 
                  sizeof(Urb->HcdUrbCommonTransfer.Extension.u.SetupPacket));
    
    TransferDescriptor->PacketBuffer = hwDescriptorList->ScratchBufferLogicalAddress;

    LOG_TD('SuTD', TransferDescriptor);

    UHCD_KdPrint((2, "'**TD for setup packet\n"));
    UHCD_Debug_DumpTD(TransferDescriptor);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\dbg.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
:ts=4

Module Name:

    dbg.h

Abstract:

    debug macros

Environment:

    Kernel & user mode

Revision History:

    10-27-95 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__


//
// Structure signatures
//

#define UHCD_TAG          0x44434855        //"UHCD"

#define SIG_QH            0x68714851        //"QHqh" signature for queue head
#define SIG_TD            0x64744454        //"TDtd" signature for transfer descriptor
#define SIG_EP            0x70655045        //"EPep" signature for endpoint
#define SIG_MD            0x646D444D        //"MDmd" signature for memory descriptor
#define SIG_RH            0x68724852        //"RHrh" signature for root hub

#define UHCD_FREE_TAG     0xFFFFFFFF        //"" signature free memory


#define LOG_MISC          0x00000001        //debug log entries
#define LOG_PROFILE       0x00000002        //profile log entries
#define LOG_ISO           0x00000004
#define LOG_IO            0x00000008        // Log all I/O access

//
// Assert Macros
//

#if DBG

//
// Assert Macros
//
// We define our own assert function because ntkern will
// not stop in the debugger on assert failures in our own
// code.
//
VOID
UHCD_Assert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define UHCD_ASSERT( exp ) \
    if (!(exp)) \
        UHCD_Assert( #exp, __FILE__, __LINE__, NULL )

#define UHCD_ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        UHCD_Assert( #exp, __FILE__, __LINE__, msg )


#define ASSERT_TRANFSER_DESCRIPTOR(td)   UHCD_ASSERT(td->Sig == SIG_TD)
#define ASSERT_QUEUE_HEAD(qh)            UHCD_ASSERT(qh->Sig == SIG_QH)
#define ASSERT_ENDPOINT(ep)              UHCD_ASSERT(ep->Sig == SIG_EP)
#define ASSERT_MD(md)                    UHCD_ASSERT(md->Sig == SIG_MD)
#define ASSERT_RH(rh)                    UHCD_ASSERT(rh->Sig == SIG_RH)

VOID
UHCD_CheckSystemBuffer(
    IN PUCHAR VirtualAddress,
    IN ULONG Length
    );

//#define ASSERT_BUFFER(buf, len)            UHCD_CheckSystemBuffer(buf, len)
#define ASSERT_BUFFER(buf, len)

//
// Heap Macros for debug heap services
//

extern LONG UHCD_TotalAllocatedHeapSpace;

#define GETHEAP(pooltype, numbytes)        UHCD_Debug_GetHeap(pooltype, numbytes, UHCD_TAG, &UHCD_TotalAllocatedHeapSpace)

#define RETHEAP(p)                         UHCD_Debug_RetHeap(p, UHCD_TAG, &UHCD_TotalAllocatedHeapSpace);

VOID
UHCD_PrintPnPMessage(
    PUCHAR Label,
    UCHAR MinorFunction
    );

VOID
UHCD_PrintPowerMessage(
    PUCHAR Label,
    UCHAR MinorFunction
    );

ULONG
_cdecl
UHCD_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

#define   UHCD_KdPrint(_x_) UHCD_KdPrintX _x_

//
// ** DEBUG TRAPS
//
// Ntkern currently implements DebugBreak with a global int 3,
// we really would like the int 3 in our own code.

// TEST_TRAP() is a code coverage trap these should be removed
// if you are able to 'g' past them OK
//
// KdTrap() breaks in the debugger on the debugger build
// these indicate bugs in client drivers or fatal error
// conditions that should be debugged. also used to mark
// code for features not implemented yet.
//
// KdBreak() breaks in the debugger when in MAX_DEBUG mode
// ie debug trace info is turned on, these are intended to help
// debug drivers devices and special conditions on the
// bus.

#ifdef NTKERN
#pragma message ("warning: ntkern debug enabled")
#define TRAP() _asm { int 3 }
#define TEST_TRAP() _asm { int 3 }
#else
#define TRAP() DbgBreakPoint()
#define TEST_TRAP() { \
    DbgPrint ("'UHCD.SYS: Code Coverage %s, %d\n", __FILE__, __LINE__);\
    TRAP(); \
    }
#endif

#ifdef MAX_DEBUG
#define UHCD_KdBreak(_s_)   {UHCD_KdPrintX _s_ ; TRAP();}
#else
//#define UHCD_KdBreak(_s_)   {DbgPrint("'UHCD: "); DbgPrint _s_; }
#define UHCD_KdBreak(_s_)
#endif

#define UHCD_KdTrap(_s_) {DbgPrint("UHCD: "); DbgPrint _s_; TRAP();}

VOID
UHCD_Debug_DumpTD(
    IN  struct _HW_TRANSFER_DESCRIPTOR *Transfer
    );

PVOID
UHCD_Debug_GetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    );

VOID
UHCD_Debug_RetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    );

#define UHCD_ASSERT_QSTOPPED(devobj, ep, qtd)

#ifdef PROFILE2

#define DEBUG_LOG

#define STARTPROC(tag)  LONG start, stop; \
                        LONG delta; \
                        start = ; \
                        LOGENTRY(LOG_PROFILE, tag, start, 0, 0);

#define ENDPROC(tag)  stop = ; \
                      delta = stop - start; \
                      LOGENTRY(LOG_PROFILE, tag, stop, start, delta);

#else

#define STARTPROC(tag)
#define ENDPROC(tag)

#endif /* PROFILE */

#else /* NOT DBG */

#define UHCD_KdTrap(_s_)

#define UHCD_KdBreak(_s_)

#define ASSERT_TRANFSER_DESCRIPTOR(td)
#define ASSERT_QUEUE_HEAD(qh)
#define ASSERT_ENDPOINT(ep)
#define ASSERT_MD(md)
#define ASSERT_RH(rh)

#define UHCD_KdPrint(_x_)

#define TRAP()

#define TEST_TRAP();

#define UHCD_ASSERT_QSTOPPED(devobj, ep, qtd)

#define UHCD_ASSERT( exp )

#define ASSERT_BUFFER(buf, len)

#define UHCD_Debug_DumpTD(transfer)

#define GETHEAP(pooltype, numbytes)        ExAllocatePoolWithTag(pooltype, numbytes, UHCD_TAG)

#define RETHEAP(p)                         ExFreePool(p);

#define STARTPROC(tag)

#define ENDPROC(tag)

#define UHCD_PrintPnPMessage(Label, MinorFunction)

#define UHCD_PrintPowerMessage(Label, MinorFunction)

#endif /* DBG */


#ifdef DEBUG_LOG
VOID
UHCD_LogTD(
    IN ULONG s,
    IN PULONG p
    );

#define LOGENTRY(mask, sig, info1, info2, info3)     \
    UHCD_Debug_LogEntry(mask, sig, (ULONG_PTR)info1, \
                        (ULONG_PTR)info2,            \
                        (ULONG_PTR)info3)

#define LOG_TD(sig, td)    UHCD_LogTD(sig, (PULONG)td)

#ifdef DEBUG_LOG_IO

#define WRITE_PORT_USHORT(P, V) UhcdLogIoUshort((P), (V), 1)
#define WRITE_PORT_ULONG(P, V) UhcdLogIoUlong((P), (V), 1)
#define WRITE_PORT_UCHAR(P, V) UhcdLogIoUchar((P), (V), 1)

#define READ_PORT_USHORT(P) UhcdLogIoUshort((P), 0, 0)
#define READ_PORT_ULONG(P) UhcdLogIoUlong((P), 0, 0)
#define READ_PORT_UCHAR(P) UhcdLogIoUchar((P), 0, 0)

USHORT
UhcdLogIoUshort(PUSHORT Port, USHORT Val, BOOLEAN Write);

ULONG
UhcdLogIoUlong(PULONG Port, ULONG Val, BOOLEAN Write);

UCHAR
UhcdLogIoUchar(PUCHAR Port, UCHAR Val, BOOLEAN Write);

#endif // DEBUG_LOG_IO

VOID
UHCD_Debug_LogEntry(
    IN ULONG     Mask,
    IN ULONG     Sig,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
    );

VOID
UHCD_LogInit(
    );

VOID
UHCD_LogFree(
    );

#else
#define LOGENTRY(mask, sig, info1, info2, info3)
#define LOG_TD(sig, td)
#endif


#endif /*  __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\dblbuff.c ===
/*++

Copyright (c) 1999 Microsoft Corporation
:ts=4

Module Name:

    dblbuff.c

Abstract:

    The module manages double buffered bulk transactions on USB.

Environment:

    kernel mode only

Notes:

Revision History:

    2-1-99 : created

--*/
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"

#if DBG
extern ULONG UHCD_XferNoise;
#endif

VOID
UHCD_StartNoDMATransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    starts receiving data for the endpoint 

Arguments:

Return Value:

    None.
        
--*/
{
    PUHCD_TD_LIST tDList;
    ULONG i;
    HW_DESCRIPTOR_PHYSICAL_ADDRESS physicalAddress;

    if (Endpoint->EndpointFlags & EPFLAG_NODMA_ON) {
        // already on, bail
        LOGENTRY(LOG_MISC, 'dmaO', Endpoint, 0, 0);
        return;        
    }

    
    
    // current TD is the first TD

    tDList = Endpoint->SlotTDList[0];        
    Endpoint->CurrentTDIdx[0] = 0;

    physicalAddress = Endpoint->NoDMAPhysicalAddress;

    LOGENTRY(LOG_MISC, 'dmG1', Endpoint, physicalAddress, tDList);
    
    for (i=0; i < Endpoint->TDCount; i++) {
        tDList->TDs[i].Endpoint = Endpoint->EndpointAddress;
        tDList->TDs[i].Address = Endpoint->DeviceAddress;        
        tDList->TDs[i].HW_Link = 
            tDList->TDs[(i+1) % Endpoint->TDCount].PhysicalAddress;    
        UHCD_InitializeAsyncTD(Endpoint, &tDList->TDs[i]);
        
        // for now take an interrupt every TD so we can keep up
        tDList->TDs[i].InterruptOnComplete = 1;
        tDList->TDs[i].PID = USB_IN_PID;

        // set data toggle;
        tDList->TDs[i].RetryToggle = Endpoint->DataToggle;
        Endpoint->DataToggle ^=1;

        // buffer length is packet size
        tDList->TDs[i].MaxLength = 
            UHCD_SYSTEM_TO_USB_BUFFER_LENGTH(Endpoint->MaxPacketSize);   
        
        // point TDs at our NoDMA buffer;
        tDList->TDs[i].PacketBuffer = 
            physicalAddress + 64*i;

        tDList->TDs[i].ShortPacketDetect = 0;

        UHCD_KdPrint((2, "'**TD for BULK DBLBUFF packet (%d)\n", i));
        UHCD_Debug_DumpTD(&tDList->TDs[i]);            
    } 

    // no T bit the controller will stop at the first in-active TD        

    // mark the endpoint as started
    SET_EPFLAG(Endpoint, EPFLAG_NODMA_ON);
    LOGENTRY(LOG_MISC, 'dmG2', Endpoint, Endpoint->QueueHead, 0);
   
    // fire up the transfer loop
    // point QH at the first TD
    
    Endpoint->QueueHead->HW_VLink = 
                        Endpoint->TDList->TDs[0].PhysicalAddress;
}


VOID
UHCD_StopNoDMATransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    stops receiving data for the endpoint

Arguments:

Return Value:

    None.
        
--*/
{
    CLR_EPFLAG(Endpoint, EPFLAG_NODMA_ON);

    LOGENTRY(LOG_MISC, 'dmaX', Endpoint, Endpoint->QueueHead, 0); 
    UHCD_KdPrint((0, "'** stopping noDMA transfer\n"));

#if DBG
    if (!IsListEmpty(&Endpoint->PendingTransferList)) {
        UHCD_KdPrint((0, "'** stopping noDMA w/ pending transfers\n"));
    }
    if(Endpoint->ActiveTransfers[0] != NULL) {
        UHCD_KdPrint((0, "'** stopping noDMA w/ active transfers\n"));
    }

#endif    

    // fixup the TDs point the QH at the first TD
    // and mark it inactive

    // note that by the time the ep is actually closed more
    // than one frame will have elapsed so it will be safe to 
    // remove the QH

    // preserve the data toglge in case the ep gets another 
    // transfer that starts it again
    
    Endpoint->DataToggle = 
        Endpoint->LastPacketDataToggle;

    Endpoint->TDList->TDs[0].Active = 0;
    Endpoint->QueueHead->HW_VLink = 
        Endpoint->TDList->TDs[0].PhysicalAddress;

    // so that only startdmatransfer can activate it
    SET_T_BIT(Endpoint->QueueHead->HW_VLink);        

#if 0
    // DEBUG ONLY
    // see if we have any unclaimed data in the buffer
    {
    LONG i, cnt = 0;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor;
    
    i = Endpoint->CurrentTDIdx[0];
    for (;;) {

        transferDescriptor = &Endpoint->TDList->TDs[i];
        
        LOGENTRY(LOG_MISC, 'CKtd', i, transferDescriptor, 
            Endpoint->CurrentTDIdx[0]);
        
        //
        // Did this TD complete?
        //
        
        if (transferDescriptor->Active == 0) {
            cnt++;
            i = NEXT_TD(i, Endpoint);
        } else {
            break;
        }

        // see if all TDs were processed
        if (i == Endpoint->CurrentTDIdx[0]) {
            break;
        }
    }

    if (cnt) {
        UHCD_KdPrint((0, "'** abort with %d unprocessed TDs\n", cnt));
        TEST_TRAP();
    }
    
    }        
#endif    
    
}


#define RECYCLE_TD(t) \
                (t)->ActualLength = 0;\
                (t)->Active = 1;\
                (t)->StatusField = 0; \
                (t)->ErrorCounter = 3;

BOOLEAN
UHCD_ProcessNoDMATransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

Arguments:

Return Value:

    True if current active transfer is complete
            
--*/
{
    BOOLEAN complete = FALSE;
    USHORT i, thisTD;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    PUCHAR tdBuffer;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor;
    PDEVICE_EXTENSION deviceExtension; 
    ULONG remain, length;
    PHCD_EXTENSION urbWork = HCD_AREA(Urb).HcdExtension;
    BOOLEAN processed = FALSE;
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;    

    // see if this transfer has been canceled
    if (Urb->HcdUrbCommonTransfer.Status == UHCD_STATUS_PENDING_XXX) {
        
        usbdStatus = USBD_STATUS_CANCELED;
        LOGENTRY(LOG_MISC, 'TCAN', Endpoint, Urb, usbdStatus); 
        complete = TRUE;
        goto UHCD_ProcessNoDMATransfer_Done;
    }
    
    // walk through the TD list starting from currentTDIdx 

    // stop as soon as:
    //  we fill the active client buffer OR
    //  we find a short packet OR
    //  we find an unprocessed TD

    // Start at the last TD that had not completed
    i = Endpoint->CurrentTDIdx[0];
    for (;;) {

        transferDescriptor = &Endpoint->TDList->TDs[i];
        
        LOGENTRY(LOG_MISC, 'CKtd', i, transferDescriptor, 
            Endpoint->CurrentTDIdx[0]);
        
        //
        // Did this TD complete?
        //
        
        UHCD_KdPrint((2, "'checking DB TD  %x\n", transferDescriptor));
        UHCD_Debug_DumpTD(transferDescriptor); 
        
        if (transferDescriptor->Active == 0) {

            LOG_TD('nACT', (PULONG) transferDescriptor);
            processed = TRUE;

            UHCD_KdPrint((2, "'TD  %x completed\n", transferDescriptor));
            UHCD_Debug_DumpTD(transferDescriptor);

            Endpoint->LastPacketDataToggle = (UCHAR) transferDescriptor->RetryToggle;

            //
            // Yes, TD completed figure out what to do
            //

            if (transferDescriptor->StatusField != 0) {
                // we got an error, map the status code and retire 
                // this transfer

                // if appropriate the caller will halt transfers 
                // on the endpoint

                complete = TRUE;
                
                usbdStatus = UHCD_MapTDError(deviceExtension, transferDescriptor->StatusField,
                    UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(transferDescriptor->ActualLength));
                                    
                LOGENTRY(LOG_MISC, 'Stal', Endpoint, 
                    transferDescriptor->StatusField, usbdStatus); 

                i = NEXT_TD(i, Endpoint);                    
                break;
            }             

            //
            //  No Error, process the TDs data
            //

            // should be an IN 
            UHCD_ASSERT(transferDescriptor->PID == USB_IN_PID);

            // see how much room is left
            remain = Urb->HcdUrbCommonTransfer.TransferBufferLength - 
                        urbWork->BytesTransferred;

            length = 
                UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(transferDescriptor->ActualLength);

            tdBuffer = Endpoint->NoDMABuffer + 64*i;
            
            if (length < remain) {

                LOGENTRY(LOG_MISC, 'lsTD', 0, transferDescriptor, 0);
        
                // copy the data to the client buffer
                RtlCopyMemory((PUCHAR) urbWork->SystemAddressForMdl + 
                                urbWork->BytesTransferred,
                              tdBuffer,
                              length);

                urbWork->BytesTransferred += length;                              
                              
                i = NEXT_TD(i, Endpoint);

                // check for short packet
                // short packets cause the transfer to complete.

                if (length < 
                    Endpoint->MaxPacketSize) {

                    LOGENTRY(LOG_MISC, 'sHRT', 
                          transferDescriptor, 
                          transferDescriptor->ActualLength, 
                          transferDescriptor->MaxLength);
                          
                    complete = TRUE;        

                    break;
                }
                
            } else if (length == remain) {

                LOGENTRY(LOG_MISC, 'eqTD', 0, transferDescriptor, 0);
                
                // this td just fills the client buffer
                RtlCopyMemory((PUCHAR)urbWork->SystemAddressForMdl + 
                                    urbWork->BytesTransferred,
                              tdBuffer,
                              length); 
                urbWork->BytesTransferred += length;
                
                complete = TRUE;            
                i = NEXT_TD(i, Endpoint);

                break;                
                
            } else {
            
                TEST_TRAP();
                // bugbug this is an odd case, not sure how to handle
                // it yet.
                
                // normally two transfers cannot span a single packet
                
            
                // TD data is bigger than space left in client buffer
                // copy what we can
                RtlCopyMemory(urbWork->SystemAddressForMdl,
                              tdBuffer,
                              remain); 
                complete = TRUE;       
                
                // save the rest of the data for the next pass
                
                break;
            }
            
        /* active == 0 */    
        } else {
            // this TD still active, all done
            LOGENTRY(LOG_MISC, 'acBK', Endpoint, transferDescriptor, 0);
            break;
        }

        // see if all TDs were processed
        if (i == Endpoint->CurrentTDIdx[0]) {
            UHCD_ASSERT(processed == TRUE);
            break;
        }

    }   /* for ;; */

    if (processed) {
        // at least one TD completed
        thisTD = Endpoint->CurrentTDIdx[0];

        UHCD_ASSERT(Endpoint->TDList->TDs[thisTD].Active == 0);
        RECYCLE_TD(&Endpoint->TDList->TDs[thisTD]);
        thisTD = NEXT_TD(thisTD, Endpoint);
    
        // set currentTDidx to where we left off
        Endpoint->CurrentTDIdx[0] = i;
        
        // recycle the TDs we processed
        for(;;) {
            if (thisTD == Endpoint->CurrentTDIdx[0]) {
                break;
            }
            UHCD_ASSERT(Endpoint->TDList->TDs[thisTD].Active == 0);
            RECYCLE_TD(&Endpoint->TDList->TDs[thisTD]);
            thisTD = NEXT_TD(thisTD, Endpoint);
        }            
    }            

    UHCD_KdPrint((2, "'check DB TD done\n"));
    
UHCD_ProcessNoDMATransfer_Done:

    if (complete) {
        Urb->HcdUrbCommonTransfer.Status = usbdStatus;
    }        
    
    return complete;
}


NTSTATUS
UHCD_InitializeNoDMAEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Set up a No-DMA style (double buffered endpoint)

Arguments:

Return Value:

    None.
        
--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;  
    ULONG length;

    UHCD_KdPrint((2, "'Init No DMA Endpoint\n"));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    // we always have work
    SET_EPFLAG(Endpoint, EPFLAG_HAVE_WORK);
    
    //
    // first we need a buffer to receive Data, and TDs to 
    // point in to it
    //

    // we should have the max TDs reserved for this endpoint
    UHCD_ASSERT(Endpoint->TDCount == MAX_TDS_PER_ENDPOINT);

    // length will be largest USB packet (64) * the MAX tds per
    // endpoint (ends up being one page on x86)
    
    length = 64 * MAX_TDS_PER_ENDPOINT;
    
    Endpoint->NoDMABuffer = 
        UHCD_Alloc_NoDMA_Buffer(DeviceObject, Endpoint, length);
        
    if (Endpoint->NoDMABuffer == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
        
    return ntStatus;
}


NTSTATUS
UHCD_UnInitializeNoDMAEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Set up a No-DMA style (Dbl buffered endpoint)

Arguments:

Return Value:

    None.
        
--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;  

    LOGENTRY(LOG_MISC, 'unIN', Endpoint, 0, 0);        
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    
    UHCD_ASSERT(!(Endpoint->EndpointFlags & EPFLAG_NODMA_ON));

    if (Endpoint->NoDMABuffer) { 
        UHCD_Free_NoDMA_Buffer(DeviceObject, Endpoint->NoDMABuffer);

        Endpoint->NoDMABuffer = NULL;                               
    }                                

    return STATUS_SUCCESS;
}


VOID
UHCD_EndpointNoDMA_Abort(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Aborts all active and/or pending transfers for a NoDMA endpoint

    Called at DPC level 

Arguments:

Return Value:

    None.
        
--*/
{
    KIRQL irql;
    //BOOLEAN done = FALSE;
    
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    UHCD_ASSERT(Endpoint->EndpointFlags & 
        (EPFLAG_ABORT_PENDING_TRANSFERS | EPFLAG_ABORT_ACTIVE_TRANSFERS));

    if (Endpoint->EndpointFlags & EPFLAG_ABORT_ACTIVE_TRANSFERS) {
    
        PHCD_URB urb;

        urb = Endpoint->ActiveTransfers[0];

        LOGENTRY(LOG_MISC, 'ABac', urb, 0, Endpoint);  

        if (urb) {
            Endpoint->ActiveTransfers[0] = NULL;

            URB_HEADER(urb).Status = USBD_STATUS_CANCELED;  
            UHCD_CompleteIrp(DeviceObject, 
                             HCD_AREA(urb).HcdIrp, 
                             STATUS_CANCELLED,
                             0,
                             urb);

            
            CLR_EPFLAG(Endpoint, 
                       EPFLAG_ABORT_ACTIVE_TRANSFERS);
        }
    }

    if (Endpoint->EndpointFlags & EPFLAG_ABORT_PENDING_TRANSFERS) {

        BOOLEAN pendingTransfers = TRUE;
        
        LOGENTRY(LOG_MISC, 'ABpd', Endpoint, 0, 0);  
        
        // dequeue all of our pending requests an complete them with status 
        // canceled
        
        while (pendingTransfers) {
        
            PHCD_URB urb;
            PLIST_ENTRY listEntry;
                
            LOCK_ENDPOINT_PENDING_LIST(Endpoint, irql, 'lck3');

            if (IsListEmpty(&Endpoint->PendingTransferList)) {
            
                pendingTransfers = FALSE;

                // clear the abort flag
                CLR_EPFLAG(Endpoint, 
                           EPFLAG_ABORT_PENDING_TRANSFERS);
                
                UNLOCK_ENDPOINT_PENDING_LIST(Endpoint, irql, 'ulk3');
                
            } else {
            
                listEntry = RemoveHeadList(&Endpoint->PendingTransferList);
                urb = (PHCD_URB) CONTAINING_RECORD(
                    listEntry,
                    struct _URB_HCD_COMMON_TRANSFER, 
                    hca.HcdListEntry);

                LOGENTRY(LOG_MISC, 'DQXF', urb, 0, 0);  

                UNLOCK_ENDPOINT_PENDING_LIST(Endpoint, irql, 'ulk3');

                URB_HEADER(urb).Status = USBD_STATUS_CANCELED;  
                UHCD_CompleteIrp(DeviceObject, 
                                 HCD_AREA(urb).HcdIrp, 
                                 STATUS_CANCELLED,
                                 0,
                                 urb);

                // complete this transfer
            }
            
         } /* while */
    }        
}

VOID
UHCD_EndpointNoDMAWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Main worker function for an endpoint that does not require DMA.

    Note: We should never have transfers in the active list for one 
    of these endooints.

    Called at DPC level 

Arguments:

Return Value:

    None.
        
--*/
{
    ULONG slot;
    BOOLEAN complete;
    KIRQL irql;
    //BOOLEAN done = FALSE;
    
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    //UHCD_KdPrint((2, "'enter UHCD_EndpointNoDMAWorker\n"));

    //
    // some asserts
    //

    // max request should always be one -- we will manage with just one
    // set of TDs
    UHCD_ASSERT(Endpoint->MaxRequests == 1);
    slot = 0;

    if (Endpoint->EndpointFlags & 
        (EPFLAG_ABORT_PENDING_TRANSFERS | EPFLAG_ABORT_ACTIVE_TRANSFERS)) {
        // client has requested abort
        UHCD_KdPrint((0, "'abort no DMA ep\n"));
        UHCD_EndpointNoDMA_Abort(DeviceObject,
                                 Endpoint);

        goto UHCD_EndpointNoDMAWorker_Done;
    }                            

    do { 
      
        // check our pending request list
        
        if (IsListEmpty(&Endpoint->PendingTransferList) && 
            Endpoint->ActiveTransfers[slot] == NULL) {
            // client list is empty, 
            // no more to do for now                       
            LOGENTRY(LOG_MISC, 'ndMT', Endpoint, 0, 0);
            break;
            
        } else {
            USBD_STATUS usbdStatus;
            PIRP irp;
            PHCD_URB urb;
            PHCD_EXTENSION urbWork;

            // no active transfer 
            // dequeue the next pending one for processing

            // if the endpoint is not stalled, start up the DMA
            // loop if not running on the first transfer
            
            if (!(Endpoint->EndpointFlags & EPFLAG_HOST_HALTED)) {
                LOGENTRY(LOG_MISC, 'ndST', Endpoint, 0, 0);
                UHCD_StartNoDMATransfer(DeviceObject,
                                        Endpoint);
            }
            
            if (Endpoint->ActiveTransfers[slot] == NULL) {
            
                PLIST_ENTRY listEntry;

                // dequeue the next transfer
                LOCK_ENDPOINT_PENDING_LIST(Endpoint, irql, 'lck6');
                
                UHCD_ASSERT(!IsListEmpty(&Endpoint->PendingTransferList));
                
                
                listEntry = RemoveHeadList(&Endpoint->PendingTransferList);
                urb = (PHCD_URB) CONTAINING_RECORD(
                    listEntry,
                    struct _URB_HCD_COMMON_TRANSFER, 
                    hca.HcdListEntry);

                LOGENTRY(LOG_MISC, 'ndDQ', Endpoint, urb, 0);                        
                UHCD_ASSERT(urb);
                
                UNLOCK_ENDPOINT_PENDING_LIST(Endpoint, irql, 'ulk6');
                 
                urbWork = HCD_AREA(urb).HcdExtension;
                UHCD_ASSERT(urbWork);

//#if DBG
//                if (UHCD_XferNoise) {
//                    UHCD_KdPrint((0, "'db xfer len req =%d\n", urb->HcdUrbCommonTransfer.TransferBufferLength));
//                }                    
//#endif                
                
                // init the work area
                // note: this area is zeroed
                if (urb->HcdUrbCommonTransfer.TransferBufferLength) {
                    PMDL mdl;
                    
                    mdl = urb->HcdUrbCommonTransfer.TransferBufferMDL;
                    if (!(mdl->MdlFlags & 
                         (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL))) {
                        urbWork->Flags |= UHCD_MAPPED_LOCKED_PAGES;             
                    }            
    
                    urbWork->SystemAddressForMdl = 
                        MmGetSystemAddressForMdl(mdl);
                                        
                    LOGENTRY(LOG_MISC, 'sMDL', 
                        Endpoint, urb, urbWork->SystemAddressForMdl);    
                     
                } else {
                    urbWork->SystemAddressForMdl = NULL;
                    TEST_TRAP();
                }
                urbWork->Flags |= UHCD_TRANSFER_ACTIVE;
                
                Endpoint->ActiveTransfers[slot] = urb;

            } 

            //
            // so now we have a client transfer in the active slot
            //
            
            UHCD_ASSERT(Endpoint->ActiveTransfers[slot] != NULL);
            urb = Endpoint->ActiveTransfers[slot];
            irp = HCD_AREA(urb).HcdIrp;
            UHCD_ASSERT(irp);
            urbWork = HCD_AREA(urb).HcdExtension;

            LOGENTRY(LOG_MISC, 'ndPR',  Endpoint, urb, 0);
            complete = UHCD_ProcessNoDMATransfer(DeviceObject,
                                                 Endpoint,
                                                 urb);

            if (complete) {            

                usbdStatus = urb->HcdUrbCommonTransfer.Status;

                // active transfer is complete
                Endpoint->ActiveTransfers[slot] = NULL;
                
                if (USBD_ERROR(usbdStatus)) {

                    if (USBD_HALTED(usbdStatus)) {
                        //
                        // error code indicates a condition that should halt
                        // the endpoint.
                        //
                        // check the endpoint state bit, if the endpoint 
                        // is marked for NO_HALT then clear the halt bit
                        // and proceed to cancel this transfer.

                        if (Endpoint->EndpointFlags & EPFLAG_NO_HALT) {
                            //
                            // clear the halt bit on the usbdStatus code
                            //
                            usbdStatus = USBD_STATUS(usbdStatus) | USBD_STATUS_ERROR;
                        } else {
                            //
                            // mark the endpoint as halted, when the client
                            // sends a reset we'll start processing with the
                            // next queued transfer.
                            //
                            SET_EPFLAG(Endpoint, EPFLAG_HOST_HALTED);
                            LOGENTRY(LOG_MISC, 'Hhlt', Endpoint, 0, 0);

                            // stop streaming from the endpoint, 
                            // it should be NAKing anyway
                            UHCD_StopNoDMATransfer(DeviceObject,
                                                   Endpoint);
                        }                    
                    }                
                    
                    //
                    // complete the original request
                    // 

                    UHCD_ASSERT(irp != NULL);
                    UHCD_CompleteIrp(DeviceObject, 
                                     irp, 
                                     STATUS_SUCCESS,
                                     0,
                                     urb);  

                    if (Endpoint->EndpointFlags & EPFLAG_HOST_HALTED) {
                    
                        //
                        // if the endpoint is halted then stop the stream now
                        //
                        
                        UHCD_StopNoDMATransfer(DeviceObject,
                                               Endpoint);
                        break;
                    }                
                } else {
                    // xfer completed with success
                    urb->HcdUrbCommonTransfer.Status = usbdStatus;
                    urb->HcdUrbCommonTransfer.TransferBufferLength = 
                        urbWork->BytesTransferred;                        

//#if DBG
//                    if (UHCD_XferNoise) {
//                        UHCD_KdPrint((0, "'xfer len cpt =%d\n", 
//                            urb->HcdUrbCommonTransfer.TransferBufferLength));
//                    }                            
//#endif                        
                        
                    UHCD_ASSERT(irp != NULL);
                    UHCD_CompleteIrp(DeviceObject, 
                                     irp, 
                                     STATUS_SUCCESS,
                                     0,
                                     urb);  
                }
            }  /* xfer complete */  
        }            
        // cuurent transfer completed, grab the next one and process it

    } while (complete);

UHCD_EndpointNoDMAWorker_Done:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\fastiso.c ===
/*++

Copyright (c) 1999 Microsoft Corporation
:ts=4

Module Name:

    fastiso.c

Abstract:

    The module manages double buffered bulk transactions on USB.

Environment:

    kernel mode only

Notes:

Revision History:

    2-1-99 : created

--*/
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"


BOOLEAN
UHCD_InitFastIsoTDs(
    IN PVOID Context
    )
/*++

Routine Description:

    Intialize our frame list, ie put our TDs phys addresses in the list,
    link our TDs to the current phys entry in the virtual list copy.

    Make a copy of the virtual frame list and copy our list
    to the virtual list copy.
    this will cause the ISR to update the schedule with our iso TDs
    when it removes other iso TDs.

Arguments:

   Context - DeviceData for this USB controller.

Return Value:

   TRUE

--*/
{
    PUHCD_ENDPOINT endpoint;
    PFAST_ISO_DATA fastIsoData;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor;
    ULONG i;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;

    endpoint = Context;
    ASSERT_ENDPOINT(endpoint);
    fastIsoData = &endpoint->FastIsoData;
    deviceObject = fastIsoData->DeviceObject;

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;

    UHCD_KdPrint((2, "'Init Fast ISO - FrameListCopyVirtualAddress %x\n",
        deviceExtension->FrameListCopyVirtualAddress));


    // intialize our iso TDs, mark them not active
    transferDescriptor =
        (PHW_TRANSFER_DESCRIPTOR) fastIsoData->IsoTDListVa;

    for (i=0; i < FRAME_LIST_SIZE ;i++) {

        // link out TD to what is in the copy
        transferDescriptor->HW_Link =
            *( ((PULONG) (deviceExtension->FrameListCopyVirtualAddress) + i));

        // update copy to point to our TD
        *( ((PULONG) (deviceExtension->FrameListCopyVirtualAddress) + i)) =
            transferDescriptor->PhysicalAddress;

        transferDescriptor++;

    }

    return TRUE;
}


BOOLEAN
UHCD_UnInitFastIso(
    IN PVOID Context
    )
/*++

Routine Description:

Arguments:

   Context - DeviceData for this USB controller.

Return Value:

   TRUE

--*/
{
    PUHCD_ENDPOINT endpoint;
    PFAST_ISO_DATA fastIsoData;
    ULONG i;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;

    endpoint = Context;
    ASSERT_ENDPOINT(endpoint);
    fastIsoData = &endpoint->FastIsoData;
    deviceObject = fastIsoData->DeviceObject;

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;

    for (i=0; i < FRAME_LIST_SIZE ;i++) {

        PHW_TRANSFER_DESCRIPTOR transferDescriptor;

        transferDescriptor =  (PHW_TRANSFER_DESCRIPTOR)
            (fastIsoData->IsoTDListVa + (i*32));

        // remove our TD from the Virtual Frame list copy

        // if we are the first td in the copy then we just need to
        // update the copy to point to the next link
        if (*( ((PULONG) (deviceExtension->FrameListCopyVirtualAddress) + i) )
                == transferDescriptor->PhysicalAddress) {
            *( ((PULONG) (deviceExtension->FrameListCopyVirtualAddress) + i) ) =
                transferDescriptor->HW_Link;
        } else {
            // not the first TD ie we have >one fast iso endpoint
            TEST_TRAP();

            // we need to find the precious TD and link it to the next
        }
    }

    return TRUE;
}


NTSTATUS
UHCD_InitializeFastIsoEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Set up a No-DMA style (double buffered endpoint) for ISO

    This is the init code for the endpoint called at PASSIVE_LEVEL

Arguments:

Return Value:

    None.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PFAST_ISO_DATA fastIsoData;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor;
    ULONG phys, i, length;

    UHCD_KdPrint((1, "'Initializing Fast ISO endpoint\n"));
    UHCD_KdPrint((2, "'Init Fast ISO Endpoint\n"));
    UHCD_KdPrint((2, "'Max Packet = %d\n", Endpoint->MaxPacketSize));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    fastIsoData = &Endpoint->FastIsoData;
    fastIsoData->FastIsoFrameList = NULL;
    fastIsoData->DeviceObject = DeviceObject;

    Endpoint->NoDMABuffer = NULL;

    if ( Endpoint->MaxPacketSize == 0) {
        UHCD_KdPrint((2, "'Init Fast ISO Endpoint - zero MP\n"));
        TEST_TRAP();
        return STATUS_SUCCESS;
    }

    // allocate our Iso FrameList
    // this is a list that contains the phys addresses of
    // our persistent ISO TDs
    fastIsoData->FastIsoFrameList =
        GETHEAP(NonPagedPool, sizeof(ULONG)*FRAME_LIST_SIZE);

    if (fastIsoData->FastIsoFrameList == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    // allocate our common buffers

    if (NT_SUCCESS(ntStatus)) {
        // allocate 1024 persistent ISO TDs
        // plus space for buffers
        length = FRAME_LIST_SIZE * 32;
        length += (Endpoint->MaxPacketSize * FRAME_LIST_SIZE);

        UHCD_KdPrint((2, "'Init Fast ISO Endpoint - need %d\n", length));

        Endpoint->NoDMABuffer =
            UHCD_Alloc_NoDMA_Buffer(DeviceObject, Endpoint, length);

        UHCD_KdPrint((2, "'NoDMA buffer = %x\n", Endpoint->NoDMABuffer));

        if (Endpoint->NoDMABuffer == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {

            fastIsoData->IsoTDListVa = Endpoint->NoDMABuffer;
            // physical address of first iso TD
            fastIsoData->IsoTDListPhys = Endpoint->NoDMAPhysicalAddress;

            fastIsoData->DataBufferStartVa =
                fastIsoData->IsoTDListVa + (FRAME_LIST_SIZE*32);

            fastIsoData->DataBufferStartPhys =
                fastIsoData->IsoTDListPhys + (FRAME_LIST_SIZE*32);
        }
    }

    if (NT_SUCCESS(ntStatus)) {
        // intialize our iso TDs, mark them not active
        transferDescriptor =
            (PHW_TRANSFER_DESCRIPTOR) fastIsoData->IsoTDListVa;

        phys = fastIsoData->DataBufferStartPhys;

        for (i=0; i<1024 ;i++) {
            // prepare the TD
            RtlZeroMemory(transferDescriptor,
                          sizeof(*transferDescriptor));

            // td in initially not active
            transferDescriptor->Active = 0;

            // we will use the Frame entry to track lost
            // iso TDs
            // initially this is set to zero -- when we mark
            // the TD active we set it to 0xabadbabe
            // when we recycle it we set it to 0xffffffff
            transferDescriptor->Frame = 0;

            transferDescriptor->Endpoint = Endpoint->EndpointAddress;
            transferDescriptor->Address = Endpoint->DeviceAddress;

            //
            // Set Pid, only support out
            //
            transferDescriptor->PID = USB_OUT_PID;
            transferDescriptor->Sig = SIG_TD;
            transferDescriptor->Isochronous = 1;
            transferDescriptor->ActualLength =
                UHCD_SYSTEM_TO_USB_BUFFER_LENGTH(0);
            transferDescriptor->StatusField = 0;

            transferDescriptor->LowSpeedControl = 0;
            transferDescriptor->ReservedMBZ = 0;
            transferDescriptor->ErrorCounter = 0;
            transferDescriptor->RetryToggle = 0;
            transferDescriptor->InterruptOnComplete = 1;

            transferDescriptor->PhysicalAddress =
                fastIsoData->IsoTDListPhys + i*sizeof(*transferDescriptor);
            transferDescriptor->PacketBuffer = phys;

            UHCD_Debug_DumpTD(transferDescriptor);

            transferDescriptor++;
            phys += Endpoint->MaxPacketSize;
        }
    }

    if (NT_SUCCESS(ntStatus)) {
         InsertHeadList(&deviceExtension->FastIsoEndpointList,
            &Endpoint->ListEntry);


        // now put the TDs in the schedule
        // this must be synchronized with the ISR


        UHCD_ASSERT(deviceExtension->InterruptObject);
        if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                    UHCD_InitFastIsoTDs,
                                    Endpoint)) {
            TRAP(); //something has gone terribly wrong
        }

        // Our TDs are now in permenently in the schedule!

    } else {

        if (fastIsoData->FastIsoFrameList) {
            RETHEAP(fastIsoData->FastIsoFrameList);
        }

        if (Endpoint->NoDMABuffer) {
            UHCD_Free_NoDMA_Buffer(DeviceObject,
                                   Endpoint->NoDMABuffer);
        }

    }

    UHCD_RequestInterrupt(DeviceObject, -2);

    UHCD_KdPrint((2, "'Init Fast ISO - FrameListCopyVirtualAddress %x\n",
        deviceExtension->FrameListCopyVirtualAddress));

    return ntStatus;
}


NTSTATUS
UHCD_UnInitializeFastIsoEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Set up a No-DMA style (iso dbl buffered endpoint)

Arguments:

Return Value:

    None.
--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PFAST_ISO_DATA fastIsoData;

    UHCD_KdPrint((1, "'Free Fast ISO Endpoint\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    fastIsoData = &Endpoint->FastIsoData;

    // remove from the fast iso list
    RemoveEntryList(&Endpoint->ListEntry);

    // put the original frame list copy back
    UHCD_ASSERT(deviceExtension->InterruptObject);
    if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                UHCD_UnInitFastIso,
                                Endpoint)) {
        TRAP(); //something has gone terribly wrong
    }

    if (fastIsoData->FastIsoFrameList) {
        RETHEAP(fastIsoData->FastIsoFrameList);
    }

    if (Endpoint->NoDMABuffer) {
        UHCD_Free_NoDMA_Buffer(DeviceObject,
                               Endpoint->NoDMABuffer);
    }

    return STATUS_SUCCESS;
}


PUHCD_ENDPOINT
UHCD_GetLastFastIsoEndpoint(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUHCD_ENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    // walk the list and return the last endpoint
    listEntry = &deviceExtension->FastIsoEndpointList;
    if (IsListEmpty(listEntry)) {
        endpoint = NULL;
    } else {
        listEntry = deviceExtension->FastIsoEndpointList.Flink;
    }

    while (listEntry != &deviceExtension->FastIsoEndpointList) {

        endpoint = (PUHCD_ENDPOINT) CONTAINING_RECORD(
                listEntry,
                struct _UHCD_ENDPOINT,
                ListEntry);

        ASSERT_ENDPOINT(endpoint);
        listEntry = endpoint->ListEntry.Flink;

    }

    return endpoint;
}


PHW_TRANSFER_DESCRIPTOR
UHCD_GetRelativeTD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN ULONG FrameNumber,
    IN OUT PUCHAR *DataBuffer
    )
/*++

Routine Description:

Arguments:

Return Value:


    fastIsoData = &Endpoint->FastIsoData;
--*/
{
    ULONG i;
    PDEVICE_EXTENSION deviceExtension =
        DeviceObject->DeviceExtension;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor = NULL;
    PUCHAR isoData;
    PFAST_ISO_DATA fastIsoData;


    fastIsoData = &Endpoint->FastIsoData;
    i = FrameNumber % FRAME_LIST_SIZE;

    if (FrameNumber <= deviceExtension->LastFrameProcessed) {
        //
        // we missed it
        //
        deviceExtension->IsoStats.IsoPacketNotAccesed++;
        deviceExtension->Stats.IsoMissedCount++;

//        TEST_TRAP();

        return NULL;
    }

    UHCD_KdPrint((2, "'frm = %x  relfrm %x \n", FrameNumber, i));
    UHCD_KdPrint((2, "'base = %x  \n", fastIsoData->DataBufferStartVa));

    transferDescriptor = (PHW_TRANSFER_DESCRIPTOR)
        (fastIsoData->IsoTDListVa + (i*32));

    isoData =
        (fastIsoData->DataBufferStartVa + (i*Endpoint->MaxPacketSize));

    *DataBuffer = isoData;

    return transferDescriptor;
}


PHW_TRANSFER_DESCRIPTOR
UHCD_CleanupFastIsoTD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN ULONG RelativeFrame,
    IN BOOLEAN Count
    )
/*++

Routine Description:

Arguments:

    Count - count the TD as missed if not accessd

Return Value:


    fastIsoData = &Endpoint->FastIsoData;
--*/
{
    ULONG i;
    PDEVICE_EXTENSION deviceExtension =
        DeviceObject->DeviceExtension;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor = NULL;
    PUCHAR isoData;
    PFAST_ISO_DATA fastIsoData;
//    ULONG cf;


    fastIsoData = &Endpoint->FastIsoData;
    i = RelativeFrame;

    transferDescriptor = (PHW_TRANSFER_DESCRIPTOR)
        (fastIsoData->IsoTDListVa + (i*32));

    if (transferDescriptor->Active &&
        Count) {

        // TD was initialized but and set active
        // but never accessed.
        // count as a HW miss

        deviceExtension->IsoStats.HWIsoMissedCount++;
        deviceExtension->IsoStats.IsoPacketNotAccesed++;
        UHCD_KdPrint((3, "'Fast ISO HWMiss = %d\n",
            deviceExtension->IsoStats.HWIsoMissedCount));
    }

    // mark inactive and set the id to
    // 'recycled'
    transferDescriptor->Frame = 0xffffffff;
    transferDescriptor->Active = 0;

    return transferDescriptor;
}


NTSTATUS
UHCD_ProcessFastIsoTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PIRP Irp,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    process a fast ios transfer

Arguments:

Return Value:

--*/
{
    PHW_TRANSFER_DESCRIPTOR transferDescriptor;
    PDEVICE_EXTENSION deviceExtension;
    ULONG i, nextPacket, offset, length;
    ULONG bytesTransferred = 0;
    PUCHAR isoData, currentVa;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    // loop thru the packets in the URB

    // all we have to do is compute the relative TD and copy the client
    // data to it

    currentVa =
        MmGetMdlVirtualAddress(Urb->HcdUrbCommonTransfer.TransferBufferMDL);

    for (i=0; i < Urb->UrbIsochronousTransfer.NumberOfPackets; i++) {

        transferDescriptor =
            UHCD_GetRelativeTD(DeviceObject,
                               Endpoint,
                               Urb->UrbIsochronousTransfer.StartFrame+i,
                               &isoData);

        if (transferDescriptor != NULL) {

            //
            // Prepare the buffer part of the TD.
            //
            offset =
                Urb->UrbIsochronousTransfer.IsoPacket[i].Offset;

            nextPacket = i+1;

            if (nextPacket >=
                Urb->UrbIsochronousTransfer.NumberOfPackets) {
                // this is the last packet
                length = Urb->UrbIsochronousTransfer.TransferBufferLength -
                    offset;
            } else {
                // compute length based on offset of next packet
                UHCD_ASSERT(Urb->UrbIsochronousTransfer.IsoPacket[nextPacket].Offset >
                            offset);

                length = Urb->UrbIsochronousTransfer.IsoPacket[nextPacket].Offset -
                            offset;
            }

            UHCD_ASSERT(length <= Endpoint->MaxPacketSize);
            Urb->UrbIsochronousTransfer.IsoPacket[i].Length = 0;
            Urb->UrbIsochronousTransfer.IsoPacket[i].Status =
                    USBD_STATUS_SUCCESS;

            UHCD_KdPrint((2, "'Fast ISO xfer TD = %x\n", transferDescriptor));
            UHCD_KdPrint((2, "'offset 0x%x len 0x%x\n", offset, length));
            UHCD_KdPrint((2, "'transfer buffer %x iso data %x\n",
                currentVa, isoData));

            // copy the client data to our DMA buffer
            RtlCopyMemory(isoData,
                          currentVa+offset,
                          length);
            bytesTransferred += length;

            transferDescriptor->MaxLength =
                UHCD_SYSTEM_TO_USB_BUFFER_LENGTH(length);

            // if the active bit is still set then this TD has
            // not been processed by HW

            if (transferDescriptor->Active &&
                transferDescriptor->Frame == 0xabadbabe) {
                // we have an overrun
                TEST_TRAP();
            } else if (transferDescriptor->Active) {
                // for some reason HW did not access this TD
                deviceExtension->IsoStats.HWIsoMissedCount++;
                deviceExtension->IsoStats.IsoPacketNotAccesed++;
                UHCD_KdPrint((3, "'Fast ISO HWMiss = %d\n",
                        deviceExtension->IsoStats.HWIsoMissedCount));
            }

            transferDescriptor->Active = 1;
            transferDescriptor->Frame = 0xabadbabe;

            transferDescriptor->InterruptOnComplete = 1;

            UHCD_Debug_DumpTD(transferDescriptor);
        }

    }

    // now complete the transfer
    // since we double buffer the client data we can actually
    // complete the transfer before the data is actually transmitted
    // on the bus.

    Urb->UrbIsochronousTransfer.ErrorCount = 0;
    Urb->HcdUrbCommonTransfer.Status =
        USBD_STATUS_SUCCESS;
    Urb->HcdUrbCommonTransfer.TransferBufferLength =
        bytesTransferred;

    deviceExtension->Stats.BytesTransferred +=
            Urb->HcdUrbCommonTransfer.TransferBufferLength;

    deviceExtension->IsoStats.IsoBytesTransferred +=
            Urb->HcdUrbCommonTransfer.TransferBufferLength;

    if (Irp != NULL) {
        InsertTailList(&deviceExtension->FastIsoTransferList,
                       &HCD_AREA(Urb).HcdListEntry);
    }


    //TEST_TRAP();

    return STATUS_PENDING;
}


NTSTATUS
UHCD_SubmitFastIsoUrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    )
/*++

Routine Description:

Arguments:

   Context - DeviceData for this USB controller.

Return Value:

    nt status code for operation

--*/
{
    NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;
    PHCD_URB hcdUrb;
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_ENDPOINT endpoint;

    hcdUrb = (PHCD_URB) Urb;
    endpoint = HCD_AREA(hcdUrb).HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);

    LOGENTRY(LOG_ISO,'subI', endpoint, hcdUrb, 0);

    UHCD_WakeIdle(DeviceObject);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (endpoint->EndpointFlags & EPFLAG_FAST_ISO) {

        UHCD_ValidateIsoUrb(DeviceObject,
                            endpoint,
                            hcdUrb);

        if (URB_HEADER(Urb).Status == USBD_STATUS_BAD_START_FRAME) {

            LOGENTRY(LOG_ISO,'Badf', 0, hcdUrb, 0);
            deviceExtension->IsoStats.BadStartFrame++;
            // NOTE: we only allow one urb per iso request
            // since we pended the original request bump
            // the pending count so we'll complete this request

            ntStatus = STATUS_INVALID_PARAMETER;

        } else {

            LOGENTRY(LOG_ISO,'rtmI', endpoint,
                hcdUrb->UrbIsochronousTransfer.StartFrame, 0);

            // Advance the next free StartFrame for this endpoint to be the
            // frame immediately following the last frame of this transfer.
            //
            endpoint->CurrentFrame = hcdUrb->UrbIsochronousTransfer.StartFrame +
                                     hcdUrb->UrbIsochronousTransfer.NumberOfPackets;

            //
            // we lose our virginity when the first transfer starts
            //
            CLR_EPFLAG(endpoint, EPFLAG_VIRGIN);

            UHCD_ProcessFastIsoTransfer(
                DeviceObject,
                endpoint,
                NULL,
                hcdUrb);

            // we always succeed a fast_iso request
            ntStatus = STATUS_SUCCESS;

        }
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\dscrptor.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    dscrptor.c

Abstract:

    The module manages descriptor allocation.

    Descriptors are structures in physical memory used by the
    host controller to manage transfers, the HC requires two
    types of TDs: Queue head TDs and Transfer TDs.

    A memory descriptor describes a buffer that can be accessed by the
    Host Controller (ie allocated with HalAllocateCommonBuffer).

    The descriptor code maintains three types of memory descriptor
    lists UHCD_LARGE_COMMON_BUFFERS, UHCD_MEDIUM_COMMON_BUFFERS and
    UHCD_SMALL_COMMON_BUFFERS

    UHCD_LARGE_COMMON_BUFFERS are blocks of memory we use for a queue
    head and its associated transfer descriptors for iso and large bulk
    endpoints.

    UHCD_MEDIUM_COMMON_BUFFERS are blocks of memory we use for a queue
    head and its associated transfer descriptors.

    UHCD_SMALL_COMMON_BUFFERS are blocks of memory we use to double
    buffer non-isochronous packets if needed.

Environment:

    kernel mode only

Notes:

Revision History:

    11-01-95 : created

--*/
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UHCD_InitializeCommonBufferPool)
#endif
#endif

LONG UHCD_CommonBufferBytes = 0;
#if DBG

#define UHCD_ASSERT_BUFFER_POOL(bp) \
           (((PUHCD_BUFFER_POOL) (bp))->Sig == UHCD_BP_SIG)
#else
#define UHCD_ASSERT_BUFFER_POOL(bp)
#endif



#define UHCD_BP_SIG 0x444a444a



PUHCD_BUFFER_POOL
UHCD_SelectBufferPool(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG CommonBufferLength
    )
/*++

Routine Description:

    select the appropriate buffer pool based on the
    size of the CommonBufferBlock requested.

Arguments:

    DeviceObject -

Return Value:

    None

--*/
{
    PUHCD_BUFFER_POOL bufferPool;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    UHCD_ASSERT(CommonBufferLength <= UHCD_LARGE_COMMON_BUFFER_SIZE);

    if (CommonBufferLength <= UHCD_SMALL_COMMON_BUFFER_SIZE) {
        bufferPool = &deviceExtension->SmallBufferPool;
    } else if (CommonBufferLength <= UHCD_MEDIUM_COMMON_BUFFER_SIZE) {
        bufferPool = &deviceExtension->MediumBufferPool;
    } else if (CommonBufferLength <= UHCD_LARGE_COMMON_BUFFER_SIZE) {
        bufferPool = &deviceExtension->LargeBufferPool;
    } else {
        bufferPool = NULL;
    }

    LOGENTRY(LOG_MISC, 'sbPL', bufferPool, CommonBufferLength, 0);

#if DBG
    if (bufferPool) {
        UHCD_ASSERT_BUFFER_POOL(bufferPool);
    }
#endif

    return bufferPool;
}


ULONG
UHCD_FreePoolSize(
    IN PUHCD_BUFFER_POOL BufferPool,
    IN OUT PULONG ByteCount
    )
/*++

Routine Description:

    returns the number of entries in the free pool

Arguments:

Return Value:

    None.

--*/
{
    ULONG count = 0;
    PSINGLE_LIST_ENTRY current;
    PSINGLE_LIST_ENTRY listEntry;
    PUHCD_MEMORY_DESCRIPTOR memoryDescriptor;
    KIRQL oldIrql;

    *ByteCount = 0;

    KeAcquireSpinLock(&BufferPool->MemoryDescriptorFreePoolSpin, &oldIrql);
    listEntry = &BufferPool->MemoryDescriptorFreePool;

    // walk the list

    current = listEntry->Next;
    LOGENTRY(LOG_MISC, 'fpsz', listEntry, 0, current);
    while (current != NULL) {
        memoryDescriptor =  CONTAINING_RECORD(current,
                                              UHCD_MEMORY_DESCRIPTOR,
                                              SingleListEntry);
        UHCD_ASSERT(memoryDescriptor->Sig == SIG_MD);
        count++;
        *ByteCount+=BufferPool->CommonBufferLength;
        current = current->Next;
        LOGENTRY(LOG_MISC, 'fpsN', count, 0, current);
    }

    KeReleaseSpinLock(&BufferPool->MemoryDescriptorFreePoolSpin, oldIrql);

    return count;
}


VOID
UHCD_InitializeHardwareQueueHeadDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHW_QUEUE_HEAD QueueHead,
    IN HW_DESCRIPTOR_PHYSICAL_ADDRESS LogicalAddress
    )
/*++

Routine Description:

    set up a newly created queue head

Arguments:

    DeviceObject - device object for this controller.

    QueueHead - ptr to queue head to initialize.

Return Value:

    None.

--*/
{

    RtlZeroMemory(QueueHead, sizeof(HW_QUEUE_HEAD));

    UHCD_ASSERT((LogicalAddress & 0xf) == 0);

    QueueHead->PhysicalAddress = SET_Q_BIT(LogicalAddress);
    QueueHead->Sig = SIG_QH;
    QueueHead->Flags = 0;

    QueueHead->HW_HLink = QueueHead->PhysicalAddress;
    SET_T_BIT(QueueHead->HW_HLink);
    QueueHead->HW_VLink = LIST_END; // T-bit set, no descriptors

    return;
}


VOID
UHCD_InitializeHardwareTransferDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHW_TRANSFER_DESCRIPTOR TransferDescriptor,
    IN HW_DESCRIPTOR_PHYSICAL_ADDRESS LogicalAddress
    )
/*++

Routine Description:

    set up a newly created transfer descriptor.

Arguments:

    DeviceObject - device object for this controller.

    Transfer - ptr to queue head to initialize

Return Value:

    None.

--*/
{

    RtlZeroMemory(TransferDescriptor, sizeof(HW_TRANSFER_DESCRIPTOR));

    UHCD_ASSERT((LogicalAddress & 0xf) == 0);

    TransferDescriptor->PhysicalAddress = LogicalAddress;
    TransferDescriptor->Sig = SIG_TD;

    return;
}


BOOLEAN
UHCD_AllocateHardwareDescriptors(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_HARDWARE_DESCRIPTOR_LIST *HardwareDescriptorList,
    IN ULONG NumberOfTransferDescriptors
    )
/*++

Routine Description:

    This function allocates a descriptor list of a specified size,
    the descriptor list includes a queue head and array of
    'NumberOfTransferDescriptors' transfer descriptors.

Arguments:

    DeviceObject - device object for this controller.

    HardwareDescriptorList - pointer to descriptor list structure,
                    filled in with information about descriptors allocated.

    NumberOfTransferDescriptors - number of transfer descriptors to allocate.

Return Value:

    returns TRUE if successful.

--*/
{
    ULONG i;
    BOOLEAN status = FALSE;
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_HARDWARE_DESCRIPTOR_LIST hardwareDescriptorList;
    PUHCD_MEMORY_DESCRIPTOR memoryDescriptor;

    UHCD_KdPrint((2, "'enter UHCD_AllocateHardwareDescriptors\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    *HardwareDescriptorList = NULL;

    UHCD_ASSERT(sizeof(HW_QUEUE_HEAD) == UHCD_HW_DESCRIPTOR_SIZE);
    UHCD_ASSERT(sizeof(HW_TRANSFER_DESCRIPTOR) == UHCD_HW_DESCRIPTOR_SIZE);


    UHCD_ASSERT(NumberOfTransferDescriptors == MAX_TDS_PER_ENDPOINT ||
        NumberOfTransferDescriptors == MIN_TDS_PER_ENDPOINT);

    // first allocate the descriptor list structure
    hardwareDescriptorList = GETHEAP(NonPagedPool,
                                     sizeof(*hardwareDescriptorList));

    LOGENTRY(LOG_MISC, 'alDL', hardwareDescriptorList, 0, 0);

    if (hardwareDescriptorList) {
        ULONG need;

        // Allocate some shared adapter memory for this
        // descriptor list.
        //
        // Note: we need one extra descriptor for the Queue Head
        // and one extra for a scratch buffer
        need = TD_LIST_SIZE(NumberOfTransferDescriptors);


        hardwareDescriptorList->MemoryDescriptor =
            UHCD_AllocateCommonBuffer(DeviceObject, need);
        hardwareDescriptorList->NumberOfHWDescriptors =
            NumberOfTransferDescriptors+1;

        if (hardwareDescriptorList->MemoryDescriptor) {
            memoryDescriptor = hardwareDescriptorList->MemoryDescriptor;

            LOGENTRY(LOG_MISC, 'iHDL', hardwareDescriptorList,
                NumberOfTransferDescriptors, 0);

            UHCD_InitializeHardwareQueueHeadDescriptor(
                DeviceObject,
               (PHW_QUEUE_HEAD) memoryDescriptor->VirtualAddress,
                memoryDescriptor->LogicalAddress);
            for (i = 0; i < NumberOfTransferDescriptors; i++) {
                LOGENTRY(LOG_MISC, 'iHTD', hardwareDescriptorList,
                    NumberOfTransferDescriptors, 0);

                UHCD_InitializeHardwareTransferDescriptor(DeviceObject,
                    (PHW_TRANSFER_DESCRIPTOR)
                     (memoryDescriptor->VirtualAddress +
                     i * sizeof(HW_TRANSFER_DESCRIPTOR) +
                     sizeof(HW_QUEUE_HEAD)),
                     memoryDescriptor->LogicalAddress +
                     i * sizeof(HW_TRANSFER_DESCRIPTOR) +
                     sizeof(HW_QUEUE_HEAD));
            }

            hardwareDescriptorList->ScratchBufferVirtualAddress =
                memoryDescriptor->VirtualAddress + i *
                sizeof(HW_TRANSFER_DESCRIPTOR) +
                sizeof(HW_QUEUE_HEAD);
            UHCD_ASSERT((ULONG)((PUCHAR)hardwareDescriptorList->
                        ScratchBufferVirtualAddress -
                        (PUCHAR)memoryDescriptor->VirtualAddress) < need);

            hardwareDescriptorList->ScratchBufferLogicalAddress =
                memoryDescriptor->LogicalAddress + i *
                    sizeof(HW_TRANSFER_DESCRIPTOR) +
                sizeof(HW_QUEUE_HEAD);

            *HardwareDescriptorList = hardwareDescriptorList;
            status = TRUE;
        } else {
            RETHEAP(hardwareDescriptorList);
        }
    }

    UHCD_KdPrint((2, "'exit UHCD_AllocateHardwareDescriptors descriptors 0x%x\n",
        status));

    return status;

}


VOID
UHCD_FreeHardwareDescriptors(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_HARDWARE_DESCRIPTOR_LIST HardwareDescriptorList
    )
/*++

Routine Description:

    This function returns descriptors to the system.

Arguments:

    DeviceObject - device object for this controller.

    HardwareDescriptorList - pointer to descriptor list structure,
                    filled in with information about descriptors allocated.


Return Value:

    None

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    UHCD_KdPrint((2, "'enter UHCD_FreeHardwareDesriptors\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Put this one back on the free list
    //

    LOGENTRY(LOG_MISC, 'frDL', HardwareDescriptorList,
        HardwareDescriptorList->MemoryDescriptor, 0);

    //
    // free the shared memory
    //
    UHCD_FreeCommonBuffer(DeviceObject,
                          HardwareDescriptorList->MemoryDescriptor);

    // free the list header structure
    RETHEAP(HardwareDescriptorList);

    UHCD_KdPrint((2, "'exit UHCD_FreeHardwareDescriptors\n"));
}


PUHCD_MEMORY_DESCRIPTOR
UHCD_DoAllocateCommonBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG CommonBufferLength
    )
/*++

Routine Description:

    This function creates a new block of memory that both the HCD and
    the HC harware can access, this memory can be used for HW descriptors
    or packet buffers.

Arguments:

    DeviceObject -

    CommonBufferLength - minimum number of bytes this shared memory block
                    must contain.

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_MEMORY_DESCRIPTOR memoryDescriptor = NULL;
    PSINGLE_LIST_ENTRY singleListEntry;
    PSINGLE_LIST_ENTRY memoryDescriptorFreePool;
    PKSPIN_LOCK memoryDescriptorFreePoolSpin;
    PUHCD_BUFFER_POOL bufferPool;

    UHCD_KdPrint((2, "'enter UHCD_DoAllocateCommonBuffer\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // select the list to allocate from
    //

    bufferPool = UHCD_SelectBufferPool(DeviceObject, CommonBufferLength);

    memoryDescriptorFreePool = &bufferPool->MemoryDescriptorFreePool;
    memoryDescriptorFreePoolSpin =
        &bufferPool->MemoryDescriptorFreePoolSpin;

    singleListEntry = ExInterlockedPopEntryList(memoryDescriptorFreePool,
                                                memoryDescriptorFreePoolSpin);

    if (singleListEntry) {
        memoryDescriptor = CONTAINING_RECORD(singleListEntry,
                                             UHCD_MEMORY_DESCRIPTOR,
                                             SingleListEntry);

        LOGENTRY(LOG_MISC, 'alMD', memoryDescriptor,
            memoryDescriptor->VirtualAddress, 0);
        ASSERT_MD(memoryDescriptor);
        memoryDescriptor->InUse++;
    }

    UHCD_KdPrint((2, "'exit UHCD_DoAllocateCommonBuffer 0x%x\n",
        memoryDescriptor));

    return memoryDescriptor;
}


PUHCD_MEMORY_DESCRIPTOR
UHCD_AllocateCommonBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG CommonBufferLength
    )
/*++

Routine Description:

    This function creates a new block of memory that both the HCD and
    the HC harware can access, this memory can be used for HW descriptors
    or packet buffers.

Arguments:

    DeviceObject -

    CommonBufferLength - minimum number of bytes this shared memory block
                    must contain.

Return Value:

    None

--*/
{
    PUHCD_MEMORY_DESCRIPTOR memoryDescriptor = NULL;

    // first attempt to satisfy the request whit what is available

    UHCD_KdPrint((2, "'enter UHCD_AllocateCommonBuffer\n"));
    LOGENTRY(LOG_MISC, 'acbr', 0, CommonBufferLength, 0);

    // try to grow the pool
    UHCD_MoreCommonBuffers(DeviceObject);

    memoryDescriptor =
        UHCD_DoAllocateCommonBuffer(DeviceObject,
                                    CommonBufferLength);

    if (memoryDescriptor == NULL) {
        // non available, attempt to grow the pool
        UHCD_AllocateCommonBufferBlock(DeviceObject,
                                       CommonBufferLength,
                                       1);
        memoryDescriptor =
            UHCD_DoAllocateCommonBuffer(DeviceObject,
                                        CommonBufferLength);

#if DBG
        if (memoryDescriptor == NULL) {
            UHCD_KdTrap(("UHCD failed to allocate common buffer\n"));
        }
#endif
    }

    //
    // if we are at passive level then grow the pool now
    //

    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        UHCD_MoreCommonBuffers(DeviceObject);
    }

    UHCD_KdPrint((2, "'exit UHCD_AllocateCommonBuffer 0x%x\n", memoryDescriptor));

    return memoryDescriptor;
}


VOID
UHCD_FreeCommonBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_MEMORY_DESCRIPTOR MemoryDescriptor
    )
/*++

Routine Description:

Arguments:

    DeviceObject -

    MemoryDescriptor - memory descriptor to free

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PSINGLE_LIST_ENTRY memoryDescriptorFreePool;
    PKSPIN_LOCK memoryDescriptorFreePoolSpin;
    PUHCD_BUFFER_POOL bufferPool;

    UHCD_KdPrint((2, "'enter UHCD_FreeCommonBuffer\n"));

    LOGENTRY(LOG_MISC, 'frMD', MemoryDescriptor,
        MemoryDescriptor->VirtualAddress, MemoryDescriptor->Length);

    ASSERT_MD(MemoryDescriptor);

    bufferPool = MemoryDescriptor->BufferPool;

#if DBG
//    RtlZeroMemory(MemoryDescriptor->VirtualAddress, MemoryDescriptor->Length);
    RtlFillMemory(MemoryDescriptor->VirtualAddress,
                  MemoryDescriptor->Length,
                  -1);
#endif

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    memoryDescriptorFreePool = &bufferPool->MemoryDescriptorFreePool;
    memoryDescriptorFreePoolSpin =
        &bufferPool->MemoryDescriptorFreePoolSpin;

    ExInterlockedPushEntryList(memoryDescriptorFreePool,
                               &MemoryDescriptor->SingleListEntry,
                               memoryDescriptorFreePoolSpin);

    MemoryDescriptor->InUse--;

    UHCD_KdPrint((2, "'exit UHCD_FreeCommonBuffer\n"));
}


VOID
UHCD_AllocateCommonBufferBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG CommonBufferLength,
    IN ULONG NumberOfPages
    )
/*++

Routine Description:

    This function tries to increase the pool of common memory
    blocks used for descriptors and packet buffers.


    Each Memory Descriptor looks like this:

                                        offset
    memoryDescriptor  =
        00 [Header] 32 bytes, (UHCD_HW_DESCRIPTOR_SIZE)
    memoryDescriptor->VirtualAddress =
        32 [memory] CommonBufferLength
        ......
        all memoryDescriptors are aligned on a 32 byte
        boundry.

Arguments:

    DeviceObject -

    CommonBufferLength - Number of contiguous bytes needed
        in the in each common buffer.

    NumberOfPages - number of pages to allocate for common buffers.

Return Value:

    None

--*/
{
    PUCHAR virtualAddress, baseVirtualAddress, endVirtualAddress;
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_MEMORY_DESCRIPTOR memoryDescriptor = NULL;
    PSINGLE_LIST_ENTRY memoryDescriptorFreePool;
    HW_DESCRIPTOR_PHYSICAL_ADDRESS hwLogicalAddress;
    PHYSICAL_ADDRESS logicalAddress;
    ULONG blockSize, remain;
    PUHCD_BUFFER_POOL bufferPool;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // first figure our what size buffer we are dealing with
    //

    bufferPool = UHCD_SelectBufferPool(DeviceObject, CommonBufferLength);
    LOGENTRY(LOG_MISC, 'ACbb', bufferPool, NumberOfPages, CommonBufferLength);

    if (bufferPool == NULL) {
        //
        // Generally this means that CommonBufferLength is an illegal size
        // so we punt without growing the pools
        //

        return;
    }

    //
    // select the descriptor list based on the size of the request
    //
    memoryDescriptorFreePool = &bufferPool->MemoryDescriptorFreePool;
    //
    // set CommonBufferLength based on the descriptor list we selected
    //
    CommonBufferLength = bufferPool->CommonBufferLength;

#if DBG
    {
    //
    // Dump out the size of the free pool for this buffer type
    //
    ULONG freeBytes, freeCommonBuffers;

    freeCommonBuffers = UHCD_FreePoolSize(bufferPool, &freeBytes);
    LOGENTRY(LOG_MISC, 'frBB', freeCommonBuffers, freeBytes, bufferPool);
    UHCD_KdPrint(
        (2, "'before alloc pool size = %d # buffs = %d total = %d bytes\n",
        bufferPool->CommonBufferLength, freeCommonBuffers, freeBytes));

    }
#endif

    //
    // Grow the pool..
    // BUGBUG
    // we always grow by one page
    //

    LOGENTRY(LOG_MISC, 'grow', NumberOfPages, bufferPool, CommonBufferLength);

    //
    // calc the number of bytes
    //

    blockSize = NumberOfPages*PAGE_SIZE;

    //
    // allocate some shared memory
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

#ifdef MAX_DEBUG
    if (KeGetCurrentIrql() > APC_LEVEL) {
       UHCD_KdPrint((2,  "UHCD calling HalAllocateCommonBuffer at DPC level\n"));
        TEST_TRAP();
    }
#endif

    virtualAddress =
        baseVirtualAddress =
            HalAllocateCommonBuffer(deviceExtension->AdapterObject,
                                    blockSize,
                                    &logicalAddress,
                                    TRUE);

#if DBG
    UHCD_CommonBufferBytes += blockSize;
#endif

    // remember the base Virtual Address so we can free it later
    // we need to keep track of the common buffers we allocate

    if (baseVirtualAddress) {

        PUHCD_PAGE_LIST_ENTRY pageListEntry;

        UHCD_KdPrint((2, "'page list size = %d\n", sizeof(UHCD_PAGE_LIST_ENTRY)));

        //
        // CIMEXCIMEX
        //

        UHCD_ASSERT((sizeof(UHCD_PAGE_LIST_ENTRY) % 32) == 0);

        pageListEntry =
            (PUHCD_PAGE_LIST_ENTRY) baseVirtualAddress;

        pageListEntry->Length = blockSize;
        pageListEntry->LogicalAddress = logicalAddress;
        pageListEntry->Flags = 0;

        baseVirtualAddress += sizeof(UHCD_PAGE_LIST_ENTRY);
        virtualAddress = baseVirtualAddress;
        blockSize -= sizeof(UHCD_PAGE_LIST_ENTRY);
        logicalAddress.LowPart += sizeof(UHCD_PAGE_LIST_ENTRY);

        // link it in
        InsertTailList(&deviceExtension->PageList,
                       &pageListEntry->ListEntry);
    }


    //
    // break the new block up in to memory descriptors
    // and put them on the free list.
    //

    if (baseVirtualAddress) {
        ULONG length;

        remain = blockSize;

        //
        // first grow the current pool by as many buffers
        // as possible
        //


        hwLogicalAddress = logicalAddress.LowPart;
        endVirtualAddress = baseVirtualAddress + (blockSize - 1);

        length = UHCD_GrowBufferPool(DeviceObject, bufferPool,
                                     CommonBufferLength, virtualAddress,
                                     endVirtualAddress, hwLogicalAddress);

        virtualAddress+=length;
        hwLogicalAddress+=length;

        //
        // use what is left over for smaller buffers
        //
        remain -= length;


        if (remain > (UHCD_MEDIUM_COMMON_BUFFER_SIZE + UHCD_HW_DESCRIPTOR_SIZE)) {

           UHCD_ASSERT(virtualAddress < endVirtualAddress);

            length = UHCD_GrowBufferPool(DeviceObject,
                                         &deviceExtension->SmallBufferPool,
                                         UHCD_MEDIUM_COMMON_BUFFER_SIZE,
                                         virtualAddress, endVirtualAddress,
                                         hwLogicalAddress);

            virtualAddress+=length;
            hwLogicalAddress+=length;
            remain -= length;
        }

        if (remain >
            (UHCD_SMALL_COMMON_BUFFER_SIZE + UHCD_HW_DESCRIPTOR_SIZE)) {

           UHCD_ASSERT(virtualAddress < endVirtualAddress);

            length = UHCD_GrowBufferPool(DeviceObject,
                                         &deviceExtension->SmallBufferPool,
                                         UHCD_SMALL_COMMON_BUFFER_SIZE,
                                         virtualAddress, endVirtualAddress,
                                         hwLogicalAddress);
            remain -= length;
        }

        LOGENTRY(LOG_MISC, 'WSTE', remain, 0, 0);

    } /* Grow the Pool */

#if DBG
    {
    //
    // Dump out the size of the free pool for this buffer type
    //
    ULONG freeBytes, freeCommonBuffers;

    freeCommonBuffers = UHCD_FreePoolSize(bufferPool, &freeBytes);
    LOGENTRY(LOG_MISC, 'frB2', freeCommonBuffers, freeBytes, bufferPool);
    UHCD_KdPrint(
        (2, "'after alloc pool size = %d # buffs = %d total = %d bytes\n",
        bufferPool->CommonBufferLength, freeCommonBuffers, freeBytes));

    }
#endif

    return;
}


VOID
UHCD_FreeCommonBufferBlocks(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Attempt to release unused shared memory to the system.

Arguments:

    DeviceObject -

Return Value:

    None

--*/
{
    // not implemented
    UHCD_KdTrap(("FreeCommonBufferBlocks not supported yet\n"));
}


ULONG
UHCD_CheckCommonBufferPool(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_BUFFER_POOL BufferPool,
    IN BOOLEAN Allocate
    )
/*++

Routine Description:

    Attempt to grow of ree common buffers relative to the maximum
    free pool size.

Arguments:

    DeviceObject -

Return Value:

    Returns number of pages needed or grown

    None

--*/
{
    ULONG freeBytes, freeCommonBuffers;
    ULONG pagesNeeded = 0;

    //
    // make sure our reserve of common buffers is
    // kept up
    //

    //
    // Dump out the size of the free pool for this buffer type
    //

    UHCD_ASSERT_BUFFER_POOL(BufferPool);

    freeCommonBuffers = UHCD_FreePoolSize(BufferPool, &freeBytes);
    UHCD_KdPrint((2, "'pool size = %d # buffs = %d total = %d bytes\n",
            BufferPool->CommonBufferLength, freeCommonBuffers, freeBytes));

    if (freeCommonBuffers < BufferPool->MaximumFreeBuffers) {
        // we are below the maximum buffers we like to
        // keep available, grow the pool to this size

        //
        // allocate more common buffers, request the
        // number of pages needed to satisfy the request
        //

        pagesNeeded = ((BufferPool->MaximumFreeBuffers - freeCommonBuffers)*
                          BufferPool->CommonBufferLength) / PAGE_SIZE;
        pagesNeeded++;

        if (Allocate) {
            UHCD_AllocateCommonBufferBlock(DeviceObject,
                                           BufferPool->CommonBufferLength,
                                           pagesNeeded);
        }

    }

    return pagesNeeded;

}


VOID
UHCD_MoreCommonBuffers(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Attempt to release unused shared memory to the system.

Arguments:

    DeviceObject -

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_WORKITEM workItem;
    KIRQL irql;
    ULONG need;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    LOGENTRY(LOG_MISC, 'mCMB', 0, KeGetCurrentIrql(), 0);

    if (KeGetCurrentIrql() > APC_LEVEL) {
        LOGENTRY(LOG_MISC, 'mCPS', 0, 0, 0);

        need = UHCD_CheckCommonBufferPool(DeviceObject,
                                          &deviceExtension->LargeBufferPool,
                                          FALSE)+
                   UHCD_CheckCommonBufferPool(DeviceObject,
                                               &deviceExtension->MediumBufferPool,
                                               FALSE)+
                   UHCD_CheckCommonBufferPool(DeviceObject,
                                               &deviceExtension->SmallBufferPool,
                                               FALSE);

        KeAcquireSpinLock(&deviceExtension->HcFlagSpin, &irql);

        if (deviceExtension->HcFlags & HCFLAG_WORK_ITEM_QUEUED || need == 0) {
            KeReleaseSpinLock(&deviceExtension->HcFlagSpin, irql);
            return;
        } else {

            deviceExtension->HcFlags |= HCFLAG_WORK_ITEM_QUEUED;
            KeReleaseSpinLock(&deviceExtension->HcFlagSpin, irql);

            workItem = GETHEAP(NonPagedPool, sizeof(UHCD_WORKITEM));

            if (workItem) {

                workItem->DeviceObject = DeviceObject;



                ExInitializeWorkItem(&workItem->WorkQueueItem,
                                     UHCD_GrowPoolWorker,
                                     workItem);

                ExQueueWorkItem(&workItem->WorkQueueItem,
                                DelayedWorkQueue);
            } else {
                KeAcquireSpinLock(&deviceExtension->HcFlagSpin, &irql);
                deviceExtension->HcFlags &= ~HCFLAG_WORK_ITEM_QUEUED;
                KeReleaseSpinLock(&deviceExtension->HcFlagSpin, irql);
            }
        }
    } else {

        LOGENTRY(LOG_MISC, 'mCnS', 0, 0, 0);
        //
        // make sure our reserve of common buffers is
        // kept up
        //

        UHCD_CheckCommonBufferPool(DeviceObject,
                                   &deviceExtension->LargeBufferPool,
                                   TRUE);

        UHCD_CheckCommonBufferPool(DeviceObject,
                                   &deviceExtension->MediumBufferPool,
                                   TRUE);

        UHCD_CheckCommonBufferPool(DeviceObject,
                                   &deviceExtension->SmallBufferPool,
                                   TRUE);
    }
}


VOID
UHCD_InitializeCommonBufferPool(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUHCD_BUFFER_POOL BufferPool,
    IN ULONG CommonBufferLength,
    IN ULONG MaximumFreeBuffers
    )
/*++

Routine Description:

Arguments:

    DeviceObject -

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    // BUGBUG Note:
    // for now we only support one size pool
    //

    KeInitializeSpinLock(&BufferPool->MemoryDescriptorFreePoolSpin);

    BufferPool->MemoryDescriptorFreePool.Next = NULL;
    BufferPool->CommonBufferLength = CommonBufferLength;
    BufferPool->MaximumFreeBuffers = MaximumFreeBuffers;
    BufferPool->Sig = UHCD_BP_SIG;
    //
    // This is where we intially grow the pool to
    // some default size.
    //
}


#if 0
VOID
UHCD_BufferPoolCheck(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

   Called by open_endpoint start_io.
   This routine sanity checks our buffer pools.

Arguments:

    DeviceObject -

Return Value:

    None

--*/

{
    PUHCD_BUFFER_POOL smallBufferPool;
    PUHCD_BUFFER_POOL mediumBufferPool;
    PUHCD_BUFFER_POOL LargeBufferPool;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


//    UHCD_ASSERT(smallBufferPool->ReservedBuffers == 0);
//    UHCD_ASSERT(largeBufferPool->ReservedBuffers == 0);
}
#endif

ULONG
UHCD_GrowBufferPool(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_BUFFER_POOL BufferPool,
    IN ULONG Length,
    IN PUCHAR VirtualAddress,
    IN PUCHAR EndVirtualAddress,
    IN HW_DESCRIPTOR_PHYSICAL_ADDRESS HwLogicalAddress
    )
/*++

Routine Description:

    Called to grow a specific buffer pool

Arguments:

    DeviceObject -

    BufferPool - buffer pool to add these descriptors to.

    Length - length of buffers to allocate

Return Value:

    None

--*/
{
    PUHCD_MEMORY_DESCRIPTOR memoryDescriptor = NULL;
    ULONG consumed = 0;

    PAGED_CODE();
    //
    // buffers must be 32 byte aligned for the hardware
    //

    UHCD_ASSERT((Length/32)*32 == Length);

    // we have a buffer, break it up in to memory descriptors
    // and add them to the free list

    do {
       //
       // CIMEXCIMEX
       //

        UHCD_ASSERT(sizeof(*memoryDescriptor) == UHCD_HW_DESCRIPTOR_SIZE);

        memoryDescriptor = (PUHCD_MEMORY_DESCRIPTOR) VirtualAddress;
        memoryDescriptor->VirtualAddress =
            VirtualAddress+UHCD_HW_DESCRIPTOR_SIZE;
        memoryDescriptor->LogicalAddress =
            HwLogicalAddress+UHCD_HW_DESCRIPTOR_SIZE;
        memoryDescriptor->Sig = SIG_MD;
        memoryDescriptor->InUse++;
        LOGENTRY(LOG_MISC, 'grad', VirtualAddress , memoryDescriptor, Length);

        memoryDescriptor->Length = Length;
        consumed+=memoryDescriptor->Length+UHCD_HW_DESCRIPTOR_SIZE;
        HwLogicalAddress += memoryDescriptor->Length+UHCD_HW_DESCRIPTOR_SIZE;
        VirtualAddress += memoryDescriptor->Length+UHCD_HW_DESCRIPTOR_SIZE;

        // put it on the free list by
        // calling the free routine
        memoryDescriptor->BufferPool = BufferPool;

        UHCD_FreeCommonBuffer(DeviceObject, memoryDescriptor);
        LOGENTRY(LOG_MISC, 'grbf', VirtualAddress , Length, EndVirtualAddress);
    } while (VirtualAddress + Length +
                    UHCD_HW_DESCRIPTOR_SIZE <= EndVirtualAddress);

    LOGENTRY(LOG_MISC, 'grpl', consumed , BufferPool, 0);

    return consumed;
}


VOID
UHCD_GrowPoolWorker(
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PUHCD_WORKITEM workItem = Context;
    PDEVICE_EXTENSION deviceExtension;
    KIRQL irql;

    LOGENTRY(LOG_MISC, 'gpwk', Context , 0, 0);

    deviceExtension = workItem->DeviceObject->DeviceExtension;

    UHCD_MoreCommonBuffers(workItem->DeviceObject);

    KeAcquireSpinLock(&deviceExtension->HcFlagSpin, &irql);
    deviceExtension->HcFlags &= ~HCFLAG_WORK_ITEM_QUEUED;
    KeReleaseSpinLock(&deviceExtension->HcFlagSpin, irql);

    RETHEAP(workItem);
}

#define     UHCD_NO_DMA_BUFFER_USED 0x00000001
#define     UHCD_NO_DMA_BUFFER_FREE 0x00000002

VOID
UHCD_Free_NoDMA_Buffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR NoDMABuffer
    )
 /* ++
  *
  * Description:
  *
  *     This function adds a No DMA buffer to our page list
  *     so that i will be freed when the HCD driver unloads
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PUHCD_PAGE_LIST_ENTRY pageListEntry;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    NoDMABuffer -= sizeof(UHCD_PAGE_LIST_ENTRY);

    pageListEntry =
        (PUHCD_PAGE_LIST_ENTRY) NoDMABuffer;

    // just mark it free
    pageListEntry->Flags = UHCD_NO_DMA_BUFFER_FREE;

}


PUCHAR
UHCD_Alloc_NoDMA_Buffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN ULONG Length
    )
 /* ++
  *
  * Description:
  *
  *     This function adds a No DMA buffer to our page list
  *     so that i will be freed when the HCD driver unloads
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PUHCD_PAGE_LIST_ENTRY pageListEntry;
    PUCHAR noDMABuffer;
    PHYSICAL_ADDRESS logicalAddress;
    PUCHAR baseVirtualAddress = NULL;
    PDEVICE_EXTENSION deviceExtension;
    PLIST_ENTRY listEntry;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    UHCD_KdPrint((2, "'page list size = %d\n", sizeof(UHCD_PAGE_LIST_ENTRY)));
    UHCD_ASSERT(sizeof(UHCD_PAGE_LIST_ENTRY) == 32);

    noDMABuffer = NULL;
    Length+=sizeof(UHCD_PAGE_LIST_ENTRY);

    // first see if we have a buffer we can use

    // walk the list, see if there is a free double_buffer entry

    listEntry = &deviceExtension->PageList;
    if (!IsListEmpty(listEntry)) {
        listEntry = deviceExtension->PageList.Flink;
    }

    while (listEntry != &deviceExtension->PageList) {

        pageListEntry = (PUHCD_PAGE_LIST_ENTRY) CONTAINING_RECORD(
                    listEntry,
                    struct _UHCD_PAGE_LIST_ENTRY,
                    ListEntry);

        LOGENTRY(LOG_MISC, 'ple>', 0 , pageListEntry->Length, pageListEntry);

        if (pageListEntry->Flags == UHCD_NO_DMA_BUFFER_FREE &&
            pageListEntry->Length >= Length) {

            UHCD_KdPrint((2, "'re-use page list\n"));
            baseVirtualAddress = (PUCHAR) pageListEntry;
            break;
        }

        listEntry = pageListEntry->ListEntry.Flink;
    }

    if (baseVirtualAddress) {

        // mark it used
        pageListEntry->Flags = UHCD_NO_DMA_BUFFER_USED;
        logicalAddress = pageListEntry->LogicalAddress;
        Length = pageListEntry->Length;

        LOGENTRY(LOG_MISC, 'rUse', baseVirtualAddress , 0, pageListEntry);

        UHCD_ASSERT(baseVirtualAddress == (PUCHAR) pageListEntry);

    }


    if (baseVirtualAddress == NULL) {

        // no buffer -- allocate one

        baseVirtualAddress =
            HalAllocateCommonBuffer(deviceExtension->AdapterObject,
                                    Length,
                                    &logicalAddress,
                                    TRUE);


        if (baseVirtualAddress != NULL) {

            pageListEntry =
                (PUHCD_PAGE_LIST_ENTRY) baseVirtualAddress;

            pageListEntry->Length = Length;
            pageListEntry->LogicalAddress = logicalAddress;
            pageListEntry->Flags = UHCD_NO_DMA_BUFFER_USED;


            // link it in
            InsertTailList(&deviceExtension->PageList,
                           &pageListEntry->ListEntry);

            LOGENTRY(LOG_MISC, 'Nple', 0 , 0, pageListEntry);

        }

    }

    if (baseVirtualAddress) {

        pageListEntry->Flags = UHCD_NO_DMA_BUFFER_USED;
        noDMABuffer = baseVirtualAddress + sizeof(UHCD_PAGE_LIST_ENTRY);
        Length -= sizeof(UHCD_PAGE_LIST_ENTRY);
        logicalAddress.LowPart += sizeof(UHCD_PAGE_LIST_ENTRY);

        Endpoint->NoDMABufferLength = Length;
       // Endpoint->NoDMALogicalAddress = logicalAddress;
        Endpoint->NoDMAPhysicalAddress = logicalAddress.LowPart;
    }

    return noDMABuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\hub.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    hub.c

Abstract:

    The UHC driver for USB, this module contains the root hub
    interface code.

Environment:

    kernel mode only

Notes:

Revision History:

    2-08-96 : created

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"

typedef struct _ROOT_HUB_TIMER {
    KTIMER Timer;
    KDPC Dpc;
    PDEVICE_OBJECT DeviceObject;
    PROOTHUB_TIMER_ROUTINE TimerRoutine;
    PVOID Context;
} ROOT_HUB_TIMER, *PROOT_HUB_TIMER;


NTSTATUS
UHCD_RootHub_OpenEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    This function is called at Dispatch level
    to process commands bound for the root hub.

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

    Urb - urb for this request

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_ENDPOINT endpoint;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor;

    UHCD_KdPrint((2, "'enter UHCD_RootHub_OpenEndpoint\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    LOGENTRY(LOG_MISC, 'rhOE', deviceExtension, 0, 0);

    endpoint = (PUHCD_ENDPOINT) GETHEAP(NonPagedPool,
                                         sizeof(UHCD_ENDPOINT));
    if (endpoint) {

        //
        // initialize endpoint structures, state variables.
        //

        // start endpoint initialization
        RtlZeroMemory(endpoint, sizeof(*endpoint));
        endpoint->Sig = SIG_EP;
        SET_EPFLAG(endpoint, EPFLAG_ROOT_HUB);

        endpointDescriptor = Urb->HcdUrbOpenEndpoint.EndpointDescriptor;
        endpoint->MaxRequests = MAX_REQUESTS(endpointDescriptor,
                                             endpoint->EndpointFlags);

        ntStatus = UHCD_FinishInitializeEndpoint(DeviceObject,
                                                 endpoint,
                                                 endpointDescriptor,
                                                 Urb);

        if (NT_SUCCESS(ntStatus)) {

            Urb->HcdUrbOpenEndpoint.HcdEndpoint = endpoint;
            URB_HEADER(Urb).Status = USBD_STATUS_SUCCESS;

            //
            // if this is the interrupt endpoint start a timer Dpc to be called
            // based on the endpoint polling interval.
            //

            if (endpoint->Type == USB_ENDPOINT_TYPE_INTERRUPT) {
                LARGE_INTEGER dueTime;
                LONG period;

                endpoint->Interval = endpointDescriptor->bInterval;
                UHCD_ASSERT(endpoint->Interval != 0);

                deviceExtension->RootHubInterruptEndpoint = endpoint;
                KeInitializeTimer(&deviceExtension->RootHubPollTimer);
                KeInitializeDpc(&deviceExtension->RootHubPollDpc,
                                UHCD_RootHubPollDpc,
                                DeviceObject);

		deviceExtension->RootHubPollTimerInitialized = TRUE;

                dueTime.QuadPart =  -10000 * endpoint->Interval;
                period = 100; //every 100 ms

                UHCD_KdPrint((2, "'UHCD Poll Interval = (0x%x) %x %x\n",
                    endpoint->Interval, dueTime.LowPart, dueTime.HighPart));

                KeSetTimerEx(&deviceExtension->RootHubPollTimer,
                             dueTime,
                             period,
                             &deviceExtension->RootHubPollDpc);

            }
        } else {
            RETHEAP(endpoint);
        }
    }

    UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);

    UHCD_KdPrint((2, "'exit UHCD_RootHub_OpenEndpoint (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
UHCD_RootHub_CloseEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    This function is called at Dispatch level
    to process commands bound for the root hub.

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

    Urb - urb for this request

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_ENDPOINT endpoint;

    UHCD_KdPrint((2, "'enter UHCD_RootHub_CloseEndpoint\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    endpoint = Urb->HcdUrbCloseEndpoint.HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);

    if (endpoint->ActiveTransfers[0]) {
        URB_HEADER(Urb).Status = USBD_STATUS_ERROR_BUSY;
    } else {

        if (endpoint == deviceExtension->RootHubInterruptEndpoint) {
            // closing the interrupt endpoint,
            // this means the root hub is stopped
            deviceExtension->RootHubDeviceAddress = USB_DEFAULT_DEVICE_ADDRESS;

            // if the timer fires before we cancel it then this
            // will stop the polling process
            deviceExtension->RootHubInterruptEndpoint = NULL;
            // if this is the interrupt endpoint kill the timer here
            KeCancelTimer(&deviceExtension->RootHubPollTimer);
        }

        RETHEAP(endpoint);

        URB_HEADER(Urb).Status = USBD_STATUS_SUCCESS;
    }

    UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);

    UHCD_KdPrint((2, "'exit UHCD_RootHub_CloseEndpoint (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
UHCD_RootHub_ControlTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    This function is called at Dispatch level
    to process commands bound for the root hub.

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

    Urb - urb for this request

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_ENDPOINT endpoint;
    RHSTATUS rootHubReturnCode;
    KIRQL irql;
    PVOID mappedSystemVa;

    UHCD_KdPrint((2, "'enter UHCD_RootHub_ControlTransfer\n"));

    INCREMENT_PENDING_URB_COUNT(Irp);

    IoAcquireCancelSpinLock(&irql);
    if (Irp->Cancel) {
        TEST_TRAP();
        //BUGBUG Irp was canceled
        IoReleaseCancelSpinLock(irql);
        UHCD_CompleteIrp(DeviceObject, Irp, STATUS_CANCELLED, 0, Urb);
        goto UHCD_RootHub_ControlTransfer_Done;

    } else {
        IoSetCancelRoutine(Irp, NULL);
        IoReleaseCancelSpinLock(irql);
    }

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    endpoint = HCD_AREA(Urb).HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);

    // NOTE:
    // should not get control transfers for anything but
    // the default pipe
    //

    UHCD_ASSERT(endpoint->EndpointAddress == 0);

    //BUGBUG no support for linked URBs yet
    UHCD_ASSERT(Urb->HcdUrbCommonTransfer.UrbLink == NULL);

    if (endpoint->EndpointAddress != 0) {
        URB_HEADER(Urb).Status = USBD_STATUS_INVALID_PARAMETER;
    } else {

        //
        // convert transfer buffer from MDL
        //
        mappedSystemVa =
            Urb->HcdUrbCommonTransfer.TransferBufferLength ?
                Urb->HcdUrbCommonTransfer.TransferBufferMDL->MappedSystemVa :
                NULL;

        //UHCD_KdPrint((2, "' Mapped systemVa = 0x%x \n", mappedSystemVa));
        rootHubReturnCode =
            RootHub_Endpoint0(deviceExtension->RootHub,
                              (PRH_SETUP)Urb->HcdUrbCommonTransfer.Extension.u.SetupPacket,
                              (PUCHAR) &deviceExtension->RootHubDeviceAddress,
                              mappedSystemVa,
                              &Urb->HcdUrbCommonTransfer.TransferBufferLength);

        switch (rootHubReturnCode) {
        case RH_SUCCESS:
            URB_HEADER(Urb).Status = USBD_STATUS_SUCCESS;
#if DBG
            // restore the original transfer buffer address
            Urb->HcdUrbCommonTransfer.TransferBuffer =
                mappedSystemVa;
#endif
            break;
        case RH_NAK:
        case RH_STALL:
            // return stall error and set the endpoint state to
            // stalled on the host side
            if (endpoint->EndpointFlags & EPFLAG_NO_HALT) {
                 URB_HEADER(Urb).Status =
                    USBD_STATUS(USBD_STATUS_STALL_PID)
                        | USBD_STATUS_ERROR;
            } else {
                SET_EPFLAG(endpoint, EPFLAG_HOST_HALTED);
                URB_HEADER(Urb).Status = USBD_STATUS_STALL_PID;
            }
            //
            // if we get here it is probably a bug in the root hub
            // code or the hub driver.
            //
            UHCD_KdTrap(("Root hub stalled request\n"));
        }
    }

    UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, Urb);

UHCD_RootHub_ControlTransfer_Done:

    UHCD_KdPrint((2, "'exit UHCD_RootHub_ControlTransfer (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
UHCD_RootHub_InterruptTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    This function is called at Dispatch level
    to process commands bound for the root hub.

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

    Urb - urb for this request

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_ENDPOINT endpoint;
    KIRQL irql;
    PHCD_EXTENSION urbWork;

    UHCD_KdPrint((2, "'enter UHCD_RootHub_InterruptTransfer\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    INCREMENT_PENDING_URB_COUNT(Irp);
    endpoint = HCD_AREA(Urb).HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);
    ASSERT(HCD_AREA(Urb).HcdExtension != NULL);

    urbWork = HCD_AREA(Urb).HcdExtension;
    // set interrupt transfer to active.
    urbWork->Flags |= UHCD_TRANSFER_ACTIVE;

    //
    // BUGBUG
    // we only allow one transfer outstanding
    // at a time here.
    //

    if (endpoint->ActiveTransfers[0] != NULL) {
        TEST_TRAP();

        URB_HEADER(Urb).Status = USBD_STATUS_REQUEST_FAILED;
        UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, Urb);

    } else if (Urb->HcdUrbCommonTransfer.UrbLink != NULL) {
        TEST_TRAP();

        URB_HEADER(Urb).Status = USBD_STATUS_INVALID_PARAMETER;
        UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, Urb);
    } else {
        endpoint->ActiveTransfers[0] = Urb;
        URB_HEADER(Urb).Status = UHCD_STATUS_PENDING_CURRENT;

        //
        // set up a cancel routine
        //

        IoAcquireCancelSpinLock(&irql);
        if (Irp->Cancel) {
            TEST_TRAP();
            //BUGBUG Irp was canceled
            IoReleaseCancelSpinLock(irql);

            // call cancel routine
            UHCD_RootHub_InterruptTransferCancel(DeviceObject, Irp);

            goto UHCD_RootHub_InterruptTransfer_Done;

        } else {
            IoSetCancelRoutine(Irp, UHCD_RootHub_InterruptTransferCancel);
            IoReleaseCancelSpinLock(irql);
        }

        ntStatus = STATUS_PENDING;

        UHCD_KdPrint((2, "'Pending transfer for root hub\n"));

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        IoMarkIrpPending(Irp);
    }

UHCD_RootHub_InterruptTransfer_Done:

    UHCD_KdPrint((2, "'exit UHCD_RootHub_InterruptTransfer (%x)\n", ntStatus));

    return ntStatus;
}


VOID
UHCD_RootHubPoll(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    This function is called at DPC level from the ISR DPC routine
    to process transfers queued to for the root hub.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NT status code.

--*/
{
    PHCD_URB urb;
    PDEVICE_EXTENSION deviceExtension;
    PIRP irp;
    RHSTATUS rootHubReturnCode;
    BOOLEAN completeIt = TRUE;
    KIRQL irql;
    PVOID mappedSystemVa;
    NTSTATUS status = STATUS_SUCCESS;

    //UHCD_KdPrint((2, "'enter UHCD_RootHub_Poll\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // See if we need to poll an endpoint for the
    // root hub.
    //
    // if the current PM state is not 'ON' we will not poll the endpoint
    // it means the HC has not fully resumed yet.
    //

    if (Endpoint &&
        deviceExtension->CurrentDevicePowerState == PowerDeviceD0) {

        // Yes, poll
        ASSERT_ENDPOINT(Endpoint);

        urb = Endpoint->ActiveTransfers[0];

        // see if we have an abort request
        if ((Endpoint->EndpointFlags & EPFLAG_ABORT_PENDING_TRANSFERS) && urb) {
            CLR_EPFLAG(Endpoint, EPFLAG_ABORT_PENDING_TRANSFERS);
            urb->HcdUrbCommonTransfer.Status =
                USBD_STATUS_CANCELED;
            completeIt = TRUE;
            // BUGBUG do we need the error bit set here?
        } else if (urb) {
            //
            // convert transfer buffer from MDL
            //


           if (urb->HcdUrbCommonTransfer.TransferBufferLength != 0) {
              urb->HcdUrbCommonTransfer.TransferBufferMDL->MdlFlags
                 |= MDL_MAPPING_CAN_FAIL;

              mappedSystemVa =
                 MmGetSystemAddressForMdl(urb->HcdUrbCommonTransfer
                                          .TransferBufferMDL);

              urb->HcdUrbCommonTransfer.TransferBufferMDL->MdlFlags
                 &= ~MDL_MAPPING_CAN_FAIL;

              if (mappedSystemVa == NULL) {
                 rootHubReturnCode = RH_STALL;
                 status = STATUS_INSUFFICIENT_RESOURCES;
                 goto UHCD_RootHubPollError;
              }
           } else{
              mappedSystemVa = NULL;
           }


            //UHCD_KdPrint((2, "' Mapped systemVa = 0x%x \n", mappedSystemVa));
            rootHubReturnCode =
                    RootHub_Endpoint1(deviceExtension->RootHub, mappedSystemVa,
                                      &urb->HcdUrbCommonTransfer
                                      .TransferBufferLength);
            //
            // set urb error code if necessary
            //

            switch (rootHubReturnCode) {
            case RH_SUCCESS:
                urb->HcdUrbCommonTransfer.Status = USBD_STATUS_SUCCESS;
#if DBG
                // restore the original transfer buffer address
                urb->HcdUrbCommonTransfer.TransferBuffer =
                    mappedSystemVa;
#endif
                break;

            case RH_STALL:
                if (Endpoint->EndpointFlags & EPFLAG_NO_HALT) {
                    // if we dont halt clear th ehalt bit on
                    // the error code
                    URB_HEADER(urb).Status =
                        USBD_STATUS(USBD_STATUS_STALL_PID) | USBD_STATUS_ERROR;
                } else {
                    SET_EPFLAG(Endpoint, EPFLAG_HOST_HALTED);
                    URB_HEADER(urb).Status = USBD_STATUS_STALL_PID;
                }
                //
                // if we get here it is probably a bug in the root hub code
                //
                UHCD_KdTrap(("root hub stalled request\n"));
                break;
            case RH_NAK:
                // NAK, don't complete request
                completeIt = FALSE;
                break;
            default:
                UHCD_KdTrap(("bogus return code from RootHub_Endpoint1\n"));
            }

        } else {
            // no transfer, same as NAK
            completeIt = FALSE;
        }

UHCD_RootHubPollError:;
        if (completeIt) {
            UHCD_ASSERT(urb != NULL);

            //
            // Remove the Irp from the cancelable state
            // before passing it to the Root Hub Code.
            //
            irp = HCD_AREA(urb).HcdIrp;

            IoAcquireCancelSpinLock(&irql);
            if (irp->Cancel) {
                TEST_TRAP();
                //BUGBUG Irp was canceled
                IoReleaseCancelSpinLock(irql);

                UHCD_RootHub_InterruptTransferCancel(DeviceObject, irp);

            } else {
                IoSetCancelRoutine(irp, NULL);
                IoReleaseCancelSpinLock(irql);
                //
                // have data or error, complete the irp
                //

                // BUGBUG we are not supporting queued
                // transfers for the hub driver.
                Endpoint->ActiveTransfers[0] = NULL;

                UHCD_ASSERT(irp != NULL);
                UHCD_CompleteIrp(DeviceObject,
                                 irp,
                                 status,
                                 0,
                                 urb);
            }
        }
    }

    //UHCD_KdPrint((2, "'exit UHCD_RootHub_Poll\n"));

    return;
}


//
// Root Hub Services
//
// These services are provided to the root
// hub code by UHCD.
//

USHORT
UHCD_RootHub_ReadPort(
    IN PROOTHUB_PORT HubPort
    )
/*++

Routine Description:

Arguments:

Return Value:

    returns the value of the requested hub
    register for a given controller identified
    by HcdPtr.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    USHORT dataVal;

    deviceExtension = HubPort->DeviceObject->DeviceExtension;

    dataVal = READ_PORT_USHORT(
        (PUSHORT) (deviceExtension->DeviceRegisters[0] +
                    HubPort->Address));

//    UHCD_KdPrint((2, "'RooHub -- read port %x\n", dataVal));

    return dataVal;
}


//BUGBUG need a return code here
VOID
UHCD_RootHub_Timer(
    IN PVOID HcdPtr,
    IN LONG WaitTime,
    IN PROOTHUB_TIMER_ROUTINE RootHubTimerRoutine,
    IN PVOID TimerContext
    )
/*++

Routine Description:

    This Routine can only be called at passive level,
    it iniializes a timer object and starts the timer
    for the root hub code.

Arguments:

    HcdPtr - pointer passed to the root hub code during
            initialization.

    WaitTime - time to wait before signaling (in ms)

    RootHubTimerRoutine - root hub function to call
                when timer expires.

    TimerContext - context pointer passed to RootHubTimerRoutine
                when timer expires.


Return Value:

    None

--*/
{
    PDEVICE_OBJECT deviceObject = HcdPtr;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER dueTime;
    PROOT_HUB_TIMER rootHubTimer;
    ULONG timerIncerent;

    deviceExtension = deviceObject->DeviceExtension;

    rootHubTimer = GETHEAP(NonPagedPool, sizeof(ROOT_HUB_TIMER));

    // compute timeout value (convert millisec to nanosec)

    UHCD_ASSERT(WaitTime == 10); // BUGBUG root hub should always use 10ms

    timerIncerent = KeQueryTimeIncrement() - 1;

    dueTime.HighPart = -1;
    // round up to the next highest timer increment
    dueTime.LowPart = -1 * (10000 * WaitTime + timerIncerent);

    if (rootHubTimer) {

        UHCD_KdPrint((2, "'roothub timer set %d (%x %x)\n", WaitTime,
            dueTime.LowPart, dueTime.HighPart));
        rootHubTimer->DeviceObject = deviceObject;
        rootHubTimer->TimerRoutine = RootHubTimerRoutine;
        rootHubTimer->Context = TimerContext;
        deviceExtension->RootHubTimersActive++;

//BUGBUG Timer DPCs not working with NTKERN
//#ifdef NTKERN
//#pragma message ("warning: using workaround for bugs in ntkern")
//        (VOID) KeDelayExecutionThread(KernelMode,
//                                      FALSE,
//                                      &dueTime);

//        UHCD_RootHubTimerDpc(&rootHubTimer->Dpc,
//                            rootHubTimer,
//                            NULL,
//                            NULL);

//#else
        KeInitializeTimer(&rootHubTimer->Timer);
        KeInitializeDpc(&rootHubTimer->Dpc,
                        UHCD_RootHubTimerDpc,
                        rootHubTimer);

        KeSetTimer(&rootHubTimer->Timer,
                   dueTime,
                   &rootHubTimer->Dpc);

//#endif
    }

}


VOID
UHCD_RootHubTimerDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies the RootHubTimer.

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PROOT_HUB_TIMER rootHubTimer = DeferredContext;
    PDEVICE_EXTENSION deviceExtension;

    UHCD_KdPrint((2, "'enter roothub timer Dpc\n"));

    deviceExtension = rootHubTimer->DeviceObject->DeviceExtension;

    //
    // call the root hub code callback
    //

    rootHubTimer->TimerRoutine(rootHubTimer->Context);

    UHCD_ASSERT(deviceExtension->RootHubTimersActive != 0);

    deviceExtension->RootHubTimersActive--;

    RETHEAP(rootHubTimer);
}


VOID
UHCD_RootHub_WritePort(
    IN PROOTHUB_PORT HubPort,
    IN USHORT DataVal
    )
/*++

Routine Description:

    This routine is called by the root hub code to perform
    writes to a specific HC register.

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = HubPort->DeviceObject->DeviceExtension;

    //
    // mask off bits 13:15 (see UHCI design guide)
    //

    DataVal &= 0x1fff;

//    UHCD_KdPrint((2, "'RooHub -- write port %x\n", DataVal));

    WRITE_PORT_USHORT(
        (PUSHORT) (deviceExtension->DeviceRegisters[0] +
            HubPort->Address), DataVal);
}


VOID
UHCD_RootHub_InterruptTransferCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is called to cancel at interrupt
    transfer request pending in the root hub code .

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:

    NT status code.

--*/
{

    PHCD_URB urb;
    PUHCD_ENDPOINT endpoint;

    UHCD_KdPrint((2, "'enter UHCD_RootHub_InterruptTransferCancel\n"));

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    urb = (PHCD_URB) URB_FROM_IRP(Irp);

    // BUGBUG we are not supporting queued
    // transfers for the hub driver.
    endpoint = HCD_AREA(urb).HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);
    endpoint->ActiveTransfers[0] = NULL;

    UHCD_CompleteIrp(DeviceObject,
                     Irp,
                     STATUS_CANCELLED,
                     0,
                     urb);

    UHCD_KdPrint((2, "'exit UHCD_RootHub_InterruptTransferCancel\n"));

}


VOID
UHCD_RootHubPollDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies the device object.

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT deviceObject = DeferredContext;
    PUHCD_ENDPOINT endpoint;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = deviceObject->DeviceExtension;
    endpoint = deviceExtension->RootHubInterruptEndpoint;

//    LOGENTRY(LOG_MISC, 'rhpX', deviceExtension, 0, 0);

    if (deviceExtension->InterruptObject) {
        UHCD_IsrDpc(
            NULL,
            DeferredContext,
            NULL,
            NULL);
    }

    UHCD_CheckIdle(deviceObject);

    if (endpoint == NULL ||
        (deviceExtension->HcFlags & HCFLAG_HCD_STOPPED)) {
        // root hub has been closed, no more polling
        // please.
        LOGENTRY(LOG_MISC, 'rhpS', deviceExtension, 0,
            deviceExtension->HcFlags);

        return;
    }

    ASSERT_ENDPOINT(endpoint);

    UHCD_RootHubPoll(deviceObject, endpoint);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\dbg.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    dbg.c

Abstract:

    Debug Code for UHCD.

Environment:

    kernel mode only

Notes:

Revision History:

    10-08-95 : created

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"

// debug compile defines
// DEBUG# sets the level of spew 0 = none
//                             > 2 turns on debug heap code
// NTKERN_TRACE  puts ' in the format buffer so that spew goes
// to ntkern buffer

#if DBG

// This turns the looping assert so that testers can't hit g
// past our assert before we can look at it.
// Win9x testers tend to do this but NT testers are conditioned not
// to so we only enable it for a DEBUG1 compile (win9x)
ULONG UHCD_Debug_Asserts =
#ifdef DEBUG1
1;
#else
0;
#endif

// this flag causes us to write a ' in the format string
// so that the string goes to the NTKERN buffer
// this trick causes problems with driver verifier on NT
// and the trace buffer isn't in NT anyway
ULONG UHCD_W98_Debug_Trace =
#ifdef NTKERN_TRACE
1;
#else
0;
#endif

// set the debug output spew level based on the DEBUG# define
// if compiled for W98 DEBUG1 is default
// if compiled for NT zero should be default
ULONG UHCD_Debug_Trace_Level =
#ifdef DEBUG3
#define DEBUG_HEAP
3;
#else
    #ifdef DEBUG2
    2;
    #else
        #ifdef DEBUG1
        1;
        #else
        0;
        #endif // DEBUG1
    #endif // DEBUG2
#endif // DEBUG3

LONG UHCD_TotalAllocatedHeapSpace = 0;


ULONG
_cdecl
UHCD_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[5];

    if (UHCD_Debug_Trace_Level >= l) {
        if (l <= 1) {
            // if flag is set override the '
            // so that the level 1 strings are
            // printed on the debugger terminal
            if (UHCD_W98_Debug_Trace) {
                DbgPrint("UHCD.SYS: ");
                *Format = ' ';
            } else {
                DbgPrint("'UHCD.SYS: ");
            }
        } else {
            DbgPrint("'UHCD.SYS: ");
        }
        va_start(list, Format);
        for (i=0; i<4; i++)
            arg[i] = va_arg(list, int);

        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3]);
    }

    return 0;
}

#if 0
ULONG
UHCD_DebugCommand(
    IN ULONG Command,
    IN ULONG Paramater1
    )
/*++

Routine Description:

    This routine performs a specific debug function.

Arguments:

    Command - debug function


Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    USBD_STATUS status = USBD_STATUS_SUCCESS;

    switch (Command) {
//    case DBG_DUMP_FRAME_LIST:

        break;
    default:
        status = USBD_STATUS_INVALID_PARAMETER;
    }

    return status;
}
#endif


VOID
UHCD_Debug_DumpTD(
    IN struct _HW_TRANSFER_DESCRIPTOR *Transfer
    )
/*++

Routine Description:

    Dump a transfer descriptor to the debug terminal

Arguments:


Return Value:

--*/
{
    if (UHCD_Debug_Trace_Level < 3)
        return;

    UHCD_KdPrint((2, "'TD DESCRIPTOR @va %0x\n", Transfer));

    UHCD_KdPrint((2, "'TD ActualLength %0x\n", Transfer->ActualLength));
    UHCD_KdPrint((2, "'TD Reserved_1 %0x\n", Transfer->Reserved_1));
    UHCD_KdPrint((2, "'TD Active %0x\n", Transfer->Active));
    UHCD_KdPrint((2, "'TD StatusField %0x\n", Transfer->StatusField));
    UHCD_KdPrint((2, "'TD InterruptOnComplete %0x\n", Transfer->InterruptOnComplete));
    UHCD_KdPrint((2, "'TD ShortPacketDetect %0x\n", Transfer->ShortPacketDetect));
    UHCD_KdPrint((2, "'TD Isochronous %0x\n", Transfer->Isochronous));
    UHCD_KdPrint((2, "'TD LowSpeedControl %0x\n", Transfer->LowSpeedControl));
    UHCD_KdPrint((2, "'TD ErrorCounter %0x\n", Transfer->ErrorCounter));
    UHCD_KdPrint((2, "'TD ReservedMBZ %0x\n", Transfer->ReservedMBZ));
    UHCD_KdPrint((2, "'TD PID %0x\n", Transfer->PID));
    UHCD_KdPrint((2, "'TD Address %0x\n", Transfer->Address));
    UHCD_KdPrint((2, "'TD Endpoint %0x\n", Transfer->Endpoint));
    UHCD_KdPrint((2, "'TD RetryToggle %0x\n", Transfer->RetryToggle));
    UHCD_KdPrint((2, "'TD Reserved_2 %0x\n", Transfer->Reserved_2));
    UHCD_KdPrint((2, "'TD MaxLength %0x\n", Transfer->MaxLength));
}


VOID
UHCD_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{

assert_loop:

    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it
    // we only do thi sif the W98 DEBUG mode is set

    TRAP();
    if (UHCD_Debug_Asserts) {
       goto assert_loop;
    }

    return;
}

VOID
UHCD_CheckSystemBuffer(
    IN PUCHAR VirtualAddress,
    IN ULONG Length
    )
/*++

Routine Description:

    Verify that this virtual address points to physically
    contiguous memory.

Arguments:

    VirtualAddress - virtual address of the system buffer

    Length         - length of buffer

Return Value:


--*/
{
    UHCD_ASSERT(Length <= PAGE_SIZE);
    UHCD_ASSERT( ADDRESS_AND_SIZE_TO_SPAN_PAGES( VirtualAddress, Length ) <= 1 );
}

//
// tag buffer we use to mark heap blocks we allocate
//

typedef struct _HEAP_TAG_BUFFER {
    ULONG Sig;
    ULONG Length;
} HEAP_TAG_BUFFER, *PHEAP_TAG_BUFFER;


PVOID
UHCD_Debug_GetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since
    most NT debug functions are not supported by NTKERN.

Arguments:

    PoolType - pool type passed to ExAllocatePool

    NumberOfBytes - number of bytes for item

    Signature - four byte signature supplied by caller

    TotalAllocatedHeapSpace - pointer to variable where client stores
                the total accumulated heap space allocated.

Return Value:

    pointer to allocated memory

--*/
{
    PUCHAR p;
#ifdef DEBUG_HEAP
    ULONG *stk;
    PHEAP_TAG_BUFFER tagBuffer;

    // we call ExAllocatePoolWithTag but no tag will be added
    // when running under NTKERN

#ifdef _M_IX86
    _asm     mov stk, ebp
#endif

    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes + sizeof(HEAP_TAG_BUFFER),
                                       Signature);

    if (p) {
        tagBuffer = (PHEAP_TAG_BUFFER) p;
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;
        p += sizeof(HEAP_TAG_BUFFER);
        *TotalAllocatedHeapSpace += NumberOfBytes;
    }

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);
//    LOGENTRY(LOG_MISC, 'GetH', p, NumberOfBytes, stk[1] & 0x00FFFFFF);
#else
    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes,
                                       Signature);

#endif /* DEBUG_HEAP */
    return p;
}


VOID
UHCD_Debug_RetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since
    most NT debug functions are not supported by NTKERN.

Arguments:

    P - pointer to free

Return Value:

    none.

--*/
{
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER tagBuffer;
    ULONG *stk;

    UHCD_ASSERT(P != 0);

#ifdef _M_IX86
    _asm     mov stk, ebp
#endif

    tagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P  - sizeof(HEAP_TAG_BUFFER));

    *TotalAllocatedHeapSpace -= tagBuffer->Length;

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);
//    LOGENTRY(LOG_MISC, 'RetH', P, tagBuffer->Length, stk[1] & 0x00FFFFFF);

    UHCD_ASSERT(*TotalAllocatedHeapSpace >= 0);
    UHCD_ASSERT(tagBuffer->Sig == Signature);

    // fill the buffer with bad data
    RtlFillMemory(P, tagBuffer->Length, 0xff);
    tagBuffer->Sig = UHCD_FREE_TAG;

    // free the original block
    ExFreePool(tagBuffer);
#else
    ExFreePool(P);
#endif /* DEBUG_HEAP */
}


#if DBG
VOID
UHCD_PrintPowerMessage(
    PUCHAR Label,
    UCHAR MinorFunction
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code
--*/
{
    UHCD_KdPrint((2, "'(%s) ", Label));

    switch (MinorFunction) {
    case IRP_MN_WAIT_WAKE:
        UHCD_KdPrint((2, "'IRP_MN_WAIT_WAKE\n"));
        break;
    case IRP_MN_SET_POWER:
        UHCD_KdPrint((2, "'IRP_MN_SET_POWER\n"));
        break;
    case IRP_MN_QUERY_POWER:
        UHCD_KdPrint((2, "'IRP_MN_QUERY_POWER\n"));
        break;
    }
}

VOID
UHCD_PrintPnPMessage(
    PUCHAR Label,
    UCHAR MinorFunction
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code
--*/
{
    UHCD_KdPrint((2, "'(%s) ", Label));

    switch (MinorFunction) {
    case IRP_MN_START_DEVICE:
        UHCD_KdPrint((2, "'IRP_MN_START_DEVICE\n"));
        break;
    case IRP_MN_STOP_DEVICE:
        UHCD_KdPrint((2, "'IRP_MN_STOP_DEVICE\n"));
        break;
    case IRP_MN_REMOVE_DEVICE:
        UHCD_KdPrint((2, "'IRP_MN_REMOVE_DEVICE\n"));
        break;
    case IRP_MN_QUERY_STOP_DEVICE:
      UHCD_KdPrint((2, "'IRP_MN_QUERY_STOP_DEVICE\n"));
      break;
    case IRP_MN_CANCEL_STOP_DEVICE:
      UHCD_KdPrint((2, "'IRP_MN_CANCEL_STOP_DEVICE\n"));
      break;
    case IRP_MN_QUERY_REMOVE_DEVICE:
      UHCD_KdPrint((2, "'IRP_MN_QUERY_REMOVE_DEVICE\n"));
      break;
    case IRP_MN_CANCEL_REMOVE_DEVICE:
      UHCD_KdPrint((2, "'IRP_MN_CANCEL_REMOVE_DEVICE\n"));
      break;
    }
}
#endif


#endif /* DBG */

#ifdef DEBUG_LOG

KSPIN_LOCK LogSpinLock;

struct UHCD_LOG_ENTRY {
    ULONG        le_sig;          // Identifying string
    ULONG_PTR    le_info1;        // entry specific info
    ULONG_PTR    le_info2;        // entry specific info
    ULONG_PTR    le_info3;        // entry specific info
}; /* USBD_LOG_ENTRY */


struct UHCD_LOG_ENTRY *HcdLStart = 0;    // No log yet
struct UHCD_LOG_ENTRY *HcdLPtr;
struct UHCD_LOG_ENTRY *HcdLEnd;
#ifdef PROFILE
ULONG LogMask = LOG_PROFILE;
#else
ULONG LogMask = 0xFFFFFFFF;
#endif

VOID
UHCD_Debug_LogEntry(
    IN ULONG     Mask,
    IN ULONG     Sig,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
    )
/*++

Routine Description:

    Adds an Entry to UHCD log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

typedef union _SIG {
    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    } b;
    ULONG l;
} SIG, *PSIG;

    SIG sig, rsig;


    if (HcdLStart == 0) {
        return;
    }

    if ((Mask & LogMask) == 0) {
        return;
    }

    irql = KeGetCurrentIrql();
    if (irql < DISPATCH_LEVEL) {
        KeAcquireSpinLock(&LogSpinLock, &irql);
    } else {
        KeAcquireSpinLockAtDpcLevel(&LogSpinLock);
    }

    if (HcdLPtr > HcdLStart) {
        HcdLPtr -= 1;    // Decrement to next entry
    } else {
        HcdLPtr = HcdLEnd;
    }

    //RtlCopyMemory(HcdLPtr->le_name, Name, 4);
//    LPtr->le_ret = (stk[1] & 0x00ffffff) | (CurVMID()<<24);

    sig.l = Sig;
    rsig.b.Byte0 = sig.b.Byte3;
    rsig.b.Byte1 = sig.b.Byte2;
    rsig.b.Byte2 = sig.b.Byte1;
    rsig.b.Byte3 = sig.b.Byte0;

    HcdLPtr->le_sig = rsig.l;
    HcdLPtr->le_info1 = Info1;
    HcdLPtr->le_info2 = Info2;
    HcdLPtr->le_info3 = Info3;

    UHCD_ASSERT(HcdLPtr >= HcdLStart);

    if (irql < DISPATCH_LEVEL) {
        KeReleaseSpinLock(&LogSpinLock, irql);
    } else {
        KeReleaseSpinLockFromDpcLevel(&LogSpinLock);
    }

    return;
}


VOID
UHCD_LogInit(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:

Return Value:

    None.

--*/
{
#ifdef MAX_DEBUG
    ULONG logSize = 4096*6;
#else
    ULONG logSize = 4096*3;
#endif


    KeInitializeSpinLock(&LogSpinLock);

    HcdLStart = ExAllocatePoolWithTag(NonPagedPool,
                                      logSize,
                                      UHCD_TAG);

    if (HcdLStart) {
        HcdLPtr = HcdLStart;

        // Point the end (and first entry) 1 entry from the end of the segment
        HcdLEnd = HcdLStart + (logSize / sizeof(struct UHCD_LOG_ENTRY)) - 1;
    } else {
        TRAP();
    }

    return;
}

VOID
UHCD_LogFree(
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    if (HcdLStart) {
        ExFreePool(HcdLStart);
    }

    return;
}



VOID
UHCD_LogTD(
    IN ULONG s,
    IN PULONG p
    )
{
    LOGENTRY(LOG_MISC, s, p, 0, 0);
    LOGENTRY(LOG_MISC, s, *p, *(p+1), *(p+2));
    LOGENTRY(LOG_MISC, s, *(p+3), *(p+4), *(p+5));
}

#ifdef DEBUG_LOG_IO

#undef WRITE_PORT_USHORT
#undef WRITE_PORT_ULONG
#undef WRITE_PORT_UCHAR
#undef READ_PORT_USHORT
#undef READ_PORT_ULONG
#undef READ_PORT_UCHAR

USHORT
UhcdLogIoUshort(PUSHORT Port, USHORT Val, BOOLEAN Write)
{
   USHORT rval = 0;

   if (Write) {
      LOGENTRY(LOG_IO, 'WrUS', Port, (ULONG_PTR)Val & 0x0000ffff, 0);
      WRITE_PORT_USHORT(Port, Val);
   } else {
      rval = READ_PORT_USHORT(Port);
      LOGENTRY(LOG_IO, 'RdUS', Port, (ULONG_PTR)rval & 0x0000ffff, 0);
   }

   return rval;
}

ULONG
UhcdLogIoUlong(PULONG Port, ULONG Val, BOOLEAN Write)
{
   ULONG rval = 0;

   if (Write) {
      LOGENTRY(LOG_IO, 'WrUL', Port, Val, 0);
      WRITE_PORT_ULONG(Port, Val);
   } else {
      rval = READ_PORT_ULONG(Port);
      LOGENTRY(LOG_IO, 'RdUL', Port, rval, 0);
   }

   return rval;
}

UCHAR
UhcdLogIoUchar(PUCHAR Port, UCHAR Val, BOOLEAN Write)

{
   UCHAR rval = 0;

   if (Write) {
      LOGENTRY(LOG_IO, 'WrUC', Port, (ULONG_PTR)Val & 0x000000ff, 0);
      WRITE_PORT_UCHAR(Port, Val);
   } else {
      rval = READ_PORT_UCHAR(Port);
      LOGENTRY(LOG_IO, 'RdUC', Port, (ULONG_PTR)rval & 0x000000ff, 0);
   }

   return rval;
}

#endif // DEBUG_LOG_IO

#endif /* DEBUG_LOG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\transfer.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    transfer.c

Abstract:

    The module manages control type transactions on the USB.

Environment:

    kernel mode only

Notes:

Revision History:

    11-01-95 : created
    04-26-96 : linked urb support

--*/
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"

//
// Use the flag to force all pending transfers to complete
//

typedef USBD_STATUS UHCD_INIT_TRANSFER_ROUTINE(PDEVICE_OBJECT DeviceObject,
                                               PUHCD_ENDPOINT Endpoint,
                                               PHCD_URB Urb);

typedef USBD_STATUS UHCD_PROCESS_TRANSFER_ROUTINE(
                                              PDEVICE_OBJECT DeviceObject,
                                              PUHCD_ENDPOINT Endpoint,
                                              PHCD_URB Urb,
                                              PBOOLEAN Completed);


UHCD_INIT_TRANSFER_ROUTINE UHCD_InitializeAsyncTransfer;
UHCD_PROCESS_TRANSFER_ROUTINE UHCD_ProcessAsyncTransfer;

UHCD_INIT_TRANSFER_ROUTINE UHCD_InitializeIsochTransfer;
UHCD_PROCESS_TRANSFER_ROUTINE UHCD_ProcessIsochTransfer;

typedef struct _UHCD_TRANSFER_DISPATCH_ENTRY {
    UHCD_INIT_TRANSFER_ROUTINE *InitializeTransfer;
    UHCD_PROCESS_TRANSFER_ROUTINE *ProcessTransfer;
} UHCD_TRANSFER_DISPATCH_ENTRY;

UHCD_TRANSFER_DISPATCH_ENTRY TransferDispatchTable[4] =
{
    //Control
    UHCD_InitializeAsyncTransfer, UHCD_ProcessAsyncTransfer,
    //Isoch
    UHCD_InitializeIsochTransfer, UHCD_ProcessIsochTransfer,
    //Bulk
    UHCD_InitializeAsyncTransfer, UHCD_ProcessAsyncTransfer,
    //Interrupt
    UHCD_InitializeAsyncTransfer, UHCD_ProcessAsyncTransfer
};


VOID
UHCD_ValidateIsoUrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN OUT PHCD_URB Urb
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:

    None.


--*/
{

    ULONG currentBusFrame;
    LONG  offset;
    PDEVICE_EXTENSION deviceExtension;
    BOOLEAN late = FALSE;

    UHCD_ASSERT(Endpoint->Type == USB_ENDPOINT_TYPE_ISOCHRONOUS);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    currentBusFrame = UHCD_GetCurrentFrame(DeviceObject);
    LOGENTRY(LOG_ISO,'ISxf', 0, Urb, currentBusFrame);

    if (Urb->HcdUrbCommonTransfer.TransferFlags &
        USBD_START_ISO_TRANSFER_ASAP) {

        if (Endpoint->EndpointFlags & EPFLAG_VIRGIN) {
            UHCD_KdPrint((2, "'ASAP flag set for virgin pipe\n"));

            // No transfers on this endpoint yet, set the StartFrame
            // to the current bus frame, plus a latency factor.
            //
            Urb->UrbIsochronousTransfer.StartFrame =
                currentBusFrame + UHCD_ASAP_LATENCY;
        } else {
            UHCD_KdPrint((2, "'ASAP flag set for non-virgin pipe\n"));

            // There have been transfers on this endpoint already,
            // set the StartFrame to the next free frame for this
            // endpoint.
            //
            Urb->UrbIsochronousTransfer.StartFrame =
                Endpoint->CurrentFrame;
        }
    } else {

        // If the StartFrame is explicitly specified and there was
        // a previous transfer on this endpoint, make sure the specified
        // StartFrame does not overlap the last transfer.
        //
        if (!(Endpoint->EndpointFlags & EPFLAG_VIRGIN)) {
            offset = Urb->UrbIsochronousTransfer.StartFrame -
                     Endpoint->CurrentFrame;
            if (offset < 0) {
                UHCD_KdPrint((2, "'StartFrame overlap\n"));
                URB_HEADER(Urb).Status = USBD_STATUS_BAD_START_FRAME;
            }
        }
    }

    // Sanity check that the start frame is within a certain range
    // of the current bus frame

    UHCD_KdPrint((2, "'currentBusFrame = %d\n", currentBusFrame));

    offset = Urb->UrbIsochronousTransfer.StartFrame - currentBusFrame;

    if (offset < 0) {
        deviceExtension->IsoStats.LateUrbs++;
        late = TRUE;
        offset*=-1;

        // transfer was late count how may packets missed due
        // to tardyness
        deviceExtension->IsoStats.LateMissedCount += ((USHORT)offset);
    }

    if (late &&
        offset == (LONG) Urb->UrbIsochronousTransfer.NumberOfPackets) {
        deviceExtension->IsoStats.StaleUrbs++;
    }

    if (offset > USBD_ISO_START_FRAME_RANGE) {
        UHCD_KdPrint((2, "'StartFrame out of range\n"));
        URB_HEADER(Urb).Status = USBD_STATUS_BAD_START_FRAME;
    }

    // update our iso Stats
    if (offset == 0) {
        deviceExtension->IsoStats.LateUrbs++;
    } else if (offset == 1 && !late) {
        // client requests this transfer within 1ms
        deviceExtension->IsoStats.TransfersCF_1ms++;
    } else if (offset == 2 && !late) {
        // client requests this transfer within 2ms
        deviceExtension->IsoStats.TransfersCF_2ms++;
    } else if (offset <= 5 && !late) {
        // client requests this transfer within 5ms
        deviceExtension->IsoStats.TransfersCF_5ms++;
    }

    if (deviceExtension->IsoStats.SmallestUrbPacketCount == 0) {
        deviceExtension->IsoStats.SmallestUrbPacketCount =
            (USHORT) Urb->UrbIsochronousTransfer.NumberOfPackets;
    }

    if (Urb->UrbIsochronousTransfer.NumberOfPackets <
        deviceExtension->IsoStats.SmallestUrbPacketCount) {
        deviceExtension->IsoStats.SmallestUrbPacketCount =
            (USHORT) Urb->UrbIsochronousTransfer.NumberOfPackets;
    }

    if (Urb->UrbIsochronousTransfer.NumberOfPackets >
        deviceExtension->IsoStats.LargestUrbPacketCount) {
        deviceExtension->IsoStats.LargestUrbPacketCount =
            (USHORT) Urb->UrbIsochronousTransfer.NumberOfPackets;
    }

}


VOID
UHCD_Transfer_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Called for each transfer request on a control endpoint,    from the
    UHCD_StartIo routine.

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:

    None.

--*/
{
    PHCD_URB urb, urbtmp;
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_ENDPOINT endpoint;
    KIRQL irql;

    UHCD_KdPrint((2, "'enter UHCD_Transfer_StartIo\n"));

    //
    // initialize pending count now
    //

    PENDING_URB_COUNT(Irp) = 0;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Get the endpoint
    //

    urb = URB_FROM_IRP(Irp);

    endpoint = HCD_AREA(urb).HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);

    UHCD_EndpointWakeup(DeviceObject, endpoint);

    LOGENTRY(LOG_ISO, 'xSIO', 0, 0, 0);

    // If this is an iso transfer then see if we need to set the start frame
    //
    if (endpoint->Type == USB_ENDPOINT_TYPE_ISOCHRONOUS) {
        UHCD_ValidateIsoUrb(DeviceObject,
                            endpoint,
                            urb);

        if (URB_HEADER(urb).Status == USBD_STATUS_BAD_START_FRAME) {

            IoStartNextPacket(DeviceObject, FALSE);

            LOGENTRY(LOG_ISO,'BADf', 0, urb, 0);

            deviceExtension->IsoStats.BadStartFrame++;
            // NOTE: we only allow one urb per iso request
            // since we pended the original request bump
            // the pending count so we'll complete this request
            INCREMENT_PENDING_URB_COUNT(Irp);
            UHCD_CompleteIrp(DeviceObject, Irp, STATUS_SUCCESS, 0, urb);

            goto UHCD_Transfer_StartIo_Done;
        }

        // Advance the next free StartFrame for this endpoint to be the
        // frame immediately following the last frame of this transfer.
        //
        endpoint->CurrentFrame = urb->UrbIsochronousTransfer.StartFrame +
                                 urb->UrbIsochronousTransfer.NumberOfPackets;

        //
        // we lose our virginity when the first transfer starts
        //
        CLR_EPFLAG(endpoint, EPFLAG_VIRGIN);
    } else if (endpoint->Type == USB_ENDPOINT_TYPE_BULK) {
        //
        // turn on BW reclimation for bulk transfers
        //
        UHCD_BW_Reclimation(DeviceObject, TRUE);
    }

    //
    // check the endpoint state, if we are stalled we need
    // to refuse transfers.
    //

    if (endpoint->EndpointFlags & EPFLAG_HOST_HALTED) {

        //
        // mark all urbs submitted with an error
        //

        urbtmp = urb;

        do {

            INCREMENT_PENDING_URB_COUNT(Irp);
            urbtmp->HcdUrbCommonTransfer.Status =
                USBD_STATUS_ENDPOINT_HALTED;
            urbtmp = urbtmp->HcdUrbCommonTransfer.UrbLink;
#if DBG
            if (urbtmp) {
                TEST_TRAP();
            }
#endif
        } while (urbtmp);

        IoStartNextPacket(DeviceObject, FALSE);

        UHCD_CompleteIrp(DeviceObject, Irp, STATUS_SUCCESS, 0, urb);

        goto UHCD_Transfer_StartIo_Done;
    }


    if (endpoint->EndpointFlags & EPFLAG_FAST_ISO) {

        INCREMENT_PENDING_URB_COUNT(Irp);
        UHCD_ProcessFastIsoTransfer(DeviceObject,
                                    endpoint,
                                    Irp,
                                    urb);

        IoStartNextPacket(DeviceObject, FALSE);

        goto UHCD_Transfer_StartIo_Done;
    }

    //
    // Get exclusive access to the endpoint pending transfer
    // queue.
    //

    LOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'lck0');

    //
    // Insert all urbs that make up this request into
    // the transfer pending queue.
    //

    do {

        INCREMENT_PENDING_URB_COUNT(Irp);
        URB_HEADER(urb).Status = UHCD_STATUS_PENDING_QUEUED;

        InsertTailList(&endpoint->PendingTransferList,
                       &HCD_AREA(urb).HcdListEntry);

//#if DBG
//        if (urb->HcdUrbCommonTransfer.UrbLink) {
//            TEST_TRAP();
//        }
//#endif
        urb = urb->HcdUrbCommonTransfer.UrbLink;

    }  while (urb);

    //
    // release exclusive access to the endpoint pending list
    //

    UNLOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'ulk0');

    //
    // call the endpoint worker function to activate
    // any transfers if possible.
    //

    if (endpoint->EndpointFlags & EPFLAG_DBL_BUFFER) {
        UHCD_RequestInterrupt(DeviceObject, -2);
    } else {
        UHCD_EndpointWorker(DeviceObject, endpoint);
    }

    IoStartNextPacket(DeviceObject, FALSE);

UHCD_Transfer_StartIo_Done:

    UHCD_KdPrint((2, "'exit UHCD_Transfer_StartIo\n"));
}


VOID
UHCD_CompleteTransferDPC(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN LONG Slot
    )
/*++

Routine Description:

    Process a urb in the active list for an endpoint, complete if
    necessary and start more transfers.

    This routine is not reentrant for the same endpoint.

Arguments:

    DeviceObject - pointer to a device object.

    Endpoint - endpoint to check for completed transfers.

    Slot - endpoint active slot to process.

Return Value:


--*/
{
    PHCD_URB urb, urbtmp;
    BOOLEAN completed = FALSE;
    ULONG usbdStatus = USBD_STATUS_SUCCESS;
    PIRP irp = NULL;
    PDEVICE_EXTENSION deviceExtension;
    ULONG i;
    PVOID currentVa;
    PHCD_EXTENSION urbWork;
    KIRQL irql;

    //UHCD_KdPrint((2, "'enter UHCD_CompleteTransferDPC\n"));

    ASSERT_ENDPOINT(Endpoint);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Do we have an current transfer for this endpoint?
    //
    // if no the endpoint is 'idle' on the host end,
    // so we just exit.
    //
    // if yes then we need to see if we have completed
    // the transfer set, if we have then we complete the
    // urb and call EndpointWorker to start more transfers
    //

    //
    // ** BUGBUG
    // ** Optimization
    // an optimization we can add here is to remove
    // the endpoint from the endpoint list when it goes
    // idle -- we would then let the EndpointWorker
    // function actuvate it when more transfers get queued.
    //

    //
    // get the Transfer we are intetrested in
    //

    urb = Endpoint->ActiveTransfers[Slot];
    UHCD_ASSERT(urb != NULL);

    urbWork = HCD_AREA(urb).HcdExtension;

    // check the skip flag

    if (Endpoint->EndpointFlags & EPFLAG_ABORT_ACTIVE_TRANSFERS) {
        // clear the skip flag if we are in an abort scenario
        LOGENTRY(LOG_MISC, 'Cdfr', urb, urbWork, Slot);
        urbWork->Flags &= ~UHCD_TRANSFER_DEFER;
    }

    // check the skip flag
    if (urbWork->Flags & UHCD_TRANSFER_DEFER) {
        LOGENTRY(LOG_MISC, 'defr', urb, urbWork, Slot);
        return;
    }

    //
    // Determine if the current transfer request is finished.
    //

    UHCD_ASSERT(Endpoint->Type<=USB_ENDPOINT_TYPE_INTERRUPT);
    irp = HCD_AREA(urb).HcdIrp;

    //
    // If the urb is marked completed with an error then don't
    // bother calling the process routine.
    //
    // This will allow the process routine to mark additional
    // active urbs for completion.
    // This also allows the completion EndpointWorker routine
    // to complete any transfers that it could not initilaize.
    //
    if (USBD_ERROR(urb->HcdUrbCommonTransfer.Status)) {
        completed = TRUE;
        LOGENTRY(LOG_MISC, 'tErr', urb->HcdUrbCommonTransfer.Status, urb, 0);
    } else if (urbWork->Flags & UHCD_TRANSFER_ACTIVE) {
        usbdStatus =
            (TransferDispatchTable[Endpoint->Type].ProcessTransfer)
                (DeviceObject,
                 Endpoint,
                 urb,
                 &completed);
    }

    if (completed) { // current transfer completed

        ULONG userBufferLength;

        LOGENTRY(LOG_ISO,'xfrC', Endpoint, urb, usbdStatus);
        LOGENTRY(LOG_ISO,'xfr2', urb->HcdUrbCommonTransfer.Status, 0, 0);

        UHCD_ASSERT(urbWork->BytesTransferred <=
            urb->HcdUrbCommonTransfer.TransferBufferLength);

        userBufferLength = urb->HcdUrbCommonTransfer.TransferBufferLength;
        urb->HcdUrbCommonTransfer.TransferBufferLength =
            urbWork->BytesTransferred;

        //
        // free the map registers now along with common buffers used to
        // double buffer packets.
        //

        if (urbWork->NumberOfLogicalAddresses) {

            currentVa =
                MmGetMdlVirtualAddress(urb->HcdUrbCommonTransfer.
                    TransferBufferMDL);


            // Flush the DMA buffer.  If this was an IN transfer and the
            // transfer was double-buffered (e.g. original buffer was located
            // above 4GB on a PAE system) this will flush the DMA buffer back
            // to the original transfer buffer.
            //
            // IoFlushAdapterBuffers() should only be called once per call
            // to IoAllocateAdapterChannel()
            //
            IoFlushAdapterBuffers(deviceExtension->AdapterObject,
                                  urb->HcdUrbCommonTransfer.TransferBufferMDL,
                                  urbWork->MapRegisterBase,
                                  currentVa,
                                  urb->HcdUrbCommonTransfer.TransferBufferLength,
                                  DATA_DIRECTION_OUT(urb));

            for (i=0; i<urbWork->NumberOfLogicalAddresses; i++) {
                if (urbWork->LogicalAddressList[i].PacketMemoryDescriptor) {
                    // if this is an IN transfer then update the
                    // client buffer
                    ULONG copylen;

                    if (DATA_DIRECTION_IN(urb)) {
                        LOGENTRY(LOG_MISC, 'PAKd', Endpoint->MaxPacketSize,
                            urbWork->LogicalAddressList[i].PacketOffset,
                            urbWork->LogicalAddressList[i].
                                PacketMemoryDescriptor->VirtualAddress);
                        LOGENTRY(LOG_MISC, 'PAKd', 0,
                            currentVa,
                            (PUCHAR)urb->HcdUrbCommonTransfer.
                                TransferBufferMDL->MappedSystemVa);

                        // make sure we don't overrun the client buffer
                        copylen = userBufferLength -
                            urbWork->LogicalAddressList[i].PacketOffset;

                        if (copylen > Endpoint->MaxPacketSize) {
                            copylen = Endpoint->MaxPacketSize;
                        }

                        RtlCopyMemory((PUCHAR)urbWork->SystemAddressForMdl +
                            urbWork->LogicalAddressList[i].PacketOffset,
                            urbWork->LogicalAddressList[i].
                                PacketMemoryDescriptor->VirtualAddress,
                            copylen);

                    }

                    //
                    // free the packet buffer if we have one
                    //

                    UHCD_FreeCommonBuffer(DeviceObject,
                        urbWork->LogicalAddressList[i].
                            PacketMemoryDescriptor);

                }

                (PUCHAR) currentVa += urbWork->LogicalAddressList[i].Length;
            }

            IoFreeMapRegisters(deviceExtension->AdapterObject,
                               urbWork->MapRegisterBase,
                               urbWork->NumberOfMapRegisters);

            if (urbWork->Flags & UHCD_MAPPED_LOCKED_PAGES) {
                PMDL mdl;

                mdl = urb->HcdUrbCommonTransfer.TransferBufferMDL;
                urbWork->Flags &= ~UHCD_MAPPED_LOCKED_PAGES;
                if (mdl->MdlFlags &
                    (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL)) {
                    // MmUnmapLockedPages(urbWork->SystemAddressForMdl, mdl);
                }
            }
        }

        UHCD_KdPrint((2, "'Transfer Completed\n"));
        UHCD_KdPrint((2, "'Status = %x\n", usbdStatus));
        UHCD_KdPrint((2, "'TransferBufferLength = %x\n",
            urb->HcdUrbCommonTransfer.TransferBufferLength));


        deviceExtension->Stats.BytesTransferred +=
            urb->HcdUrbCommonTransfer.TransferBufferLength;

        deviceExtension->IsoStats.IsoBytesTransferred +=
            urb->HcdUrbCommonTransfer.TransferBufferLength;

        //
        // retire this transfer, give the TransferCancel routine a chance to
        // mark it.
        //

        LOCK_ENDPOINT_ACTIVE_LIST(Endpoint, irql);

        Endpoint->ActiveTransfers[Slot] = NULL;

        // bump the current xfer count
        Endpoint->CurrentXferId++;

        UNLOCK_ENDPOINT_ACTIVE_LIST(Endpoint, irql);

        //
        // check if we have an error.
        //
        // if an error occurred on this transfer we need to
        // retire this transfer along with any other linked
        // transfers (urbs) associated with the same irp.
        //

        if (USBD_ERROR(usbdStatus)) {

            if (USBD_HALTED(usbdStatus)) {
                //
                // error code indicates a condition that should halt
                // the endpoint.
                //
                // check the endpoint state bit, if the endpoint
                // is marked for NO_HALT then clear the halt bit
                // and proceed to cancel this transfer.

                if (Endpoint->EndpointFlags & EPFLAG_NO_HALT) {
                    //
                    // clear the halt bit on the usbdStatus code
                    //
                    usbdStatus = USBD_STATUS(usbdStatus) | USBD_STATUS_ERROR;
                } else {
                    //
                    // mark the endpoint as halted, when the client
                    // sends a reset we'll start processing with the
                    // next queued transfer.
                    //
                    SET_EPFLAG(Endpoint, EPFLAG_HOST_HALTED);
                    LOGENTRY(LOG_MISC, 'Hhlt', Endpoint, 0, 0);
                }
            }

            //
            // complete any additional urbs associated with this irp.
            //

            LOCK_ENDPOINT_PENDING_LIST(Endpoint, irql, 'lck1');

            //
            // mark active urbs so that they get retired
            //

            for (i=0; i<Endpoint->MaxRequests; i++) {

                urbtmp = Endpoint->ActiveTransfers[i];

                if (urbtmp != NULL &&
                    HCD_AREA(urbtmp).HcdIrp == irp) {

                    urbtmp->HcdUrbCommonTransfer.Status =
                        UHCD_STATUS_PENDING_XXX;
                    //
                    // BUGBUG need a way to pass the error thru
                    //
                    TEST_TRAP();
                }
            }

            //
            // remove urbs associated with this Irp from the pending list
            //

            urbtmp = UHCD_RemoveQueuedUrbs(DeviceObject, urb, irp);

            UNLOCK_ENDPOINT_PENDING_LIST(Endpoint, irql, 'ulk1');

            //
            // request an interrupt to process any active urbs that
            // need canceling
            //

            UHCD_RequestInterrupt(DeviceObject, -2);

            while (urbtmp) {
                //
                // complete all linked urbs with status
                // USBD_CANCELED
                //
                TEST_TRAP();
                urbtmp->HcdUrbCommonTransfer.Status = USBD_STATUS_CANCELED;

                UHCD_ASSERT(irp == HCD_AREA(urbtmp).HcdIrp);

                UHCD_CompleteIrp(DeviceObject,
                                 irp,
                                 STATUS_SUCCESS,
                                 0,
                                 urbtmp);

                urbtmp = urb->HcdUrbCommonTransfer.UrbLink;
            }

            //
            // complete the original request
            //

            urb->HcdUrbCommonTransfer.Status = usbdStatus;

            UHCD_ASSERT(irp != NULL);
            UHCD_CompleteIrp(DeviceObject,
                             irp,
                             STATUS_SUCCESS,
                             0,
                             urb);

            if (!(Endpoint->EndpointFlags & EPFLAG_HOST_HALTED)) {
                //
                // if the endpoint is not halted then advance to
                // the next queued transfer.
                //
                UHCD_EndpointWorker(DeviceObject, Endpoint);
            }

            goto UHCD_CompleteTransferDPC_Done;
        }

        //
        // since the transfer completed at least one slot is free
        // so call EndpointWorker to activate another transfer.
        //

        UHCD_EndpointWorker(DeviceObject, Endpoint);

        //
        // Now we complete the irp for the urb transfer request
        // that just finished.
        //

        urb->HcdUrbCommonTransfer.Status = usbdStatus;

        UHCD_ASSERT(irp != NULL);
        UHCD_CompleteIrp(DeviceObject,
                         irp,
                         STATUS_SUCCESS,
                         0,
                         urb);

    }  // completed == TRUE

UHCD_CompleteTransferDPC_Done:

    //UHCD_KdPrint((2, "'exit UHCD_CompleteTransferDPC\n"));

    return;
}


IO_ALLOCATION_ACTION
UHCD_StartDmaTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )
/*++

Routine Description:

    Begin a DMA transfer -- this is the adapter control routine called
    from IoAllocateAdapterChannel.

Arguments:

Return Value:

    see IoAllocateAdapterChannel

--*/
{
    PUHCD_ENDPOINT endpoint;
    PHCD_URB urb = Context;
    ULONG length, lengthMapped = 0;
    PHYSICAL_ADDRESS logicalAddress;
    PVOID currentVa;
    PDEVICE_EXTENSION deviceExtension;
    PHCD_EXTENSION urbWork;
    KIRQL irql;

    UHCD_KdPrint((2, "'enter UHCD_StartDmaTransfer\n"));
    UHCD_KdPrint((2, "'TransferBufferMDL = 0x%x Length = 0x%x\n",
            urb->HcdUrbCommonTransfer.TransferBufferMDL,
            urb->HcdUrbCommonTransfer.TransferBufferLength));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    // allow dma operations now
    KeAcquireSpinLock(&deviceExtension->HcDmaSpin, &irql);
    UHCD_ASSERT(deviceExtension->HcDma >= 0);
    deviceExtension->HcDma--;
    LOGENTRY(LOG_MISC, '2DM-', 0, 0, 0);
    KeReleaseSpinLock(&deviceExtension->HcDmaSpin, irql);

    UHCD_ASSERT(urb->HcdUrbCommonTransfer.TransferBufferMDL != 0);

    urbWork = HCD_AREA(urb).HcdExtension;
    urbWork->MapRegisterBase = MapRegisterBase;

    endpoint = HCD_AREA(urb).HcdEndpoint;

    currentVa =
        MmGetMdlVirtualAddress(urb->HcdUrbCommonTransfer.TransferBufferMDL);

    length = urb->HcdUrbCommonTransfer.TransferBufferLength;

    //
    // keep calling IoMapTransfer until we get Logical Addresses for
    // the entire clinet buffer
    //
    UHCD_ASSERT(!urbWork->NumberOfLogicalAddresses);

    do {

        // make sure we don't overrun the work area.
        UHCD_ASSERT(urbWork->NumberOfLogicalAddresses <=
            (urb->HcdUrbCommonTransfer.
                TransferBufferLength / PAGE_SIZE + 1));

        // first map the transfer buffer
        logicalAddress =
            IoMapTransfer(deviceExtension->AdapterObject,
                          urb->HcdUrbCommonTransfer.TransferBufferMDL,
                          MapRegisterBase,
                          currentVa,
                          &length,
                          DATA_DIRECTION_OUT(urb));
        // save the Logical Address and length
        UHCD_KdPrint((2, "'CurrentVa = 0x%x \n", currentVa));

        lengthMapped += length;
        (PUCHAR)currentVa += length;

        UHCD_KdPrint((2, "'IoMapTransfer length = 0x%x log address = 0x%x\n",
            length, logicalAddress.LowPart));

        //
        // update Urb work area with physical buffer addresses
        // that the HC can use.
        //
        urbWork->LogicalAddressList[urbWork->NumberOfLogicalAddresses].
            LogicalAddress = logicalAddress.LowPart;
        urbWork->LogicalAddressList[urbWork->NumberOfLogicalAddresses].
            Length = length;

        length = urb->HcdUrbCommonTransfer.TransferBufferLength -
            lengthMapped;

        urbWork->NumberOfLogicalAddresses++;
    } while (lengthMapped != urb->HcdUrbCommonTransfer.TransferBufferLength);

    //
    // Transfer is now ACTIVE.
    //

    urbWork->Flags |= UHCD_TRANSFER_MAPPED;

    UHCD_BeginTransfer(DeviceObject,
                       endpoint,
                       urb,
                       urbWork->Slot);

    UHCD_KdPrint((2, "'exit UHCD_StartDmaTransfer\n"));

    return DeallocateObjectKeepRegisters;
}


VOID
UHCD_InitializeDmaTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHCD_URB Urb,
    IN PUHCD_ENDPOINT Endpoint,
    IN LONG Slot,
    IN UCHAR XferId
    )
/*++

Routine Description:

    Sets up a DMA transfer, this routine performs the mapping necessary
    for the HC to access the physical memory asssociated with the transfer.

Arguments:

Return Value:

    see IoAllocateAdapterChannel

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PVOID currentVa;
    NTSTATUS ntStatus;
    PHCD_EXTENSION urbWork;

    UHCD_KdPrint((2, "'enter UHCD_InitializeDmaTransfer\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    urbWork = HCD_AREA(Urb).HcdExtension;
    urbWork->Slot = (UCHAR) Slot;
    urbWork->XferId = XferId;

    if (Urb->HcdUrbCommonTransfer.TransferBufferLength) {
        currentVa =
            MmGetMdlVirtualAddress(
                Urb->HcdUrbCommonTransfer.TransferBufferMDL);

        // save the number of map registers in our work area
        // since the transferBufferLength may get changed by the
        // time the URB completes
        urbWork->NumberOfMapRegisters =
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                currentVa,
                Urb->HcdUrbCommonTransfer.TransferBufferLength);

        UHCD_KdPrint((2, "'NumberOfMapRegistersRequired = 0x%x\n",
                        urbWork->NumberOfMapRegisters));

        KeFlushIoBuffers(Urb->HcdUrbCommonTransfer.TransferBufferMDL,
                         DATA_DIRECTION_IN(Urb),
                         TRUE);

        // first we'll need to map the MDL for this transfer
        LOGENTRY(LOG_MISC, 'AChn', Endpoint,
            urbWork->NumberOfMapRegisters, Urb);

        ntStatus =
            IoAllocateAdapterChannel(deviceExtension->AdapterObject,
                                     DeviceObject,
                                     urbWork->NumberOfMapRegisters,
                                     UHCD_StartDmaTransfer,
                                     Urb);

        if (!NT_SUCCESS(ntStatus)) {

            //
            // if error, mark the transfer complete with error
            // now -- the TransferCompleteDPC routine will pick it up
            // and complete it.
            //

            LOGENTRY(LOG_MISC, 'ChnE', Endpoint,
            urbWork->NumberOfMapRegisters, ntStatus);

            TEST_TRAP();
            // BUGBUG do we need another error for this in usbdi.h?
            URB_HEADER(Urb).Status = USBD_STATUS_REQUEST_FAILED;

            //
            // Trigger an interrupt to process the endpoint
            //

            UHCD_RequestInterrupt(DeviceObject, -2);
        }

    } else {
        KIRQL irql;
        //
        // zero length transfer means no buffers to map.
        // begin the transfer now.
        //

        // allow dma operations now
        KeAcquireSpinLock(&deviceExtension->HcDmaSpin, &irql);
        UHCD_ASSERT(deviceExtension->HcDma >= 0);
        deviceExtension->HcDma--;
        LOGENTRY(LOG_MISC, '1DM-', 0, 0, 0);
        KeReleaseSpinLock(&deviceExtension->HcDmaSpin, irql);


        //
        // Transfer is now ACTIVE.
        //
        urbWork->Flags |= UHCD_TRANSFER_MAPPED;

        UHCD_BeginTransfer(DeviceObject,
                           Endpoint,
                           Urb,
                           Slot);
    }

    UHCD_KdPrint((2, "'exit UHCD_InitializeDmaTransfer\n"));
}


VOID
UHCD_TransferCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is called to cancel a transfer request that has been
    processed by the startio routine and is in the pending list for an
    endpoint.

    The pending transfer queue for the endpoint looks like this:

    -------------  -------------  -------------  -------------  -------------
    |Urb {irp 1}|->|Urb {irp 1}|->|Urb {irp 2}|->|Urb {irp 2}|->|Urb {irp x}|
    -------------  -------------  -------------  -------------  -------------
                                       |               |
                      remove  --------------------------

    So if {irp 2} is canceled the we would have to remove multiple urbs
    from the chain.  The cnacel routine does this, then completes the Irp
    with STATUS_CANCELED.

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:

    NT status code.

--*/
{
    PHCD_URB urb;
    PUHCD_ENDPOINT endpoint;
    ULONG i;
    PDEVICE_OBJECT deviceObject;
    KIRQL irql;

    UHCD_KdPrint((2, "'enter UHCD_TransferCancel\n"));

    {
        PUSBD_EXTENSION de;
        de = DeviceObject->DeviceExtension;
        if (de->TrueDeviceExtension == de) {
            deviceObject = DeviceObject;
        } else {
            de = de->TrueDeviceExtension;
            deviceObject = de->HcdDeviceObject;
        }
    }

    LOGENTRY(LOG_MISC, 'TCan', Irp, deviceObject, 0);

    UHCD_ASSERT(Irp->Cancel == TRUE);

    urb = (PHCD_URB) URB_FROM_IRP(Irp);
    endpoint = HCD_AREA(urb).HcdEndpoint;

    if (((PHCD_EXTENSION)HCD_AREA(urb).HcdExtension)->Flags
        & UHCD_TRANSFER_ACTIVE) {
       //
       // This request is on the active list, so we just request
       // that TransferComplete cancels it for us.
       //

       urb->HcdUrbCommonTransfer.Status = UHCD_STATUS_PENDING_XXX;
       IoReleaseCancelSpinLock(Irp->CancelIrql);
       return;
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    LOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'lck2');

    urb = UHCD_RemoveQueuedUrbs(deviceObject, urb, Irp);

    UNLOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'ulk2');

    //
    // complete the urbs we removed from the pending list.
    //

    while (urb) {

        urb->HcdUrbCommonTransfer.Status = USBD_STATUS_CANCELED;

        //
        // Note: request will not be completed by this routine if
        // the cancel flag is set.
        //

#if DBG
        {
        PHCD_EXTENSION urbWork;
        urbWork = HCD_AREA(urb).HcdExtension;
        UHCD_ASSERT((urbWork->Flags & UHCD_TRANSFER_ACTIVE) == 0);
        }
#endif

        LOGENTRY(LOG_MISC, 'pCan', Irp, urb, 0);

        UHCD_CompleteIrp(deviceObject,
                        Irp,
                        STATUS_CANCELLED,
                        0,
                        urb);

        urb = urb->HcdUrbCommonTransfer.UrbLink;

    }

    //
    // NOTE: UHCD_CompleteIrp
    // will not complete the request if the cancel flag is set
    //

    if (PENDING_URB_COUNT(Irp) == 0) {

        //
        // All urbs for this request were in the pending
        // list so complete the irp now.
        //

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        USBD_CompleteRequest(Irp,
                             IO_NO_INCREMENT);

    }

    UHCD_KdPrint((2, "'exit UHCD_TransferCancel\n"));

}


VOID
UHCD_BeginTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb,
    IN ULONG Slot
    )
/*++

Routine Description:

    This routine actually starts the transfer, it sets up the TDs
    and puts them in the schedule.

Arguments:

Return Value:

    NT status code.

--*/
{
    PHCD_EXTENSION urbWork;
    USBD_STATUS usbdStatus;

    UHCD_KdPrint((2, "'enter UHCD_BeginTransfer\n"));

    ASSERT_ENDPOINT(Endpoint);
    UHCD_ASSERT(Endpoint == HCD_AREA(Urb).HcdEndpoint);

    UHCD_ASSERT(Endpoint->Type<=USB_ENDPOINT_TYPE_INTERRUPT);
    LOGENTRY(LOG_MISC, 'Bxfr', 0, Urb, 0);

    urbWork = HCD_AREA(Urb).HcdExtension;
    UHCD_ASSERT(urbWork->Flags & UHCD_TRANSFER_MAPPED);

    if (Urb->HcdUrbCommonTransfer.TransferBufferLength) {
        PMDL mdl;
        mdl = Urb->HcdUrbCommonTransfer.TransferBufferMDL;
        if (!(mdl->MdlFlags &
             (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL))) {
            urbWork->Flags |= UHCD_MAPPED_LOCKED_PAGES;
        }

        mdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;

        urbWork->SystemAddressForMdl = MmGetSystemAddressForMdl(mdl);

        //
        // CIMEXCIMEX - handle failure case
        //


        mdl->MdlFlags &= ~MDL_MAPPING_CAN_FAIL;

        ASSERTMSG("UHCD: SystemAddressForMdl -- MDL mapping failed",
                  urbWork->SystemAddressForMdl != NULL);

    } else {
        urbWork->SystemAddressForMdl = NULL;
    }
// BUGBUG
// verify that the request has not been canceled.

    if (Endpoint->Type != USB_ENDPOINT_TYPE_ISOCHRONOUS &&
        Endpoint->CurrentXferId != urbWork->XferId &&
        Endpoint->MaxRequests >1) {
        // set the defer flag
        LOGENTRY(LOG_MISC, 'sDFR', Endpoint->MaxRequests, urbWork,
            Endpoint->CurrentXferId);

        urbWork->Flags |= UHCD_TRANSFER_DEFER;
    }


    usbdStatus =
        (TransferDispatchTable[Endpoint->Type].InitializeTransfer)(
            DeviceObject,
            Endpoint,
            Urb);

    UHCD_KdPrint((2, "'New Transfer\n"));
    UHCD_KdPrint((2, "'TransferBufferLength = 0x%x\n",
        Urb->HcdUrbCommonTransfer.TransferBufferLength ));
    UHCD_KdPrint((2, "'TransferFlags = 0x%x\n",
        Urb->HcdUrbCommonTransfer.TransferFlags ));
    UHCD_KdPrint((2, "'MappedSystemAddress = 0x%x\n",
        urbWork->SystemAddressForMdl));

    //
    // start the transfer by linking the first TD to the
    // QUEUE head
    //

     if (USBD_ERROR(usbdStatus)) {
        //
        // An error occurred setting up the transfer set an error in the urb
        // so the next time the completion routine is called we'll complete
        // the request.
        //

        TEST_TRAP();

        URB_HEADER(Urb).Status = usbdStatus;
    } else {
// BUGBUG
// this won't work if we have mutiple requests
// for a non-isoch endpoint

        //
        // this transfer id is now current
        //

        if (Endpoint->MaxRequests == 1) {

            // maxRequests == 1 is the old codepath
            UHCD_ASSERT(Endpoint->Type != USB_ENDPOINT_TYPE_ISOCHRONOUS);
            UHCD_ASSERT(Endpoint->CurrentXferId == urbWork->XferId);

            Endpoint->QueueHead->HW_VLink =
                Endpoint->TDList->TDs[0].PhysicalAddress;

        }  else {
            //bugbug leave iso alone for now
            if (Endpoint->Type != USB_ENDPOINT_TYPE_ISOCHRONOUS) {

                // if this transfer is now current we need to muck with
                // the queue head, the TDs are already set up

                if (Endpoint->CurrentXferId == urbWork->XferId) {

                    UHCD_ASSERT(!(urbWork->Flags & UHCD_TRANSFER_DEFER));
                    // update the endpoints TDList
                    // slot id corresponds to TD list
                    LOGENTRY(LOG_MISC, 'mkCU', Endpoint->CurrentXferId, urbWork->Slot,
                            Urb);

                    Endpoint->TDList =
                         Endpoint->SlotTDList[urbWork->Slot];

                    // fix up the data toggle now if we need to
                    if (!(urbWork->Flags & UHCD_TOGGLE_READY)) {
                         UHCD_FixupDataToggle(
                                     DeviceObject,
                                     Endpoint,
                                     Urb);
                    }

                    Endpoint->QueueHead->HW_VLink =
                        Endpoint->TDList->TDs[0].PhysicalAddress;
                } else {
                    // we cant start this transfer becuse it is not
                    // current yet -- just leave it in the slot for now

                    LOGENTRY(LOG_MISC, 'xRDY', Endpoint->CurrentXferId, urbWork->Slot,
                            Endpoint->SlotTDList[urbWork->Slot]);

                    UHCD_ASSERT(urbWork->Flags & UHCD_TRANSFER_INITIALIZED);
                }
            }
        }
    }

    //
    // Completion routine will now process this transfer.
    //

    urbWork->Flags |= UHCD_TRANSFER_ACTIVE;

    UHCD_KdPrint((2, "'exit UHCD_BeginTransfer\n"));
}


PHCD_URB
UHCD_RemoveQueuedUrbs(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHCD_URB Urb,
    IN PIRP Irp
    )
/*++

Routine Description:

    Removes Urbs associated with a given irp from the pending queue.

    NOTE: The endpoint must be held before calling this routine.

Arguments:

Return Value:

    NT status code.

--*/
{
    PHCD_URB urb, prevUrb, nextUrb, parentUrb = NULL;
    PLIST_ENTRY listEntry, nextUrbLink, prevUrbLink;
    PUHCD_ENDPOINT endpoint;

    UHCD_KdPrint((2, "'enter UHCD_RemoveQueuedUrbs\n"));

    endpoint = HCD_AREA(Urb).HcdEndpoint;

    //
    // we need to walk through the list of Urbs
    // queued for this endpoint, any urbs associated
    // with this irp must be removed.
    //

    ASSERT_ENDPOINT(endpoint);

    listEntry = &endpoint->PendingTransferList;
    if (!IsListEmpty(listEntry)) {
        listEntry = endpoint->PendingTransferList.Flink;
    }

    while (listEntry != &endpoint->PendingTransferList) {
        urb = (PHCD_URB) CONTAINING_RECORD(listEntry,
                                           struct _URB_HCD_COMMON_TRANSFER,
                                           hca.HcdListEntry);

        if (HCD_AREA(urb).HcdIrp == Irp) {

            parentUrb = urb;

            //
            // found the first Urb associated with
            // this Irp
            //

            prevUrbLink = HCD_AREA(urb).HcdListEntry.Blink;

            //
            // Find the last Urb associated with this irp
            // so we can remove the whole chain
            //

            while (urb->HcdUrbCommonTransfer.UrbLink != NULL) {
                // yes, we are finished unlinking
                urb = urb->HcdUrbCommonTransfer.UrbLink;
            }

            nextUrbLink = HCD_AREA(urb).HcdListEntry.Flink;

            //
            // we have found the group of URBs associated with this Irp
            // it is now time to remove them.
            //

            if (nextUrbLink != &endpoint->PendingTransferList) {
                // this is not the last one
                nextUrb = (PHCD_URB) CONTAINING_RECORD(
                    nextUrbLink,
                    struct _URB_HCD_COMMON_TRANSFER,
                    hca.HcdListEntry);

                UHCD_ASSERT(HCD_AREA(nextUrb).HcdIrp != Irp);

                HCD_AREA(nextUrb).HcdListEntry.Blink =
                    prevUrbLink;
            } else {
                // this is the last one
                endpoint->PendingTransferList.Blink =
                    prevUrbLink;
            }

            if  (prevUrbLink != &endpoint->PendingTransferList) {
                prevUrb = (PHCD_URB) CONTAINING_RECORD(
                    prevUrbLink,
                    struct _URB_HCD_COMMON_TRANSFER,
                    hca.HcdListEntry);

                UHCD_ASSERT(HCD_AREA(prevUrb).HcdIrp != Irp);

                HCD_AREA(prevUrb).HcdListEntry.Flink =
                    nextUrbLink;
            } else {
                endpoint->PendingTransferList.Flink =
                    nextUrbLink;
            }

            break;
        }

        listEntry = HCD_AREA(urb).HcdListEntry.Flink;
    }

    UHCD_KdPrint((2, "'exit UHCD_RemoveQueuedUrbs 0x%x\n", parentUrb));

    return parentUrb;
}


VOID
UHCD_EndpointWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Main worker function for an endpoint.

    Called at DPC level - either call the DMA routine or
    the non DMA version as appropriate.

Arguments:

Return Value:

    None.

--*/
{
    if (Endpoint->EndpointFlags & EPFLAG_DBL_BUFFER) {
        LOGENTRY(LOG_MISC, 'nDMA', 0, Endpoint, 0);
        UHCD_EndpointNoDMAWorker(DeviceObject,
                                 Endpoint);
    } else {
        LOGENTRY(LOG_MISC, 'yDMA', 0, Endpoint, 0);
        UHCD_EndpointDMAWorker(DeviceObject,
                               Endpoint);
    }
}


VOID
UHCD_EndpointDMAWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Main worker function for an endpoint.

    Called at DPC level -- this routine activates any transfers for an
    endpoint if possible by removing them from the pending queue and
    initializing them.

    Since EndpointWorker calls IoMapTransfer it cannot be reentered so
    we set a flag to allow it to only run on one processor at a time.

Arguments:

Return Value:

    None.

--*/
{
    PLIST_ENTRY listEntry;
    PHCD_URB urb;
    LONG slot, i;
    KIRQL irql;
    PHCD_EXTENSION urbWork;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    UHCD_KdPrint((2, "'enter UHCD_EndpointWorker\n"));

    // see if this endpoint is Halted, if so
    // there is no need to check the DMA lock

    if (Endpoint->EndpointFlags & EPFLAG_HOST_HALTED) {
        //
        // if the endpoint is halted then perform no
        // processing.
        //
#ifdef MAX_DEBUG
        TEST_TRAP();
#endif
        // allow DMA processing
        LOGENTRY(LOG_MISC, 'Hhlt', 0, Endpoint, 0);
        goto UHCD_EndpointWorker_Done;
    }

UHCD_EndpointWorker_NextTransfer:

    // attempt to take the DMA lock

    KeAcquireSpinLock(&deviceExtension->HcDmaSpin, &irql);
    deviceExtension->HcDma++;

    LOGENTRY(LOG_MISC, '3DM+', 0, 0, 0);

    if (deviceExtension->HcDma) {
        // dma lock is already held, mark the
        // endpoint so we process it later

        SET_EPFLAG(Endpoint, EPFLAG_HAVE_WORK);
        UHCD_ASSERT(deviceExtension->HcDma >= 0);
        deviceExtension->HcDma--;
        LOGENTRY(LOG_MISC, '4DM-', 0, 0, 0);
        KeReleaseSpinLock(&deviceExtension->HcDmaSpin, irql);
        LOGENTRY(LOG_MISC, 'Dbz1', 0, Endpoint, 0);
        // busy, bail
        goto UHCD_EndpointWorker_Done;
    }

    LOGENTRY(LOG_MISC, 'CHAN', 0, 0, 0);

    // got the lock, process the transfer

    CLR_EPFLAG(Endpoint, EPFLAG_HAVE_WORK);
    KeReleaseSpinLock(&deviceExtension->HcDmaSpin, irql);


    LOCK_ENDPOINT_ACTIVE_LIST(Endpoint, irql);
    LOGENTRY(LOG_MISC, 'lka1', 0, Endpoint, 0);

    //
    // find an open slot
    //

    slot = -1;

    for (i=0; i<Endpoint->MaxRequests; i++) {

        if (Endpoint->ActiveTransfers[i] == NULL) {

            //
            // dequeue the next urb we want to start
            //

            LOCK_ENDPOINT_PENDING_LIST(Endpoint, irql, 'lck3');

            if (IsListEmpty(&Endpoint->PendingTransferList)) {
                //
                // pending list is empty, reset the abort pending
                // tranfers bit now -- this will allow a reset.
                //
                CLR_EPFLAG(Endpoint,
                           EPFLAG_ABORT_PENDING_TRANSFERS);
            } else {

               KIRQL cancelIrql;
               PIRP pIrp;

               IoAcquireCancelSpinLock(&cancelIrql);

               pIrp
                  = HCD_AREA((PHCD_URB)
                    CONTAINING_RECORD(Endpoint->PendingTransferList.Flink,
                                      struct _URB_HCD_COMMON_TRANSFER,
                                      hca.HcdListEntry)).HcdIrp;

               if (pIrp->Cancel) {
                  //
                  // Uh-oh, this IRP is being cancelled; we'll let the
                  // cancel routine finish the job.  Leave it on the list.
                  //

                  IoReleaseCancelSpinLock(cancelIrql);
                  UNLOCK_ENDPOINT_PENDING_LIST(Endpoint, irql, 'ulk7');
                  continue;
               }

                listEntry = RemoveHeadList(&Endpoint->PendingTransferList);

                IoReleaseCancelSpinLock(cancelIrql);

                slot = i;

                urb = (PHCD_URB) CONTAINING_RECORD(
                    listEntry,
                    struct _URB_HCD_COMMON_TRANSFER,
                    hca.HcdListEntry);

                LOGENTRY(LOG_MISC, 'dqXF', urb, slot, 0);

                URB_HEADER(urb).Status = UHCD_STATUS_PENDING_CURRENT;
            }

            UNLOCK_ENDPOINT_PENDING_LIST(Endpoint, irql, 'ulk3');

            //
            // found a transfer, start it
            //

            break;
        }
    }

    if (slot != -1) {

        //
        // we have a transfer, start it.
        //

        UHCD_KdPrint((2, "'Starting Next Queued Transfer\n"));

        //
        // AbortPendingTransfers - indicates that all transfers in the
        // pending queue should be canceled.
        //
        // If the abort flag is set then we just complete the queued
        // transfer here.
        //

        if (Endpoint->EndpointFlags & EPFLAG_ABORT_PENDING_TRANSFERS) {

            LOGENTRY(LOG_MISC, 'abrP', Endpoint, 0, urb);

            // release the DMA lock now
            KeAcquireSpinLock(&deviceExtension->HcDmaSpin, &irql);
            UHCD_ASSERT(deviceExtension->HcDma >= 0);
            deviceExtension->HcDma--;
            LOGENTRY(LOG_MISC, '5DM-', 0, 0, 0);
            KeReleaseSpinLock(&deviceExtension->HcDmaSpin, irql);

            //
            // release exclusive access.
            //

            UNLOCK_ENDPOINT_ACTIVE_LIST(Endpoint, irql);
            LOGENTRY(LOG_MISC, 'uka1', 0, Endpoint, 0);

            URB_HEADER(urb).Status = USBD_STATUS_CANCELED;

            UHCD_CompleteIrp(DeviceObject,
                             HCD_AREA(urb).HcdIrp,
                             STATUS_CANCELLED,
                             0,
                             urb);
        } else {

            UCHAR xferId;
            //
            // Urb is now in the active list.
            //

            urbWork = HCD_AREA(urb).HcdExtension;

            //
            // initialize worker flags
            //

            // give the transfer a sequence number
            xferId = Endpoint->NextXferId;
            Endpoint->NextXferId++;

            Endpoint->ActiveTransfers[slot] = urb;

            //
            // release exclusive access.
            //

            UNLOCK_ENDPOINT_ACTIVE_LIST(Endpoint, irql);
            LOGENTRY(LOG_MISC, 'uka2', 0, Endpoint, 0);

            UHCD_InitializeDmaTransfer(DeviceObject, urb, Endpoint, slot, xferId);
        }

        // next transfer will attempt to grab the DMA lock again
        // if the lock was released by InitializeDMAtransfer
        // then we will be able to handle another transfer

        goto  UHCD_EndpointWorker_NextTransfer;

    } else {

        //
        // no free slots, release the DMA lock
        //

        KeAcquireSpinLock(&deviceExtension->HcDmaSpin, &irql);
        UHCD_ASSERT(deviceExtension->HcDma >= 0);
        deviceExtension->HcDma--;
       LOGENTRY(LOG_MISC, '6DM-', 0, 0, 0);
       KeReleaseSpinLock(&deviceExtension->HcDmaSpin, irql);
    }

    UNLOCK_ENDPOINT_ACTIVE_LIST(Endpoint, irql);
    LOGENTRY(LOG_MISC, 'uka3', 0, Endpoint, 0);

UHCD_EndpointWorker_Done:

    UHCD_KdPrint((2, "'exit UHCD_EndpointWorker\n"));

    return;
}


VOID
UHCD_EndpointIdle(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    See if this endpoint has been idle for a while.
    if so pull it from the schedule

Arguments:

Return Value:

    None.

--*/
{
    LARGE_INTEGER timeNow;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    KIRQL irql;
#if DBG
    ULONG slot;
#endif

    if (Endpoint->EndpointFlags & EPFLAG_IDLE) {
        // already idle
#if DBG
        for (slot=0; slot<Endpoint->MaxRequests; slot++) {
            UHCD_ASSERT(Endpoint->ActiveTransfers[slot] == NULL);
        }
#endif
        return;
    }

    if (Endpoint->Type != USB_ENDPOINT_TYPE_BULK) {
        // we only idle bulk endpoints
        return;
    }

    KeQuerySystemTime(&timeNow);

    if (Endpoint->IdleTime == 0) {
        LOGENTRY(LOG_MISC, 'Bid0', Endpoint->IdleTime, 0, Endpoint);
        KeQuerySystemTime(&Endpoint->LastIdleTime);
        Endpoint->IdleTime = 1;
    }

    LOGENTRY(LOG_MISC, 'Bid1', Endpoint->IdleTime, 0, Endpoint);

    Endpoint->IdleTime +=
        (LONG) (timeNow.QuadPart -
        Endpoint->LastIdleTime.QuadPart);
    Endpoint->LastIdleTime = timeNow;

    LOGENTRY(LOG_MISC, 'Bid2', Endpoint->IdleTime, 0, Endpoint);

    if (// 10 seconds in 100ns units
        Endpoint->IdleTime > 100000000) {

        KeAcquireSpinLock(&deviceExtension->HcScheduleSpin, &irql);

        SET_EPFLAG(Endpoint, EPFLAG_IDLE);
        LOGENTRY(LOG_MISC, 'Bid3', Endpoint->IdleTime, 0, Endpoint);

        // pull the ep from the schedule

        UHCD_KdPrint((0, "'Bulk Enpoint (%x) going idle\n", Endpoint));
//        TEST_TRAP();
#if DBG
        for (slot=0; slot<Endpoint->MaxRequests; slot++) {
            UHCD_ASSERT(Endpoint->ActiveTransfers[slot] == NULL);
        }

        UHCD_ASSERT(IsListEmpty(&Endpoint->PendingTransferList));
#endif

        UHCD_RemoveQueueHeadFromSchedule(DeviceObject,
                                         Endpoint,
                                         Endpoint->QueueHead,
                                         FALSE);

        KeReleaseSpinLock(&deviceExtension->HcScheduleSpin, irql);

    }
}


VOID
UHCD_EndpointWakeup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Wakeup an idle endpoint

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    KIRQL irql;

    Endpoint->IdleTime = 0;

    KeAcquireSpinLock(&deviceExtension->HcScheduleSpin, &irql);

    if (Endpoint->EndpointFlags & EPFLAG_IDLE) {
        UHCD_ASSERT(Endpoint->Type == USB_ENDPOINT_TYPE_BULK);

        LOGENTRY(LOG_MISC, 'Ewak', Endpoint, 0, Endpoint->EndpointFlags);
        UHCD_KdPrint((0, "'Bulk Enpoint (%x) wakeup\n", Endpoint));
//        TEST_TRAP();

        UHCD_InsertQueueHeadInSchedule(DeviceObject,
                                       Endpoint,
                                       Endpoint->QueueHead,
                                       0); // no offset

        CLR_EPFLAG(Endpoint, EPFLAG_IDLE);

    }

    KeReleaseSpinLock(&deviceExtension->HcScheduleSpin, irql);
}



#if DBG
VOID
UHCD_LockAccess(
    IN PULONG c
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    UHCD_ASSERT(*c == 0);

    (*c)++;
}


VOID
UHCD_UnLockAccess(
    IN PULONG c
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    UHCD_ASSERT(*c>0);

    (*c)--;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\isoch.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    isoch.c

Abstract:

    This module manages bulk, interrupt & control type
    transactions on the USB.

Environment:

    kernel mode only

Notes:

Revision History:

    2-15-95 : created

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"

typedef struct _UHCD_INSERTION_CONTEXT {
    PDEVICE_EXTENSION DeviceExtension;
    ULONG FrameNumber;
    PHW_TRANSFER_DESCRIPTOR TransferDescriptor;
} UHCD_INSERTION_CONTEXT, *PUHCD_INSERTION_CONTEXT;


BOOLEAN
UHCD_SyncInsertIsochDescriptor(
    IN PUHCD_INSERTION_CONTEXT InsertionContext
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    ULONG i;
    PDEVICE_EXTENSION deviceExtension =
        InsertionContext->DeviceExtension;
    ULONG frameNumber = InsertionContext->FrameNumber;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor =
        InsertionContext->TransferDescriptor;

    i = frameNumber % FRAME_LIST_SIZE;

    if (frameNumber <= deviceExtension->LastFrameProcessed) {
        //
        // we missed it just don't insert
        //
        goto UHCD_SyncInsertIsochDescriptor_Done;
    }

    // link to what is currently in the
    // frame
    transferDescriptor->HW_Link =
        *( ((PULONG) (deviceExtension->FrameListVirtualAddress) + i) );

    // now we are in the frame
    *( ((PULONG) (deviceExtension->FrameListVirtualAddress) + i) )  =
        transferDescriptor->PhysicalAddress;

#if DBG
    {
        ULONG length;

        length = *( deviceExtension->IsoList + i);

        length +=
            UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(transferDescriptor->MaxLength);

        *( deviceExtension->IsoList + i ) = length;

        // BUGBUG for iso debugging with camera only!!
//#ifdef MAX_DEBUG
//         UHCD_ASSERT(length <= 385);
//#endif
    }
#endif

    //
    // free our context info
    //
UHCD_SyncInsertIsochDescriptor_Done:

    return TRUE;
}


VOID
UHCD_InsertIsochDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHW_TRANSFER_DESCRIPTOR TransferDescriptor,
    IN ULONG FrameNumber
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    UHCD_INSERTION_CONTEXT insertionContext;
    PDEVICE_EXTENSION deviceExtension =
        DeviceObject->DeviceExtension;

    LOGENTRY(LOG_ISO,'iFrm', FrameNumber, &insertionContext,
        deviceExtension->LastFrameProcessed);


    insertionContext.DeviceExtension = DeviceObject->DeviceExtension;
    insertionContext.FrameNumber = FrameNumber;
    insertionContext.TransferDescriptor = TransferDescriptor;

    // we had better have an interrupt object
    UHCD_ASSERT(deviceExtension->InterruptObject != NULL);
    KeSynchronizeExecution(deviceExtension->InterruptObject,
                           UHCD_SyncInsertIsochDescriptor,
                           &insertionContext);

}


USBD_STATUS
UHCD_InitializeIsochTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    This routine initializes the TDs needed by the hardware
    to process this request, called from the AdapterControl
    function of from within TranferCompleteDPC.

    The transfer list for this URB should be ready for
    processing before returning from this routine.

Arguments:

    DeviceObject - pointer to a device object.

    Endpoint - Endpoint associated with this Urb.

    Urb - pointer to URB Request Packet for this transfer.

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PHCD_EXTENSION urbWork;
#if DBG
    ULONG i;
#endif

//    UHCD_KdPrint((2, "'enter UHCD_InitializeIsochTransfer\n"));

    ASSERT_ENDPOINT(Endpoint);

    LOGENTRY(LOG_ISO,'tISO', Endpoint, Urb, Urb->UrbIsochronousTransfer.StartFrame);

    deviceExtension = DeviceObject->DeviceExtension;

    urbWork = HCD_AREA(Urb).HcdExtension;
    LOGENTRY(LOG_ISO,'tISw', urbWork->Flags, Urb, urbWork->Slot);

    //
    // See if we have already initialized this urb
    //
    if (urbWork->Flags & UHCD_TRANSFER_INITIALIZED) {
        goto UHCD_InitializeIsochTransfer_Done;
    }

    //
    // make sure the transfer is mapped
    //
    if (!(urbWork->Flags & UHCD_TRANSFER_MAPPED)) {
        LOGENTRY(LOG_ISO,'nMpd', urbWork->Flags, Urb, 0);
        goto UHCD_InitializeIsochTransfer_Done;
    }

    if (Urb->UrbIsochronousTransfer.StartFrame >
        deviceExtension->LastFrameProcessed+1+FRAME_LIST_SIZE-1) {

        //
        // if the request is too far in the future to schedule
        // TDs then delay initialization, request an interrupt.
        // near a time when we can schedule this transfer.
        //

        UHCD_RequestInterrupt(DeviceObject, Urb->UrbIsochronousTransfer.StartFrame - 32);

        LOGENTRY(LOG_ISO,'erly', Urb->UrbIsochronousTransfer.StartFrame,
            deviceExtension->LastFrameProcessed, 0);


        goto UHCD_InitializeIsochTransfer_Done;
    }

    urbWork->Flags |= UHCD_TRANSFER_INITIALIZED;
    Endpoint->TdsScheduled[urbWork->Slot] = 0;

    //
    // initialize working space variables for this
    // transfer.
    //

    urbWork->CurrentPacketIdx =
        urbWork->BytesTransferred = 0;

    urbWork->PacketsProcessed = 0;

    Urb->UrbIsochronousTransfer.ErrorCount = 0;

#if DBG
    i = UHCD_GetCurrentFrame(DeviceObject);

    LOGENTRY(LOG_ISO,'bISO', i,  Urb->UrbIsochronousTransfer.StartFrame, DeviceObject);
    UHCD_KdPrint((2, "'IsochTransfer: start frame = 0x%x current frame = 0x%x\n",
        Urb->UrbIsochronousTransfer.StartFrame, i));

#endif

    UHCD_ScheduleIsochTransfer(DeviceObject,
                               Endpoint,
                               Urb);

UHCD_InitializeIsochTransfer_Done:

//    UHCD_KdPrint((2, "'exit UHCD_InitializeIsochTransfer\n"));

    return USBD_STATUS_SUCCESS;
}


VOID
UHCD_ScheduleIsochTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to a device object.

    Endpoint - Endpoint associated with this Urb.

    Urb - pointer to URB Request Packet for this transfer.

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PHCD_EXTENSION urbWork;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor;
    ULONG i, offset, length;
    ULONG nextPacket;
    PUHCD_TD_LIST urbTDList;

    //UHCD_KdPrint((2, "'enter UHCD_ScheduleIsochTransfer\n"));

    ASSERT_ENDPOINT(Endpoint);

    UHCD_ASSERT(Endpoint->Type == USB_ENDPOINT_TYPE_ISOCHRONOUS);
    UHCD_ASSERT(Endpoint->EndpointFlags & EPFLAG_NO_HALT);

    LOGENTRY(LOG_ISO,'sISO', Endpoint, Urb, DeviceObject);

    deviceExtension = DeviceObject->DeviceExtension;

    urbWork = HCD_AREA(Urb).HcdExtension;
    urbTDList = Endpoint->SlotTDList[urbWork->Slot];

    UHCD_ASSERT(urbWork->Flags & UHCD_TRANSFER_MAPPED);

    LOGENTRY(LOG_ISO,'sIS2', Endpoint, urbTDList, urbWork->Slot);

    //
    // If we are done with this transfer just exit
    //

    if (urbWork->CurrentPacketIdx ==
        Urb->UrbIsochronousTransfer.NumberOfPackets) {
        goto UHCD_ScheduleIsochTransfer_Done;
    }

    //
    // See if we can put any TDs into the schedule
    //

    for (i=0; i< Endpoint->TDCount; i++) {

        //
        // BUGBUG possibly attach TD list to URB
        // for now we share the TDs among mutiple active
        // requests.
        //
        transferDescriptor = &urbTDList->TDs[i];

        if (transferDescriptor->Frame == 0) {

            //
            // TD is not in use, go ahead and schedule it
            //

            LOGENTRY(LOG_ISO,'ISOc', Urb->UrbIsochronousTransfer.StartFrame,
                urbWork->CurrentPacketIdx, deviceExtension->LastFrameProcessed);

            // See if it is too early to set up this TD

            if (Urb->UrbIsochronousTransfer.StartFrame + urbWork->CurrentPacketIdx >
                deviceExtension->LastFrameProcessed+1+FRAME_LIST_SIZE-1) {
                LOGENTRY(LOG_ISO,'ISOd', 0, 0, 0);

                break;    // No, stop setting up TDs
            }

            // prepare the TD for this packet
            transferDescriptor->Active = 1;
            transferDescriptor->Endpoint = Endpoint->EndpointAddress;
            transferDescriptor->Address = Endpoint->DeviceAddress;

            //
            // Set Pid based on direction
            //
            transferDescriptor->PID = DATA_DIRECTION_IN(Urb) ? USB_IN_PID : USB_OUT_PID;

            transferDescriptor->Isochronous = 1;
            transferDescriptor->ActualLength =
                UHCD_SYSTEM_TO_USB_BUFFER_LENGTH(0);
            transferDescriptor->StatusField = 0;

            transferDescriptor->LowSpeedControl = 0;
            transferDescriptor->ReservedMBZ = 0;
            transferDescriptor->ErrorCounter = 0;
            transferDescriptor->RetryToggle = 0;

            //
            // BUGBUG for now, one every frame
            //
            Endpoint->TdsScheduled[urbWork->Slot]++;

            transferDescriptor->InterruptOnComplete = 0;
            if (Endpoint->TdsScheduled[urbWork->Slot] >
                    (Endpoint->TDCount/2)) {
                transferDescriptor->InterruptOnComplete = 1;
                Endpoint->TdsScheduled[urbWork->Slot] = 0;
            }

            // request some interrupts near the end
            if (Urb->UrbIsochronousTransfer.NumberOfPackets -
                urbWork->CurrentPacketIdx < 5) {
                transferDescriptor->InterruptOnComplete = 1;
            }

            transferDescriptor->Frame = Urb->UrbIsochronousTransfer.StartFrame +
                urbWork->CurrentPacketIdx;
            transferDescriptor->Urb = Urb;

            //
            // Prepare the buffer part of the TD.
            //
            offset =
                Urb->UrbIsochronousTransfer.IsoPacket[urbWork->CurrentPacketIdx].Offset;
            UHCD_ASSERT(urbWork->CurrentPacketIdx <
                Urb->UrbIsochronousTransfer.NumberOfPackets);

            nextPacket = urbWork->CurrentPacketIdx+1;

            if (nextPacket >=
                Urb->UrbIsochronousTransfer.NumberOfPackets) {
                // this is the last packet
                length = Urb->UrbIsochronousTransfer.TransferBufferLength -
                    offset;
            } else {
                // compute length based on offset of next packet
                UHCD_ASSERT(Urb->UrbIsochronousTransfer.IsoPacket[nextPacket].Offset >
                            offset);

                length = Urb->UrbIsochronousTransfer.IsoPacket[nextPacket].Offset -
                            offset;
            }

            transferDescriptor->PacketBuffer =
                 UHCD_GetPacketBuffer(DeviceObject,
                                      Endpoint,
                                      Urb,
                                      urbWork,
                                      offset,
                                      length);

            transferDescriptor->MaxLength =
                UHCD_SYSTEM_TO_USB_BUFFER_LENGTH(length);


            //
            // Put the TD in to the schedule at the requested frame.
            //

            LOG_TD('isTD', transferDescriptor);
            //UHCD_Debug_DumpTD(transferDescriptor);

            if (transferDescriptor->PacketBuffer) {
                UHCD_ASSERT(urbWork->CurrentPacketIdx <=
                            Urb->UrbIsochronousTransfer.NumberOfPackets);

                UHCD_InsertIsochDescriptor(DeviceObject,
                                           transferDescriptor,
                                           Urb->UrbIsochronousTransfer.StartFrame +
                                               urbWork->CurrentPacketIdx);
            } else {
                TEST_TRAP();
                // failed to get the packet buffer,
                // we set the fields in the TD as
                // if the HC got it, the urb will
                // get updated when the rest of the TDs
                // are processed.

                // make inactive
                transferDescriptor->Active = 0;
                // mark TD so we know we have a software
                // error
                transferDescriptor->StatusField = 0x3f;
            }

            urbWork->CurrentPacketIdx++;

            if (urbWork->CurrentPacketIdx ==
                Urb->UrbIsochronousTransfer.NumberOfPackets) {
                break;
            }
        } /* end td->FRame == 0*/
    } /* end for */

UHCD_ScheduleIsochTransfer_Done:
    //UHCD_KdPrint((2, "'exit UHCD_ScheduleIsochTransfer\n"));

    return;
}


USBD_STATUS
UHCD_ProcessIsochTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb,
    IN OUT PBOOLEAN Completed
    )
/*++

Routine Description:

    Checks to see if an isoch transfer is complete.

Arguments:

    DeviceObject - pointer to a device object.

    Endpoint - endpoint to check for completed transfers.

    Urb - ptr to URB to process.

    Completed -  TRUE if this transfer is complete.

Return Value:

    TRUE if this transfer is complete, Status set to proper
    error code.

--*/
{
    PHCD_EXTENSION urbWork;
    PDEVICE_EXTENSION deviceExtension;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor;
    ULONG i, packetIdx;
    USBD_STATUS err;
//    PHCD_URB urb;
    USBD_STATUS usbStatus = USBD_STATUS_SUCCESS;
    PUHCD_TD_LIST urbTDList;

    STARTPROC("Piso");

    *Completed = FALSE;
    deviceExtension = DeviceObject->DeviceExtension;

    urbWork = HCD_AREA(Urb).HcdExtension;
    urbTDList = Endpoint->SlotTDList[urbWork->Slot];

    ASSERT_ENDPOINT(Endpoint);

    // make sure the urb has been properly initialized
    UHCD_InitializeIsochTransfer(DeviceObject,
                                 Endpoint,
                                 Urb);

    if ((urbWork->Flags & UHCD_TRANSFER_INITIALIZED) == 0) {
        //
        // urb has not been initialized yet, probably too early
        // attempt to initialize now.
        //
        LOGENTRY(LOG_ISO,'npIS', Endpoint, Urb, urbTDList);
        goto UHCD_ProcessIsochTransfer_Done;
    }

    //
    // walk thru our TD list for this URB retire any TDs
    // that are done.
    //
    LOGENTRY(LOG_ISO,'doIS', Endpoint, urbWork->Slot, urbTDList);

    for (i=0; i< Endpoint->TDCount; i++) {

        UHCD_ASSERT(urbTDList->TDs[i].Urb == Urb ||
                urbTDList->TDs[i].Urb == NULL);

        if (urbTDList->TDs[i].Frame <= deviceExtension->LastFrameProcessed &&
            // only deal with TDs that have been removed
            // from the schedule.
            urbTDList->TDs[i].Frame != 0 &&
            // don't check retired TDs
            urbTDList->TDs[i].Urb == Urb) {
            // only look at TDs for this urb

            transferDescriptor = &urbTDList->TDs[i];

            LOGENTRY(LOG_ISO,'piTD', transferDescriptor, transferDescriptor->Frame,
                urbWork->PacketsProcessed);

            //
            // index for this packet
            //
            packetIdx = transferDescriptor->Frame -
                Urb->UrbIsochronousTransfer.StartFrame;

            //
            // Update transfer buffer based on data received for
            // this frame.
            //

            // assume we got no error
            err = Urb->UrbIsochronousTransfer.IsoPacket[packetIdx].Status =
                USBD_STATUS_SUCCESS;
            //
            // see if we got an error.
            //

            if (transferDescriptor->Active) {
                //
                // if the active bit is still set then we put this transfer
                // in the schedule too late.
                //

                err = USBD_STATUS_NOT_ACCESSED;

                deviceExtension->IsoStats.IsoPacketNotAccesed++;
                LOGENTRY(LOG_MISC, 'nPRO', transferDescriptor, transferDescriptor->Frame,
                    err);
//                TEST_TRAP();
            } else if (transferDescriptor->StatusField) {
                // BUGBUG map the hardware error
                err = UHCD_MapTDError(deviceExtension, transferDescriptor->StatusField,
                     UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(transferDescriptor->ActualLength));
                LOGENTRY(LOG_MISC, 'hERR', transferDescriptor, transferDescriptor->Frame,
                    err);
                deviceExtension->IsoStats.IsoPacketHWError++;
//                TEST_TRAP();
            }

            if (USBD_ERROR(err)) {

                //
                // Note this error in the error list
                //
                // ErrorList is a list of packet indexes which have an error

                UHCD_ASSERT(packetIdx <= 255);


                Urb->UrbIsochronousTransfer.ErrorCount++;

                Urb->UrbIsochronousTransfer.IsoPacket[packetIdx].Status = err;
            }

            // BUGBUG
            // note, we report length even for
            // errors.

            //
            // keep count the number of bytes succesfully transferred.
            //
            urbWork->BytesTransferred +=
                UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(transferDescriptor->ActualLength);
            //
            // return the length of the packet
            //
            if (USBD_TRANSFER_DIRECTION(
                  Urb->UrbIsochronousTransfer.TransferFlags) ==
                  USBD_TRANSFER_DIRECTION_IN) {

                //
                // return the length of the packet
                //

                Urb->UrbIsochronousTransfer.IsoPacket[packetIdx].Length =
                    UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(transferDescriptor->ActualLength);

                // if the device transmitted < max packet size
                // set the buffer underrun status.
                if (Urb->UrbIsochronousTransfer.IsoPacket[packetIdx].Length <
                      Endpoint->MaxPacketSize) {
                    Urb->UrbIsochronousTransfer.IsoPacket[packetIdx].Status =
                                USBD_STATUS_DATA_UNDERRUN & ~USBD_STATUS_HALTED;
                }
            } else {
                 Urb->UrbIsochronousTransfer.IsoPacket[packetIdx].Length = 0;
            }

            //
            // retire this isoch TD
            //
            transferDescriptor->Frame = 0;
            urbWork->PacketsProcessed++;
            UHCD_ASSERT(urbWork->PacketsProcessed <=
                Urb->UrbIsochronousTransfer.NumberOfPackets);
        }

    } /* for */

    //
    // see if we are done with this transfer
    //

    if (urbWork->PacketsProcessed ==
        Urb->UrbIsochronousTransfer.NumberOfPackets) {

        //
        // All TDs for this transfer have been processed.

        LOGENTRY(LOG_MISC, 'iCmp', Urb, 0,
                urbWork->PacketsProcessed);

        *Completed = TRUE;

        //
        // Clear the Urb field for all TDs associated with
        // the completing urb
        //

        for (i=0; i< Endpoint->TDCount; i++) {
            urbTDList->TDs[i].Urb = NULL;
        }

        //
        // we should return an error if all packets completed with an error.
        //

        if (Urb->UrbIsochronousTransfer.ErrorCount ==
            Urb->UrbIsochronousTransfer.NumberOfPackets) {
            //
            // Isoch transfer will be failed but isoch
            // errors never stall the endpoint on the host so
            // clear the stall bit now.
            //
            usbStatus = USBD_STATUS_ISOCH_REQUEST_FAILED;
            // clear stall bit
            usbStatus &= ~USBD_STATUS_HALTED;

        } else {
            usbStatus = USBD_STATUS_SUCCESS;
        }

    } else {

        //
        // not complete yet, put some more TDs in the schedule.
        //

        //
        // Set up any TDs we still need to complete the
        // current URB
        //

        UHCD_ScheduleIsochTransfer(DeviceObject,
                                   Endpoint,
                                   Urb);
#if 0
        //
        // some preprocessing code, try to start up the next transfer here
        //
        // NOTE: this will kick in close to the end of the current transfer
        //

        UHCD_ASSERT(Endpoint->MaxRequests == 2);

        // this trick only works if maxrequests is 2
        i = !urbWork->Slot;
        urb = Endpoint->ActiveTransfers[i];

        //
        // When we near the end of this transfer we want to start the next one
        //

//BUGBUG
// should be when numpackets - packetsprocessed < numTds
// ie there are some extra
//  Urb->UrbIsochronousTransfer.NumberOfPackets -
//  urbWork->PacketsProcessed < NUM_TDS_PER_ENDPOINT
        if (urbWork->PacketsProcessed > Urb->UrbIsochronousTransfer.NumberOfPackets-
            8
            && urb != NULL) {

            UHCD_KdPrint((2, "'process next iso urb from ProcessIsochTransfer\n"));

            LOGENTRY(LOG_ISO,'iPRE', urb,  &Endpoint->PendingTransferList, Endpoint);

            UHCD_InitializeIsochTransfer(DeviceObject,
                                         Endpoint,
                                         urb);

        }
#endif
    }


UHCD_ProcessIsochTransfer_Done:

    ENDPROC("pIso");

    return usbStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\roothub.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
:ts=4

Module Name:

    roothub.h

Abstract:

    This file contains the interface functions
    for the root hub code.

Environment:

    Kernel & user mode

Revision History:

    2-13-96 : created

--*/

#define RH_RESET_TIMELENGTH  10	/* Default to 10 ms. */

#define RH_NUMBER_OF_PORTS  2

#define    RH_SUCCESS          0
#define    RH_NAK              1                                                                    
#define    RH_STALL            2

#define RH_PORT_SC_BASE        0x0010

typedef LONG RHSTATUS;

#include <PSHPACK1.H>

#define RECIPIENT_DEVICE      0
#define RECIPIENT_INTRFACE    1
#define RECIPIENT_ENDPOINT    2
#define RECIPIENT_PORT        3

typedef struct _RH_SETUP {
    struct _bmRequestType {
        UCHAR   Recipient:5;
        UCHAR   Type:2;
        UCHAR   Dir:1;
    } bmRequestType;
    
    UCHAR bRequest;
    union _wValue {
        struct {
            UCHAR lowPart;
            UCHAR hiPart;
        };
        USHORT W;
    } wValue;        
    USHORT wIndex;
    USHORT wLength;
} RH_SETUP, *PRH_SETUP;

typedef struct _RH_PORT_STATUS {
    //
    // Status bits
    //
    unsigned Connected:1;
    unsigned Enabled:1;
    unsigned Suspended:1;
    unsigned OverCurrent:1;
    unsigned Reset:1;        
    unsigned Reserved0:3;
    unsigned PowerOn:1;
    unsigned LowSpeed:1;
    unsigned Reserved1:6;
    //
    // Change bits
    //
    unsigned ConnectChange:1;
    unsigned EnableChange:1;
    unsigned SuspendChange:1;
    unsigned OverCurrentChange:1;
    unsigned ResetChange:1;
    unsigned Reserved2:11;
    
} RH_PORT_STATUS, *PRH_PORT_STATUS;

#include <POPPACK.H>

#define UHCD_FAKE_CONNECT_CHANGE   0x00000001
#define UHCD_FAKE_DISCONNECT       0x00000002

typedef struct _ROOTHUB_PORT {
    PDEVICE_OBJECT DeviceObject; // HCD DeviceObject
    USHORT Address;              // offset of the port
    BOOLEAN ResetChange;
    BOOLEAN SuspendChange;
} ROOTHUB_PORT, *PROOTHUB_PORT;

typedef struct _ROOTHUB {
    ULONG Sig;
    PDEVICE_OBJECT DeviceObject;                // HCD DeviceObject
    
    UCHAR NumberOfPorts;
    UCHAR ConfigurationValue;                   // current configuration value,
                                                // zero is unconfigured
    BOOLEAN DoSelectiveSuspend;
    UCHAR Pad[1];
    ULONG *DisabledPort;
    
    ROOTHUB_PORT Port[0];      // port structs
} ROOTHUB, *PROOTHUB;

VOID
RootHubTimerHandler(
    IN PVOID TimerContext
    );

PROOTHUB 
RootHub_Initialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfPorts,
    IN BOOLEAN DoSelectiveSuspend 
    );

RHSTATUS 
RootHub_Endpoint0(
    IN PROOTHUB RootHub,
    IN PRH_SETUP SetupPacket,
    IN PUCHAR DeviceAddress,
    IN PUCHAR Buffer,
    IN OUT PULONG BufferLength
    );        

RHSTATUS
RootHub_Endpoint1(
    IN PROOTHUB RootHub,
    IN PUCHAR Buffer,
    IN OUT PULONG BufferLength
    );  

RHSTATUS
RootHub_StandardCommand(
    IN PROOTHUB RootHub,
    IN PRH_SETUP SetupPacket,
	IN OUT PUCHAR DeviceAddress,
	IN OUT PUCHAR Buffer,
	IN OUT PULONG BufferLength
    );    

RHSTATUS
RootHub_ClassCommand(
    IN PROOTHUB RootHub,
    IN PRH_SETUP SetupPacket,
    IN OUT PUCHAR Buffer,
    IN OUT PULONG BufferLength
    );    

BOOLEAN 
RootHub_PortsIdle(
    IN PROOTHUB RootHub
    );  

//
// Services provided by HCD
//

typedef
VOID
(*PROOTHUB_TIMER_ROUTINE) (
    IN PVOID TimerContext
    );


//
// UHCD_RootHub_Timer
//
// Inputs:
//        HcdPtr - pointer passed to Root hub
//            during initialization
//        WaitTime - time to wait in ms until
//            calling callback.
//        RootHubTimerRoutine - VOID fn(PVOID TimerContext) 
//                context is ptr returned from 
//                RootHub_Initialize routine.
//        TimerContext - pointer to be passed to the callback routine
//
// Returns:
//         None
//

VOID
UHCD_RootHub_Timer(
    IN PVOID HcdPtr,
    IN LONG WaitTime,
    IN PROOTHUB_TIMER_ROUTINE RootHubTimerRoutine,
    IN PVOID TimerContext
    );

USHORT
UHCD_RootHub_ReadPort(
    IN PROOTHUB_PORT HubPort
    );

VOID
UHCD_RootHub_WritePort(
    IN PROOTHUB_PORT HubPort,
    IN USHORT DataVal
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\int.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    int.c

Abstract:

    This module contains the interrupt routine, DPC routines and routines
    that synchronize with the interrupt routine.

Environment:

    kernel mode only

Notes:

Revision History:

    11-01-95 : created

--*/
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"

#ifdef DEBUG_LOG
ULONG TrapOn = 0;
#endif

BOOLEAN
UHCD_InterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the interrupt service routine for the UHCD.

Arguments:

    Interrupt - A pointer to the interrupt object for this interrupt.

    Context - A pointer to the device object.

Return Value:

    Returns TRUE if the interrupt was expected (and therefore processed);
    otherwise, FALSE is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;
    USHORT status;
    ULONG frameNumber;
    BOOLEAN usbInt = FALSE;

    UNREFERENCED_PARAMETER(Interrupt);

//    UHCD_KdPrint((2, "'enter UHCD_InterruptService\n"));

    deviceObject = (PDEVICE_OBJECT) Context;
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;

    // Ignore ints if we are not in D0.

    if (deviceExtension->CurrentDevicePowerState != PowerDeviceD0) {
        goto UHCD_InterruptService_Done;
    }

    status = READ_PORT_USHORT(STATUS_REG(deviceExtension));

    if (status & (UHCD_STATUS_USBINT |
                  UHCD_STATUS_USBERR |
                  UHCD_STATUS_RESUME |
                  UHCD_STATUS_HCERR |
                  UHCD_STATUS_PCIERR
// BUGBUG we will ignore the halt bit by itself since
// the controller will never allow us to clear the status
                  /*| UHCD_STATUS_HCHALT*/)) {
        usbInt = TRUE;
        //clear the condition
        WRITE_PORT_USHORT(STATUS_REG(deviceExtension),  0xff);
    } else {
        goto UHCD_InterruptService_Done;
    }


    if ((status & (UHCD_STATUS_HCHALT | UHCD_STATUS_USBINT)) ==
            (UHCD_STATUS_HCHALT | UHCD_STATUS_USBINT)) {
        ULONG frame;
        USHORT cmd;

        frameNumber = (ULONG) READ_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension)) & 0x3ff;

        frame = UHCD_GetCurrentFrame(deviceObject);
        //LOGENTRY(LOG_MISC, 'Hlt!', status, deviceExtension->FrameListVirtualAddress, frameNumber);

        UHCD_KdPrint((2, "'UHCD Host Controller Halted %x, frame = 0x%x - 0x%x\n", status,
            frame, frameNumber));

        //
        // nasty error in the host controller, we will want to debug.
        //
        UHCD_KdPrint((0, "'HC HALTED! attempting to recover\n"));

        // attempt to recover
        WRITE_PORT_USHORT(STATUS_REG(deviceExtension),  0xff);
        cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
        cmd |= UHCD_CMD_RUN;
        WRITE_PORT_USHORT(COMMAND_REG(deviceExtension),  cmd);
        usbInt = TRUE;

        return usbInt;
    }


    //
    // Process the interrupt
    //

    if (status & UHCD_STATUS_RESUME) {

        //
        // system wakeup interrupt
        //

#ifdef MAX_DEBUG
        TEST_TRAP();
#endif
    } else if (status & UHCD_STATUS_USBINT) {

        //
        // Interrupt because a TD completed
        //

    //    UHCD_KdPrint((2, "'UHCD_InterruptService status = %x\n", status));

#ifdef DEBUG_LOG
//        if (TrapOn > 0) {
//            USHORT portStatus;
//            // check for port disable
//            portStatus = READ_PORT_USHORT(PORT1_REG(deviceExtension));
//            if (portStatus & 0x0008) {
                frameNumber = (ULONG) READ_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension)) & 0x3ff;
////
////                UHCD_KdPrint((2, "'Port Disabled frame = 0x%x\n", frameNumber));
////
//                TRAP();
//            }

//            portStatus = READ_PORT_USHORT(PORT2_REG(deviceExtension));
//            if (portStatus & 0x0008) {
//                frameNumber = (ULONG) READ_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension)) & 0x3ff;
////
////                UHCD_KdPrint((2, "'Port Disabled frame = 0x%x\n", frameNumber));
////
//                TRAP();
//            }
//        }
#endif

        // This code maintains the 32-bit frame counter

        frameNumber = (ULONG) READ_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension));

        // did the sign bit change ?
        if ((deviceExtension->LastFrame ^ frameNumber) & 0x0400) {
            // Yes
            deviceExtension->FrameHighPart += 0x0800 -
                ((frameNumber ^ deviceExtension->FrameHighPart) & 0x0400);
        }

        // remember the last frame number
        deviceExtension->LastFrame = frameNumber;


//***
    //
    // start at the last frame processed
    //

        {
        ULONG i, j;
        ULONG currentFrame, highPart;

        highPart = deviceExtension->FrameHighPart;

        // get 11-bit frame number, high 17-bits are 0
        //frameNumber = (ULONG) READ_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension));

        currentFrame = ((frameNumber & 0x0bff) | highPart) +
            ((frameNumber ^ highPart) & 0x0400);

//        UHCD_KdPrint((2, "'currentFrame = %x\n", currentFrame));

        if (currentFrame-deviceExtension->LastFrameProcessed > 1024) {

            deviceExtension->Stats.ScheduleOverrunCount++;

            // we have a schedule overrun,
            // this means it has been more that 1000 ms since our last
            // interrupt, because of this the iso entries in the schedule
            // are invalid -- we need to remove all of them and start over

//            UHCD_KdPrint((2, "'schedule overrun currentFrame = %d, lastframe = %d \n",
//                currentFrame, deviceExtension->LastFrameProcessed));
//            TRAP();

            // first remove all iso TDs from the list
            for (j=0; j<FRAME_LIST_SIZE; j++) {

                // put back the physical address that was there before we started
                // adding isoch descriptors.

                *( ((PULONG) (deviceExtension->FrameListVirtualAddress) + j) )  =
                    *( ((PULONG) (deviceExtension->FrameListCopyVirtualAddress) + j) );

#if DBG
                *( deviceExtension->IsoList + j ) = 0;
#endif
            }

            deviceExtension->LastFrameProcessed = currentFrame;
        }

        {
#ifdef FAST_ISO
        PUHCD_ENDPOINT endpoint;

        endpoint = UHCD_GetLastFastIsoEndpoint(deviceObject);
#endif /* FAST_ISO */

        for (i=deviceExtension->LastFrameProcessed+1; i<currentFrame; i++) {
            // remove isoch TDs for frame i;
            j = i % FRAME_LIST_SIZE;

            // put back the physical address that was there before we started
            // adding isoch descriptors.

            *( ((PULONG) (deviceExtension->FrameListVirtualAddress) + j) )  =
                *( ((PULONG) (deviceExtension->FrameListCopyVirtualAddress) + j) );

#if DBG
            *( deviceExtension->IsoList + j ) = 0;
#endif

#ifdef FAST_ISO
            if (endpoint) {

                UHCD_CleanupFastIsoTD(deviceObject,
                                      endpoint,
                                      j,
                                      TRUE);

            }
#endif /* FAST_ISO */
        }

        }


        deviceExtension->LastFrameProcessed = currentFrame-1;
        }

//***

        //
        // Queue the DPC to complete any transfers
        //

#ifdef PROFILE
        {
        LARGE_INTEGER time;

        time = KeQueryPerformanceCounter(NULL);
        UHCD_KdPrint((2, "'time.HighPart = %x time.LowPart %x\n", time.HighPart,
            time.LowPart));


//        LOGENTRY(LOG_MISC, 'Tim1", 0, sysTime.LowPart, sysTime.HighPart);
        KeInsertQueueDpc(&deviceExtension->IsrDpc,
                         time.HighPart,
                         time.LowPart);
        }
#else
        KeInsertQueueDpc(&deviceExtension->IsrDpc,
                         NULL,
                         NULL);
#endif
    //    UHCD_KdPrint((2, "'exit UHCD_InterruptService\n"));
    // USB interrupt
    } else {
        //
        // USB Interrupt not recognized in ISR
        //
        UHCD_KdBreak((2, "'USB interrupt not recognized by ISR, status = %x\n", status));
        // BUGBUG check why we are not handling it
    }

UHCD_InterruptService_Done:

//#ifdef MAX_DEBUG
//    if (!usbInt) {
//        UHCD_KdPrint((2, "'Non USB interrupt, status = %x\n", status));
//    }
//#endif

    return usbInt;
}


VOID
UHCD_IsrDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies the DeviceObject.

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;
    PLIST_ENTRY listEntry;
    PUHCD_ENDPOINT endpoint;
    LONG slot;
    BOOLEAN process = TRUE;
    KIRQL irql;

//    STARTPROC("IDpc");

#ifdef PROFILE
    {
    //
    // See how long it took for our DPC to get called
    //
    LARGE_INTEGER time, timeNow;
    LONG delta;

    time.HighPart = SystemArgument1;
    time.LowPart = SystemArgument2;

    timeNow = KeQueryPerformanceCounter(NULL);

    delta = timeNow.QuadPart - time.QuadPart;

    UHCD_KdPrint((2, "'time.HighPart = %x time.LowPart %x\n", time.HighPart,
            time.LowPart));
    UHCD_KdPrint((2, "'timeNow.HighPart = %x timeNow.LowPart %x\n", timeNow.HighPart,
            timeNow.LowPart));
    UHCD_KdPrint((2, "'delta %x %x ms\n", delta, delta/((0x1234de*50)/1000)));

    if (delta > ((0x1234de*50)/1000)) {
        UHCD_KdTrap(("DPC delayed > 50 ms\n"));
    }

    //LOGENTRY(LOG_MISC, 'Tim2", timeNow - time, time, timeNow);
    }
#endif

//    UHCD_KdPrint((2, "'enter UHCD_IsrDpc\n"));

    deviceObject = (PDEVICE_OBJECT) DeferredContext;
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;

    //
    // Walk through the Endpoint list checking for
    // any endpoints that have transfers that need completing
    //

    LOCK_ENDPOINT_LIST(deviceExtension, irql);

    if (deviceExtension->EndpointListBusy) {
        process = FALSE;
    } else {
        deviceExtension->EndpointListBusy = TRUE;
    }

    UNLOCK_ENDPOINT_LIST(deviceExtension, irql);

    if (process) {

        //
        // we now have exclusive access to the endpoint list
        //

        listEntry = &deviceExtension->EndpointList;
        if (!IsListEmpty(listEntry)) {
            listEntry = deviceExtension->EndpointList.Flink;
        }
        LOGENTRY(LOG_MISC, 'EPl+', listEntry,
                &deviceExtension->EndpointList, 0);

        while (listEntry != &deviceExtension->EndpointList) {
            ULONG cnt = 0;

            endpoint = CONTAINING_RECORD(listEntry,
                                         UHCD_ENDPOINT,
                                         ListEntry);
            ASSERT_ENDPOINT(endpoint);
//            LOGENTRY(LOG_MISC, 'prEP', endpoint,
//                &deviceExtension->EndpointList, listEntry);

            listEntry = endpoint->ListEntry.Flink;

            //
            // Scan active transfer slots and process any transfers
            // that have been programmed into the hardware.
            //

            for (slot=0; slot<endpoint->MaxRequests; slot++) {

                //
                // If we have a transfer in the slot call the completion
                // handler.
                //

                if (endpoint->ActiveTransfers[slot]) {
                    cnt++;
                    LOGENTRY(LOG_MISC, 'epWk', endpoint,  slot, endpoint->ActiveTransfers[slot]);

                    // only call the completer if no double buffer
                    // endpoints
                    if (!(endpoint->EndpointFlags & EPFLAG_DBL_BUFFER)) {
                        LOGENTRY(LOG_MISC, 'cPTR', endpoint,
                            slot, endpoint->ActiveTransfers[slot]);
                        UHCD_CompleteTransferDPC(deviceObject, endpoint, slot);
                    }
                }
            }

            // if we had no transfers see if we can idle the endpoint
            if (cnt) {
                UHCD_EndpointWakeup(deviceObject, endpoint);
            } else {
                UHCD_EndpointIdle(deviceObject, endpoint);
            }

            //
            // For DBL_BUFFER transfers, we don't do the active abort
            // until we call the worker code.  The worker code will also
            // clear the flag for us.  So, if it is a DBL_BUFFER, don't
            // clear the flag yet.
            //


            if (!(endpoint->EndpointFlags & EPFLAG_DBL_BUFFER)) {
               //
               // safe to clear the ABORT_ACTIVE_TRANSFERS flag
               // this will allow a reset_endpoint to succeed.
               // LOGENTRY(LOG_MISC, 'clrA', endpoint,  0, 0);
               //

               CLR_EPFLAG(endpoint, EPFLAG_ABORT_ACTIVE_TRANSFERS);
            }


            // does this endpoint need attention, we mail have bailed
            // because endpointworker was busy, if so process it now

            if (endpoint->EndpointFlags & EPFLAG_HAVE_WORK) {
                UHCD_EndpointWorker(deviceObject, endpoint);
            }

        }

        LOGENTRY(LOG_MISC, 'EPl-', listEntry,
                &deviceExtension->EndpointList, 0);


        // now walk the list looking for idle bulk
        {
        ULONG idleBulkEndpoints = 0;
        ULONG bulkEndpoints = 0;

        listEntry = &deviceExtension->EndpointList;
        if (!IsListEmpty(listEntry)) {
            listEntry = deviceExtension->EndpointList.Flink;
        }
        LOGENTRY(LOG_MISC, 'EPl+', listEntry,
                &deviceExtension->EndpointList, 0);

        while (listEntry != &deviceExtension->EndpointList) {
            BOOLEAN idle = TRUE;

            endpoint = CONTAINING_RECORD(listEntry,
                                         UHCD_ENDPOINT,
                                         ListEntry);
            ASSERT_ENDPOINT(endpoint);
            LOGENTRY(LOG_MISC, 'prEP', endpoint,
                &deviceExtension->EndpointList, listEntry);

            listEntry = endpoint->ListEntry.Flink;

            // see if this ep is closed, if so remove it and
            // it on the closed list
            if (endpoint->EndpointFlags & EPFLAG_EP_CLOSED) {

                LOGENTRY(LOG_MISC, 'epCL', endpoint,
                    &deviceExtension->EndpointList, listEntry);

                RemoveEntryList(&endpoint->ListEntry);

                continue;
            }

            //
            // Scan active transfer slots and process any transfers
            // thet have been programmed into the hardware.
            //

            for (slot=0; slot<endpoint->MaxRequests; slot++) {

                //
                // If we have a transfer in the slot we are not idle
                //

                if (endpoint->ActiveTransfers[slot]) {
                    idle = FALSE;
                }
            }


            if (endpoint->Type == USB_ENDPOINT_TYPE_BULK) {
                bulkEndpoints++;
                if (idle) {
                    idleBulkEndpoints++;
                }
            }
        }

        if (bulkEndpoints && bulkEndpoints == idleBulkEndpoints) {
            // no activity on the bulk endpoints
            // disable BW reclimation.
            UHCD_BW_Reclimation(deviceObject, FALSE);
        }
        }

        //
        // See if we can free any endpoint structures
        //

        // walk through the closed endpoint list, if we find an endpoint that has
        // been freed in a previous frame then go ahead and release its
        // resources.

        while (!IsListEmpty(&deviceExtension->ClosedEndpointList)) {
            ULONG cnt;

            listEntry = RemoveHeadList( &deviceExtension->ClosedEndpointList);

            endpoint =  CONTAINING_RECORD(listEntry,
                                          UHCD_ENDPOINT,
                                          ListEntry);
            ASSERT_ENDPOINT(endpoint);

            if (UHCD_GetCurrentFrame(deviceObject) <= endpoint->FrameToClose) {
                //
                // put it back and get out
                //
                InsertHeadList(&deviceExtension->ClosedEndpointList, &endpoint->ListEntry);

                break;
            }

            // free the endpoint resources
            UHCD_KdPrint((2, "'UHCD_IsrDpc free endpoint %x\n", endpoint));

            if (endpoint->EndpointFlags & EPFLAG_DBL_BUFFER) {
                UHCD_UnInitializeNoDMAEndpoint(deviceObject,
                                               endpoint);
            }

            UHCD_ASSERT(!(endpoint->EndpointFlags & EPFLAG_FAST_ISO));

            UHCD_FreeBandwidth(deviceObject, endpoint, endpoint->Offset);

            for (cnt=0; cnt< endpoint->MaxRequests; cnt++) {

                UHCD_FreeHardwareDescriptors(deviceObject,
                    endpoint->HardwareDescriptorList[cnt]);
            }

#if DBG
            //UHCD_BufferPoolCheck(deviceObject);
#endif

            RETHEAP(endpoint);
        }

        // now check the lookaside list and add any endpoints on it
        while (!IsListEmpty(&deviceExtension->EndpointLookAsideList)) {
            listEntry = RemoveHeadList(&deviceExtension->EndpointLookAsideList);
            endpoint = CONTAINING_RECORD(listEntry,
                                         UHCD_ENDPOINT,
                                         ListEntry);
            ASSERT_ENDPOINT(endpoint);
            InsertHeadList(&deviceExtension->EndpointList, &endpoint->ListEntry);
        }

        LOCK_ENDPOINT_LIST(deviceExtension, irql);

        deviceExtension->EndpointListBusy = FALSE;

        UNLOCK_ENDPOINT_LIST(deviceExtension, irql);
    }

#ifdef FAST_ISO
    // walk the fastiso list and complete any transfers
    // if the last frame has pssed
    {
        listEntry = &deviceExtension->FastIsoTransferList;
        if (!IsListEmpty(listEntry)) {
            listEntry = deviceExtension->FastIsoTransferList.Flink;
        }
        LOGENTRY(LOG_MISC, 'FIl+', listEntry,
                &deviceExtension->FastIsoTransferList, 0);

        while (listEntry != &deviceExtension->FastIsoTransferList) {

            PIRP irp;
            PHCD_URB urb;
            ULONG cf, lastFrame;

            urb = (PHCD_URB) CONTAINING_RECORD(
                    listEntry,
                    struct _URB_HCD_COMMON_TRANSFER,
                    hca.HcdListEntry);

            listEntry = HCD_AREA(urb).HcdListEntry.Flink;

            lastFrame = urb->UrbIsochronousTransfer.StartFrame+1;
//                urb->UrbIsochronousTransfer.NumberOfPackets;

            cf = UHCD_GetCurrentFrame(deviceObject);

            LOGENTRY(LOG_MISC, 'FIck', urb, cf, lastFrame);

            if (cf >= lastFrame) {

                LOGENTRY(LOG_MISC, 'FIcp', urb, cf, lastFrame);

                RemoveEntryList(&HCD_AREA(urb).HcdListEntry);

                irp = HCD_AREA(urb).HcdIrp;

                UHCD_CompleteIrp(deviceObject,
                     irp,
                     STATUS_SUCCESS,
                     0,
                     urb);

                continue;
            }
        }
    }
#endif /* FAST_ISO */

 //   ENDPROC("IDpc");

//    UHCD_KdPrint((2, "'exit UHCD_IsrDpc\n"));
}


VOID
UHCD_RequestInterrupt(
    IN PDEVICE_OBJECT DeviceObject,
    IN LONG FrameNumber
    )

/*++

Routine Description:

    This routine triggers a hradware interrupt on a specific
    USB frame number.

Arguments:

    DeviceObject - Supplies the device object.

    Frame - frame to generate intrerrupt on, a negative value
            indicates relative to the current frame.

Return Value:

    None.

--*/

{
    ULONG requestFrameNumber;
    PDEVICE_EXTENSION deviceExtension;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor;
    ULONG i;

    UHCD_KdPrint((2, "'enter UHCD_RequestInterrupt\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Allocate a TD we can use for this request
    //
    // NOTE:
    // First two TDs are dedicated to detecting frame rollover.
    //

    for (i=UHCD_FIRST_TRIGGER_TD; i<MAX_TDS_PER_ENDPOINT; i++) {
        transferDescriptor =
            &deviceExtension->TriggerTDList->TDs[i];

        if (deviceExtension->LastFrameProcessed >
            transferDescriptor->Frame) {
            break;
        }

        transferDescriptor = NULL;
    }

    if (transferDescriptor == NULL) {

        //
        // no TDS available for interrupt request, this means enough
        // interrupts are happening that we'll be OK -- worst case
        // is we'll get an interrupt on frame rollover.
        //
        UHCD_KdBreak((2, "'no tds for interrupt request\n"));

        goto UHCD_RequestInterrupt_Done;
    }

    if (FrameNumber < 0) {
        requestFrameNumber = UHCD_GetCurrentFrame(DeviceObject) -
            FrameNumber;
    } else {
        requestFrameNumber = FrameNumber;
    }

    //
    // all we do here is put a dummy isoch TD in the schedule at
    // the requested frame number
    //

    LOGENTRY(LOG_MISC, 'REQi', requestFrameNumber, FrameNumber,
        transferDescriptor);

    //
    // Make sure we can schedule it
    //

    if (requestFrameNumber >
        deviceExtension->LastFrameProcessed+1+FRAME_LIST_SIZE-1) {

        // note: if the request is to far in advance.

        LOGENTRY(LOG_MISC, 'REQf', FrameNumber, requestFrameNumber,
            (deviceExtension->LastFrameProcessed+1+FRAME_LIST_SIZE-1));

        // if the request is too far in advance we'll just let it be handled
        // by the rollover interrupts.
    } else {

        transferDescriptor->Active = 0;
        transferDescriptor->MaxLength = UHCD_SYSTEM_TO_USB_BUFFER_LENGTH(0);
        transferDescriptor->InterruptOnComplete = 1;
        transferDescriptor->Frame = requestFrameNumber;
#ifdef VIA_HC
        transferDescriptor->PID = USB_IN_PID;
#endif  /* VIA_HC */

        UHCD_InsertIsochDescriptor(DeviceObject,
                                   transferDescriptor,
                                   requestFrameNumber);
    }

UHCD_RequestInterrupt_Done:

     UHCD_KdPrint((2, "'exit UHCD_RequestInterrupt\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\uhcd.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    uhcd.c

Abstract:

    The UHC driver for USB, this module contains the initialization code.

Environment:

    kernel mode only

Notes:

Revision History:

    10-08-95 : created

--*/

#include "wdm.h"
#include <windef.h>
#include <unknown.h>
#ifdef DRM_SUPPORT
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>
#include <ksdrmhlp.h>
#endif
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"

#ifdef DRM_SUPPORT
NTSTATUS
UHCD_PreUSBD_SetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
    );

NTSTATUS
UHCD_PostUSBD_SetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
    );

#endif

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
// WIN98 breaks if we have an INIT segment
//#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, UHCD_CreateDeviceObject)
#pragma alloc_text(PAGE, UHCD_ReadWriteConfig)
#pragma alloc_text(PAGE, UHCD_QueryCapabilities)
#pragma alloc_text(PAGE, UHCD_StartDevice)
#pragma alloc_text(PAGE, UHCD_InitializeSchedule)
#pragma alloc_text(PAGE, UHCD_StartGlobalReset)
#pragma alloc_text(PAGE, UHCD_Suspend)
#pragma alloc_text(PAGE, UHCD_StopBIOS)
#ifdef DRM_SUPPORT
#pragma alloc_text(PAGE, UHCD_PreUSBD_SetContentId)
#pragma alloc_text(PAGE, UHCD_PostUSBD_SetContentId)
#endif
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    NT status code

--*/
{

    PDEVICE_OBJECT deviceObject = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    UHCD_KdPrint((2, "'entering DriverEntry\n"));

    UHCD_KdPrint ((1, "'UHCI Universal Serial Bus Host Controller Driver.\n"));
    UHCD_KdPrint ((1, "'HCD using USBDI version %x\n", USBDI_VERSION));

#ifdef DEBUG_LOG
    //
    // Initialize our debug trace log
    //
    UHCD_LogInit();
#endif

    //
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]=
    DriverObject->MajorFunction[IRP_MJ_CLOSE] =
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = UHCD_Dispatch;

    DriverObject->MajorFunction[IRP_MJ_PNP] = UHCD_Dispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = UHCD_Dispatch;

    DriverObject->DriverExtension->AddDevice = UHCD_PnPAddDevice;

    DriverObject->DriverUnload = UHCD_Unload;
    DriverObject->DriverStartIo = UHCD_StartIo;

    return ntStatus;
}


NTSTATUS
UHCD_ProcessPnPIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Process the Power IRPs sent to the PDO for this device.

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT stackDeviceObject;
    BOOLEAN touchTheHardware = TRUE;

    UHCD_KdPrint((2, "'IRP_MJ_PNP\n"));

    // we should only process PnP messages sent to our
    // FDO for the HCD, USBD will handle any others.
    //   UHCD_ASSERT(DeviceObject == hcdDeviceObject);

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    UHCD_PrintPnPMessage("PNP DISPATCH:", irpStack->MinorFunction);
    UHCD_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    switch (irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        //
        // USB handles start for us so we
        // should not get here.
        //

        LOGENTRY(LOG_MISC, 'STR!', deviceExtension->TopOfStackDeviceObject, 0, 0);
        UHCD_KdTrap(("HCD START_DEVICE Irp\n"));
        break;

    //
    // STOP & REMOVE messages unload the driver
    // when we get a STOP message it is still possible
    // touch the hardware, when we get a REMOVE message
    // we have to assume that the hardware is gone.
    //

    case IRP_MN_STOP_DEVICE:

        stackDeviceObject =  deviceExtension->TopOfStackDeviceObject;

        ntStatus = UHCD_StopDevice(DeviceObject);

        UHCD_CleanupDevice(DeviceObject);

        LOGENTRY(LOG_MISC, 'STOP', deviceExtension->TopOfStackDeviceObject, 0, 0);
        // Pass on to PDO
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        touchTheHardware = FALSE;
   LOGENTRY(LOG_MISC, 'SRMV', deviceExtension->TopOfStackDeviceObject,
       ntStatus, 0);

    case IRP_MN_REMOVE_DEVICE:

        stackDeviceObject =  deviceExtension->TopOfStackDeviceObject;

        //
        // BUGBUG
        // we really only want stop processing if we are
        // sure the device is present.
        //

        ntStatus = UHCD_StopDevice(DeviceObject);

        UHCD_CleanupDevice(DeviceObject);

        LOGENTRY(LOG_MISC, 'REMV', deviceExtension->TopOfStackDeviceObject,
       ntStatus, 0);

        //
        // Undo anything we did in the PnPAddDevice function
        //

        UHCD_KdPrint((2, "'UHCD -- removing device object\n"));

        //
        // Detach FDO from PDO
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // pass on to our PDO
        //

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                                Irp);

        //
        // important to detach after we pass the irp on
        //

        IoDetachDevice( deviceExtension->TopOfStackDeviceObject );

        USBD_FreeDeviceName(deviceExtension->DeviceNameHandle);

        //
        // Delete the device object we created for this controller
        //

        IoDeleteDevice (DeviceObject);
        goto UHCD_ProcessPnPIrp_Done;

        break;

    //
    // All other PnP messages passed on to our PDO
    //

    default:
        stackDeviceObject = deviceExtension->TopOfStackDeviceObject;
        UHCD_ASSERT(stackDeviceObject != NULL);
        UHCD_KdPrint((2, "'UNKNOWN PNP MESSAGE (%x)\n", irpStack->MinorFunction));

        //
        // All unahndled PnP messages are passed on to the PDO
        //

    } /* case PNP minor function */

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // pass on to our PDO
    //

    ntStatus = IoCallDriver(stackDeviceObject,
                            Irp);

UHCD_ProcessPnPIrp_Done:

    return ntStatus;
}


#ifdef DRM_SUPPORT

NTSTATUS
UHCD_PreUSBD_SetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
)
 /* ++
  *
  * Description:
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PVOID Handlers[1];
    ULONG ContentId;

    PAGED_CODE();

    ASSERT(irp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    ContentId = pvData->ContentId;
    Handlers[0] = USBD_Dispatch;
    return pKsProperty->DrmAddContentHandlers(ContentId, Handlers, SIZEOF_ARRAY(Handlers));
}

NTSTATUS
UHCD_PostUSBD_SetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
)
 /* ++
  *
  * Description:
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    NTSTATUS ntStatus;

    PAGED_CODE();

    ASSERT(irp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    // ioStackLocation = IoGetCurrentIrpStackLocation(irp);
    // deviceExtension = ioStackLocation->DeviceObject->DeviceExtension;
    // Context = pKsProperty->Context;
    // ContentId = pvData->ContentId;;

    return STATUS_SUCCESS;
}

#endif


NTSTATUS
UHCD_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the IRPs sent to this device.

    Power States for the USB host controller
        D0 - On.
        D1 - USB defined Suspend per 1.00 specification.
        D2 - undefined, reserved for future use.
        D3 - Off

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT hcdDeviceObject;

    UHCD_KdPrint((2, "'enter UHCD_Dispatch\n"));

#ifdef DRM_SUPPORT

    //
    // Need to check DRM request before passing to USBD and advise DRM of
    // the USBD entry point.  Otherwise, a rogue USBD could circumvent DRM.
    //
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    if (IRP_MJ_DEVICE_CONTROL == irpStack->MajorFunction && IOCTL_KS_PROPERTY == irpStack->Parameters.DeviceIoControl.IoControlCode) {
        NTSTATUS ntStatus;
        ntStatus = KsPropertyHandleDrmSetContentId(Irp, UHCD_PreUSBD_SetContentId);
        if (!NT_SUCCESS(ntStatus) && ntStatus != STATUS_PROPSET_NOT_FOUND) {
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return ntStatus;
        }
    }

#endif

    //
    // pass the irp to USBD
    //
    if (!USBD_Dispatch(DeviceObject,
                       Irp,
                       &hcdDeviceObject,
                       &ntStatus)) {
        //
        // Irp was completed by USBD just exit our dispatch
        // routine.
        //
        goto UHCD_Dispatch_Done;
    }

    deviceExtension = (PDEVICE_EXTENSION) hcdDeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    UHCD_KdPrint((2, "'UHCD_Dispatch IRP = %x, stack = %x\n", Irp, irpStack));

    switch (irpStack->MajorFunction) {

    case IRP_MJ_CREATE:

        UHCD_KdPrint((2, "'IRP_MJ_CREATE\n"));
        UHCD_CompleteIrp(hcdDeviceObject, Irp, ntStatus, 0, NULL);

        break;

    case IRP_MJ_CLOSE:

        UHCD_KdPrint((2, "'IRP_MJ_CLOSE\n"));
        UHCD_CompleteIrp(hcdDeviceObject, Irp, ntStatus, 0, NULL);

        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        UHCD_KdPrint((2, "'IRP_MJ_INTERNAL_DEVICE_CONTROL\n"));

        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_INTERNAL_USB_SUBMIT_URB:

            UHCD_KdPrint((2, "'IOCTL_USB_SUBMIT_URB\n"));
            ntStatus = UHCD_URB_Dispatch(hcdDeviceObject, Irp);

            break;
        default:

            // this IOCTL not handled by the HCD, we need
            // to invetigate why
            UHCD_KdTrap(("why is this IOCTL NOT HANDLED by HCD?\n"));

            // BUGBUG
            UHCD_CompleteIrp(hcdDeviceObject, Irp, STATUS_SUCCESS, 0, NULL);
            break;
        } /* case */

        break;

    case IRP_MJ_DEVICE_CONTROL:
        UHCD_KdPrint((2, "'IRP_MJ_DEVICE_CONTROL\n"));

        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

#ifdef DRM_SUPPORT

        case IOCTL_KS_PROPERTY:
            {
            ntStatus = KsPropertyHandleDrmSetContentId(Irp, UHCD_PostUSBD_SetContentId);
            UHCD_CompleteIrp(hcdDeviceObject, Irp, ntStatus, 0, NULL);
            break;
            }
#endif

        case IOCTL_USB_HCD_GET_STATS_1:
            {
            PVOID ioBuffer;
            ULONG inputBufferLength;
            ULONG outputBufferLength;
            PHCD_STAT_INFORMATION_1 uhcdStatInfo;

            UHCD_KdPrint((1, "'IOCTL_USB_HCD_GET_STATS 1\n"));

            //
            // Get a pointer to the current location in the Irp. This is where
            //     the function codes and parameters are located.
            //

            irpStack = IoGetCurrentIrpStackLocation (Irp);

            //
            // Get the pointer to the input/output buffer and it's length
            //

            uhcdStatInfo = (PHCD_STAT_INFORMATION_1) ioBuffer = Irp->AssociatedIrp.SystemBuffer;
            inputBufferLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
            outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

            if (outputBufferLength >= sizeof(HCD_STAT_INFORMATION_1)) {

                //
                // return the IOBASE address of the controller
                // followed by the Phys address of the persistent queue head
                //
                // This is for Intels TD-Poker app on Memphis
#ifdef NTKERN
                uhcdStatInfo->Reserved1 =
                    *((PULONG) &deviceExtension->DeviceRegisters[0]);
                uhcdStatInfo->Reserved2 =
                    (ULONG) deviceExtension->PersistantQueueHead->PhysicalAddress;
#endif
                // reg counters
                RtlCopyMemory(&uhcdStatInfo->Counters,
                              &deviceExtension->Stats,
                              sizeof(uhcdStatInfo->Counters));


                KeQuerySystemTime(&uhcdStatInfo->TimeRead);

                if (uhcdStatInfo->ResetCounters) {
                    UHCD_KdPrint((1, "'<Reset Stats>\n"));
                    RtlZeroMemory(&deviceExtension->Stats,
                                  sizeof(deviceExtension->Stats));
                }
                ntStatus = STATUS_SUCCESS;
            } else {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }

            UHCD_KdPrint((2, "'inputBufferLength = %d outputBufferLength = %d\n",
                        inputBufferLength, outputBufferLength));

            UHCD_CompleteIrp(hcdDeviceObject, Irp, ntStatus,
               sizeof(HCD_STAT_INFORMATION_1), NULL);
            }
            break;



        case IOCTL_USB_HCD_GET_STATS_2:
            {
            PVOID ioBuffer;
            ULONG inputBufferLength;
            ULONG outputBufferLength;
            PHCD_STAT_INFORMATION_2 uhcdStatInfo;

            UHCD_KdPrint((1, "'IOCTL_USB_HCD_GET_STATS 2\n"));

            //
            // Get a pointer to the current location in the Irp. This is where
            //     the function codes and parameters are located.
            //

            irpStack = IoGetCurrentIrpStackLocation (Irp);

            //
            // Get the pointer to the input/output buffer and it's length
            //

            uhcdStatInfo = (PHCD_STAT_INFORMATION_2) ioBuffer = Irp->AssociatedIrp.SystemBuffer;
            inputBufferLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
            outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

            if (outputBufferLength >= sizeof(HCD_STAT_INFORMATION_2)) {
                extern LONG UHCD_CommonBufferBytes;
                //
                // return the IOBASE address of the controller
                // followed by the Phys address of the persistent queue head
                //
                // This is for Intels TD-Poker app on Memphis
#ifdef NTKERN
                uhcdStatInfo->Reserved1 =
                    *((PULONG) &deviceExtension->DeviceRegisters[0]);
                uhcdStatInfo->Reserved2 =
                    (ULONG) deviceExtension->PersistantQueueHead->PhysicalAddress;
#endif

                // reg counters
                RtlCopyMemory(&uhcdStatInfo->Counters,
                              &deviceExtension->Stats,
                              sizeof(uhcdStatInfo->Counters));


                // iso counters
                RtlCopyMemory(&uhcdStatInfo->IsoCounters,
                              &deviceExtension->IsoStats,
                              sizeof(uhcdStatInfo->IsoCounters));

                KeQuerySystemTime(&uhcdStatInfo->TimeRead);

                uhcdStatInfo->LockedMemoryUsed = UHCD_CommonBufferBytes;


                if (uhcdStatInfo->ResetCounters) {
                    UHCD_KdPrint((1, "'<Reset Stats>\n"));
                    RtlZeroMemory(&deviceExtension->Stats,
                                  sizeof(deviceExtension->Stats));
                    RtlZeroMemory(&deviceExtension->IsoStats,
                                  sizeof(deviceExtension->IsoStats));
                    deviceExtension->LastFrameInterrupt = 0;
                }
                ntStatus = STATUS_SUCCESS;
            } else {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }

            UHCD_KdPrint((2, "'inputBufferLength = %d outputBufferLength = %d\n",
                        inputBufferLength, outputBufferLength));

            UHCD_CompleteIrp(hcdDeviceObject, Irp, ntStatus,
                sizeof(HCD_STAT_INFORMATION_2), NULL);
            }
            break;


            #if DBG
            //
            // This is a test IOCTL only in debug versions
            //

        case IOCTL_USB_HCD_DISABLE_PORT:
            {
                PVOID ioBuffer;
                ULONG inputBufferLength;
                ULONG outputBufferLength;
                PIO_STACK_LOCATION pIrpSp;
                ULONG portIndex;
                PROOTHUB pRootHub;

                pIrpSp = IoGetCurrentIrpStackLocation(Irp);

                ioBuffer = Irp->AssociatedIrp.SystemBuffer;

                pRootHub = deviceExtension->RootHub;

                inputBufferLength
                    = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

                if (inputBufferLength < sizeof(ULONG)) {
                    ntStatus = STATUS_BUFFER_TOO_SMALL;
                    goto IoctlDisablePortError;
                }

                portIndex = *(ULONG *)ioBuffer;

                if (portIndex >= pRootHub->NumberOfPorts) {
                    ntStatus = STATUS_INVALID_PARAMETER;
                    goto IoctlDisablePortError;
                }

                //
                // Flag the port as having no devices in there and
                // status changed.
                //

                pRootHub->DisabledPort[portIndex]
                    |= UHCD_FAKE_CONNECT_CHANGE | UHCD_FAKE_DISCONNECT;

IoctlDisablePortError:;

                //
                // Complete the IRP
                //

                UHCD_CompleteIrp(hcdDeviceObject, Irp, ntStatus, 0, NULL);
            }
            break;

       case IOCTL_USB_HCD_ENABLE_PORT:
       {
      PVOID ioBuffer;
      ULONG inputBufferLength;
      ULONG outputBufferLength;
      PIO_STACK_LOCATION pIrpSp;
      ULONG portIndex;
      PROOTHUB pRootHub;

      pIrpSp = IoGetCurrentIrpStackLocation(Irp);

      ioBuffer = Irp->AssociatedIrp.SystemBuffer;

      pRootHub = deviceExtension->RootHub;

      inputBufferLength
          = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

      if (inputBufferLength < sizeof(ULONG)) {
          ntStatus = STATUS_BUFFER_TOO_SMALL;
          goto IoctlEnablePortError;
      }

      portIndex = *(ULONG *)ioBuffer;

      if (portIndex >= pRootHub->NumberOfPorts) {
          ntStatus = STATUS_INVALID_PARAMETER;
          goto IoctlEnablePortError;
      }

      //
      // Flag the port as having no devices in there and
      // status changed.
      //

      pRootHub->DisabledPort[portIndex] = UHCD_FAKE_CONNECT_CHANGE;

IoctlEnablePortError:;

      //
      // Complete the IRP
      //

      UHCD_CompleteIrp(hcdDeviceObject, Irp, ntStatus, 0, NULL);
       }
       break;

#endif

   default:
       ntStatus = STATUS_INVALID_DEVICE_REQUEST;

            UHCD_CompleteIrp(hcdDeviceObject, Irp,
                             STATUS_INVALID_DEVICE_REQUEST, 0, NULL);


        } /* case */

        break;

    //
    // Process PnP and Power messages
    //
    case IRP_MJ_POWER:
        // should not get here
        UHCD_KdTrap(("Power Message to HCD\n"));
        break;

    case IRP_MJ_PNP:

        ntStatus = UHCD_ProcessPnPIrp(hcdDeviceObject, Irp);
        break;

    default:
        UHCD_KdPrint((2, "'unrecognized IRP_MJ_ function (%x)\n", irpStack->MajorFunction));
        ntStatus = STATUS_INVALID_PARAMETER;
        UHCD_CompleteIrp(hcdDeviceObject, Irp, ntStatus, 0, NULL);
    } /* case MJ_FUNCTION */

UHCD_Dispatch_Done:

    UHCD_KdPrint((2, "'exit UHCD_Dispatch 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
UHCD_SetDevicePowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE DeviceState
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    DeviceState - Device specific power state to set the device in to.

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    BOOLEAN hookIt = FALSE;
    PIO_STACK_LOCATION irpStack;
    PUSBD_EXTENSION usbdExtension;
    PDEVICE_CAPABILITIES hcDeviceCapabilities;
    BOOLEAN bIsSuspend;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    if (irpStack->Parameters.Power.Type ==
            SystemPowerState) {

        switch (irpStack->Parameters.Power.State.SystemState) {
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:

            // suspend coming thru
            UHCD_KdPrint((1, "'Shutdown (Suspend) Host Controller\n"));
            deviceExtension->HcFlags |= HCFLAG_SUSPEND_NEXT_D3;

            ntStatus = STATUS_SUCCESS;
            break;

        case PowerSystemShutdown:

            //
            // this is a shutdown request
            //

            UHCD_KdPrint((1, "'Shutdown Host Controller\n"));

            //
            // do a stop to unhook the interrupt
            //
            UHCD_StopDevice(DeviceObject);

#ifdef NTKERN
            //
            // now give control back to the BIOS if we have one
            //
            if (deviceExtension->HcFlags & HCFLAG_USBBIOS) {
                UHCD_StartBIOS(DeviceObject);
            }
#endif

            ntStatus = STATUS_SUCCESS;
            break;

        default:
            // should not get here
            TRAP();
            break;
        }

    } else {
        bIsSuspend = (deviceExtension->HcFlags & HCFLAG_SUSPEND_NEXT_D3) ? 1:0;
        deviceExtension->HcFlags &= ~HCFLAG_SUSPEND_NEXT_D3;

        switch (DeviceState) {
        case PowerDeviceD3:
            //
            // Request for HC to power off
            // we will:
            //
            // 1. stop the controller schedule
            // 2. clean up the schedule
            // 3. reset the frame counter
            //

            LOGENTRY(LOG_MISC, 'D3go', deviceExtension, 0, 0);

            // it is possible (although remote) to are get a D3 with no
            // root hub attached if so we will turn off the hardware here
            if (!(deviceExtension->HcFlags & HCFLAG_RH_OFF)) {

                UHCD_SaveHCstate(DeviceObject);
                UHCD_Suspend(DeviceObject, FALSE);
            }

            UHCD_KdPrint((2, "'PowerDeviceD3 (OFF)\n"));

            // In the NT power management model, D3 is not necessarily "OFF".
            // What governs this is the DeviceWake setting in the DeviceCaps
            // structure.  If DeviceWake for our controller device is D3, then
            // we know that it is possible for the controller to wake the
            // machine from this power level.  The controller must have power
            // to be able to do so, therefore, we suppress setting the
            // HCFLAG_LOST_POWER flag in this case.  Setting it actually has
            // the undesired effect of causing us to reset the controller on
            // resume, which in turn causes the hub to fail and the devices to
            // be surprise removed/reenumerated unnecessarily when the hub is
            // reinitialized.  This normally isn't more than a minor annoyance
            // (e.g. slow resume time), except in the case where one of these
            // devices is a USB mass storage device.  Surprise removal is
            // dangerous for mass storage devices, and the user is presented
            // with the annoying "don't surprise remove this device" dialog
            // when the system is resumed, even though the user himself did not
            // directly cause the device removal.
            //
            // Note that the case where the host controller really does lose
            // power could result in the same problem, but that will have to
            // be addressed in the hub driver.

            usbdExtension = (PUSBD_EXTENSION)deviceExtension;
            hcDeviceCapabilities = &usbdExtension->HcDeviceCapabilities;
            if (!bIsSuspend ||
                DeviceState > hcDeviceCapabilities->DeviceWake) {
                deviceExtension->HcFlags |= HCFLAG_LOST_POWER;
                UHCD_KdPrint((1, "'HC will lose power in D3\n"));
            }
#if DBG
              else {
                UHCD_KdPrint((1, "'HC will NOT lose power in D3\n"));
            }
#endif

            // ensure no interrupts are generated by the controller
            {
                USHORT legsup;

                UHCD_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                                     TRUE,
                                     &legsup,
                                     0xc0,     // offset of legacy bios reg
                                     sizeof(legsup));

                LOGENTRY(LOG_MISC, 'PIRd', deviceExtension, legsup, 0);
                // clear the PIRQD routing bit
                legsup &= ~LEGSUP_USBPIRQD_EN;

                UHCD_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                                     FALSE,
                                     &legsup,
                                     0xc0,     // offset of legacy bios reg
                                     sizeof(legsup));
            }


            deviceExtension->CurrentDevicePowerState = DeviceState;
            UHCD_KdPrint((1, "'Host Controller entered (D%d)\n", DeviceState-1));

            // pass on to PDO
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
            //
            // power states D1,D2 translate to USB suspend

            UHCD_KdPrint((2, "'PowerDeviceD1/D2 (SUSPEND) HC\n"));
#ifdef DEBUG_LOG
            if (DeviceState == PowerDeviceD1) {
                LOGENTRY(LOG_MISC, 'D1go', deviceExtension, 0, 0);
            } else {
                LOGENTRY(LOG_MISC, 'D2go', deviceExtension, 0, 0);
            }
#endif

            // change the state of the PRIQD routing bit
            {
            USHORT legsup;

            UHCD_ReadWriteConfig(   deviceExtension->PhysicalDeviceObject,
                                    TRUE,
                                    &legsup,
                                    0xc0,     // offset of legacy bios reg
                                    sizeof(legsup));

            LOGENTRY(LOG_MISC, 'PIRd', deviceExtension, legsup, 0);
            // clear the PIRQD routing bit
            legsup &= ~LEGSUP_USBPIRQD_EN;

            UHCD_ReadWriteConfig(   deviceExtension->PhysicalDeviceObject,
                                    FALSE,
                                    &legsup,
                                    0xc0,     // offset of legacy bios reg
                                    sizeof(legsup));
            }

            //
            // Note, we should not get here unless all the children of the HC
            // have been suspended.
            //

            deviceExtension->CurrentDevicePowerState = DeviceState;
            UHCD_KdPrint((1, "'Host Controller entered (D%d)\n", DeviceState-1));

            // pass on to PDO
            break;

        case PowerDeviceD0:

            //
            // Request for HC to go to resume
            // we will:
            //
            // 1. start the controller in the completetion routine
            //

            UHCD_KdPrint((2, "'PowerDeviceD0 (ON), defer\n"));
            LOGENTRY(LOG_MISC, 'D0go', deviceExtension, 0, 0);

            //
            // finish the rest in the completion routine
            //

            hookIt = TRUE;

            // pass on to PDO
            break;

        default:

            UHCD_KdTrap(("Bogus DeviceState = %x\n", DeviceState));
        }

        if (hookIt) {
            UHCD_KdPrint((2, "'Set PowerIrp Completion Routine\n"));
            IoSetCompletionRoutine(Irp,
                   UHCD_PowerIrp_Complete,
                   // always pass FDO to completion routine
                   DeviceObject,
                   hookIt,
                   hookIt,
                   hookIt);
        }
    }

    return ntStatus;
}


NTSTATUS
UHCD_PowerIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;

    UHCD_KdPrint((2, "' enter UHCD_PowerIrp_Complete\n"));

    deviceObject = (PDEVICE_OBJECT) Context;
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    UHCD_KdPrint((1, "'Controller is in D0\n"));
    LOGENTRY(LOG_MISC, 'POWc', deviceExtension->CurrentDevicePowerState,
        0, Irp);

    // This function should only be called whe the controller
    // is put in D0
    UHCD_ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    UHCD_ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    UHCD_ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);
    UHCD_ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);

#ifdef JD
    //TEST_TRAP();
#endif

    ntStatus = deviceExtension->LastPowerUpStatus = Irp->IoStatus.Status;

    if (NT_SUCCESS(ntStatus)) {
       deviceExtension->CurrentDevicePowerState = PowerDeviceD0;
    }

    UHCD_KdPrint((2, "' exit UHCD_PowerIrp_Complete\n"));

    return ntStatus;
}

VOID
UHCD_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:

    None

--*/
{
    //
    // Free any global resources
    //

    UHCD_KdPrint((2, "'unloading\n"));

#ifdef DEBUG_LOG
    //
    // free our debug trace log
    //
    UHCD_LogFree();
#endif
}


NTSTATUS
UHCD_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT *DeviceObject,
    IN PUNICODE_STRING DeviceNameUnicodeString
    )
/*++

Routine Description:

    This routine is called to create a new instance of a USB host
    controller.

Arguments:

    DriverObject - pointer to the driver object for USBD.

    *DeviceObject - ptr to DeviceObject ptr to be filled
                    in with the device object we create.

    Configuration - ptr to configuration data to be stored
                    in the device extension.

    DeviceNameUnicodeString - optional pointer to a device
                    name for this FDO, can be NULL

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    UHCD_KdPrint((2, "'enter UHCD_CreateDeviceObject\n"));

    ntStatus = IoCreateDevice(DriverObject,
                              sizeof (DEVICE_EXTENSION),
                              DeviceNameUnicodeString, // Name
                              FILE_DEVICE_CONTROLLER,
                              0,
                              FALSE, //NOT Exclusive
                              DeviceObject);

    if (NT_SUCCESS(ntStatus)) {

        deviceExtension = (PDEVICE_EXTENSION) ((*DeviceObject)->DeviceExtension);


        UHCD_KdPrint((2, "'UHCD_CreateDeviceObject: device object %x device extension = %x\n",
                 *DeviceObject, deviceExtension));

    } else if (*DeviceObject) {
        IoDeleteDevice(*DeviceObject);
    }

    UHCD_KdPrint((2, "'exit UHCD_CreateDeviceObject (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
UHCD_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of a USB host controller

Arguments:

    DriverObject - pointer to the driver object for this instance of UHCD

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_EXTENSION deviceExtension;
    UNICODE_STRING deviceNameUnicodeString;
    ULONG deviceNameHandle;
    ULONG disableController = 0;

    UHCD_KdBreak((2, "'UHCD_PnPAddDevice\n"));

    LOGENTRY(LOG_MISC, 'ADDd', 0, 0, PhysicalDeviceObject);
//#ifdef JD
//    TEST_TRAP();
//#endif

    //UHCD_GetGlobalRegistryParameters(&disableController);

    if (disableController) {
        ntStatus = STATUS_UNSUCCESSFUL;
        goto UHCD_PnPAddDevice_Done;
    }


    //
    // Let USBD generate a device name
    //
    deviceNameHandle = USBD_AllocateDeviceName(&deviceNameUnicodeString);

    ntStatus = UHCD_CreateDeviceObject( DriverObject,
                                        &deviceObject,
                                        &deviceNameUnicodeString);

    LOGENTRY(LOG_MISC, 'cdnS', 0, 0, ntStatus);

    if (NT_SUCCESS(ntStatus)) {

        deviceExtension = deviceObject->DeviceExtension;

        RtlZeroMemory(deviceExtension, sizeof(DEVICE_EXTENSION));

        deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
        deviceExtension->DeviceNameHandle = deviceNameHandle;

        //
        // until we get a start we will comsider ourselves OFF
        //
        deviceExtension->CurrentDevicePowerState = PowerDeviceD3;

        //deviceExtension->NeedCleanup = FALSE;
        //deviceExtension->BWReclimationEnabled = FALSE;
        //deviceExtension->Stopped = FALSE;

        deviceExtension->TopOfStackDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        //
        // Indicate that the device object is ready for requests.
        //

        if (deviceExtension->TopOfStackDeviceObject) {

            //
            // a device object has been created, register with the bus driver now
            //

            USBD_RegisterHostController(PhysicalDeviceObject,
                                        deviceObject,
                                        deviceExtension->TopOfStackDeviceObject,
                                        DriverObject,
                                        UHCD_DeferredStartDevice,
                                        UHCD_SetDevicePowerState,
                                        UHCD_ExternalGetCurrentFrame,
#ifndef WIN98
                                        UHCD_ExternalGetConsumedBW,
#endif
                                        UHCD_SubmitFastIsoUrb,
                                        deviceNameHandle);
            {
            // make sure our USBD and HCD used matching hcdi header files
            PUSBD_EXTENSION usbdExtension;
            usbdExtension = deviceObject->DeviceExtension;
            if (usbdExtension->Length != sizeof(USBD_EXTENSION)) {
                UHCD_KdTrap(("UHCD/USBD version mismatch\n"));
                ntStatus = STATUS_UNSUCCESSFUL;
            }
            }

        }

        deviceObject->Flags |= DO_POWER_PAGABLE;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;


    }

    RtlFreeUnicodeString(&deviceNameUnicodeString);

UHCD_PnPAddDevice_Done:

    LOGENTRY(LOG_MISC, 'addD', 0, 0, ntStatus);

    UHCD_KdPrint((2, "'exit UHCD_PnPAddDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
UHCD_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}


VOID
UHCD_ReadWriteConfig(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  BOOLEAN Read,
    IN  PVOID Buffer,
    IN  ULONG Offset,
    IN  ULONG Length
)

/*++

Routine Description:

    This routine reads or write config space.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

    Read                - TRUE if read, FALSE if write.

    Buffer              - The info to read or write.

    Offset              - The offset in config space to read or write.

    Length              - The length to transfer.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    PAGED_CODE();

    if (Read) {
        memset(Buffer, '\0', Length);
    }

    irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (!irp) {
        UHCD_KdTrap(("failed to allocate Irp\n"));
        return;
    }

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           UHCD_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);


    nextStack = IoGetNextIrpStackLocation(irp);
    UHCD_ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= Read ? IRP_MN_READ_CONFIG : IRP_MN_WRITE_CONFIG;
    nextStack->Parameters.ReadWriteConfig.WhichSpace = 0;  /*PCI_WHICHSPACE_CONFIG */
    nextStack->Parameters.ReadWriteConfig.Buffer = Buffer;
    nextStack->Parameters.ReadWriteConfig.Offset = Offset;
    nextStack->Parameters.ReadWriteConfig.Length = Length;

    ntStatus = IoCallDriver(DeviceObject,
                            irp);

    UHCD_KdPrint((2, "'ntStatus from IoCallDriver to PCI = 0x%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete

       TEST_TRAP(); // first time we hit this

       KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
    }

    if (!NT_SUCCESS(ntStatus)) {
        // failed? this is probably a bug
        UHCD_KdTrap(("ReadWriteConfig failed, why?\n"));
    }

    IoFreeIrp(irp);
}


NTSTATUS
UHCD_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    )

/*++

Routine Description:

    This routine reads or write config space.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    PAGED_CODE();

    // init the caps structure before calldown
    RtlZeroMemory(DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = -1;
    DeviceCapabilities->UINumber = -1;

    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!irp) {
        UHCD_KdTrap(("failed to allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    nextStack = IoGetNextIrpStackLocation(irp);
    UHCD_ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           UHCD_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    ntStatus = IoCallDriver(PdoDeviceObject,
                            irp);

    UHCD_KdPrint((2, "'ntStatus from IoCallDriver to PCI = 0x%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete



       KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

        ntStatus = irp->IoStatus.Status;
    }

#if DBG
    if (!NT_SUCCESS(ntStatus)) {
        // failed? this is probably a bug
        UHCD_KdTrap(("QueryCapabilities failed, why?\n"));
    }
#endif

    IoFreeIrp(irp);

    return ntStatus;
}


#if 0
BOOLEAN
UHCD_StopController(
    IN PVOID Context
    )
/*++

Routine Description:

   Starts the USB host controller executing the schedule.
   Start Controller is called in by KeSynchronizeExecution.

Arguments:

   Context - DeviceData for this USB controller.

Return Value:

   TRUE

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    USHORT cmd;

    deviceExtension = Context;

    // no more interrupts
    cmd = 0;
    WRITE_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension), cmd);


    return TRUE;
}
#endif



NTSTATUS
UHCD_StopDevice(
     IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Resets the USB host controller and disconnects the interrupt.
    if a USB bios is present it is re-started.

Arguments:

    DeviceObject - DeviceObject of the controller to stop

Return Value:

    NT status code.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER startTime;
    USHORT cmd;
    USHORT status;
    KIRQL irql;

    UHCD_KdPrint((2, "'enter UHCD_StopDevice \n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (deviceExtension->HcFlags & HCFLAG_HCD_STOPPED) {
        // already stopped, bail
        goto UHCD_StopDevice_Done;
    }

    UHCD_DisableIdleCheck(deviceExtension);

    if (!(deviceExtension->HcFlags & HCFLAG_GOT_IO)) {
        // if we don't have io ports we can't stop
        // the controller
        //
        // This check is here because Win98 will send a stop
        // if we fail the start and we mail fail to start because
        // we did not get io ports
        goto UHCD_StopDevice_Done;
    }

    //
    // disable all interrupts
    //


//    KeSynchronizeExecution(deviceExtension->InterruptObject,
//                               UHCD_StopController,
//                               deviceExtension);
    cmd = 0;
    WRITE_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension), cmd);

    //
    // reset the controller
    //
    cmd = UHCD_CMD_RESET;
    WRITE_PORT_USHORT(COMMAND_REG(deviceExtension), cmd);

    // now wait for HC to reset
    KeQuerySystemTime(&startTime);
    for (;;) {
        LARGE_INTEGER sysTime;

        cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
        UHCD_KdPrint((2, "'COMMAND = %x\n", cmd));
        if ((cmd & UHCD_CMD_RESET) == 0) {
            break;
        }

        KeQuerySystemTime(&sysTime);
        if (sysTime.QuadPart - startTime.QuadPart > 10000) {
            // timeout trying to rest
#if DBG
            UHCD_KdPrint((1, "TIMEOUT RESETTING CONTROLLER! \n"));
            UHCD_KdPrint((1, "'Port Resources @ %x Ports Available \n",
                deviceExtension->Port));
            TRAP();
#endif
            break;
        }
    }

    //
    // after reset the halt bit is set, clear status register just
    // in case.
    //
    status = 0xff;
    WRITE_PORT_USHORT(STATUS_REG(deviceExtension), status);

#if DBG
    {
    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
    status = READ_PORT_USHORT(STATUS_REG(deviceExtension));
    UHCD_KdBreak((2, "'after reset cmd = %x stat = %x\n", cmd, status));
    }
#endif

UHCD_StopDevice_Done:

    //
    // handle no more interrupts for the HC
    //

    KeAcquireSpinLock(&deviceExtension->HcFlagSpin, &irql);
    deviceExtension->HcFlags |= HCFLAG_HCD_STOPPED;

    if (deviceExtension->InterruptObject) {
        PKINTERRUPT interruptObject;

        interruptObject = deviceExtension->InterruptObject;
        deviceExtension->InterruptObject = NULL;
        KeReleaseSpinLock(&deviceExtension->HcFlagSpin, irql);

        IoDisconnectInterrupt(interruptObject);
    } else {
        KeReleaseSpinLock(&deviceExtension->HcFlagSpin, irql);
    }

    UHCD_KdPrint((2, "'exit UHCD_StopDevice (%x)\n", ntStatus));

    return ntStatus;
}


VOID
UHCD_CleanupDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Cleans up resources allocated for the host controller,
    this routine should undo anything done in START_DEVICE
    that does not require access to the HC hardware.

Arguments:

    DeviceObject - DeviceObject of the controller to stop

Return Value:

    NT status code.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PUHCD_PAGE_LIST_ENTRY pageListEntry;
    BOOLEAN waitMore = TRUE;
    LARGE_INTEGER deltaTime;
#ifdef MAX_DEBUG
    extern LONG UHCD_CommonBufferBytes;
    extern LONG UHCD_TotalAllocatedHeapSpace;
#endif

    PAGED_CODE();
    UHCD_KdPrint((2, "'enter UHCD_CleanupDevice \n"));

    if (deviceExtension->HcFlags & HCFLAG_NEED_CLEANUP) {

        deviceExtension->HcFlags &= ~HCFLAG_NEED_CLEANUP;

   if (deviceExtension->RootHubPollTimerInitialized) {
       KeCancelTimer(&deviceExtension->RootHubPollTimer);
   }

        //
        // If someone issued a reset to one of the root
        // hub ports before the stop there may be timers
        // still outstanding, we wait here fo them to
        // expire.
        //

        while (deviceExtension->RootHubTimersActive) {

            //
            // wait 20 ms for our timers to expire
            //
            deltaTime.QuadPart = -10000 * 20;
            (VOID) KeDelayExecutionThread(KernelMode,
                                          FALSE,
                                          &deltaTime);

       waitMore = FALSE;
        }

   //
   // Wait for the polling timer to expire if we didn't wait
   // for the the root hub timers
   //

   if (waitMore && deviceExtension->RootHubPollTimerInitialized) {
       deltaTime.QuadPart = -10000 * 10;
       (VOID)KeDelayExecutionThread(KernelMode, FALSE,
                &deltaTime);
   }

        //
        // free memory allocated for frame list
        //

        if (deviceExtension->FrameListVirtualAddress != NULL) {
            UHCD_ASSERT(deviceExtension->AdapterObject != NULL);


            HalFreeCommonBuffer(deviceExtension->AdapterObject,
#if DBG
                                FRAME_LIST_LENGTH *3,
#else
                                FRAME_LIST_LENGTH *2,
#endif
                                deviceExtension->FrameListLogicalAddress,
                                deviceExtension->FrameListVirtualAddress,
                                FALSE);



            deviceExtension->FrameListVirtualAddress = NULL;

#if DBG
           {
           extern LONG UHCD_CommonBufferBytes;
           UHCD_ASSERT(UHCD_CommonBufferBytes > FRAME_LIST_LENGTH*3);
           UHCD_CommonBufferBytes -= (FRAME_LIST_LENGTH*3);
           }
#endif
        }

        // free HW descriptors used as interrupt triggers
        if (deviceExtension->PersistantQueueHead) {
            UHCD_FreeHardwareDescriptors(DeviceObject, deviceExtension->PQH_DescriptorList);
            deviceExtension->PersistantQueueHead = NULL;
        }

        //
        // unmap device registers here
        //
        if (deviceExtension->HcFlags & HCFLAG_UNMAP_REGISTERS) {
           TEST_TRAP();
        }

        if (deviceExtension->Piix4EP) {
            RETHEAP(deviceExtension->Piix4EP);
            deviceExtension->Piix4EP = NULL;
        }

        //BUGBUG
        //ASSERT that we have no active endpoints
        //and that no endpoints are on the close list


        //
        // free root hub memory
        //
        if (deviceExtension->RootHub) {
#if DBG
            if (deviceExtension->RootHub->DisabledPort) {
               RETHEAP (deviceExtension->RootHub->DisabledPort);
            }
#endif
            RETHEAP(deviceExtension->RootHub);
            deviceExtension->RootHub = NULL;
        }

        //
        // free all pages allocated with HalAllocateCommonBuffer
        //

        while (!IsListEmpty(&deviceExtension->PageList)) {
            pageListEntry = (PUHCD_PAGE_LIST_ENTRY)
                RemoveHeadList(&deviceExtension->PageList);
#ifdef MAX_DEBUG
            UHCD_CommonBufferBytes -= pageListEntry->Length;
#endif

            HalFreeCommonBuffer(deviceExtension->AdapterObject,
                                pageListEntry->Length,
                                pageListEntry->LogicalAddress,
                                pageListEntry,
                                FALSE);
        }

        //
        // NOTE: may not have an adapter object if getresources fails
        //

        if (deviceExtension->AdapterObject) {
	    KIRQL oldIrql;
	    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
            (deviceExtension->AdapterObject->DmaOperations->PutDmaAdapter)
                (deviceExtension->AdapterObject);
	    KeLowerIrql (oldIrql);
        }
        deviceExtension->AdapterObject = NULL;
#ifdef MAX_DEBUG
        {
        extern LONG UHCD_CommonBufferBytes;
        extern LONG UHCD_TotalAllocatedHeapSpace;
        //
        // Check totalmemory allocated count
        //
        if (UHCD_TotalAllocatedHeapSpace != 0) {
            //
            // memory leak!!
            //
            TRAP();
        }

        if (UHCD_CommonBufferBytes != 0) {
            //
            // memory leak!!
            //
            TRAP();
        }
        TEST_TRAP();
        }
#endif
    }

    UHCD_KdPrint((2, "'exit UHCD_CleanupDevice (%x)\n", STATUS_SUCCESS));

    return;
}


NTSTATUS
UHCD_InitializeSchedule(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initializes the schedule structures for the HCD

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT Status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    ULONG i, length;
    PHW_QUEUE_HEAD persistantQueueHead;
    PUHCD_HARDWARE_DESCRIPTOR_LIST pqh_DescriptorList;

    PAGED_CODE();
    UHCD_KdPrint((2, "'enter UHCD_InitializeSchedule\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // allocate a contiguous range of physical memory for the frame list --
    // we will need enough for 1024 physical addresses
    //

    length = FRAME_LIST_LENGTH;

    // 
    // Allocate a common buffer for the frame list (that is programmed into
    // the hardware later) as well as a copy of the active frame list.
    //

    deviceExtension->FrameListVirtualAddress =
        HalAllocateCommonBuffer(deviceExtension->AdapterObject,
#if DBG
                                length*3,
#else
                                length*2,
#endif
                                &deviceExtension->FrameListLogicalAddress,
                                FALSE);



#if DBG
    {
        extern LONG UHCD_CommonBufferBytes;
        UHCD_CommonBufferBytes += length*3;
    }
#endif

    //
    // Set the copy pointer into the common buffer at the end of the
    // master frame list.
    //

    deviceExtension->FrameListCopyVirtualAddress =
        ((PUCHAR) deviceExtension->FrameListVirtualAddress) + length;

    if (deviceExtension->FrameListVirtualAddress == NULL ||
        deviceExtension->FrameListCopyVirtualAddress == NULL) {
        if (deviceExtension->FrameListVirtualAddress != NULL) {

           HalFreeCommonBuffer(deviceExtension->AdapterObject,
#if DBG
                            length*3,
#else
                            length*2,
#endif
                            deviceExtension->FrameListLogicalAddress,
                            deviceExtension->FrameListVirtualAddress,
                            FALSE);

           deviceExtension->FrameListVirtualAddress = NULL;

#if DBG
	   {
	       extern LONG UHCD_CommonBufferBytes;
	       UHCD_CommonBufferBytes -= length*3;
	   }
#endif
        }
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto UHCD_InitializeScheduleExit;
    } else {
        RtlZeroMemory(deviceExtension->FrameListVirtualAddress, length);
        RtlZeroMemory(deviceExtension->FrameListCopyVirtualAddress, length);
#if DBG
        deviceExtension->IsoList =
            (PULONG)(((PUCHAR) deviceExtension->FrameListCopyVirtualAddress) + length);
        RtlZeroMemory(deviceExtension->IsoList, length);
        UHCD_KdPrint((2, "'(%d) bytes allocated for usb iso list va = %x\n", length,
                        deviceExtension->IsoList));

#endif
        //
        // this should be 1 page
        //
        UHCD_KdPrint((2, "'(%d) bytes allocated for usb frame list va = %x\n", length,
                        deviceExtension->FrameListVirtualAddress));

        UHCD_KdPrint((2, "'(%d) bytes allocated for usb frame list copy va = %x\n", length,
                        deviceExtension->FrameListCopyVirtualAddress));

    }

    //
    // Initialize the lists of Memory Descriptors
    // used to allocate TDs and packet buffers
    //

    UHCD_InitializeCommonBufferPool(DeviceObject,
                                    &deviceExtension->LargeBufferPool,
                                    UHCD_LARGE_COMMON_BUFFER_SIZE,
                                    UHCD_RESERVE_LARGE_BUFFERS);

    UHCD_InitializeCommonBufferPool(DeviceObject,
                                    &deviceExtension->MediumBufferPool,
                                    UHCD_MEDIUM_COMMON_BUFFER_SIZE,
                                    UHCD_RESERVE_MEDIUM_BUFFERS);

    UHCD_InitializeCommonBufferPool(DeviceObject,
                                    &deviceExtension->SmallBufferPool,
                                    UHCD_SMALL_COMMON_BUFFER_SIZE,
                                    UHCD_RESERVE_SMALL_BUFFERS);


    //
    // Now set up our base queues for active endpoints
    //

    InitializeListHead(&deviceExtension->EndpointList);
    InitializeListHead(&deviceExtension->EndpointLookAsideList);
    InitializeListHead(&deviceExtension->FastIsoEndpointList);
    InitializeListHead(&deviceExtension->FastIsoTransferList);

    //
    // Queue for released endpoints
    //
    InitializeListHead(&deviceExtension->ClosedEndpointList);

    //BUGBUG check for error

    //
    // TDs are allocated for use as interrupt triggers.
    // the first two are used to detect when the sign bit for
    // the frame counter changes.
    //
    // The rest are used to generate interrupts for cleanup and cancel
    //

    if (!UHCD_AllocateHardwareDescriptors(DeviceObject,
                                          &deviceExtension->PQH_DescriptorList,
                                          MAX_TDS_PER_ENDPOINT)) {


        HalFreeCommonBuffer(deviceExtension->AdapterObject,
#if DBG
                            length*3,
#else
                            length*2,
#endif
                            deviceExtension->FrameListLogicalAddress,
                            deviceExtension->FrameListVirtualAddress,
                            FALSE);


        deviceExtension->FrameListVirtualAddress = NULL;


#if DBG
    {
        extern LONG UHCD_CommonBufferBytes;
        UHCD_CommonBufferBytes -= length*3;
    }
#endif

       ntStatus = STATUS_INSUFFICIENT_RESOURCES;
       goto UHCD_InitializeScheduleExit;
    }

    pqh_DescriptorList = deviceExtension->PQH_DescriptorList;
    persistantQueueHead =
        deviceExtension->PersistantQueueHead = (PHW_QUEUE_HEAD) pqh_DescriptorList->MemoryDescriptor->VirtualAddress;

    UHCD_KdPrint((2, "'Control Queue Head va = (%x)\n", deviceExtension->PersistantQueueHead));

    //
    // This is our base queue head, it goes in every frame
    // but never has transfers associated with it.
    // Control Q heads are always added after this guy,
    // Bulk Q heads are always added in front of this guy (end of queue).
    //
    // initialize Horiz ptr to point to himself with the T-Bit set
    //
    persistantQueueHead->HW_HLink = persistantQueueHead->PhysicalAddress;
    SET_T_BIT(persistantQueueHead->HW_HLink);
    persistantQueueHead->HW_VLink = LIST_END;
    persistantQueueHead->Next =
        persistantQueueHead->Prev = persistantQueueHead;

    // Put the control 'base' queue in every frame
    for (i=0; i < FRAME_LIST_SIZE; i++)
        *( ((PULONG) (deviceExtension->FrameListVirtualAddress)+i) ) =
            persistantQueueHead->PhysicalAddress;

    //
    // Initialize an empty interrupt schedule.
    //

    for (i=0; i < MAX_INTERVAL; i++)
        deviceExtension-> InterruptSchedule[i] =
            persistantQueueHead;


    // this is a dummy TD we use to generate an interrupt
    // when the sign bit changes on the frame counter
    deviceExtension->TriggerTDList = (PUHCD_TD_LIST) (pqh_DescriptorList->MemoryDescriptor->VirtualAddress +
                UHCD_HW_DESCRIPTOR_SIZE);

    deviceExtension->TriggerTDList->TDs[0].Active = 0;
    deviceExtension->TriggerTDList->TDs[0].InterruptOnComplete = 1;
#ifdef VIA_HC
    // VIA Host Controller requires a valid PID even if the TD is inactive
    deviceExtension->TriggerTDList->TDs[0].PID = USB_IN_PID;
#endif /* VIA_HC */

    deviceExtension->TriggerTDList->TDs[1].Active = 0;
    deviceExtension->TriggerTDList->TDs[1].InterruptOnComplete = 1;
#ifdef VIA_HC
    deviceExtension->TriggerTDList->TDs[1].PID = USB_IN_PID;
#endif /* VIA_HC */
    deviceExtension->TriggerTDList->TDs[0].HW_Link =
        deviceExtension->TriggerTDList->TDs[1].HW_Link = persistantQueueHead->PhysicalAddress;

    //
    // The PIIX3 has the following bug:
    //
    // If a frame babble occurrs an interrupt in generated with no way to
    // clear it -- the host controller will continue to generate interrupts
    // until an active TD is encountered.
    //
    // The workaround for this is to put an active TD in the schedule
    // (on the persistent queue head).  We activate this TD whenever a TD
    // completes with the babble bit set.
    //


    //
    // set up a TD for frame babble recovery
    //
    {
        PHW_TRANSFER_DESCRIPTOR transferDescriptor;

        transferDescriptor =
            &deviceExtension->TriggerTDList->TDs[2];

        transferDescriptor->Active = 1;
        transferDescriptor->Isochronous = 1;
        transferDescriptor->InterruptOnComplete = 0;
        transferDescriptor->PID = USB_OUT_PID;
        transferDescriptor->Address = 0;
        transferDescriptor->Endpoint = 1;
        transferDescriptor->ErrorCounter = 0;
        transferDescriptor->PacketBuffer = 0;
        transferDescriptor->MaxLength =
            NULL_PACKET_LENGTH;

        // point to ourself
        transferDescriptor->HW_Link =
            transferDescriptor->PhysicalAddress;
        //SET_T_BIT(transferDescriptor->HW_Link);

        // point the persistent queue head at this TD
        persistantQueueHead->HW_VLink =
            transferDescriptor->PhysicalAddress;

        deviceExtension->FrameBabbleRecoverTD =
            transferDescriptor;
    }

    // Initilaize the remainder of the trigger TDs for use by the
    // transfer code -- used to generate interrupts.
    for (i=UHCD_FIRST_TRIGGER_TD; i<MAX_TDS_PER_ENDPOINT; i++) {
        PHW_TRANSFER_DESCRIPTOR transferDescriptor;

        transferDescriptor =
            &deviceExtension->TriggerTDList->TDs[i];

        transferDescriptor->PID = USB_IN_PID;
        transferDescriptor->Frame = 0;
    }


    // Initialize internal frame counters.
    deviceExtension->FrameHighPart =
        deviceExtension->LastFrame = 0;

    // BUGBUG for now just insert trigger TDs
    *( ((PULONG) (deviceExtension->FrameListVirtualAddress)) )  =
        deviceExtension->TriggerTDList->TDs[0].PhysicalAddress;

    *( ((PULONG) (deviceExtension->FrameListVirtualAddress) + FRAME_LIST_SIZE-1) )  =
        deviceExtension->TriggerTDList->TDs[1].PhysicalAddress;

    // schedule has been set up, make copy here
    RtlCopyMemory(deviceExtension->FrameListCopyVirtualAddress,
                  deviceExtension->FrameListVirtualAddress,
                  FRAME_LIST_SIZE * sizeof(HW_DESCRIPTOR_PHYSICAL_ADDRESS));
    UHCD_KdPrint((2, "'FrameListCopy = %x FrameList= %x\n",
                  deviceExtension->FrameListCopyVirtualAddress,
                  deviceExtension->FrameListVirtualAddress));
    //
    // Initilaize Root hub variables
    //

    deviceExtension->RootHubDeviceAddress = USB_DEFAULT_DEVICE_ADDRESS;
    deviceExtension->RootHubInterruptEndpoint = NULL;

    //
    // Initialize Isoch variables
    //

    deviceExtension->LastFrameProcessed = 0;

    //
    // Initialize Misc variables
    //

    deviceExtension->EndpointListBusy = FALSE;
    deviceExtension->LastPowerUpStatus = STATUS_SUCCESS;

    UHCD_InitBandwidthTable(DeviceObject);

    KeInitializeSpinLock(&deviceExtension->EndpointListSpin);

    KeInitializeSpinLock(&deviceExtension->HcFlagSpin);
    KeInitializeSpinLock(&deviceExtension->HcDmaSpin);
    KeInitializeSpinLock(&deviceExtension->HcScheduleSpin);
    deviceExtension->HcDma = -1;

    //
    // fix PIIX4 issues.
    //
    UHCD_FixPIIX4(DeviceObject);

UHCD_InitializeScheduleExit:

    LOGENTRY(LOG_MISC, 'BASE', deviceExtension->FrameListVirtualAddress, 0, DeviceObject);

    UHCD_KdPrint((2, "'exit UHCD_InitializeSchedule (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
UHCD_StartGlobalReset(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initializes the hardware registers in the host controller.

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT Status code.

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();
    UHCD_KdPrint((2, "'enter UHCD_StartGlobalReset\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    LOGENTRY(LOG_MISC, 'InHW', DeviceObject, deviceExtension, 0);

    UHCD_KdPrint((2, "'before init -- hardware state: Command = %x Status = %x  interrupt mask %x\nFrame Base = %x\n",
                    READ_PORT_USHORT(COMMAND_REG(deviceExtension)),
                    READ_PORT_USHORT(STATUS_REG(deviceExtension)),
                    READ_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension)),
                    READ_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension))));

    //
    // Perform global reset on the controller
    //
    // A global reset of the USB requires 20ms, we
    // begin the process here and finish later (in the
    // hub emulation code)

    UHCD_KdPrint((2, "'Begin Global Reset of Host Controller \n"));

    WRITE_PORT_USHORT(COMMAND_REG(deviceExtension),  UHCD_CMD_GLOBAL_RESET);

    UHCD_KdPrint((2, "'exit UHCD_StartGlobalReset -- (STATUS_SUCCESS)\n"));

    return STATUS_SUCCESS;
}


NTSTATUS
UHCD_CompleteGlobalReset(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Starts the USB host controller executing the schedule,
    his routine is called when the global reset for the
    controller has completed.

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT Status code.

--*/
{
    PHYSICAL_ADDRESS frameListBaseAddress;
    PDEVICE_EXTENSION deviceExtension;
    USHORT cmd;

    UHCD_KdPrint((2, "'enter CompleteGlobalReset\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Initialization has completed
    //

    UHCD_KdPrint((2, "'Initialization Completed, starting controller\n"));

    // clear the global reset bit
    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
    WRITE_PORT_USHORT(COMMAND_REG(deviceExtension),  cmd &= ~UHCD_CMD_GLOBAL_RESET);

    UHCD_KdPrint((2, "'after global reset -- hardware state: Command = %x Status = %x  interrupt mask %x\nFrame Base = %x\n",
                    READ_PORT_USHORT(COMMAND_REG(deviceExtension)),
                    READ_PORT_USHORT(STATUS_REG(deviceExtension)),
                    READ_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension)),
                    READ_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension))));

    //
    // do a HC reset
    //

//    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension)) | UHCD_CMD_RESET;
//    WRITE_PORT_USHORT(COMMAND_REG(deviceExtension),  cmd);

    // stall for 10 microseconds
//    KeStallExecutionProcessor(10);        //stall for 10 microseconds

//    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));

    //
    // HCReset bit should be cleared when HC completes the reset
    //

//    if (cmd &  UHCD_CMD_RESET) {
//        UHCD_KdPrint((2, "'Host Controller unable to reset!!!\n"));
//        TRAP();
//    }

    //
    // program the frame list base address
    //

    frameListBaseAddress = deviceExtension->FrameListLogicalAddress;

    WRITE_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension), frameListBaseAddress.LowPart);
    UHCD_KdPrint((2, "'Frame list base address programmed to (physical) %x.\n", frameListBaseAddress));

    UHCD_KdPrint((2, "'after init -- hardware state: Command = %x Status = %x  interrupt mask %x\nFrame Base = %x\n",
                    READ_PORT_USHORT(COMMAND_REG(deviceExtension)),
                    READ_PORT_USHORT(STATUS_REG(deviceExtension)),
                    READ_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension)),
                    READ_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension))));

    if (deviceExtension->SteppingVersion >= UHCD_B0_STEP) {
#ifdef ENABLE_B0_FEATURES
        //
        // set maxpacket for bandwidth reclimation
        //

        // TEST_TRAP();
        WRITE_PORT_USHORT(COMMAND_REG(deviceExtension),  UHCD_CMD_MAXPKT_64);
        UHCD_KdPrint((2, "'Set MaxPacket to 64\n"));
#endif
    }

    //
    // Enable Interrupts on the controller
    //


    UHCD_KdPrint((2, "'Enable Interrupts \n"));
    cmd = UHCD_INT_MASK_IOC | UHCD_INT_MASK_TIMEOUT | UHCD_INT_MASK_RESUME;
    if (deviceExtension->SteppingVersion >= UHCD_B0_STEP) {
        // enable short packet detect
        cmd |= UHCD_INT_MASK_SHORT;
    }

    WRITE_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension), cmd);

    // set the SOF modify to whatever we found before
    // the reset

    UHCD_KdPrint((1, "'Setting SOF Modify to %d\n",
            deviceExtension->SavedSofModify));

    WRITE_PORT_UCHAR(SOF_MODIFY_REG(deviceExtension),
        deviceExtension->SavedSofModify);

    //
    // Start the controller schedule
    //

    UHCD_KdPrint((2, "'Set Run/Stop bit \n"));

    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension)) | UHCD_CMD_RUN;
    WRITE_PORT_USHORT(COMMAND_REG(deviceExtension), cmd);

    //
    // Make sure that the controller is really running and if not, kick it
    //

    UhcdKickStartController(DeviceObject);

    UHCD_KdPrint((2, "'after start -- hardware state: Command = %x Status = %x  interrupt mask %x\nFrame Base = %x\n",
                    READ_PORT_USHORT(COMMAND_REG(deviceExtension)),
                    READ_PORT_USHORT(STATUS_REG(deviceExtension)),
                    READ_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension)),
                    READ_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension))));


    UHCD_KdPrint((2, "'exit CompleteGlobalReset\n"));

    return STATUS_SUCCESS;
}


ULONG
UHCD_GetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    returns the current frame number as an unsigned 32-bit value.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    Current Frame Number.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    ULONG currentFrame, highPart, frameNumber;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // The following algorithm compliments
    // of jfuller and kenr
    //

    // get Hcd's high part of frame number
    highPart = deviceExtension->FrameHighPart;

    // get 11-bit frame number, high 17-bits are 0
    frameNumber = (ULONG) READ_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension));

    currentFrame = ((frameNumber & 0x0bff) | highPart) +
        ((frameNumber ^ highPart) & 0x0400);

    //UHCD_KdPrint((2, "'exit UHCD_GetCurrentFrame = %d\n", currentFrame));

    return currentFrame;

}


NTSTATUS
UHCD_SaveHCstate(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

Arguments:

    DeviceObject        - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT cmd;
    PDEVICE_EXTENSION deviceExtension;

    UHCD_KdPrint((1, "'saving host controller state\n"));
    LOGENTRY(LOG_MISC, 'HCsv', 0, 0, 0);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    //
    // save some state info
    //
    deviceExtension->SavedInterruptEnable =
        READ_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension));

    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
    // save the cmd regs in the "stopped" state
    cmd &= ~UHCD_CMD_RUN;

    deviceExtension->SavedCommandReg = cmd;

    // additonal saved info needed to restore from hibernate
    deviceExtension->SavedFRNUM =
        READ_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension));
    deviceExtension->SavedFRBASEADD =
        READ_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension));

    return ntStatus;
}


NTSTATUS
UHCD_RestoreHCstate(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

Arguments:

    DeviceObject        - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    BOOLEAN lostPower = FALSE;
    LARGE_INTEGER deltaTime;
    BOOLEAN apm = FALSE;

    UHCD_KdPrint((1, "'restoring host controller state\n"));
    LOGENTRY(LOG_MISC, 'HCrs', 0, 0, 0);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // this check tells us that power was turned off
    // to the controller.
    //
    // IBM Aptiva rapid resume will turn off power to
    // the controller without going thru the OS
    // may APM BIOSes do this too
    //

    // see if we were in D3, if so restore additional info
    // necessary to recover from hibernate

    if (deviceExtension->HcFlags & HCFLAG_LOST_POWER) {
        UHCD_KdPrint((0, "'restoring HC from hibernate\n"));

        deviceExtension->HcFlags &= ~HCFLAG_LOST_POWER;
        // we will need to do much the same thing we do
        // in START_DEVICE

        // first restore the HC regs for the schedule
        WRITE_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension),
            deviceExtension->SavedFRNUM);
        WRITE_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension),
            deviceExtension->SavedFRBASEADD);

         // now do a global reset
        ntStatus = UHCD_StartGlobalReset(DeviceObject);

        if (!NT_SUCCESS(ntStatus)) {
            goto UHCD_RestoreHCstate_Done;
        }
        //
        // Everything is set, we need to wait for the
        // global reset of the Host controller to complete.
        //

        // 20 ms to reset...
        deltaTime.QuadPart = -10000 * 20;

        //
        // block here until reset is complete
        //

        (VOID) KeDelayExecutionThread(KernelMode,
                                      FALSE,
                                      &deltaTime);

        ntStatus = UHCD_CompleteGlobalReset(DeviceObject);

        lostPower = TRUE;

    } else {
        //
        // interrupt masks disabled indicates power was turned
        // off to the piix3/piix4.
        //
        lostPower =
            (BOOLEAN) (READ_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension)) == 0);
        // we get here on APM/ACPI systems
        // note that lostPower should be false on an ACPI system
        apm = TRUE;
    }

    if (lostPower)  {
        // we get here for hibernate, APM suspend or ACPI D2/D3
        // on hibernate we need to re-init the controller
        // on APM we let the BIOS do it.

        //for APM:
        //  lostPower = TRUE if APM BIOS turned off hc
        //  apm = TRUE

        //for ACPI D3/Hibernate
        //  HCFLAG_LOST_POWER flag is set
        //  lostPower TRUE

        //for ACPI D2 & APM supprted USB suspend
        //  lostPower = FALSE
        //  HCFLAG_LOST_POWER is clear
        //  apm = FALSE;

        UHCD_KdPrint((0, "'detected (APM/HIBERNATE) loss of power during suspend\n"));

        if (apm) {
            //
            // some APM BIOSes trash these registers so we'll have to put
            // them back
            //

            WRITE_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension),
                deviceExtension->SavedFRNUM);

            WRITE_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension),
                deviceExtension->SavedFRBASEADD);
        }

        WRITE_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension),
            deviceExtension->SavedInterruptEnable);

        WRITE_PORT_USHORT(COMMAND_REG(deviceExtension),
            deviceExtension->SavedCommandReg);
    }

UHCD_RestoreHCstate_Done:

    return ntStatus;
}



NTSTATUS
UHCD_Suspend(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN SuspendBus
    )

/*++

Routine Description:

    This routine suspends the host controller.

Arguments:

    DeviceObject        - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    USHORT cmd, status;
    LARGE_INTEGER finishTime, currentTime;

    PAGED_CODE();

    UHCD_KdPrint((1, "'suspending Host Controller (Root Hub)\n"));
    LOGENTRY(LOG_MISC, 'RHsu', 0, 0, 0);
#ifdef JD
    //TEST_TRAP();
#endif
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //may not be in D0 if we haven't started yet.
    //UHCD_ASSERT(deviceExtension->CurrentDevicePowerState == PowerDeviceD0);

    UHCD_DisableIdleCheck(deviceExtension);

#if DBG
    UHCD_KdPrint((2, "'HC regs before suspend\n"));
    UHCD_KdPrint((2, "'cmd register = %x\n",
        READ_PORT_USHORT(COMMAND_REG(deviceExtension)) ));
    UHCD_KdPrint((2, "'status register = %x\n",
        READ_PORT_USHORT(STATUS_REG(deviceExtension)) ));
    UHCD_KdPrint((2, "'interrupt enable register = %x\n",
        READ_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension)) ));

    UHCD_KdPrint((2, "'frame list base = %x\n",
        READ_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension)) ));
#endif

    //
    // save some state info
    //
    deviceExtension->SavedInterruptEnable =
        READ_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension));

    // set the run/stop bit

    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
    cmd &= ~UHCD_CMD_RUN;

    deviceExtension->SavedCommandReg = cmd;

    UHCD_KdPrint((2, "'run/stop = %x\n", cmd));
    WRITE_PORT_USHORT(COMMAND_REG(deviceExtension), cmd);



    KeQuerySystemTime(&finishTime); // get current time
    finishTime.QuadPart += 5000000; // figure when we quit (.5 seconds
                                    // later)

    // poll the status reg for the halt bit
    for (;;) {
        status = READ_PORT_USHORT(STATUS_REG(deviceExtension));
        UHCD_KdPrint((2, "'STATUS = %x\n", status));
        if (status & UHCD_STATUS_HCHALT) {
            break;
        }
        KeQuerySystemTime(&currentTime);
        if (currentTime.QuadPart >= finishTime.QuadPart) {
            UHCD_KdPrint((0, "'Warning: Host contoller did not respond to halt req\n"));
#if DBG
            if (SuspendBus) {
                // this is very bad if we are suspending
                TRAP();
            }
#endif
            break;
        }
    }

    UHCD_KdPrint((2, "'UHCD Suspend RH, schedule stopped\n"));

    // reset the frame list current index
    WRITE_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension), 0);

    // re-initialize internal frame counters.
    deviceExtension->FrameHighPart =
        deviceExtension->LastFrame = 0;

    deviceExtension->XferIdleTime =
        deviceExtension->IdleTime = 0;

    // clear idle flag sinec we will be running on resume
    // note we leave the state of the rollover ints since
    // it reflects the status of the TDs not the HC schecdule

    deviceExtension->HcFlags &= ~HCFLAG_IDLE;

    //
    // we let the hub driver handle suspending the ports
    //

// BUGBUG
// not sure if we need to force resume
    if (SuspendBus) {
        LOGENTRY(LOG_MISC, 'RHew', 0, 0, 0);
        cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
        // FGR=0
        cmd &= ~UHCD_CMD_FORCE_RESUME;
        // EGSM=1
        cmd |= UHCD_CMD_SUSPEND;
        UHCD_KdPrint((2, "'enter suspend = %x\n", cmd));
        WRITE_PORT_USHORT(COMMAND_REG(deviceExtension), cmd);
    }

    UHCD_KdPrint((2, "'exit UHCD_SuspendHC 0x%x\n", ntStatus));
#ifdef MAX_DEBUG
    TEST_TRAP();
#endif

    return ntStatus;
}


NTSTATUS
UHCD_Resume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DoResumeSignaling
    )

/*++

Routine Description:

    This routine resumes the host controller from either the
    OFF or suspended state.

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT cmd;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER deltaTime;

    UHCD_KdPrint((1, "'resuming Host Controller (Root Hub)\n"));
    LOGENTRY(LOG_MISC, 'RHre', 0, 0, 0);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

#if DBG
    UHCD_KdPrint((2, "'HC regs after suspend\n"));
    UHCD_KdPrint((2, "'cmd register = %x\n",
        READ_PORT_USHORT(COMMAND_REG(deviceExtension)) ));
    UHCD_KdPrint((2, "'status register = %x\n",
        READ_PORT_USHORT(STATUS_REG(deviceExtension)) ));
    UHCD_KdPrint((2, "'interrupt enable register = %x\n",
        READ_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension)) ));

    UHCD_KdPrint((2, "'frame list base = %x\n",
        READ_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension)) ));
#endif

    // if we are resuming the controller should be in D0
    UHCD_ASSERT(deviceExtension->CurrentDevicePowerState == PowerDeviceD0);

    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
    if (DoResumeSignaling) {
        // force a global resume
        UHCD_KdPrint((2, "'forcing resume = %x\n", cmd));
        cmd |= UHCD_CMD_FORCE_RESUME;
        WRITE_PORT_USHORT(COMMAND_REG(deviceExtension), cmd);

        //
        // wait 20 ms for our timers to expire
        //
        deltaTime.QuadPart = -10000 * 20;
        (VOID) KeDelayExecutionThread(KernelMode,
                                      FALSE,
                                      &deltaTime);

        //done with resume
        cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
        cmd &= ~(UHCD_CMD_SUSPEND | UHCD_CMD_FORCE_RESUME);
        UHCD_KdPrint((2, "'clear suspend = %x\n", cmd));
        WRITE_PORT_USHORT(COMMAND_REG(deviceExtension), cmd);

        //
        // start schedule
        //

        // wait for FGR bit to go low
        do {
            cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
        } while (cmd & UHCD_CMD_FORCE_RESUME);

    }

    // start controller
    cmd |= UHCD_CMD_RUN;

    UHCD_KdPrint((2, "'exit resume = %x\n", cmd));
    WRITE_PORT_USHORT(COMMAND_REG(deviceExtension), cmd);

    //
    // Note: we let the hub driver handle resume
    // signaling
    //

    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));


    //
    // Make sure that the controller is really running and if not, kick it
    //

    UhcdKickStartController(DeviceObject);

    UHCD_KdPrint((2, "'exit UHCD_Resume 0x%x\n", ntStatus));
#ifdef MAX_DEBUG
    TEST_TRAP();
#endif

    // enable the idle check routine
    deviceExtension->HcFlags &= ~HCFLAG_DISABLE_IDLE;

    UHCD_KdPrint((1, "'Host controller root hub entered D0\n"));

    return ntStatus;
}


NTSTATUS
UHCD_ExternalGetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG CurrentFrame
    )

/*++

Routine Description:


Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    *CurrentFrame = UHCD_GetCurrentFrame(DeviceObject);

    return STATUS_SUCCESS;
}


ULONG
UHCD_ExternalGetConsumedBW(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:


Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    ULONG low, i;

    LOGENTRY(LOG_MISC, 'AVbw', 0, 0, 0);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    low = UHCD_TOTAL_USB_BW;

    // find the lowest value in our available bandwidth table

    for (i=0; i<MAX_INTERVAL; i++) {
        //
        // max bytes per frame - bw reaerved for bulk and control
        //
        if (deviceExtension->BwTable[i] < low) {
            low = deviceExtension->BwTable[i];
        }
    }

    // lowest available - total = consumed bw

    return UHCD_TOTAL_USB_BW-low;
}


NTSTATUS
UHCD_RootHubPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles power messages to the root hub, note that
    we save the state of the HC here instead of when the HC itself is
    powered down.  The reason for this is for compatibility with APM
    systems that cut power to the HC during a suspend.  On these
    systems WDM never sends a power state change mesage to the HC ie
    the HC is assumed to always stay on.

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;

    UHCD_KdPrint((2, "'UHCD_RootHubPower\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    LOGENTRY(LOG_MISC, 'HCrp', irpStack->MinorFunction, 0, 0);

    switch (irpStack->MinorFunction) {
    case IRP_MN_WAIT_WAKE:
        UHCD_KdPrint((2, "'IRP_MN_WAIT_WAKE\n"));
        //
        // someone is enabling us for wakeup
        //
        LOGENTRY(LOG_MISC, 'rpWW', 0, 0, 0);

        TEST_TRAP();  // never seen this before?
        break;

    case IRP_MN_SET_POWER:

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
            LOGENTRY(LOG_MISC, 'SPsp', 0, 0, 0);

            // should not get here
            UHCD_KdTrap(("RootHubPower -- SystemState\n"));
            break;

        case DevicePowerState:

            LOGENTRY(LOG_MISC, 'SPdp', 0, 0, 0);
            switch(irpStack->Parameters.Power.State.DeviceState) {
            case PowerDeviceD0:
                {
                BOOLEAN doResumeSignaling;

                if (!NT_SUCCESS(deviceExtension->LastPowerUpStatus)) {
                   ntStatus = deviceExtension->LastPowerUpStatus;
                } else {
                   doResumeSignaling = !(deviceExtension->HcFlags
                                         & HCFLAG_RH_OFF);
                   deviceExtension->HcFlags &= ~HCFLAG_RH_OFF;
                   UHCD_SetControllerD0(DeviceObject);
                   UHCD_RestoreHCstate(DeviceObject);

                   ntStatus = UHCD_Resume(DeviceObject, doResumeSignaling);
                }
                }
                break;
            case PowerDeviceD1:
            case PowerDeviceD2:
                UHCD_SaveHCstate(DeviceObject);
                ntStatus = UHCD_Suspend(DeviceObject, TRUE);
                break;
            case PowerDeviceD3:
                deviceExtension->HcFlags |= HCFLAG_RH_OFF;
                UHCD_SaveHCstate(DeviceObject);
                ntStatus = UHCD_Suspend(DeviceObject, FALSE);
                break;
            }
            break;
        }
    }

    return ntStatus;
}

VOID
UhcdKickStartController(IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

    Best effort at fixing a hung UHCI device on power up.
    Symptom is that everything is fine and chip in run state,
    but frame counter never increments.  It was found that if
    we strobe the run/stop (RS) bit, the frame counter starts incrementing
    and the device starts working.

    We don't know the exact cause or why the fix appears to work, but the
    addition of this code was requested by MS management to help alleviate the
    problem.

Arguments:

    PDevObj        - DeviceObject for this USB controller.

Return Value:

    VOID

--*/
{
   PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
   USHORT cmd;
   USHORT counter;
   ULONG i;
   LARGE_INTEGER deltaTime;



   for (i = 0; i < UHCD_MAX_KICK_STARTS; i++) {
      //
      // Wait at least two frames (2 ms)
      //


      deltaTime.QuadPart = -10000 * 2;
      KeDelayExecutionThread(KernelMode, FALSE, &deltaTime);

      counter = READ_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(pDevExt));

      if (counter != 0x0000) {
         //
         // It is working splendidly
         //

         break;
      }

      //
      // The frame counter is jammed.  Kick the chip.
      //

      cmd = READ_PORT_USHORT(COMMAND_REG(pDevExt)) & ~UHCD_CMD_RUN;
      WRITE_PORT_USHORT(COMMAND_REG(pDevExt), cmd);

      //
      // Delay two frames (2ms)
      //

      deltaTime.QuadPart = -10000 * 2;
      KeDelayExecutionThread(KernelMode, FALSE, &deltaTime);

      cmd |= UHCD_CMD_RUN;

      WRITE_PORT_USHORT(COMMAND_REG(pDevExt), cmd);
   }

   LOGENTRY(LOG_MISC | LOG_IO, 'HCks', i, UHCD_MAX_KICK_STARTS, 0);
}


NTSTATUS
UHCD_FixPIIX4(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:


 PIIX4 hack

 we will need a dummy bulk queue head inserted in the schedule
    This routine resumes the host controller.

Arguments:

    DeviceObject        - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/
{
    PUHCD_ENDPOINT endpoint;
    PHW_TRANSFER_DESCRIPTOR transferDescriptor,
        qhtransferDescriptor;
    PHW_QUEUE_HEAD queueHead;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;


    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // create the endpoint
    //

    endpoint = GETHEAP(NonPagedPool, sizeof(UHCD_ENDPOINT));

    if (endpoint) {
        deviceExtension->Piix4EP = endpoint;
        endpoint->Type = USB_ENDPOINT_TYPE_BULK;
        endpoint->Sig = SIG_EP;
        endpoint->EndpointFlags = 0;

        // we will use two of the trigger TDs
        //
        // to set up the dummy qh with TD attached.
        //

        transferDescriptor =
                &deviceExtension->TriggerTDList->TDs[3];

        transferDescriptor->Active = 0;
        transferDescriptor->Isochronous = 1;
        transferDescriptor->InterruptOnComplete = 0;
        transferDescriptor->PID = USB_OUT_PID;
        transferDescriptor->Address = 0;
        transferDescriptor->Endpoint = 1;
        transferDescriptor->ErrorCounter = 0;
        transferDescriptor->PacketBuffer = 0;
        transferDescriptor->MaxLength =
            NULL_PACKET_LENGTH;


        // point to ourself
        transferDescriptor->HW_Link =
            transferDescriptor->PhysicalAddress;

        queueHead = (PHW_QUEUE_HEAD)
                &deviceExtension->TriggerTDList->TDs[4];

        qhtransferDescriptor =
                &deviceExtension->TriggerTDList->TDs[4];

        UHCD_InitializeHardwareQueueHeadDescriptor(
                DeviceObject,
                queueHead,
                qhtransferDescriptor->PhysicalAddress);

        UHCD_KdPrint((2, "'PIIX4 dummy endpoint, qh 0x%x\n", endpoint, queueHead));

        //link the td to the QH
        queueHead->HW_VLink = transferDescriptor->PhysicalAddress;
        queueHead->Endpoint = endpoint;

        UHCD_InsertQueueHeadInSchedule(DeviceObject,
                                       endpoint,
                                       queueHead,
                                       0);

        UHCD_BW_Reclimation(DeviceObject, FALSE);

    } else {
        // could not get memory for dummy queue head,
        // something is really broken.
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        UHCD_KdTrap(("failed to get memory for dummy qh\n"));
    }

    return ntStatus;
}

#ifdef USB_BIOS

// this is the Phoenix revised version
NTSTATUS
UHCD_StopBIOS(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine stops a UHCI USB BIOS if present.

Arguments:

    DeviceObject        - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    USHORT cmd;
    USHORT legsup, status;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    LARGE_INTEGER startTime;
    ULONG sofModifyValue = 0;
    WCHAR UHCD_SofModifyKey[] = L"SofModify";


    PAGED_CODE();
    UHCD_KdPrint((2, "'UHCD_Stopping BIOS\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    // initilialize to whatever the BIOS set it to.
    sofModifyValue =
        (ULONG) (READ_PORT_UCHAR(SOF_MODIFY_REG(deviceExtension)));

    //
    // save current values for BIOS hand-back
    //

    deviceExtension->BiosCmd =
        READ_PORT_USHORT(COMMAND_REG(deviceExtension));

    deviceExtension->BiosIntMask =
        READ_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension));

    deviceExtension->BiosFrameListBase =
        READ_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension));
    deviceExtension->BiosFrameListBase &= 0xfffff000;

    // Grab any SOF ModifyValue indicated in the registry

    //USBD_GetPdoRegistryParameter(deviceExtension->PhysicalDeviceObject,
    //                             &sofModifyValue,
    //                             sizeof(sofModifyValue),
    //                            UHCD_SofModifyKey,
    //                             sizeof(UHCD_SofModifyKey));

    UHCD_GetSOFRegModifyValue(DeviceObject,
                              &sofModifyValue);

    // save the SOF modify for posterity
    deviceExtension->SavedSofModify = (CHAR) sofModifyValue;
    UHCD_ASSERT(sofModifyValue <= 255);

    // stop the controller,
    // clear RUN bit but keep config flag set so BIOS won't reinit
    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
    LOGENTRY(LOG_MISC, 'spBI', cmd, 0, 0);
    // BUGBUG
    // save cmd bits to set when we hand back
    cmd &= ~(UHCD_CMD_RUN | UHCD_CMD_SW_CONFIGURED);
    WRITE_PORT_USHORT(COMMAND_REG(deviceExtension), cmd);

    // NOTE: if no BIOS is present
    // halt bit is initially set with PIIX3
    // halt bit is initially clear with VIA

    // now wait for HC to halt
    KeQuerySystemTime(&startTime);
    for (;;) {
        LARGE_INTEGER sysTime;

        status = READ_PORT_USHORT(STATUS_REG(deviceExtension));
        UHCD_KdPrint((2, "'STATUS = %x\n", status));
        if (status & UHCD_STATUS_HCHALT) {
            WRITE_PORT_USHORT(STATUS_REG(deviceExtension), 0xff);
            LOGENTRY(LOG_MISC, 'spBH', cmd, 0, 0);
            break;
        }

        KeQuerySystemTime(&sysTime);
        if (sysTime.QuadPart - startTime.QuadPart > 10000) {
            // time out
#if DBG
            UHCD_KdPrint((1,
                "'TIMEOUT HALTING CONTROLLER! (I hope you don't have USB L-BIOS)\n"));
            UHCD_KdPrint((1, "'THIS IS A BIOS BUG, Port Resources @ %x Ports Available \n",
                deviceExtension->Port));
            //TRAP();
#endif
            break;
        }
    }

    UHCD_ReadWriteConfig(   deviceExtension->PhysicalDeviceObject,
                            TRUE,
                            &legsup,
                            0xc0,     // offset of legacy bios reg
                            sizeof(legsup));


    LOGENTRY(LOG_MISC, 'legs', legsup, 0, 0);
    UHCD_KdPrint((2, "'legs = %x\n", legsup));

#ifdef JD
//    TEST_TRAP();
#endif
    // save it
    deviceExtension->LegacySupportRegister = legsup;
    if ((legsup & LEGSUP_BIOS_MODE) != 0) {


        // BUGBUG save old state
        deviceExtension->HcFlags |= HCFLAG_USBBIOS;

        UHCD_KdPrint((1, "'*** uhcd detected a USB legacy BIOS ***\n"));

        //
        // if BIOS mode bits set we have to take over
        //

        // shut off host controller SMI enable
        legsup &= ~0x10;
        UHCD_ReadWriteConfig(   deviceExtension->PhysicalDeviceObject,
                                FALSE,
                                &legsup,
                                0xc0,     // offset of legacy bios reg
                                sizeof(legsup));

        //
        // BUGBUG
        // out 0xff to 64h if possible
        //

        //
        // take control
        //

        // read
        UHCD_ReadWriteConfig(   deviceExtension->PhysicalDeviceObject,
                                TRUE,
                                &legsup,
                                0xc0,     // offset of legacy bios reg
                                sizeof(legsup));

        legsup = LEGSUP_HCD_MODE;
        //write
        UHCD_ReadWriteConfig(   deviceExtension->PhysicalDeviceObject,
                                FALSE,
                                &legsup,
                                0xc0,     // offset of legacy bios reg
                                sizeof(legsup));

    }

    UHCD_KdPrint((2, "'exit UHCD_StopBIOS 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
UHCD_StartBIOS(
    IN  PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine start a USB bios.

Arguments:

    DeviceObject        - DeviceObject for this USB controller.

Return Value:

    NT status code.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    USHORT cmd, legsup;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    UHCD_KdPrint((1, "'Returning Control to USB BIOS, base port = %x\n",
        deviceExtension->DeviceRegisters[0]));

    // restore saved reg values

    WRITE_PORT_USHORT(STATUS_REG(deviceExtension), 0xff);

    WRITE_PORT_USHORT(INTERRUPT_MASK_REG(deviceExtension),
        deviceExtension->BiosIntMask);
    WRITE_PORT_ULONG(FRAME_LIST_BASE_REG(deviceExtension),
        deviceExtension->BiosFrameListBase);

    legsup = deviceExtension->LegacySupportRegister;

    //write
    UHCD_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                         FALSE,
                         &legsup,
                         0xc0,     // offset of legacy bios reg
                         sizeof(legsup));


    // read
    UHCD_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                         TRUE,
                         &legsup,
                         0xc0,     // offset of legacy bios reg
                         sizeof(legsup));

    // enable SMI
    legsup |= 0x10;
    //write
    UHCD_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                         FALSE,
                         &legsup,
                         0xc0,     // offset of legacy bios reg
                         sizeof(legsup));

    cmd = deviceExtension->BiosCmd | UHCD_CMD_RUN;
    WRITE_PORT_USHORT(COMMAND_REG(deviceExtension),
            cmd);

    return ntStatus;
}

#endif //USB_BIOS

NTSTATUS
UHCD_GetResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCM_RESOURCE_LIST ResourceList,
    IN OUT PUHCD_RESOURCES Resources
    )

/*++

Routine Description:

Arguments:

    DeviceObject        - DeviceObject for this USB controller.

    ResourceList        - Resources for this controller.

Return Value:

    NT status code.

--*/

{
    ULONG i;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR interrupt;
    PHYSICAL_ADDRESS cardAddress;
    ULONG addressSpace;
    PDEVICE_EXTENSION deviceExtension;
    PCM_PARTIAL_RESOURCE_LIST PartialResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR fullResourceDescriptor;
    BOOLEAN gotIO=FALSE, gotIRQ=FALSE;

    UHCD_KdPrint((2, "'enter UHCD_GetResources\n"));

    LOGENTRY(LOG_MISC, 'GRES', 0, 0, 0);

    if (ResourceList == NULL) {
        UHCD_KdPrint((1, "'got no resources, failing start.\n"));
        return STATUS_NONE_MAPPED;
    }

    fullResourceDescriptor = &ResourceList->List[0];
    PartialResourceList = &fullResourceDescriptor->PartialResourceList;

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Initailize our page list, do this here so that UHCD_CleanupDevice can
    // clean up if necessary.
    //

    InitializeListHead(&deviceExtension->PageList);

    deviceExtension->HcFlags |= HCFLAG_NEED_CLEANUP;

    for (i = 0; i < PartialResourceList->Count && NT_SUCCESS(ntStatus); i++) {

        switch (PartialResourceList->PartialDescriptors[i].Type) {
        case CmResourceTypePort:

            //
            // Set up AddressSpace to be of type Port I/O
            //

            UHCD_KdPrint((1, "'Port Resources Found @ %x, %d Ports Available \n",
                PartialResourceList->PartialDescriptors[i].u.Port.Start.LowPart,
                PartialResourceList->PartialDescriptors[i].u.Port.Length));

#if DBG
            deviceExtension->Port =
                PartialResourceList->PartialDescriptors[i].u.Port.Start.LowPart;
#endif

            addressSpace =
                (PartialResourceList->PartialDescriptors[i].Flags & CM_RESOURCE_PORT_IO) ==
                CM_RESOURCE_PORT_IO? 1:0;

            cardAddress=PartialResourceList->PartialDescriptors[i].u.Port.Start;

            if (!addressSpace) {
                deviceExtension->HcFlags |= HCFLAG_UNMAP_REGISTERS;
                deviceExtension->DeviceRegisters[0] =
                    MmMapIoSpace(
                    cardAddress,
                    PartialResourceList->PartialDescriptors[i].u.Port.Length,
                    FALSE);
            } else {
                deviceExtension->HcFlags &= ~HCFLAG_UNMAP_REGISTERS;
                deviceExtension->DeviceRegisters[0] =
                    (PVOID)(ULONG_PTR)cardAddress.QuadPart;
            }

            //
            // see if we successfully mapped the IO regs
            //

            if (!deviceExtension->DeviceRegisters[0]) {
                UHCD_KdPrint((2, "'Couldn't map the device registers. \n"));
                ntStatus = STATUS_NONE_MAPPED;

            } else {
                UHCD_KdPrint((2, "'Mapped device registers to 0x%x.\n",
                    deviceExtension->DeviceRegisters[0]));
                gotIO=TRUE;
                deviceExtension->HcFlags |= HCFLAG_GOT_IO;
            }

            break;

        case CmResourceTypeInterrupt:

            //
            // Get Vector, level, and affinity information for this interrupt.
            //

            UHCD_KdPrint((1, "'Interrupt Resources Found!  Level = %x Vector = %x\n",
                PartialResourceList->PartialDescriptors[i].u.Interrupt.Level,
                PartialResourceList->PartialDescriptors[i].u.Interrupt.Vector
                ));

            interrupt = &PartialResourceList->PartialDescriptors[i];
            gotIRQ=TRUE;

            //BUGBUG ??
            //KeInitializeSpinLock(&DeviceExtension->InterruptSpinLock);


            //DeviceExtension->InterruptMode = PartialResourceList->PartialDescriptors[i].Flags;

            break;

        case CmResourceTypeMemory:

            //
            // Set up AddressSpace to be of type Memory mapped I/O
            //

            UHCD_KdPrint((1, "'Memory Resources Found @ %x, Length = %x\n",
                PartialResourceList->PartialDescriptors[i].u.Memory.Start.LowPart,
                PartialResourceList->PartialDescriptors[i].u.Memory.Length
                ));

            // we should never get memory resources
            UHCD_KdTrap(("PnP gave us memory resources!!\n"));

            break;

        } /* switch */
    } /* for */

    //
    // Sanity check that we got enough resources.
    //
    if (!gotIO || !gotIRQ) {
        UHCD_KdPrint((1, "'Missing IO or IRQ: failing to start\n"));
        ntStatus = STATUS_NONE_MAPPED;
    }

    if (NT_SUCCESS(ntStatus)) {
        //
        // Note that we have all the resources we need
        // to start
        //

        //
        // Set up our interrupt.
        //

        UHCD_KdPrint((2, "'requesting interrupt vector %x level %x\n",
                                interrupt->u.Interrupt.Level,
                                interrupt->u.Interrupt.Vector));

        Resources->InterruptLevel=(KIRQL)interrupt->u.Interrupt.Level;
        Resources->InterruptVector=interrupt->u.Interrupt.Vector;
        Resources->Affinity=interrupt->u.Interrupt.Affinity;

        //
        // Initialize the interrupt object for the controller.
        //

        deviceExtension->InterruptObject = NULL;
        Resources->ShareIRQ =
            interrupt->ShareDisposition == CmResourceShareShared ? TRUE : FALSE;
        Resources->InterruptMode =
            interrupt->Flags == CM_RESOURCE_INTERRUPT_LATCHED ? Latched : LevelSensitive;

#ifdef MAX_DEBUG
        UHCD_KdPrint((2, "'interrupt->ShareDisposition %x\n", interrupt->ShareDisposition));
        if (!Resources->ShareIRQ) {
            TEST_TRAP();
        }
#endif
    }


    UHCD_KdPrint((2, "'exit UHCD_GetResources (%x)\n", ntStatus));
    LOGENTRY(LOG_MISC, 'GRS1', 0, 0, ntStatus);

    return ntStatus;
}

NTSTATUS
UHCD_StartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_RESOURCES Resources
    )

/*++

Routine Description:

    This routine initializes the DeviceObject for a given instance
    of a USB host controller.

Arguments:

    DeviceObject  - DeviceObject for this USB controller.

    Resources - our assigned resources

Return Value:

    NT status code.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER deltaTime;
    DEVICE_CAPABILITIES deviceCapabilities;
    ULONG numberOfMapRegisters = (ULONG)-1;
    DEVICE_DESCRIPTION deviceDescription;
    BOOLEAN isPIIX3or4;
    ULONG disableSelectiveSuspendValue = 0;
    WCHAR disableSelectiveSuspendKey[] = DISABLE_SELECTIVE_SUSPEND;
    WCHAR clocksPerFrameKey[] = CLOCKS_PER_FRAME;
    WCHAR recClocksPerFrameKey[] = REC_CLOCKS_PER_FRAME;
    LONG clocksPerFrame = 0;
    LONG recClocksPerFrame = 0;
    PUSBD_EXTENSION usbdExtension;

    PAGED_CODE();
    deviceExtension = DeviceObject->DeviceExtension;

    // get the debug options from the registry
#if DBG
    UHCD_GetClassGlobalDebugRegistryParameters();
#endif

    UHCD_KdPrint((2, "'enter UHCD_StartDevice\n"));

    deviceExtension->HcFlags &= ~HCFLAG_HCD_STOPPED;

    // enable the idle check routine
    deviceExtension->HcFlags &= ~HCFLAG_DISABLE_IDLE;

    LOGENTRY(LOG_MISC, 'STRT', deviceExtension->TopOfStackDeviceObject, 0, 0);

    //
    // sanity check our registers
    //
    {
    USHORT cmd;

    cmd = READ_PORT_USHORT(COMMAND_REG(deviceExtension));
    if (cmd == 0xffff) {
        UHCD_KdPrint((0, "'Controller Registers are bogus -- this is a bug\n"));
        UHCD_KdPrint((0, "'Controller will FAIL to start\n"));
        TRAP();
        // regs are bogus -- clear the gotio flag so we don't
        // try to access the registers any more
        deviceExtension->HcFlags &= ~HCFLAG_GOT_IO;
        ntStatus = STATUS_UNSUCCESSFUL;
    }
    }

    if (!NT_SUCCESS(ntStatus)) {
        goto UHCD_InitializeDeviceExit;
    }

    //
    // Create our adapter object
    //

    RtlZeroMemory(&deviceDescription, sizeof(deviceDescription));

    //BUGBUG check these
    deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
    deviceDescription.Master = TRUE;
    deviceDescription.ScatterGather = TRUE;
    deviceDescription.Dma32BitAddresses = TRUE;

    deviceDescription.InterfaceType = PCIBus;
    deviceDescription.DmaWidth = Width32Bits;
    deviceDescription.DmaSpeed = Compatible;

    deviceDescription.MaximumLength = (ULONG)-1;

    deviceExtension->NumberOfMapRegisters = (ULONG)-1;
    deviceExtension->AdapterObject =
        IoGetDmaAdapter(deviceExtension->PhysicalDeviceObject,
                        &deviceDescription,
                        &deviceExtension->NumberOfMapRegisters);

    if (deviceExtension->AdapterObject == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto UHCD_InitializeDeviceExit;
    }

    //
    // We found a host controller or a host controller found us, do the final
    // stages of initialization.
    // Setup state variables for the host controller
    //

    ntStatus = UHCD_QueryCapabilities(deviceExtension->TopOfStackDeviceObject,
                                     &deviceCapabilities);

    if (!NT_SUCCESS(ntStatus)) {
        goto UHCD_InitializeDeviceExit;
    }

    if (deviceExtension->HcFlags & HCFLAG_MAP_SX_TO_D3) {
        ULONG i;

        for (i=PowerSystemSleeping1; i< PowerSystemMaximum; i++) {

            deviceCapabilities.DeviceState[i] = PowerDeviceD3;

            UHCD_KdPrint((1, "'changing -->S%d = D%d\n", i-1,
                deviceCapabilities.DeviceState[i]-1));
        }
    }

#if DBG
    {
        ULONG i;
        UHCD_KdPrint((1, "'HCD Device Caps returned from PCI:\n"));
        UHCD_KdPrint((1, "'\tSystemWake = S%d\n", deviceCapabilities.SystemWake-1));
        UHCD_KdPrint((1, "'\tDeviceWake = D%d\n", deviceCapabilities.DeviceWake-1));
        UHCD_KdPrint((1, "'\tDevice State Map:\n"));

        for (i=0; i< PowerSystemHibernate; i++) {
             UHCD_KdPrint((1, "'\t-->S%d = D%d\n", i-1,
                 deviceCapabilities.DeviceState[i]-1));
        }
    }
#endif

    USBD_RegisterHcDeviceCapabilities(DeviceObject,
                                      &deviceCapabilities,
                                      UHCD_RootHubPower);

    //
    // Detect the Host Controller stepping version.
    //
    {
        UCHAR revisionId;
        USHORT vendorId, deviceId;

        UHCD_KdPrint((2, "'Get the stepping version\n"));

        UHCD_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                             TRUE,
                             &vendorId,
                             0,
                             sizeof(vendorId));

        UHCD_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                             TRUE,
                             &deviceId,
                             2,
                             sizeof(deviceId));

        UHCD_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                             TRUE,
                             &revisionId,
                             8,
                             sizeof(revisionId));

        UHCD_KdPrint((1, "'HC vendor = %x device = %x rev = %x\n",
                vendorId, deviceId, revisionId));

        if (vendorId == UHCD_INTEL_VENDOR_ID &&
            deviceId == UHCD_PIIX3_DEVICE_ID) {
            UHCD_KdPrint((1, "'detected PIIX3\n"));
            deviceExtension->ControllerType = UHCI_HW_VERSION_PIIX3;
        } else if (vendorId == UHCD_INTEL_VENDOR_ID &&
                   deviceId == UHCD_PIIX4_DEVICE_ID) {
            UHCD_KdPrint((1, "'detected PIIX4\n"));
            deviceExtension->ControllerType = UHCI_HW_VERSION_PIIX4;
        } else {
            UHCD_KdPrint((1, "'detected unknown host controller type\n"));
            deviceExtension->ControllerType = UHCI_HW_VERSION_UNKNOWN;
        }


        //
        // is this an A1 stepping version of the piix3?
        //
        if (revisionId == 0 &&
            vendorId == UHCD_INTEL_VENDOR_ID &&
            deviceId == UHCD_PIIX3_DEVICE_ID) {
            //yes, we will fail to load on the A1 systems
            UHCD_KdPrint((0, "'Intel USB HC stepping version A1 is not supported\n"));
            deviceExtension->SteppingVersion = UHCD_A1_STEP;
            ntStatus = STATUS_UNSUCCESSFUL;
        } else {
#ifdef ENABLE_B0_FEATURES
            deviceExtension->SteppingVersion = UHCD_B0_STEP;
#else
            deviceExtension->SteppingVersion = UHCD_A1_STEP;
#endif //ENABLE_B0_FEATURES
        }

#ifdef USB_BIOS
        if (NT_SUCCESS(ntStatus)) {
            ntStatus = UHCD_StopBIOS(DeviceObject);
        }
#endif //USB_BIOS
    }

    {
        USHORT legsup;

        UHCD_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                             TRUE,
                             &legsup,
                             0xc0,     // offset of legacy bios reg
                             sizeof(legsup));

        LOGENTRY(LOG_MISC, 'PIRd', deviceExtension, legsup, 0);
        // set the PIRQD routing bit
        legsup |= LEGSUP_USBPIRQD_EN;

        UHCD_ReadWriteConfig(   deviceExtension->PhysicalDeviceObject,
                                FALSE,
                                &legsup,
                                0xc0,     // offset of legacy bios reg
                                sizeof(legsup));
    }

    if (!NT_SUCCESS(ntStatus)) {
        goto UHCD_InitializeDeviceExit;
    }

    ntStatus = UHCD_InitializeSchedule(DeviceObject);

    LOGENTRY(LOG_MISC, 'INIs', 0, 0, ntStatus);
    if (!NT_SUCCESS(ntStatus)) {
        UHCD_KdPrint((0, "'InitializeSchedule Failed! %x\n", ntStatus));
        goto UHCD_InitializeDeviceExit;
    }

    //
    // initialization all done, last step is to connect the interrupt & DPCs.
    //

    KeInitializeDpc(&deviceExtension->IsrDpc,
                    UHCD_IsrDpc,
                    DeviceObject);

    UHCD_KdPrint((2, "'requesting interrupt vector %x level %x\n",
                                Resources->InterruptLevel,
                                Resources->InterruptVector));

    ntStatus = IoConnectInterrupt(
                 &(deviceExtension->InterruptObject),
                 (PKSERVICE_ROUTINE) UHCD_InterruptService,
                 (PVOID) DeviceObject,
                 (PKSPIN_LOCK)NULL,
                 Resources->InterruptVector,
                 Resources->InterruptLevel,
                 Resources->InterruptLevel,
                 Resources->InterruptMode,
                 Resources->ShareIRQ,
                 Resources->Affinity,
                 FALSE);            // BUGBUG FloatingSave, this is configurable

    LOGENTRY(LOG_MISC, 'IOCi', 0, 0, ntStatus);
    if (!NT_SUCCESS(ntStatus)) {
        UHCD_KdPrint((0, "'IoConnectInterrupt Failed! %x\n", ntStatus));
        goto UHCD_InitializeDeviceExit;
    }

    // consider ourselves 'ON'
    deviceExtension->CurrentDevicePowerState = PowerDeviceD0;

    //
    // Initialize the controller registers.
    // NOTE:
    // We don't do reset until the interrrupt is hooked because
    // the HC for some reason likes to generate an interrupt
    // (USBINT) when it is reset.
    //

    ntStatus = UHCD_StartGlobalReset(DeviceObject);

    LOGENTRY(LOG_MISC, 'GLBr', 0, 0, ntStatus);
    if (!NT_SUCCESS(ntStatus)) {
        UHCD_KdPrint((0, "'GlobalReset Failed! %x\n", ntStatus));
        goto UHCD_InitializeDeviceExit;
    }
    //
    // Everything is set, we need to wait for the
    // global reset of the Host controller to complete.
    //

    // 20 ms to reset...
    deltaTime.QuadPart = -10000 * 20;

    //
    // block here until reset is complete
    //

    (VOID) KeDelayExecutionThread(KernelMode,
                                  FALSE,
                                  &deltaTime);

    ntStatus = UHCD_CompleteGlobalReset(DeviceObject);

    // 10 ms for devices to recover
    // BUGBUG seems the Philips speakers need this
//    deltaTime.QuadPart = -10000 * 1000;
//
//    (VOID) KeDelayExecutionThread(KernelMode,
//                                  FALSE,
//                                  &deltaTime);

    if (!NT_SUCCESS(ntStatus)) {
        goto UHCD_InitializeDeviceExit;
    }

    //
    // bus reset complete, now activate the root hub emulation
    //
#ifdef ROOT_HUB
    UHCD_KdPrint((2, "'Initialize Root Hub\n"));

    //
    // BUGBUG hard coded to two ports
    //
    isPIIX3or4 = (deviceExtension->ControllerType == UHCI_HW_VERSION_PIIX3) ||
                  (deviceExtension->ControllerType == UHCI_HW_VERSION_PIIX4);

    USBD_GetPdoRegistryParameter(deviceExtension->PhysicalDeviceObject,
                                 &disableSelectiveSuspendValue,
                                 sizeof(disableSelectiveSuspendValue),
                                 disableSelectiveSuspendKey,
                                 sizeof(disableSelectiveSuspendKey));

    USBD_GetPdoRegistryParameter(deviceExtension->PhysicalDeviceObject,
                                 &recClocksPerFrame,
                                 sizeof(recClocksPerFrame),
                                 recClocksPerFrameKey,
                                 sizeof(recClocksPerFrameKey));

    deviceExtension->RegRecClocksPerFrame =
        recClocksPerFrame;

    if ((deviceExtension->RootHub =
         RootHub_Initialize(DeviceObject,
                            2,
                            (BOOLEAN)(!isPIIX3or4 &&
                                      !disableSelectiveSuspendValue))) == NULL) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
#if DBG
    if (!isPIIX3or4 && !disableSelectiveSuspendValue) {
        UHCD_KdPrint ((1, "'selective suspend enabled\n"));
    } else {
        UHCD_KdPrint ((1, "'selective suspend disabled\n"));
    }
#endif

    // HACK - Tell USBD if this HC is PIIX3 or PIIX4.

    if (isPIIX3or4) {
        usbdExtension = (PUSBD_EXTENSION)deviceExtension;
        usbdExtension->IsPIIX3or4 = TRUE;
    }

    // END HACK

    deviceExtension->RootHubTimersActive = 0;
#endif //ROOT_HUB

    //
    // our current power state is 'ON'
    //
    deviceExtension->CurrentDevicePowerState = PowerDeviceD0;

    // this will disable the controller if nothing
    // is initailly connected to the ports
    KeQuerySystemTime(&deviceExtension->LastIdleTime);
    deviceExtension->IdleTime = 100000000;
    deviceExtension->XferIdleTime = 0;

UHCD_InitializeDeviceExit:

    if (!NT_SUCCESS(ntStatus)) {
#ifdef MAX_DEBUG
        TEST_TRAP();
#endif
        UHCD_KdPrint((2, "'Initialization Failed, cleaning up \n"));

        //
        // The initialization failed.  Cleanup resources before exiting.
        //
        //
        // Note:  No need/way to undo the KeInitializeDpc or
        //        KeInitializeTimer calls.
        //

        UHCD_CleanupDevice(DeviceObject);

    }

    UHCD_KdPrint((2, "'exit UHCD_StartDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
UHCD_DeferredStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT Status code.

--*/
{
    NTSTATUS ntStatus;
    UHCD_RESOURCES resources;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;
    ULONG forceLowPowerState = 0;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    // initailize extension here
    deviceExtension->HcFlags = 0;

    UHCD_GetClassGlobalRegistryParameters(&forceLowPowerState);

    if (forceLowPowerState) {
        deviceExtension->HcFlags |= HCFLAG_MAP_SX_TO_D3;
    }


    irpStack = IoGetCurrentIrpStackLocation (Irp);

    ntStatus = UHCD_GetResources(DeviceObject,
                                 irpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
                                 &resources);

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = UHCD_StartDevice(DeviceObject,
                                    &resources);
    }

    //
    // Set the IRP status because USBD doesn't
    //

    Irp->IoStatus.Status = ntStatus;

    LOGENTRY(LOG_MISC, 'dfST', 0, 0, ntStatus);

    return ntStatus;
}


BOOLEAN
UHCD_UpdateFrameCounter(
    IN PVOID Context
    )
/*++

Routine Description:

   Starts the USB host controller executing the schedule.
   Start Controller is called in by KeSynchronizeExecution.

Arguments:

   Context - DeviceData for this USB controller.

Return Value:

   TRUE

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    ULONG frameNumber;
    ULONG currentFrame, highPart;

    deviceExtension = Context;

    // This code maintains the 32-bit frame counter

    frameNumber = (ULONG) READ_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension));

    // did the sign bit change ?
    if ((deviceExtension->LastFrame ^ frameNumber) & 0x0400) {
        // Yes
        deviceExtension->FrameHighPart += 0x0800 -
            ((frameNumber ^ deviceExtension->FrameHighPart) & 0x0400);
    }

    // remember the last frame number
    deviceExtension->LastFrame = frameNumber;

    // calc frame number and update las frame processed
    // if necseesary

    highPart = deviceExtension->FrameHighPart;

    // get 11-bit frame number, high 17-bits are 0
    //frameNumber = (ULONG) READ_PORT_USHORT(FRAME_LIST_CURRENT_INDEX_REG(deviceExtension));

    currentFrame = ((frameNumber & 0x0bff) | highPart) +
        ((frameNumber ^ highPart) & 0x0400);

    //UHCD_KdPrint((2, "'currentFrame2 = %x\n", currentFrame));

    if (deviceExtension->HcFlags & HCFLAG_ROLLOVER_IDLE) {
        deviceExtension->LastFrameProcessed = currentFrame - 1;
    }

    return TRUE;
}

VOID
UHCD_DisableIdleCheck(
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    KIRQL irql;

    KeAcquireSpinLock(&DeviceExtension->HcFlagSpin, &irql);

    DeviceExtension->HcFlags |= HCFLAG_DISABLE_IDLE;

    KeReleaseSpinLock(&DeviceExtension->HcFlagSpin, irql);
}

VOID
UHCD_WakeIdle(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    takes the controller out of the idle state

Arguments:

Return Value:

    None

--*/

{
    KIRQL irql;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    LOGENTRY(LOG_MISC, 'wIDL', DeviceObject, 0, 0);

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    deviceExtension->XferIdleTime = 0;
    UHCD_CheckIdle(DeviceObject);
    KeLowerIrql(irql);
}


VOID
UHCD_CheckIdle(
    IN  PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    If the controllers hub ports are not connected this function
    stops the host controller

    If there are no iso enpoints open then this function
    disables the rollover interrupt

Arguments:

    DeviceObject - DeviceObject of the controller to stop

Return Value:

    NT status code.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    BOOLEAN portsIdle = TRUE;
    USHORT cmd;
    LARGE_INTEGER timeNow;
    BOOLEAN fastIsoEndpointListEmpty;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    fastIsoEndpointListEmpty = IsListEmpty(&deviceExtension->FastIsoEndpointList);

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->HcFlagSpin);

    if (deviceExtension->HcFlags & HCFLAG_DISABLE_IDLE) {
        goto UHCD_CheckIdle_Done;
    }

    UHCD_ASSERT(deviceExtension->InterruptObject);
    if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                UHCD_UpdateFrameCounter,
                                deviceExtension)) {
        TRAP(); //something has gone terribly wrong
    }

    portsIdle = RootHub_PortsIdle(deviceExtension->RootHub) &&
                    IsListEmpty(&deviceExtension->EndpointList);

    if (portsIdle) {

        if (!(deviceExtension->HcFlags & HCFLAG_IDLE)) {
            // we are not idle,
            // see how long ports have been idle if it
            // is longer then 10 seconds stop the
            // controller
            KeQuerySystemTime(&timeNow);

            if (deviceExtension->IdleTime == 0) {
                KeQuerySystemTime(&deviceExtension->LastIdleTime);
                deviceExtension->IdleTime = 1;
            }

            deviceExtension->IdleTime +=
                (LONG) (timeNow.QuadPart -
                deviceExtension->LastIdleTime.QuadPart);
            deviceExtension->LastIdleTime = timeNow;

            // ports are idle stop the controller
            if (// 10 seconds in 100ns units
                deviceExtension->IdleTime > 100000000) {

                cmd = READ_PORT_USHORT(
                    COMMAND_REG(deviceExtension)) & ~UHCD_CMD_RUN;
                WRITE_PORT_USHORT(COMMAND_REG(deviceExtension), cmd);

                deviceExtension->HcFlags |= HCFLAG_IDLE;
                deviceExtension->IdleTime = 0;

                LOGENTRY(LOG_MISC, 'sOFF', DeviceObject, 0, 0);

                UHCD_KdPrint((2, "'HC stopped\n"));

            }
        }

    } else {
        // ports are active start the controller
        deviceExtension->IdleTime = 0;
        if (deviceExtension->HcFlags & HCFLAG_IDLE) {

            UHCD_KdPrint((2, "'ports active, break idle\n"));

            // reset the frame list current index
            WRITE_PORT_USHORT(
                FRAME_LIST_CURRENT_INDEX_REG(deviceExtension), 0);

            // re-initialize internal frame counters.
            deviceExtension->FrameHighPart =
                deviceExtension->LastFrame = 0;


            cmd = READ_PORT_USHORT(
                COMMAND_REG(deviceExtension)) | UHCD_CMD_RUN;
            WRITE_PORT_USHORT(COMMAND_REG(deviceExtension), cmd);

            LOGENTRY(LOG_MISC, 's-ON', DeviceObject, 0, 0);

            deviceExtension->HcFlags &= ~HCFLAG_IDLE;

            UHCD_KdPrint((2, "'HC restart\n"));

        }
    }

    //
    // now deal with the HC rollover interrupt
    //

    if (!(deviceExtension->HcFlags & HCFLAG_ROLLOVER_IDLE)) {

        //
        // rollover ints are on,
        // see how long it has been since the last data transfer
        //

        KeQuerySystemTime(&timeNow);

        if (deviceExtension->XferIdleTime == 0) {
            KeQuerySystemTime(&deviceExtension->LastXferIdleTime);
            deviceExtension->XferIdleTime = 1;
        }

        deviceExtension->XferIdleTime +=
                (LONG) (timeNow.QuadPart -
            deviceExtension->LastXferIdleTime.QuadPart);
        deviceExtension->LastXferIdleTime = timeNow;
    }

    if (deviceExtension->XferIdleTime > 100000000 &&
        !fastIsoEndpointListEmpty) {

        // are we currently idle

        if (!(deviceExtension->HcFlags & HCFLAG_ROLLOVER_IDLE)) {
            //
            // No
            //
            // if we have seen no data transfers submitted
            // for 10 seconds disable the rollover interrupt
            //

            // turn off the interrupts for rollover
            deviceExtension->HcFlags |= HCFLAG_ROLLOVER_IDLE;

            deviceExtension->TriggerTDList->TDs[0].InterruptOnComplete =
             deviceExtension->TriggerTDList->TDs[1].InterruptOnComplete = 0;

            //UHCD_KdPrint((2, "UHCD: HC idle ints stopped\n"));
        }

    } else {
        //
        // this will turn on the rollover interrupts
        // when we see transfers
        //

        // are we currently idle

        if (deviceExtension->HcFlags & HCFLAG_ROLLOVER_IDLE) {

            //
            // Yes
            //

            UHCD_KdPrint((2, "'activate rollover ints\n"));

            deviceExtension->TriggerTDList->TDs[0].InterruptOnComplete =
              deviceExtension->TriggerTDList->TDs[1].InterruptOnComplete = 1;

            deviceExtension->HcFlags &= ~HCFLAG_ROLLOVER_IDLE;

            //UHCD_KdPrint((2, "UHCD: HC idle ints started\n"));
        }
    }

UHCD_CheckIdle_Done:

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->HcFlagSpin);
}


NTSTATUS
UHCD_GetSOFRegModifyValue(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG SofModifyValue
    )
/*++

Routine Description:

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT Status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    LONG clocksPerFrame = 12000;
    LONG recClocksPerFrame;
    LONG sofModify;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    // the default
    *SofModifyValue = 64;

    deviceExtension = DeviceObject->DeviceExtension;

    recClocksPerFrame =
        deviceExtension->RegRecClocksPerFrame;

    if (recClocksPerFrame && clocksPerFrame) {
        sofModify = recClocksPerFrame - clocksPerFrame + 64;
        *SofModifyValue = sofModify;
    }

    UHCD_KdPrint((1, "'Clocks/Frame %d Recommended Clocks/Frame %d SofModify %d\n",
        clocksPerFrame, recClocksPerFrame, *SofModifyValue));

    return ntStatus;
}


NTSTATUS
UHCD_GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

   This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).
   ValueType - The type of the value
   ValueData - The data for the value.
   ValueLength - The length of ValueData.
   Context - A pointer to the CONFIG structure.
   EntryContext - The index in Config->Parameters to save the value.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    UHCD_KdPrint((2, "'Type 0x%x, Length 0x%x\n", ValueType, ValueLength));

   switch (ValueType) {
   case REG_DWORD:
        RtlCopyMemory(EntryContext, ValueData, sizeof(ULONG));
        break;
    case REG_BINARY:
        // BUGBUG we are only set up to read a byte
        RtlCopyMemory(EntryContext, ValueData, 1);
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}



VOID
UHCD_SetControllerD0(
    IN PDEVICE_OBJECT DeviceObject
    )
 /* ++
  *
  * Description:
  *
  * Work item scheduled to do processing at passive
  * level when the controller is put in D0 by PNP/POWER.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //if (deviceExtension->CurrentDevicePowerState == PowerDeviceD0) {
    //    TEST_TRAP();
    //   return;
    //}

    LOGENTRY(LOG_MISC, 'POWC', deviceExtension->CurrentDevicePowerState,
        DeviceObject, 0);

    switch (deviceExtension->CurrentDevicePowerState) {
    case PowerDeviceD3:

        UHCD_KdPrint((2, "'PowerDeviceD0 (ON) from (OFF)\n"));
        deviceExtension->CurrentDevicePowerState = PowerDeviceD0;
        break;

    case PowerDeviceD1:
    case PowerDeviceD2:
        UHCD_KdPrint((2, "'PowerDeviceD0 (ON) from (SUSPEND)\n"));
        break;
    case PowerDeviceD0:
        // probably a bug in the kernel/configmg or usbd
        UHCD_KdPrint((2, "'PowerDeviceD0 (ON) from (ON)\n"));
        break;
    } /* case */

#ifdef USB_BIOS
    //if (deviceExtension->HcFlags & HCFLAG_USBBIOS) {
   UHCD_StopBIOS(DeviceObject);
   //}
#endif //USB_BIOS
    {
        USHORT legsup;

        UHCD_ReadWriteConfig(deviceExtension->PhysicalDeviceObject,
                             TRUE,
                             &legsup,
                             0xc0,     // offset of legacy bios reg
                             sizeof(legsup));

        LOGENTRY(LOG_MISC, 'PIRd', deviceExtension, legsup, 0);
        // set the PIRQD routing bit
        legsup |= LEGSUP_USBPIRQD_EN;

        UHCD_ReadWriteConfig(   deviceExtension->PhysicalDeviceObject,
                                FALSE,
                                &legsup,
                                0xc0,     // offset of legacy bios reg
                                sizeof(legsup));
    }

    deviceExtension->CurrentDevicePowerState = PowerDeviceD0;
    UHCD_KdPrint((1, " Host Controller entered (D0)\n"));

}

#if DBG

NTSTATUS
UHCD_GetClassGlobalDebugRegistryParameters(
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    PWCHAR usb = L"usb";
    extern ULONG UHCD_Debug_Trace_Level;
    extern ULONG UHCD_W98_Debug_Trace;
    extern ULONG UHCD_Debug_Asserts;

    PAGED_CODE();

    //
    // Set up QueryTable to do the following:
    //

    // spew level
    QueryTable[0].QueryRoutine = UHCD_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = DEBUG_LEVEL;
    QueryTable[0].EntryContext = &UHCD_Debug_Trace_Level;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &UHCD_Debug_Trace_Level;
    QueryTable[0].DefaultLength = sizeof(UHCD_Debug_Trace_Level);

    // ntkern trace buffer
    QueryTable[1].QueryRoutine = UHCD_GetConfigValue;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = DEBUG_WIN9X;
    QueryTable[1].EntryContext = &UHCD_W98_Debug_Trace;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = &UHCD_W98_Debug_Trace;
    QueryTable[1].DefaultLength = sizeof(UHCD_W98_Debug_Trace);

    //
    // Stop
    //
    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
         UHCD_KdPrint((1, "'Debug Trace Level Set: (%d)\n", UHCD_Debug_Trace_Level));

        if (UHCD_W98_Debug_Trace) {
            UHCD_KdPrint((1, "'NTKERN Trace is ON\n"));
        } else {
            UHCD_KdPrint((1, "'NTKERN Trace is OFF\n"));
        }

        if (UHCD_Debug_Trace_Level > 0) {
            ULONG UHCD_Debug_Asserts = 1;
        }
    }

    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

#endif

NTSTATUS
UHCD_GetClassGlobalRegistryParameters(
    IN OUT PULONG ForceLowPowerState
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    UCHAR toshibaLegacyFlags = 0;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usb = L"class\\usb";

    PAGED_CODE();

    //
    // Set up QueryTable to do the following:
    //

    // force power mapping
    QueryTable[0].QueryRoutine = UHCD_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = L"ForceLowPowerState";
    QueryTable[0].EntryContext = ForceLowPowerState;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = ForceLowPowerState;
    QueryTable[0].DefaultLength = sizeof(*ForceLowPowerState);

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
//                 RTL_REGISTRY_ABSOLUTE,    // RelativeTo
                RTL_REGISTRY_SERVICES,
//                 UnicodeRegistryPath->Buffer, // Path
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
        UHCD_KdPrint(( 0, "'HC ForceLowPower = 0x%x\n",
            *ForceLowPowerState));
    }

   if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
       ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

#if 0
// not used
NTSTATUS
UHCD_GetGlobalRegistryParameters(
    IN OUT PULONG DisableController
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    UCHAR toshibaLegacyFlags = 0;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usb  = L"usb";

    PAGED_CODE();

    //
    // Set up QueryTable to do the following:
    //

    // legacy flag
    QueryTable[0].QueryRoutine = UHCD_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = L"DisablePIIXUsb";
    QueryTable[0].EntryContext = DisableController;
    QueryTable[0].DefaultType = REG_BINARY;
    QueryTable[0].DefaultData = DisableController;
    QueryTable[0].DefaultLength = sizeof(*DisableController);

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
//                 RTL_REGISTRY_ABSOLUTE,   // RelativeTo
                RTL_REGISTRY_SERVICES,
//                 UnicodeRegistryPath->Buffer,// Path
                usb,
                QueryTable,         // QurryTable
                NULL,               // Context
                NULL);              // Environment

    if (NT_SUCCESS(ntStatus)) {
        UHCD_KdPrint(( 0, "'HC Disable flag = 0x%x\n",
            *DisableController));
    }

   if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
       ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\roothub.c ===
/*++

Copyright (c) 1995,1996  Microsoft Corporation
:ts=4

Module Name:

    roothub.c

Abstract:

    The UHC driver for USB, this module contains the root hub
    code.

Environment:

    kernel mode only

Notes:

Revision History:

   8-13-96 : created

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"
#include "dbg.h"


#define RH_STANDARD_REQ    0
#define RH_CLASS_REQ       1

#define MIN(x, y)  (((x)<(y)) ? (x) : (y))

#define RH_CHECK_BUFFER(x, y, z)

#define RH_PORT_RESET       0x0200  // Port Reset 1=in reset
#define RH_PORT_ENABLE      0x0004  // Port Enable/Disable 1=enabled
#define RH_PORT_CONNECT     0x0001  // Current Connect Status 1=connect
#define RH_PORT_LS          0x0100  // Low Speed 1=ls device attached
#define RH_PORT_SUSPEND     0x1000  // Suspend 1=in suspend
#define RH_PORT_RESUME      0x0040  // resume port

#define RH_C_PORT_ENABLE    0x0008  // Port Enabled/Disabled Change
#define RH_C_PORT_CONNECT   0x0002  // Port Connect Status Change

//
// HUB feature selectors
//
#define C_HUB_LOCAL_POWER           0
#define C_HUB_OVER_CURRENT          1
#define PORT_CONNECTION             0
#define PORT_ENABLE                 1
#define PORT_SUSPEND                2
#define PORT_OVER_CURRENT           3
#define PORT_RESET                  4
#define PORT_POWER                  8
#define PORT_LOW_SPEED              9
#define C_PORT_CONNECTION           16
#define C_PORT_ENABLE               17
#define C_PORT_SUSPEND              18
#define C_PORT_OVER_CURRENT         19
#define C_PORT_RESET                20


#define HUB_REQUEST_GET_STATUS      0
#define HUB_REQUEST_CLEAR_FEATURE   1
#define HUB_REQUEST_GET_STATE       2
#define HUB_REQUEST_SET_FEATURE     3
#define HUB_REQUEST_GET_DESCRIPTOR  6
#define HUB_REQUEST_SET_DESCRIPTOR  7


UCHAR RH_DeviceDescriptor[] = {0x12, //bLength
                               0x01, //bDescrpitorType
                               0x00, 0x01, //bcdUSB
                               0x09, //bDeviceClass
                               0x01, //bDeviceSubClass
                               0x00, //bDeviceProtocol
                               0x08, //bMaxPacketSize0
                               0x86, 0x80, //idVendor
                               0x0B, 0x0B, //idProduct
                               0x00, 0x00, //bcdDevice
                               0x00, //iManufacturer
                               0x00, //iProduct
                               0x00, //iSerialNumber
                               0x01};//bNumConfigurations

UCHAR RH_ConfigurationDescriptor[] =
                         /* Config Descriptor   */
                        {0x09, //bLength
                         0x02, //bDescriptorType
                         0x19, 0x00, //wTotalLength
                         0x01, //bNumInterfaces
                         0x23, //iConfigurationValue
                         0x00, //iConfiguration
                         0x40, //bmAttributes
                         0x00, //MaxPower

                         /* Interface Descriptor */
                         0x09, //bLength
                         0x04, //bDescriptorType
                         0x00, //bInterfaceNumber
                         0x00, //bAlternateSetting
                         0x01, //bNumEndpoints
                         0x09, //bInterfaceClass
                         0x01, //bInterfaceSubClass
                         0x00, //bInterfaceProtocol
                         0x00, //iInterface

                         /* Endpoint Descriptor  */
                         0x07, //bLength
                         0x05, //bDescriptorType
                         0x81, //bEndpointAddress
                         0x03, //bmAttributes
                         0x08, 0x00, //wMaxPacketSize
                         0x0a};//bInterval

UCHAR RH_HubDescriptor[] =
                      {0x09,  //bLength
                       0x00,  //bDescriptorType
                       0x02,  //bNbrPorts
                       0x1B, 0x00, //wHubCharacteristics
                    // D0,D1 (11)  - no power switching
                    // D2    (0)   - not compund
                    // D3,D4 (11)  - no overcurrent
                    // D5, D15 (0)
                       0x01,  // bPwrOn2PwrGood
                       0x00,  // bHubContrCurrent
                       0x00,  // DeviceRemovable
                       0x00}; // PortPwrCtrlMask

VOID
RootHub_ResetTimerHandler(
    IN PVOID TimerContext
    )
/*++

Routine Description:

    Called as a result of scheduling a timer event for a root hub port

    This function is called 10ms after the reset bit for the port is set,
    the reset bit is cleared and the enable bit is set.

Arguments:

    TimerContext - supplies hub port structure

Return Value:

    None.

--*/
{
    PROOTHUB_PORT hubPort = (PROOTHUB_PORT) TimerContext;
    USHORT reg;
    int i;

    //
    // BUGBUG this code assumes it is being called as a result
    // of a reset_port command being sent to the hub.
    //
    LOGENTRY(LOG_MISC, 'rRTH', TimerContext, 0, 0);

    //
    // clear the RESET bit
    //
    reg = UHCD_RootHub_ReadPort(hubPort);
    reg &= (~RH_PORT_RESET);
    UHCD_RootHub_WritePort(hubPort, reg);

    //
    // Reset is complete, enable the port
    //
    // BUGBUG not sure why we need this loop
    // original code from intel has this
    //

    for (i=1; i<10; i++) {

        // Need a delay between clearing the port reset and setting
        // the port enable.  VIA suggests delaying 64 USB bit times,
        // or 43us if those are low-speed bit times.
        //
        KeStallExecutionProcessor(50);

        reg = UHCD_RootHub_ReadPort(hubPort);

        if (reg & RH_PORT_ENABLE) {
            // port is enabled
            break;
        }

        // enable the port
        reg |= RH_PORT_ENABLE;
        UHCD_RootHub_WritePort(hubPort, reg);
    }

    //
    // clear port connect & enable change bits
    //

    reg |= (RH_C_PORT_CONNECT | RH_C_PORT_ENABLE);

    UHCD_RootHub_WritePort(hubPort, reg);

    //
    // Note that we have a change condition
    //
    hubPort->ResetChange = TRUE;

    return;
}


VOID
RootHub_SuspendTimerHandler(
    IN PVOID TimerContext
    )
/*++

Routine Description:

Arguments:

    TimerContext - supplies hub port structure

Return Value:

    None.

--*/
{
    PROOTHUB_PORT hubPort = (PROOTHUB_PORT) TimerContext;
    USHORT reg;

    //
    // BUGBUG this code assumes it is being called as a result
    // of a resume_port command being sent to the hub.
    //
    LOGENTRY(LOG_MISC, 'rSTH', TimerContext, 0, 0);


    //
    // clear the SUSPEND bit
    //
    reg = UHCD_RootHub_ReadPort(hubPort);
    reg &= (~RH_PORT_RESUME);
    reg &= (~RH_PORT_SUSPEND);
    UHCD_RootHub_WritePort(hubPort, reg);

    //
    // Note that we have a change condition
    //
    hubPort->SuspendChange = TRUE;

    return;
}



PROOTHUB
RootHub_Initialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfPorts,
    IN BOOLEAN DoSelectiveSuspend
    )
/*++

Routine Description:

    Initialize the root hub:

Arguments:

    DeviceObject - HCD device object

Return Value:

    ptr to root hub structure.

--*/
{
    //
    // Perform any Root Hub hardware specific initialization here.
    //

    UCHAR i;
    USHORT base = RH_PORT_SC_BASE;
    PROOTHUB rootHub;
#if DBG
    PULONG pDisabledPorts;
#endif


    rootHub = GETHEAP(NonPagedPool, sizeof(ROOTHUB)+
                        sizeof(ROOTHUB_PORT)*NumberOfPorts);
#if DBG
    pDisabledPorts = GETHEAP(NonPagedPool, sizeof(ULONG) * NumberOfPorts);
#endif

    if (rootHub) {
        LOGENTRY(LOG_MISC, 'rINI', DeviceObject, rootHub,
                DoSelectiveSuspend);

        rootHub->Sig = SIG_RH;
    //        rootHub->DeviceAddress = 0x00;
        rootHub->DeviceObject = DeviceObject;
        rootHub->NumberOfPorts = (UCHAR) NumberOfPorts;
        rootHub->ConfigurationValue = 0;
        rootHub->DoSelectiveSuspend =
            DoSelectiveSuspend;

        for (i=0; i<rootHub->NumberOfPorts; i++) {
            rootHub->Port[i].ResetChange = FALSE;
            rootHub->Port[i].SuspendChange = FALSE;
            rootHub->Port[i].DeviceObject = DeviceObject;
            rootHub->Port[i].Address  = base;
            base+=2;
        }

#if DBG
   rootHub->DisabledPort = pDisabledPorts;

   if (pDisabledPorts != NULL) {
       RtlZeroMemory(pDisabledPorts, sizeof(ULONG) * NumberOfPorts);
   }
#else
   rootHub->DisabledPort = NULL;
#endif

    }

    return rootHub;
}


RHSTATUS
RootHub_Endpoint0(
    IN PROOTHUB RootHub,
    IN PRH_SETUP SetupPacket,
    IN PUCHAR DeviceAddress,
    IN PUCHAR Buffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

    This routine should be called anytime there is any control transfer to
    the RootHub endpoint 0.  This procedure behaves like a real device would
    in that it parses the command data, performs the requested operation,
    using or modifying the data area as appropriate.
    The return code is equivalent to the 'status stage' of a normal control
    transfer.

Arguments:

Return Value:

    root hub transfer status code

--*/
{
    RHSTATUS rhStatus;

    ASSERT_RH(RootHub);
    LOGENTRY(LOG_MISC, 'rEP0', RootHub, SetupPacket, DeviceAddress);
    if (SetupPacket->bmRequestType.Type == RH_STANDARD_REQ) {
        rhStatus =
            RootHub_StandardCommand(RootHub,
                                    SetupPacket,
                                    DeviceAddress,
                                    Buffer,
                                    BufferLength);

    } else if (SetupPacket->bmRequestType.Type == RH_CLASS_REQ) {
        rhStatus =
            RootHub_ClassCommand(RootHub,
                                 SetupPacket,
                                 Buffer,
                                 BufferLength);
    } else {
        rhStatus = RH_STALL;
        // probably a bug in the hub driver
        TRAP();
    }

    return rhStatus;
}


#define RH_DEV_TO_HOST      1
#define RH_HOST_TO_DEV      0

RHSTATUS
RootHub_StandardCommand(
    IN PROOTHUB RootHub,
    IN PRH_SETUP SetupPacket,
   IN OUT PUCHAR DeviceAddress,
   IN OUT PUCHAR Buffer,
   IN OUT PULONG BufferLength
    )
/*++

Routine Description:


Arguments:

   DeviceAddress - pointer to HCD address assigned to the
               root hub

   SetupPacket - pointer to a SetupPacket packet

Return Value:

    Root Hub status code.

--*/
{
    PVOID descriptor = NULL;
    ULONG length;
    RHSTATUS rhStatus = RH_STALL;

    ASSERT_RH(RootHub);
    LOGENTRY(LOG_MISC, 'rSCM', RootHub, SetupPacket, DeviceAddress);
    //
    // switch on the command
    //
    switch (SetupPacket->bRequest) {
    case USB_REQUEST_SET_ADDRESS:
        //
        //
        //
        if (SetupPacket->wIndex == 0 &&
         SetupPacket->wLength == 0 &&
         SetupPacket->bmRequestType.Dir == RH_HOST_TO_DEV) {
            *DeviceAddress =
                  (UCHAR)SetupPacket->wValue.W;

            rhStatus = RH_SUCCESS;
            LOGENTRY(LOG_MISC, 'rSAD', *DeviceAddress, 0, 0);
        }
        break;

    case USB_REQUEST_GET_DESCRIPTOR:
        {
            PVOID descriptor = NULL;
            ULONG siz;
            UCHAR descriptorIndex, descriptorType;

            descriptorType = (UCHAR) SetupPacket->wValue.hiPart;
            descriptorIndex = (UCHAR) SetupPacket->wValue.lowPart;

            switch (descriptorType) {

            case USB_DEVICE_DESCRIPTOR_TYPE:
                if (descriptorIndex == 0 &&
                    SetupPacket->bmRequestType.Dir == RH_DEV_TO_HOST) {

                    siz = sizeof(RH_DeviceDescriptor);
                    descriptor = RH_DeviceDescriptor;
                    LOGENTRY(LOG_MISC, 'rGDS', descriptor, siz, 0);
                }
                break;

            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                if (descriptorIndex == 0 &&
                    SetupPacket->bmRequestType.Dir == RH_DEV_TO_HOST) {
                    siz = sizeof(RH_ConfigurationDescriptor);
                    descriptor = RH_ConfigurationDescriptor;
                    LOGENTRY(LOG_MISC, 'rGCS', descriptor, siz, 0);
                }
                break;

            //
            // BUGBUG these descriptor types not handled
            //
            case USB_STRING_DESCRIPTOR_TYPE:
            default:
                TRAP();
            } /* descriptorType */

            if (descriptor) {
                RH_CHECK_BUFFER(SetupPacket->wLength,
                                *BufferLength,
                                siz);

                length = MIN(*BufferLength, siz);

                RtlCopyMemory(Buffer, descriptor, length);
                *BufferLength = length;
                rhStatus = RH_SUCCESS;
            }
        }
        break;

    case USB_REQUEST_GET_STATUS:
        //
        // get_device_status
        //
        // report that we are self powered
        //
        // BUGBUG
        // are we self powered?
        // are we a remote wakeup source
        //
        // see section 9.4.5 USB 1.0 spec
        //
        {
        PUSHORT status = (PUSHORT) Buffer;

        if (SetupPacket->wValue.W == 0 &&   //mbz
            SetupPacket->wLength == 2 &&
            SetupPacket->wIndex == 0 &&   //device
            SetupPacket->bmRequestType.Dir == RH_DEV_TO_HOST) {

            *status = USB_GETSTATUS_SELF_POWERED;
            *BufferLength = sizeof(*status);
            rhStatus = RH_SUCCESS;
        }
        }
        break;

    case USB_REQUEST_GET_CONFIGURATION:
        //
        // get_device_configuration
        //
        if (SetupPacket->wValue.W == 0 &&   //mbz
            SetupPacket->wIndex == 0 &&   //mbz
            SetupPacket->wLength == 1 &&
            SetupPacket->bmRequestType.Dir == RH_DEV_TO_HOST) {

            TEST_TRAP();
            RH_CHECK_BUFFER(SetupPacket->wLength,
                            *BufferLength,
                            sizeof(RootHub->Configuration));

            length = MIN(*BufferLength, sizeof(RootHub->ConfigurationValue));
            RtlCopyMemory(Buffer, &RootHub->ConfigurationValue, length);
            *BufferLength = length;
            rhStatus = RH_SUCCESS;
        }
        break;

    case USB_REQUEST_CLEAR_FEATURE:
        // bugbug, required
        TRAP();
        break;
    case USB_REQUEST_SET_CONFIGURATION:
        {
        PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor =
            (PUSB_CONFIGURATION_DESCRIPTOR) RH_ConfigurationDescriptor;

        if (SetupPacket->wIndex == 0 &&   // mbz
            SetupPacket->wLength == 0 &&  // mbz
            SetupPacket->bmRequestType.Dir == RH_HOST_TO_DEV &&
            (SetupPacket->wValue.W ==
                configurationDescriptor->bConfigurationValue ||
             SetupPacket->wValue.W == 0)) {

            RootHub->ConfigurationValue = (UCHAR) SetupPacket->wValue.W;
            rhStatus = RH_SUCCESS;
            LOGENTRY(LOG_MISC, 'rSEC', RootHub->ConfigurationValue, 0, 0);
      }
      }
        break;
    case USB_REQUEST_SET_FEATURE:
        // bugbug, required
        TRAP();
        break;
    //
    // these commands are optional for the hub
    //
    case USB_REQUEST_SET_DESCRIPTOR:
    case USB_REQUEST_SET_INTERFACE:
    case USB_REQUEST_GET_INTERFACE:
    case USB_REQUEST_SYNC_FRAME:
    default:
        // bad command, probably a bug in the
        // hub driver
        TRAP();
        break;
    }

    return rhStatus;
}


RHSTATUS
RootHub_ClassCommand(
    IN PROOTHUB RootHub,
    IN PRH_SETUP SetupPacket,
    IN OUT PUCHAR Buffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    Root Hub status code.

--*/
{
    PVOID descriptor = NULL;
    ULONG length;
    RHSTATUS rhStatus = RH_STALL;

    ASSERT_RH(RootHub);
    LOGENTRY(LOG_MISC, 'rCCM', RootHub, SetupPacket, 0);
    //
    // switch on the command
    //

    switch (SetupPacket->bRequest) {
    case HUB_REQUEST_GET_STATUS:
        //
        //
        //
        if (SetupPacket->bmRequestType.Recipient == RECIPIENT_PORT) {
            //
            // get port status
            //
            PRH_PORT_STATUS portStatus;
            //
            // see if we have a valid request
            //
            if (SetupPacket->wIndex > 0 &&
                SetupPacket->wIndex <= RH_NUMBER_OF_PORTS &&
                SetupPacket->wLength >= sizeof(*portStatus)) {

                USHORT reg;
                PROOTHUB_PORT hubPort =
                            &RootHub->Port[SetupPacket->wIndex-1];

                ASSERT(sizeof(*portStatus) == 4);
                ASSERT(*BufferLength >= sizeof(*portStatus));
                portStatus = (PRH_PORT_STATUS) Buffer;
                RtlZeroMemory(Buffer, sizeof(*portStatus));

                reg = UHCD_RootHub_ReadPort (hubPort);

                //
                // get port status bits
                //
                portStatus->Connected = (reg & RH_PORT_CONNECT)
#if DBG
             && !(RootHub->DisabledPort[SetupPacket->wIndex - 1]
             & UHCD_FAKE_DISCONNECT)
#endif
            ? 1:0;
                portStatus->Enabled = (reg & RH_PORT_ENABLE) ? 1:0;
                portStatus->Suspended = (reg & RH_PORT_SUSPEND) ? 1:0;
                portStatus->OverCurrent = 0; // never report overcurrent
                portStatus->Reset = (reg & RH_PORT_RESET) ? 1:0;
                portStatus->PowerOn = 1; // always on
                portStatus->LowSpeed = (reg & RH_PORT_LS) ? 1:0;

                //
                // get port change bits
                //
                portStatus->ConnectChange = (reg & RH_C_PORT_CONNECT)
#if DBG
                   || (RootHub->DisabledPort[SetupPacket->wIndex - 1]
             & UHCD_FAKE_CONNECT_CHANGE)
#endif
         ? 1:0;
                portStatus->EnableChange = (reg & RH_C_PORT_ENABLE) ? 1:0;
                portStatus->SuspendChange = hubPort->SuspendChange ? 1:0;;
                portStatus->OverCurrentChange = 0;
                portStatus->ResetChange = hubPort->ResetChange ? 1:0;

                LOGENTRY(LOG_MISC, 'rPST',
                    portStatus, *((PULONG) (portStatus)), reg);
                rhStatus = RH_SUCCESS;
            }
        } else {
            //
            // get hub status
            //
            TRAP();
        }
        break;

    case HUB_REQUEST_CLEAR_FEATURE:
        //
        // Hub/Port Clear Feature
        //
        LOGENTRY(LOG_MISC, 'rCFR',
            SetupPacket->bmRequestType.Recipient, 0, 0);
        if (SetupPacket->bmRequestType.Recipient == RECIPIENT_PORT) {
            //
            // clear port feature
            //
            LOGENTRY(LOG_MISC, 'rCPR', SetupPacket->wValue.W, 0, 0);
            switch(SetupPacket->wValue.W) {
                //
                //
                //
            case PORT_ENABLE:
                // BUGBUG
                // disable the port

                if (SetupPacket->wIndex > 0 &&
                    SetupPacket->wIndex <= RH_NUMBER_OF_PORTS) {

                    USHORT reg;
                    PROOTHUB_PORT hubPort =
                        &RootHub->Port[SetupPacket->wIndex-1];

                    reg = UHCD_RootHub_ReadPort (hubPort);

                    // clear the enable bit
                    reg &= ~(RH_PORT_ENABLE);

                    LOGENTRY(LOG_MISC, 'rDsP', SetupPacket->wIndex, 0, 0);
                    UHCD_RootHub_WritePort(hubPort, reg);

                    rhStatus = RH_SUCCESS;
                }
                break;
            case PORT_POWER:
                // BUGBUG
                // this should turn off power, but for now we silently
                // ignore it.
                //
                    rhStatus = RH_SUCCESS;
                break;
            case PORT_CONNECTION:
            case PORT_OVER_CURRENT:
            case PORT_LOW_SPEED:
            case PORT_RESET:
                TRAP();
                break;

            case C_PORT_CONNECTION:
            case C_PORT_ENABLE:

                // validate the port number
                if (SetupPacket->wIndex > 0 &&
                    SetupPacket->wIndex <= RH_NUMBER_OF_PORTS) {

                    USHORT reg;
                    PROOTHUB_PORT hubPort =
                        &RootHub->Port[SetupPacket->wIndex-1];

                    reg = UHCD_RootHub_ReadPort (hubPort);

                    // mask off the change bits
                    reg &= ~(RH_C_PORT_ENABLE | RH_C_PORT_CONNECT);

                    if (SetupPacket->wValue.W == C_PORT_CONNECTION) {
#if DBG
         RootHub->DisabledPort[SetupPacket->wIndex - 1]
             &= ~UHCD_FAKE_CONNECT_CHANGE;
#endif
                        reg |= RH_C_PORT_CONNECT;
                        LOGENTRY(LOG_MISC, 'rCPC', SetupPacket->wIndex, 0, 0);
                    } else {
                        // C_PORT_ENABLE
                        reg |= RH_C_PORT_ENABLE;
                        LOGENTRY(LOG_MISC, 'rCLE', SetupPacket->wIndex, 0, 0);
                    }
                    UHCD_RootHub_WritePort(hubPort, reg);

                    rhStatus = RH_SUCCESS;
                }
                break;

            case C_PORT_RESET:
                if (SetupPacket->wIndex >0 &&
                    SetupPacket->wIndex <= RH_NUMBER_OF_PORTS) {

                    PROOTHUB_PORT hubPort =
                        &RootHub->Port[SetupPacket->wIndex-1];

                    LOGENTRY(LOG_MISC, 'rCLP', SetupPacket->wIndex,
                        hubPort->ResetChange, 0);

                    hubPort->ResetChange = FALSE;

                    LOGENTRY(LOG_MISC, 'rCLR', SetupPacket->wIndex, 0, 0);
                    rhStatus = RH_SUCCESS;

                }
                break;

            case PORT_SUSPEND:
                //
                // clearing port suspend triggers a resume
                //
                if (SetupPacket->wIndex > 0 &&
                    SetupPacket->wIndex <= RH_NUMBER_OF_PORTS) {

                    USHORT reg;
                    PROOTHUB_PORT hubPort =
                        &RootHub->Port[SetupPacket->wIndex-1];

                    reg = UHCD_RootHub_ReadPort(hubPort);

                    //
                    // signal resume on the port
                    //
                    if (RootHub->DoSelectiveSuspend) {
                        reg |= RH_PORT_RESUME;
                        UHCD_RootHub_WritePort(hubPort, reg);

                        UHCD_RootHub_Timer(hubPort->DeviceObject,
                                           RH_RESET_TIMELENGTH, //bugbug
                                           &RootHub_SuspendTimerHandler,
                                           (PVOID)hubPort);

                        rhStatus = RH_SUCCESS;
                        LOGENTRY(LOG_MISC, 'rCPS', hubPort, 0, 0);
                    } else {
                        rhStatus = RH_SUCCESS;
                    }
#ifdef MAX_DEBUG
                    TEST_TRAP();
#endif
                }
                break;

            case C_PORT_SUSPEND:
                if (SetupPacket->wIndex > 0 &&
                    SetupPacket->wIndex <= RH_NUMBER_OF_PORTS) {

                    PROOTHUB_PORT hubPort =
                        &RootHub->Port[SetupPacket->wIndex-1];

                    hubPort->SuspendChange = FALSE;

                    LOGENTRY(LOG_MISC, 'rCls', SetupPacket->wIndex, 0, 0);
                    rhStatus = RH_SUCCESS;
#ifdef MAX_DEBUG
                    TEST_TRAP();
#endif
                }
                break;

            case C_PORT_OVER_CURRENT:
                TEST_TRAP();
                rhStatus = RH_SUCCESS;
                break;
            default:
                TRAP();
            }
        } else {
            //
            // clear hub feature
            //
            LOGENTRY(LOG_MISC, 'rCHR', SetupPacket->wValue.W, 0, 0);
            switch(SetupPacket->wValue.W) {
            case C_HUB_LOCAL_POWER:
            case C_HUB_OVER_CURRENT:
            default:
                TRAP();
            }
        }
        break;

    case HUB_REQUEST_GET_STATE:
        //
        //
        //
        TRAP();
        break;

    case HUB_REQUEST_SET_FEATURE:
        //
        //  Hub/Port feature request
        //
        if (SetupPacket->bmRequestType.Recipient == RECIPIENT_PORT) {
            //
            // set port feature
            //
            switch(SetupPacket->wValue.W) {
            case PORT_RESET:
                LOGENTRY(LOG_MISC, 'rRES', SetupPacket->wIndex, 0, 0);
                if (SetupPacket->wIndex > 0 &&
                    SetupPacket->wIndex <= RH_NUMBER_OF_PORTS) {

                    USHORT reg;
                    PROOTHUB_PORT hubPort =
                        &RootHub->Port[SetupPacket->wIndex-1];

                    reg = UHCD_RootHub_ReadPort(hubPort);

                    if (reg & RH_PORT_RESET) {
                        //
                        // stall if the port is already in reset
                        //
                        rhStatus = RH_STALL;
                        TEST_TRAP();
                    } else {
                        //
                        // drive reset on the port
                        // for RH_RESET_TIMELENGTH (in ms)
                        //
                        reg |= RH_PORT_RESET;
                        UHCD_RootHub_WritePort(hubPort, reg);

                        UHCD_RootHub_Timer(hubPort->DeviceObject,
                                           RH_RESET_TIMELENGTH,
                                           &RootHub_ResetTimerHandler,
                                           (PVOID)hubPort);

                        rhStatus = RH_SUCCESS;
                        LOGENTRY(LOG_MISC, 'rSTM', hubPort, 0, 0);
                    }
                }
                break;

            case PORT_SUSPEND:
                if (SetupPacket->wIndex > 0 &&
                    SetupPacket->wIndex <= RH_NUMBER_OF_PORTS) {

                    USHORT reg;
                    PROOTHUB_PORT hubPort =
                        &RootHub->Port[SetupPacket->wIndex-1];

                    reg = UHCD_RootHub_ReadPort(hubPort);

                    if ((reg & (RH_PORT_SUSPEND | RH_PORT_ENABLE)) ==
                        (RH_PORT_SUSPEND | RH_PORT_ENABLE)) {
                        //
                        // stall if the port is already in suspended
                        //

                        // 9/7/2000: Just ignore this case and return success
                        //
                        rhStatus = RH_SUCCESS;

                    } else {
                        //
                        // write the suspend bit
                        //
#ifdef MAX_DEBUG
                        TRAP();
#endif

                        if (RootHub->DoSelectiveSuspend) {
                            reg |= (RH_PORT_SUSPEND | RH_PORT_ENABLE);
                            UHCD_RootHub_WritePort(hubPort, reg);

                            rhStatus = RH_SUCCESS;
                        } else {
                            // just pretend we did it for the piix4
                            rhStatus = RH_SUCCESS;
                            LOGENTRY(LOG_MISC, 'rSno', hubPort, reg, rhStatus);
                        }

                        LOGENTRY(LOG_MISC, 'rSUS', hubPort, reg, rhStatus);
                    }
                }
                break;

            case PORT_ENABLE:
                if (SetupPacket->wIndex > 0 &&
                    SetupPacket->wIndex <= RH_NUMBER_OF_PORTS) {

                    USHORT reg;
                    PROOTHUB_PORT hubPort =
                        &RootHub->Port[SetupPacket->wIndex-1];

                    reg = UHCD_RootHub_ReadPort(hubPort);
#ifdef MAX_DEBUG
                    TRAP();
#endif
                    reg |= RH_PORT_ENABLE;
                    UHCD_RootHub_WritePort(hubPort, reg);

                    rhStatus = RH_SUCCESS;
                    LOGENTRY(LOG_MISC, 'rPEN', hubPort, 0, 0);
                }
                break;
            case PORT_POWER:
                // just return success for a power on request
                rhStatus = RH_SUCCESS;
                break;
            case PORT_CONNECTION:
            case PORT_OVER_CURRENT:
            case PORT_LOW_SPEED:

            case C_PORT_CONNECTION:
            case C_PORT_ENABLE:
            case C_PORT_SUSPEND:
            case C_PORT_OVER_CURRENT:
            case C_PORT_RESET:
            default:
                TRAP();
            }
        } else {
            //
            // set hub feature
            //
            switch(SetupPacket->wValue.W) {
            case C_HUB_LOCAL_POWER:
            case C_HUB_OVER_CURRENT:
            default:
                TRAP();
            }

        }
        break;

    case HUB_REQUEST_GET_DESCRIPTOR:
        //
        // return the hub descriptor
        //
        if (SetupPacket->wValue.W == 0 &&
            // we already know it is a class command
            SetupPacket->bmRequestType.Dir == RH_DEV_TO_HOST) {
            LOGENTRY(LOG_MISC, 'rGHD', SetupPacket, SetupPacket->wLength, 0);

            RH_CHECK_BUFFER(SetupPacket->wLength,
                            *BufferLength,
                            sizeof(RH_HubDescriptor));

            length = MIN(*BufferLength, sizeof(RH_HubDescriptor));

            RtlCopyMemory(Buffer, RH_HubDescriptor, length);
            *BufferLength = length;
            rhStatus = RH_SUCCESS;
        }
        break;

    case HUB_REQUEST_SET_DESCRIPTOR:
        //
        //
        //
        TRAP();
        break;

    default:
        // bad command
        TRAP();
        break;
    }

    return rhStatus;
}

RHSTATUS
RootHub_Endpoint1(
    IN PROOTHUB RootHub,
    IN PUCHAR Buffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    root hub transfer status code

--*/
{
    RHSTATUS rhStatus = RH_NAK;
    PROOTHUB_PORT hubPort;
    USHORT reg;
    PUCHAR bitmap;
    ULONG bit = 2, i;

    ASSERT_RH(RootHub);
    LOGENTRY(LOG_MISC, 'rPOL', RootHub, Buffer, *BufferLength);
    if (*BufferLength < sizeof(*bitmap)) {
        UHCD_KdTrap(("Bad buffer length passed to root hub\n"));
        return RH_STALL;
    }

    bitmap = (PUCHAR) Buffer;
    *bitmap = 0;
    // one byte of data returned.
    *BufferLength = 1;

    UHCD_ASSERT(RootHub->NumberOfPorts < 8);
    for (i=0; i< RootHub->NumberOfPorts; i++) {
        hubPort = &RootHub->Port[i];

        reg = UHCD_RootHub_ReadPort(hubPort);

        if (!(reg & RH_PORT_RESET) &&
            ((reg & RH_C_PORT_ENABLE) ||
             (reg & RH_C_PORT_CONNECT) ||
              hubPort->ResetChange ||
              hubPort->SuspendChange
#if DBG
         || (RootHub->DisabledPort[i] & UHCD_FAKE_CONNECT_CHANGE)
#endif
        )) {

            //
            // note we have a change on this port
            //
            *bitmap |= bit;
            rhStatus = RH_SUCCESS;
            LOGENTRY(LOG_MISC, 'rSTA', RootHub, reg, hubPort->ResetChange);
        }
        bit = bit<<1;
    }

    return rhStatus;
}


BOOLEAN
RootHub_PortsIdle(
    IN PROOTHUB RootHub
    )
/*++

Routine Description:

Arguments:

Return Value:

    root hub idle detect

--*/
{
    PROOTHUB_PORT hubPort;
    USHORT reg;
    ULONG i;
    BOOLEAN idle = TRUE;


     for (i=0; i< RootHub->NumberOfPorts; i++) {
        hubPort = &RootHub->Port[i];

        reg = UHCD_RootHub_ReadPort(hubPort);

#if DBG
       if(RootHub->DisabledPort[i] & UHCD_FAKE_DISCONNECT) {
      reg &= ~RH_PORT_CONNECT;
       }
#endif

   if ((reg & (RH_PORT_CONNECT | RH_PORT_SUSPEND)) == RH_PORT_CONNECT) {
            idle = FALSE;
        }

#if DBG
          else {
            LOGENTRY(LOG_MISC, 'rIDL', RootHub, reg, 0);
        }
#endif
    }

    return idle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\uhcd.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
:ts=4

Module Name:

    uhcd.h

Abstract:

    This module contains the PRIVATE definitions for the
    code that implements the UHC device driver for USB.

Environment:

    Kernel & user mode

Revision History:

    10-27-95 : created

--*/

#ifndef   __UHCD_H__
#define   __UHCD_H__

//enable pageable code
#ifndef PAGE_CODE
#define PAGE_CODE
#endif

#if !defined(max)
#define max(a, b) (a > b ? a : b)
#endif // !defined(max)

/*
Registry Keys
*/

// Disables selective suspend for the root hub ports.
// this behavior is the default for the PIIX3 or PIIX4 because
// of hardware bugs -- it is off (ie sel suspend enabled)
// for all other UHCI controllers unless this key is set
#define DISABLE_SELECTIVE_SUSPEND       L"DisableSelectiveSuspend"

// used to overide the default clock timing in the host controller
// hardware.
// Some motherboard designs use a cheap clock crystal -- if so there
// is an adjustment that must be made to the SOF clock.
// This system BIOS should do this but if it does not there is a
// utility that can be run to determine the correct value which can
// then be set with these registry keys
#define CLOCKS_PER_FRAME                L"timingClocksPerFrame"
#define REC_CLOCKS_PER_FRAME            L"recommendedClocksPerFrame"
#define DEBUG_LEVEL                     L"debuglevel"
#define DEBUG_WIN9X                     L"debugWin9x"

/*****/

#define LEGSUP_HCD_MODE     0x2000  // value to put in LEGSUP reg for normal HCD use  JMD
#define LEGSUP_BIOS_MODE    0x00BF  // value to put in LEGSUP reg for BIOS/SMI use  JMD

#define LEGSUP_USBPIRQD_EN  0x2000  // bit 13

//
// Defines for enabling certian host controller driver features

#define VIA_HC                  // enable support for the VIA version of the
                                // Universal Host Controller

#define ENABLE_B0_FEATURES      // enable B0 optimizations
#define RECLAIM_BW              // enable bandwidth reclimation for bulk

#include "usbdlibi.h"
#include "usbdlib.h"
#include "roothub.h"

//
// total bandwidth in bits/ms
//

#define UHCD_TOTAL_USB_BW       12000

//
// 10% reserved for bulk and control
//
#define UHCD_BULK_CONTROL_BW    (UHCD_TOTAL_USB_BW/10)

//
// Number of times to try and get controller out of hung frame counter
// state before giving up (approx. 4ms per shot)
//

#define UHCD_MAX_KICK_STARTS 3


//
// enable USB BIOS support
//
#define USB_BIOS
//
// enable root hub support
//
#define ROOT_HUB


// flag to enable debug timing code
#if DBG
//#define DBG_TIMING
#define DEBUG_LOG
#endif
#define FRAME_LIST_SIZE                 1024

// number of bit times in a USB frame based on a 12MHZ SOF clock
#define UHCD_12MHZ_SOF              11936

//
// we keep a list of TDs for use as interrupt triggers,
// frame rollover detection and error recovery
// TDs 0,1 are used for frame rollover
// TD 2 is used for error recovery
// TD 3,4 reserved for PIIX4 hack
// TDs 5+ are used as triggers
//
#define UHCD_FIRST_TRIGGER_TD 5

#include "dbg.h"

//
// This is (on average) how many ms we can expect it to take for us to get an
// iso request in to the schedule.
//
#define UHCD_ASAP_LATENCY       5

//
// UHCD pending status values
//


// Urb is the current urb being serviced for the endpoint
#define UHCD_STATUS_PENDING_CURRENT \
    (((USBD_STATUS)0x00000001L) | USBD_STATUS_PENDING)

// Urb is queued to the endpoint
#define UHCD_STATUS_PENDING_QUEUED  \
    (((USBD_STATUS)0x00000002L) | USBD_STATUS_PENDING)

// Urb is being canceled in hardware
#define UHCD_STATUS_PENDING_CANCELING \
    (((USBD_STATUS)0x00000003L) | USBD_STATUS_PENDING)

// Urb in hardware needs to be canceled
#define UHCD_STATUS_PENDING_XXX \
    (((USBD_STATUS)0x00000004L) | USBD_STATUS_PENDING)

// the Urb is queued to the startio routine
#define UHCD_STATUS_PENDING_STARTIO  \
    (((USBD_STATUS)0x00000005L) | USBD_STATUS_PENDING)
//
// Macros used to keep track of how many pending urbs are
// associated with an endpoint.
//

#define DECREMENT_PENDING_URB_COUNT(irp)  \
    (((LONG)(ULONG_PTR)(IoGetCurrentIrpStackLocation(irp))->\
        Parameters.Others.Argument2)--)
#define INCREMENT_PENDING_URB_COUNT(irp)  \
    (((LONG)(ULONG_PTR)(IoGetCurrentIrpStackLocation(irp))->\
        Parameters.Others.Argument2)++)
#define PENDING_URB_COUNT(irp)  \
    (((LONG)(ULONG_PTR)(IoGetCurrentIrpStackLocation(irp))->\
        Parameters.Others.Argument2))

#define URB_HEADER(u) ((u)->UrbHeader)
#define HCD_AREA(u) ((u)->HcdUrbCommonTransfer.hca)

//
// number of bytes to allocate for a frame list
//

#define FRAME_LIST_LENGTH   (FRAME_LIST_SIZE * \
                            sizeof(HW_DESCRIPTOR_PHYSICAL_ADDRESS))

//
// Stepping Versions of the UHCI host controller
//

#define UHCD_A1_STEP    0
#define UHCD_B0_STEP    1

#define UHCI_HW_VERSION_UNKNOWN     0
#define UHCI_HW_VERSION_PIIX3       1
#define UHCI_HW_VERSION_PIIX4       2
#define UHCI_HW_VERSION_82460GXPIIX6   3        // IA64 PowerOn


//
// values for the HCD_EXTENSION flags field
//

#define UHCD_TRANSFER_ACTIVE        0x01
#define UHCD_TRANSFER_INITIALIZED   0x02
#define UHCD_MAPPED_LOCKED_PAGES    0x04
#define UHCD_TRANSFER_MAPPED        0x08
#define UHCD_TRANSFER_DEFER         0x10
#define UHCD_TOGGLE_READY           0x20


#define LOCK_ENDPOINT_PENDING_LIST(ep, irql, sig) \
                        KeAcquireSpinLock(&(ep)->PendingListSpin, &(irql)); \
                        LOGENTRY(LOG_MISC, sig, ep, irql, 0);\
                        UHCD_LockAccess(&(ep)->AccessPendingList);

#define UNLOCK_ENDPOINT_PENDING_LIST(ep, irql, sig) \
                        UHCD_UnLockAccess(&(ep)->AccessPendingList); \
                        LOGENTRY(LOG_MISC, sig, ep, irql, 0);\
                        KeReleaseSpinLock(&(ep)->PendingListSpin, irql);

#define LOCK_ENDPOINT_ACTIVE_LIST(ep, irql) \
                        KeAcquireSpinLock(&ep->ActiveListSpin, &irql); \
                        UHCD_LockAccess(&(ep)->AccessActiveList);

#define UNLOCK_ENDPOINT_ACTIVE_LIST(ep, irql) \
            UHCD_UnLockAccess(&(ep)->AccessActiveList); \
            KeReleaseSpinLock(&(ep)->ActiveListSpin, irql);


#define LOCK_ENDPOINT_LIST(de, irql) \
    KeAcquireSpinLock(&(de)->EndpointListSpin, &irql);

#define UNLOCK_ENDPOINT_LIST(de, irql) \
    KeReleaseSpinLock(&(de)->EndpointListSpin, irql);

//
// Maximum Polling Interval we support (ms)
//

//BUGBUG should be 32
#define MAX_INTERVAL                32

//
// Definitions for Common Buffer sizes,
// these are the buffers we use for TDs and
// double buffering packets.
//

//
// Needs to be big enough for all the TDs plus a queue header
// and a scratch buffer
//
#define UHCD_LARGE_COMMON_BUFFER_SIZE      \
    ((MAX_TDS_PER_ENDPOINT+2) * UHCD_HW_DESCRIPTOR_SIZE)
//#define UHCD_LARGE_COMMON_BUFFER_SIZE      1023
// size of largest packet (iso)

//
// Big enough for 8 TDs plus queue head plus scratch buffer
//
#define UHCD_MEDIUM_COMMON_BUFFER_SIZE      \
    ((MIN_TDS_PER_ENDPOINT+2) * UHCD_HW_DESCRIPTOR_SIZE)

#define UHCD_SMALL_COMMON_BUFFER_SIZE       128

//
// This is the number of buffers we hold in reserve -- we grow the free pool
// whenever we allocate at passive to maintain the reserve pool.  The idea
// here is to minimize the frequency that we have to call
// HalAllocateCommonBuffer from DPC level.
//
// buffers needed during DPC time will be typically packet buffers
// (needed to double buffer packets that cross page boundries)
//

// BUGBUG
// Currently NTKERN will fail any calls to HalAllocateCommonBuffer at DPC
// level so these values are unususally large.
//

#define UHCD_RESERVE_LARGE_BUFFERS      16
#define UHCD_RESERVE_MEDIUM_BUFFERS     32
#define UHCD_RESERVE_SMALL_BUFFERS      32

#define UHCD_MAX_ACTIVE_TRANSFERS   4

//
// The last four bits of a descriptor ptr are defined as control
// flag bits.
//

#define UHCD_CF_TERMINATE_BIT       0
#define UHCD_CF_TERMINATE           (1<<UHCD_CF_TERMINATE_BIT)

#define UHCD_CF_QUEUE_BIT           1
#define UHCD_CF_QUEUE               (1<<UHCD_CF_QUEUE_BIT)

#define UHCD_CF_VERTICAL_FIRST_BIT  2
#define UHCD_CF_VERTICAL_FIRST      (1<<UHCD_CF_VERTICAL_FIRST_BIT)

#define UHCD_CF_RESERVED_BIT        3
#define UHCD_CF_RESERVED            (1<<UHCD_CF_RESERVED_BIT)

#define SET_T_BIT(x)                (x |=  UHCD_CF_TERMINATE)
#define SET_Q_BIT(x)                (x |=  UHCD_CF_QUEUE)

#define CLEAR_T_BIT(x)              (x &= ~UHCD_CF_TERMINATE)


#define UHCD_DESCRIPTOR_PTR_MASK      0xfffffff0
#define UHCD_DESCRIPTOR_FLAGS_MASK    0x0000000f

//
//  Macros for manipulating descriptors
//

#define TD_PTR(descriptor)      ((PHW_TRANSFER_DESCRIPTOR) descriptor)
#define QH_PTR(descriptor)      ((PHW_QUEUE_HEAD) descriptor)

#define LIST_END                (UHCD_CF_TERMINATE)


//
// MACROS for USB controller registers
//

#define COMMAND_REG(deviceExtension)                    \
    ((PUSHORT) (deviceExtension->DeviceRegisters[0]))
#define STATUS_REG(deviceExtension)                     \
    ((PUSHORT) (deviceExtension->DeviceRegisters[0] + 0x02))
#define INTERRUPT_MASK_REG(deviceExtension)             \
    ((PUSHORT) (deviceExtension->DeviceRegisters[0] + 0x04))
#define FRAME_LIST_CURRENT_INDEX_REG(deviceExtension)   \
    ((PUSHORT) (deviceExtension->DeviceRegisters[0] + 0x06))
#define FRAME_LIST_BASE_REG(deviceExtension)            \
    ((PULONG) (deviceExtension->DeviceRegisters[0] + 0x08))
#define SOF_MODIFY_REG(deviceExtension)   \
    ((PUCHAR) (deviceExtension->DeviceRegisters[0] + 0x0C))
#define PORT1_REG(deviceExtension)                      \
    ((PUSHORT) (deviceExtension->DeviceRegisters[0] + 0x10))
#define PORT2_REG(deviceExtension)                      \
    ((PUSHORT) (deviceExtension->DeviceRegisters[0] + 0x12))

//
// Interrupt Mask register bits
//
#define UHCD_INT_MASK_SHORT_BIT         3
#define UHCD_INT_MASK_SHORT             (1<<UHCD_INT_MASK_SHORT_BIT)

#define UHCD_INT_MASK_IOC_BIT           2
#define UHCD_INT_MASK_IOC               (1<<UHCD_INT_MASK_IOC_BIT)

#define UHCD_INT_MASK_RESUME_BIT        1
#define UHCD_INT_MASK_RESUME            (1<<UHCD_INT_MASK_RESUME_BIT)

#define UHCD_INT_MASK_TIMEOUT_BIT       0
#define UHCD_INT_MASK_TIMEOUT           (1<<UHCD_INT_MASK_TIMEOUT_BIT)


//
// Port Register Bits
//
// BUGBUG these are for hub port control

#define UHCD_PORT_ENABLE_BIT            2
#define UHCD_PORT_ENABLE                (1<<UHCD_PORT_ENABLE_BIT)


//
// Command Register Bits
//

#define UHCD_CMD_RUN_BIT                0
#define UHCD_CMD_RUN                    (USHORT)(1<<UHCD_CMD_RUN_BIT)

#define UHCD_CMD_RESET_BIT              1
#define UHCD_CMD_RESET                  (USHORT)(1<<UHCD_CMD_RESET_BIT)

#define UHCD_CMD_GLOBAL_RESET_BIT       2
#define UHCD_CMD_GLOBAL_RESET           (USHORT)(1<<UHCD_CMD_GLOBAL_RESET_BIT)

#define UHCD_CMD_SUSPEND_BIT            3
#define UHCD_CMD_SUSPEND                (USHORT)(1<<UHCD_CMD_SUSPEND_BIT)

#define UHCD_CMD_FORCE_RESUME_BIT       4
#define UHCD_CMD_FORCE_RESUME           (USHORT)(1<<UHCD_CMD_FORCE_RESUME_BIT)

#define UHCD_CMD_SW_DEBUG_BIT           5
#define UHCD_CMD_SW_DEBUG               (USHORT)(1<<UHCD_CMD_SW_DEBUG_BIT)

#define UHCD_CMD_SW_CONFIGURED_BIT      6
#define UHCD_CMD_SW_CONFIGURED          (USHORT)(1<<UHCD_CMD_SW_CONFIGURED_BIT)

#define UHCD_CMD_MAXPKT_64_BIT          7
#define UHCD_CMD_MAXPKT_64              (USHORT)(1<<UHCD_CMD_MAXPKT_64_BIT)



//
// Status Register Bits
//

#define UHCD_STATUS_USBINT_BIT          0
#define UHCD_STATUS_USBINT              (1<<UHCD_STATUS_USBINT_BIT)

#define UHCD_STATUS_USBERR_BIT          1
#define UHCD_STATUS_USBERR              (1<<UHCD_STATUS_USBERR_BIT)

#define UHCD_STATUS_RESUME_BIT          2
#define UHCD_STATUS_RESUME              (1<<UHCD_STATUS_RESUME_BIT)

#define UHCD_STATUS_PCIERR_BIT          3
#define UHCD_STATUS_PCIERR              (1<<UHCD_STATUS_PCIERR_BIT)

#define UHCD_STATUS_HCERR_BIT           4
#define UHCD_STATUS_HCERR               (1<<UHCD_STATUS_HCERR_BIT)

#define UHCD_STATUS_HCHALT_BIT          5
#define UHCD_STATUS_HCHALT              (1<<UHCD_STATUS_HCHALT_BIT)

//
// opcodes for Create/Allocate/Free Descriptor functions
//

#define QUEUE_HEAD                  0
#define TRANSFER_DESCRIPTOR_LIST    1

#define UHCD_INTEL_VENDOR_ID             0x8086
#define UHCD_PIIX3_DEVICE_ID             0x7020
#define UHCD_PIIX4_DEVICE_ID             0x7112
#define UHCD_82460GXPIIX6_DEVICE_ID      0x7602         //IA64 PowerOn

#define MAX_TDS_PER_ENDPOINT    64
#define MIN_TDS_PER_ENDPOINT    8

// computes the size of a common buffer needed for an endpoint
// with n TDs.
// plus one for scratch buffer and one for queue head (+2)
#define TD_LIST_SIZE(n) (((n)+2)*UHCD_HW_DESCRIPTOR_SIZE)

//bugbug change to UHCD to HC
typedef PVOID HW_DESCRIPTOR_PTR;
typedef ULONG HW_DESCRIPTOR_PHYSICAL_ADDRESS;

//
// bit values for StatusField
//


#define TD_STATUS_BITSTUFF_BIT      0
#define TD_STATUS_BITSTUFF          (1<<TD_STATUS_BITSTUFF_BIT)

#define TD_STATUS_CRC_TIMEOUT_BIT   1
#define TD_STATUS_CRC_TIMEOUT       (1<<TD_STATUS_CRC_TIMEOUT_BIT)

#define TD_STATUS_NAK_BIT           2
#define TD_STATUS_NAK               (1<<TD_STATUS_NAK_BIT)

#define TD_STATUS_BABBLE_BIT        3
#define TD_STATUS_BABBLE            (1<<TD_STATUS_BABBLE_BIT)

#define TD_STATUS_FIFO_BIT          4
#define TD_STATUS_FIFO              (1<<TD_STATUS_FIFO_BIT)

#define TD_STATUS_STALL_BIT         5
#define TD_STATUS_STALL             (1<<TD_STATUS_STALL_BIT)

typedef struct _UHCD_BUFFER_POOL {
    SINGLE_LIST_ENTRY MemoryDescriptorFreePool;
    //
    // BUGBUG is it worth padding here to make space
    // between the spinlock and the list?
    //
    ULONG Sig;
    ULONG MaximumFreeBuffers;
    ULONG CommonBufferLength;
    KSPIN_LOCK MemoryDescriptorFreePoolSpin;
} UHCD_BUFFER_POOL, *PUHCD_BUFFER_POOL;

//
// To figure out padding for multiple architectures, we use
// this macro; if we wanted to be fancy we could do bitwise rounding,
// but this is obfuscated enough.  Let the compiler do the math for us.
//

#define UHCD_SPAD(T, align) \
     ((align) - (sizeof(T) % (align)) + sizeof(T))
//
// Take advantage of the fact that the MS compiler supports
// variant structs and unions so that we can get the proper padding
// for our structures.  Put in lots of C_ASSERT()s just to be sure
// nothing goes really really bad.
//

//
// Structure for tracking blocks of memory containing HW
// descriptors or packet buffers
//

struct _UHCD_MEMORY_DESCRIPTOR_INTERNAL {
   ULONG Sig;
   PUCHAR VirtualAddress;        // virtual address for the start of this
                                 // block
   HW_DESCRIPTOR_PHYSICAL_ADDRESS LogicalAddress;
                                // Address we can give the HC.
   ULONG Length;                 // length in bytes
   ULONG InUse;                  // in use count, bummped when we alloc
   SINGLE_LIST_ENTRY SingleListEntry;
   PUHCD_BUFFER_POOL BufferPool; // buffer pool that owns this MD
   ULONG Pad;
};

struct _HW_QUEUE_HEAD_INTERNAL {
    HW_DESCRIPTOR_PHYSICAL_ADDRESS HW_HLink;
        // used by host controller hardware
    HW_DESCRIPTOR_PHYSICAL_ADDRESS HW_VLink;
        // used by host controller hardware

    //
    // These fields are for software use
    //

    ULONG Sig;
    HW_DESCRIPTOR_PHYSICAL_ADDRESS  PhysicalAddress;
        // Physical address of this QH
    struct _HW_QUEUE_HEAD *Next;
    struct _HW_QUEUE_HEAD *Prev;
       // used for keeping track of where it is in
       // the schedule
    struct _UHCD_ENDPOINT *Endpoint;
    ULONG Flags;
};

//
//
// This structure aligns to 16 bytes
//

struct _HW_TRANSFER_DESCRIPTOR_INTERNAL {
     HW_DESCRIPTOR_PHYSICAL_ADDRESS HW_Link;

   ULONG    ActualLength:11;         /* 0 ..10 */
   ULONG    Reserved_1:6;            /* 11..16 */
   ULONG    StatusField:6;           /* 17..22 */
   ULONG    Active:1;                /* 23 */
   ULONG    InterruptOnComplete:1;   /* 24 */
   ULONG    Isochronous:1;           /* 25 */
   ULONG    LowSpeedControl:1;       /* 26 */
   ULONG    ErrorCounter:2;          /* 27..28 */
   ULONG    ShortPacketDetect:1;     /* 29 */
   ULONG    ReservedMBZ:2;           /* 30..31 */

   ULONG    PID:8;                   /* 0..7 */
   ULONG    Address:7;               /* 8..14 */
   ULONG    Endpoint:4;              /* 15..18 */
   ULONG    RetryToggle:1;           /* 19 */
   ULONG    Reserved_2:1;            /* 20 */
   ULONG    MaxLength:11;            /* 21..31 */

   HW_DESCRIPTOR_PHYSICAL_ADDRESS  PacketBuffer;

   //
   // These fields are for software use
   //

   ULONG Sig;
   HW_DESCRIPTOR_PHYSICAL_ADDRESS PhysicalAddress;
   ULONG Frame;
   //BUGBUG used to preprocess isoch Urbs
   PHCD_URB Urb;
};

typedef struct _HW_TRANSFER_DESCRIPTOR {
   union {
      //
      // For addressing
      //

      struct _HW_TRANSFER_DESCRIPTOR_INTERNAL;

      //
      // The compiler will pick the biggest as aligned to a multiple of 16
      //

      UCHAR _ReservedPad1[UHCD_SPAD(struct _UHCD_MEMORY_DESCRIPTOR_INTERNAL, 16)];
      UCHAR _ReservedPad2[UHCD_SPAD(struct _HW_TRANSFER_DESCRIPTOR_INTERNAL, 16)];
      UCHAR _ReservedPad3[UHCD_SPAD(struct _HW_QUEUE_HEAD_INTERNAL, 16)];
   };

} HW_TRANSFER_DESCRIPTOR, *PHW_TRANSFER_DESCRIPTOR;


//
// Hardware requires that all descriptors have 16 byte HW-specific section and
// have a software-use section so that the descriptor as a whole is 16-byte
// aligned
//

C_ASSERT(((sizeof(HW_TRANSFER_DESCRIPTOR) % 16) == 0));

#define UHCD_HW_DESCRIPTOR_SIZE     (sizeof(HW_TRANSFER_DESCRIPTOR))

//
// values for Flags field in queue head
//

#define UHCD_QUEUE_IN_USE       0x00000001

typedef struct _HW_QUEUE_HEAD {
   union {
      //
      // For addressing
      //

      struct _HW_QUEUE_HEAD_INTERNAL;

      //
      // The compiler will pick the biggest as aligned to a multiple of 16
      //

      UCHAR _ReservedPad1[UHCD_SPAD(struct _UHCD_MEMORY_DESCRIPTOR_INTERNAL, 16)];
      UCHAR _ReservedPad2[UHCD_SPAD(struct _HW_TRANSFER_DESCRIPTOR_INTERNAL, 16)];
      UCHAR _ReservedPad3[UHCD_SPAD(struct _HW_QUEUE_HEAD_INTERNAL, 16)];
   };
} HW_QUEUE_HEAD, *PHW_QUEUE_HEAD;


//
// Hardware requires that all descriptors have 16 byte HW-specific section and
// have a software-use section so that the descriptor as a whole is 16-byte
// aligned
//

C_ASSERT(((sizeof(HW_TRANSFER_DESCRIPTOR) % 16) == 0));

C_ASSERT(((sizeof(HW_QUEUE_HEAD) % 16) == 0));
C_ASSERT(sizeof(HW_TRANSFER_DESCRIPTOR) == sizeof(HW_QUEUE_HEAD));


//
// TD list structure
//

typedef struct _UHCD_TD_LIST {
    HW_TRANSFER_DESCRIPTOR TDs[1];
} UHCD_TD_LIST, *PUHCD_TD_LIST;



typedef struct _UHCD_MEMORY_DESCRIPTOR {
   union {

      //
      // For addressing
      //

      struct _UHCD_MEMORY_DESCRIPTOR_INTERNAL;

      //
      // The compiler will pick the biggest as aligned to a multiple of 16
      //

      UCHAR _ReservedPad1[UHCD_SPAD(struct _UHCD_MEMORY_DESCRIPTOR_INTERNAL, 16)];
      UCHAR _ReservedPad2[UHCD_SPAD(struct _HW_TRANSFER_DESCRIPTOR_INTERNAL, 16)];
      UCHAR _ReservedPad3[UHCD_SPAD(struct _HW_QUEUE_HEAD_INTERNAL, 16)];
   };

} UHCD_MEMORY_DESCRIPTOR, *PUHCD_MEMORY_DESCRIPTOR;

C_ASSERT(sizeof(UHCD_MEMORY_DESCRIPTOR) == sizeof(HW_TRANSFER_DESCRIPTOR));


//
// A descriptor list contains a Queue head descriptor
// plus one or more transfer descriptors
//
typedef struct _UHCD_HARDWARE_DESCRIPTOR_LIST {
    // includes queue head
    ULONG NumberOfHWDescriptors;

    // memory descriptor points to common buffer
    // containing descriptors
    PUHCD_MEMORY_DESCRIPTOR MemoryDescriptor;

    // 32 byte scratch buffer, we use this for the setup
    // packet
    HW_DESCRIPTOR_PHYSICAL_ADDRESS ScratchBufferLogicalAddress;
    PVOID ScratchBufferVirtualAddress;
} UHCD_HRADWARE_DESCRIPTOR_LIST, *PUHCD_HARDWARE_DESCRIPTOR_LIST;

//
// UHCD Endpoint Structure
//
// We create one of these for every endpoint we open.
//

//
// values for EndpointFlags field
//

// set to if the root hub code owns this ep
#define EPFLAG_ROOT_HUB                 0x00000001
// set when client issues an abort endpoint
// request -- causes all queued transfers for
// the endpoint to be completed.
#define EPFLAG_ABORT_PENDING_TRANSFERS  0x00000002
// causes all currently active transfers for an
// endpoint to be aborted.
#define EPFLAG_ABORT_ACTIVE_TRANSFERS   0x00000004
// endpoint is in the halted (AKA stalled) state
#define EPFLAG_HOST_HALTED              0x00000008
// endpoint belongs to a lowspeed device
#define EPFLAG_LOWSPEED                 0x00000010
// endpoint has had no transfers submitted,
// restored on reset
#define EPFLAG_VIRGIN                   0x00000020
// endpoint will not enter the 'halted' state
#define EPFLAG_NO_HALT                  0x00000040
// need attention
#define EPFLAG_HAVE_WORK                0x00000080
// idle state
#define EPFLAG_IDLE                     0x00000100
// ed is in th eschedule
#define EPFLAG_ED_IN_SCHEDULE           0x00000200
// ed is closed
#define EPFLAG_EP_CLOSED                0x00000400
// inicates we need to double buffer
// transfers for this endpoint
#define EPFLAG_DBL_BUFFER               0x00000800
#define EPFLAG_NODMA_ON                 0x00001000
// indicates we need to use the 'fast iso path'
// for transfers to the EP
#define EPFLAG_FAST_ISO                 0x00002000
// indicates we have initialized the ED
#define EPFLAG_INIT                     0x00004000

typedef struct _FAST_ISO_DATA {

    PDEVICE_OBJECT DeviceObject;

    PULONG  FastIsoFrameList;

    PUCHAR IsoTDListVa;
    HW_DESCRIPTOR_PHYSICAL_ADDRESS IsoTDListPhys;

    PUCHAR DataBufferStartVa;
    HW_DESCRIPTOR_PHYSICAL_ADDRESS DataBufferStartPhys;

} FAST_ISO_DATA, *PFAST_ISO_DATA;


#define SET_EPFLAG(ep, flag)    ((ep)->EndpointFlags |= (flag))
#define CLR_EPFLAG(ep, flag)    ((ep)->EndpointFlags &= ~(flag))

typedef struct _UHCD_ENDPOINT {
    ULONG Sig;                  // signature field
    UCHAR Type;                 // type of endpoint we are dealing with
    UCHAR EndpointAddress;
    USHORT MaxPacketSize;

    UCHAR Interval;
    UCHAR DeviceAddress;
    USHORT TDCount;                 // number of TDS in TDList

    PUHCD_TD_LIST TDList;
    PUHCD_TD_LIST SlotTDList[UHCD_MAX_ACTIVE_TRANSFERS];

    PUHCD_HARDWARE_DESCRIPTOR_LIST HardwareDescriptorList[UHCD_MAX_ACTIVE_TRANSFERS];
    // Pointer to queue head associated with this endpoint
    PHW_QUEUE_HEAD QueueHead;
    // Urbs currently being processed
    PHCD_URB ActiveTransfers[UHCD_MAX_ACTIVE_TRANSFERS];
    // List Urbs waiting to be processed
    LIST_ENTRY PendingTransferList;
    // Field for linking endpoints
    LIST_ENTRY ListEntry;

    // BUGBUG move some of this to
    // the urb work space
    SHORT LastTDPreparedIdx[UHCD_MAX_ACTIVE_TRANSFERS];
    SHORT CurrentTDIdx[UHCD_MAX_ACTIVE_TRANSFERS];

    SHORT LastTDInTransferIdx[UHCD_MAX_ACTIVE_TRANSFERS];
    UCHAR MaxRequests;
    UCHAR DataToggle;

    ULONG MaxTransferSize;
    ULONG CurrentFrame;

    PUCHAR NoDMABuffer;
    ULONG NoDMABufferLength;

    HW_DESCRIPTOR_PHYSICAL_ADDRESS NoDMAPhysicalAddress;

#if DBG
    ULONG AccessPendingList; // access flag, incremented when we HOLD
                             // the endpoint
                             // decremented when we RELEASE the endpoint
    ULONG AccessActiveList;
#endif

    ULONG FrameToClose;      // Frame number when the close request was
                             // processed

    ULONG EndpointFlags;

    KSPIN_LOCK ActiveListSpin;

    KSPIN_LOCK PendingListSpin;

    USHORT TdsScheduled[UHCD_MAX_ACTIVE_TRANSFERS];
    USHORT Offset;

    LONG IdleTime;
    LARGE_INTEGER LastIdleTime;

    FAST_ISO_DATA FastIsoData;

    UCHAR LastPacketDataToggle;
    UCHAR CurrentXferId;
    UCHAR NextXferId;
    UCHAR Pad[1];

}  UHCD_ENDPOINT, *PUHCD_ENDPOINT;

struct _UHCD_PAGE_LIST_ENTRY_INTERNAL {
   LIST_ENTRY ListEntry;
   PHYSICAL_ADDRESS LogicalAddress;
   ULONG Length;
   ULONG Flags;
};

//
// Take advantage of the fact that the MS compiler supports
// variant structs and unions so that we can get the proper padding
// for our structures.  Put in lots of C_ASSERT()s just to be sure
// nothing goes really really bad
//

//
// Thist structure must be a multiple of 32 bytes
// to maintain proper alignemnt of the HW descriptors
// it is the first entry in the blocks of memory we allocate
// Host controller HW descriptors from
//

typedef struct _UHCD_PAGE_LIST_ENTRY {
   union {
       struct _UHCD_PAGE_LIST_ENTRY_INTERNAL;
       UCHAR _ReservedPad[UHCD_SPAD(struct _UHCD_PAGE_LIST_ENTRY_INTERNAL, 32)];
   };
} UHCD_PAGE_LIST_ENTRY, *PUHCD_PAGE_LIST_ENTRY;

C_ASSERT(((sizeof(UHCD_PAGE_LIST_ENTRY) % 32) == 0));

//
//typedef struct _UHCD_WORKER_CONTEXT {
//    WORK_QUEUE_ITEM WorkQueueItem;
//    PIRP Irp;
//    PDEVICE_OBJECT DeviceObject;
//} UHCD_WORKER_CONTEXT, *PUHCD_WORKER_CONTEXT;

//
// A structure representing the instance information associated with
// a particular device
//

typedef struct _DEVICE_EXTENSION {

    UCHAR UsbdWorkArea[sizeof(USBD_EXTENSION)];

    //
    // Device object that the bus extender created for me.
    //

    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Device object of the first guy on the stack
    // -- the guy we pass our Irps on to.
    //

    PDEVICE_OBJECT TopOfStackDeviceObject;


    //
    // Pointer to interrupt object.
    //

    PKINTERRUPT InterruptObject;

    //
    // Pointer to the virtual base address for the USB frame list
    //

    PVOID FrameListVirtualAddress;

    //
    // Logical address of frame list returned from
    // HalAllocateCommonBuffer
    //

    PHYSICAL_ADDRESS FrameListLogicalAddress;

    //
    // BUGBUG keep a copy to remove isoch descriptors
    // Pointer to the virtual base address for the USB frame list
    //

    PVOID FrameListCopyVirtualAddress;

    //
    // DPC Object for processing frames with completed transfers
    //

    KDPC IsrDpc;

    //
    // Base queue head that we link all control/bulk transfer
    // queues to.
    //

    PHW_QUEUE_HEAD PersistantQueueHead;

    //
    // Descriptor List for the PersistantQueueHead
    //

    PUHCD_HARDWARE_DESCRIPTOR_LIST PQH_DescriptorList;

    //
    // Queue of active endpoints
    //

    // BUGBUG we'll probably have a separate queue for each
    // transfer type eventually
    LIST_ENTRY EndpointList;
    LIST_ENTRY EndpointLookAsideList;

    // lists for fast iso
    LIST_ENTRY FastIsoEndpointList;
    LIST_ENTRY FastIsoTransferList;

    //
    // List of closed endpoints who's resources need to be
    // released.
    //

    LIST_ENTRY ClosedEndpointList;

    // Virtual Addresses for the interrupt queue heads in the
    // schedule.

    PHW_QUEUE_HEAD InterruptSchedule[MAX_INTERVAL];

    // list of common buffer pages allocated

    LIST_ENTRY PageList;

    //
    // Table where we keep track of the available bw on the usb
    // for iso and interrupt, entries are in bits/ms
    //

    ULONG BwTable[MAX_INTERVAL];

    //
    // 12 bit counter, contains the frame value from the previous
    // interrupt
    //

    ULONG LastFrame;

    //
    // High part of USB frame counter
    //

    ULONG FrameHighPart;

    LARGE_INTEGER LastIdleTime;

    LARGE_INTEGER LastXferIdleTime;

    LONG IdleTime;

    LONG XferIdleTime;

    //
    // TDs we are using as interrupt triggers
    //

    PUHCD_TD_LIST   TriggerTDList;

    UHCD_BUFFER_POOL LargeBufferPool;
    UHCD_BUFFER_POOL MediumBufferPool;
    UHCD_BUFFER_POOL SmallBufferPool;

    //
    // ROOT HUB VARIABLES
    //

    //
    // device address assigned to root hub
    //

    ULONG RootHubDeviceAddress;

    //
    // context pointer passed to root hub
    //
    PROOTHUB RootHub;

    //
    // counter for the number of root hub timers
    // that are currently scheduled
    //

    ULONG RootHubTimersActive;

    //
    // Timer and Dpc for polling the root hub interrupt
    // endpoint
    //

    KDPC RootHubPollDpc;

    KTIMER RootHubPollTimer;

    //
    // non-zero if timer was initialized
    //

    ULONG RootHubPollTimerInitialized;


    KSPIN_LOCK EndpointListSpin;

    PUHCD_ENDPOINT RootHubInterruptEndpoint;

    // BUGBUG
    // isoch stuff

    ULONG LastFrameProcessed;

    //
    // DMA adapter object representing this instance
    // of the UHCI controller.
    //

    PDMA_ADAPTER AdapterObject;

    ULONG NumberOfMapRegisters;


    PHW_TRANSFER_DESCRIPTOR FrameBabbleRecoverTD;

    ULONG DeviceNameHandle;


    //
    // save registers for BIOS
    //

    USHORT BiosCmd;
    USHORT BiosIntMask;

    ULONG BiosFrameListBase;

    USHORT LegacySupportRegister;
    USHORT Pad;

    PUCHAR DeviceRegisters[1];

    //
    // saved state information for no power resume
    //
    USHORT SavedInterruptEnable;
    USHORT SavedCommandReg;

    DEVICE_POWER_STATE CurrentDevicePowerState;

    ULONG HcFlags;

    USHORT SavedFRNUM;
    USHORT SavedUnused;
    ULONG SavedFRBASEADD;
    ULONG Port;
    LONG HcDma;

    ULONG RegRecClocksPerFrame;

    PVOID Piix4EP;

    KSPIN_LOCK HcFlagSpin;
    KSPIN_LOCK HcDmaSpin;
    KSPIN_LOCK HcScheduleSpin;

    //
    // Busy flag set when the ISRDPC routine is
    // processing the endpoint list
    //

    BOOLEAN EndpointListBusy;

    //
    // Stepping Version of the Host Controller
    //

    UCHAR SteppingVersion;

    CHAR SavedSofModify;

    UCHAR ControllerType;

    //
    // statistic counters, used for debugging and interfacing with
    // sysmon.
    //
    HCD_STAT_COUNTERS Stats;
    HCD_ISO_STAT_COUNTERS IsoStats;
    ULONG LastFrameInterrupt;

#if DBG
    // ptr to list of dwords containing the number of iso bytes
    // scheduled for a particular frame
    PULONG IsoList;
#endif

    //
    // Status we returned last time we were asked to power up the
    // controller.  We check this to see if we can touch the
    // hardware when the hub is powered up.
    //

    NTSTATUS LastPowerUpStatus;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// values for HcFlags
//

// Set to indicate port resources were assigned
#define HCFLAG_GOT_IO                   0x00000001
// Set at initialization to indicate that the base register
// address must be unmapped when the driver is unloaded.
#define HCFLAG_UNMAP_REGISTERS          0x00000002
// Set if we have a USB BIOS on this system
#define HCFLAG_USBBIOS                  0x00000004
// Current state of BW reclimation
#define HCFLAG_BWRECLIMATION_ENABLED    0x00000008
// This flag indicates if the driver needs to cleanup resources
// allocated in start_device.
#define HCFLAG_NEED_CLEANUP             0x00000010
// HC is idle
#define HCFLAG_IDLE                     0x00000020
// set when the rollover int is disabled
#define HCFLAG_ROLLOVER_IDLE            0x00000040
// set when the controller is stopped
#define HCFLAG_HCD_STOPPED              0x00000080
// turn off idle check
#define HCFLAG_DISABLE_IDLE             0x00000100
// work item queued
#define HCFLAG_WORK_ITEM_QUEUED         0x00000200
// hcd has shut down
#define HCFLAG_HCD_SHUTDOWN             0x00000400
// indicates we need to restore HC from hibernate
#define HCFLAG_LOST_POWER               0x00000800
// set when root hub turns off the HC
#define HCFLAG_RH_OFF                   0x00001000

#define HCFLAG_MAP_SX_TO_D3             0x00002000
// set if we will be suspending in this D3
#define HCFLAG_SUSPEND_NEXT_D3          0x00004000

typedef struct _UHCD_RESOURCES {
    ULONG InterruptVector;
    KIRQL InterruptLevel;
    KAFFINITY Affinity;
    BOOLEAN ShareIRQ;
    KINTERRUPT_MODE InterruptMode;
} UHCD_RESOURCES, *PUHCD_RESOURCES;

// Macros used by the transfer modules

#define NEXT_TD(idx, ep)    ((idx+1) % ep->TDCount)

#define DATA_DIRECTION_IN(u)  \
    ((BOOLEAN)((u)->HcdUrbCommonTransfer.TransferFlags & \
        USBD_TRANSFER_DIRECTION_IN))

#define DATA_DIRECTION_OUT(u)  \
    ((BOOLEAN)!((u)->HcdUrbCommonTransfer.TransferFlags & \
        USBD_TRANSFER_DIRECTION_IN))

typedef struct _UHCD_LOGICAL_ADDRESS {
    HW_DESCRIPTOR_PHYSICAL_ADDRESS LogicalAddress;
    ULONG Length;
    // if this block caintained a USB packet that crossed a
    // page boundry and needed to be double
    // buffered then this is the offset of that packet.
    ULONG PacketOffset;
    PUHCD_MEMORY_DESCRIPTOR PacketMemoryDescriptor; // block of memory
                                                    // used to double buffer
                                                    // packet

} UHCD_LOGICAL_ADDRESS, *PUHCD_LOGICAL_ADDRESS;

//
// Private definition for urb work area
// used by HCD for each transfer URB.
//

typedef struct _HCD_EXTENSION {
    ULONG CurrentPacketIdx;
    ULONG BytesTransferred;
    ULONG TransferOffset;
    ULONG Status;

    ULONG PacketsProcessed;

    UCHAR Slot;
    UCHAR Flags;
    UCHAR ErrorCount;
    UCHAR XferId;

    UCHAR DataToggle;
    UCHAR Reserved[3];

    //
    // list of logical addresses we can give
    // to the HC
    //

    PVOID SystemAddressForMdl;
    ULONG NumberOfMapRegisters;
    PVOID MapRegisterBase;
    ULONG NumberOfLogicalAddresses;
    UHCD_LOGICAL_ADDRESS LogicalAddressList[1];
} HCD_EXTENSION, *PHCD_EXTENSION;


typedef struct _UHCD_WORKITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    PDEVICE_OBJECT DeviceObject;
} UHCD_WORKITEM, *PUHCD_WORKITEM;

//
// some USB constants
//

#define USB_IN_PID      0x69
#define USB_OUT_PID     0xe1
#define USB_SETUP_PID   0x2d

#define NULL_PACKET_LENGTH      0x7ff

#define UHCD_USB_TO_SYSTEM_BUFFER_LENGTH(len)   \
    ((len+1) & NULL_PACKET_LENGTH)
#define UHCD_SYSTEM_TO_USB_BUFFER_LENGTH(len)   \
    ((len-1) & NULL_PACKET_LENGTH)

//
// Function Prototypes
//

NTSTATUS
UHCD_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
UHCD_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UHCD_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
UHCD_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT *DeviceObject,
    IN PUNICODE_STRING DeviceNameUnicodeString
    );

NTSTATUS
UHCD_StartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_RESOURCES Resources
    );

NTSTATUS
UHCD_GetResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCM_RESOURCE_LIST ResourceList,
    IN OUT PUHCD_RESOURCES Resources
    );

VOID
UHCD_CompleteIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS ntStatus,
    IN ULONG Information,
    IN PHCD_URB Urb
    );

VOID
UHCD_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UHCD_URB_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UHCD_OpenEndpoint_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UHCD_Transfer_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
UHCD_InterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

VOID
UHCD_IsrDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
UHCD_OpenEndpoint_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UHCD_CloseEndpoint_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UHCD_GetDoneTransfer(
    IN PVOID Context
    );

NTSTATUS
UHCD_GetResourceList(
    IN PDRIVER_OBJECT DriverOject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PCM_RESOURCE_LIST *ResourceList,
    IN PUNICODE_STRING    RegistryPath
    );

NTSTATUS
UHCD_MakeInterrupt(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UHCD_StopDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UHCD_InitializeSchedule(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UHCD_StartGlobalReset(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UHCD_CompleteGlobalReset(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
UHCD_InsertQueueHeadInSchedule(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHW_QUEUE_HEAD QueueHead,
    IN ULONG Offset
    );

VOID
UHCD_InitializeTransferDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHW_TRANSFER_DESCRIPTOR Transfer
    );

VOID
UHCD_InitializeQueueHead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHW_QUEUE_HEAD QueueHead
    );

BOOLEAN
UHCD_AllocateHardwareDescriptors(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_HARDWARE_DESCRIPTOR_LIST *HardwareDescriptorList,
    IN ULONG NumberOfTransferDescriptors
    );

VOID
UHCD_FreeHardwareDescriptors(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_HARDWARE_DESCRIPTOR_LIST HardwareDescriptorList
    );

VOID
UHCD_CompleteTransferDPC(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN LONG Slot
    );

BOOLEAN
UHCD_RemoveQueueHeadFromSchedule(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHW_QUEUE_HEAD QueueHead,
    IN BOOLEAN RemoveFromEPList
    );

ULONG
UHCD_GetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
UHCD_CopyInterruptScheduleToFrameList(
    IN PDEVICE_OBJECT DeviceObject
    );

__inline VOID
UHCD_InitializeAsyncTD(
    IN PUHCD_ENDPOINT Endpoint,
    IN PHW_TRANSFER_DESCRIPTOR TransferDescriptor
    );

VOID
UHCD_GlobalResetDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
UHCD_PrepareStatusPacket(
    IN PHW_TRANSFER_DESCRIPTOR TransferDescriptor,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB    Urb
    );

VOID
UHCD_PrepareSetupPacket(
    IN PHW_TRANSFER_DESCRIPTOR TransferDescriptor,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB    Urb
    );

USBD_STATUS
UHCD_PrepareMoreAsyncTDs(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb,
    IN BOOLEAN Busy
    );

NTSTATUS
UHCD_RootHub_OpenEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHCD_URB Urb
    );

NTSTATUS
UHCD_RootHub_CloseEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHCD_URB Urb
    );

NTSTATUS
UHCD_RootHub_ControlTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHCD_URB Urb
    );

NTSTATUS
UHCD_RootHub_InterruptTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PHCD_URB Urb
    );

VOID
UHCD_RootHubPoll(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

VOID
UHCD_ScheduleIsochTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB    Urb
    );

VOID
UHCD_RootHubTimerDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
UHCD_PnPIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UHCD_PowerIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
UHCD_RootHub_InterruptTransferCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



IO_ALLOCATION_ACTION
UHCD_StartDmaTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

VOID
UHCD_InitializeDmaTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHCD_URB Urb,
    IN PUHCD_ENDPOINT Endpoint,
    IN LONG Slot,
    IN UCHAR XferId
    );

PUHCD_MEMORY_DESCRIPTOR
UHCD_AllocateCommonBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfBytes
    );

VOID
UHCD_FreeCommonBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_MEMORY_DESCRIPTOR MemoryDescriptor
    );

VOID
UHCD_InitializeCommonBufferPool(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUHCD_BUFFER_POOL BufferPool,
    IN ULONG CommonBufferLength,
    IN ULONG MaximumFreeBuffers
    );

HW_DESCRIPTOR_PHYSICAL_ADDRESS
UHCD_GetPacketBuffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb,
    IN PHCD_EXTENSION urbWork,
    IN ULONG Offset,
    IN ULONG PacketSize
    );

VOID
UHCD_RequestInterrupt(
    IN PDEVICE_OBJECT DeviceObject,
    IN LONG FrameNumber
    );

VOID
UHCD_TransferCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UHCD_BeginTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb,
    IN ULONG Slot
    );

PHCD_URB
UHCD_RemoveQueuedUrbs(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHCD_URB Urb,
    IN PIRP Irp
    );

#if DBG
VOID
UHCD_LockAccess(
    IN PULONG c
    );

VOID
UHCD_UnLockAccess(
    IN PULONG c
    );
#else
#define UHCD_UnLockAccess(c)
#define UHCD_LockAccess(c)
#endif

VOID
UHCD_StartIoCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UHCD_EndpointWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

VOID
UHCD_InsertIsochDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHW_TRANSFER_DESCRIPTOR TransferDescriptor,
    IN ULONG FrameNumber
    );

VOID
UHCD_GetSetEndpointState_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


#define UHCD_AllocateBandwidth(DeviceObject, Endpoint, Offset)  \
    UHCD_ManageBandwidth((DeviceObject), \
    (Endpoint), \
    (Offset),\
    TRUE)

#define UHCD_FreeBandwidth(DeviceObject, Endpoint, Offset)  \
    UHCD_ManageBandwidth((DeviceObject), \
    (Endpoint), \
    (Offset),\
    FALSE)

BOOLEAN
UHCD_ManageBandwidth(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN ULONG Offset,
    IN BOOLEAN AllocateFlag
    );

NTSTATUS
UHCD_GetDeviceName(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING DeviceNameUnicodeString,
    IN BOOLEAN DeviceLink
    );

USBD_STATUS
UHCD_MapTDError(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG Td_Status,
    ULONG ActualLength
    );

VOID
UHCD_RootHubPollDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
UHCD_Suspend(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN SuspendBus
    );

NTSTATUS
UHCD_Resume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DoResumeSignaling
    );

NTSTATUS
UHCD_SaveHCstate(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UHCD_RestoreHCstate(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UHCD_FinishInitializeEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PUSB_ENDPOINT_DESCRIPTOR EndpointDescriptor,
    IN PHCD_URB Urb
    );

VOID
UHCD_CleanupDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

VOID
UHCD_BufferPoolCheck(
    IN PDEVICE_OBJECT DeviceObject
    );

ULONG
UHCD_GrowBufferPool(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_BUFFER_POOL BufferPool,
    IN ULONG Length,
    IN PUCHAR VirtualAddress,
    IN PUCHAR EndVirtualAddress,
    IN HW_DESCRIPTOR_PHYSICAL_ADDRESS HwLogicalAddress
    );

VOID
UHCD_InitBandwidthTable(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UHCD_StopBIOS(
    IN PDEVICE_OBJECT DeviceObject
    );

USHORT
UHCD_GetNumTDsPerEndoint(
    IN UCHAR EndpointType
    );

VOID
UHCD_BW_Reclimation(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Enable
    );

NTSTATUS
UHCD_SetDevicePowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE DeviceState
    );

VOID
UHCD_ReadWriteConfig(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  BOOLEAN Read,
    IN  PVOID Buffer,
    IN  ULONG Offset,
    IN  ULONG Length
    );

NTSTATUS
UHCD_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    );

ULONG
UHCD_FreePoolSize(
    IN PUHCD_BUFFER_POOL BufferPool,
    IN OUT PULONG ByteCount
    );

NTSTATUS
UHCD_GetClassGlobalRegistryParameters(
    IN OUT PULONG ForceLowPowerState
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
UHCD_DeferPoRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
UHCD_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UHCD_FixPIIX4(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
UHCD_InitializeHardwareQueueHeadDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PHW_QUEUE_HEAD QueueHead,
    IN HW_DESCRIPTOR_PHYSICAL_ADDRESS LogicalAddress
    );

VOID
UHCD_MoreCommonBuffers(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
UHCD_AllocateCommonBufferBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG CommonBufferLength,
    IN ULONG NumberOfPages
    );

ULONG
UHCD_CheckCommonBufferPool(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_BUFFER_POOL BufferPool,
    IN BOOLEAN Allocate
    );

NTSTATUS
UHCD_StartBIOS(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UHCD_RootHubPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UHCD_ProcessPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
UHCD_ProcessPowerPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
UHCD_DeferredStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UHCD_CheckIdle(
    IN  PDEVICE_OBJECT DeviceObject
    );

VOID
UHCD_DisableIdleCheck(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
UHCD_WakeIdle(
    IN  PDEVICE_OBJECT DeviceObject
    );

VOID
UHCD_GrowPoolWorker(
    IN PVOID Context
    );

NTSTATUS
UHCD_GetSOFRegModifyValue(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG SofModifyValue
    );

NTSTATUS
UHCD_GetGlobalRegistryParameters(
    IN OUT PULONG DisableController
    );

NTSTATUS
UHCD_ExternalGetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG CurrentFrame
    );

UCHAR
MAX_REQUESTS(
    IN PUSB_ENDPOINT_DESCRIPTOR EndpointDescriptor,
    IN ULONG EpFlags
    );

VOID
UHCD_FixupDataToggle(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHCD_URB Urb
    );

VOID
UHCD_SetControllerD0(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
UHCD_EndpointWakeup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

VOID
UHCD_EndpointIdle(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

ULONG
UHCD_ExternalGetConsumedBW(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
UHCD_EndpointDMAWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

VOID
UHCD_EndpointNoDMAWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

NTSTATUS
UHCD_InitializeNoDMAEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

VOID
UHCD_Free_NoDMA_Buffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR NoDMABuffer
    );

PUCHAR
UHCD_Alloc_NoDMA_Buffer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN ULONG Length
    );

NTSTATUS
UHCD_UnInitializeNoDMAEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

VOID
UHCD_StopNoDMATransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

NTSTATUS
UHCD_InitializeFastIsoEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

NTSTATUS
UHCD_UnInitializeFastIsoEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint
    );

NTSTATUS
UHCD_ProcessFastIsoTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PIRP Irp,
    IN PHCD_URB Urb
    );

PUHCD_ENDPOINT
UHCD_GetLastFastIsoEndpoint(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UHCD_GetClassGlobalDebugRegistryParameters(
    );

PHW_TRANSFER_DESCRIPTOR
UHCD_CleanupFastIsoTD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN ULONG RelativeFrame,
    IN BOOLEAN Count
    );

VOID
UhcdKickStartController(IN PDEVICE_OBJECT PDevObj);

NTSTATUS
UHCD_SubmitFastIsoUrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    );

VOID
UHCD_ValidateIsoUrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN OUT PHCD_URB Urb
    );

#endif /*  __UHCD_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\uhcd\urb.c ===
/*++

Copyright (c) 1995,1996 Microsoft Corporation
:ts=4

Module Name:

    urb.c

Abstract:

    The module manages transactions on the USB.

Environment:

    kernel mode only

Notes:

Revision History:

    11-01-95 : created
    04-28-96 : linked urb support & cancel support

--*/
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"
#include "hcdi.h"
#include "uhcd.h"


#define COMPUTE_HCD_EXTENSION_SIZE(urb)  (sizeof(HCD_EXTENSION) + \
                    (urb->HcdUrbCommonTransfer.TransferBufferLength / PAGE_SIZE + 1) \
                    * sizeof(UHCD_LOGICAL_ADDRESS))

#define UHCD_IS_TRANSFER(urb)    (((urb)->UrbHeader.Function == URB_FUNCTION_CONTROL_TRANSFER || \
                                   (urb)->UrbHeader.Function == URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER ||\
                                   (urb)->UrbHeader.Function == URB_FUNCTION_ISOCH_TRANSFER) \
                                         ? TRUE : FALSE)



// calc the maxrequests based on endpoint type nad
// flag options
UCHAR
MAX_REQUESTS(
    IN PUSB_ENDPOINT_DESCRIPTOR EndpointDescriptor,
    IN ULONG EpFlags
    )
{

    if (EpFlags & EPFLAG_DBL_BUFFER) {
        return 1;
    }

    switch (USB_ENDPOINT_TYPE_MASK &
        EndpointDescriptor->bmAttributes) {
    case USB_ENDPOINT_TYPE_BULK:
        return 2;
        //return 1;
    case USB_ENDPOINT_TYPE_ISOCHRONOUS:
        return 3;
    default:
        return 1;
    }
}

#if 0
ULONG
UHCD_CountPageCrossings(
    IN ULONG MaxRequests,
    IN ULONG MaxTransferSize
    )
/*++

Routine Description:

    Completes an I/O Request

Arguments:


Return Value:

    maximum number of possible page crossings

--*/
{
    ULONG pageCrossings;

    pageCrossings = (MaxTransferSize + PAGE_SIZE) / PAGE_SIZE;

    if (MaxRequests>1) {
        pageCrossings *= 2;
    }

    // now allocate space for packet buffers
    UHCD_KdPrint((2, "'UHCD_CountPageCrossings, max transfer size  0x%x -- page crossings = 0x%x\n",
        MaxTransferSize, pageCrossings));

    UHCD_ASSERT(pageCrossings > 0);

    return pageCrossings;
}
#endif


VOID
UHCD_CompleteIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS ntStatus,
    IN ULONG Information,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    Completes an I/O Request

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet to complete

    ntStatus - status code to set int the IRP when completed

    Information -

    Urb - root transfer urb if this Irp is associated with
            a transfer.

Return Value:


--*/
{
    KIRQL irql;
    UCHAR flags = 0;

    STARTPROC("cIrp");

    UHCD_KdPrint((2, "'UHCD_CompleteIrp status = %x\n", ntStatus));
    LOGENTRY(LOG_MISC, 'ICan', Urb, 0, Irp);

    if (Urb) {

        //
        // if we have any working space free it now
        //

        if (UHCD_IS_TRANSFER(Urb) && HCD_AREA(Urb).HcdExtension) {
            PHCD_EXTENSION urbWork;
            urbWork = HCD_AREA(Urb).HcdExtension;
            // remember the flags
            flags = urbWork->Flags;

            RETHEAP(HCD_AREA(Urb).HcdExtension);
            HCD_AREA(Urb).HcdExtension = NULL;
        }

        //
        // Decrement the urb counter that we keep in our stack location for
        // the irp, when it goes to zero -- complete it
        //

        //
        // one Urb completed
        //

        DECREMENT_PENDING_URB_COUNT(Irp);

        if (PENDING_URB_COUNT(Irp)) {

            //
            // stall completion until all Urbs are done.
            //

            TEST_TRAP();
            return;

        } else {

            IoAcquireCancelSpinLock(&irql);

            if (Irp->Cancel) {

                LOGENTRY(LOG_MISC, 'irpX', flags, 0, Irp);

                // note that the cancel routine will only mess
                // with the urbs on the active list -- any active
                // urbs should have been removed from the active
                // list before calling this routine

                //
                // Irp associated with this transfer has
                // been canceled.
                //
                // The cancel routine will complete the Irp
                // unless there are active transfers.
                //

                if (flags & UHCD_TRANSFER_ACTIVE) {

                    IoSetCancelRoutine(Irp, NULL);

                    IoReleaseCancelSpinLock(irql);

                    //
                    // if the io has already started the we must
                    // complete the Irp with STATUS_CANCELLED here.
                    //

                    ntStatus = STATUS_CANCELLED;
                    Information = 0;

                    goto UHCD_CompleteIrp_CompleteRequest;
                }

                IoReleaseCancelSpinLock(irql);

                return;

            } else {

                //
                // Irp is no longer cancelable
                //

                LOGENTRY(LOG_MISC, 'NCan', flags, 0, Irp);

                IoSetCancelRoutine(Irp, NULL);

                IoReleaseCancelSpinLock(irql);

                //
                // Pending bit should be cleared
                //

                UHCD_ASSERT(!USBD_PENDING(Urb->HcdUrbCommonTransfer.Status));

            }

        }
    }

UHCD_CompleteIrp_CompleteRequest:

    Irp->IoStatus.Status      = ntStatus;
    Irp->IoStatus.Information = Information;

    LOGENTRY(LOG_MISC, 'irpC', Irp, DeviceObject, Urb);

    USBD_CompleteRequest(Irp,
                         IO_NO_INCREMENT);

    ENDPROC("cIrp");
}


NTSTATUS
UHCD_URB_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Process URBs from the dispatch routine.

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:


--*/
{
    PHCD_URB urb;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_ENDPOINT endpoint = NULL;
    ULONG siz, cnt;
    ULONG numTDs;

    UHCD_KdPrint((2, "'enter UHCD_URB_Dispatch \n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    urb = (PHCD_URB) URB_FROM_IRP(Irp);

    if (deviceExtension->CurrentDevicePowerState != PowerDeviceD0 ||
        deviceExtension->HcFlags & HCFLAG_HCD_SHUTDOWN) {
        //
        // someone is submitting requests while the
        // HC is suspended or OFF, we will just fail them
        //
        UHCD_KdPrint
            ((0, "'Warning: UHCD got a request while not in D0 in shutdown\n"));
        ntStatus = STATUS_DEVICE_NOT_READY;
        URB_HEADER(urb).Status = USBD_STATUS_REQUEST_FAILED;
        UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
        return ntStatus;
    }

    switch(URB_HEADER(urb).Function) {

    //
    // These commands get queued to the startio routine
    // for processing.
    //

    case URB_FUNCTION_HCD_OPEN_ENDPOINT:

#ifdef ROOT_HUB
        if (urb->HcdUrbOpenEndpoint.DeviceAddress ==
            deviceExtension->RootHubDeviceAddress) {

            // This routine will either complete
            // the irp or mark it pending.
            ntStatus = UHCD_RootHub_OpenEndpoint(DeviceObject,
                                                 Irp,
                                                 urb);
            break;
        }
#endif
        //
        // Grow the common buffer pool based on how much
        // memory we'll need for transfers
        //
        // Well need enough for one set of TDs plus
        // a common buffer for each possible page crossing
        // within a trasnsfer.

        // first allocate space for the TDs
        // for now use a global value

        //
        // allocate the endpoint structures here while we are
        // at passive level
        //

        endpoint = (PUHCD_ENDPOINT) GETHEAP(NonPagedPool,
                                            sizeof(UHCD_ENDPOINT));


        if (endpoint) {

            // start endpoint initialization
            RtlZeroMemory(endpoint, sizeof(*endpoint));
            endpoint->Sig = SIG_EP;

             // check for bulk and iso special options
             // we only support double buffering for bulk-IN
             // we only support fast iso for iso-OUT

            if (urb->HcdUrbOpenEndpoint.HcdEndpointFlags &
                    USBD_EP_FLAG_DOUBLE_BUFFER) {

                if (USB_ENDPOINT_DIRECTION_IN(
                        urb->HcdUrbOpenEndpoint.EndpointDescriptor->bEndpointAddress)
                    &&
                    (USB_ENDPOINT_TYPE_MASK &
                     urb->HcdUrbOpenEndpoint.EndpointDescriptor->bmAttributes)
                        ==
                     USB_ENDPOINT_TYPE_BULK) {

                    SET_EPFLAG(endpoint, EPFLAG_DBL_BUFFER);

                } else { // bugbug error here?
                    UHCD_KdPrint((1, "'WARNING: Cannot double buffer this endpoint\n"));

                }
            }

#ifdef FAST_ISO
            if (urb->HcdUrbOpenEndpoint.HcdEndpointFlags &
                    USBD_EP_FLAG_FAST_ISO) {
                if (USB_ENDPOINT_DIRECTION_OUT(
                        urb->HcdUrbOpenEndpoint.EndpointDescriptor->bEndpointAddress)
                    &&
                    (USB_ENDPOINT_TYPE_MASK &
                      urb->HcdUrbOpenEndpoint.EndpointDescriptor->bmAttributes)
                        ==
                      USB_ENDPOINT_TYPE_ISOCHRONOUS) {

                    SET_EPFLAG(endpoint, EPFLAG_FAST_ISO);

                } else { // bugbug error here?
                    UHCD_KdPrint((1, "'WARNING: Cannot fast-iso this endpoint\n"));

                }
            }
  #endif

            urb->HcdUrbOpenEndpoint.HcdEndpoint = endpoint;
            urb->HcdUrbOpenEndpoint.ScheduleOffset = 0;

            numTDs =
                endpoint->TDCount = UHCD_GetNumTDsPerEndoint((UCHAR) (USB_ENDPOINT_TYPE_MASK &
                        urb->HcdUrbOpenEndpoint.EndpointDescriptor->bmAttributes));

            UHCD_ASSERT(TD_LIST_SIZE(numTDs) <= UHCD_LARGE_COMMON_BUFFER_SIZE);

            if (endpoint->EndpointFlags & EPFLAG_DBL_BUFFER) {
                // do the double buffer init
                ntStatus = UHCD_InitializeNoDMAEndpoint(DeviceObject,
                                                        endpoint);
            }

            if (NT_SUCCESS(ntStatus)) {

                endpoint->MaxRequests =
                    MAX_REQUESTS(urb->HcdUrbOpenEndpoint.EndpointDescriptor,
                                 endpoint->EndpointFlags);

                UHCD_KdPrint((2, "'MaxRequests = %d\n", endpoint->MaxRequests));

                // init transfer sequence numbers
                endpoint->NextXferId = 0;
                endpoint->CurrentXferId = 0;

                if (endpoint->EndpointFlags & EPFLAG_FAST_ISO) {
                    // do the double buffer init
                    UHCD_KdPrint((1, "'Using Fast ISO for Endpoint\n"));

                    ntStatus = UHCD_FinishInitializeEndpoint(DeviceObject,
                                                             endpoint,
                                                             urb->HcdUrbOpenEndpoint.EndpointDescriptor,
                                                             urb);

                    if (NT_SUCCESS(ntStatus)) {
                        ntStatus = UHCD_InitializeFastIsoEndpoint(DeviceObject,
                                                                  endpoint);
                    }
                } else {

                    for (cnt=0; cnt< endpoint->MaxRequests; cnt++) {

                        if ((UHCD_AllocateHardwareDescriptors(DeviceObject,
                                                              &endpoint->HardwareDescriptorList[cnt],
                                                              endpoint->TDCount))) {
                                PUCHAR descriptors;
                                ULONG i;

                                descriptors = endpoint->HardwareDescriptorList[cnt]->MemoryDescriptor->VirtualAddress;

                                // Initialize the queue head for this endpoint
                                // use the TD on the first list
                                if (cnt == 0) {

                                    endpoint->QueueHead = (PHW_QUEUE_HEAD) descriptors;

                                    // save our endpoint in the QueueHead

                                    endpoint->QueueHead->Endpoint = endpoint;
                                }

                                //
                                // the TDs we'll need to service this endpoint
                                //

                                endpoint->SlotTDList[cnt] = (PUHCD_TD_LIST) (descriptors + sizeof(HW_QUEUE_HEAD));

                                // BUGBUG possibly move this to allocate TD code
                                for (i=0; i<= endpoint->TDCount; i++) {
                                    // one time init stuff
                                    // for isoch TDs.

                                    endpoint->SlotTDList[cnt]->TDs[i].Frame = 0;
                                    endpoint->SlotTDList[cnt]->TDs[i].Urb = NULL;
                                }

                        } else {

                            RETHEAP(endpoint);
                            endpoint = NULL;
                            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }
                    }  // for

                    // point to first list
                    if (endpoint) {
                        endpoint->TDList = endpoint->SlotTDList[0];
                    }
                }
            }

        } else {
            // failed to alloc endpoint structure
            UHCD_KdTrap(("UHCD failed to alloc endpoint structure\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

#if DBG
        UHCD_KdPrint((2, "'Open Endpoint, max transfer size  0x%x \n",
                      urb->HcdUrbOpenEndpoint.MaxTransferSize));
//        transfers >64k are valid

//        if (urb->HcdUrbOpenEndpoint.MaxTransferSize >
//            1024*64) {
//            // bigger than 64k, probably a bug.
//            UHCD_KdPrint((2, "'Open Endpoint, max transfer size  0x%x \n",
//                urb->HcdUrbOpenEndpoint.MaxTransferSize));
//            TEST_TRAP();
//        }
#endif

        if (NT_SUCCESS(ntStatus)) {
            //
            // take the opportunity to grow our pool
            // in necessary
            //
            // BUGBUG possibly use max_packet size as a hint
            UHCD_MoreCommonBuffers(DeviceObject);

            URB_HEADER(urb).Status = UHCD_STATUS_PENDING_STARTIO;
            ntStatus = STATUS_PENDING;
            UHCD_KdPrint((2, "'Queue Irp To StartIo\n"));

            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            IoMarkIrpPending(Irp);



            IoStartPacket(DeviceObject,
                          Irp,
                          0,
                          UHCD_StartIoCancel);
        } else {
            URB_HEADER(urb).Status = USBD_STATUS_NO_MEMORY;
            UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
        }
        break;


    case URB_FUNCTION_CONTROL_TRANSFER:
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
        // this will activate the rolover interrupts
        deviceExtension->XferIdleTime = 0;

    case URB_FUNCTION_HCD_CLOSE_ENDPOINT:


        if (URB_HEADER(urb).Function == URB_FUNCTION_HCD_CLOSE_ENDPOINT) {
            endpoint = urb->HcdUrbCloseEndpoint.HcdEndpoint;
            ASSERT_ENDPOINT(endpoint);
        } else {
//#if DBG
//            UHCD_KdPrint((2, "'originalTransfer Buffer = 0x%x \n",
//                urb->HcdUrbCommonTransfer.TransferBuffer));
//            // Trash the TransferBuffer field - we only use MDLs
//            urb->HcdUrbCommonTransfer.TransferBuffer = (PVOID)-1;
//#endif
            // allocate some working space and attach it to
            // this urb

            endpoint = HCD_AREA(urb).HcdEndpoint;
            ASSERT_ENDPOINT(endpoint);

            if (urb->HcdUrbCommonTransfer.TransferBufferLength >
                endpoint->MaxTransferSize) {
                ntStatus = STATUS_INVALID_PARAMETER;
                URB_HEADER(urb).Status = USBD_STATUS_INVALID_PARAMETER;
                UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
                break;
            }

            siz = COMPUTE_HCD_EXTENSION_SIZE(urb);

            HCD_AREA(urb).HcdExtension =
                GETHEAP(NonPagedPool, siz);

            if (HCD_AREA(urb).HcdExtension == NULL) {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                URB_HEADER(urb).Status = USBD_STATUS_NO_MEMORY;
                UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
                break;
            }

            RtlZeroMemory(HCD_AREA(urb).HcdExtension, siz);
        }

#ifdef ROOT_HUB

        if (endpoint->EndpointFlags & EPFLAG_ROOT_HUB) {
            // These routines will either complete
            // the irp or mark it pending.
            switch (URB_HEADER(urb).Function) {
            case URB_FUNCTION_CONTROL_TRANSFER:
                ntStatus = UHCD_RootHub_ControlTransfer(DeviceObject,
                                                        Irp,
                                                        urb);

                // note: URB and IRP may be gone
                break;
            case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
                ntStatus = UHCD_RootHub_InterruptTransfer(DeviceObject,
                                                          Irp,
                                                          urb);
                // note: URB and IRP may be gone
                break;
            case URB_FUNCTION_HCD_CLOSE_ENDPOINT:
                ntStatus = UHCD_RootHub_CloseEndpoint(DeviceObject,
                                                      Irp,
                                                      urb);
                break;
            default:
                //BUGBUG could just complete it with an error
                //here
                // this is probably a bug in the hub driver
                UHCD_KdTrap(("Bogus transfer request to root hub\n"));
            }
            break;
        }
#endif
        URB_HEADER(urb).Status = UHCD_STATUS_PENDING_STARTIO;
        ntStatus = STATUS_PENDING;
        UHCD_KdPrint((2, "'Queue Irp To StartIo\n"));

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        IoMarkIrpPending(Irp);

        IoStartPacket(DeviceObject,
                      Irp,
                      0,
                      UHCD_StartIoCancel);

        break;

    case URB_FUNCTION_ISOCH_TRANSFER:

        //
        // validate max transfer size

        // this will activate the rollover interrupts
        UHCD_WakeIdle(DeviceObject);

        endpoint = HCD_AREA(urb).HcdEndpoint;
        ASSERT_ENDPOINT(endpoint);
        // don't ref TDList
        endpoint->TDList = (PVOID) -1;

        if (urb->HcdUrbCommonTransfer.TransferBufferLength >
            endpoint->MaxTransferSize) {
            ntStatus = STATUS_INVALID_PARAMETER;
            URB_HEADER(urb).Status = USBD_STATUS_INVALID_PARAMETER;
            UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
            break;
        }

        // allocate some working space and attach it to
        // this urb

        siz = COMPUTE_HCD_EXTENSION_SIZE(urb);

        HCD_AREA(urb).HcdExtension =
            GETHEAP(NonPagedPool, siz);

        if (HCD_AREA(urb).HcdExtension == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            URB_HEADER(urb).Status = USBD_STATUS_NO_MEMORY;
            UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
            break;
        }

        RtlZeroMemory(HCD_AREA(urb).HcdExtension, siz);

        if (HCD_AREA(urb).HcdExtension == NULL) {
            UHCD_KdBreak((2, "'Unable to allocate working space for isoch transfer\n"));
            URB_HEADER(urb).Status = USBD_STATUS_NO_MEMORY;
            UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
            break;
        }

        URB_HEADER(urb).Status = UHCD_STATUS_PENDING_STARTIO;
        ntStatus = STATUS_PENDING;
        UHCD_KdPrint((2, "'Queue Irp To StartIo\n"));

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        IoMarkIrpPending(Irp);
#if DBG
        {
            UHCD_KdPrint((2, "'cf = %x",
                UHCD_GetCurrentFrame(DeviceObject)));
        }
#endif


        if (endpoint->EndpointFlags & EPFLAG_FAST_ISO) {
            KIRQL irql;

            KeRaiseIrql(DISPATCH_LEVEL, &irql);
            UHCD_Transfer_StartIo(DeviceObject, Irp);
            KeLowerIrql(irql);

        } else {
        IoStartPacket(DeviceObject,
                      Irp,
                      0,
                      UHCD_StartIoCancel);
        }
        break;

    case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
        // this will activate the rollover interrupts
        UHCD_WakeIdle(DeviceObject);

        urb->UrbGetCurrentFrameNumber.FrameNumber =
            UHCD_GetCurrentFrame(DeviceObject);
        LOGENTRY(LOG_MISC, 'gcfR',
            Irp, urb, urb->UrbGetCurrentFrameNumber.FrameNumber);
        URB_HEADER(urb).Status = USBD_STATUS_SUCCESS;
        UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
        break;

    case URB_FUNCTION_HCD_GET_ENDPOINT_STATE:
    case URB_FUNCTION_HCD_SET_ENDPOINT_STATE:

        URB_HEADER(urb).Status = UHCD_STATUS_PENDING_STARTIO;
        ntStatus = STATUS_PENDING;
        UHCD_KdPrint((2, "'Queue Irp To StartIo\n"));

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        IoMarkIrpPending(Irp);

        IoStartPacket(DeviceObject,
                      Irp,
                      0,
                      UHCD_StartIoCancel);
        break;

    case URB_FUNCTION_HCD_ABORT_ENDPOINT:

        endpoint = urb->HcdUrbAbortEndpoint.HcdEndpoint;

        ASSERT_ENDPOINT(endpoint);

        //
        // Mark the endpoint so that we abort all the transfers the
        // next time we process it.
        //

        SET_EPFLAG(endpoint,
                   EPFLAG_ABORT_PENDING_TRANSFERS | EPFLAG_ABORT_ACTIVE_TRANSFERS);

        URB_HEADER(urb).Status = UHCD_STATUS_PENDING_STARTIO;
        ntStatus = STATUS_PENDING;
        UHCD_KdPrint((2, "'Queue Irp To StartIo\n"));

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        IoMarkIrpPending(Irp);

        IoStartPacket(DeviceObject,
                      Irp,
                      0,
                      UHCD_StartIoCancel);
        break;

     case URB_FUNCTION_SET_FRAME_LENGTH:
        {
        CHAR sofModify;

        //get the current value

        sofModify = (CHAR) (READ_PORT_UCHAR(SOF_MODIFY_REG(deviceExtension)));
        sofModify += (CHAR) urb->UrbSetFrameLength.FrameLengthDelta;
        WRITE_PORT_UCHAR(SOF_MODIFY_REG(deviceExtension),  (UCHAR) sofModify);

        URB_HEADER(urb).Status = USBD_STATUS_SUCCESS;
        UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
        UHCD_KdPrint((2, "'Irp Completed in dispatch\n"));
        }
        break;

     case URB_FUNCTION_GET_FRAME_LENGTH:
        {
        CHAR sofModify;

        //get the current value

        sofModify = (CHAR) (READ_PORT_UCHAR(SOF_MODIFY_REG(deviceExtension)));
        urb->UrbGetFrameLength.FrameNumber = UHCD_GetCurrentFrame(DeviceObject);
        urb->UrbGetFrameLength.FrameLength = UHCD_12MHZ_SOF + sofModify;


        URB_HEADER(urb).Status = USBD_STATUS_SUCCESS;
        UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
        UHCD_KdPrint((2, "'Irp Completed in dispatch\n"));
        }
        break;

    default:
        UHCD_KdPrint((2, "'UHCD_URB_Dispatch -- invalid URB function (%x)\n",
            URB_HEADER(urb).Function));
        URB_HEADER(urb).Status = USBD_STATUS_INVALID_URB_FUNCTION;
        ntStatus = STATUS_INVALID_PARAMETER;
        UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);
    }

    UHCD_KdPrint((2, "'exit UHCD_URB_Dispatch (%x)\n", ntStatus));

    return ntStatus;
}


VOID
UHCD_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Process URBs from the startIo routine.

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:


--*/
{
    PHCD_URB urb;
    KIRQL irql;

    UHCD_KdPrint((2, "'enter UHCD_StartIo\n"));

    //
    // see if the Irp was canceled
    //

    urb = URB_FROM_IRP(Irp);

    IoAcquireCancelSpinLock(&irql);

    IoSetCancelRoutine(Irp, NULL);

    if (Irp->Cancel) {
        TEST_TRAP();

        Irp->IoStatus.Status = STATUS_CANCELLED;

        IoReleaseCancelSpinLock(irql);

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        IoStartNextPacket(DeviceObject, FALSE);

    } else {

        if (UHCD_IS_TRANSFER(urb)) {
            IoSetCancelRoutine(Irp, UHCD_TransferCancel);
        } else {
            IoSetCancelRoutine(Irp, NULL);
        }

        IoReleaseCancelSpinLock(irql);

        switch(URB_HEADER(urb).Function) {
        case URB_FUNCTION_HCD_OPEN_ENDPOINT:
            UHCD_OpenEndpoint_StartIo(DeviceObject, Irp);
            break;

        case URB_FUNCTION_HCD_CLOSE_ENDPOINT:
            LOGENTRY(LOG_MISC, 'CLEP',
                     (PUHCD_ENDPOINT)urb->HcdUrbAbortEndpoint.HcdEndpoint, 0,
                     0);
            UHCD_CloseEndpoint_StartIo(DeviceObject, Irp);
            break;

        case URB_FUNCTION_ISOCH_TRANSFER:
        case URB_FUNCTION_CONTROL_TRANSFER:
        case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
            UHCD_Transfer_StartIo(DeviceObject, Irp);
            break;

        case URB_FUNCTION_HCD_ABORT_ENDPOINT:

            // walk the pending transfer list, since the
            // enpoint is halted no new transfers will
            // be dequeued by EndpointWorker and the only
            // way to clear the HALT is thru
            // GetSetEndpointState_StartIo so it is safe to
            // mess with the list.

            {
                PIRP irp;
                PHCD_URB urbtmp;
                PUHCD_ENDPOINT endpoint;
                PLIST_ENTRY listEntry;
                KIRQL irql;

                endpoint = (PUHCD_ENDPOINT) urb->HcdUrbAbortEndpoint.HcdEndpoint;
                ASSERT_ENDPOINT(endpoint);

                UHCD_KdPrint((2, "'Aborting endpoint %x flags = %x\n",
                    endpoint, endpoint->EndpointFlags));
                LOGENTRY(LOG_MISC, 'ABRP', endpoint, 0, 0);

                LOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'lck4');

                while (!IsListEmpty(&endpoint->PendingTransferList)) {

                    listEntry = RemoveHeadList(&endpoint->PendingTransferList);
                    urbtmp = (PHCD_URB) CONTAINING_RECORD(listEntry,
                                                          struct _URB_HCD_COMMON_TRANSFER,
                                                          hca.HcdListEntry);

                    UNLOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'ulk4');

                    UHCD_KdPrint((2, "'Aborting urb = %x\n", urbtmp));

                    URB_HEADER(urbtmp).Status = USBD_STATUS_CANCELED;

                    //
                    // complete the request
                    //

                    irp =  HCD_AREA(urbtmp).HcdIrp;
                    LOGENTRY(LOG_MISC, 'ABRc', endpoint, irp, 0);

                    UHCD_CompleteIrp(DeviceObject,
                                     irp,
                                     STATUS_CANCELLED,
                                     0,
                                     urbtmp);

                    LOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'lck5');
                }

                UNLOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'ulk5');

                // do cleanup for fast iso
                if (endpoint->EndpointFlags & EPFLAG_FAST_ISO) {
                    ULONG f;

                    for (f=0; f < FRAME_LIST_SIZE; f++) {
                        UHCD_CleanupFastIsoTD(DeviceObject,
                                              endpoint,
                                              f,
                                              FALSE);
                    }
                }

            }

            //
            // we have already set the abortPendingTransfers and
            // abortActiveTransfers flags in the dispatch
            // routine.  Now we need to request an interrupt
            // so that any active transfers will be cleaned
            // up.
            //
            UHCD_RequestInterrupt(DeviceObject, -2);

            IoStartNextPacket(DeviceObject, FALSE);
            URB_HEADER(urb).Status = USBD_STATUS_SUCCESS;
            UHCD_CompleteIrp(DeviceObject, Irp, STATUS_SUCCESS, 0, NULL);

            UHCD_KdPrint((2, "'UHCD Abort Endpoint Request Complete\n"));
            break;

        case URB_FUNCTION_HCD_GET_ENDPOINT_STATE:
        case URB_FUNCTION_HCD_SET_ENDPOINT_STATE:
            UHCD_GetSetEndpointState_StartIo(DeviceObject, Irp);
            break;

        default:
            UHCD_KdPrint((2, "'UHCD_URB_StartIo -- invalid URB function (%x)\n", URB_HEADER(urb).Function));
            URB_HEADER(urb).Status = USBD_STATUS_INVALID_URB_FUNCTION;
            UHCD_CompleteIrp(DeviceObject, Irp, STATUS_SUCCESS, 0, NULL);
        }

    }
    UHCD_KdPrint((2, "'exit UHCD_StartIo\n"));
}


VOID
UHCD_OpenEndpoint_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Create a UHCD endpoint, this function is called from UHCD_StartIo to
    create a new endpoint structure.

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:


--*/
{
    PHCD_URB urb;
    PDEVICE_EXTENSION deviceExtension;
    PUHCD_ENDPOINT endpoint;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor;
    KIRQL irql;
    NTSTATUS ntStatus;
    BOOLEAN haveBW;
    ULONG offset;


    UHCD_KdPrint((2, "'enter UHCD_OpenEndpoint_StartIo\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // extract a pointer to the URB
    //

    urb = URB_FROM_IRP(Irp);

    //
    // make sure the length of the urb is what we expect
    //

    if (urb->HcdUrbOpenEndpoint.Length != sizeof(struct _URB_HCD_OPEN_ENDPOINT)) {
        URB_HEADER(urb).Status = USBD_STATUS_INVALID_PARAMETER;
        ntStatus = STATUS_INVALID_PARAMETER;
        goto UHCD_OpenEndpoint_StartIo_Done;
    }

    //
    // information about the endpoint comes from the USB endpoint
    // descriptor passed in the URB.
    //

    endpointDescriptor = urb->HcdUrbOpenEndpoint.EndpointDescriptor;
    URB_HEADER(urb).Status = USBD_STATUS_SUCCESS;

    //
    // Allocate resources for the endpoint, this includes an endpoint
    // handle that will be passed to us in subsequent transfer requests
    //

    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    endpoint = urb->HcdUrbOpenEndpoint.HcdEndpoint;

    UHCD_ASSERT(endpoint != NULL);
    ASSERT_ENDPOINT(endpoint);

    if (endpoint) {

        //
        // initialize endpoint structures, state variables, queue head, ...
        //

        // bugbug -- may not need to call this for fastIiso
        ntStatus = UHCD_FinishInitializeEndpoint(DeviceObject,
                                                 endpoint,
                                                 endpointDescriptor,
                                                 urb);

        if (!NT_SUCCESS(ntStatus)) {
            RETHEAP(endpoint);
            goto UHCD_OpenEndpoint_StartIo_Done;
        }

        UHCD_KdPrint((2, "'Open Endpoint:\n"));
        UHCD_KdPrint((2, "'Type = (%d) \n", endpoint->Type));
#if DBG
        switch (endpoint->Type) {
        case USB_ENDPOINT_TYPE_CONTROL:
            UHCD_KdPrint((2, "'-control\n"));
            break;
        case USB_ENDPOINT_TYPE_ISOCHRONOUS:
            UHCD_KdPrint((2, "'-iso\n"));
            break;
        case USB_ENDPOINT_TYPE_BULK:
            UHCD_KdPrint((2, "'-bulk\n"));
            break;
        case USB_ENDPOINT_TYPE_INTERRUPT:
            UHCD_KdPrint((2, "'-interrupt\n"));
        }

        if (USB_ENDPOINT_DIRECTION_IN(endpointDescriptor->bEndpointAddress)) {
            UHCD_KdPrint((2, "'IN\n"));
        } else {
            UHCD_KdPrint((2, "'OUT\n"));
        }
#endif
        UHCD_KdPrint((2, "'EP Address = %d\n", endpoint->EndpointAddress));
        UHCD_KdPrint((2, "'DEV Address = %d\n", endpoint->DeviceAddress));
        UHCD_KdPrint((2, "'MaxPacket = %d\n", endpoint->MaxPacketSize));
        UHCD_KdPrint((2, "'Interval: Requested = %d, Selected = %d\n",  endpointDescriptor->bInterval,
                            endpoint->Interval));


        //
        // Now attempt to allocate the bandwidth we'll need to
        // open this endpoint
        //

        if (endpoint->Type == USB_ENDPOINT_TYPE_INTERRUPT) {

            ULONG i;

            // check bw available in all locations and
            // pick the least loaded frame
            offset = 0;
            for (i=0; i< endpoint->Interval; i++) {
                if (deviceExtension->BwTable[i] > deviceExtension->BwTable[offset]) {
                    offset = i;
                }
            }

            haveBW = UHCD_AllocateBandwidth(DeviceObject,
                                            endpoint,
                                            offset);
            if (!haveBW) {
                //
                // could not use the least loaded frame, just grab the
                // first frame we can fit in.
                //
                for (offset=0; offset<endpoint->Interval; offset++) {
                    haveBW = UHCD_AllocateBandwidth(DeviceObject,
                                                endpoint,
                                                offset);
                    if (haveBW) {
                        UHCD_KdPrint((2, "'using offset %d\n", offset));
                        break;
                    }
                }
            }

            urb->HcdUrbOpenEndpoint.ScheduleOffset = offset;

        } else {
            offset = 0;
            haveBW = UHCD_AllocateBandwidth(DeviceObject,
                                            endpoint,
                                            offset);
        }

        if (!haveBW) {   // no offset
            ULONG cnt;
            //
            // insufficient bandwidth to open this
            // endpoint.
            //

            URB_HEADER(urb).Status = USBD_STATUS_NO_BANDWIDTH;
            UHCD_KdPrint((0, "'warning: no bandwidth for endpoint\n"));

            for (cnt=0; cnt< endpoint->MaxRequests; cnt++) {

                UHCD_FreeHardwareDescriptors(DeviceObject,
                    endpoint->HardwareDescriptorList[cnt]);
            }

            RETHEAP(endpoint);

            goto UHCD_OpenEndpoint_StartIo_Done;
        }

        if (endpoint->EndpointFlags & EPFLAG_FAST_ISO) {
            goto UHCD_OpenEndpoint_StartIo_Done;
        }

        //
        // put the endpoint in to our list of active endpoints
        //
        // BUGBUG may want to wait for the first transfer to
        // do this.
        //

        LOCK_ENDPOINT_LIST(deviceExtension, irql);

        if (deviceExtension->EndpointListBusy) {
            // if the endpoint list is busy we have to put the endpoint
            // on a lookaside list so that the ISRDPC can add it later
            InsertHeadList(&deviceExtension->EndpointLookAsideList, &endpoint->ListEntry);
        } else {
            InsertHeadList(&deviceExtension->EndpointList, &endpoint->ListEntry);
        }

        UNLOCK_ENDPOINT_LIST(deviceExtension, irql);

        //
        // Put this Queue Head in the Schedule.
        //

        //
        // This routine will insert the queue head in the proper place
        // in the schedule and add the endpoint to the endpoint list
        // so that completed transfers will be detected.
        //

        KeAcquireSpinLock(&deviceExtension->HcScheduleSpin, &irql);

        UHCD_InsertQueueHeadInSchedule(DeviceObject,
                                       endpoint,
                                       endpoint->QueueHead,
                                       offset); // no offset

        // clear the idle flag just in case it got set
        CLR_EPFLAG(endpoint, EPFLAG_IDLE);

        KeReleaseSpinLock(&deviceExtension->HcScheduleSpin, irql);

        //
        // return the endpoint handle
        //

        urb->HcdUrbOpenEndpoint.HcdEndpoint = endpoint;

        ntStatus = STATUS_SUCCESS;

    } /* if endpoint */

    //
    // Complete the IRP, status is in the status field of the URB
    //

    UHCD_KdPrint((2, "'exit UHCD_OpenEndpoint_StartIo (URB STATUS = %x)\n", URB_HEADER(urb).Status ));

UHCD_OpenEndpoint_StartIo_Done:

#if DBG
    //
    // sanity check our buffer pools
    //
//    UHCD_BufferPoolCheck(DeviceObject);
#endif

    IoStartNextPacket(DeviceObject, FALSE);
    UHCD_CompleteIrp(DeviceObject, Irp, ntStatus, 0, NULL);

    return;
}


VOID
UHCD_CloseEndpoint_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Free a UHCD endpoint, if there are any pending transfers for this
    endpoint this routine should fail.

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:


--*/
{
    PHCD_URB urb;
    PUHCD_ENDPOINT endpoint;
    BOOLEAN outstandingTransfers = FALSE;
    PDEVICE_EXTENSION deviceExtension;
    ULONG i;
    KIRQL irql;
    BOOLEAN removed;

    UHCD_KdPrint((2, "'enter UHCD_CloseEndpoint_StartIo\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    urb = URB_FROM_IRP(Irp);

    endpoint = urb->HcdUrbCloseEndpoint.HcdEndpoint;
    ASSERT_ENDPOINT(endpoint);

    if (endpoint->EndpointFlags & EPFLAG_FAST_ISO) {

        UHCD_UnInitializeFastIsoEndpoint(DeviceObject,
                                         endpoint);

        UHCD_FreeBandwidth(DeviceObject, endpoint, endpoint->Offset);

    }

    //
    // if there are any pending transfers fail this request
    //

    LOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'lck4');

    //
    // Do we have any transfers pending?
    //

    outstandingTransfers = !IsListEmpty(&endpoint->PendingTransferList);

    for (i=0; !outstandingTransfers && i < endpoint->MaxRequests; i++) {

        //
        // no outstanding transfers in the queue, check the active list
        // -- if some transfers get retired while we walk the list that
        //    is OK.
        //

        if (endpoint->ActiveTransfers[i] != NULL) {
            outstandingTransfers = TRUE;
        }
    }

    UNLOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'ulk4');

    if (outstandingTransfers) {

        //
        // If we have outstanding transfers then we fail the
        // request
        //

        URB_HEADER(urb).Status = USBD_STATUS_ERROR_BUSY;

    } else {

        //
        // Remove the endpoint Queue from the schedule
        //

        KeAcquireSpinLock(&deviceExtension->HcScheduleSpin, &irql);

        removed = UHCD_RemoveQueueHeadFromSchedule(DeviceObject,
                                                   endpoint,
                                                   endpoint->QueueHead,
                                                   TRUE);

        KeReleaseSpinLock(&deviceExtension->HcScheduleSpin, irql);

        // stop 'NoDMA' transfers
        if (endpoint->EndpointFlags & EPFLAG_DBL_BUFFER) {
            UHCD_StopNoDMATransfer(DeviceObject,
                                   endpoint);
        }

        //
        // Put the endpoint on a queue to be freed at after
        // the next frame has executed
        //

        // At this point the hardware links have been updated to remove this
        // endpoint.
        //
        // we note the frame when it is safe to retire the endpoint so that
        // the queue head may be freed safely by the ISR DPC routine next time
        // we take an interrupt.
        endpoint->FrameToClose = UHCD_GetCurrentFrame(DeviceObject)+2;

        // BUGBUG this needs to be protected from the ISR DPC
        // routine where these things are actually freed.
        // queue it to be released
        if (removed) {
            InsertTailList(&deviceExtension->ClosedEndpointList, &endpoint->ListEntry);
        }

        URB_HEADER(urb).Status = USBD_STATUS_SUCCESS;
    }

    IoStartNextPacket(DeviceObject, FALSE);
    UHCD_CompleteIrp(DeviceObject, Irp, STATUS_SUCCESS, 0, NULL);


    UHCD_KdPrint((2, "'exit UHCD_CloseEndpoint_StartIo\n"));
}


VOID
UHCD_InsertQueueHeadInSchedule(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHW_QUEUE_HEAD QueueHead,
    IN ULONG Offset
    )
/*++

Routine Description:

    Inserts an initialized queue head into the schedule


    Queue head schedule looks like this:

    PQH = persistant queue head
    CQH = control Queue Head
    IQH = Interrupt Queue Head
    BQH = Bulk Queue Head

    The persistant queue head software links
    look like this:

               |>---->---->-|
               | <-    <-   | prev
              BQH   PQH    CQH
               |  ->    ->  | next
               |<----<----<-|


    IQH->IQH->PQH

    Hardware links look like this:

    PQH->CQH->BQH->|    (reclimaton on)
               |-<-|

         or

    PQH->CQH->BQH->|    (reclimation off)
              |<-T-|  (T BIT SET)



    Iso/Interrupt hardware links:

    ISO->IQH->PQH

Arguments:

    DeviceObject - device object for this controller.

    Endpoint - endpoint this Queue Head belongs to.

    QueueHead - queue head to insert in schedule.

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PHW_QUEUE_HEAD persistantQueueHead, queueHeadForFrame,
        nextQueueHead, prevQueueHead;
#ifdef RECLAIM_BW
    PHW_QUEUE_HEAD firstBulkQueueHead;
#endif
    ULONG i, interval;
    BOOLEAN fixFrameList = FALSE;

    UHCD_ASSERT(!(Endpoint->EndpointFlags & EPFLAG_ED_IN_SCHEDULE));

    UHCD_KdPrint((2, "'enter InsertQueueHeadInSchedule\n"));

    ASSERT_ENDPOINT(Endpoint);
    ASSERT_QUEUE_HEAD(QueueHead);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    persistantQueueHead = deviceExtension->PersistantQueueHead;


    switch(Endpoint->Type) {
    case USB_ENDPOINT_TYPE_CONTROL:
        LOGENTRY(LOG_MISC, 'Cep+', Endpoint, 0, DeviceObject);

        //
        // before
        //
        //   a     b
        //  -PQH<->CQH-
        //  |---<->---|
        //
        // after
        //
        //   a                b
        //  -PQH<->CQH(new)<->CQH-
        //  |-------<->----------|
        //

        // insert in list
        QueueHead->Next = persistantQueueHead->Next;  //point to b
        QueueHead->Prev = persistantQueueHead;        //point to a

        QueueHead->Next->Prev = QueueHead; // item b points back to new

        // PQH points to the new element
        QueueHead->Prev->Next = QueueHead; // item a points to new

        // Fix up hardware links
        QueueHead->HW_HLink = persistantQueueHead->HW_HLink;

        // we are in the chain just after the Persistant Queue Head
        // this line activates the QH
        persistantQueueHead->HW_HLink =
            QueueHead->PhysicalAddress;
        break;

    case USB_ENDPOINT_TYPE_INTERRUPT:
        LOGENTRY(LOG_MISC, 'Iep+', Endpoint, QueueHead, DeviceObject);
        QueueHead->Next = 0;
        QueueHead->Prev = 0;

        interval = Endpoint->Interval;
        UHCD_ASSERT(Offset < interval);

        UHCD_ASSERT(interval != 0);

        LOGENTRY(LOG_MISC, 'Iep+',
                 Endpoint,
                 interval,
                 &deviceExtension->InterruptSchedule[0]);

        // MAX_INTERVAL is the maximum polling interval we support in UHCD (power of 2).
        // the requested polling intervals is always rounded to the next lowest power of 2.

        // We keep an array (InterruptSchedule) of MAX_INTERVAL with the virtual addresses
        // of the queue heads in the schedule. The size of InterruptSchedule is always a
        // multiple of MAX_FRAME. i.e. InterruptSchedule contains the virtual addresses of
        // queue heads for the first MAX_INTERVAL frames in the schedule.

        UHCD_ASSERT(interval<=MAX_INTERVAL);
        UHCD_ASSERT(Offset<interval);
        UHCD_ASSERT(MAX_INTERVAL % interval == 0);

        for (i=Offset; i<MAX_INTERVAL; i+=interval) {
            // select the queue head
            queueHeadForFrame = deviceExtension->InterruptSchedule[i];
            LOGENTRY(LOG_MISC, 'Iqhf',
                      0, //queueHeadForFrame->Endpoint->Interval,
                      queueHeadForFrame,
                      i);

            // find the appropriate place to add ourselves
            if (queueHeadForFrame == persistantQueueHead ||
                interval >= queueHeadForFrame->Endpoint->Interval) {

                // if the first entry is the persistant queue head or our polling
                // interval is greater or equal than this queue head then we just
                // add in front of this one, we become the root node for this
                // frame.

                LOGENTRY(LOG_MISC, 'I>SC', 0, QueueHead, i);
                deviceExtension->InterruptSchedule[i] = QueueHead;
                fixFrameList = TRUE;
                if (QueueHead->Next == 0) {
                    QueueHead->Next = queueHeadForFrame;
                    // update hardware link here
                    QueueHead->HW_HLink =  queueHeadForFrame->PhysicalAddress;
                } else {
                    // ounce the next pointer is updated
                    // it should never change
                    UHCD_ASSERT(QueueHead->Next == queueHeadForFrame);
                }

            } else {
                // if our polling interval is less than the current queue
                // head we need to insert in the proper position

                LOGENTRY(LOG_MISC, 'I<SC', queueHeadForFrame, QueueHead, i);
                nextQueueHead = queueHeadForFrame;
                do {
                    prevQueueHead = nextQueueHead;
                    nextQueueHead = nextQueueHead->Next;

                }  while (nextQueueHead != persistantQueueHead &&
                          nextQueueHead->Endpoint->Interval > interval);

                LOGENTRY(LOG_MISC, 'I<SQ', nextQueueHead,
                    QueueHead, prevQueueHead);
                UHCD_ASSERT(nextQueueHead != 0);

                // link in to the chain

                if (QueueHead->Next == 0) {
                    QueueHead->Next = nextQueueHead;
                      // update hardware link here
                    QueueHead->HW_HLink =  nextQueueHead->PhysicalAddress;
                } else {
                    UHCD_ASSERT(QueueHead->Next == nextQueueHead ||
                                nextQueueHead == QueueHead);
                }

                prevQueueHead->Next = QueueHead;

                // update hardware link here
                prevQueueHead->HW_HLink = QueueHead->PhysicalAddress;

            }

            //
            // repeat the process until we
            // have visited all possible nodes for this queue head
            //

        }

        // now update the physical frame list based on the virtual list
        // if we have modified it.

        if (fixFrameList) {
            UHCD_CopyInterruptScheduleToFrameList(DeviceObject);
        }

        break;

    case USB_ENDPOINT_TYPE_BULK:

        //
        // before
        //
        //  b      a
        //  -BQH<->PQH-
        //  |---<->---|
        //
        // after
        //
        //  b                 a
        //  -BQH<->BQH(new)<->PQH-
        //  |-------<->----------|
        //
        // We need to add this endpoint to the tail of the
        // persistant queue
        //

        LOGENTRY(LOG_MISC, 'Bep+', Endpoint, 0, DeviceObject);

        // set up queue head fields
        UHCD_KdPrint((2, "'bulk QH = %x, %x\n", QueueHead, Endpoint));

        // insert in list
        QueueHead->Next = persistantQueueHead;       // point to a
        QueueHead->Prev = persistantQueueHead->Prev; // point to b

        // first item points back to us
        QueueHead->Prev->Next = QueueHead; // item b points to new
        // head points to the element

        // select the old tail element
        prevQueueHead = persistantQueueHead->Prev; // remember b
        persistantQueueHead->Prev = QueueHead;     // item a points to new

#ifdef RECLAIM_BW

        //
        // Fix up hardware links
        //
        // BUGBUG
        // NOTE: we are only reclaiming bandwidth for bulk right
        // now.
        //

        if (deviceExtension->SteppingVersion == UHCD_B0_STEP) {

            //TEST_TRAP();
            //
            // BW reclimation, point back to the first bulk queue head
            // with no T bit set
            //

            // walk the list and find the first bulk
            // queue head

            firstBulkQueueHead = persistantQueueHead;

            do {
                PUHCD_ENDPOINT endpoint;

                endpoint = firstBulkQueueHead->Endpoint;

                if (endpoint &&
                    endpoint->Type == USB_ENDPOINT_TYPE_BULK) {
                    break;
                }

                firstBulkQueueHead = firstBulkQueueHead->Next;

            } while (firstBulkQueueHead != persistantQueueHead);

            UHCD_ASSERT(firstBulkQueueHead != persistantQueueHead);

            QueueHead->HW_HLink = firstBulkQueueHead->PhysicalAddress;

            deviceExtension->HcFlags |= HCFLAG_BWRECLIMATION_ENABLED;

        } else {
            // Fix up hardware links
            // points to the control queue head with T bit set
            QueueHead->HW_HLink = prevQueueHead->HW_HLink;
            UHCD_ASSERT(QueueHead->HW_HLink & UHCD_CF_TERMINATE);
        }
#else
        // Fix up hardware links
        // points to the control queue head with T bit set
        QueueHead->HW_HLink = prevQueueHead->HW_HLink;
        UHCD_ASSERT(QueueHead->HW_HLink & UHCD_CF_TERMINATE);
#endif

        // we are in the chain just before the PersistantQueueHead
        // this line activates the QH
        prevQueueHead->HW_HLink =
            QueueHead->PhysicalAddress;
        break;

    case USB_ENDPOINT_TYPE_ISOCHRONOUS:

        LOGENTRY(LOG_MISC, 'Sep+', Endpoint, 0, DeviceObject);
        break;

    default:
        // invalid endpoint type, probably a bug
        UHCD_KdTrap(
            ("UHCD_InsertQueueHeadInSchedule inavlid endpoint type\n"));
    }

    SET_EPFLAG(Endpoint, EPFLAG_ED_IN_SCHEDULE);

    UHCD_KdPrint((2, "'exit InsertQueueHeadInSchedule\n"));

    return;
}


BOOLEAN
UHCD_RemoveQueueHeadFromSchedule(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PHW_QUEUE_HEAD QueueHead,
    IN BOOLEAN RemoveFromEPList
    )
/*++

Routine Description:

    Removes a queue head from the schedule

Arguments:

    DeviceObject - device object for this controller.

    Endpoint - endpoint this Queue Head belongs to.

    QueueHead - queue head to remove.

Return Value:

    returns TRUE if EP was removed from ep list

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PHW_QUEUE_HEAD persistantQueueHead, queueHeadForFrame,
        nextQueueHead, prevQueueHead;
    BOOLEAN fixFrameList = FALSE;
    ULONG i;
    HW_DESCRIPTOR_PHYSICAL_ADDRESS physicalAddress;
    KIRQL irql;
    BOOLEAN removed = FALSE;

    UHCD_KdPrint((2, "'enter RemoveQueueHeadFromSchedule\n"));

    ASSERT_ENDPOINT(Endpoint);

    if (Endpoint->EndpointFlags & EPFLAG_FAST_ISO) {
        // nothing to remove
        return FALSE;
    }

    ASSERT_QUEUE_HEAD(QueueHead);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    persistantQueueHead = deviceExtension->PersistantQueueHead;

    //
    // Remove the Queue Head from the endpoint list
    //

    if (RemoveFromEPList) {
        LOCK_ENDPOINT_LIST(deviceExtension, irql);

        if (deviceExtension->EndpointListBusy) {
            // mark the entry so we can remove it later
            SET_EPFLAG(Endpoint, EPFLAG_EP_CLOSED);
        } else {
            RemoveEntryList(&Endpoint->ListEntry);
            removed = TRUE;
        }

        UNLOCK_ENDPOINT_LIST(deviceExtension, irql);
    }

    if (!(Endpoint->EndpointFlags & EPFLAG_ED_IN_SCHEDULE)) {
        LOGENTRY(LOG_MISC, 'NISc', Endpoint, 0, DeviceObject);
        return removed;
    }

    switch(Endpoint->Type) {
    case USB_ENDPOINT_TYPE_CONTROL:
    case USB_ENDPOINT_TYPE_BULK:
        // set up queue head fields

        prevQueueHead = QueueHead->Prev;
        nextQueueHead = QueueHead->Next;

        // unlink software links
        prevQueueHead->Next = QueueHead->Next;
        nextQueueHead->Prev = QueueHead->Prev;

        if ((QueueHead->HW_HLink & UHCD_DESCRIPTOR_PTR_MASK)
                 ==
            (QueueHead->PhysicalAddress & UHCD_DESCRIPTOR_PTR_MASK)) {

            //
            // Queue head points to itself, this means it is
            // the only bulk queue in the list.
            //
            // This will only happen if we have BW reclaimation
            // is enabled.
            //

            physicalAddress =
                deviceExtension->PersistantQueueHead->PhysicalAddress;
            SET_T_BIT(physicalAddress);

            UHCD_ASSERT(physicalAddress & UHCD_CF_QUEUE);
            prevQueueHead->HW_HLink = physicalAddress;

        } else {
            // Fix up hardware link
            prevQueueHead->HW_HLink = QueueHead->HW_HLink;
        }

        break;

    case USB_ENDPOINT_TYPE_INTERRUPT:

        //
        // Brute force method:
        // Walk every frame in the InterruptSchedule and update
        // any node that references this queue head.
        //

        for (i=0; i<MAX_INTERVAL; i++) {
            queueHeadForFrame = deviceExtension->InterruptSchedule[i];

            if (queueHeadForFrame == QueueHead) {
                // Queue Head was root node for this frame
                deviceExtension->InterruptSchedule[i] = QueueHead->Next;
                fixFrameList = TRUE;
            } else {
                while (queueHeadForFrame != persistantQueueHead &&
                       queueHeadForFrame->Endpoint->Interval >=
                            QueueHead->Endpoint->Interval) {
                    if (queueHeadForFrame->Next == QueueHead) {
                        // found a link to our queue head,
                        // remove it
                        queueHeadForFrame->Next = QueueHead->Next;
                        // unlink from Hardware Queue
                        queueHeadForFrame->HW_HLink = QueueHead->HW_HLink;
                    }
                    queueHeadForFrame = queueHeadForFrame->Next;
                }
            }

            if (fixFrameList) {
                UHCD_CopyInterruptScheduleToFrameList(DeviceObject);
            }
        }


        break;

    case USB_ENDPOINT_TYPE_ISOCHRONOUS:

        LOGENTRY(LOG_MISC, 'Sep-', Endpoint, 0, DeviceObject);
        break;
    default:
        // Invalid endpoint type, probably a bug
        UHCD_KdTrap(
            ("UHCD_RemoveQueueHeadFromSchedule inavlid endpoint type\n"));
    }

    CLR_EPFLAG(Endpoint,
               EPFLAG_ED_IN_SCHEDULE);

    UHCD_KdPrint((2, "'exit RemoveQueueHeadFromSchedule\n"));

    return removed;
}


VOID
UHCD_CopyInterruptScheduleToFrameList(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Transfers the virtual interrupt schedule to the frame list

Arguments:

    DeviceObject - device object for this controller.

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    ULONG i;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    for (i=0; i < FRAME_LIST_SIZE; i++) {
        if (i == 0 || i == FRAME_LIST_SIZE-1)
            deviceExtension->TriggerTDList->TDs[i == 0 ? 0 : 1].HW_Link =
                deviceExtension->InterruptSchedule[i % MAX_INTERVAL]->PhysicalAddress;
        else {
            ULONG currentTdCopy, currentTd;
            PUHCD_ENDPOINT endpoint;

            currentTd =
                *( ((PULONG) (deviceExtension->FrameListVirtualAddress)+i));

            currentTdCopy =
                *( ((PULONG) (deviceExtension->FrameListCopyVirtualAddress)+i));

            endpoint = UHCD_GetLastFastIsoEndpoint(DeviceObject);

            // have fast iso?
            if (endpoint) {

                PFAST_ISO_DATA fastIsoData;
                PHW_TRANSFER_DESCRIPTOR transferDescriptor;

                // fast iso TDs are present, we will need to insert
                // the interrupt schedule after these TDs.

                fastIsoData = &endpoint->FastIsoData;
                transferDescriptor = (PHW_TRANSFER_DESCRIPTOR)
                    (fastIsoData->IsoTDListVa + (i*32));

                transferDescriptor->HW_Link =
                    deviceExtension->InterruptSchedule[i % MAX_INTERVAL]->PhysicalAddress;

            } else {
                // no fast iso -- just update the schedule
                *( ((PULONG) (deviceExtension->FrameListCopyVirtualAddress)+i) ) =
                    deviceExtension->InterruptSchedule[i % MAX_INTERVAL]->PhysicalAddress;

                // if the currentTd == the copy then we don't have any iso
                // tds in the schedule so it is safe to update the schedule directly
                if (currentTd == currentTdCopy) {
                    *( ((PULONG) (deviceExtension->FrameListVirtualAddress)+i) ) =
                        deviceExtension->InterruptSchedule[i % MAX_INTERVAL]->PhysicalAddress;
                }
            }
        }
    }
}


VOID
UHCD_StartIoCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PHCD_URB urb;

    //
    // Irp has not been processed by StartIo yet
    //

    LOGENTRY(LOG_MISC, 'sioC', Irp, 0, DeviceObject);

    if (DeviceObject->CurrentIrp == Irp) {

        LOGENTRY(LOG_MISC, 'curI', Irp, 0, DeviceObject);

        IoReleaseCancelSpinLock(Irp->CancelIrql);

    } else {
        LOGENTRY(LOG_MISC, 'Ncur', Irp, 0, DeviceObject);

        if (KeRemoveEntryDeviceQueue(&DeviceObject->DeviceQueue,
                                     &Irp->Tail.Overlay.DeviceQueueEntry)) {
            LOGENTRY(LOG_MISC, 'YDVQ', Irp, 0, DeviceObject);
            TEST_TRAP();

            urb = (PHCD_URB) URB_FROM_IRP(Irp);

            IoReleaseCancelSpinLock(Irp->CancelIrql);

            while (urb) {

                URB_HEADER(urb).Status = USBD_STATUS_CANCELED;

                if (UHCD_IS_TRANSFER(urb)) {
                    urb = urb->HcdUrbCommonTransfer.UrbLink;
                } else {
                    break;
                }

            }

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            USBD_CompleteRequest(Irp,
                                 IO_NO_INCREMENT);

        } else {
            LOGENTRY(LOG_MISC, 'NDVQ', Irp, 0, DeviceObject);
            TEST_TRAP();
            IoReleaseCancelSpinLock(Irp->CancelIrql);
        }

    }
}


VOID
UHCD_GetSetEndpointState_StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Change or report state of an endpoint

Arguments:

    DeviceObject - pointer to a device object

    Irp - pointer to an I/O Request Packet

Return Value:


--*/
{
    PUHCD_ENDPOINT endpoint;
    PHCD_URB urb;
    BOOLEAN outstandingTransfers;
    ULONG i;
    KIRQL irql;

    urb = (PHCD_URB) URB_FROM_IRP(Irp);
    endpoint = (PUHCD_ENDPOINT) urb->HcdUrbEndpointState.HcdEndpoint;

    ASSERT_ENDPOINT(endpoint);

    //
    // Do we have any transfers pending?
    //

    irql = KeGetCurrentIrql();
    LOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'lck5');

    outstandingTransfers = !IsListEmpty(&endpoint->PendingTransferList);

#if DBG
    if (outstandingTransfers) {
        UHCD_KdPrint((2, "'GET_ENDPOINT_STATE ep has pending transfers\n"));
    }
#endif

    for (i=0; !outstandingTransfers && i < endpoint->MaxRequests; i++) {

        //
        // no outstanding transfers in the queue, check the active list
        // -- if some transfers get retired while we walk the list that
        //    is OK.
        //

        if (endpoint->ActiveTransfers[i] != NULL) {
            UHCD_KdPrint((2, "'GETSET_ENDPOINT_STATE ep has active transfers\n"));
            outstandingTransfers = TRUE;
        }
    }

    UNLOCK_ENDPOINT_PENDING_LIST(endpoint, irql, 'ulk5');


    switch (urb->HcdUrbEndpointState.Function) {

    case URB_FUNCTION_HCD_GET_ENDPOINT_STATE:

        urb->HcdUrbEndpointState.HcdEndpointState = 0;

        if (endpoint->EndpointFlags & EPFLAG_HOST_HALTED) {
            UHCD_KdPrint((2, "'GET_ENDPOINT_STATE host halted\n"));
            urb->HcdUrbEndpointState.HcdEndpointState |=
                HCD_ENDPOINT_HALTED;
        }

        if (outstandingTransfers) {
            urb->HcdUrbEndpointState.HcdEndpointState |=
                HCD_ENDPOINT_TRANSFERS_QUEUED;
        }

        URB_HEADER(urb).Status = USBD_STATUS_SUCCESS;
        UHCD_KdPrint((2, "'GET_ENDPOINT_STATE state = %x\n",
            urb->HcdUrbEndpointState.HcdEndpointState));

        break;

    case URB_FUNCTION_HCD_SET_ENDPOINT_STATE:

        if (!outstandingTransfers) {
            LOGENTRY(LOG_MISC, 'cla2', endpoint, 0, 0);
            CLR_EPFLAG(endpoint,
                        EPFLAG_ABORT_PENDING_TRANSFERS |
                        EPFLAG_ABORT_ACTIVE_TRANSFERS);

        }

        UHCD_KdPrint((2, "'Set Enpoint State flags = %x\n", endpoint->EndpointFlags));
        if (endpoint->EndpointFlags & (EPFLAG_ABORT_ACTIVE_TRANSFERS |
                                       EPFLAG_ABORT_PENDING_TRANSFERS)) {
            //fail the request


            IoStartNextPacket(DeviceObject, FALSE);
            // let USBD map the error for us
            URB_HEADER(urb).Status = USBD_STATUS_ERROR_BUSY;
            UHCD_CompleteIrp(DeviceObject, Irp, STATUS_SUCCESS, 0, NULL);

            return;
        }

        if (endpoint->EndpointFlags & EPFLAG_DBL_BUFFER) {
            // stop streaming data

            UHCD_StopNoDMATransfer(DeviceObject,
                                   endpoint);
        }

        //
        // restore virgin status to the pipe
        //

        SET_EPFLAG(endpoint, EPFLAG_VIRGIN);

        //
        // set the data toggle back to 0
        //
        if (urb->HcdUrbEndpointState.HcdEndpointState &
             HCD_ENDPOINT_RESET_DATA_TOGGLE) {
            endpoint->DataToggle = 0;
        }

        if (!(urb->HcdUrbEndpointState.HcdEndpointState & HCD_ENDPOINT_HALTED)) {

            //
            // halt bit cleared, reset the endpoint.
            //
            LOGENTRY(LOG_MISC, 'cla3', endpoint, 0, 0);
            CLR_EPFLAG(endpoint,
                EPFLAG_ABORT_PENDING_TRANSFERS |
                EPFLAG_ABORT_ACTIVE_TRANSFERS |
                EPFLAG_HOST_HALTED);

            //
            // Start any transfers in the pending queue
            //

            if (endpoint->EndpointFlags & EPFLAG_DBL_BUFFER) {
                // transfers will re-start on the next interrupt
                UHCD_RequestInterrupt(DeviceObject, -2);
            } else {
                UHCD_EndpointWorker(DeviceObject, endpoint);
            }
        }

        URB_HEADER(urb).Status = USBD_STATUS_SUCCESS;

        break;

    default:
        // unknown command, probably a bug
        UHCD_KdTrap(("Bogus Endpoint state command\n"));
    }

    IoStartNextPacket(DeviceObject, FALSE);

    UHCD_CompleteIrp(DeviceObject, Irp, STATUS_SUCCESS, 0, NULL);
}


NTSTATUS
UHCD_FinishInitializeEndpoint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUHCD_ENDPOINT Endpoint,
    IN PUSB_ENDPOINT_DESCRIPTOR EndpointDescriptor,
    IN PHCD_URB Urb
    )
/*++

Routine Description:

    Change or report state of an endpoint

Arguments:

    Endpoint - endpoint structure to initilaize

    EndpointDescriptor - pointer to the USB endpoint descriptor
                for this endpoint.

    Urb - urb associated with the open request

Return Value:


--*/
{
    UCHAR tmp;
    ULONG i;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // note that some fields are already initilaized
    ASSERT_ENDPOINT(Endpoint);

    Endpoint->Type = USB_ENDPOINT_TYPE_MASK & EndpointDescriptor->bmAttributes;
    Endpoint->EndpointAddress = EndpointDescriptor->bEndpointAddress;
    Endpoint->MaxPacketSize = EndpointDescriptor->wMaxPacketSize;
    Endpoint->DeviceAddress = (UCHAR) Urb->HcdUrbOpenEndpoint.DeviceAddress;
    Endpoint->LastPacketDataToggle =
        Endpoint->DataToggle = 0;

    Endpoint->Interval = 0;
    Endpoint->IdleTime = 0;

    SET_EPFLAG(Endpoint, EPFLAG_VIRGIN);
    SET_EPFLAG(Endpoint, EPFLAG_INIT);

    Endpoint->MaxTransferSize = Urb->HcdUrbOpenEndpoint.MaxTransferSize;

    // No DMA endpoint ?
#if DBG
    if (Endpoint->EndpointFlags & EPFLAG_DBL_BUFFER) {

        // client idicates that transfers will be mostly short
        // in this case we will turn off short packet detect
        // and double buffer all transfers to reduce the overhead of
        // having to program each transfer to the hardware separately

        UHCD_KdPrint((1, "'Client requesting double buffering EP = %x\n", Endpoint));
    }
#endif


#if DBG
    if (!(Endpoint->EndpointFlags & EPFLAG_ROOT_HUB)) {
         UHCD_ASSERT(Endpoint->TDCount == UHCD_GetNumTDsPerEndoint(Endpoint->Type));
    }
#endif

    if (Urb->HcdUrbOpenEndpoint.HcdEndpointFlags & USBD_EP_FLAG_LOWSPEED) {
        SET_EPFLAG(Endpoint, EPFLAG_LOWSPEED);
    }

    if (Urb->HcdUrbOpenEndpoint.HcdEndpointFlags & USBD_EP_FLAG_NEVERHALT) {
        SET_EPFLAG(Endpoint, EPFLAG_NO_HALT);
    }

    KeInitializeSpinLock(&Endpoint->ActiveListSpin);
    KeInitializeSpinLock(&Endpoint->PendingListSpin);
#if DBG
    Endpoint->AccessPendingList = 0;
    Endpoint->AccessActiveList = 0;
#endif

    UHCD_KdPrint((2, "'MaxRequests = %d\n", Endpoint->MaxRequests));
    UHCD_ASSERT(Endpoint->MaxRequests == MAX_REQUESTS(EndpointDescriptor,
                                                      Endpoint->EndpointFlags));

    // Select the highest interval we support <= the requested interval.
    // note: an interval of zero gets a oeriod of MAX_INTERVAL

    tmp = EndpointDescriptor->bInterval;
    Endpoint->Interval = MAX_INTERVAL;

    if (EndpointDescriptor->bInterval > MAX_INTERVAL ||
        EndpointDescriptor->bInterval == 0) {
        tmp |= MAX_INTERVAL;
    }

    while ((Endpoint->Interval & tmp) == 0) {
        Endpoint->Interval >>= 1;
    }

    //
    // make sure that iso endpoints have an
    // interval of 1
    //

    if (Endpoint->Type == USB_ENDPOINT_TYPE_ISOCHRONOUS) {
        Endpoint->Interval = 1; //iso endpoints have a period of 1
    }

    InitializeListHead(&Endpoint->PendingTransferList);

    for (i=0; i<UHCD_MAX_ACTIVE_TRANSFERS; i++) {
        Endpoint->ActiveTransfers[i] = NULL;
    }

    return ntStatus;
}


USHORT
UHCD_GetNumTDsPerEndoint(
    IN UCHAR EndpointType
    )
/*++

Routine Description:

    Return the number of TDs to use for this endpoint based on type

Arguments:

Return Value:


--*/
{
    // use max TDs always for bulk to get max thru-put regardless
    // of packet size.

    // Historical Note:
    // this is a change from Win98gold and Win98se,
    // originally we only enabled this if MAX_PACKET was 64 to save
    // memory for slower devices -- but vendors bitched about it so
    // now we enable it regardless of packet size.

    if (EndpointType == USB_ENDPOINT_TYPE_ISOCHRONOUS ||
        EndpointType == USB_ENDPOINT_TYPE_BULK) {
        return MAX_TDS_PER_ENDPOINT;
    } else {
        return MIN_TDS_PER_ENDPOINT;
    }

}


VOID
UHCD_BW_Reclimation(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    Turn on/off BW reclimation for the Bulk Queues

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PHW_QUEUE_HEAD persistantQueueHead, firstBulkQueueHead,
        lastBulkQueueHead;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    persistantQueueHead = deviceExtension->PersistantQueueHead;

    if ((deviceExtension->HcFlags & HCFLAG_BWRECLIMATION_ENABLED)
        == Enable) {
        // no state change just return;
        return;
    }

    LOGENTRY(LOG_MISC, 'BRCL', deviceExtension, Enable, DeviceObject);

    //
    // BW reclimation, point back to the first bulk queue head
    // with no T bit set
    //

    // walk the list and find the first bulk
    // queue head

    firstBulkQueueHead = persistantQueueHead;

    do {
        PUHCD_ENDPOINT endpoint;

        endpoint = firstBulkQueueHead->Endpoint;

        if (endpoint &&
            endpoint->Type == USB_ENDPOINT_TYPE_BULK) {
            break;
        }

        firstBulkQueueHead = firstBulkQueueHead->Next;

    } while (firstBulkQueueHead != persistantQueueHead);

    if (firstBulkQueueHead != persistantQueueHead) {
        // no bulk endpoints
        PHW_QUEUE_HEAD next;
        PUHCD_ENDPOINT endpoint;

        lastBulkQueueHead = firstBulkQueueHead;

        do {
            next = lastBulkQueueHead->Next;
            endpoint = next->Endpoint;
            if (endpoint == NULL ||
                endpoint->Type != USB_ENDPOINT_TYPE_BULK) {
                break;
            }
            lastBulkQueueHead = next;
        } while (1);

        if (Enable) {
            //clear the T-bit to enable reclimation
            LOGENTRY(LOG_MISC, 'BRC+', lastBulkQueueHead, 0, DeviceObject);
            CLEAR_T_BIT(lastBulkQueueHead->HW_HLink);
            deviceExtension->HcFlags |= HCFLAG_BWRECLIMATION_ENABLED;
        } else {
            //set the T-bit to disable reclimation
            LOGENTRY(LOG_MISC, 'BRC-', lastBulkQueueHead, 0, DeviceObject);
            SET_T_BIT(lastBulkQueueHead->HW_HLink);
            deviceExtension->HcFlags &= ~HCFLAG_BWRECLIMATION_ENABLED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usb2lib\dbg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros for usbdlib
    
Environment:

    Kernel & user mode

Revision History:

    10-31-00 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

#if DBG

ULONG
_cdecl
USB2LIB_KdPrintX(
    PCH Format,
    ...
    );

#define TEST_TRAP()            LibData.DbgBreak()

#define DBGPRINT(_x_)          USB2LIB_KdPrintX _x_  

#else

#define TEST_TRAP()

#define DBGPRINT(_x_)

#endif /* DBG */

#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usb2lib\usb2lib.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    usb2lib.h

Abstract:

    interface to the usb2 library
    
Environment:

    Kernel & user mode

Revision History:

    10-31-00 : created

--*/

#ifndef   __USB2LIB_H__
#define   __USB2LIB_H__

#define PUSB2LIB_HC_CONTEXT PVOID
#define PUSB2LIB_ENDPOINT_CONTEXT PVOID
#define PUSB2LIB_TT_CONTEXT PVOID

#define Budget_Iso          0
#define Budget_Interrupt    1        

#define Budget_In           0
#define Budget_Out          1

#define Budget_LowSpeed     0
#define Budget_FullSpeed    1
#define Budget_HighSpeed    2

#define SIG_LIB_HC              'chbl'  //lbhc
#define SIG_LIB_TT              'ttbl'  //lbtt
#define SIG_LIB_EP              'pebl'  //lbep    

typedef struct _REBALANCE_LIST {

    PVOID RebalanceContext[0];

} REBALANCE_LIST, *PREBALANCE_LIST;


typedef struct _USB2LIB_BUDGET_PARAMETERS {

    /* input */

    UCHAR TransferType;     // Budget_Iso
    UCHAR Speed;            // Budget_Interrupt
    UCHAR Direction;        // Budget_FullSpeed, Budget_HighSpeed, Budget_LowSpeed
    UCHAR Pad1;             // Round out to dword
    
    ULONG MaxPacket;        // MaxPacketSize

    /* input, output */
    
    // period is specified in frames for FS, LS
    // or microframes for HS, period is set to 
    // the actual period assigned (may be less
    // than requested)
    ULONG Period;

} USB2LIB_BUDGET_PARAMETERS, *PUSB2LIB_BUDGET_PARAMETERS;


#define USBP2LIBFN __stdcall

/* 
    client entry points
*/        

/* 
VOID
USB2LIB_DbgPrint(
    PCH Format,
    PVOID Arg0,
    PVOID Arg1,
    PVOID Arg2,
    PVOID Arg3,
    PVOID Arg4,
    PVOID Arg5
    );

*/

typedef VOID
    (USBP2LIBFN *PUSB2LIB_DBGPRINT) (
        PCHAR,
        int, 
        int,
        int,
        int,
        int,
        int
    );

/* 
VOID
USB2LIB_DbgBreak(
    );

*/

typedef VOID
    (USBP2LIBFN *PUSB2LIB_DBGBREAK) (
    );    



/* LIB interface functions */

VOID
USB2LIB_InitializeLib(
    PULONG HcContextSize,
    PULONG EndpointContextSize,
    PULONG TtContextSize,
    PUSB2LIB_DBGPRINT Usb2LibDbgPrint,
    PUSB2LIB_DBGBREAK Usb2LibDbgBreak
    );

VOID
USB2LIB_InitController(
    PUSB2LIB_HC_CONTEXT HcContext
    );    

VOID
USB2LIB_InitTt(
    PUSB2LIB_HC_CONTEXT HcContext,
    PUSB2LIB_TT_CONTEXT TtContext
    );    

BOOLEAN
USB2LIB_AllocUsb2BusTime(
    PUSB2LIB_HC_CONTEXT HcContext,				// Host Controller Context
    PUSB2LIB_TT_CONTEXT TtContext,				// Transaction Translater Context
    PUSB2LIB_ENDPOINT_CONTEXT EndpointContext,	// Endpoint Context
    PUSB2LIB_BUDGET_PARAMETERS BudgetParameters,	// Budget Parameters
    PVOID RebalanceContext,						// Driver Endpoint Context
    PVOID RebalanceList,						// List of endpoints to be rebalanced
    PULONG  RebalanceListEntries				// Number of endpoints to be rebalanced
    );    

VOID
USB2LIB_FreeUsb2BusTime(
    PUSB2LIB_HC_CONTEXT HcContext,
    PUSB2LIB_TT_CONTEXT TtContext,
    PUSB2LIB_ENDPOINT_CONTEXT EndpointContext,
    PVOID RebalanceList,
    PULONG  RebalanceListEntries
    );    

UCHAR
USB2LIB_GetSMASK(PUSB2LIB_ENDPOINT_CONTEXT Context);

UCHAR
USB2LIB_GetCMASK(PUSB2LIB_ENDPOINT_CONTEXT Context);

UCHAR
USB2LIB_GetStartMicroFrame(PUSB2LIB_ENDPOINT_CONTEXT Context);

UCHAR
USB2LIB_GetStartFrame(PUSB2LIB_ENDPOINT_CONTEXT Context);

UCHAR
USB2LIB_GetPromotedThisTime(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

UCHAR
USB2LIB_GetNewPeriod(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

ULONG
USB2LIB_GetScheduleOffset(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

ULONG
USB2LIB_GetAllocedBusTime(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

PVOID
USB2LIB_GetNextEndpoint(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

// Debug only
PVOID
USB2LIB_GetEndpoint(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

#undef PUSB2LIB_HC_CONTEXT 
#undef PUSB2LIB_ENDPOINT_CONTEXT 
#undef PUSB2LIB_TT_CONTEXT 

#endif /* __USB2LIB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usb2lib\dbg.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug only functions

Environment:

    kernel mode only

Notes:

Revision History:

    10-31-00 : created

--*/

#include "stdarg.h"
#include "stdio.h"

#include "common.h"

#if DBG

ULONG
_cdecl
USB2LIB_KdPrintX(
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function. 

    calls the port driver print function

Arguments:

Return Value:


--*/    
{
    va_list list;
    int i;
    int arg[6];
    
    LibData.DbgPrint("'USB2LIB: ", 0, 0, 0, 0, 0, 0);
    va_start(list, Format);
    for (i=0; i<6; i++) 
        arg[i] = va_arg(list, int);
    
    LibData.DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    
    
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usb2lib\usb2lib.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    usb2lib.c

Abstract:

    interface to usb2lib, usb2 low/full speed scheduling algorithms

Environment:

    kernel or user mode only

Notes:

Revision History:

    10-31-00 : created

--*/

#include "common.h"

USB2LIB_DATA LibData;


VOID
USB2LIB_InitializeLib(
    PULONG HcContextSize,
    PULONG EndpointContextSize,
    PULONG TtContextSize,
    PUSB2LIB_DBGPRINT Usb2LibDbgPrint,
    PUSB2LIB_DBGBREAK Usb2LibDbgBreak
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    *HcContextSize = sizeof(USB2LIB_HC_CONTEXT);
    *TtContextSize = sizeof(USB2LIB_TT_CONTEXT);
    *EndpointContextSize = sizeof(USB2LIB_ENDPOINT_CONTEXT);

    LibData.DbgPrint = Usb2LibDbgPrint;
    LibData.DbgBreak = Usb2LibDbgBreak;
}


VOID
USB2LIB_InitController(
    PUSB2LIB_HC_CONTEXT HcContext
    )
/*++

Routine Description:

    Called at init time for an instance of the USB 2 
    controller

Arguments:

Return Value:

--*/
{
    DBGPRINT(("USB2LIB_InitController %x\n", HcContext));

    HcContext->Sig = SIG_LIB_HC;
    init_hc(&HcContext->Hc);
    init_tt(&HcContext->Hc, &HcContext->DummyTt);  // set up dummy TT for use by HS endpoints
}


VOID
USB2LIB_InitTt(
    PUSB2LIB_HC_CONTEXT HcContext,
    PUSB2LIB_TT_CONTEXT TtContext
    )
/*++

Routine Description:


Arguments:

Return Value:

--*/
{
    DBGPRINT(("USB2LIB_InitTt %x %x\n", HcContext, TtContext));
    
    TtContext->Sig = SIG_LIB_TT;
    init_tt(&HcContext->Hc, &TtContext->Tt);
}


#if  1
void Shift_to_list_end(
	int			move_ep,
	PEndpoint	RebalanceList[]
	)
{
//	int i;
	PEndpoint ep = RebalanceList[move_ep];

	move_ep++;
	while (RebalanceList[move_ep])
	{
		RebalanceList[move_ep-1] = RebalanceList[move_ep];
		move_ep++;
	}
	RebalanceList[move_ep-1] = ep;
}
#endif




BOOLEAN 
Promote_endpoint_periods(
	PEndpoint	ep,
    PEndpoint	RebalanceList[],
    PULONG		RebalanceListEntries
	)
{
	int unwind = 0, check_ep;
	unsigned result;

	if ((ep->actual_period != 1) && (ep->ep_type == interrupt) && (ep->start_microframe > 2))
	{
    	DBGPRINT((">Period Promotion of allocated endpoint\n"));

	// To promote an endpoint period:
	// 0) unwind = false
	// 1) deallocate original endpoint
	// 2) change new ep period to 1
	// 3) (re)allocate new endpoint (with new period 1)
	// 4) if successful
	// 5)	check endpoints in change list for need of period promotion
	// 6)		deallocate endpoint, move to end of change list, change period to 1, reallocate
	// 7)		if unsuccessful
	// 8)			unwind = true; break
	// 9)		next ep
	//10)	if unwind
	//11)		deallocate orginal ep
	//12)		check change list for promotion endpoint(s)
	//13)			if promoted ep
	//14)				deallocate ep, change back to original period, allocate
	//15)			next ep
	//16)		return false
	//17)	else return true
	//18) else return false

	/*
	//  On return, change list will have promoted endpoints in order of reallocation, but it is possible
	//	to have other endpoints interspersed with the promoted endpoints.  The corresponding schedule of endpoints
	//	must be adjusted to match the order of the promoted endpoints (since they are reinserted into the budget).
	//	The promoted endpoints (except the original endpoint) are moved to the end of the change list as the
	//	promotion reallocations are done to ensure that they are in the change list in the order of insertion
	//	into the budget.  This allows the scheduler to derive the new schedule/budget order from the order the
	//	promoted endpoints appear in the change list.
	//
	//	This algorithm (critically) depends on the Allocate/Deallocate "appending"/reusing an existing change list
	//	as the "final" change list is composed during the period promotion processing is performed.
	*/

	    Deallocate_time_for_endpoint(ep, 
	                                 RebalanceList, 
	                                 RebalanceListEntries);    

		ep->saved_period = ep->period;
		ep->period = 1;

		// 3) (re)allocate new endpoint (with new period 1)
	    result = Allocate_time_for_endpoint(ep, 
	                                        RebalanceList, 
	                                        RebalanceListEntries);
		if (!result) {
			ep->period = ep->saved_period;
			ep->saved_period = 0;
			ep->promoted_this_time = 0;
			return 0;  // failed period promotion of original endpoint
		}
	}

	check_ep = 0;
	while (RebalanceList[check_ep])
	{
		RebalanceList[check_ep]->promoted_this_time = 0;
		check_ep++;
	}

	check_ep = 0;
	while (RebalanceList[check_ep])
	{
		if ((RebalanceList[check_ep]->actual_period != 1) &&
			(RebalanceList[check_ep]->ep_type == interrupt) &&
			(RebalanceList[check_ep]->start_microframe > 2))
		{

	// 6)		deallocate endpoint, move to end of change list, change period to 1, reallocate

    		DBGPRINT((">Period Promoting endpoint\n"));

			Deallocate_time_for_endpoint(
				RebalanceList[check_ep], 
                RebalanceList, 
                RebalanceListEntries);

			// Shift_to_list_end(check_ep, RebalanceList);

			RebalanceList[check_ep]->promoted_this_time = 1;

			RebalanceList[check_ep]->saved_period = RebalanceList[check_ep]->period;
			RebalanceList[check_ep]->period = 1;

			result = Allocate_time_for_endpoint(
					RebalanceList[check_ep], 
                    RebalanceList, 
                    RebalanceListEntries);
			if (!result)
			{
				unwind = 1;
				break;
			}
		}
		check_ep++;
	}

	if (unwind)
	{

    	DBGPRINT((">Unwinding Promoted endpoints\n"));

	//11)		deallocate orginal ep
		Deallocate_time_for_endpoint(
			ep, 
	        RebalanceList, 
               RebalanceListEntries);    

		ep->period = ep->saved_period;
		ep->saved_period = 0;

	//12)		check change list for promotion endpoint(s)

		check_ep = 0;

		while (RebalanceList[check_ep])
		{

	//13)			if promoted ep

			if (RebalanceList[check_ep]->promoted_this_time)
			{

	//14)				deallocate ep, change back to original period, allocate

    	DBGPRINT((">Reallocating Unpromoted endpoint\n"));

				if(RebalanceList[check_ep]->calc_bus_time != 0)
					Deallocate_time_for_endpoint(
						RebalanceList[check_ep], 
						RebalanceList, 
						RebalanceListEntries);

				RebalanceList[check_ep]->period = RebalanceList[check_ep]->saved_period;
				RebalanceList[check_ep]->saved_period = 0;
					
				// Leave the promoted flag set since order could have changed.
				// schedule must be reconciled accordingly by the HC code.
				//RebalanceList[check_ep]->promoted_this_time = 0;

				result = Allocate_time_for_endpoint(
					RebalanceList[check_ep], 
					RebalanceList, 
					RebalanceListEntries);
			}
			check_ep++;
		}

		return 0;
	} else {
		return 1;
	}

}



BOOLEAN
USB2LIB_AllocUsb2BusTime(
    PUSB2LIB_HC_CONTEXT HcContext,
    PUSB2LIB_TT_CONTEXT TtContext,
    PUSB2LIB_ENDPOINT_CONTEXT EndpointContext,
    PUSB2LIB_BUDGET_PARAMETERS Budget,
    PVOID RebalanceContext,
    PVOID RebalanceList,
    PULONG  RebalanceListEntries
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    eptype endpointType;
    unsigned direction, speed;
    //PEndpoint changed_ep_list[];
    unsigned result;
    //unsigned changed_eps;
    PEndpoint ep;
    BOOLEAN alloced;
    ULONG ilop;
    PREBALANCE_LIST rbl;
    PTT tt;
    
    ep = &EndpointContext->Ep; 
    EndpointContext->Sig = SIG_LIB_EP;
    EndpointContext->RebalanceContext = RebalanceContext;

    //changed_ep_list = RebalanceList; 

    switch (Budget->TransferType) {
    case Budget_Iso:
        DBGPRINT((">Iso \n"));
        endpointType = isoch;
        break;
    case Budget_Interrupt:        
        DBGPRINT((">Interrupt \n"));
        endpointType = interrupt;
        break;
    default:
        TEST_TRAP();
    }

    if (Budget->Direction == Budget_In) {
        DBGPRINT((">In \n"));
        direction = INDIR;
    } else {
        DBGPRINT((">Out \n"));
        direction = OUTDIR;
    }

    switch (Budget->Speed) {
    case Budget_FullSpeed:
        DBGPRINT((">FullSpeed \n"));
        speed = FSSPEED;
        tt = &TtContext->Tt;
        break;
    case Budget_HighSpeed:
        DBGPRINT((">HighSpeed \n"));
        speed = HSSPEED;
        tt = &HcContext->DummyTt;	// set endpoint to dummy TT so HC can be reached
        break;        
    case Budget_LowSpeed:
        DBGPRINT((">LowSpeed \n"));
        speed = LSSPEED;
        tt = &TtContext->Tt;
        break;          
    default:
    	DBGPRINT(("BAD SPEED\n"));
    }

    DBGPRINT((">Period %d\n", Budget->Period));

	if(Budget->Speed == Budget_HighSpeed) {
		// This value should be a power of 2, so we don't have to check
		// but limit its value to MAXFRAMES * 8
		if(Budget->Period > MAXMICROFRAMES) {
			Budget->Period = MAXMICROFRAMES;
		}
	} else {
		// We are full / low speed endpoint
		//
		// Round down the period to the nearest power of two (if it isn't already)
		//
		for(ilop = MAXFRAMES; ilop >= 1; ilop = ilop >> 1) {
			if(Budget->Period >= ilop) {
				break;
			}
		}
		Budget->Period = ilop;
	}

    DBGPRINT((">MaxPacket %d\n", Budget->MaxPacket));
    DBGPRINT((">Converted Period %d\n", Budget->Period));
    DBGPRINT((">RebalanceListEntries %d\n", *RebalanceListEntries));

    Set_endpoint(
        ep,
        endpointType,
        direction,
        speed, 
        Budget->Period,            
        Budget->MaxPacket,
        tt);

    // ask John Garney to do the math 
    DBGPRINT((">alloc (ep) %x \n", ep));
    result = Allocate_time_for_endpoint(ep, 
                                        RebalanceList, 
                                        RebalanceListEntries);        

	// check if successful, period != 1, interrupt, and "late" in frame,
	//   then need to promote period to 1
   	// DBGPRINT((">Executing Promote_endpoint_periods (ep) %x \n", ep));
	if (result)
	{
		result = Promote_endpoint_periods(ep, 
	                                      RebalanceList,
										  RebalanceListEntries);
	}

    // nonzero indicates success
    if (result) {
        // set return parameters
        DBGPRINT((">Results\n"));
        DBGPRINT((">num_starts %d \n", ep->num_starts));
        DBGPRINT((">num_completes %d \n", ep->num_completes));
        DBGPRINT((">start_microframe %d \n", ep->start_microframe));
        // this is the schedule offset 
        DBGPRINT((">start_frame %d \n", ep->start_frame));
        // period awarded, may be less than requested
        DBGPRINT((">actual_period %d \n", ep->actual_period));
        DBGPRINT((">start_time %d \n", ep->start_time));
        DBGPRINT((">calc_bus_time %d \n", ep->calc_bus_time));
        DBGPRINT((">promoted_this_time %d \n", ep->promoted_this_time));
         
        alloced = TRUE;
    } else {
        alloced = FALSE;
    }

    // fix up rebalance list
    rbl = RebalanceList;
	ilop = 0;
    while (rbl->RebalanceContext[ilop]) {
        PUSB2LIB_ENDPOINT_CONTEXT endpointContext;
        DBGPRINT((">rb[%d] %x\n", ilop, rbl->RebalanceContext[ilop]));
        endpointContext = CONTAINING_RECORD(rbl->RebalanceContext[ilop],
                                            struct _USB2LIB_ENDPOINT_CONTEXT, 
                                            Ep);    
        rbl->RebalanceContext[ilop] = endpointContext->RebalanceContext;
		ilop++;
    }

    DBGPRINT((">Change List Size =  %d RBE = %d\n", ilop, *RebalanceListEntries));

    *RebalanceListEntries = ilop;
    return alloced;
}


VOID
USB2LIB_FreeUsb2BusTime(
    PUSB2LIB_HC_CONTEXT HcContext,
    PUSB2LIB_TT_CONTEXT TtContext,
    PUSB2LIB_ENDPOINT_CONTEXT EndpointContext,
    PVOID RebalanceList,
    PULONG  RebalanceListEntries
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    unsigned result;
    PEndpoint ep;
    PREBALANCE_LIST rbl;
    ULONG i;

//    ASSERT(EndpointContext->Sig == SIG_LIB_EP);
    ep = &EndpointContext->Ep; 

    DBGPRINT((">dealloc ep Context = 0x%x (ep) %x \n", EndpointContext, ep));
    DBGPRINT((">RebalanceListEntries  %d \n", *RebalanceListEntries));
        
    Deallocate_time_for_endpoint(ep, 
                                 RebalanceList, 
                                 RebalanceListEntries);    

    // fix up rebalance list
    rbl = RebalanceList;
	i = 0;
    while (rbl->RebalanceContext[i]) {
        PUSB2LIB_ENDPOINT_CONTEXT endpointContext;
        
        DBGPRINT((">rb[%d] %x\n", i, rbl->RebalanceContext[i]));
        endpointContext = CONTAINING_RECORD(rbl->RebalanceContext[i],
                                            struct _USB2LIB_ENDPOINT_CONTEXT, 
                                            Ep);  
        rbl->RebalanceContext[i] = endpointContext->RebalanceContext;                                            
		i++;
    }                                 
    DBGPRINT((">Change List Size =  %d RBE = %d\n", i, *RebalanceListEntries));

    *RebalanceListEntries = i;
}

VOID 
ConvertBtoHFrame(UCHAR BFrame, UCHAR BUFrame, PUCHAR HFrame, PUCHAR HUFrame)
{
	// The budgeter returns funky values that we have to convert to something
	// that the host controller understands.
	// If bus micro frame is -1, that means that the start split is scheduled 
	// in the last microframe of the previous bus frame.
	// to convert to hframes, you simply change the microframe to 0 and 
	// keep the bus frame (see one of the tables in the host controller spec 
	// eg 4-17.
	if(BUFrame == 0xFF) {
		*HUFrame = 0;
		*HFrame = BFrame;
	}
		
	// if the budgeter returns a value in the range from 0-6
	// we simply add one to the bus micro frame to get the host 
	// microframe
	if(BUFrame >= 0 && BUFrame <= 6) {
		*HUFrame = BUFrame + 1;
		*HFrame = BFrame;
	}

	// if the budgeter returns a value of 7 for the bframe
	// then the HUframe = 0 and the HUframe = buframe +1
	if(BUFrame == 7) {
		*HUFrame = 0;
		*HFrame = BFrame + 1;
	}
}

UCHAR
USB2LIB_GetSMASK(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
	PEndpoint 	Ep;
	UCHAR 		tmp = 0;

    Ep = &EndpointContext->Ep; 
  //  ASSERT(EndpointContext->Sig == SIG_LIB_EP);

	if(Ep->speed == HSSPEED) {
//DBGPRINT(("in GetSMASK StartUFrame on High Speed Endpoint = 0x%x\n", Ep->start_microframe));
	 	tmp |= 1 << Ep->start_microframe;
	} else {
		ULONG 		ilop;
		UCHAR 		HFrame; 		// H (Host) frame for endpoint
		UCHAR 		HUFrame;		// H (Host) micro frame for endpoint
		// For Full and Low Speed Endpoints 
		// the budgeter returns a bframe. Convert to HUFrame to get SMASK
		ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe, &HFrame, &HUFrame);

		for(ilop = 0; ilop < Ep->num_starts; ilop++) {
		 	tmp |= 1 << HUFrame++;
		}
	}

	return tmp;
}

// 
// I'm too brain dead to calculate this so just do table lookup
//
// Calculated by 1 << Start H Frame + 2. If Start H Frame + 2 > 7 wrap the bits 
// to the lower part of the word
// eg. hframe 0 +2 means cmask in frames 2,3,4 ==> cmask 0x1c
// eg. hframe 5 + 2 means cmasks in frames 7, 8, 9 which means cmask 0x83
#define SIZE_OF_CMASK 8
static UCHAR CMASKS [SIZE_OF_CMASK] = 
{		0x1c, 		// Start HUFRAME 0  
		0x38,		// Start HUFRAME 1
		0x70,		// Start HUFRAME 2
		0xE0,		// Start HUFRAME 3
		0xC1,		// Start HUFRAME 4
		0x83,		// Start HUFRAME 5
		0x07,		// Start HUFRAME 6
		0x0E,		// Start HUFRAME 7
};


UCHAR
USB2LIB_GetCMASK(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
	PEndpoint Ep;

   	Ep = &EndpointContext->Ep; 
//    ASSERT(EndpointContext->Sig == SIG_LIB_EP);

	if(Ep->speed == HSSPEED) {
		return 0;
	} else if(Ep->ep_type == interrupt) {
		UCHAR 		HFrame; 		// H (Host) frame for endpoint
		UCHAR 		HUFrame;		// H (Host) micro frame for endpoint

		ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe, 
			&HFrame, &HUFrame);

		return CMASKS[HUFrame];
	} else {
		// Split ISO!
		UCHAR 		HFrame; 		// H (Host) frame for endpoint
		UCHAR 		HUFrame;		// H (Host) micro frame for endpoint
		UCHAR 		tmp;
		ULONG 		NumCompletes;

		if(Ep->direction == OUTDIR) {
			// Split iso out -- NO complete splits
			return 0;
		}
		ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe, 
			&HFrame, &HUFrame);

		HUFrame += 2;  
		NumCompletes = Ep->num_completes;

//		ASSERT(NumCompletes > 0);
		
		//
		//  Set all CMASKS bits to be set at the end of the frame
		// 
		for(;  HUFrame < 8; HUFrame++) {
			tmp |= 1 <<  HUFrame;
			NumCompletes--; 
			if(!NumCompletes){
				break;
			}
		}

		//
		// Now set all CMASKS bits to be set at the end of the 
		// frame I.E. for the next frame wrap condition
		// 
		while(NumCompletes) {
			tmp |= 1 << (HUFrame - 8); 
			NumCompletes--;
		}

//DBGPRINT(("in GetCMASK HFRAME = 0x%x HUFRAME 0x%x\n", HFrame, HUFrame));
		return tmp;
	}
}

UCHAR
USB2LIB_GetStartMicroFrame(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
	PEndpoint 	Ep;
	UCHAR 		HFrame; 		// H (Host) frame for endpoint
	UCHAR 		HUFrame;		// H (Host) micro frame for endpoint

    Ep = &EndpointContext->Ep; 
//    ASSERT(EndpointContext->Sig == SIG_LIB_EP);

	ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe, 
		&HFrame, &HUFrame);

	return HUFrame;
}

UCHAR
USB2LIB_GetPromotedThisTime(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
	PEndpoint Ep;
	UCHAR Promoted = 0;

    Ep = &EndpointContext->Ep; 
//    ASSERT(EndpointContext->Sig == SIG_LIB_EP);
	
	Promoted = (UCHAR) Ep->promoted_this_time;

	Ep->promoted_this_time = 0;

	return Promoted;
}

UCHAR
USB2LIB_GetNewPeriod(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
    PEndpoint Ep;

    Ep = &EndpointContext->Ep; 
//    ASSERT(EndpointContext->Sig == SIG_LIB_EP);

    return (UCHAR) Ep->actual_period;
}


ULONG
USB2LIB_GetScheduleOffset(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
    PEndpoint Ep;

    Ep = &EndpointContext->Ep; 
//    assert(EndpointContext->Sig == SIG_LIB_EP);

    return Ep->start_frame;
}

PVOID
USB2LIB_GetEndpoint(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
	return &(EndpointContext->Ep);
}



ULONG
USB2LIB_GetAllocedBusTime(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
    PEndpoint Ep;

    Ep = &EndpointContext->Ep; 
//    assert(EndpointContext->Sig == SIG_LIB_EP);

    return Ep->calc_bus_time;
}


PVOID
USB2LIB_GetNextEndpoint(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
    PEndpoint Ep, nextEp;
    PUSB2LIB_ENDPOINT_CONTEXT nextContext;
    
    Ep = &EndpointContext->Ep; 
    nextEp = Ep->next_ep;

    if (nextEp) {
        
        nextContext = CONTAINING_RECORD(nextEp,
                                        struct _USB2LIB_ENDPOINT_CONTEXT, 
                                        Ep);  
//    assert(EndpointContext->Sig == SIG_LIB_EP);
        return nextContext->RebalanceContext;
    } else {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usb2lib\sched.h ===
// scheduling algorithm for split periodic 

#ifndef   __SCHED_H__
#define   __SCHED_H__

#define MAXCEPS 30

// all times are in units of bytes
#define	FS_BYTES_PER_MICROFRAME 188
#define MICROFRAMES_PER_FRAME	8
#define FS_SOF 6  // number of byte times allocated to an SOF packet at the beginning of a frame
//#define	MAXFRAMES	8	// scheduling window for budget tracking, periods longer than
#define	MAXFRAMES	32	// scheduling window for budget tracking, periods longer than
				// this are reduced to this.  Also impacts space required for
				// tracking data structures.  Otherwise fairly arbitrary.

#define	MAXMICROFRAMES	(MAXFRAMES * 8)	

// 4 byte sync, 4 byte split token, 1 byte EOP, 11 byte ipg, plus
// 4 byte sync, 3 byte regular token, 1 byte EOP, 11 byte ipg
#define HS_SPLIT_SAME_OVERHEAD 39
// 4 byte sync, 4 byte split token, 1 byte EOP, 11 byte ipg, plus
// 4 byte sync, 3 byte regular token, 1 byte EOP, 1 byte bus turn
#define HS_SPLIT_TURN_OVERHEAD 29
// 4 byte sync, 1 byte PID, 2 bytes CRC16, 1 byte EOP, 11 byte ipg
#define HS_DATA_SAME_OVERHEAD 19
// 4 byte sync, 1 byte PID, 2 bytes CRC16, 1 byte EOP, 1 byte bus turn
#define HS_DATA_TURN_OVERHEAD 9
// 4 byte sync, 1 byte PID, 1 byte EOP, 1 byte bus turn
#define HS_HANDSHAKE_OVERHEAD 7
//#define HS_MAX_PERIODIC_ALLOCATION	6000	// floor(0.8*7500)
#define HS_MAX_PERIODIC_ALLOCATION	7000	// floor(0.8*7500)

// This could actually be a variable based on an HC implementation
// some measurements have shown 3?us between transactions or about 3% of a microframe
// which is about 200+ byte times.  We'll use about half that for budgeting purposes.
#define HS_HC_THINK_TIME 100

// 4 byte sync, 3 byte regular token, 1 byte EOP, 11 byte ipg
#define HS_TOKEN_SAME_OVERHEAD 19
// 4 byte sync, 3 byte regular token, 1 byte EOP, 1 byte bus turn
#define HS_TOKEN_TURN_OVERHEAD 9

// TOKEN: 1 byte sync, 3 byte token, 3 bit EOP, 1 byte ipg
// DATA: 1 byte sync, 1 byte PID, 2 bytes CRC16, 3 bit EOP, 1 byte ipg
// HANDSHAKE: 1 byte sync, 1 byte PID, 3 bit EOP, 1 byte ipg
#define	FS_ISOCH_OVERHEAD 9
#define FS_INT_OVERHEAD 13
//#define LS_INT_OVERHEAD (19*8)
#define LS_INT_OVERHEAD ((14 *8) + 5)
#define HUB_FS_ADJ 30 // periodic allocation at beginning of frame for use by hubs, maximum allowable is 60 bytes
#define FS_MAX_PERIODIC_ALLOCATION	(1157)	// floor(0.9*1500/1.16)
#define FS_BS_MAX_PERIODIC_ALLOCATION 1350 // floor(0.9*1500), includes bitstuffing allowance (for HC classic allocation)

// byte time to qualify as a large FS isoch transaction
//   673 = 1023/1.16 (i.e. 881) - 1microframe (188) - adj (30) or
//   1/2 of max allocation in this case 
// #define LARGEXACT (881-FS_BYTES_PER_MICROFRAME)
#define LARGEXACT (579)

typedef struct _Endpoint *PEndpoint;

typedef struct _frame_rec
{
	unsigned  time_used:16;		// The number of bytes that are budgeted for all endpoints in this frame
	PEndpoint allocated_large;	// endpoint if xact over LARGEXACT bytes is allocated in this frame
	PEndpoint isoch_ehead;		// many frames can point to the same endpoint. endpoints are linked
	PEndpoint int_ehead;		// in longest to shortest period.
		//
		// NOTE: always start with a "dummy" endpoint for SOF on the lists to avoid empty list corner condition
		//
} frame_rec;

typedef struct _HC *PHC;
typedef struct _TT *PTT;

typedef enum {bulk, control, interrupt, isoch} eptype;

#define	HSSPEED 2
#define FSSPEED 1
#define LSSPEED 0
#define INDIR 0
#define OUTDIR 1
typedef struct _Endpoint
{
	unsigned	type;

	// These fields have static information that is valid/constant as long as an
	// endpoint is configured
	unsigned 	max_packet:16;	// maximum number of data bytes allowed for this
                        		// endpoint. 0-8 for LS_int, 0-64 for FS_int,
                        		// 0-1023 for FS_isoch.
	unsigned 	period:16;       // desired period of transactions, assumed to be a power of 2
	eptype		ep_type:4;
	unsigned	direction:1;
	unsigned	speed:2;
	unsigned	moved_this_req:1;	// 1 when this endpoint has been changed during this allocation request
	PTT			mytt;			// the TT that roots this classic device.

	// These fields hold dynamically calculated information that changes as (other)
	// endpoints are added/removed.

	unsigned calc_bus_time:16;	// bytes of FS/LS bus time this endpoint requires
                        		// including overhead. This can be calculated once.

	unsigned start_time:16;		// classic bus time at which this endpoint is budgeted to occupy the classic bus

	unsigned actual_period:16;	// requested period can be modified:
								// 1. when period is greater than scheduling window (MAXFRAMES)
								// 2. if period is reduced (not currently done by algorithm)

	unsigned start_frame:8;		// first bus frame that is allocated to this endpoint.
	int	start_microframe:8;		// first bus microframe (in a frame) that can have a
                        		// start-split for this ep.
                        		// Complete-splits always start 2 microframes after a
                        		// start-split.
	unsigned num_starts:4;		// the number of start splits.
	unsigned num_completes:4;	// the number of complete splits.
	/* The numbers above could be (better?) represented as bitmasks. */

	/* corner conditions above: coder beware!!
	   patterns can have the last CS in the "next" frame
	     This is indicated in this design when:
		(start_microframe + num_completes + 1) > 7
	   patterns can have the first SS in the previous frame
             This is indicated in this design when:
                start_microframe = -1
	*/

	PEndpoint next_ep;			// pointer to next (faster/equal period) endpoint in budget

	int	id:16;						// not needed for real budgeter
	unsigned saved_period:16;	// used during period promotion to hold original period
	unsigned promoted_this_time:1;

} Endpoint;

typedef	struct _TT
{
	unsigned	HS_split_data_time[MAXFRAMES][MICROFRAMES_PER_FRAME]; // HS data bytes used for split completes
	// the above time tracks the data time for all devices rooted in this TT.
	// when the time is below 188 in a microframe, that time is allocated in the
	// HS microframe (in the HS HC budget).  When the time is greater than 188
	// only 188 byte times (bit stuffed) is allocated on the HS microframe budget.

	unsigned	num_starts[MAXFRAMES][MICROFRAMES_PER_FRAME];

	frame_rec frame_budget[MAXFRAMES];

	PHC	myHC;

	unsigned	think_time;	// TT reports it inter transaction "think" time.  Keep it here.
	unsigned	allocation_limit;	// maximum allocation allowed for this TT's classic bus

	struct _Endpoint isoch_head[MAXFRAMES];
	struct _Endpoint int_head[MAXFRAMES];
} TT;

typedef struct _microframe_rec
{
	unsigned	time_used;
	
} microframe_rec;

typedef struct _HC
{
	microframe_rec HS_microframe_info[MAXFRAMES][MICROFRAMES_PER_FRAME];	// HS bus time allocated to
								//this host controller
	PTT tthead;					// head of list of TTs attached to this HC
	unsigned thinktime;
	unsigned allocation_limit;	// maximum allocation allowed for this HC
	int	speed;					// HS or FS

} HC;

#if 0
typedef struct _command {
    char cmd_code;
    int  endpoint_number;
} Cmd_t;
#endif


/* protoypes */
void init_hc(PHC myHC);

Set_endpoint(
    PEndpoint	ep,
    eptype		t,
    unsigned	d,
    unsigned	s,
	unsigned	p,
	unsigned	m,
	TT			*thistt
	);

int Allocate_time_for_endpoint(
	PEndpoint ep,					
	PEndpoint changed_ep_list[],	
									
	int	*max_changed_eps			
									
	);

void
init_tt(PHC myHC, PTT myTT);	

void
Deallocate_time_for_endpoint(
	PEndpoint ep,					// endpoint that needs to be removed (bus time deallocated)
	PEndpoint changed_ep_list[],	// pointer to array to set (on return) with list of
									// changed endpoints
	int	*max_changed_eps			// input: maximum size of (returned) list
									// on return: number of changed endpoints
	);

#endif //   __SCHED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usb2lib\common.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    common.h

Abstract:

Environment:

    Kernel & user mode

Revision History:

    10-31-00 : created

--*/

#ifndef   __COMMON_H__
#define   __COMMON_H__

#include <wdm.h>
#include "usb2lib.h"
#include "sched.h"
#include "dbg.h"

typedef struct _USB2LIB_DATA {

    PUSB2LIB_DBGPRINT DbgPrint;
    PUSB2LIB_DBGBREAK DbgBreak;
    
} USB2LIB_DATA, *PUSB2LIB_DATA;


typedef struct _USB2LIB_HC_CONTEXT {

    ULONG Sig;
    HC Hc;
    TT DummyTt;	// fake TT used for HS endpoints to get to HC struct
    
} USB2LIB_HC_CONTEXT, *PUSB2LIB_HC_CONTEXT;


typedef struct _USB2LIB_TT_CONTEXT {

    ULONG Sig;
    TT Tt;
    
} USB2LIB_TT_CONTEXT, *PUSB2LIB_TT_CONTEXT;


typedef struct _USB2LIB_ENDPOINT_CONTEXT {

    ULONG Sig;
    PVOID RebalanceContext;
    Endpoint Ep;
    
} USB2LIB_ENDPOINT_CONTEXT, *PUSB2LIB_ENDPOINT_CONTEXT;


extern USB2LIB_DATA LibData;

/*
    prototypes
*/

#endif /*  __COMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\busif.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    busif.c

Abstract:

    bus interface for the usbport driver

    this is where we export the routines that create
    and remove devices on the bus for use by the hub
    driver.

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_GetBusInterface)
#pragma alloc_text(PAGE, USBPORT_BusInterfaceReference)
#pragma alloc_text(PAGE, USBPORT_BusInterfaceDereference)
#pragma alloc_text(PAGE, USBPORTBUSIF_CreateUsbDevice)
#pragma alloc_text(PAGE, USBPORTBUSIF_InitializeUsbDevice)
#pragma alloc_text(PAGE, USBPORTBUSIF_GetUsbDescriptors)
#pragma alloc_text(PAGE, USBPORTBUSIF_RemoveUsbDevice)
#pragma alloc_text(PAGE, USBPORTBUSIF_RestoreUsbDevice)
#endif

// non paged functions
//

PDEVICE_OBJECT
USBPORT_PdoFromBusContext(
    PVOID BusContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{   
    PTRANSACTION_TRANSLATOR transactionTranslator = BusContext;
    
    if (transactionTranslator->Sig == SIG_TT) {
        return transactionTranslator->PdoDeviceObject;
    } else {
        return BusContext; 
    }        
}


VOID
USBPORT_BusInterfaceReference(
    PVOID BusContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);

    PAGED_CODE();

    TEST_TRAP();
}


VOID
USBPORT_BusInterfaceDereference(
    PVOID BusContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);

    PAGED_CODE();

    TEST_TRAP();
}


NTSTATUS
USBPORT_GetBusInterface(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    USHORT requestedSize, requestedVersion;
    PVOID interfaceData;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    requestedSize = irpStack->Parameters.QueryInterface.Size;
    requestedVersion = irpStack->Parameters.QueryInterface.Version;

    USBPORT_KdPrint((1, "'USBPORT_GetBusInterface - Requested version = %d\n",
            requestedVersion));
    USBPORT_KdPrint((1, "'USBPORT_GetBusInterface - Requested size = %d\n",
            requestedSize));
    USBPORT_KdPrint((1, "'USBPORT_GetBusInterface - interface data = %x\n",
            irpStack->Parameters.QueryInterface.InterfaceSpecificData));
            
    interfaceData = irpStack->Parameters.QueryInterface.InterfaceSpecificData;

    // assume success
    ntStatus = STATUS_SUCCESS;

    // validate version, size and GUID
    if (RtlCompareMemory(irpStack->Parameters.QueryInterface.InterfaceType,
                         &USB_BUS_INTERFACE_HUB_GUID,
                         sizeof(GUID)) == sizeof(GUID)) {

        ntStatus = USBPORT_GetBusInterfaceHub(FdoDeviceObject,
                                              PdoDeviceObject,
                                              Irp);
    } else if (RtlCompareMemory(irpStack->Parameters.QueryInterface.InterfaceType,
               &USB_BUS_INTERFACE_USBDI_GUID,
               sizeof(GUID)) == sizeof(GUID)) {

        ntStatus = USBPORT_GetBusInterfaceUSBDI(FdoDeviceObject,
                                                PdoDeviceObject,
                                                interfaceData,
                                                Irp);
    } else {

        //
        // Don't change the status of an IRP that isn't understand.
        //
        ntStatus = Irp->IoStatus.Status;
    }

    return ntStatus;
}


NTSTATUS
USBPORT_GetBusInterfaceHub(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    USHORT requestedSize, requestedVersion;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    requestedSize = irpStack->Parameters.QueryInterface.Size;
    requestedVersion = irpStack->Parameters.QueryInterface.Version;

    // assume success
    ntStatus = STATUS_SUCCESS;


    if (requestedVersion >= USB_BUSIF_HUB_VERSION_0) {

        PUSB_BUS_INTERFACE_HUB_V0 busInterface0;

        busInterface0 = (PUSB_BUS_INTERFACE_HUB_V0)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface0->BusContext =
            PdoDeviceObject;
        busInterface0->InterfaceReference =
            USBPORT_BusInterfaceReference;
        busInterface0->InterfaceDereference =
            USBPORT_BusInterfaceDereference;

        busInterface0->Size = sizeof(USB_BUS_INTERFACE_HUB_V0);
        busInterface0->Version = USB_BUSIF_HUB_VERSION_0;
    }

    if (requestedVersion >= USB_BUSIF_HUB_VERSION_1) {

        PUSB_BUS_INTERFACE_HUB_V1 busInterface1;

        busInterface1 = (PUSB_BUS_INTERFACE_HUB_V1)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface1->CreateUsbDevice =
            USBPORTBUSIF_CreateUsbDevice;
        busInterface1->InitializeUsbDevice =
            USBPORTBUSIF_InitializeUsbDevice;
        busInterface1->GetUsbDescriptors =
            USBPORTBUSIF_GetUsbDescriptors;
        busInterface1->RemoveUsbDevice =
            USBPORTBUSIF_RemoveUsbDevice;
        busInterface1->RestoreUsbDevice =
            USBPORTBUSIF_RestoreUsbDevice;
        busInterface1->QueryDeviceInformation =
            USBPORTBUSIF_BusQueryDeviceInformation;

        busInterface1->Size = sizeof(USB_BUS_INTERFACE_HUB_V1);
        busInterface1->Version = USB_BUSIF_HUB_VERSION_1;
    }

    // note that version 2 is a superset of version 1
    if (requestedVersion >= USB_BUSIF_HUB_VERSION_2) {

        PUSB_BUS_INTERFACE_HUB_V2 busInterface2;

        busInterface2 = (PUSB_BUS_INTERFACE_HUB_V2)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface2->GetControllerInformation =
            USBPORTBUSIF_GetControllerInformation;
        busInterface2->ControllerSelectiveSuspend =
            USBPORTBUSIF_ControllerSelectiveSuspend;
        busInterface2->GetExtendedHubInformation =
            USBPORTBUSIF_GetExtendedHubInformation;
        busInterface2->GetRootHubSymbolicName =
            USBPORTBUSIF_GetRootHubSymbolicName;
        busInterface2->GetDeviceBusContext =
            USBPORTBUSIF_GetDeviceBusContext;
        busInterface2->Initialize20Hub = 
            USBPORTBUSIF_InitailizeUsb2Hub;            

        busInterface2->Size = sizeof(USB_BUS_INTERFACE_HUB_V2);
        busInterface2->Version = USB_BUSIF_HUB_VERSION_2;
    }

    // note that version 3 is a superset of version 2 & 1
    if (requestedVersion >= USB_BUSIF_HUB_VERSION_3) {

        PUSB_BUS_INTERFACE_HUB_V3 busInterface3;

        busInterface3 = (PUSB_BUS_INTERFACE_HUB_V3)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface3->RootHubInitNotification = 
            USBPORTBUSIF_RootHubInitNotification;                 

        busInterface3->Size = sizeof(USB_BUS_INTERFACE_HUB_V3);
        busInterface3->Version = USB_BUSIF_HUB_VERSION_3;
    }

     // note that version 4 is a superset of version 3,2 & 1
    if (requestedVersion >= USB_BUSIF_HUB_VERSION_4) {

        PUSB_BUS_INTERFACE_HUB_V4 busInterface4;

        busInterface4 = (PUSB_BUS_INTERFACE_HUB_V4)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface4->FlushTransfers = 
            USBPORTBUSIF_FlushTransfers;   
            
        busInterface4->Size = sizeof(USB_BUS_INTERFACE_HUB_V4);
        busInterface4->Version = USB_BUSIF_HUB_VERSION_4;
    }

    if (requestedVersion >= USB_BUSIF_HUB_VERSION_5) {

        PUSB_BUS_INTERFACE_HUB_V5 busInterface5;

        busInterface5 = (PUSB_BUS_INTERFACE_HUB_V5)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface5->SetDeviceHandleData = 
            USBPORTBUSIF_SetDeviceHandleData;               
            
        busInterface5->Size = sizeof(USB_BUS_INTERFACE_HUB_V5);
        busInterface5->Version = USB_BUSIF_HUB_VERSION_5;
        
    }


    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_CreateUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE *NewDeviceHandle,
    PUSB_DEVICE_HANDLE HubDeviceHandle,
    USHORT PortStatus,
    USHORT PortNumber
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;
    PUSBD_DEVICE_HANDLE deviceHandle;

    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    ntStatus =
        USBPORT_CreateDevice(&deviceHandle,
                             rhDevExt->HcFdoDeviceObject,
                             HubDeviceHandle,
                             PortStatus,
                             PortNumber);

    *NewDeviceHandle = (PUSB_DEVICE_HANDLE) deviceHandle;

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_RootHubInitNotification(
    PVOID BusContext,
    PVOID CallbackContext,
    PRH_INIT_CALLBACK CallbackRoutine
    )
/*++

Routine Description:

    This is where we hold the enumeration of the CC root hubs until
    the USB 2.0 controller has initialized.

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION rhDevExt, devExt;
    KIRQL irql;
    
    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // remember the callback
    KeAcquireSpinLock(&devExt->Fdo.HcSyncSpin.sl, &irql);
    rhDevExt->Pdo.HubInitContext = CallbackContext;
    rhDevExt->Pdo.HubInitCallback = CallbackRoutine;
    KeReleaseSpinLock(&devExt->Fdo.HcSyncSpin.sl, irql);
     
    return STATUS_SUCCESS;
}


NTSTATUS
USBPORTBUSIF_InitailizeUsb2Hub(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE HubDeviceHandle,
    ULONG TtCount
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;

    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    LOGENTRY(NULL, rhDevExt->HcFdoDeviceObject, 
        LOG_MISC, 'i2hb', BusContext, HubDeviceHandle, TtCount);

    ntStatus =
        USBPORT_InitializeHsHub(rhDevExt->HcFdoDeviceObject,
                                HubDeviceHandle,
                                TtCount);

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_InitializeUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;

    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    ntStatus =
        USBPORT_InitializeDevice(DeviceHandle,
                                 rhDevExt->HcFdoDeviceObject);

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_GetUsbDescriptors(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle,
    PUCHAR DeviceDescriptorBuffer,
    PULONG DeviceDescriptorBufferLength,
    PUCHAR ConfigDescriptorBuffer,
    PULONG ConfigDescriptorBufferLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;
    PUSBD_DEVICE_HANDLE deviceHandle = DeviceHandle;

    PAGED_CODE();

    // assume success
    ntStatus = STATUS_SUCCESS;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    // Use the cached device descriptor instead of bothering the device with
    // another request for it.  You would be surprised by how many devices
    // get confused if you ask for descriptors too often back to back.
    //
    if (DeviceDescriptorBuffer && *DeviceDescriptorBufferLength) {

        USBPORT_ASSERT(*DeviceDescriptorBufferLength ==
                       sizeof(USB_DEVICE_DESCRIPTOR));

        USBPORT_ASSERT(deviceHandle->DeviceDescriptor.bLength >=
                       sizeof(USB_DEVICE_DESCRIPTOR));

        if (*DeviceDescriptorBufferLength > sizeof(USB_DEVICE_DESCRIPTOR)) {
            *DeviceDescriptorBufferLength = sizeof(USB_DEVICE_DESCRIPTOR);
        }

        RtlCopyMemory(DeviceDescriptorBuffer,
                      &deviceHandle->DeviceDescriptor,
                      *DeviceDescriptorBufferLength);
    }

    if (NT_SUCCESS(ntStatus)) {
        ntStatus =
            USBPORT_GetUsbDescriptor(DeviceHandle,
                                     rhDevExt->HcFdoDeviceObject,
                                     USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                     ConfigDescriptorBuffer,
                                     ConfigDescriptorBufferLength);
    }

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_RemoveUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle,
    ULONG Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;
    PUSBD_DEVICE_HANDLE deviceHandle = DeviceHandle;

    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    ntStatus =
        USBPORT_RemoveDevice(deviceHandle,
                             rhDevExt->HcFdoDeviceObject,
                             Flags);

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_RestoreUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE OldDeviceHandle,
    PUSB_DEVICE_HANDLE NewDeviceHandle
    )
/*++

Routine Description:

    This function clones the configuration from the 'OldDeviceHandle'
    to the 'NewDevicehandle' iff the device has the same VID/PID .
    On completion the 'old' device handle is feed

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;

    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    ntStatus = USBPORT_CloneDevice(rhDevExt->HcFdoDeviceObject,
                                   OldDeviceHandle,
                                   NewDeviceHandle);

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_BusQueryDeviceInformation(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle,
    PVOID DeviceInformationBuffer,
    ULONG DeviceInformationBufferLength,
    PULONG LengthOfDataCopied
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    ULONG need;
    PUSBD_CONFIG_HANDLE cfgHandle;
    ULONG i, j;
    PUSB_DEVICE_INFORMATION_0 level_0 = DeviceInformationBuffer;
    PUSB_LEVEL_INFORMATION levelInfo = DeviceInformationBuffer;
    ULONG numberOfPipes = 0;
    PUSBD_DEVICE_HANDLE deviceHandle = DeviceHandle;

    PAGED_CODE();

    *LengthOfDataCopied = 0;

    if (DeviceInformationBufferLength < sizeof(*levelInfo)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (levelInfo->InformationLevel > 0) {
        // only support level 0
        return STATUS_NOT_SUPPORTED;
    }

    // figure out how much room we need
    cfgHandle = deviceHandle->ConfigurationHandle;
    if (cfgHandle != NULL) {

        PLIST_ENTRY listEntry;
        PUSBD_INTERFACE_HANDLE_I iHandle;

         // walk the list
        GET_HEAD_LIST(cfgHandle->InterfaceHandleList, listEntry);

        while (listEntry &&
               listEntry != &cfgHandle->InterfaceHandleList) {

            // extract the handle from this entry
            iHandle = (PUSBD_INTERFACE_HANDLE_I) CONTAINING_RECORD(
                        listEntry,
                        struct _USBD_INTERFACE_HANDLE_I,
                        InterfaceLink);

            ASSERT_INTERFACE(iHandle);
            numberOfPipes += iHandle->InterfaceDescriptor.bNumEndpoints;

            listEntry = iHandle->InterfaceLink.Flink;
        }

    }

    need = (numberOfPipes-1) * sizeof(USB_PIPE_INFORMATION_0) +
            sizeof(USB_DEVICE_INFORMATION_0);


    if (DeviceInformationBufferLength < need) {
        // report how much space if possible
        levelInfo->ActualLength = need;
        *LengthOfDataCopied = sizeof(*levelInfo);
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlZeroMemory(level_0, need);

    //
    // enough room, fill in the buffer
    //

    level_0->InformationLevel = 0;
    level_0->ActualLength = need;
    level_0->DeviceAddress = deviceHandle->DeviceAddress;
    level_0->DeviceDescriptor = deviceHandle->DeviceDescriptor;
    level_0->DeviceSpeed = deviceHandle->DeviceSpeed;

    switch(level_0->DeviceSpeed) {
    case UsbFullSpeed:
    case UsbLowSpeed:
        level_0->DeviceType = Usb11Device;
        break;
    case UsbHighSpeed:
        level_0->DeviceType = Usb20Device;
        break;
    }

//    level_0->PortNumber = xxx;
    level_0->NumberOfOpenPipes = numberOfPipes;
    // default to 'unconfigured'
    level_0->CurrentConfigurationValue = 0;
    // get the pipe information
    if (cfgHandle) {

        PLIST_ENTRY listEntry;
        PUSBD_INTERFACE_HANDLE_I iHandle;

        level_0->CurrentConfigurationValue =
            cfgHandle->ConfigurationDescriptor->bConfigurationValue;

         // walk the list
        GET_HEAD_LIST(cfgHandle->InterfaceHandleList, listEntry);

        j = 0;
        while (listEntry &&
               listEntry != &cfgHandle->InterfaceHandleList) {

            // extract the handle from this entry
            iHandle = (PUSBD_INTERFACE_HANDLE_I) CONTAINING_RECORD(
                        listEntry,
                        struct _USBD_INTERFACE_HANDLE_I,
                        InterfaceLink);

            ASSERT_INTERFACE(iHandle);
            for (i=0; i<iHandle->InterfaceDescriptor.bNumEndpoints; i++) {

                if (TEST_FLAG(iHandle->PipeHandle[i].PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {
                    level_0->PipeList[j].ScheduleOffset = 1;
                } else {
                    level_0->PipeList[j].ScheduleOffset =
                       iHandle->PipeHandle[i].Endpoint->Parameters.ScheduleOffset;
                }

                RtlCopyMemory(&level_0->PipeList[j].EndpointDescriptor,
                              &iHandle->PipeHandle[i].EndpointDescriptor,
                              sizeof(USB_ENDPOINT_DESCRIPTOR));
                j++;
            }
            listEntry = iHandle->InterfaceLink.Flink;
        }
    }

    *LengthOfDataCopied = need;

    // dump the level data returned
    USBPORT_KdPrint((1, "  USBD level 0 Device Information:\n"));
    USBPORT_KdPrint((1, "  InformationLevel %d\n",
        level_0->InformationLevel));
    USBPORT_KdPrint((1, "  ActualLength %d\n",
        level_0->ActualLength));
    USBPORT_KdPrint((1, "  DeviceSpeed %d\n",
        level_0->DeviceSpeed));
    USBPORT_KdPrint((1, "  DeviceType %d\n",
        level_0->DeviceType));
    USBPORT_KdPrint((1, "  PortNumber %d\n",
        level_0->PortNumber));
    USBPORT_KdPrint((1, "  CurrentConfigurationValue %d\n",
        level_0->CurrentConfigurationValue));
    USBPORT_KdPrint((1, "  DeviceAddress %d\n",
        level_0->DeviceAddress));
    USBPORT_KdPrint((1, "  NumberOfOpenPipes %d\n",
        level_0->NumberOfOpenPipes));

    for (i=0; i<level_0->NumberOfOpenPipes; i++) {
        USBPORT_KdPrint((1, "  ScheduleOffset[%d] %d\n", i,
            level_0->PipeList[i].ScheduleOffset));
        USBPORT_KdPrint((1, "  MaxPacket %d\n",
            level_0->PipeList[i].EndpointDescriptor.wMaxPacketSize));
        USBPORT_KdPrint((1, "  Interval %d\n",
            level_0->PipeList[i].EndpointDescriptor.bInterval));
//        USBD_KdPrint(1, ("' \n", level_0->));
//        USBD_KdPrint(1, ("' \n", level_0->));
    }

    return STATUS_SUCCESS;
}


PVOID
USBPORTBUSIF_GetDeviceBusContext(
    IN PVOID HubBusContext,
    IN PVOID DeviceHandle
    )
/*++

Routine Description:

    Retun the device relative bus context

Arguments:

Return Value:


--*/
{
    PDEVICE_OBJECT pdoDeviceObject = 
        USBPORT_PdoFromBusContext(HubBusContext);
    PDEVICE_EXTENSION rhDevExt;
    
    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    return USBPORT_GetDeviceBusContext(rhDevExt->HcFdoDeviceObject,
                                       DeviceHandle,
                                       HubBusContext);
}               


PVOID
USBPORT_GetDeviceBusContext(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PVOID HubBusContext 
    )
/*++

Routine Description:

    Return the device relative bus context

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION devExt;
    
    ASSERT_DEVICE_HANDLE(DeviceHandle);

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // if this is not USB2 just return the hubs bus 
    // context passed in as the device relative context,
    // ie there are no virtual 1.1 buses. Otherwise 
    // return the tt handle for this device
    
    if (USBPORT_IS_USB20(devExt)) {
        return DeviceHandle->Tt;
    } else {
        return HubBusContext;
    }
    
}


BOOLEAN
USBPORT_IsDeviceHighSpeed(
    PVOID BusContext
    )
/*++

Routine Description:

    return the speed of the given device

Arguments:

Return Value:

    speed
--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    PTRANSACTION_TRANSLATOR transactionTranslator = BusContext;
    
    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);

    if (transactionTranslator->Sig != SIG_TT) {
        // return true if bus is high speed
        if (USBPORT_IS_USB20(devExt)) {
            return TRUE; 
        }            
    }       

    return FALSE;
}    


NTSTATUS
USBPORT_BusQueryBusInformation(
    PVOID BusContext,
    ULONG Level,
    PVOID BusInformationBuffer,
    PULONG BusInformationBufferLength,
    PULONG BusInformationActulaLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    switch (Level) {
    case 0:
        {
        PUSB_BUS_INFORMATION_LEVEL_0 level_0;

        level_0 =  BusInformationBuffer;
        LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'lev1', 0, level_0, 0);

        if (BusInformationActulaLength != NULL) {
            *BusInformationActulaLength = sizeof(*level_0);
        }

        if (*BusInformationBufferLength >= sizeof(*level_0)) {
            *BusInformationBufferLength = sizeof(*level_0);

            // BUGBUG
            TEST_TRAP();
            level_0->TotalBandwidth = 
                USBPORT_ComputeTotalBandwidth(fdoDeviceObject,
                                              BusContext);
            level_0->ConsumedBandwidth =
                USBPORT_ComputeAllocatedBandwidth(fdoDeviceObject,
                                                  BusContext);

            ntStatus = STATUS_SUCCESS;
        } else {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        }
        break;

    case 1:
        {
        PUSB_BUS_INFORMATION_LEVEL_1 level_1;
        ULONG need;

        level_1 =  BusInformationBuffer;
        LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'lev1', 0, level_1, 0);

        need = sizeof(*level_1) + devExt->SymbolicLinkName.Length;

        if (BusInformationActulaLength != NULL) {
            *BusInformationActulaLength = need;
        }

        if (*BusInformationBufferLength >= need) {
            *BusInformationBufferLength = need;

            level_1->TotalBandwidth = 
                USBPORT_ComputeTotalBandwidth(fdoDeviceObject,
                                              BusContext);
            level_1->ConsumedBandwidth =
                USBPORT_ComputeAllocatedBandwidth(fdoDeviceObject,
                                                  BusContext);
            level_1->ControllerNameLength =
                devExt->SymbolicLinkName.Length;

            RtlCopyMemory(level_1->ControllerNameUnicodeString,
                          devExt->SymbolicLinkName.Buffer,
                          level_1->ControllerNameLength);

            ntStatus = STATUS_SUCCESS;
        } else {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        }
    }

    return ntStatus;
}


NTSTATUS
USBPORT_GetBusInterfaceUSBDI(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    USHORT requestedSize, requestedVersion;
    PVOID usbBusContext;
    PDEVICE_EXTENSION rhDevExt;
    
    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    if (DeviceHandle == NULL) {
        DeviceHandle = &rhDevExt->Pdo.RootHubDeviceHandle;
    }
    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gbi1', FdoDeviceObject, 
        DeviceHandle, 0);
    ASSERT_DEVICE_HANDLE(DeviceHandle);
    
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    requestedSize = irpStack->Parameters.QueryInterface.Size;
    requestedVersion = irpStack->Parameters.QueryInterface.Version;

    // assume success
    ntStatus = STATUS_SUCCESS;

    if (requestedVersion >= USB_BUSIF_USBDI_VERSION_0) {

        PUSB_BUS_INTERFACE_USBDI_V0 busInterface0;

        busInterface0 = (PUSB_BUS_INTERFACE_USBDI_V0)
            irpStack->Parameters.QueryInterface.Interface;

        usbBusContext = PdoDeviceObject;
        // if the device handle is for a device attched to a TT
        // the the bus context is a TT not the root hub Pdo
        if (DeviceHandle->Tt != NULL) {
            usbBusContext = DeviceHandle->Tt;    
        }            
        
        busInterface0->BusContext = usbBusContext;
        busInterface0->InterfaceReference =
            USBPORT_BusInterfaceReference;
        busInterface0->InterfaceDereference =
            USBPORT_BusInterfaceDereference;
        busInterface0->GetUSBDIVersion =
            USBPORT_BusGetUSBDIVersion;
        busInterface0->QueryBusTime =
            USBPORT_BusQueryBusTime;
        busInterface0->QueryBusInformation =
            USBPORT_BusQueryBusInformation;

        busInterface0->Size = sizeof(USB_BUS_INTERFACE_USBDI_V0);
        busInterface0->Version = USB_BUSIF_USBDI_VERSION_0;
    }

    
    if (requestedVersion >= USB_BUSIF_USBDI_VERSION_1) {

        PUSB_BUS_INTERFACE_USBDI_V1 busInterface1;

        busInterface1 = (PUSB_BUS_INTERFACE_USBDI_V1)
            irpStack->Parameters.QueryInterface.Interface;

        // add version 1 extensions
        busInterface1->IsDeviceHighSpeed =
            USBPORT_IsDeviceHighSpeed;
            
        busInterface1->Size = sizeof(USB_BUS_INTERFACE_USBDI_V1);
        busInterface1->Version = USB_BUSIF_USBDI_VERSION_1;
    }

     if (requestedVersion >= USB_BUSIF_USBDI_VERSION_2) {

        PUSB_BUS_INTERFACE_USBDI_V2 busInterface2;

        busInterface2 = (PUSB_BUS_INTERFACE_USBDI_V2)
            irpStack->Parameters.QueryInterface.Interface;

        // add version 2 extensions
        busInterface2->EnumLogEntry =
            USBPORT_BusEnumLogEntry;
            
        busInterface2->Size = sizeof(USB_BUS_INTERFACE_USBDI_V2);
        busInterface2->Version = USB_BUSIF_USBDI_VERSION_2;
    }

    return ntStatus;
}


VOID
USBPORT_BusGetUSBDIVersion(
    PVOID BusContext,
    PUSBD_VERSION_INFORMATION VersionInformation,
    PULONG HcdCapabilities
    )
/*++

Routine Description:

    returns the current USB frame

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(HcdCapabilities != NULL);

    *HcdCapabilities = 0;

    if (VersionInformation != NULL) {
        VersionInformation->USBDI_Version = USBDI_VERSION;

        if (USBPORT_IS_USB20(devExt)) {
            VersionInformation->Supported_USB_Version = 0x0200;
        } else {
            VersionInformation->Supported_USB_Version = 0x0110;
        }
    }

//    if (deviceExtensionUsbd->HcdSubmitIsoUrb != NULL) {
//        *HcdCapabilities = USB_HCD_CAPS_SUPPORTS_RT_THREADS;
//    }
}


NTSTATUS
USBPORT_BusQueryBusTime(
    PVOID BusContext,
    PULONG CurrentFrame
    )
/*++

Routine Description:

    returns the current USB frame

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(CurrentFrame != NULL);

    MP_Get32BitFrameNumber(devExt, *CurrentFrame);

    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'biCF', 0,
        CurrentFrame, *CurrentFrame);

    return STATUS_SUCCESS;
}


NTSTATUS
USBPORT_BusEnumLogEntry(
    PVOID BusContext,
    ULONG DriverTag,
    ULONG EnumTag,
    ULONG P1,
    ULONG P2
    )
/*++

Routine Description:

    returns the current USB frame

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_EnumLogEntry(fdoDeviceObject,
                         DriverTag,
                         EnumTag,
                         P1,
                         P2);

    return STATUS_SUCCESS;
}


NTSTATUS
USBPORT_BusSubmitIsoOutUrb(
    PVOID BusContext,
    PURB Urb
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    TEST_TRAP();

    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
USBPORTBUSIF_GetControllerInformation(
    PVOID BusContext,
    PVOID ControllerInformationBuffer,
    ULONG ControllerInformationBufferLength,
    PULONG LengthOfDataCopied
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    ULONG len;
    PUSB_CONTROLLER_INFORMATION_0 level_0 = ControllerInformationBuffer;
    PUSB_LEVEL_INFORMATION levelInfo = ControllerInformationBuffer;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    PAGED_CODE();

    *LengthOfDataCopied = 0;

    if (ControllerInformationBufferLength < sizeof(*levelInfo)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *LengthOfDataCopied = sizeof(*levelInfo);

    switch (levelInfo->InformationLevel) {
    // level 0
    case 0:
        len = sizeof(*level_0);
        level_0->ActualLength = len;

        if (ControllerInformationBufferLength >= len) {
            *LengthOfDataCopied = len;
            level_0->SelectiveSuspendEnabled =
                TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND) ?
                    TRUE : FALSE;
        }

        *LengthOfDataCopied = sizeof(*level_0);
        return STATUS_SUCCESS;

    default:
        return STATUS_NOT_SUPPORTED;
    }

    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
USBPORTBUSIF_ControllerSelectiveSuspend(
    PVOID BusContext,
    BOOLEAN Enable
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    NTSTATUS ntStatus;
    ULONG disableSelectiveSuspend;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);


    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    PAGED_CODE();

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_DISABLE_SS)) {
        // if SS diabled by hardware then we will not allow UI 
        // to enable it
        return STATUS_SUCCESS;
    }

    if (Enable) {
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND);
        disableSelectiveSuspend = 0;
    } else {
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND);
        disableSelectiveSuspend = 1;
    }

    ntStatus = USBPORT_SetRegistryKeyValueForPdo(
                            devExt->Fdo.PhysicalDeviceObject,
                            USBPORT_SW_BRANCH,
                            REG_DWORD,
                            DISABLE_SS_KEY,
                            sizeof(DISABLE_SS_KEY),
                            &disableSelectiveSuspend,
                            sizeof(disableSelectiveSuspend));


    if (NT_SUCCESS(ntStatus)) {
        if (Enable) {
            SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND);
        } else {
            CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND);
        }
    }
    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_GetExtendedHubInformation(
    PVOID BusContext,
    PDEVICE_OBJECT HubPhysicalDeviceObject,
    PVOID HubInformationBuffer,
    ULONG HubInformationBufferLength,
    PULONG LengthOfDataCopied
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    NTSTATUS ntStatus;
    ULONG i;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // is this the root hub PDO, if so we'll report values from the 
    // registry

    if (HubPhysicalDeviceObject == pdoDeviceObject) {
        // root hub PDO

        if (HubInformationBufferLength < sizeof(USB_EXTHUB_INFORMATION_0))  {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
            *LengthOfDataCopied = 0;    
        } else {
            PUSB_EXTHUB_INFORMATION_0 extendedHubInfo = HubInformationBuffer;

            extendedHubInfo->NumberOfPorts = NUMBER_OF_PORTS(rhDevExt);

            for (i=0; i< extendedHubInfo->NumberOfPorts; i++) {

                // set up the defaults
                extendedHubInfo->Port[i].PhysicalPortNumber = i+1;
                extendedHubInfo->Port[i].PortLabelNumber = i+1;
                extendedHubInfo->Port[i].VidOverride = 0;
                extendedHubInfo->Port[i].PidOverride = 0;
                extendedHubInfo->Port[i].PortAttributes = 0;
            

                if (USBPORT_IS_USB20(devExt)) {
                    RH_PORT_STATUS portStatus;
                    USB_MINIPORT_STATUS mpStatus;
                    
                    extendedHubInfo->Port[i].PortAttributes |= 
                        USB_PORTATTR_SHARED_USB2;   
                                        
                    MPRH_GetPortStatus(devExt, 
                                       (USHORT)(i+1),
                                       &portStatus,
                                       mpStatus);     

                    if (portStatus.OwnedByCC) {
                        extendedHubInfo->Port[i].PortAttributes |= 
                            USB_PORTATTR_OWNED_BY_CC;   
                    }
                } else {
                    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC) && 
                        USBPORT_FindUSB2Controller(fdoDeviceObject)) {

                        extendedHubInfo->Port[i].PortAttributes |= 
                            USB_PORTATTR_NO_OVERCURRENT_UI;   
                    }
                }
            }

            // get optional registry parameters that describe port 
            // attributes
            for (i=0; i < extendedHubInfo->NumberOfPorts; i++) {
                WCHAR key[64];
                ULONG portAttr;
                
                RtlCopyMemory(key, 
                              PORT_ATTRIBUTES_KEY, 
                              sizeof(PORT_ATTRIBUTES_KEY));

                key[8] = '1'+i;

                portAttr = 0;
                USBPORT_GetRegistryKeyValueForPdo(devExt->HcFdoDeviceObject,
                                          devExt->Fdo.PhysicalDeviceObject,
                                          USBPORT_HW_BRANCH,
                                          key,
                                          sizeof(key),
                                          &portAttr,
                                          sizeof(portAttr));  

                USBPORT_KdPrint((1, "  Registry PortAttribute[%d] %x \n", i+1, portAttr));                                              

                // augment with registry value
                extendedHubInfo->Port[i].PortAttributes |= portAttr;                
            }


#if DBG
           for (i=0; i < extendedHubInfo->NumberOfPorts; i++) {
                USBPORT_KdPrint((1, "  PortAttribute[%d] %x \n", i+1, 
                         extendedHubInfo->Port[i].PortAttributes));   
            }                         

#endif
            // execute the control method to see if ACPI knows about
            // any extended attributes here
        
            *LengthOfDataCopied =  sizeof(USB_EXTHUB_INFORMATION_0);
            ntStatus = STATUS_SUCCESS;
        }            
        
    } else {
        // not supporting extended attributes for ports other than the 
        // root hub at this time

        // if the BIOS supports the ACPI methods we will execute the 
        // method here

        *LengthOfDataCopied = 0;
        ntStatus = STATUS_NOT_SUPPORTED;
    }
    
    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_GetRootHubSymbolicName(
    PVOID BusContext,
    PVOID HubSymNameBuffer,
    ULONG HubSymNameBufferLength,
    PULONG HubSymNameActualLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    NTSTATUS ntStatus;
    UNICODE_STRING hubNameUnicodeString;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_KdPrint((1, "  HubSymNameBuffer %x \n", HubSymNameBuffer));
    USBPORT_KdPrint((1, "  HubSymNameBufferLength x%x \n", HubSymNameBufferLength));
    USBPORT_KdPrint((1, "  HubSymNameActualLength x%x \n", HubSymNameBufferLength));


    ntStatus = USBPORT_GetSymbolicName(fdoDeviceObject,
                                       devExt->Fdo.RootHubPdo,
                                       &hubNameUnicodeString);

    // copy what we can
    if (HubSymNameBufferLength >= hubNameUnicodeString.Length) {
        RtlCopyMemory(HubSymNameBuffer,
                      hubNameUnicodeString.Buffer,
                      hubNameUnicodeString.Length);
    } else {
        // too small return a NULL
        RtlZeroMemory(HubSymNameBuffer,
                      sizeof(UNICODE_NULL));
    }
    *HubSymNameActualLength = hubNameUnicodeString.Length;

    USBPORT_KdPrint((1, " hubNameUnicodeString.Buffer  %x l %d\n",
        hubNameUnicodeString.Buffer,
        hubNameUnicodeString.Length));

    USBPORT_KdPrint((1, "  HubSymNameActualLength x%x \n", *HubSymNameActualLength));

    RtlFreeUnicodeString(&hubNameUnicodeString);

    // note we always return status success, in order to be backward
    // compaible with the original IOCTL

    return ntStatus;
}


VOID
USBPORTBUSIF_FlushTransfers(
    PVOID BusContext,
    PVOID DeviceHandle
    )
/*++

Routine Description:

    Flushes any outstanding tranfers for a device handle plus the bad request 
    list.
    if no device handle is given just all tranfers on the bad request list
    are flushed.

    The purpose of this function is to complete any tranfers that may be pening 
    by client drivers that are about to unload.

Arguments:

Return Value:

    

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    
    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_BadRequestFlush(fdoDeviceObject, TRUE);     

    return;
}


VOID
USBPORTBUSIF_SetDeviceHandleData(
    PVOID BusContext,
    PVOID DeviceHandle,
    PDEVICE_OBJECT UsbDevicePdo
    )
/*++

Routine Description:

    Assocaites a particular PDO with a device handle for use 
    in post mortem debugging situaltions

    This routine must be called at passive level.
    
Arguments:

Return Value:

    

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    PUSBD_DEVICE_HANDLE deviceHandle = DeviceHandle;
    
    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    //USBPORT_ASSERT(UsbDevicePdo != NULL);
    //USBPORT_ASSERT(deviceHandle != NULL);

    USBPORT_KdPrint((1, "  SetDeviceHandleData (PDO) %x dh (%x)\n", 
        UsbDevicePdo, deviceHandle));

    if (UsbDevicePdo != NULL && 
        deviceHandle != NULL) {

        PDEVICE_OBJECT fdo;
        // get driver name from device object.
       
        deviceHandle->DevicePdo = UsbDevicePdo;

        // walk up one location for the FDO
        // note: this may be verifier but we 
        // need to know this a well
        fdo = UsbDevicePdo->AttachedDevice;
        USBPORT_KdPrint((1, "  SetDeviceHandleData (FDO) %x \n", 
            fdo));

        // there may be no FDO if the client driver never attached
        
        if (fdo != NULL &&
            fdo->DriverObject != NULL ) { 

            PDRIVER_OBJECT driverObject;
            ULONG len, i;
            PWCHAR pwch;

            driverObject = fdo->DriverObject;

            pwch = driverObject->DriverName.Buffer;
            
            len = (driverObject->DriverName.Length/sizeof(WCHAR)) > USB_DRIVER_NAME_LEN ? 
                USB_DRIVER_NAME_LEN : 
                driverObject->DriverName.Length/sizeof(WCHAR);
                
            // grab the first 8 chars of the driver name
            for (i=0; i<len && pwch; i++) {
                deviceHandle->DriverName[i] = 
                    *pwch;
                pwch++;                                    
            }
        }            
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usb2lib\sched.c ===
// scheduling algorithm for split periodic 

/*
 *  Allocate_time_for_endpoint - adds a new endpoint to the periodic budget tracking list
 *  Dealloate_time_for_endpoint - removes an endpoint from the budget
 *
 * Each of these routines return a list of other (previously allocated) endpoints that have had
 * their allocation changed due to the (de)allocation of an endpoint.
 *
 */


/***************** Design notes *********************
 *
 * Split transactions require three allocations (and/or budgets).
 *  1) the classic bus must count the byte times required in each classic frame.
 *     This is what a classic bus already normally does.
 *  2) a microframe patterned frame budget must be computed for each classic frame.
 *     This is used to determine what microframes require split transactions.
 *  3) the high speed bus must count the byte times required in each HS microframe.
 *     This is the HS equivalent of what is done for a (classic) bus, i.e same
 *     general allocation algorithm, just at HS and for microframes (vs. frames).
 *
 * A frame budget must be maintained for currently configured endpoints.
 * A frame budget consists of a (continuous repeating) sequence of frames.
 * Each frame consists of the endpoints that are allocated time for that frame.
 * Each frame contains the microframe patterns for each configured endpoint for
 * split transaction endpoints.  A microframe pattern consists of the microframes in a
 * frame that contain start-splits (SS) or complete-splits (CS) for an endpoint.
 *
 * The frame budget is maintained separately from any HC schedule of transactions for endpoints.
 * The two must be coherent with each other, but the budget is essentially a pattern to be used
 * to construct an HC transaction schedule as clients request data transfer.  When a new endpoint
 * is allocated, it can change the pattern of previously existing (allocated) endpoints.  This
 * requires that the corresponding HC schedule be reconciled at some point in time.  Precisely how
 * the two are reconciled is not dealt with in this algorithm.  However, some ideas are captured
 * later in these comments.
 *
 * The microframe patterns budgeted must match the order in which transactions are
 * processed on the bus by the host controller and its driver.  This makes the
 * scheduling software interdependent with the host controller and its driver.
 *
 * There are several requirements between the computed frame budget and the order in which the
 * HC visits transactions:
 *	1) (EHCI req): a large isoch transaction (> about 570 bytes?) must be first in the
 *		frame to avoid having more than 1 microframe with an SS and CS
 *		This is in lieu of having to sort the transactions into decreasing size through the frame.
 *	2) (core spec req): the order of CSs in a microframe for a set of endpoints must be
 *		identical to the order of SSs used to start the classic transactions
 *	3) (implementation requirement due to EHCI and core spec TT rules): the order of endpoints
 *		for isoch OUTs longer than 188 bytes (e.g. ones with more than one SS) must match the
 *		budgeted order so that multiple SSs are sequenced correctly across microframes for multiple
 *		endpoints.
 *
 *		Example, assume endpoint A and B
 *		are isoch OUT, with A budgeted before B and B requires 2 microframes of SS.  A must
 *		be processed before B so that the SS sequence is:
 *			microframe N:   A-SS1, B-SS1
 *			microframe N+1: B-SS2
 *
 *		if instead the processing order were allowed to be B and then A this would result in:
 *
 *			microframe N:   B-SS1, A-SS1
 *			microframe N+1: B-SS2
 *
 *		this would result in the TT seeing B-SS1, A-SS1, B-SS2.  This is not a valid order for
 * 		long isoch OUT for B.  The TT will treat B (initially) as incomplete (due to the A SS) and ignore
 *		B-SS2.
 *	4) (implementation requirement due to EHCI and core spec TT rules): The order of endpoints for
 *		isoch INs longer than 188 bytes must match the budgeted order (similar to above for OUTs).
 *	5) (core spec) Only 2^N periods are allowed.
 *	6) Classic (split) budget is based on best case times (specified by core spec), i.e. no bit stuffing.
 *		However, high speed budgets are based on worst case times, i.e. including bit stuffing.
 *	7) (EHCI req) Interrupt endpoints must be ordered in the frame from largest period to smallest period.
 *	8) (core spec and EHCI req) Interrupt endpoints have different numbers of CSs.  Ones near the end of
 *		a frame have 2, while others have 3.  EHCI requires that late endpoints DON'T have 3, so all
 *		endpoints can't be treated as having three (to try and allow unordered endpoints in a frame).
 *		It also might appear that early endpoints could be unordered, while later ones are ordered.
 *		However, as endpoints are allocated, a previously "undordered" endpoint would then need to
 *		become "ordered".  This seems to be a really hard transition, therefore all interrupt
 *		endpoints are required to be ordered in a frame.
 *
 * This scheduling algorithm depends on the HC transaction processing sequence:
 * 1) Interrupt endpoints are executed in decreasing period order (e.g. period 16 endpoint
 *    is executed before a period 8 endpoint).  Endpoints with the same period are
 *    executed in budget order.
 * 2) Interrupt endpoints are executed after all isochronous endpoints.
 * 3) Isochronous OUT endpoints longer than 188 bytes are executed in budget order.
 * 4) Isochronous IN periodic endpoints are executed in budget order. (must be so to ensure
 *    that CSs for endpoints occur in correct order, e.g. for different lengths)
 *		Note: this could be relaxed if more CSs were budgeted. 
 * 5) If there is a large isoch, it is first in the frame.
 *
 * When transactions are enqueued in the framelist HC data structures, the order
 * of the transactions must be the same as that budgeted.  This is so that when an endpoint
 * is allocated (inserted), the budget computation accurately determines the other affected endpoints.
 * The HC is required to process SSs and CSs for a set of endpoints for the same TT in the same order.
 * The act of creating the frame list ensures that this order is preserved (without
 * requiring any particular order to be explicitly created.
 * The physical framelist order from time to time can be different for interrupt endpoints,
 * but the TT is not sensitive to order.
 *
 * This algorithm computes budget order as determined in the routine OK_to_insert (below).
 *
 * Simplifying scheduling and HC assumptions:
 * a) The maximum allocation allowed is reduced by 30 (from 1157 to 1127 FS byte times)
 *    FS byte times to eliminate needing to deal with an end of frame wrap case
 *    that would require a TD back pointer.
 * b) Isoch IN transactions/endpoints longer than 1023-188-30 FS byte times are artifically
 *    processed (inserted) at the beginning of a frame.  This eliminates another
 *    end of frame wrap case.  Actually this is reduced to 1/2 a frame, since there can only be
 *	  one "large" transaction in a frame.
 * c) It is highly desirable to have the least impact on other endpoints due to an allocation.
 *
 * The isoch portion of the frame budget is maintained such that the frame time is "compacted".
 * I.e., there are no "holes" in the allocated frame time.
 *
 * In contrast, the interrupt portion of the frame budget has "holes" in the allocated frame time.
 * This is because the HC visits endpoints in the schedule in increasing period order, and we
 * must have the same SS/CS masks for all frames the endpoint is in, while a compacted budget
 * would require decreasing period order.
 *
 * The SS and CS masks used are only computed when the endpoint is configured.
 * This eliminates requiring different microframe patterns for different frames.
 * This also means that based on the presence of transactions for configured endpoints,
 * there can be "holes" in the periodic portion of the classic frame.  These holes can be
 * reclaimed and used for control and bulk classic transactions.
 *
 * Endpoints have a single "SS/CS microframe within frame" pattern for all frames
 * in which they have transfers.  This pattern is computed once when the endpoint is
 * configured.  It is also recomputed whenever other endpoints in the same frame have their
 * allocation time changed due to some other newly allocated endpoint.
 *
 * The budget frame list for FS/LS devices behind a TT, must be bound/tracked to/by
 * that TT.  A normal FS/LS frame bus time is maintained in addition to
 * the more detailed microframe pattern information.

 * Once the microframe pattern is determined, an HS allocation must be made of the
 * HS HC budget.  This HS allocation is done on a microframe basis for each SS/CS
 * that is required to support the classic device (and its TT).  The time for each
 * SS (and any data per microframe) is allocated in the appropriate microframe(s).
 * The time for each CS is allocated in the appropriate microframe(s).
 *
 * The data requirements (vs. overhead) for all classic IN endpoints for each TT should be tracked
 * for each HS microframe. The time for the data portion should never exceed 188 bytes
 * (inc. bitstuffing overhead) for CSs for all devices of a TT in a HS microframe.  SSs always
 * allocate the required time.  For CSs, the first classic device must allocate data time in
 * all microframes for all splits.  However, once the time in a HS microframe for a TT reaches
 * 188 data bytes, no more time needs to be allocated from the HS budget for data.  This is
 * because that is the most data that a classic bus can ever require.  It may take more split
 * transactions to move that data, but the amount of data can't increase.  The additional splits
 * just deal with the classic bus operation variation.
 *
 * The bus times for each period in the frame list must be updated for an endpoint. I.e.
 * multiple frame entries will need to be adjusted for periods smaller than the budgeting
 * window (i.e. MAXFRAMES).  A tree structure is used to link slower period endpoints from different
 * frames to the same endpoint of a faster period (similar to the periodic Qhead HC structure.
 * There is a tree for isoch endpoints and a separate tree for interrupt endpoints.
 * The endpoints lists rooted in each budget frame starts with a dummy SOF endpoint to make link
 * traversal easier (i.e. avoids an empty list case).
 *
 * All bus times are kept in byte time units (either HS or FS).  LS bus times are tracked
 * as appropriately scaled FS byte times.
 *
 * A general comment about processing flow in allocate and deallocate.  There are three processing
 * concepts.  All frames that an endpoint is allcoated within, must be visited to do the endpoint
 * specific processing.  However, other frames must also be visited to deal with the movement of
 * their budget times due to the changed endpoint.  Therefore all frames are always visited for
 * an allocation change.  As the frame list is walked, the "frame_bias" ranges over:
 *		(- ep->start_frame) + MAXFRAMES - 1 ... (- ep->start_frame)
 *	(frames are visited in reverse order)
 * But only in frames that are multiples of the endpoint's period are changes
 * made.  This causes some of the code "tracking" complexity.
 *
 * Comments about reconciling HC schedule and changed frame budgets:
 * When an isoch endpoint's microframe pattern is recomputed, currently pending transaction
 * requests are not manipulated.  But the new pattern does affect future transactions.
 * (Since the FS/LS device is expecting its transactions anywhere in the frame, the
 * microframe "jitter" that results is not relevant.)
 *
 * However, when an interrupt endpoint is inserted/removed in/from the middle of a frame, the
 * other endpoints (with pending/active transactions) affected must have their
 * transactions updated.  For interrupt endpoints, the split transaction masks are
 * in the queue head.  To change the interrupt masks:
 * 	1. the endpoint QH must be made inactive
 * 	2. the driver must wait for >= 1 frame time to ensure that the HC is not processing the QH
 *	3. the split masks are changed
 *	4. if the TD did an SS and didn't do a CS in the frame, the endpoint is halted to recover
 *	   (a nasty race condition, but hopefully rare)
 *	5. the QH is made active.
 *
 * To change isoch masks, the current pending/active TDs can be changed in place.
 * Existing error mechanisms can handle any race conditions with the HC.
 * 
 * There may be a corner condition in that the budget information shouldn't be used
 * (solely) to find transactions in the current schedule. If a client requests transactions
 * according to one budget and then the budget changes, and then the client wants to abort
 * the old transactions, I think the stack would normally use the budget to determine where
 * the transactions are in the schedule, but now the budget may identify "other"
 * microframes as having the transaction(s).  Coder beware!
 *
 * Classic HC allocation uses the microframe_info, microframe[0] to count the bandwidth allocation.
 *
 * History:
 *
 * 10-3-2000, JIG: fixed incorrect starting time and shift calculations for first interrupt and only large isoch
 * 10-4-2000, JIG: moved max allocation into TT and HC structs,
 *				   added inputfile ability to set TT/HC allocation_limit, TT/HC thinktime, and HC speed
 *				   made dump_budget not dump split info for classic HC
 *				   fixed duplicate thinktime addition in calc_bus_time for HS/FS nonsplit allocations
 *
 ****************************************************/

#include "common.h"


#if 0
int min (int a, int b)
{
    return (int) ((a<=b) ? a : b);
}

int max (int a, int b) 
{
    return (int) ((a>=b) ? a : b);
}
#endif

/**

	error
	
**/
error(char *s)
{
	// take some action for error, but
	// don't return to caller
	//printf("error called: %s.\n", s);
	DBGPRINT(("error called: %s.\n", s));
//	exit(1);
}

/*******

	Add_bitstuff
	
*******/

unsigned Add_bitstuff(
	unsigned bus_time)
{
	// Bit stuffing is 16.6666% extra.
	// But we'll calculate bitstuffing as 16% extra with an add of a 4bit
	// shift (i.e.  value + value/16) to avoid floats.
	return (bus_time + (bus_time>>4));
}

/*******

	Allocate_check
	
*******/

int Allocate_check(
	unsigned *used,
	unsigned newval,
	unsigned limit)
{
	int ok = 1;
	unsigned t;

	// check if this new allocation fits in the currently used amout below the limit.
	//
	t = *used + newval;
	// do allocation even if over limit.  This will be fixed/deallocated after the frame is finished.
	*used = t;

	if ( t > limit)
	{
		//printf("Allocation of %d+%d out of %d\n", *used, newval, limit);
		DBGPRINT(("Allocation of %d+%d out of %d\n", (*used-newval), newval, limit));
		error("Allocation check failed");
		ok = 0;
	}
	return ok;
}


/*******

	OK_to_Insert
	
*******/
int OK_to_insert(
	PEndpoint	curr,
	PEndpoint	newep
	)
{

	// Determine if this current endpoint in the budget frame endpoint list is the one before
	// which the new endpoint should be inserted.

	// DON'T call this routine if there is already a large isoch ep in this frame and this is a
	// large isoch ep!!

	// Called in a loop for each endpoint while walking the budget frame endpoint list in linkage order.

	// on exit when returns 1: curr points to the endpoint before which the new endpoint should be inserted.

	int insertion_OK = 0;
	/*
		There are separate endpoint budget "trees" for isoch and interrupt.  A budget tree has the same
		organization as the EHCI interrupt qhead tree.  This allows a single endpoint data structure to
		represent the allocation requirements in all frames allocated to the endpoint.

		Order of insertion in a budget frame list of endpoints is as follows for each list.

		Isoch:
		1. Endpoints in period order, largest period to smallest period
				(required to maintain endpoint linkages easily in a "Tree")
				(HC will actually enqueue isoch xacts in smallest period to largest period order)
			1a. within the same period
				newer endpoints are at the front of the sublist, older are at the end
				(Since isoch are visited by the HC in reverse order, this results in new
				 endpoints being added after older endpoints, thereby having least impact on existing
				 frame traffic)
		2. An endpoint larger than LARGEXACT bytes (only ever one possible per frame) is held separated
			from normal list
			(avoids having a long isoch that requires 2 uframes with SS and CS)
			Note that the endpoint could have a period different than 1

		Interrupt:
		1. Endpoints in period order, largest period to smallest period
				(required to maintain endpoint linkages easily in a "Tree")
			1.2 within same period, newer endpoints are at the end of the sublist, older are at the front

		Corresponding required (for this algorithm) order of transactions in HC frame list is:
		1. First, an isoch endpoint larger than LARGEXACT bytes (only ever one possible per frame)
			(avoids having a long isoch that requires 2 uframes with SS and CS)
			Note that the endpoint could have a period different than 1
		2. Isoch endpoint ITDs in INCREASING period order
			***** (NOTE: THIS IS opposite AS IN THE BUDGET LIST!!!!) *****
			2a. within the same period, oldest allocated eps are first, newest allocated are last
		3. interrupts endpoint Qheads in decreasing period order (in "tree" of qheads)
			3a. within the same period, oldest allocated (in time) eps are first, newest allocated are last
	*/

	if (newep->calc_bus_time < LARGEXACT)  // only really possible for isoch
	{
		if (curr)  // some endpoints already allocated
		{
			// This is the correct insertion point if the new ep has a period longer/larger
			// than the current ep (so put it before the current ep)

			// check if this is the correct period order
			if ( ((curr->actual_period < newep->actual_period) && newep->ep_type == interrupt) ||
				 ((curr->actual_period <= newep->actual_period) && newep->ep_type == isoch))
			{
				insertion_OK = 1;
			} else
				if (curr == newep) // we are at the current endpoint (due to inserting during a previous frame)
					insertion_OK = 1;
		} else
			insertion_OK = 1;  // if first endpoint, always "insert" at head

	} //else large xact, so this routine shouldn't be called since the large is held separately
		// This routine won't be called if there is already a large in this frame.

	return insertion_OK;
}



/*******

	Compute_last_isoch_time

********/
int Compute_last_isoch_time(
	PEndpoint ep,
	int frame
	)
{
	int t;
	PEndpoint p;

	p = ep->mytt->frame_budget[frame].isoch_ehead;  // dummy SOF
	p = p->next_ep; // potential real isoch, could be large isoch or other isoch
	if (p)
	{
		// There is an isoch, so use its start time (since it is the last isoch on the bus.
		t = p->start_time + p->calc_bus_time;
	} else // There aren't other, nonlarge isoch transactions in the frame
	{
		// If there is a large isoch, use that
		if (ep->mytt->frame_budget[frame].allocated_large)
		{
			p = ep->mytt->frame_budget[frame].allocated_large;
			t = p->start_time + p->calc_bus_time;
		} else
			// no isoch transactions
			t = FS_SOF;
	}
	return t;
}




/*******

	Compute_ep_start_time

********/
int Compute_ep_start_time(
	PEndpoint curr_ep,
	PEndpoint ep,
	PEndpoint last_ep,
	int frame
	)
{
	int t;
	PEndpoint p;

	// Given that there is a dummy SOF endpoint at the beginning of each list (always), there
	// is always a valid last_ep.  If the end of list is reached, curr_ep will be zero.

	// For isoch endpoints, the "next" ep on the list is the previous start time endpoint

	// For interrupt endpoint, the previous ep is the previous start time endpoint.
	// For interrupt endpoint, if this is the interrupt endpoint at the beginning of the int list
	// (after some isoch), the start time is the end of the isoch.

	if (curr_ep)  // we will do an insertion in the middle of the list
	{
		if (ep->ep_type == isoch)
		{
			t = curr_ep->start_time + curr_ep->calc_bus_time;
		} else // interrupt
		{
			if (last_ep == ep->mytt->frame_budget[frame].int_ehead) // new first interrupt ep
			{
				t = Compute_last_isoch_time(ep, frame);
			} else
				t = last_ep->start_time + last_ep->calc_bus_time;
		}
	} else  // empty list or have run off end of budget list
	{
		if (ep->ep_type == isoch)
		{
			if (ep->mytt->frame_budget[frame].allocated_large)
			{
				p = ep->mytt->frame_budget[frame].allocated_large;
				t = p->start_time + p->calc_bus_time;
			} else
				t = FS_SOF;
		} else  // interrupt
		{
			if (last_ep != ep->mytt->frame_budget[frame].int_ehead)  // is the last ep not the dummy SOF?
			{
				// non empty list, ran off end of interrupt list,
				// this is the last transaction in the frame
				t = last_ep->start_time + last_ep->calc_bus_time;
			} else  // was empty interrupt list
				t = Compute_last_isoch_time(ep, frame);
		}
	} // end if for first endpoint on list

	return t;
}




/*******

	Compute_nonsplit_overhead

********/
int Compute_nonsplit_overhead(
	PEndpoint	ep)
{
	PHC hc;

	hc = ep->mytt->myHC;

	if (ep->speed == HSSPEED)
	{
		if (ep->direction == OUTDIR)
		{
			if (ep->ep_type == isoch)
			{
				return HS_TOKEN_SAME_OVERHEAD + HS_DATA_SAME_OVERHEAD + hc->thinktime;
			} else // interrupt
			{
				return HS_TOKEN_SAME_OVERHEAD + HS_DATA_SAME_OVERHEAD +
					HS_HANDSHAKE_OVERHEAD + hc->thinktime;
			}
		} else
		{ // IN
			if (ep->ep_type == isoch)
			{
				return HS_TOKEN_TURN_OVERHEAD + HS_DATA_TURN_OVERHEAD + hc->thinktime;
				
			} else // interrupt
			{
				return HS_TOKEN_TURN_OVERHEAD + HS_DATA_TURN_OVERHEAD +
					HS_HANDSHAKE_OVERHEAD + hc->thinktime;
			}
		}  // end of IN overhead calculations
	} else  if (ep->speed == FSSPEED)
	{
		if (ep->ep_type == isoch)
		{
			return FS_ISOCH_OVERHEAD + hc->thinktime;
		} else // interrupt
		{
			return FS_INT_OVERHEAD + hc->thinktime;
		}
	} else  // LS
	{
		return LS_INT_OVERHEAD + hc->thinktime;
	}
}





/*******

	Compute_HS_Overheads

********/
Compute_HS_Overheads(
	PEndpoint	ep,
	int			*HS_SS,
	int			*HS_CS)
{
	PHC hc;

	hc = ep->mytt->myHC;

	if (ep->direction == OUTDIR)
	{
		if (ep->ep_type == isoch)
		{
			*HS_SS = HS_SPLIT_SAME_OVERHEAD + HS_DATA_SAME_OVERHEAD + hc->thinktime;
			*HS_CS = 0;
		} else // interrupt
		{
			*HS_SS = HS_SPLIT_SAME_OVERHEAD + HS_DATA_SAME_OVERHEAD + hc->thinktime;
			*HS_CS = HS_SPLIT_TURN_OVERHEAD + HS_HANDSHAKE_OVERHEAD + hc->thinktime;
		}
	} else
	{ // IN
		if (ep->ep_type == isoch)
		{
			*HS_SS = HS_SPLIT_SAME_OVERHEAD + hc->thinktime;
			*HS_CS = HS_SPLIT_TURN_OVERHEAD + HS_DATA_TURN_OVERHEAD + hc->thinktime;
			
		} else // interrupt
		{
			*HS_SS = HS_SPLIT_SAME_OVERHEAD + hc->thinktime;
			*HS_CS = HS_SPLIT_TURN_OVERHEAD + HS_DATA_TURN_OVERHEAD + hc->thinktime;
		}
	}  // end of IN overhead calculations
}





/*******

	Deallocate_HS

********/
Deallocate_HS(
	PEndpoint	ep,
	int			frame_bias)
{

	// 1.   Calculate last microframe for a nominal complete split
	// 2.   Calculate HS overheads
	// 3.   Deallocate HS split overhead time
	// 4.   Deallocate separate HS data bus time

	
	unsigned i, t, f, HS_SSoverhead, HS_CSoverhead, lastcs, min_used;
	int m;
	PHC hc;

	hc = ep->mytt->myHC;
	
	//***
	//*** 1. Calculate last microframe for a nominal complete split
	//***



	// determine last microframe for complete split (isoch in particular)
	//lastcs = floor( (ep->start_time + ep->calc_bus_time) / (float) FS_BYTES_PER_MICROFRAME) + 1;
    lastcs =  ( (ep->start_time + ep->calc_bus_time) /  FS_BYTES_PER_MICROFRAME) + 1;

	//***
	//*** 2. Calculate HS overheads
	//***



	Compute_HS_Overheads(ep, &HS_SSoverhead, &HS_CSoverhead);


	//***
	//*** 3. Deallocate HS split overhead time for this frame
	//***


	// Deallocate HS time for SS and CS overhead, but treat data differently

	// Deallocate HS start split bus time
	
	m = ep->start_microframe;
	f = ep->start_frame + frame_bias;

	if (m == -1)
	{
		m = 7;
		if (f == 0)
			f = MAXFRAMES - 1;
		else
			f--;
	}

	for (i=0;i < ep->num_starts; i++)
	{
		hc->HS_microframe_info[f][m].time_used -= HS_SSoverhead;

		ep->mytt->num_starts[f][m]--;

		m++;
		if (m > 7) {
			m = 0;
			f = (f + 1) % MAXFRAMES;
		}
	}


	// Deallocate HS complete split bus time
	if (ep->num_completes > 0)
	{
		m = ep->start_microframe + ep->num_starts + 1;
		f = ep->start_frame + frame_bias;

		for (i = 0; i < ep->num_completes; i++)
		{
			hc->HS_microframe_info[f][m].time_used -= HS_CSoverhead;

			m++;
			if (m > 7) {
				m = 0;
				f = (f + 1) % MAXFRAMES;
			}
		}
	}


	//***
	//*** 4. Deallocate separate HS data bus time
	//***



	// Deallocate HS data part of split bus time
	if (ep->direction) // OUT
	{
		// Deallocate full portion of data time in each microframe for OUTs

		m = ep->start_microframe;
		f = ep->start_frame + frame_bias;

		if (m == -1)
		{
			m = 7;
			if (f == 0)
				f = MAXFRAMES - 1;
			else
				f--;
		}

		for (i=0; i < ep->num_starts; i++) {
			min_used = min(
				FS_BYTES_PER_MICROFRAME,
			    Add_bitstuff(ep->max_packet) - FS_BYTES_PER_MICROFRAME * i);

			hc->HS_microframe_info[f][m].time_used -= min_used;

			m++;
			if (m > 7) {
				m = 0;
				f = (f + 1) % MAXFRAMES;
			}
		}
	} else // IN
	{
		// Only deallocate at most 188 bytes for all devices behind a TT in
		// each microframe.
		if (ep->num_completes > 0)
		{
			m = ep->start_microframe + ep->num_starts + 1;
			f = ep->start_frame + frame_bias;

			for (i=0; i < ep->num_completes; i++)
			{
				// update total HS bandwith due to devices behind this tt
				// This is used to determine when to deallocate HS bus time.
				ep->mytt->HS_split_data_time[f][m] -=
					min(Add_bitstuff(ep->max_packet), FS_BYTES_PER_MICROFRAME);

				// calculate remaining bytes this endpoint contributes
				// to 188 byte limit per microframe and (possible) HS deallocation.

				if (ep->mytt->HS_split_data_time[f][m] < FS_BYTES_PER_MICROFRAME)
				{
					// find adjustment to HS allocation for data
					t = min(
						// 
					    FS_BYTES_PER_MICROFRAME - ep->mytt->HS_split_data_time[f][m],
						Add_bitstuff(ep->max_packet));

					hc->HS_microframe_info[f][m].time_used -= t;
				}


				m++;
				if (m > 7) {
					m = 0;
					f = (f + 1) % MAXFRAMES;
				}
			}
		}
	}
}



/*******

	Allocate_HS

********/
int Allocate_HS(
	PEndpoint	ep,
	int			frame_bias)
{

	// 1.   Calculate start microframe
	// 2.   Calculate last microframe for a nominal complete split
	// 3.   Calculate number of SSs, CSs and HS overheads
	// 4.   Allocate HS split overhead time
	// 5.   Allocate separate HS data bus time

	
	unsigned i, t, f, HS_SSoverhead, HS_CSoverhead, lastcs, min_used;
	int m, retv;
	PHC hc;

	retv = 1;

	hc = ep->mytt->myHC;
	
	//***
	//*** 1. Calculate start microframe
	//***

	if (frame_bias == 0)
		// only update endpoint for first frame since other frames will simply
		// reference this endpoint (which has already had its information computed)

		//ep->start_microframe = floor(ep->start_time / (float) FS_BYTES_PER_MICROFRAME) - 1;
        ep->start_microframe = (ep->start_time /  FS_BYTES_PER_MICROFRAME) - 1;


	//***
	//*** 2. Calculate last microframe for a nominal complete split
	//***



		// determine last microframe for complete split (isoch in particular)
	//lastcs = floor( (ep->start_time + ep->calc_bus_time) / (float) FS_BYTES_PER_MICROFRAME) + 1;
    lastcs = ( (ep->start_time + ep->calc_bus_time) / FS_BYTES_PER_MICROFRAME) + 1;

	//***
	//*** 3. Calculate number of SSs, CSs and HS overheads
	//***


	Compute_HS_Overheads(ep, &HS_SSoverhead, &HS_CSoverhead);


	// determine number of splits (starts and completes)
	if (ep->direction == OUTDIR)
	{
		if (ep->ep_type == isoch)
		{
			if (frame_bias == 0) {
				ep->num_starts = (ep->max_packet / FS_BYTES_PER_MICROFRAME) + 1;
				ep->num_completes = 0;
			}
		} else // interrupt
		{
			if (frame_bias == 0) {
				ep->num_starts = 1;
				ep->num_completes = 2;
				if (ep->start_microframe + 1 < 6)
					ep->num_completes++;
			}
			}
	} else
	{ // IN
		if (ep->ep_type == isoch)
		{
			if (frame_bias == 0) {
				ep->num_starts = 1;
				ep->num_completes = lastcs - (ep->start_microframe + 1);
				if (lastcs <= 6)
				{
					if ((ep->start_microframe + 1) == 0)
						ep->num_completes++;
					else
						ep->num_completes += 2;  // this can cause one CS to be in the next frame
				}
				else if (lastcs == 7)
				{
					if ((ep->start_microframe + 1) != 0)
						ep->num_completes++;  // only one more CS if late in the frame.
				}
			}
			
		} else // interrupt
		{
			if (frame_bias == 0) {
				ep->num_starts = 1;
				ep->num_completes = 2;
				if (ep->start_microframe + 1 < 6)
					ep->num_completes++;
			}
		}
	}  // end of IN


	//***
	//*** 4. Allocate HS split overhead time for this frame
	//***


	// check avail time for HS splits
	// allocate HS time for SS and CS overhead, but treat data differently

	// allocate HS start split bus time
	
	m = ep->start_microframe;
	f = ep->start_frame + frame_bias;

	if (m == -1)
	{
		m = 7;
		if (f == 0)
			f = MAXFRAMES - 1;
		else
			f--;
	}

	for (i=0;i < ep->num_starts; i++)
	{
		// go ahead and do the allocations even if the checks fail.  This will be deallocated after the
		// frame is finished.
		if (!Allocate_check(
				&hc->HS_microframe_info[f][m].time_used,
				HS_SSoverhead,
				HS_MAX_PERIODIC_ALLOCATION))
			retv = 0;

		// Check for >16 SS in a microframe to one TT?  Maybe not needed in practice.
		if (ep->mytt->num_starts[f][m] + 1 > 16) {
			error("too many SSs in microframe");
			retv = 0;
		}

		ep->mytt->num_starts[f][m]++;

		m++;
		if (m > 7) {
			m = 0;
			f = (f + 1) % MAXFRAMES;
		}
	}


	// allocate HS complete split bus time
	if (ep->num_completes > 0)
	{
		m = ep->start_microframe + ep->num_starts + 1;
		f = ep->start_frame + frame_bias;

		for (i = 0; i < ep->num_completes; i++)
		{
			if (!Allocate_check(
					&hc->HS_microframe_info[f][m].time_used,
					HS_CSoverhead,
					HS_MAX_PERIODIC_ALLOCATION))
				retv = 0;

			m++;
			if (m > 7) {
				m = 0;
				f = (f + 1) % MAXFRAMES;
			}
		}
	}


	//***
	//*** 5. Allocate separate HS data bus time
	//***



	// allocate HS data part of split bus time
	if (ep->direction) // OUT
	{
		// allocate full portion of data time in each microframe for OUTs

		m = ep->start_microframe;
		f = ep->start_frame + frame_bias;

		if (m == -1)
		{
			m = 7;
			if (f == 0)
				f = MAXFRAMES - 1;
			else
				f--;
		}

		for (i=0; i < ep->num_starts; i++) {
			min_used = min(
				FS_BYTES_PER_MICROFRAME,
			    Add_bitstuff(ep->max_packet) - FS_BYTES_PER_MICROFRAME * i);

			if (! Allocate_check(
					&hc->HS_microframe_info[f][m].time_used,
					min_used,
					HS_MAX_PERIODIC_ALLOCATION))
				retv = 0;

			m++;
			if (m > 7) {
				m = 0;
				f = (f + 1) % MAXFRAMES;
			}
		}
	} else // IN
	{
		// Only allocate at most 188 bytes for all devices behind a TT in
		// each microframe.
		if (ep->num_completes > 0)
		{
			m = ep->start_microframe + ep->num_starts + 1;
			f = ep->start_frame + frame_bias;

			for (i=0; i < ep->num_completes; i++)
			{
				//calculate remaining bytes this endpoint contributes
				// to 188 byte limit per microframe and new (possible) HS allocation.

				if (ep->mytt->HS_split_data_time[f][m] < FS_BYTES_PER_MICROFRAME)
				{
					// find minimum required new contribution of this device:
					// either remaining bytes of maximum for TT or the bus time the
					// device can contribute
					t = min(
						// find maximum remaining bytes in this microframe for this tt.
						// Don't let it go to negative, which it could when device bus time
						// is greater than bytes per microframe (188)
						max(
						  FS_BYTES_PER_MICROFRAME -
						    ep->mytt->HS_split_data_time[f][m],
						  0),
						Add_bitstuff(ep->max_packet));

					if (! Allocate_check(
							&hc->HS_microframe_info[f][m].time_used,
							t,
							HS_MAX_PERIODIC_ALLOCATION))
						retv = 0;
				}

				// update total HS bandwith due to devices behind this tt
				// This is used in remove device to determine when to deallocate HS
				// bus time.
				ep->mytt->HS_split_data_time[f][m] +=
					min(Add_bitstuff(ep->max_packet), FS_BYTES_PER_MICROFRAME);

				m++;
				if (m > 7) {
					m = 0;
					f = (f + 1) % MAXFRAMES;
				}
			}
		}
	}
	return retv;
}



/*******

	Move_ep

********/
int Move_ep(
	PEndpoint	curr_ep,
	int			shift_time,
	PEndpoint	changed_ep_list[],
	int			*changed_eps,
	int			max_changed_eps,
	int			*err)
{
	int i, f;

	*err = 1;
	// Adjust endpoint allocation, if we haven't already done so.
	// This endpoint is adjusted to its new time.

	// For interrupt endpoints that are being moved due to deallocation, an endpoint can be moved more than once.
	// This can happen when recomputing the adjustment in some previous frame didn't allow the full movement to take place
	// because some later frame hadn't yet been recomputed (so it was inconsistent).  The later move brings it closer to
	// consistency.

	// check if we already have this endpoint from some previous frame
//	for (i = 0; i < *changed_eps; i++)
	for (i = 0; changed_ep_list[i] != 0; i++)
		//if ((changed_ep_list[i] == curr_ep) && (curr_ep->moved_this_req))
		if (changed_ep_list[i] == curr_ep) 
			break;

//	if ((i >= *changed_eps) ||  // haven't seen this endpoint before
//		((i < *changed_eps) && !curr_ep->moved_this_req) || // have seen this endpoint this pass
		if ((changed_ep_list[i] == 0) ||  // haven't seen this endpoint before
		((changed_ep_list[i] != 0) && !curr_ep->moved_this_req) || // have seen this endpoint this pass
		((curr_ep->ep_type == interrupt) && (shift_time < 0)) )
	{	// Update NEW changed endpoint

		// newly moved endpoints must have their HS bus time deallocated in all period frames in the budget window
		// (since the start_time can't be changed without affecting all frames the endpoint is in) 
		// then their start_time can be changed and the bus time reallocated for all period frames in the budget window
		for (f=0; (f + curr_ep->start_frame) < MAXFRAMES; f += curr_ep->actual_period)
			Deallocate_HS(curr_ep, f);

		curr_ep->start_time += shift_time;

		if ((curr_ep->start_time + curr_ep->calc_bus_time) > FS_MAX_PERIODIC_ALLOCATION)
		{
			error("end of new xact too late");
			*err = 0;
		}

		curr_ep->moved_this_req = 1;
		if (changed_ep_list[i] == 0)
		{

			// don't overrun bounds of array if too small
			if (i < max_changed_eps)
			{ 
				changed_ep_list[i] = curr_ep;
				changed_ep_list[i + 1] = 0; // zero terminated list
			} else
			{
				error("too many changed eps");
				*err = 0;
				// will be fixed after the frame is finished
			}

		} // already have this endpoint on the change list

		for (f=0; (f + curr_ep->start_frame) < MAXFRAMES; f += curr_ep->actual_period)
			if (! Allocate_HS(curr_ep, f))
				*err = 0;

		return 1;
	} else
		return 0;
}


/*******

	Common_frames

********/
int Common_frames(PEndpoint a, PEndpoint b)
{
	PEndpoint maxep, minep;

	/* Determine if the two endpoints are present in the same frames based on their
	*	start_frame and actual_period.
	*/

	if ((a->actual_period == 1) || (b->actual_period == 1))
		return 1;

	if (a->actual_period >= b->actual_period)
	{
		maxep = a;
		minep = b;
	}
	else
	{
		maxep = b;
		minep = a;
	}

	if ((maxep->start_frame % minep->actual_period) == minep->start_frame)
		return 1;
	else
		return 0;
}



/*******

	Deallocate_endpoint_budget

********/
int Deallocate_endpoint_budget(
	PEndpoint ep,					// endpoint that needs to be removed (bus time deallocated)
	PEndpoint changed_ep_list[],	// pointer to array to set (on return) with list of
									// changed endpoints
	int	*max_changed_eps,			// input: maximum size of (returned) list
									// on return: number of changed endpoints
	int partial_frames)				// number of partial frames that have been allocated
									// Normally MAXFRAMES, but this function is also used to unwind partial
									// allocations.
{
	/*

	 1. For each frame that endpoint is in:
	 2.		Deallocate HS bus time for this endpoint
	 3. 	Deallocate classic bus time
	 4.		Find where endpoint is
	 5.		Unlink this endpoint
	 6. 	For isoch:
	 7.			Compute gap
	 8.			For previous (larger/eq period) endpoint in this frame list
	 9.				move endpoint its new earlier position in the frame
						(skipping same period endpoints that have already been moved)
	10.			Setup to move interrupt endpoints
	11.		For interrupt:
	12.			For next (smaller/eq period) endpoint in this frame list
	13.				Compute gap
	14.				if ep is same period as gap, move it earlier
	15.				else  "ep has faster period"
	16.					check for gap in "sibling" dependent frames of ep
	17.					if gap in all, move ep earlier
	18.				if moved, do next ep

	*/

	int frame_bias, shift_time, changed_eps, moved, move_status;
	unsigned frame_cnt, gap_start, gap_end, i, j, siblings, gap_period;
	PEndpoint curr_ep, last_ep, p, head, gap_ep;

	// check that this endpoint is already allocated
	if (! ep->calc_bus_time)
	{
		error("endpoint not allocated");
		return 0;
	}

	// handle nonsplit HS deallocation
	if ((ep->speed == HSSPEED) && (ep->mytt->myHC->speed == HSSPEED))
	{
		for (i = (ep->start_frame*MICROFRAMES_PER_FRAME) + ep->start_microframe;
			i < MAXFRAMES*MICROFRAMES_PER_FRAME;
			i += ep->actual_period)
		{
			ep->mytt->myHC->HS_microframe_info[i/MICROFRAMES_PER_FRAME][
				i % MICROFRAMES_PER_FRAME].time_used -= ep->calc_bus_time;
		}
		ep->calc_bus_time = 0;
		return 1;
	} else  // split and nonsplit FS/LS deallocation
	{
		if ((ep->speed != HSSPEED) && (ep->mytt->myHC->speed != HSSPEED))
		{
			// do classic (nonsplit) deallocation for classic HC
			for (i = ep->start_frame; i < MAXFRAMES; i += ep->actual_period)
				ep->mytt->myHC->HS_microframe_info[i][0].time_used -= ep->calc_bus_time;
			ep->calc_bus_time = 0;
			return 1;
		}
	}


	changed_eps = 0;

	while (changed_ep_list[changed_eps])  // reset indicators of endpoints changed this pass.
	{
		changed_ep_list[changed_eps]->moved_this_req = 0;
		changed_eps++;
	}
	// this allows appending changed endpoints onto the current change list.
	
	frame_bias = ep->start_frame;
	frame_bias = (- frame_bias) + (partial_frames - 1);

	for (frame_cnt=partial_frames; frame_cnt > 0; frame_cnt--)
	{


	//***
	//*** 2. Deallocate HS bus time
	//***

		// Only do deallocation handling for frames this endpoint is located in
		if ((frame_bias % ep->actual_period) == 0)
		{
			Deallocate_HS(ep, frame_bias);


	//***
	//*** 3. Deallocate classic bus time
	//***


			ep->mytt->frame_budget[ep->start_frame + frame_bias].time_used -= ep->calc_bus_time;

		}



	//***
	//*** 4. Find where endpoint is
	//***


		// endpoint may not be in a particular frame since we process all frames, and the endpoint
		// can have a period greater than 1.  We process all frames, since the allocated times in a
		// frame can be affected by endpoint allocations in other frames.

		if (ep->ep_type == isoch)
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead;
			curr_ep = last_ep->next_ep;  // get past SOF endpoint
		} else
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead;
			curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint
		}


		// if this is not a large transaction, then search for it.
		if (ep->calc_bus_time <= LARGEXACT)
		{
			// walk endpoint list for this frame to find where to insert new endpoint
			while (curr_ep)
			{
				if (OK_to_insert(curr_ep, ep))
					break;
				last_ep = curr_ep;
				curr_ep = curr_ep->next_ep;
			}

			// The isoch search will stop at the beginning of the same period sublist.  The endpoint to be removed
			// could be further in the sublist, we need to check for that if the ep to be removed isn't the first
			// on the list.  However, if it turns out that the ep isn't in the list, we can't lose the initial
			// location

			if ((ep->ep_type == isoch) && curr_ep)
			{
				p = last_ep;

				while ((curr_ep->actual_period == ep->actual_period) && (curr_ep != ep))
				{
					last_ep = curr_ep;
					curr_ep = curr_ep->next_ep;
					if (curr_ep == 0)
					{
						// didn't find endpoint in list, so restore pointers back to initial location
						last_ep = p;
						curr_ep = last_ep->next_ep;
						break;
					}
				}
			}

		} else  // large transaction, so just get to the end of the isoch list to set up curr_ep and last_ep
		{
			while (curr_ep)
			{
				last_ep = curr_ep;
				curr_ep = curr_ep->next_ep;
			}

			// now set up curr_ep to point to the large endpoint, but leave last_ep pointing to the end of the isoch list
			curr_ep = ep;
		}


	//***
	//*** 5. Unlink endpoint
	//***

		// only unlink if the endpoint is in this frame
		if ((frame_bias % ep->actual_period) == 0)
		{

			if (ep->calc_bus_time <= LARGEXACT)
			{

//				if ((curr_ep == 0) && ((frame_bias % ep->actual_period) == 0))
				if (curr_ep != 0)
				{
					last_ep->next_ep = curr_ep->next_ep;
					curr_ep = curr_ep->next_ep;
				}
			} else
				ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large = 0;

		}  // processing of frames this endpoint is in

		gap_ep = ep;
		gap_period = gap_ep->actual_period;



	//***
	//*** 6. For isoch
	//***


		if (ep->ep_type == isoch)
		{

			// For isoch, when we find the deallocated endpoint in a frame, all isoch endpoints after it must
			// be compacted (moved earlier).  Since the isoch portion of the frame is kept in increasing period
			// order and is compacted, a deallocation results in a recompacted budget.


	//***
	//*** 7. Compute gap
	//***


			head = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead;

			gap_start = ep->start_time;
			gap_end = gap_start + ep->calc_bus_time;

			// If the deallocated endpoint is the large one and not period 1, we must check for siblings before
			// compacting, since large allocations in other frames can prevent a compaction

			if ((ep->calc_bus_time > LARGEXACT) && (ep->actual_period != 1))
			{
				for (i = 0; i < ep->actual_period; i++)
				{
					if (i != ep->start_frame)
					{
						p = ep->mytt->frame_budget[i].allocated_large;
						if (p)
							if (p->start_time + p->calc_bus_time - 1 > gap_start)
							{
								gap_start = p->start_time + p->calc_bus_time;
								if (gap_end - gap_start <= 0)
									break;
							}
					}
				}
			}



	//***
	//*** 8. For previous (larger/eq period) endpoint in this frame list
	//***


			if (gap_end - gap_start > 0)
			{
				// if large isoch is the one deallocated, update gap period based on the period of the last isoch
				// in this frame
				if ((ep->calc_bus_time > LARGEXACT) && (last_ep->actual_period < gap_period))
					gap_period = last_ep->actual_period;

				while (last_ep != head)
				{

					// The isoch list is "backwards", so curr_ep is earlier in the frame and last_ep is later.
					// Compute the gap accordingly.

					// curr_ep and last_ep are normally valid endpoints, but there are some corner conditions:
					// a) curr_ep can be null when the ep isn't found, but we won't be here if that's true.
					// b) last_ep can be dummy_sof when ep is newest, slowest period endpoint, but that will be
					//		handled as part of the interrupt ep handling initial conditions (and we won't get here)


	//***
	//*** 9.				move endpoint its new earlier position in the frame
	//***					(skipping same period endpoints that have already been moved)
	//***


					shift_time = gap_end - gap_start;

					if (shift_time > 0)
					{
						moved = Move_ep(
							last_ep,
							- shift_time,
							changed_ep_list,
							&changed_eps,
							*max_changed_eps,
							&move_status);
						if (! move_status)
							error("deallocation move failure!!");  //<<few things can go wrong here, but num eps could >>

						if (! moved)
							break;	// since we have found the part of the frame tree that has already been moved
									// previous frames.
					}

					// rewalk isoch list until we get to "previous" endpoint in list/frame.
					// This will be a little nasty since the isoch tree is linked in the opposite order that we
					// really need to walk the frame to "compact".  Simply re-walk the isoch tree for this frame
					// from the head until we get to the previous. This is mostly ok since the isoch tree is
					// extremely likely to be normally very short so the processing hit of rewalking the list will
					// normally be small.

					p = last_ep;
					last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead;
					curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint

					// This test always terminates since we can't run off the end of the list due to the entry
					// condition of the last_ep not being the (dummy) head.
					while (curr_ep != p)
					{
						last_ep = curr_ep;
						curr_ep = curr_ep->next_ep;
					}

				} // end of isoch endpoints in frame
			}  // end of shift handling



	//***
	//*** 10.			Setup to move interrupt endpoints
	//***


			last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead;
			curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint

			// if there is an isoch endpoint, use the last one as the last_ep for interrupt budget
			// processing to allow correct computation of the previous transaction end time.
			// if there is a non-large isoch endpoint, use it other if there is a large isoch use that
			// otherwise, leave the dummy sof interrupt endpoint as last
			if (ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead->next_ep)
				last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead->next_ep;
			else if (ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large)
				last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large;

		} // end isoch



	//***
	//*** 11.		For interrupt
	//***


		// The interrupt frame budget can have "holes" of unallocated time in a frame.  These holes
		// can be caused by some endpoint in one frame forcing an endpoint in another frame to be later
		// in the frame to avoid collisions.  In order to compact after a deallocation, we have to ensure
		// that the gap exists in all frames of an endpoint that is a candidate to move.

		// An endpoint that has an end time that is greater than ep's start time (but less than the
		// end time) advances the gap start time to the (previous) endpoint's end time.
		// An endpoint that has a start time that is less than the ep's end time (but greater than the
		// start time) reduces the end time to the (later) endpoint's start time.
		//
		// If the gap end time is greater than the gap start time, we have to move affected endpoints by that
		// amount.  Otherwise, no endpoints are affected by the removal in this frame.


		// if this is the first interrupt on the endpoint list, fixup the last_ep pointer for the gap computation
		if ((ep->ep_type == interrupt) && (last_ep == ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead))
		{
			if (ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead->next_ep)
				last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead->next_ep;
			else if (ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large)
				last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large;
		}


	//***
	//*** 12.			For next (smaller/eq period) endpoint in this frame list 
	//***


		while (curr_ep)
		{



	//***
	//*** 13.				Compute gap				 
	//***


			gap_start = last_ep->start_time + last_ep->calc_bus_time;
			gap_end = curr_ep->start_time;

			moved = 0;

	//***
	//*** 14.				if ep is same or larger period than gap, move it earlier 
	//***


			if ((gap_period <= curr_ep->actual_period) && (gap_ep->start_frame == curr_ep->start_frame))
			{
				shift_time = gap_end - gap_start;

				if (shift_time > 0)
				{
					moved = Move_ep(
						curr_ep,
						- shift_time,
						changed_ep_list,
						&changed_eps,
						*max_changed_eps,
						&move_status);
					if (! move_status)
						error("deallocate move failure 2");  // <<few things, but num eps could fail here>>
				}
			} else // move candidate has a smaller interrupt period or has a different start_frame
			{


	//***
	//*** 15.				else  "ep has faster period or different start_frame"
	//***



	//***
	//*** 16.					check for gap in "sibling" dependent frames of ep
	//***

				// siblings are the other frames that the curr_ep is dependent upon.  E.g. if curr period
				// is 1 and gap_period is 8, there are 7 other frames that need to be checked for a gap
				if (Common_frames(curr_ep, ep))
					siblings = (gap_period / curr_ep->actual_period);
				else // move candidate is not in frames occupied by deleted endpoint
					siblings = MAXFRAMES / curr_ep->actual_period;

				j = curr_ep->start_frame;

				for (i = 0; i < siblings; i++)
				{
					// find curr_ep in new sibling frame to check gap
					// We only look in frames that we know the curr_ep is in.
					// We can look in frames that aren't affected by the deleted ep, but don't optimize for now.

					// skip the gap start frame since we already know it has a gap
					if (j != gap_ep->start_frame) {
						
						last_ep = ep->mytt->frame_budget[j].int_ehead;
						p = last_ep->next_ep;

						// fixup last_ep if this is the first interrupt ep in the frame after some isoch.
						if (ep->mytt->frame_budget[j].isoch_ehead->next_ep)
							last_ep = ep->mytt->frame_budget[j].isoch_ehead->next_ep;
						else if (ep->mytt->frame_budget[j].allocated_large)
							last_ep = ep->mytt->frame_budget[j].allocated_large;
						
						while (p && (p != curr_ep))
						{
							last_ep = p;
							p = p->next_ep;
						}

						if (last_ep->start_time + last_ep->calc_bus_time - 1 > gap_start)
						{
							gap_start = last_ep->start_time + last_ep->calc_bus_time;
							if (gap_end - gap_start <= 0)
								break;
						}
					}
					j += curr_ep->actual_period;
				}


	//***
	//*** 17.					if gap in all, move ep earlier
	//***


				shift_time = gap_end - gap_start;

				if (shift_time > 0)
				{
					moved = Move_ep(
						curr_ep,
						- shift_time,
						changed_ep_list,
						&changed_eps,
						*max_changed_eps,
						&move_status);
					if (! move_status)
						error("deallocate move failure 3"); //  << few things, but num eps could fail here>>
				}
			}  // end of faster period interrupt endpoint move candidate


	//***
	//*** 18.				if moved, do next ep
	//***


			if (!moved)
				break;

			gap_ep = curr_ep;
			if (gap_period > curr_ep->actual_period)
				gap_period = curr_ep->actual_period;

			last_ep = curr_ep;
			curr_ep = curr_ep->next_ep;
		} // end interrupt endpoints in frame

		frame_bias--;
	}  // end for all frames


	ep->calc_bus_time = 0;

	return 1;
}






/*******

	Allocate_time_for_endpoint

********/
int Allocate_time_for_endpoint(
	PEndpoint ep,					// endpoint that needs to be configured (bus time allocated)
	PEndpoint changed_ep_list[],	// pointer to array to set (on return) with list of
									// changed endpoints
	int	*max_changed_eps			// input: maximum size of (returned) list
									// on return: number of changed endpoints
	)
{
	int shift_time, frame_bias, moved, retv, move_status;
	unsigned t, overhead, changed_eps, i, min_used, latest_start, frame_cnt;
	PEndpoint curr_ep, last_ep, p;

	changed_eps = 0;

	retv = 1;

	// OVERVIEW of algorithm steps:
	//  1. Determine starting frame # for period
	//  2. Calculate classic time required
	//  3. For all period frames, find the latest starting time so we can check the classic allocation later
	//  4. Process each frame data structure for endpoint period in budget window
	//  5.   Now check allocation for each frame using shift adjustment based on latest start time
	//  6a.  Now move isoch endpoints, insert new isoch and then move interrupt endpoints
	//  6b.	 Now insert new interrupt and move rest of interrupt endpoints
	//	7.   Allocate HS bus time
	//  8.   Allocate classic bus time


	//***
	//*** 1. Determine starting frame # for period
	//***



	// Also remember the maximum frame time allocation since it will be used to pass the allocation check.

	// Find starting frame number for reasonable balance of all classic frames

	ep->start_frame = 0;
	ep->start_microframe = 0;
	ep->num_completes = 0;
	ep->num_starts = 0;

	// check that this endpoint isn't already allocated
	if (ep->calc_bus_time)
	{
		error("endpoint already allocated");
		return 0;
	}

	// handle nonsplit HS allocation
//	if ((ep->speed == HSSPEED) && (ep->mytt->myHC->speed == HSSPEED)) {
	if (ep->speed == HSSPEED) {

		min_used = ep->mytt->myHC->HS_microframe_info[0][0].time_used;

		if (ep->period > MAXFRAMES*MICROFRAMES_PER_FRAME)
			ep->actual_period = MAXFRAMES*MICROFRAMES_PER_FRAME;
		else
			ep->actual_period = ep->period;

		// Look at all candidate frames for this period to find the one with min
		// allocated bus time.  
		//
		for (i=1; i < ep->actual_period; i++)
		{
			if (ep->mytt->myHC->HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used < min_used)
			{
				min_used = ep->mytt->myHC->HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used;
				ep->start_frame = i/MICROFRAMES_PER_FRAME;
				ep->start_microframe = i % MICROFRAMES_PER_FRAME;
			}
		}

		// compute and allocate HS bandwidth
		ep->calc_bus_time = Compute_nonsplit_overhead(ep) + Add_bitstuff(ep->max_packet);
		for (i = (ep->start_frame*MICROFRAMES_PER_FRAME) + ep->start_microframe;
			i < MAXFRAMES*MICROFRAMES_PER_FRAME;
			i += ep->actual_period)
		{
			if (! Allocate_check(
				&(ep->mytt->myHC->HS_microframe_info[i/MICROFRAMES_PER_FRAME][
						i % MICROFRAMES_PER_FRAME].time_used),
				ep->calc_bus_time,
				HS_MAX_PERIODIC_ALLOCATION))
			  retv = 0;
		}
		if (! retv)  // if allocation failed, deallocate
		{
			for (i = (ep->start_frame*MICROFRAMES_PER_FRAME) + ep->start_microframe;
				i < MAXFRAMES*MICROFRAMES_PER_FRAME;
				i += ep->actual_period)
			{
				ep->mytt->myHC->HS_microframe_info[i/MICROFRAMES_PER_FRAME][
					i % MICROFRAMES_PER_FRAME].time_used -= ep->calc_bus_time;
			}
		}
		return retv;
	} else  {
		// split or nonsplit FS/LS speed allocation
		// classic allocation
		if ((ep->speed != HSSPEED) && (ep->mytt->myHC->speed != HSSPEED)) {
			min_used = ep->mytt->myHC->HS_microframe_info[0][0].time_used;

			if (ep->period > MAXFRAMES)
				ep->actual_period = MAXFRAMES;
			else
				ep->actual_period = ep->period;

			// Look at all candidate frames for this period to find the one with min
			// allocated bus time.  
			//
			for (i=1; i < ep->actual_period ; i++)
			{
				if (ep->mytt->myHC->HS_microframe_info[i][0].time_used < min_used)
				{
					min_used = ep->mytt->myHC->HS_microframe_info[i][0].time_used;
					ep->start_frame = i;
				}
			}

			// compute and allocate FS/LS bandwidth
			ep->calc_bus_time = Compute_nonsplit_overhead(ep) +
				Add_bitstuff((ep->speed?1:8) * ep->max_packet);

			for (i = ep->start_frame; i < MAXFRAMES; i += ep->actual_period) {
				t = ep->mytt->myHC->HS_microframe_info[i][0].time_used;  // can't take address of bitfield (below)
				if (! Allocate_check( &t, ep->calc_bus_time, FS_MAX_PERIODIC_ALLOCATION))
				  retv = 0;
				ep->mytt->myHC->HS_microframe_info[i][0].time_used =	t;
			}
			if (! retv) {
				for (i = ep->start_frame; i < MAXFRAMES; i += ep->actual_period)
					ep->mytt->myHC->HS_microframe_info[i][0].time_used -= ep->calc_bus_time;
			}
			return retv;
		} else {
			// split allocation
			min_used = ep->mytt->frame_budget[0].time_used;

			if (ep->period > MAXFRAMES)
				ep->actual_period = MAXFRAMES;
			else
				ep->actual_period = ep->period;

			// Look at all candidate frames for this period to find the one with min
			// allocated bus time.  
			//
			for (i=1; i < ep->actual_period ; i++) {
				if (ep->mytt->frame_budget[i].time_used < min_used) {
					min_used = ep->mytt->frame_budget[i].time_used;
					ep->start_frame = i;
				}
			}
		}
	}

	// above handles all speeds, the rest of this code is for split transaction processing



	// There could be multiple frames with a minimum already allocated bus time.
	// If there is a frame where this ep would be added at the end of the frame,
	// we can avoid doing an insert (which requires other endpoints to be adjusted).
	// Currently we don't look for that optimization.  It would involve checking the
	// frame endpoint list to see if the new endpoint would be the last and if not
	// going back to see if there is another candidate frame and trying again (until
	// there are no more candidate frames).  We could also keep track of the candidate
	// frame that had the least affect on other endpoints (for the case where there
	// is a frame that makes the new endpoint closest to last).

	// <<attempt later maybe>>??



	//***
	//*** 2. Calculate classic time required
	//***

	// Calculate classic overhead
	if (ep->ep_type == isoch)
	{
		if (ep->speed == FSSPEED)
			overhead = FS_ISOCH_OVERHEAD + ep->mytt->think_time;
		else
		{
			error("low speed isoch illegal"); // illegal, LS isoch
			return 0;
		}
	} else
	{ // interrupt
		if (ep->speed == FSSPEED)
			overhead = FS_INT_OVERHEAD + ep->mytt->think_time;
		else
			overhead = LS_INT_OVERHEAD + ep->mytt->think_time;
	}

	// Classic bus time, NOT including bitstuffing overhead (in FS byte times) since we do best case budget
	ep->calc_bus_time = ep->max_packet * (ep->speed?1:8) + overhead;



	//***
	//*** 3. For all period frames, find the latest starting time so we can check the classic allocation later.
	//***

	//	Checking the classic allocation takes two passes through the frame/endpoint lists.
	//	Or else we would have to remember the last/curr ep pointers for each period frame and loop back
	//	through that list the second time. (<<Future optimization?>>)

	//	To find the start time to use for the new endpoint: for each frame, find the insertion point and use
	//	the "previous" endpoint in the FRAME. Use the previous endpoint end time as a possible start time
	//	for this new endpoint. Use the end time instead of the insertion point start time since there can
	//	before endpoints and we want to allocate as contiguously as possible.  Using this time, find the latest
	//	start be unallocated time time across all frames (this keeps the early part of the frame as allocated as
	//	possible to avoid having to worry about fragmentation of	time (and even more complexity).
	//
	//	Once the final start time is known, then for each frame, check the allocation required in each frame.
	//	The total frame allocation is actually the time of the ending of the last transaction in the frame.
	//	It is possible that a new allocation can fit in an unallocated "gap" between two other allocated
	//	endpoints of slower periods. The new allocation is therefore any shift required of later endpoints in
	//	the frame.
	//
	//	The shift is computed as:
	//		shift = (final_start_time + new.calc_bus_time) - curr.start_time
	//	If shift is positive, later endpoints must be moved by the shift amount, otherwise later endpoints
	//	(and the frame allocation) aren't affected.

	latest_start = FS_SOF + HUB_FS_ADJ;  // initial start time must be after the SOF transaction

	// find latest start
	for (i=0; ep->start_frame + i < MAXFRAMES; i += ep->actual_period)
	{
		if (ep->ep_type == isoch)
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + i].isoch_ehead;
			curr_ep = last_ep->next_ep;  // get past SOF endpoint
		} else
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + i].int_ehead;
			curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint
		}

		// if this frame has a large transaction endpoint, make sure we don't allocate another one
		if (ep->mytt->frame_budget[ep->start_frame + i].allocated_large)
		{
			if (ep->calc_bus_time >= LARGEXACT)
			{
				error("too many large xacts");  // only one large transaction allowed in a frame.
				return 0;
			}
		}

		while (curr_ep)  // walk endpoint list for this frame to find where to insert new endpoint
		{
			// Note: the actual insertion will be done later
			//

			if (OK_to_insert(curr_ep, ep))
			{
				break;
			}
			last_ep = curr_ep;
			curr_ep = curr_ep->next_ep;
		}

		t = Compute_ep_start_time(curr_ep, ep, last_ep, ep->start_frame + i);

		// update latest start time as required
		if (t > latest_start)
			latest_start = t;
	} // end of for loop looking for latest start time


	// Set the start time for the new endpoint
	ep->start_time = latest_start;
	
	if ((ep->start_time + ep->calc_bus_time) > FS_MAX_PERIODIC_ALLOCATION)
	{
//		error("start time %d past end of frame", ep->start_time + ep->calc_bus_time);
		ep->calc_bus_time = 0;
		return 0;
	}


	//***
	//*** 4.  Process each frame data structure for endpoint period in budget window
	//***


	changed_eps = 0;	// Track number of endpoints that will need to be updated.

	while (changed_ep_list[changed_eps])  // reset indicators of endpoints changed this pass.
	{
		changed_ep_list[changed_eps]->moved_this_req = 0;
		changed_eps++;
	}
	// this allows appending changed endpoints onto the current change list.

	// We have to check the allocation of this new endpoint in each frame.  We also have to move any
	// later endpoints in the frame to their new start times (and adjust their SS/CS allocations as
	// appropriate).
	//
	// Doing this is tricky since:
	//	A. The actual isoch portion of the frame is organized in reverse order in the budget list
	//	B. If a large isoch transaction exists in this frame, it is first in the frame
	//
	// For a new isoch ep:
	//	We have to find the shift for this endpoint.
	//	We have to move isoch endpoints up to (but not including) the isoch insertion point endpoint
	//  We also have to move all interrupt endpoints (to the end of the list and frame) after we
	//	finish the isoch endpoints.
	//
	// For a new interrupt ep:
	//	skip to the insertion point without doing anything
	//	then move the start times of the rest of the interrupt endpoints until the end of the list (and frame)
	//

	// Allocate time in each frame of the endpoint period in the budgeting window.
	//
	// Since the interrupt frame budget is ordered with decreasing period (with holes in the budget),
	// we must process all frames in the budget window to correctly move any smaller period interrupt
	// endpoints that are affected by this new enpoint, even though the new endpoint is only added in
	// its period frames

	frame_bias = ep->start_frame;
	frame_bias = - frame_bias;

	for (frame_cnt=0; frame_cnt < MAXFRAMES; frame_cnt++)
	{


	//***
	//*** 5. Now check allocation for each frame using shift adjustment based on latest start time
	//***

		if (ep->ep_type == isoch)
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead;
			curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint

			p = last_ep;  // save the starting point so we can start over after finding the shift time

			// walk endpoint list for this frame to find where to insert new endpoint
			while (curr_ep)
			{
				// Note: the actual insertion will be done later, this just does the allocation check
				//

				if (OK_to_insert(curr_ep, ep))
					break;

				last_ep = curr_ep;
				curr_ep = curr_ep->next_ep;
			}

			//	shift = (final_start_time + new.calc_bus_time) - curr.start_time
			// for isoch the last_ep is the endpoint before which the new one is inserted, i.e. it is "curr"
			if (last_ep != ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead)
				// This is somewhere in the "middle" of the list
				shift_time = (latest_start + ep->calc_bus_time) - last_ep->start_time;
			else
			{
				if (curr_ep)
				{
					// There is only one endpoint on the list, so must use 1st (non dummy SOF) int endpoint as
					// next ep in frame (if there is one)
					if (ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead->next_ep)
						shift_time = (latest_start + ep->calc_bus_time) -
										ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead->next_ep->start_time;
					else  // no int endpoints
						shift_time = 0;
				} else
					// There are no endpoints on the isoch list
					shift_time = ep->calc_bus_time;
			}

			//
			// Check classic allocation
			//

			// check that if new ep is at end of frame, it will fit in the frame
			//if ((ep->start_time + ep->calc_bus_time) > FS_MAX_PERIODIC_ALLOCATION)
			//{
			//	error("new xact too late in frame");
			//	Deallocate_endpoint_budget(ep, changed_ep_list, max_changed_eps, frame_cnt);
			//	return 0;
			//}

			// check classic allocation with adjusted start time before proceeding
			if (shift_time > 0)
			{
				// worst frame test to stop remaining processing as early as possible.
				t = ep->mytt->frame_budget[ep->start_frame + frame_bias].time_used;
				if ( ! Allocate_check(&t, shift_time, FS_MAX_PERIODIC_ALLOCATION))
				{
					Deallocate_endpoint_budget(ep, changed_ep_list, max_changed_eps, frame_cnt);
					return 0;
				}
			}


	//***
	//*** 6a. Now move isoch endpoints, insert new isoch and then move interrupt endpoints
	//***


			last_ep = p;
			curr_ep = last_ep->next_ep;

			// Walk endpoint list for this frame to find where to insert new isoch endpoint.
			// This time we move later isoch endpoints in frame (early endpoints on budget list)
			while (curr_ep)
			{

				if (! OK_to_insert(curr_ep, ep))
				{
					if (shift_time > 0) {
						moved = Move_ep(
							curr_ep,
							shift_time,
							changed_ep_list,
							&changed_eps,
							*max_changed_eps,
							&move_status);

						if (! move_status)
							retv = 0;

						if (! moved)  // already have visited the endpoints from here on in this frame
							break;
					}
				} else  // insert new endpoint here
					break;

				last_ep = curr_ep;
				curr_ep = curr_ep->next_ep;
			}

			// Don't insert endpoint if its already been inserted and processed due to a previous endpoint
			//
			if (curr_ep != ep) {
				if ((frame_bias % ep->actual_period) == 0)
				// Only allocate new endpoint in its period frames 
				{
					// insert new endpoint
					if (ep->calc_bus_time >= LARGEXACT)
					{
						// save the large ep pointer
						ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large = ep;
				
						// we don't link the large onto any other endpoints
					} else
					{  // not large, so link the endpoint onto the list
						if (frame_bias == 0)
							ep->next_ep = curr_ep;
						last_ep->next_ep = ep;
					}
				}

				// now move all interrupt endpoints
				// find end of last isoch ep and check if it is after start of first interrupt, if so, interrupt
				// eps must be shifted

				p = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead; // sof

				if (p->next_ep)
					p = p->next_ep;  // last actual isoch , could be null when no isoch allocated in this frame
				else
					if (ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large)
						p = ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large;
					
				last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead;
				curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint

				if (curr_ep) {  // only move interrupt endpoints that are there

					if ((p->start_time + p->calc_bus_time) > curr_ep->start_time) {
			

						// Compute the shift time for all following interrupt endpoints ONCE.  Then
						// apply it to all endpoints.  This ensures that any gaps between endpoints are
						// preserved without compression.
						shift_time = p->start_time + p->calc_bus_time - curr_ep->start_time;

						while (curr_ep)
						{
							// Note: this doesn't do any insertion, just adjusts start times of interrupt eps
							// we haven't seen yet

							//  << this can exit once it finds an ep we have already seen>>
							moved = Move_ep(
								curr_ep,
								shift_time,
								changed_ep_list,
								&changed_eps,
								*max_changed_eps,
								&move_status);
							if (! move_status)
								retv = 0;

							if (! moved)
								break;

							last_ep = curr_ep;
							curr_ep = curr_ep->next_ep;
						}
					}
				}
			}

		} else  // interrupt
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead;
			curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint

			// walk endpoint list for this frame to find where to insert new endpoint
			while (curr_ep)
			{
				// Note: the actual insertion will be done later, this just does the allocation check
				//

				if (OK_to_insert(curr_ep, ep))
					break;

				last_ep = curr_ep;
				curr_ep = curr_ep->next_ep;
			}

			//	shift = (final_start_time + new.calc_bus_time) - curr.start_time
			if (curr_ep)
				shift_time = (latest_start + ep->calc_bus_time) - curr_ep->start_time;
			else
				shift_time = ep->calc_bus_time;


			// only change endpoints in frame if the new interrupt endpoint is in this frame
			if ((frame_bias % ep->actual_period) == 0)
			{
				shift_time = 0;
			}


			//
			// Check classic allocation
			//

			// check classic allocation with adjusted start time before proceeding
			if (shift_time > 0)
			{
				// worst frame test to stop remaining processing as early as possible.
				t = ep->mytt->frame_budget[ep->start_frame + frame_bias].time_used;
				if ( ! Allocate_check(&t, shift_time, FS_MAX_PERIODIC_ALLOCATION))
					retv = 0;
			}


	//***
	//*** 6b. Now insert new interrupt endpoint and move rest of interrupt endpoints
	//***


			// insert new endpoint
			if (curr_ep != ep) {
				if ((frame_bias % ep->actual_period) == 0) {
					// Only allocate new endpoint in its period frames 
					if (frame_bias == 0)
						ep->next_ep = curr_ep;

					last_ep->next_ep = ep;
					last_ep = ep;
				}

				if (shift_time > 0) {
					while (curr_ep)
					{
						// Move the rest of the interrupt endpoints
						//

						moved = Move_ep(
							curr_ep,
							shift_time,
							changed_ep_list,
							&changed_eps,
							*max_changed_eps,
							&move_status);
						if (! move_status)
							retv = 0;

						if (! moved)
							break;

						last_ep = curr_ep;
						curr_ep = curr_ep->next_ep;
					}
				}
			}
		} // end of interrupt insertion handling


	//***
	//*** 7. Allocate HS bus time for endpoint
	//***

		if (frame_bias % ep->actual_period == 0)  // Only allocate new endpoint in its period frames
		{
			if (! Allocate_HS(ep, frame_bias))
				retv = 0;

	//***
	//*** 8. Allocate classic bus time
	//***


			ep->mytt->frame_budget[ep->start_frame + frame_bias].time_used += ep->calc_bus_time;
		}

		if (!retv)
		{
			// some error in this frame, so do partial deallocation and exit
			Deallocate_endpoint_budget(ep, changed_ep_list, max_changed_eps, frame_cnt + 1);
			return 0;
		}

		frame_bias++;

	} // end of "for each frame in budget window"

	return retv;
}





/*******

	Deallocate_time_for_endpoint

********/
void
Deallocate_time_for_endpoint(
	PEndpoint ep,					// endpoint that needs to be removed (bus time deallocated)
	PEndpoint changed_ep_list[],	// pointer to array to set (on return) with list of
									// changed endpoints
	int	*max_changed_eps			// input: maximum size of (returned) list
									// on return: number of changed endpoints
	)
{
	// Deallocate all frames of information
	Deallocate_endpoint_budget(ep, changed_ep_list,max_changed_eps, MAXFRAMES);
}










/*******

	Set_endpoint()

********/
Set_endpoint(
	PEndpoint	ep,
	eptype		t,
	unsigned	d,
	unsigned	s,
	unsigned	p,
	unsigned	m,
	TT			*thistt
	)
{
	ep->ep_type = t;
	ep->direction = d;
	ep->speed = s;
	ep->period = p;
	ep->max_packet = m;
	ep->mytt = thistt;
	ep->calc_bus_time = 0;
	ep->start_frame = 0;
	ep->start_microframe = 0;
	ep->start_time = 0;
	ep->num_starts = 0;
	ep->num_completes = 0;
	ep->actual_period = 0;
	ep->next_ep = 0;
	ep->saved_period = 0;
	ep->promoted_this_time = 0;
	ep->id = 0;  // not needed for real budgeter
}

void
init_hc(PHC myHC)
{
	int i,j;
	PEndpoint ep;

	// allocate at TT to test with
	//myHC.tthead = (PTT) malloc(sizeof(TT));
	myHC->thinktime = HS_HC_THINK_TIME;
	myHC->allocation_limit = HS_MAX_PERIODIC_ALLOCATION;
	myHC->speed = HSSPEED;

	for (i=0; i<MAXFRAMES; i++)
	{

		for (j=0; j < MICROFRAMES_PER_FRAME; j++)
		{
			myHC->HS_microframe_info[i][j].time_used = 0;
		}

	}
}


void
init_tt(PHC myHC, PTT myTT)
{
	int i,j;
	PEndpoint ep;

	myTT->think_time = 1;
	myTT->myHC = myHC;
	myTT->allocation_limit = FS_MAX_PERIODIC_ALLOCATION;

	for (i=0; i<MAXFRAMES; i++)
	{

		myTT->frame_budget[i].time_used = FS_SOF + HUB_FS_ADJ;
		myTT->frame_budget[i].allocated_large = 0;

		for (j=0; j < MICROFRAMES_PER_FRAME; j++)
		{
			myTT->HS_split_data_time[i][j] = 0;
			myTT->num_starts[i][j] = 0;
		}
		
		ep = &myTT->isoch_head[i];
		myTT->frame_budget[i].isoch_ehead = ep; 

		//  SOF at the beginning of each frame
		Set_endpoint(ep, isoch, OUTDIR, FSSPEED, MAXFRAMES, 0, myTT);
		ep->calc_bus_time = FS_SOF + HUB_FS_ADJ;
		ep->actual_period = MAXFRAMES;
		ep->start_microframe = -1;
		ep->start_frame = i;
		
		ep = &myTT->int_head[i];
		myTT->frame_budget[i].int_ehead = ep;

		// dummy SOF at the beginning of each int frame budget list
		Set_endpoint(ep, interrupt, OUTDIR, FSSPEED, MAXFRAMES, 0, myTT);
		ep->calc_bus_time = FS_SOF + HUB_FS_ADJ;
		ep->actual_period = MAXFRAMES;
		ep->start_microframe = -1;
		ep->start_frame = i;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\common.h ===
#ifndef   __COMMON_H__
#define   __COMMON_H__


#include "wdm.h"
#include <windef.h>
#include <unknown.h>
#ifdef DRM_SUPPORT
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>
#endif
#include <initguid.h>
#include <wdmguid.h>

#include "..\USB2LIB\usb2lib.h"

#include "usb.h"
#include "usbhcdi.h"
#include "dbg.h"

// <begin> special debug defines
//#define ISO_LOG
//#define TRACK_IRPS
// <end> special debug defines

// include all bus interfaces
#include "usbbusif.h"
#include "hubbusif.h"

// inclulde ioctl defs for port drivers
#include "usbkern.h"
#include "usbuser.h"

// include iodefs for client drivers
#include "usbdrivr.h"

#include "usbport.h"
#include "prototyp.h"

#include "enumlog.h"


#endif //__COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\cancel.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    core.c

Abstract:

    We maintain two lists for Transfer Irps

    (1)
    PendingTransferIrps - transfers on the endpoint pending List
    protected by PendingIrpLock

    (2)
    ActiveTransferIrps  - transfers on the enpoint ACTIVE, CANCEL list 
                            or on the MapTransfer List
    protected by ActiveIrpLock                            

    each list has its own cancel and completion routine   

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

#ifdef ALLOC_PRAGMA
#endif

// non paged functions
// USBPORT_QueuePendingTransferIrp
// USBPORT_CancelPendingTransferIrp
// USBPORT_InsertIrpInTable
// USBPORT_RemoveIrpFromTable
// USBPORT_FindIrpInTable

VOID
USBPORT_InsertIrpInTable(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_IRP_TABLE IrpTable,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG i;
    PUSBPORT_IRP_TABLE t = IrpTable;   

    USBPORT_ASSERT(IrpTable != NULL);

    t = (PUSBPORT_IRP_TABLE) &IrpTable; 

    do {
        t = t->NextTable;
        for (i = 0; i<IRP_TABLE_LENGTH; i++) {
            if (t->Irps[i] == NULL) {
                t->Irps[i] = Irp; 
                return;
            }
        }            
    } while (t->NextTable);

    // no room, grow the table and recurse

    ALLOC_POOL_Z(t->NextTable, NonPagedPool,
                 sizeof(USBPORT_IRP_TABLE));

    if (t->NextTable != NULL) {
        USBPORT_InsertIrpInTable(FdoDeviceObject, t->NextTable, Irp);
    } else {
        BUGCHECK(USBBUGCODE_INTERNAL_ERROR, 0, 0, 0);
    }
    
    return;
}   


PIRP
USBPORT_RemoveIrpFromTable(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_IRP_TABLE IrpTable,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG i;
    PUSBPORT_IRP_TABLE t = IrpTable;   

    USBPORT_ASSERT(IrpTable != NULL);

    t = (PUSBPORT_IRP_TABLE) &IrpTable; 

    do {
        t = t->NextTable;
        for (i = 0; i<IRP_TABLE_LENGTH; i++) {
            if (t->Irps[i] == Irp) {
                t->Irps[i] = NULL; 
                LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'rmIP', i, Irp, IrpTable);
                return Irp;
            }
        }            
    } while (t->NextTable);

    return NULL;
}   


PIRP
USBPORT_FindUrbInIrpTable(
    PDEVICE_OBJECT FdoDeviceObject,    
    PUSBPORT_IRP_TABLE IrpTable,
    PTRANSFER_URB Urb,
    PIRP InputIrp
    )
/*++

Routine Description:

    Given and table urb we scan for it in the the irp table
    if we find it it means the client has submitted the same 
    urb twice.

    This function is used to validate client drivers, there is
    a small perf hit taken here but probably worth it.

Arguments:

Return Value:

--*/
{
    ULONG i;
    PUSBPORT_IRP_TABLE t = IrpTable;   
    PIRP tIrp = NULL;
    PTRANSFER_URB urb;
    PIO_STACK_LOCATION irpStack;

    USBPORT_ASSERT(IrpTable != NULL);

    t = (PUSBPORT_IRP_TABLE) &IrpTable; 

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'fndU', t, Urb, 0);

    do {
        t = t->NextTable;
        for (i=0; i<IRP_TABLE_LENGTH; i++) {
            tIrp = t->Irps[i];
            if (tIrp != NULL) {           
                irpStack = IoGetCurrentIrpStackLocation(tIrp);
                urb = irpStack->Parameters.Others.Argument1;
                if (urb == Urb) {
                    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'fkkX', tIrp, urb, InputIrp);
                    if (tIrp == InputIrp) {
                        // this is a double submit by the client driver, that 
                        // is the irp is still pending
                        BUGCHECK(USBBUGCODE_DOUBLE_SUBMIT, (ULONG_PTR) tIrp, 
                                (ULONG_PTR) urb, 0);
                    } else {
                        // this is the case where the URB is attached to 
                        // another irp
                        BUGCHECK(USBBUGCODE_BAD_URB, (ULONG_PTR) tIrp, (ULONG_PTR) InputIrp,
                                (ULONG_PTR) urb);
                    }                                
                }
            }                    

        }            
    } while (t->NextTable);

    return tIrp;
}   


PIRP
USBPORT_FindIrpInTable(
    PDEVICE_OBJECT FdoDeviceObject,    
    PUSBPORT_IRP_TABLE IrpTable,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG i;
    PUSBPORT_IRP_TABLE t = IrpTable;   

    USBPORT_ASSERT(IrpTable != NULL);

    t = (PUSBPORT_IRP_TABLE) &IrpTable; 

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'fIPT', t, Irp, 0);

    do {
        t = t->NextTable;
        for (i = 0; i<IRP_TABLE_LENGTH; i++) {
            if (t->Irps[i] == Irp) {
                return Irp;
            }
        }            
    } while (t->NextTable);

    return NULL;
}   


VOID
USBPORT_QueuePendingTransferIrp(
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;
    KIRQL cancelIrql, irql;
    PDEVICE_OBJECT fdoDeviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION devExt;
    PTRANSFER_URB urb;

    // on entry the urb is not cancelable ie
    // no cancel routine
    
    // extract the urb;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    urb = irpStack->Parameters.Others.Argument1;

    ASSERT_TRANSFER_URB(urb);
    transfer = urb->pd.HcdTransferContext;
    endpoint = transfer->Endpoint;    

    fdoDeviceObject = endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'tIRP', transfer, endpoint, 0);
            
    USBPORT_ASSERT(Irp == transfer->Irp);
    USBPORT_ASSERT(Irp != NULL);
    
    Irp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(Irp);

    ACQUIRE_PENDING_IRP_LOCK(devExt, irql);

    IoSetCancelRoutine(Irp, USBPORT_CancelPendingTransferIrp);

    if (Irp->Cancel && 
        IoSetCancelRoutine(Irp, NULL)) {

        // irp was canceled and our cancel routine
        // did not run
        RELEASE_PENDING_IRP_LOCK(devExt, irql);                
        
        USBPORT_CompleteTransfer(urb,
                                 USBD_STATUS_CANCELED);
    } else {
    
        // cancel routine is set 
        USBPORT_InsertPendingTransferIrp(fdoDeviceObject, Irp);

        USBPORT_QueuePendingUrbToEndpoint(endpoint, urb);

        RELEASE_PENDING_IRP_LOCK(devExt, irql);
    }
        
}


VOID
USBPORT_CancelPendingTransferIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP CancelIrp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION devExt, rhDevExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql;
    
    // release cancel spinlock 
    IoReleaseCancelSpinLock(CancelIrp->CancelIrql);

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'canP', fdoDeviceObject, CancelIrp, 0);

    ACQUIRE_PENDING_IRP_LOCK(devExt, irql);    

    irp = USBPORT_RemovePendingTransferIrp(fdoDeviceObject, CancelIrp);

    if (irp) {
        PTRANSFER_URB urb;
    
        // found it 
        irpStack = IoGetCurrentIrpStackLocation(CancelIrp);
        urb = irpStack->Parameters.Others.Argument1;

        ASSERT_TRANSFER_URB(urb);
        transfer = urb->pd.HcdTransferContext;
        endpoint = transfer->Endpoint;    
        
        USBPORT_ASSERT(fdoDeviceObject == endpoint->FdoDeviceObject);

        ACQUIRE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'Le10');
       
        // remove request from the endpoint,
        // it will be on the pending list
#if DBG
        USBPORT_ASSERT(
            USBPORT_FindUrbInList(urb, &endpoint->PendingList));
#endif
        RemoveEntryList(&transfer->TransferLink);
        transfer->TransferLink.Flink = NULL;
        transfer->TransferLink.Blink = NULL;

        RELEASE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'Ue10');
    }        


    RELEASE_PENDING_IRP_LOCK(devExt, irql);           

    // noone nows about this irp anymore
    // complete it with status canceled
    if (irp) {
        USBPORT_CompleteTransfer(transfer->Urb,
                                 USBD_STATUS_CANCELED);
    }
}                


VOID
USBPORT_CancelActiveTransferIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP CancelIrp
    )
/*++

Routine Description:

    Cancels come in on the root hub Pdo

Arguments:

Return Value:

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION devExt, rhDevExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql;

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'canA', fdoDeviceObject, CancelIrp, 0);

    // when we have the fdo we can release the global cancel lock
    IoReleaseCancelSpinLock(CancelIrp->CancelIrql);

    ACQUIRE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);    

    irp = USBPORT_FindActiveTransferIrp(fdoDeviceObject, CancelIrp);

    // if irp is not on our list then we have already completed it.
    if (irp) {
        
        PTRANSFER_URB urb;

        USBPORT_ASSERT(irp == CancelIrp);
        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'CANA', fdoDeviceObject, irp, 0);
        // found it 
        // mark the transfer so it will be canceled the next 
        // time we process the endpoint.
        irpStack = IoGetCurrentIrpStackLocation(irp);
        urb = irpStack->Parameters.Others.Argument1;

        ASSERT_TRANSFER_URB(urb);
        transfer = urb->pd.HcdTransferContext;
        endpoint = transfer->Endpoint;    
        
        USBPORT_ASSERT(fdoDeviceObject == endpoint->FdoDeviceObject);

        ACQUIRE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'LeI0');

        if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_SPLIT)) {
            KIRQL tIrql;
            PLIST_ENTRY listEntry;
            PHCD_TRANSFER_CONTEXT childTransfer;

            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_CANCELED);

            ACQUIRE_TRANSFER_LOCK(fdoDeviceObject, transfer, tIrql);

            // mark all children as cancelled
            GET_HEAD_LIST(transfer->SplitTransferList, listEntry);

            while (listEntry &&
                   listEntry != &transfer->SplitTransferList) {
           
                childTransfer =  (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                                     listEntry,
                                     struct _HCD_TRANSFER_CONTEXT, 
                                     SplitLink);

                ASSERT_TRANSFER(childTransfer); 
            
                SET_FLAG(childTransfer->Flags, USBPORT_TXFLAG_CANCELED);

                listEntry = childTransfer->SplitLink.Flink; 
            }

            RELEASE_TRANSFER_LOCK(fdoDeviceObject, transfer, tIrql);

        } else {
            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_CANCELED);
        }            
        RELEASE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'UeI0');        

        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql); 
        // if we canceled a transfer then
        // this endpoint needs attention
        USBPORT_InvalidateEndpoint(fdoDeviceObject,
                                   endpoint,
                                   IEP_SIGNAL_WORKER);
    } else {
    
        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);  
        
    }        

}


PIRP
USBPORT_FindActiveTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'fnAC', 0, Irp, 0);
    
    return USBPORT_FindIrpInTable(FdoDeviceObject,
                                  devExt->ActiveTransferIrpTable, 
                                  Irp);
}


PIRP
USBPORT_RemoveActiveTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'rmAC', 0, Irp, 0);
    
    return USBPORT_RemoveIrpFromTable(FdoDeviceObject,
                                      devExt->ActiveTransferIrpTable, 
                                      Irp);
    
}


PIRP
USBPORT_RemovePendingTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'rmPN', 0, Irp, 0);
    
    return USBPORT_RemoveIrpFromTable(FdoDeviceObject,
                                      devExt->PendingTransferIrpTable, 
                                      Irp);
}


VOID
USBPORT_FreeIrpTable(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_IRP_TABLE BaseIrpTable
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBPORT_IRP_TABLE tmp;
    
    while (BaseIrpTable != NULL) {
        tmp = BaseIrpTable->NextTable;
        FREE_POOL(FdoDeviceObject, BaseIrpTable);
        BaseIrpTable = tmp;
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\dbg.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug functions and services

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "stdarg.h"
#include "stdio.h"

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
//USBPORT_GetGlobalDebugRegistryParameters
//USBPORT_AssertFailure
//USBPORT_KdPrintX

// 
ULONG USBPORT_LogMask = (LOG_MINIPORT |
                         LOG_XFERS |
                         LOG_PNP |
                         LOG_MEM |
                         LOG_POWER |
                         LOG_RH |
                         LOG_URB |
                         LOG_MISC |
                         LOG_IRPS |
                         LOG_ISO);

//ULONG USBPORT_LogMask = (
//                         LOG_IRPS |
//                         LOG_URB);                         

ULONG USBPORT_DebugLogEnable =
#if DBG
    1;
#else 
    1;
#endif

ULONG USBPORT_CatcTrapEnable = 0;

#if DBG
/******
DEBUG
******/

#define  DEFAULT_DEBUG_LEVEL    0

#ifdef DEBUG1
#undef DEFAULT_DEBUG_LEVEL
#define  DEFAULT_DEBUG_LEVEL    1
#endif

#ifdef DEBUG2
#undef DEFAULT_DEBUG_LEVEL
#define  DEFAULT_DEBUG_LEVEL    2
#endif

ULONG USBPORT_TestPath = 0;
ULONG USBPORT_W98_Debug_Trace = 0;
ULONG USBPORT_Debug_Trace_Level = DEFAULT_DEBUG_LEVEL;
ULONG USBPORT_Client_Debug = 0;
ULONG USBPORT_BreakOn = 0;


VOID
USB2LIB_DbgPrint(
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    )
{
    if (USBPORT_Debug_Trace_Level) {
        DbgPrint(Format, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5);
    }        
}

VOID
USB2LIB_DbgBreak(
    VOID
    )
{
    DbgPrint("<Break in USB2LIB>\n");
    DbgBreakPoint();
}


VOID
USBPORTSVC_DbgPrint(
    PDEVICE_DATA DeviceData,
    ULONG Level,
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    )
{

    if (USBPORT_Debug_Trace_Level >= Level) {
        if (Level <= 1) {
            // dump line to debugger
            if (USBPORT_W98_Debug_Trace) {
                DbgPrint("xMP.SYS: ");
                *Format = ' ';
            } else {
                DbgPrint("'xMP.SYS: ");
            }
        } else {
            // dump line to NTKERN buffer
            DbgPrint("'xMP.SYS: ");
            if (USBPORT_W98_Debug_Trace) {
                *Format = 0x27;
            }
        }

        DbgPrint(Format, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5);
    }
}


VOID
USBPORTSVC_TestDebugBreak(
    PDEVICE_DATA DeviceData
    )
{
    DEBUG_BREAK();
}


VOID
USBPORTSVC_AssertFailure(
    PDEVICE_DATA DeviceData,
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
{
    USBPORT_AssertFailure(
        FailedAssertion,
        FileName,
        LineNumber,
        Message);
}


NTSTATUS
USBPORT_GetGlobalDebugRegistryParameters(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
#define MAX_KEYS    8
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[MAX_KEYS];
    PWCHAR usb = L"usb";
    ULONG k = 0;

    PAGED_CODE();

    //
    // Set up QueryTable to do the following:
    //

    // spew level - 0
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_LEVEL_KEY;
    QueryTable[k].EntryContext = &USBPORT_Debug_Trace_Level;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_Debug_Trace_Level;
    QueryTable[k].DefaultLength = sizeof(USBPORT_Debug_Trace_Level);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

    // use ntkern trace buffer - 1
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_WIN9X_KEY;
    QueryTable[k].EntryContext = &USBPORT_W98_Debug_Trace;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_W98_Debug_Trace;
    QueryTable[k].DefaultLength = sizeof(USBPORT_W98_Debug_Trace);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

    // break on start - 2
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_BREAK_ON;
    QueryTable[k].EntryContext = &USBPORT_BreakOn;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_BreakOn;
    QueryTable[k].DefaultLength = sizeof(USBPORT_BreakOn);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

    // log mask - 3
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_LOG_MASK;
    QueryTable[k].EntryContext = &USBPORT_LogMask;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_LogMask;
    QueryTable[k].DefaultLength = sizeof(USBPORT_LogMask);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);


    // log mask - 4
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_CLIENTS;
    QueryTable[k].EntryContext = &USBPORT_Client_Debug;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_Client_Debug;
    QueryTable[k].DefaultLength = sizeof(USBPORT_LogMask);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

     // log enable - 5
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_LOG_ENABLE;
    QueryTable[k].EntryContext = &USBPORT_DebugLogEnable;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_DebugLogEnable;
    QueryTable[k].DefaultLength = sizeof(USBPORT_DebugLogEnable);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

     // catc trap enable - 6
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_CATC_ENABLE;
    QueryTable[k].EntryContext = &USBPORT_CatcTrapEnable;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_CatcTrapEnable;
    QueryTable[k].DefaultLength = sizeof(USBPORT_CatcTrapEnable);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

    //
    // Stop
    //
    QueryTable[k].QueryRoutine = NULL;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
         USBPORT_KdPrint((1, "'Debug Trace Level Set: (%d)\n", USBPORT_Debug_Trace_Level));

        if (USBPORT_W98_Debug_Trace) {
            USBPORT_KdPrint((1, "'NTKERN Trace is ON\n"));
        } else {
            USBPORT_KdPrint((1, "'NTKERN Trace is OFF\n"));
        }

        if (USBPORT_DebugLogEnable) {
            USBPORT_KdPrint((1, "'DEBUG-LOG is ON\n"));
        } else {
            USBPORT_KdPrint((1, "'DEBUG-LOG is OFF\n"));
        }

        if (USBPORT_BreakOn) {
            USBPORT_KdPrint((1, "'DEBUG BREAK is ON\n"));
        }

        USBPORT_KdPrint((1, "'DEBUG Log Mask is 0x%08.8x\n", USBPORT_LogMask));

        if (USBPORT_Debug_Trace_Level > 0) {
            ULONG USBPORT_Debug_Asserts = 1;
        }

        if (USBPORT_Client_Debug) {
            USBPORT_KdPrint((1, "'DEBUG CLIENTS (verifier) is ON\n"));
        }

        if (USBPORT_CatcTrapEnable) {
            USBPORT_KdPrint((0, "'DEBUG ANALYZER TRIGGER is ON\n"));
        }
    }

    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

VOID
USBPORT_AssertTransferUrb(
    PTRANSFER_URB Urb
    )
{
    PDEVICE_OBJECT fdoDeviceObject;
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;

    transfer = Urb->pd.HcdTransferContext;
    ASSERT_TRANSFER(transfer);

    USBPORT_ASSERT(transfer->Urb == Urb);

    endpoint = transfer->Endpoint;
    ASSERT_ENDPOINT(endpoint);

    fdoDeviceObject = endpoint->FdoDeviceObject;
    LOGENTRY(NULL, fdoDeviceObject, LOG_URB, 'Aurb', Urb, transfer, 0);

    USBPORT_ASSERT(Urb->pd.UrbSig == URB_SIG);
}


VOID
USBPORT_AssertFailure(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function.

    on NT the debugger does this for us but on win9x it does not.
    so we have to do it ourselves.

Arguments:

Return Value:


--*/
{

    // this makes the compiler generate a ret
    ULONG stop = 0;

assert_loop:

    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it

    DbgBreakPoint();
    if (stop) {
        goto assert_loop;
    }

    return;
}


ULONG
_cdecl
USBPORT_DebugClientX(
    PCH Format,
    ...
    )
/*++

Routine Description:

    Special debug print function for debugging client USB drivers.

    if the client debug mode is set then this function will print a
    message and break in the debugger.  This is the embedded USBPORT
    equivalent of Verifier.

Arguments:

Return Value:


--*/
{
    va_list list;
    int i;
    int arg[6];

    if (USBPORT_Debug_Trace_Level > 1 ||
        USBPORT_Client_Debug) {
        DbgPrint(" *** USBPORT(VERIFIER) - CLIENT DRIVER BUG:\n");
        DbgPrint(" * ");
        va_start(list, Format);
        for (i=0; i<6; i++)
            arg[i] = va_arg(list, int);

        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);
        DbgPrint(" ***\n ");

        DbgBreakPoint();
    }

    return 0;
}


ULONG
_cdecl
USBPORT_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function.

    Prints based on the value of the USBPORT_DEBUG_TRACE_LEVEL

    Also if USBPORT_W98_Debug_Trace is set then all debug messages
    with a level greater than one are modified to go in to the
    ntkern trace buffer.

    It is only valid to set USBPORT_W98_Debug_Trace on Win9x
    becuse the static data segments for drivers are marked read-only
    by the NT OS.

Arguments:

Return Value:


--*/
{
    va_list list;
    int i;
    int arg[6];

    if (USBPORT_Debug_Trace_Level >= l) {
        if (l <= 1) {
            // dump line to debugger
            if (USBPORT_W98_Debug_Trace) {
                DbgPrint("USBPORT.SYS: ");
                *Format = ' ';
            } else {
                DbgPrint("'USBPORT.SYS: ");
            }
        } else {
            // dump line to NTKERN buffer
            DbgPrint("'USBPORT.SYS: ");
            if (USBPORT_W98_Debug_Trace) {
                *Format = 0x27;
            }
        }
        va_start(list, Format);
        for (i=0; i<6; i++)
            arg[i] = va_arg(list, int);

        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);
    }

    return 0;
}


VOID
USBPORT_DebugTransfer_LogEntry(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    PHCD_TRANSFER_CONTEXT Transfer,
    PTRANSFER_URB Urb,
    PIRP Irp,
    NTSTATUS IrpStatus
    )
/*++

Routine Description:

    Adds an entry to transfer log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (devExt->TransferLog.LogStart == 0) {
        return;
    }

    USBPORT_AddLogEntry(
        &devExt->TransferLog,
        0xFFFFFFFF,
        '1rfx',
        (ULONG_PTR) Endpoint,
        (ULONG_PTR) Irp,
        (ULONG_PTR) Urb,
        FALSE);

    // decode some info about the transfer and log it as well

    USBPORT_AddLogEntry(
        &devExt->TransferLog,
        0xFFFFFFFF,
        '2rfx',
        (ULONG_PTR) Urb->Hdr.Function,
        IrpStatus,
        (ULONG_PTR) Urb->TransferBufferLength,
        FALSE);
}


#else

/********
RETAIL
 ********/

VOID
USB2LIB_DbgPrint(
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    )
{
    // nop
}

VOID
USB2LIB_DbgBreak(
    VOID
    )
{
    // nop
}


VOID
USBPORTSVC_DbgPrint(
    PDEVICE_DATA DeviceData,
    ULONG Level,
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    )
{
    // nop
}

VOID
USBPORTSVC_AssertFailure(
    PDEVICE_DATA DeviceData,
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
{
    // nop
}

VOID
USBPORTSVC_TestDebugBreak(
    PDEVICE_DATA DeviceData
    )
{
    // nop
}

#endif /* DBG */

/********
LOG CODE
    enabled in both retail and debug builds
*********/


VOID
USBPORTSVC_LogEntry(
    PDEVICE_DATA DeviceData,
    ULONG Mask,
    ULONG Sig,
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3
    )
/*++

Routine Description:

    Service for miniport to add log entries.

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    PDEBUG_LOG l;
    extern ULONG USBPORT_DebugLogEnable;\
    extern ULONG USBPORT_LogMask;\
    
    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);
    
    if (USBPORT_DebugLogEnable && 
        devExt->Log.LogStart != NULL && 
        (LOG_MINIPORT & USBPORT_LogMask)) {
        l = &devExt->Log;
        USBPORT_AddLogEntry(l, LOG_MINIPORT, Sig, Info1, Info2, Info3, TRUE);
    }
}


VOID
USBPORT_LogAlloc(
    PDEBUG_LOG Log,
    ULONG Pages
    )
/*++

Routine Description:

    Init the debug log -
    remember interesting information in a circular buffer

Arguments:

Return Value:

    None.

--*/
{
    ULONG logSize = 4096*Pages;

    if (USBPORT_DebugLogEnable) {

        // we won't track the mem we alloc for the log
        // we will let the verifier do that
        ALLOC_POOL_Z(Log->LogStart,
                     NonPagedPool,
                     logSize);

        if (Log->LogStart) {
            Log->LogIdx = 0;
            Log->LogSizeMask = (logSize/sizeof(LOG_ENTRY));
            Log->LogSizeMask-=1;
            // Point the end (and first entry) 1 entry from the end
            // of the segment
            Log->LogEnd = Log->LogStart +
                (logSize / sizeof(struct LOG_ENTRY)) - 1;
        } else {
            DEBUG_BREAK();
        }
    }

    return;
}


VOID
USBPORT_LogFree(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEBUG_LOG Log
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{

    if (Log->LogStart != NULL) {
        // log the free of the log in order to debug
        // verifier bugs
        FREE_POOL(FdoDeviceObject, Log->LogStart);
        // this will indicate that we have freed the 
        // log, other log pointers will remain intact
        Log->LogStart = NULL;
    }

    return;
}

/*
     Transmit the analyzer trigger packet 
*/

VOID
USBPORT_BeginTransmitTriggerPacket(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    PUCHAR va, mpData;
    ULONG length, mpDataLength;
    MP_PACKET_PARAMETERS mpPacket;
    USBD_STATUS usbdStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    UCHAR data[4];
    
    USBPORT_KdPrint((1, "'USBPORT_TransmitTriggerPacket\n"));

    ASSERT_PASSIVE();
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'TRIG', &mpPacket, 0, 
       0);

    // build up request for miniport
    
    length = devExt->Fdo.ScratchCommonBuffer->MiniportLength;
    va = devExt->Fdo.ScratchCommonBuffer->MiniportVa;
    phys = devExt->Fdo.ScratchCommonBuffer->MiniportPhys;

    mpPacket.DeviceAddress = 127;
    mpPacket.EndpointAddress = 8;
    mpPacket.MaximumPacketSize = 64;
    mpPacket.Type = ss_Out; 
    mpPacket.Speed = ss_Full;
    mpPacket.Toggle = ss_Toggle0;

    data[0] = 'G';
    data[1] = 'O'; 
    data[2] = 'A';
    data[3] = 'T';
     
    mpData = &data[0];
    mpDataLength = sizeof(data);
    
    MP_StartSendOnePacket(devExt,
                          &mpPacket,
                          mpData,
                          &mpDataLength,
                          va,
                          phys,
                          length,
                          &usbdStatus,
                          mpStatus);

}    


VOID
USBPORT_EndTransmitTriggerPacket(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    PUCHAR va, mpData;
    ULONG length, mpDataLength;
    MP_PACKET_PARAMETERS mpPacket;
    USBD_STATUS usbdStatus;
    UCHAR data[4];
    
    USBPORT_KdPrint((1, "'USBPORT_TransmitTriggerPacket\n"));

    ASSERT_PASSIVE();
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
      
    mpData = &data[0];
    mpDataLength = sizeof(data);

    length = devExt->Fdo.ScratchCommonBuffer->MiniportLength;
    va = devExt->Fdo.ScratchCommonBuffer->MiniportVa;
    phys = devExt->Fdo.ScratchCommonBuffer->MiniportPhys;

   
    USBPORT_Wait(FdoDeviceObject, 10);
            
    MP_EndSendOnePacket(devExt,
                        &mpPacket,
                        mpData,
                        &mpDataLength,
                        va,
                        phys,
                        length,
                        &usbdStatus,
                        mpStatus);


    USBPORT_KdPrint((1, "'<ANALYZER TRIGER FIRED>\n"));
    DbgBreakPoint();
    
}    


VOID
USBPORT_CatcTrap(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (KeGetCurrentIrql() > PASSIVE_LEVEL) {
        USBPORT_BeginTransmitTriggerPacket(FdoDeviceObject);
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_CATC_TRAP);
    } else {
        TEST_TRAP();
        USBPORT_BeginTransmitTriggerPacket(FdoDeviceObject);
        USBPORT_EndTransmitTriggerPacket(FdoDeviceObject);
    }        
}    


VOID
USBPORT_EnumLogEntry(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG DriverTag,
    ULONG EnumTag,
    ULONG P1,
    ULONG P2
    )
/*++

Routine Description:

    Enumeration Log, this is where any USB device driver may log a failure 
    to track failure causes

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (devExt->EnumLog.LogStart == 0) {
        return;
    }

    USBPORT_AddLogEntry(
        &devExt->EnumLog,
        0xFFFFFFFF,
        EnumTag,
        (ULONG_PTR) DriverTag,
        (ULONG_PTR) P1,
        (ULONG_PTR) P2,
        FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\config.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    config.c

Abstract:

    handles configuration and interface URBs

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGE, USBPORT_SelectInterface)
#pragma alloc_text(PAGE, USBPORT_SelectConfiguration)
#pragma alloc_text(PAGE, USBPORT_InitializeConfigurationHandle)
#pragma alloc_text(PAGE, USBPORT_InternalOpenInterface)
#pragma alloc_text(PAGE, USBPORT_InternalCloseConfiguration)
#pragma alloc_text(PAGE, USBPORT_InternalParseConfigurationDescriptor)
#pragma alloc_text(PAGE, USBPORT_InternalGetInterfaceLength)
#endif

// non paged functions

USBD_PIPE_TYPE PipeTypes[4] = {UsbdPipeTypeControl, UsbdPipeTypeIsochronous,
                                    UsbdPipeTypeBulk, UsbdPipeTypeInterrupt};


NTSTATUS
USBPORT_SelectInterface(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Select an alternate interface for a USB device.  The orginal 
    USBD code only supported selecting a single alternate interface
    so we will as well.

    Client will(should) pass in a URB buffer that looks like this:

    +------------------------------+
    |Hdr                           |
    |(_URB_HEADER)                 |
    |    - <caller inputs>         |
    |      Function                |
    |      Length                  |
    |      UsbdDeviceHandle        |
    |                              |
    |    - <port outputs>          |
    |        Status                |
    +------------------------------+
    |    - <caller inputs>         |
    |      ConfigurationHandle     |
    +------------------------------+
    |Interface                     |
    |(USBD_INTERFACE_INFORMATION)  |
    |    - <caller inputs>         |
    |      Length                  |
    |      InterfaceNumber         |  
    |      AlternateSetting        |
    |                              |
    |    - <port  outputs>         |
    |      InterfaceHandle         |
    |      NumberOfPipes           |
    |      SubClass                |
    |      Class                   |
    |      Protocol                |
    +------------------------------+
    |Pipes[0]                      | one of these for each pipe in the
    |(USBD_PIPE_INFORMATION)       | interface
    |    - <caller inputs>         |
    |      PipeFlags               |      
    |      MaximumPacketSize (opt) |
    |                              |
    |    - <port outputs>          |
    +------------------------------+
    |Pipes[1]                      |
    +------------------------------+
    |....                          |
    +------------------------------+
    |Pipes[n]                      |
    +------------------------------+ 

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PUSBD_CONFIG_HANDLE configHandle = NULL;
    ULONG i;
    PDEVICE_EXTENSION devExt;
    PUSBD_DEVICE_HANDLE deviceHandle;
    PUSBD_INTERFACE_INFORMATION interfaceI;
    PUSBD_INTERFACE_HANDLE_I iHandle, iHandleNew;
    USHORT tmp;
    USBD_STATUS usbdStatus;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_HANDLE(deviceHandle, Urb);
    LOCK_DEVICE(deviceHandle, FdoDeviceObject);

    // validate the configuration handle input    
    configHandle = Urb->UrbSelectInterface.ConfigurationHandle;
    ASSERT_CONFIG_HANDLE(configHandle);

    //
    // will are interested in the alt setting of a specific 
    // interface based on the interface number.
    //

    interfaceI = &Urb->UrbSelectInterface.Interface;

    // validate the Length field in the Urb header, we can
    // figure out the correct value based on the interface 
    // information passed in
    tmp = interfaceI->Length + sizeof(struct _URB_HEADER)
        + sizeof(configHandle);

    if (tmp != Urb->UrbHeader.Length) {
        // client passed in bogus total length, warn if in 
        // 'verifier' mode.
        
        USBPORT_DebugClient(
                ("client driver passed invalid Urb.Header.Length\n"));

        // generally cleints mess up the header length so 
        // we will override with the length we calculated 
        // from the interface-information.

        Urb->UrbHeader.Length = tmp;
    }

    // validate the interfaceI structure passed to us by the client
    usbdStatus = USBPORT_InitializeInterfaceInformation(FdoDeviceObject,
                                                        interfaceI,
                                                        configHandle);
    
    if (usbdStatus == USBD_STATUS_SUCCESS) {

        // find the interface handle for the interface we are 
        // interested in, if it is currently open we will need
        // to close it.

        iHandle = USBPORT_GetInterfaceHandle(FdoDeviceObject,
                                             configHandle,
                                             interfaceI->InterfaceNumber);

        if (iHandle != NULL) {

            // unlink this handle
            RemoveEntryList(&iHandle->InterfaceLink);

            // we have a handle

            ASSERT_INTERFACE(iHandle);     

            // close the pipes in this interface, note that we 
            // force the pipes closed unlike past versions of 
            // USBD and force the client driver to deal with the
            // consequences if it has transfers outstanding.

            // attempt to close all endpoints in this interface
            for (i=0; i < iHandle->InterfaceDescriptor.bNumEndpoints; i++) {

                USBPORT_ClosePipe(deviceHandle,
                                  FdoDeviceObject,
                                  &iHandle->PipeHandle[i]);
            }
        }

        //
        // Now open the new interface with the new alternate setting
        //

        iHandleNew = NULL;
        usbdStatus = USBPORT_InternalOpenInterface(Urb,
                                                   deviceHandle,
                                                   FdoDeviceObject,
                                                   configHandle,
                                                   interfaceI,
                                                   &iHandleNew,
                                                   TRUE);
    }

    if (usbdStatus == USBD_STATUS_SUCCESS) {

        //
        // successfully opened the new interface,
        // we can free the old handle now if we 
        // had one.
        //
        if (iHandle != NULL ) {
#if DBG
            // all pipes should be closed
            for (i=0; i < iHandle->InterfaceDescriptor.bNumEndpoints; i++) {
                USBPORT_ASSERT(iHandle->PipeHandle[i].ListEntry.Flink == NULL &&
                               iHandle->PipeHandle[i].ListEntry.Blink == NULL);
            }
#endif
            FREE_POOL(FdoDeviceObject, iHandle);
        }            

        // return the 'new' handle
        interfaceI->InterfaceHandle = iHandleNew;

        // associate it with this configuration
        InsertTailList(&configHandle->InterfaceHandleList,
                       &iHandleNew->InterfaceLink);

    } else {

        //
        // selecting the aternate interface failed.
        // Possible reasons:
        //
        // 1. we didn't have enough BW
        // 2. the device stalled the set_interface request
        // 3. The set_interface request failed because the
        //      device is gone
        // 4. USBPORT_InitializeInterfaceInformation() failed due
        //      bad parameters.

        // attempt to re-open the original alt-interface so that 
        // the client still has the bandwidth

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'slI!', 
            usbdStatus,
            0,
            0);  
            
        if (usbdStatus == USBD_STATUS_NO_BANDWIDTH) {

            // HISTORICAL NOTE:
            // The 2k USBD driver attempted to re-open the original
            // alt-setting on a failure to allocate bw.  This would 
            // leave the client with the bw it had when calling in
            // to select the new interface.   
            //
            // I don't beleive that any drivers use this feature 
            // and many drivers attempt to allocate BW in a loop 
            // until they succeed.  
            //
            // So as a performance optimization we will return 
            // with no bandwidth allocated to the caller -- the 
            // pipe handles will be invalid. 
            // This should speed things up since the realloc of
            // the old bandwidth takes time.
            interfaceI->InterfaceHandle = USBPORT_BAD_HANDLE;
        
        } else {
            // case 2,3 we just fail the request and set the interface 
            // handle to 'bad handle'
            interfaceI->InterfaceHandle = USBPORT_BAD_HANDLE;
        }
        
    }
    
    UNLOCK_DEVICE(deviceHandle, FdoDeviceObject);

    ntStatus = SET_USBD_ERROR(Urb, usbdStatus);   
    
    return ntStatus;

}


NTSTATUS
USBPORT_SelectConfiguration(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Open a configuration for a USB device.

    Client will(should) pass in a URB buffer that looks like this:

    +------------------------------+
    |Hdr                           |
    |(_URB_HEADER)                 |
    |    - <caller inputs>         |
    |      Function                |
    |      Length                  |
    |      UsbdDeviceHandle        |
    |                              |
    |    - <port outputs>          |
    |       Status                 |
    +------------------------------+
    |    - <caller inputs>         |
    |      ConfigurationDescriptor |
    |    - <port outputs>          |
    |      ConfigurationHandle     |
    +------------------------------+
    |Interface(0)                  |
    |(USBD_INTERFACE_INFORMATION)  |
    |    - <caller inputs>         |
    |      Length                  |
    |      InterfaceNumber         |  
    |      AlternateSetting        |
    |                              |
    |    - <port  outputs>         |
    |      InterfaceHandle         |
    |      NumberOfPipes           |
    |      SubClass                |
    |      Class                   |
    |      Protocol                |
    +------------------------------+
    |Pipes[0]                      | one of these for each pipe in the
    |(USBD_PIPE_INFORMATION)       | interface
    |    - <caller inputs>         |
    |                              |      
    |    - <port outputs>          |
    +------------------------------+
    |Pipes[1]                      |
    +------------------------------+
    |....                          |
    +------------------------------+
    |Pipes[n]                      |
    +------------------------------+ 
    | Interface(1)                 | one of these for each interface in 
    |                              | the configuration
    +------------------------------+
    |Pipes[1]                      |
    +------------------------------+
    |....                          |
    +------------------------------+
    |Pipes[n]                      |
    +------------------------------+
    
    On input:
    The ConfigurationDescriptor must specify the number of interfaces
    in the configuration.

    The InterfaceInformation will specify a specific alt setting to be 
    selected for each interface.

    1. First we look at the configuration descriptor for the
        requested configuration and validate the client
        input buffer agianst it.

    2. We open the interfaces for the requested configuration
        and open the pipes within those interfaces, setting
        alt settings were appropriate.

    3. We set the configuration for the device with the
        appropriate control request.

Arguments:

    DeviceObject -

    Irp -  IO request block

    Urb -  ptr to USB request block

    IrpIsPending -

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_CONFIG_HANDLE configHandle = NULL;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    PUSBD_INTERFACE_INFORMATION interfaceInformation;
    PUCHAR pch;
    ULONG i;
    PDEVICE_EXTENSION devExt;
    ULONG numInterfaces;
    PUCHAR end;
    PUSBD_DEVICE_HANDLE deviceHandle;
    USBD_STATUS usbdStatus;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;

    PAGED_CODE();
    USBPORT_KdPrint((2, "' enter USBPORT_SelectConfiguration\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    GET_DEVICE_HANDLE(deviceHandle, Urb);
    LOCK_DEVICE(deviceHandle, FdoDeviceObject);

    ntStatus = STATUS_BOGUS;

    // BUGBUG 
    // flush all current transfers or fail?

    //
    // dump old configuration data if we have any
    //

    if (deviceHandle->ConfigurationHandle) {
    
        // This is where we close the old configuration
        // handle, all pipes and all interfaces.

        USBPORT_InternalCloseConfiguration(deviceHandle,
                                           FdoDeviceObject,
                                           0);
    }

    // now set up the new configuration
    
    configurationDescriptor =
        Urb->UrbSelectConfiguration.ConfigurationDescriptor;

    //
    // if null pased in set configuration to 0
    // 'unconfigured'
    //

    if (configurationDescriptor == NULL) {

        // device needs to be in the unconfigured state

        //
        // NOTE:
        // this may fail if the configuration is being
        // closed as the result of the device being unplugged
        // so we ignore the error
        //

        USBPORT_INIT_SETUP_PACKET(setupPacket,
                USB_REQUEST_SET_CONFIGURATION, // bRequest
                BMREQUEST_HOST_TO_DEVICE, // Dir
                BMREQUEST_TO_DEVICE, // Recipient
                BMREQUEST_STANDARD, // Type
                0, // wValue
                0, // wIndex
                0); // wLength
        
        USBPORT_SendCommand(deviceHandle,
                           FdoDeviceObject,
                           &setupPacket,
                           NULL,
                           0,
                           NULL,
                           NULL);

        ntStatus = SET_USBD_ERROR(Urb, USBD_STATUS_SUCCESS);                           

        goto USBD_SelectConfiguration_Done;
        
    } else {
        // validate the config descriptor by accessing it 
        //
        // Note: that we we will still crash here if the config 
        // descriptor is invalid. However is will be easiser to 
        // debug this way.
        //
        // 
        // 
        
        PUCHAR tmp;
        UCHAR ch;

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'vCNF', 
            configurationDescriptor,
            0,
            0);                           
                   
        // first a quick sanity check, it must be non-zero
        if (configurationDescriptor->wTotalLength == 0) {
            // this is bogus
            ntStatus = SET_USBD_ERROR(Urb, 
                USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR);
                
            goto USBD_SelectConfiguration_Done;        
            
        } else {
            // touch first and last byte, this wil fault if invalid.
            
            tmp = (PUCHAR) configurationDescriptor;
            ch = *tmp;
            tmp += configurationDescriptor->wTotalLength-1;
            ch = *tmp;
            
        } 

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'CFok', 
            configurationDescriptor,
            0,
            0); 
    }

    //
    // count the number of interfaces to process in this
    // request
    //

    pch = (PUCHAR) &Urb->UrbSelectConfiguration.Interface;
    numInterfaces = 0;
    end = ((PUCHAR) Urb) + Urb->UrbSelectConfiguration.Hdr.Length;

    do {
        numInterfaces++;

        interfaceInformation = (PUSBD_INTERFACE_INFORMATION) pch;
        pch+=interfaceInformation->Length;

    } while (pch < end);

    USBPORT_KdPrint((2, "'USBD_SelectConfiguration -- %d interfaces\n", 
        numInterfaces));

    // sanity check the config descriptor with the URB request
    if (numInterfaces != configurationDescriptor->bNumInterfaces ||
        numInterfaces == 0) {
        //
        // driver is broken, config request does not match
        // config descriptor passed in!!!
        //
        USBPORT_DebugClient((
            "config request does not match config descriptor\n"));
        ntStatus = SET_USBD_ERROR(Urb, 
            USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR);             

        TC_TRAP();             
        
        goto USBD_SelectConfiguration_Done;        
    }

    //
    // Allocate a configuration handle and
    // verify there is enough room to store
    // all the information in the client buffer.
    //

    configHandle = USBPORT_InitializeConfigurationHandle(deviceHandle,
                                                         FdoDeviceObject,
                                                         configurationDescriptor);
    if (configHandle == NULL) {
        USBPORT_DebugClient((
            "failed to allocate config handle\n"));
        ntStatus = SET_USBD_ERROR(Urb, 
            USBD_STATUS_INSUFFICIENT_RESOURCES);             
        
        goto USBD_SelectConfiguration_Done;      
    }

    //
    // Send the 'set configuration' command
    //

    USBPORT_INIT_SETUP_PACKET(setupPacket,
                USB_REQUEST_SET_CONFIGURATION, // bRequest
                BMREQUEST_HOST_TO_DEVICE, // Dir
                BMREQUEST_TO_DEVICE, // Recipient
                BMREQUEST_STANDARD, // Type
                configurationDescriptor->bConfigurationValue, // wValue
                0, // wIndex
                0); // wLength
      

    USBPORT_SendCommand(deviceHandle,
                       FdoDeviceObject,
                       &setupPacket,
                       NULL,
                       0,
                       NULL,
                       &usbdStatus);

    USBPORT_KdPrint((2,"' SendCommand, SetConfiguration returned 0x%x\n", usbdStatus));
                        
    if (USBD_ERROR(usbdStatus)) {
        USBPORT_DebugClient((
            "failed to 'set' the configuration\n"));
        ntStatus = SET_USBD_ERROR(Urb, 
            USBD_STATUS_SET_CONFIG_FAILED);             
        TC_TRAP();             
        goto USBD_SelectConfiguration_Done;      
    }

    USBPORT_ASSERT(ntStatus == STATUS_BOGUS);

    // we have "configured" the device in the USB sense.

    //
    // User buffer checks out and we have 'configured' 
    // the device.
    // Now parse thru the configuration descriptor  
    // and open the interfaces.
    //
    // The URB contains a set of INTERFACE_INFORMATION
    // structures these give us the information we need
    // to open the pipes
    /*        
    
    _USBD_INTERFACE_INFORMATION 
    client should have filled in:
    
    USHORT Length;     
    UCHAR InterfaceNumber;
    UCHAR AlternateSetting;

    we fill in :
    UCHAR Class;
    UCHAR SubClass;
    UCHAR Protocol;
    UCHAR Reserved;

    USBD_INTERFACE_HANDLE InterfaceHandle;
    ULONG NumberOfPipes; 

    */
    
    pch = (PUCHAR) &Urb->UrbSelectConfiguration.Interface;
    
    for (i=0; i<numInterfaces; i++) {
        PUSBD_INTERFACE_HANDLE_I interfaceHandle;
        // open the interface
        
        interfaceInformation = (PUSBD_INTERFACE_INFORMATION) pch;

        usbdStatus = USBPORT_InitializeInterfaceInformation(
                        FdoDeviceObject,
                        interfaceInformation,
                        configHandle);
                        
        interfaceHandle = NULL;
        if (usbdStatus == USBD_STATUS_SUCCESS) {
            
            // this function allocates the actual 'handle'
            usbdStatus = USBPORT_InternalOpenInterface(Urb,
                                                       deviceHandle,
                                                       FdoDeviceObject,
                                                       configHandle,
                                                       interfaceInformation,
                                                       &interfaceHandle,
                                                       TRUE);
            USBPORT_KdPrint((2, "' InternalOpenInterface returned(USBD) 0x%x\n", 
                usbdStatus));
        }
        
        pch+=interfaceInformation->Length;

        // if we got back a handle add it to the list
        if (interfaceHandle != NULL) {
            InsertTailList(&configHandle->InterfaceHandleList,
                           &interfaceHandle->InterfaceLink);
        }

        if (!USBD_SUCCESS(usbdStatus)) {
            
            ntStatus = SET_USBD_ERROR(Urb, usbdStatus);
            
            // we have an error opening the interface
            DEBUG_BREAK();
            TC_TRAP();
            goto USBD_SelectConfiguration_Done;
        }
    }

    //
    // interfaces were successfully set up then return success.
    //
    
    ntStatus = SET_USBD_ERROR(Urb, USBD_STATUS_SUCCESS);   

USBD_SelectConfiguration_Done:

    if (NT_SUCCESS(ntStatus)) { 

        USBPORT_ASSERT(Urb->UrbSelectConfiguration.Hdr.Status == 
            USBD_STATUS_SUCCESS);

        Urb->UrbSelectConfiguration.ConfigurationHandle = 
            configHandle;
        
        // remember the current configuration
        deviceHandle->ConfigurationHandle = configHandle;

    } else {

        //
        // something failed, clean up before we return an error.
        //

        if (configHandle) {

            TC_TRAP();
            ASSERT_DEVICE_HANDLE(deviceHandle);
            
            //
            // if we have a configHandle then we need to free it
            deviceHandle->ConfigurationHandle =
                configHandle;

            //
            // attempt to close it
            //
            
            USBPORT_InternalCloseConfiguration(deviceHandle,
                                               FdoDeviceObject,
                                               0);

            deviceHandle->ConfigurationHandle = NULL;
        }

        // make sure we return an error in the URB.
        USBPORT_ASSERT(Urb->UrbSelectConfiguration.Hdr.Status != 
            USBD_STATUS_SUCCESS);
        USBPORT_KdPrint((2, "'Failing SelectConfig\n"));
    }

    UNLOCK_DEVICE(deviceHandle, FdoDeviceObject);

    USBPORT_KdPrint((2, "'exit SelectConfiguration 0x%x\n", ntStatus));

    return ntStatus;
}


PUSBD_CONFIG_HANDLE
USBPORT_InitializeConfigurationHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++

Routine Description:

    Initialize the configuration handle structure.

    Given a (hopefully) valid configuration descriptor
    and a count of the interfaces create the configuration
    handle for the device

Arguments:

Return Value:


--*/
{
    PUSBD_CONFIG_HANDLE configHandle = NULL;
    ULONG i;
    PUCHAR pch;

    PAGED_CODE();
    USBPORT_ASSERT(ConfigurationDescriptor->bNumInterfaces > 0);
    
    USBPORT_KdPrint((2, "' enter InitializeConfigurationHandle\n"));
    
    // get enough space for each interface
    ALLOC_POOL_Z(configHandle, 
                 NonPagedPool,
                 sizeof(USBD_CONFIG_HANDLE) +
                 ConfigurationDescriptor->wTotalLength);

    pch = (PUCHAR)configHandle;

    if (configHandle) {

        //
        // Initilaize the interface handle list
        //

        InitializeListHead(&configHandle->InterfaceHandleList);

        configHandle->ConfigurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)
                              (pch + sizeof(USBD_CONFIG_HANDLE));

        // copy the config descriptor to our handle
        
        RtlCopyMemory(configHandle->ConfigurationDescriptor,
                      ConfigurationDescriptor,
                      ConfigurationDescriptor->wTotalLength);
                      
        configHandle->Sig = SIG_CONFIG_HANDLE;

    }        

    USBPORT_KdPrint((2, "' exit InitializeConfigurationHandle 0x%x\n", 
        configHandle));

    return configHandle;
}


USBD_STATUS
USBPORT_InternalOpenInterface(
    PURB Urb,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_CONFIG_HANDLE ConfigHandle,
    PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    PUSBD_INTERFACE_HANDLE_I *InterfaceHandle,
    BOOLEAN SendSetInterfaceCommand
    )
/*++

Routine Description:


Arguments:

    DeviceObject -

    DeviceHandle - USBD device handle for this device.

    ConfigHandle - USBD configuration handle.

    InterfaceInformation - pointer to USBD interface information structure
        passed in by the client.
        
        We use the InterfaceNumber and AlternateSetting specified 
        in this structure to select the interface.
        
        On success the .Length field is filled in with the actual length
        of the interface_information structure and the Pipe[] fields are filled
        in with the handles for the opened pipes.

    InterfaceHandle - pointer to an interface handle pointer, filled in
        with the allocated interface handle structure if NULL, otherwise the
        structure passed in is used.

    SendSetInterfaceCommand - indicates if the set_interface command should be
        sent.

Return Value:


--*/
{
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    BOOLEAN hasAlternateSettings;
    PUSBD_INTERFACE_HANDLE_I interfaceHandle = NULL;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUCHAR pch;
    ULONG i;
    BOOLEAN allocated = FALSE;
    PUSB_COMMON_DESCRIPTOR descriptor;
    USHORT need;
    ULONG numEndpoints;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;

    PAGED_CODE();

    ASSERT_CONFIG_HANDLE(ConfigHandle);

    if (*InterfaceHandle != NULL) {
        // using a previously allocated interface handle
        ASSERT_INTERFACE_HANDLE(*InterfaceHandle);
        TEST_TRAP();
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'opIF', 
        InterfaceInformation->InterfaceNumber,
        InterfaceInformation->AlternateSetting,
        *InterfaceHandle);

    USBPORT_KdPrint((2, "' enter InternalOpenInterface\n"));
    USBPORT_KdPrint((2, "' Interface %d Altsetting %d\n",
        InterfaceInformation->InterfaceNumber,
        InterfaceInformation->AlternateSetting));

    //
    // Find the interface descriptor we are interested in inside
    // the configuration descriptor.
    //

    interfaceDescriptor =
        USBPORT_InternalParseConfigurationDescriptor(ConfigHandle->ConfigurationDescriptor,
                                          InterfaceInformation->InterfaceNumber,
                                          InterfaceInformation->AlternateSetting,
                                          &hasAlternateSettings);

    // we already validated this, if it is NULL 
    // the function has a bug.
    USBPORT_ASSERT(interfaceDescriptor != NULL);
    if (interfaceDescriptor == NULL) {
        BUGCHECK(USBBUGCODE_INTERNAL_ERROR, (ULONG_PTR) DeviceHandle, 0, 0);
        // keep prefix scanner happy
        return USBD_STATUS_SUCCESS;        
    }
    
    //
    // We got the interface descriptor, now try
    // to open all the pipes.
    //

    // found the requested interface in the configuration descriptor.


    numEndpoints = interfaceDescriptor->bNumEndpoints;
    need = (USHORT) (((numEndpoints-1) * sizeof(USBD_PIPE_INFORMATION) +
            sizeof(USBD_INTERFACE_INFORMATION)));
            
    // we should have already validated this
    USBPORT_ASSERT(InterfaceInformation->Length == need);

    if (hasAlternateSettings && 
        SendSetInterfaceCommand) {

        NTSTATUS ntStatus;
        //
        // If we have alternate settings we need
        // to send the set interface command.
        //

        USBPORT_INIT_SETUP_PACKET(setupPacket,
            USB_REQUEST_SET_INTERFACE, // bRequest
            BMREQUEST_HOST_TO_DEVICE, // Dir
            BMREQUEST_TO_INTERFACE, // Recipient
            BMREQUEST_STANDARD, // Type
            InterfaceInformation->AlternateSetting, // wValue
            InterfaceInformation->InterfaceNumber, // wIndex
            0); // wLength
  

        ntStatus = USBPORT_SendCommand(DeviceHandle,
                           FdoDeviceObject,
                           &setupPacket,
                           NULL,
                           0,
                           NULL,
                           &usbdStatus);

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'seIF', 
            ntStatus,
            InterfaceInformation->AlternateSetting,
            InterfaceInformation->InterfaceNumber);                           
                           
        if (USBD_ERROR(usbdStatus)) {                               
            DEBUG_BREAK();
            goto USBPORT_InternalOpenInterface_Done;    
        }

        USBPORT_ASSERT(ntStatus == STATUS_SUCCESS);
        
    }

    //
    // we successfully selected the alternate interface
    // initialize the interface handle and open the pipes
    //

    if (*InterfaceHandle == NULL) {
    
        ULONG privateLength = sizeof(USBD_INTERFACE_HANDLE_I) +
                              sizeof(USBD_PIPE_HANDLE_I) * numEndpoints;

        // allow space for a copy of the USBD_INTERFACE_INFORMATION
        // that is returned to the client
        ALLOC_POOL_Z(interfaceHandle, 
                     NonPagedPool,
                     privateLength);
                              
        if (interfaceHandle != NULL) {
            // initialize the pipe handles to a known state
            for (i=0; i<numEndpoints; i++) {
                interfaceHandle->PipeHandle[i].Endpoint = NULL;
                interfaceHandle->PipeHandle[i].Sig = SIG_PIPE_HANDLE;
                interfaceHandle->PipeHandle[i].PipeStateFlags = 
                    USBPORT_PIPE_STATE_CLOSED;
                //interfaceHandle->PipeHandle[i].ListEntry.Flink = NULL;
                //interfaceHandle->PipeHandle[i].ListEntry.Blink = NULL;    
            }        
            allocated = TRUE;
        } else {
            TEST_TRAP();
            usbdStatus = USBD_STATUS_INSUFFICIENT_RESOURCES;                    
TEST_TRAP();                 
            goto USBPORT_InternalOpenInterface_Done;
        }
        
    } else {
        // using old handle
        interfaceHandle = *InterfaceHandle;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'ihIF', 
            interfaceHandle,
            0,
            0);   

    USBPORT_ASSERT(interfaceHandle != NULL);
    
    interfaceHandle->Sig = SIG_INTERFACE_HANDLE;
    interfaceHandle->HasAlternateSettings = hasAlternateSettings;

    InterfaceInformation->NumberOfPipes = 
        interfaceDescriptor->bNumEndpoints;
    InterfaceInformation->Class =
        interfaceDescriptor->bInterfaceClass;
    InterfaceInformation->SubClass =
        interfaceDescriptor->bInterfaceSubClass;
    InterfaceInformation->Protocol =
        interfaceDescriptor->bInterfaceProtocol;
    InterfaceInformation->Reserved = 0;
    
    // start with first endpoint
    // skip over any non-endpoint descriptors
    pch = (PUCHAR) (interfaceDescriptor) +
        interfaceDescriptor->bLength;

    // initialize the pipe fields for this interfacae

    // assume success
    usbdStatus = USBD_STATUS_SUCCESS;       

    interfaceHandle->InterfaceDescriptor = *interfaceDescriptor;
    for (i=0; i<numEndpoints; i++) {
        USB_HIGH_SPEED_MAXPACKET muxPacket;
        
        descriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        while (descriptor->bDescriptorType != 
               USB_ENDPOINT_DESCRIPTOR_TYPE) {
            if (descriptor->bLength == 0) {
                break; // Don't loop forever
            }
            pch += descriptor->bLength;
            descriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        }

        endpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR) pch;
        USBPORT_ASSERT(endpointDescriptor->bDescriptorType ==
            USB_ENDPOINT_DESCRIPTOR_TYPE);

        // initial state is CLOSED
        interfaceHandle->PipeHandle[i].PipeStateFlags = 
            USBPORT_PIPE_STATE_CLOSED;
        interfaceHandle->PipeHandle[i].Endpoint = NULL;                 

        // init pipe flags
        interfaceHandle->PipeHandle[i].UsbdPipeFlags = 
            InterfaceInformation->Pipes[i].PipeFlags;
        
        if (InterfaceInformation->Pipes[i].PipeFlags &
            USBD_PF_CHANGE_MAX_PACKET) {
            // client wants to override original max_packet
            // size in endpoint descriptor
             endpointDescriptor->wMaxPacketSize =
                InterfaceInformation->Pipes[i].MaximumPacketSize;

            USBPORT_KdPrint((2,
                "'new bMaxPacket 0x%x\n", endpointDescriptor->wMaxPacketSize));
        }

        //
        // copy the endpoint descriptor into the
        // pipe handle structure.
        //

        RtlCopyMemory(&interfaceHandle->PipeHandle[i].EndpointDescriptor,
                      pch,
                      sizeof(interfaceHandle->PipeHandle[i].EndpointDescriptor) );

        // advance to next endpoint
        // first field in endpoint descriptor is length
        pch += endpointDescriptor->bLength;

        //
        // return information about the pipe
        //
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'ipIF', 
            interfaceHandle,
            i,
            &interfaceHandle->PipeHandle[i]);  

        InterfaceInformation->Pipes[i].EndpointAddress =
            endpointDescriptor->bEndpointAddress;
        InterfaceInformation->Pipes[i].PipeType =
            PipeTypes[endpointDescriptor->bmAttributes & USB_ENDPOINT_TYPE_MASK];
        muxPacket.us = endpointDescriptor->wMaxPacketSize;            
        InterfaceInformation->Pipes[i].MaximumPacketSize =
             muxPacket.MaxPacket * (muxPacket.HSmux+1);
        InterfaceInformation->Pipes[i].Interval =
            endpointDescriptor->bInterval;

        InterfaceInformation->Pipes[i].PipeHandle = 
            USBPORT_BAD_HANDLE;

    } /* end for numEndpoints */

    if (usbdStatus != USBD_STATUS_SUCCESS) {
        // if we got an error bail now
        // we will return with the structure
        // initailized but no open pipes
        goto USBPORT_InternalOpenInterface_Done;
    }

    // all pipe handle fields initialized and
    // urb structure has been filled in 

    // now loop thru and open the pipes
    for (i=0; i<interfaceDescriptor->bNumEndpoints; i++) {
        NTSTATUS ntStatus;
        
        ntStatus = USBPORT_OpenEndpoint(DeviceHandle,
                                        FdoDeviceObject,
                                        &interfaceHandle->PipeHandle[i],
                                        &usbdStatus,
                                        FALSE);

        if (NT_SUCCESS(ntStatus)) {

            // if success set the pipe handle for client
            InterfaceInformation->Pipes[i].PipeHandle = 
                &interfaceHandle->PipeHandle[i];
            USBPORT_KdPrint((2, "'pipe handle = 0x%x\n", 
                InterfaceInformation->Pipes[i].PipeHandle ));

        } else {
                
            USBPORT_KdPrint((1,
                "'error opening one of the pipes in interface (%x)\n", usbdStatus));
            ntStatus = SET_USBD_ERROR(Urb, usbdStatus);
            break;
        }                                                    
    }


USBPORT_InternalOpenInterface_Done:

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'oIFd', 
        InterfaceInformation->InterfaceNumber,
        InterfaceInformation->AlternateSetting,
        usbdStatus);

    if (USBD_SUCCESS(usbdStatus)) {

        //
        // successfully opened the interface, return the handle
        // to it
        //

        *InterfaceHandle =
            InterfaceInformation->InterfaceHandle = interfaceHandle;

        //
        // set the length properly, the value we already
        // calculated
        //

        InterfaceInformation->Length = (USHORT) need;

    } else {

        //
        // had a problem, go back thru and close anything we opened.
        //

        if (interfaceHandle) {

            for (i=0; i<numEndpoints; i++) {
            
                USBPORT_KdPrint((2, "'open interface cleanup -- closing endpoint %x\n",
                              &interfaceHandle->PipeHandle[i]));

                // fortunately this cannot fail
                USBPORT_ClosePipe(DeviceHandle,
                                  FdoDeviceObject,
                                  &interfaceHandle->PipeHandle[i]);

            }

            if (allocated) {
                FREE_POOL(FdoDeviceObject, interfaceHandle);
                interfaceHandle = NULL;
            }
            
        }            
    }

    USBPORT_KdPrint((3, "' exit InternalOpenInterface 0x%x\n", usbdStatus));

    return usbdStatus;
}


VOID
USBPORT_InternalCloseConfiguration(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG Flags
    )
/*++

Routine Description:

    Closes the current configuration for a device.

Arguments:


Return Value:

    this function cannot fail


--*/
{
    ULONG i, j;
    PUSBD_CONFIG_HANDLE configHandle = NULL;
    BOOLEAN retry = TRUE;
    ULONG interfaceCount;

    PAGED_CODE();

    // device handle MUST be valid
    ASSERT_DEVICE_HANDLE(DeviceHandle);
    configHandle = DeviceHandle->ConfigurationHandle;

    if (configHandle == NULL) {
        // device is not configured      
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'nCFG', 0, 0, DeviceHandle);
        goto USBPORT_InternalCloseConfiguration_Done;
    }
    
    ASSERT_CONFIG_HANDLE(configHandle);
    interfaceCount = configHandle->ConfigurationDescriptor->bNumInterfaces;

    LOGENTRY(NULL, FdoDeviceObject, 
            LOG_PNP, 'cCFG', interfaceCount, 0, configHandle);
    
    // we ensure that all transfers are aborted for the device handle
    // before calling this function so the close configuration will 
    // not fail


    // do the cleanup
    
    while (!IsListEmpty(&configHandle->InterfaceHandleList)) {

        //
        // found an open interface, close it
        //

        PUSBD_INTERFACE_HANDLE_I iHandle;
        ULONG endpointCount; 
        PLIST_ENTRY listEntry;
        
        listEntry = RemoveHeadList(&configHandle->InterfaceHandleList);
        iHandle = (PUSBD_INTERFACE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_INTERFACE_HANDLE_I, 
                    InterfaceLink);
        
        ASSERT_INTERFACE(iHandle);

        endpointCount = iHandle->InterfaceDescriptor.bNumEndpoints;

        LOGENTRY(NULL, FdoDeviceObject, 
            LOG_PNP, 'cIFX', iHandle, 0, configHandle);
            
        USBPORT_KdPrint((2, "'%d endpoints to close\n", endpointCount));

        for (j=0; j<endpointCount; j++) {
        
            PUSBD_PIPE_HANDLE_I pipeHandle;
            
            // if the pipe is open, close it

            pipeHandle = &iHandle->PipeHandle[j];
            
            USBPORT_KdPrint((2, "'close config -- closing pipe %x\n",
                &iHandle->PipeHandle[j]));
                
            USBPORT_ClosePipe(DeviceHandle,
                              FdoDeviceObject,
                              pipeHandle);

            USBPORT_ASSERT(pipeHandle->ListEntry.Flink == NULL &&
                           pipeHandle->ListEntry.Flink == NULL);
        }

        // all pipes are now closed
        FREE_POOL(FdoDeviceObject, iHandle);
    }

    // NOTE: this also frees 
    // configHandle->ConfigurationDescriptor since it 
    // is in the same block allocated for the confighandle
    FREE_POOL(FdoDeviceObject, configHandle);
    // device is not 'unconfigured'
    DeviceHandle->ConfigurationHandle = NULL;

USBPORT_InternalCloseConfiguration_Done:

    USBPORT_KdPrint((2, "'current configuration closed\n"));

}


PUSB_INTERFACE_DESCRIPTOR
USBPORT_InternalParseConfigurationDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    UCHAR InterfaceNumber,
    UCHAR AlternateSetting,
    PBOOLEAN HasAlternateSettings
    )
/*++

Routine Description:

    Get the configuration descriptor for a given device.

Arguments:

    DeviceObject -

    DeviceData -

    Urb -

    ConfigurationDescriptor -

Return Value:


--*/
{
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptorSetting = NULL;
    PUCHAR pch = (PUCHAR) ConfigurationDescriptor, end;
    ULONG i;
    PUSB_COMMON_DESCRIPTOR commonDescriptor;

    PAGED_CODE();
    if (HasAlternateSettings) {
        *HasAlternateSettings = FALSE;
    }

    commonDescriptor =
        (PUSB_COMMON_DESCRIPTOR) (pch + ConfigurationDescriptor->bLength);

    while (commonDescriptor->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE) {
        if (commonDescriptor->bLength == 0) {
            break; // Don't loop forever
        }
        ((PUCHAR)(commonDescriptor))+= commonDescriptor->bLength;
    }

    interfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR) commonDescriptor;
    USBPORT_ASSERT(interfaceDescriptor->bDescriptorType ==
                USB_INTERFACE_DESCRIPTOR_TYPE);

    end = pch + ConfigurationDescriptor->wTotalLength;

    //
    // First find the matching InterfaceNumber
    //
    while (pch < end && interfaceDescriptor->bInterfaceNumber != InterfaceNumber) {
        pch = (PUCHAR) interfaceDescriptor;
        pch += USBPORT_InternalGetInterfaceLength(interfaceDescriptor, end);

        // point to the next interface
        interfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR) pch;
#if DBG
        if (pch < end) {
            USBPORT_ASSERT(interfaceDescriptor->bDescriptorType ==
                    USB_INTERFACE_DESCRIPTOR_TYPE);
        }
#endif //MAX_DEBUG
    }

//#ifdef MAX_DEBUG
//    if (pch >= end) {
//        USBD_KdPrint(3, ("'Interface %x alt %x not found!\n", InterfaceNumber,
//            AlternateSetting));
//        TEST_TRAP();
//    }
//#endif //MAX_DEBUG

    i = 0;
    // Now find the proper alternate setting
    while (pch < end && interfaceDescriptor->bInterfaceNumber == InterfaceNumber) {

        if (interfaceDescriptor->bAlternateSetting == AlternateSetting) {
            interfaceDescriptorSetting = interfaceDescriptor;
        }

        pch = (PUCHAR) interfaceDescriptor;
        pch += USBPORT_InternalGetInterfaceLength(interfaceDescriptor, end);

        // point to next interface
        interfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR) pch;
#if DBG
        if (pch < end) {
            USBPORT_ASSERT(interfaceDescriptor->bDescriptorType ==
                    USB_INTERFACE_DESCRIPTOR_TYPE);
        }
#endif
        i++;
    }

    if (i>1 && HasAlternateSettings) {
        *HasAlternateSettings = TRUE;
        USBPORT_KdPrint((2, "'device has alternate settings!\n"));
    }

    return interfaceDescriptorSetting;
}


ULONG
USBPORT_InternalGetInterfaceLength(
    PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor,
    PUCHAR End
    )
/*++

Routine Description:

    Initialize the configuration handle structure.

Arguments:

    InterfaceDescriptor - pointer to usb interface descriptor
        followed by endpoint descriptors

Return Value:

    Length of the interface plus endpoint descriptors and class specific
    descriptors in bytes.

--*/
{
    PUCHAR pch = (PUCHAR) InterfaceDescriptor;
    ULONG i, numEndpoints;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor;
    PUSB_COMMON_DESCRIPTOR usbDescriptor;

    PAGED_CODE();
    USBPORT_ASSERT(InterfaceDescriptor->bDescriptorType ==
                USB_INTERFACE_DESCRIPTOR_TYPE);
    i = InterfaceDescriptor->bLength;
    numEndpoints = InterfaceDescriptor->bNumEndpoints;

    // advance to the first endpoint
    pch += i;

    while (numEndpoints) {

        usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        while (usbDescriptor->bDescriptorType !=
                USB_ENDPOINT_DESCRIPTOR_TYPE) {
            if (usbDescriptor->bLength == 0) {
                break; // Don't loop forever
            }
            i += usbDescriptor->bLength;
            pch += usbDescriptor->bLength;
            usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        }

        endpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR) pch;
        USBPORT_ASSERT(endpointDescriptor->bDescriptorType ==
            USB_ENDPOINT_DESCRIPTOR_TYPE);
        i += endpointDescriptor->bLength;
        pch += endpointDescriptor->bLength;
        numEndpoints--;
    }

    while (pch < End) {
        // see if we are pointing at an interface
        // if not skip over the other junk
        usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        if (usbDescriptor->bDescriptorType ==
            USB_INTERFACE_DESCRIPTOR_TYPE) {
            break;
        }

        USBPORT_ASSERT(usbDescriptor->bLength != 0);
        if (usbDescriptor->bLength == 0) {
            break; // Don't loop forever
        }
        i += usbDescriptor->bLength;
        pch += usbDescriptor->bLength;
    }


    return i;
}


BOOLEAN
USBPORT_ValidateConfigurtionDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    USBD_STATUS *UsbdStatus
    )   
/*++

Routine Description:

    Validate a configuration descriptor

Arguments:

    ConfigurationDescriptor -

    Urb -

Return Value:

    TRUE if it looks valid

--*/
{
    BOOLEAN valid = TRUE;

    if (ConfigurationDescriptor->bDescriptorType != 
        USB_CONFIGURATION_DESCRIPTOR_TYPE) {

        valid = FALSE;

        *UsbdStatus = USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR;
    }        

    if (ConfigurationDescriptor->bLength != 
        sizeof(USB_CONFIGURATION_DESCRIPTOR)) {

        valid = FALSE;

        *UsbdStatus = USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR;
    }   
    
    return valid;            
    
}            


PUSBD_INTERFACE_HANDLE_I
USBPORT_GetInterfaceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_CONFIG_HANDLE ConfigurationHandle,
    UCHAR InterfaceNumber
    )
/*++

Routine Description:

   Walks the list of interfaces attached to the configuration
   handle and returns the one with the matching InterfaceNumber

Arguments:


Return Value:

    interface handle


--*/
{
    PLIST_ENTRY listEntry;
    PUSBD_INTERFACE_HANDLE_I iHandle;
    
     // walk the list
    GET_HEAD_LIST(ConfigurationHandle->InterfaceHandleList, listEntry);

    while (listEntry && 
           listEntry != &ConfigurationHandle->InterfaceHandleList) {
           
        // extract the handle from this entry 
        iHandle = (PUSBD_INTERFACE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_INTERFACE_HANDLE_I, 
                    InterfaceLink);
                    
        ASSERT_INTERFACE(iHandle);                    

        // is this the one we want?
        if (iHandle->InterfaceDescriptor.bInterfaceNumber == 
            InterfaceNumber) {

            LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'gfh1', iHandle, 0, 0);  
            return iHandle;
        }

        listEntry = iHandle->InterfaceLink.Flink; 
        
    } /* while */

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'gfh2', 0, 0, 0);  
    return NULL;
}


USBD_STATUS
USBPORT_InitializeInterfaceInformation(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    PUSBD_CONFIG_HANDLE ConfigHandle
    )
/*++

Routine Description:

    validates and initializes the interface information structure
    passed by the client

Arguments:

Return Value:


--*/
{
    ULONG need, i;
    ULONG numEndpoints;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    BOOLEAN hasAlternateSettings;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    
    interfaceDescriptor =
        USBPORT_InternalParseConfigurationDescriptor(
                                          ConfigHandle->ConfigurationDescriptor,
                                          InterfaceInformation->InterfaceNumber,
                                          InterfaceInformation->AlternateSetting,
                                          &hasAlternateSettings);

    // we know we need at least this much
    need = sizeof(USBD_PIPE_INFORMATION) + sizeof(USBD_INTERFACE_INFORMATION);
    
    if (interfaceDescriptor == NULL) {
        usbdStatus = USBD_STATUS_INTERFACE_NOT_FOUND;
        TEST_TRAP();  
        goto USBPORT_InitializeInterfaceInformation_Done;
    }
    
    // Here is where we verify there is enough room in the client
    // buffer since we know how many pipes we'll need based on the
    // interface descriptor.
    //
    // we need space for pipe_info for each endpoint plus the 
    // interface_info

    
    numEndpoints = interfaceDescriptor->bNumEndpoints;
    need = (USHORT) (((numEndpoints-1) * sizeof(USBD_PIPE_INFORMATION) +
                sizeof(USBD_INTERFACE_INFORMATION)));

    USBPORT_KdPrint((2, "'Interface.Length = %d need = %d\n", 
        InterfaceInformation->Length, need));

    if (InterfaceInformation->Length < need) {
        // the client has indicated that the buffer
        // is smaller than what we need
        
        usbdStatus = USBD_STATUS_BUFFER_TOO_SMALL;
        TC_TRAP();             
    }                      

    if (usbdStatus == USBD_STATUS_SUCCESS) {
        // initialize all fields not set by caller to zero 

        InterfaceInformation->Class = 0;
        InterfaceInformation->SubClass = 0;
        InterfaceInformation->Protocol = 0;
        InterfaceInformation->Reserved = 0;
        InterfaceInformation->InterfaceHandle = NULL;
        InterfaceInformation->NumberOfPipes = 
            numEndpoints;

        for (i=0; i< numEndpoints; i++) {
            InterfaceInformation->Pipes[i].EndpointAddress = 0;
            InterfaceInformation->Pipes[i].Interval = 0;
            InterfaceInformation->Pipes[i].PipeType = 0;
            InterfaceInformation->Pipes[i].PipeHandle = NULL;

            // attempt to detect bad flags
            // if any unused bits are set we assume that the pipeflags 
            // field is uninitialized.
            if (InterfaceInformation->Pipes[i].PipeFlags & ~USBD_PF_VALID_MASK) {
                // client driver is passing bad flags
                USBPORT_DebugClient(("client driver is passing bad pipe flags\n"));
                
                usbdStatus = USBD_STATUS_INAVLID_PIPE_FLAGS;                    
                TC_TRAP();         
            }

            // note: if USBD_PF_CHANGE_MAX_PACKET is set then 
            // maxpacket size is passed in as a parameter so 
            // we don't initialize it
            
            if (!TEST_FLAG(InterfaceInformation->Pipes[i].PipeFlags,  
                           USBD_PF_CHANGE_MAX_PACKET)) {
                InterfaceInformation->Pipes[i].MaximumPacketSize = 0;                           
            }                           
        }
    }
    
USBPORT_InitializeInterfaceInformation_Done:

    // set length to the correct value regardless 
    // of error
    InterfaceInformation->Length = need;

    return usbdStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\dbg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros
    
Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

#define USBPORT_TAG          'pbsu'        //"USBP"


#if DBG
/**********
DUBUG
***********/

#define UNSIG(x) (x)->Sig = SIG_FREE 

// this is a code coverage test trap -- we use them to determine 
// if our tests are covering a particular code path.
#define TC_TRAP()  


// 
// Triggers a break in the debugger iff the registry key
// debugbreakOn is set.  These breakpoints are useful for
// debugging hardware/client software problems
//
// they are not on by default, do not comment them out
//

#define DEBUG_BREAK()  do {\
                            extern ULONG USBPORT_BreakOn;\
                            if (USBPORT_BreakOn) {\
                                DbgPrint("<USB DEBUG BREAK> %s, line %d\n",\
                                    __FILE__, __LINE__);\
                                DbgBreakPoint();\
                            }\
                        } while (0)                           

//
// This Breakpoint means we either need to test the code path 
// somehow or the code is not implemented.  ie either case we
// should not have any of these when the driver is finished
// and tested
//

#define TEST_TRAP()         {\
                            DbgPrint("<TEST_TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                            }

//
// This trap is triggered in the event that something non-fatal 
// has occurred that we will want to 'debug'.
//

#define BUG_TRAP()         {\
                            DbgPrint("<BUG_TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                            }


//
// This trap means something very bad has happened, the system will crash 
//

#define BUGCHECK(bc, p2, p3, p4)         {\
                            DbgPrint("<USB BUGCHECK> %s, line %d\n", __FILE__, __LINE__);\
                            KeBugCheckEx(BUGCODE_USB_DRIVER, (bc), (p2), (p3), (p4)); \
                            }


#define CATC_TRAP(d) USBPORT_CatcTrap((d))

#define CATC_TRAP_ERROR(d, e) \
    do {\
    extern ULONG USBPORT_CatcTrapEnable;\
    if (!NT_SUCCESS((e) && USBPORT_CatcTrapEnable)) { \
        USBPORT_CatcTrap((d));\
    }\
    }\
    while(0)

ULONG
_cdecl
USBPORT_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

ULONG
_cdecl
USBPORT_DebugClientX(
    PCH Format,
    ...
    );    

#define   USBPORT_KdPrint(_x_) USBPORT_KdPrintX _x_
#define   USBPORT_DebugClient(_x_) USBPORT_DebugClientX _x_

VOID
USBPORT_AssertFailure(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define USBPORT_ASSERT( exp ) \
    if (!(exp)) {\
        USBPORT_AssertFailure( #exp, __FILE__, __LINE__, NULL );\
    }        


#define ASSERT_PDOEXT(de)  USBPORT_ASSERT((de)->Sig == ROOTHUB_DEVICE_EXT_SIG)    
#define ASSERT_FDOEXT(de)  USBPORT_ASSERT((de)->Sig == USBPORT_DEVICE_EXT_SIG)   

#define ASSERT_DEVICE_HANDLE(d) USBPORT_ASSERT((d)->Sig == SIG_DEVICE_HANDLE)
#define ASSERT_CONFIG_HANDLE(d) USBPORT_ASSERT((d)->Sig == SIG_CONFIG_HANDLE)
#define ASSERT_PIPE_HANDLE(d) USBPORT_ASSERT((d)->Sig == SIG_PIPE_HANDLE)
#define ASSERT_INTERFACE_HANDLE(d) USBPORT_ASSERT((d)->Sig == SIG_INTERFACE_HANDLE)
#define ASSERT_ENDPOINT(d) USBPORT_ASSERT((d)->Sig == SIG_ENDPOINT)
#define ASSERT_TRANSFER(d) USBPORT_ASSERT((d)->Sig == SIG_TRANSFER)
#define ASSERT_COMMON_BUFFER(d) USBPORT_ASSERT((d)->Sig == SIG_CMNBUF)
#define ASSERT_INTERFACE(d) USBPORT_ASSERT((d)->Sig == SIG_INTERFACE_HANDLE)
#define ASSERT_TT(tt) USBPORT_ASSERT((tt)->Sig == SIG_TT)
#define ASSERT_DB_HANDLE(db) USBPORT_ASSERT((db)->Sig == SIG_DB)
#define ASSERT_IRP_CONTEXT(ic) USBPORT_ASSERT((ic)->Sig == SIG_IRPC)

#define ASSERT_ENDPOINT_LOCKED(ep) USBPORT_ASSERT((ep)->LockFlag == 1)

#define ASSERT_TRANSFER_URB(u) USBPORT_AssertTransferUrb((u))

NTSTATUS
USBPORT_GetGlobalDebugRegistryParameters(
    VOID
    );

#define GET_GLOBAL_DEBUG_PARAMETERS() \
    USBPORT_GetGlobalDebugRegistryParameters();

#define ASSERT_PASSIVE() \
    do {\
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        KdPrint(( "EX: code not expecting high irql %d\n", KeGetCurrentIrql() )); \
        USBPORT_ASSERT(FALSE); \
    }\
    } while(0)

// test failure paths
#define FAILED_GETRESOURCES              1
#define FAILED_LOWER_START               2
#define FAILED_REGISTERUSBPORT           3
#define FAILED_USBPORT_START             4
#define FAILED_NEED_RESOURCE             5

#define TEST_PATH(status, pathname) \
    { \
    extern USBPORT_TestPath;\
    if ((pathname) == USBPORT_TestPath) {\
        status = STATUS_UNSUCCESSFUL;\
    }\
    }

#define USBPORT_AcquireSpinLock(fdo, sl, oir) USBPORT_DbgAcquireSpinLock((fdo), (sl), (oir))

#define USBPORT_ReleaseSpinLock(fdo, sl, nir) USBPORT_DbgReleaseSpinLock((fdo), (sl), (nir))

#define USBPORT_ENUMLOG(fdo, etag, p1, p2)\
        USBPORT_EnumLogEntry((fdo), USBDTAG_USBPORT, etag, (ULONG) p1, (ULONG) p2)

#else 
/**********
RETAIL
***********/

// debug macros for retail build

#define TEST_TRAP()
#define TRAP()
#define BUG_TRAP()

#define GET_GLOBAL_DEBUG_PARAMETERS()
#define ASSERT_PASSIVE()

#define ASSERT_PDOEXT(de)      
#define ASSERT_FDOEXT(de)     

#define ASSERT_DEVICE_HANDLE(d) 
#define ASSERT_CONFIG_HANDLE(d) 
#define ASSERT_PIPE_HANDLE(d) 
#define ASSERT_INTERFACE_HANDLE(d) 
#define ASSERT_ENDPOINT(d) 
#define ASSERT_TRANSFER(d) 
#define ASSERT_COMMON_BUFFER(d) 
#define ASSERT_INTERFACE(d)
#define ASSERT_TRANSFER_URB(u)
#define ASSERT_TT(tt)
#define ASSERT_DB_HANDLE(tt)
#define ASSERT_IRP_CONTEXT(ic)

#define ASSERT_ENDPOINT_LOCKED(ep) 

#define DEBUG_BREAK()
#define TC_TRAP()

#define BUGCHECK(bc, p2, p3, p4)  {\
                    KeBugCheckEx(BUGCODE_USB_DRIVER, (bc), (p2), (p3), (p4)); \
                    }

#define CATC_TRAP(d) 

#define CATC_TRAP_ERROR(d, e) 

#define   USBPORT_KdPrint(_x_) 
#define   USBPORT_DebugClient(_x_) 

#define USBPORT_ASSERT(exp)

#define TEST_PATH(status, path)

#define UNSIG(x)  

#define USBPORT_AcquireSpinLock(fdo, sl, oir) \
    KeAcquireSpinLock((PKSPIN_LOCK)(sl), (oir))

#define USBPORT_ReleaseSpinLock(fdo, sl, nir) \
    KeReleaseSpinLock((PKSPIN_LOCK)(sl), (nir))


#define USBPORT_ENUMLOG(fdo, etag, p1, p2)

#endif /* DBG */

/*************
RETAIL & DEBUG
**************/

VOID USBP2LIBFN
USB2LIB_DbgPrint(
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    );

VOID USBP2LIBFN
USB2LIB_DbgBreak(
    VOID
    );    

VOID
USBPORTSVC_DbgPrint(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    );

VOID
USBPORTSVC_TestDebugBreak(
    PVOID DeviceData
    );

VOID
USBPORTSVC_AssertFailure(
    PVOID DeviceData,
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );    

/*
    since log entries may hold pointers the size of a log struct 
    varies with the platform
*/

#ifdef _WIN64
#define LOG_ENTRY LOG_ENTRY64    
#define PLOG_ENTRY PLOG_ENTRY64  
#else 
#define LOG_ENTRY LOG_ENTRY32 
#define PLOG_ENTRY PLOG_ENTRY32 
#endif

typedef struct LOG_ENTRY64 {
    ULONG        le_sig;          // Identifying string
    ULONG        pad;
    ULONG64      le_info1;        // entry specific info
    ULONG64      le_info2;        // entry specific info
    ULONG64      le_info3;        // entry specific info
} LOG_ENTRY64, *PLOG_ENTRY64; /* LOG_ENTRY */

typedef struct LOG_ENTRY32 {
    ULONG        le_sig;          // Identifying string
    ULONG        le_info1;        // entry specific info
    ULONG        le_info2;        // entry specific info
    ULONG        le_info3;        // entry specific info
} LOG_ENTRY32, *PLOG_ENTRY32; /* LOG_ENTRY */


/* This structure is 64 bytes regardless of platform */

struct XFER_LOG_ENTRY {
    ULONG        xle_sig;          // Identifying string
    ULONG        Unused1;

    ULONG        BytesRequested;
    ULONG        BytesTransferred;
    
    ULONG        UrbStatus;
    ULONG        IrpStatus;

    USHORT       DeviceAddress;
    USHORT       EndpointAddress;
    ULONG        TransferType;
    
    ULONG64      Irp;        
    ULONG64      Urb;        
    ULONG64      le_info0;        
    ULONG64      le_info1;   
}; /* XFER_LOG_ENTRY */


typedef struct _DEBUG_LOG {
    ULONG LogIdx;
    ULONG LogSizeMask;
    PLOG_ENTRY LogStart; 
    PLOG_ENTRY LogEnd;
} DEBUG_LOG, *PDEBUG_LOG;       


VOID
USBPORT_DebugTransfer_LogEntry(
    PDEVICE_OBJECT FdoDeviceObject,
    struct _HCD_ENDPOINT *Endpoint,
    struct _HCD_TRANSFER_CONTEXT *Transfer,
    struct _TRANSFER_URB *Urb,
    PIRP Irp,
    NTSTATUS IrpStatus
    );


// log noisy is for entries that tend
// to fill up the log and we genrally
// don' use
#define LOG_NOISY       0x00000001
#define LOG_MINIPORT    0x00000002
#define LOG_XFERS       0x00000004
#define LOG_PNP         0x00000008
#define LOG_MEM         0x00000010
#define LOG_SPIN        0x00000020
#define LOG_POWER       0x00000040
#define LOG_RH          0x00000080
#define LOG_URB         0x00000100
#define LOG_MISC        0x00000200
#define LOG_ISO         0x00000400
#define LOG_IRPS        0x00000800


VOID
USBPORT_LogAlloc(
    PDEBUG_LOG Log,
    ULONG Pages
    );   

VOID
USBPORT_LogFree(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEBUG_LOG Log      
    );    

VOID
USBPORT_AddLogEntry(
    PDEBUG_LOG Log,
    ULONG Mask,
    ULONG Sig, 
    ULONG_PTR Info1, 
    ULONG_PTR Info2, 
    ULONG_PTR Info3,
    BOOLEAN Miniport
    );        

typedef union _LOGSIG {
    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    } b;
    ULONG l;
} LOGSIG, *PLOGSIG;

#define LOGENTRY(ep, fdo, lmask, lsig, linfo1, linfo2, linfo3)  \
    do {\
    PDEVICE_EXTENSION delog;\
    PDEBUG_LOG llog;\
    extern ULONG USBPORT_DebugLogEnable;\
    extern ULONG USBPORT_LogMask;\
    GET_DEVICE_EXT(delog, (fdo));\
    ASSERT_FDOEXT(delog);\
    if (USBPORT_DebugLogEnable && \
        delog->Log.LogStart != NULL && \
        ((lmask) & USBPORT_LogMask)) {\
        llog = &delog->Log;\
        USBPORT_AddLogEntry(llog, (lmask), (lsig), (linfo1), (linfo2), (linfo3), FALSE);\
    }\
    } while(0);

#define USBPORT_AddLogEntry(log, mask, insig, i1, i2, i3, mp) \
    {\
    PLOG_ENTRY lelog;\
    ULONG ilog;\
    LOGSIG siglog, rsiglog;\
    siglog.l = (insig);\
    rsiglog.b.Byte0 = siglog.b.Byte3;\
    rsiglog.b.Byte1 = siglog.b.Byte2;\
    rsiglog.b.Byte2 = siglog.b.Byte1;\
    rsiglog.b.Byte3 = siglog.b.Byte0;\
    ASSERT((insig) != 0);\
    ilog = InterlockedDecrement(&(log)->LogIdx);\
    ilog &= (log)->LogSizeMask;\
    lelog = (log)->LogStart+ilog;\
    ASSERT(lelog <= (log)->LogEnd);\
    if ((mp)) rsiglog.b.Byte0 = '_';\
    lelog->le_sig = rsiglog.l;\
    lelog->le_info1 = (ULONG_PTR) (i1);\
    lelog->le_info2 = (ULONG_PTR) (i2);\
    lelog->le_info3 = (ULONG_PTR) (i3);\
    };

VOID
USBPORT_EnumLogEntry(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG DriverTag,
    ULONG EnumTag,
    ULONG P1,
    ULONG P2
    );

/***********
USB BUGCODES

Parameter 1 to the USB bugcheck is always the USBBUGCODE_
************/


//
// USBBUGCODE_INTERNAL_ERROR
// An internal error has occurred in the USB stack
// -- we will eventually never throw these instead 
// -- we will find a more graceful way to handle them
//

#define USBBUGCODE_INTERNAL_ERROR    1

//
// USBBUGCODE_BAD_URB
// The USB client driver has submitted a URB that is 
// already attached to another irp pending in the bus 
// driver.  
//
// parameter 2 = address of Pending IRP urb is attached
// parameter 3 = address of  IRP passed in
// parameter 4 = address URB that caused the error
// 

#define USBBUGCODE_BAD_URB           2

//
// USBBUGCODE_MINIPORT_ERROR
// The USB miniport driver has generated a bugcheck. 
// This is usually in response to catastrophic hardware 
// failure.
//
// parameter 2 = PCI Vendor,Product id for the controller
// parameter 3 = pointer to usbport.sys debug log
// 

#define USBBUGCODE_MINIPORT_ERROR    3

//
// USBBUGCODE_DOUBLE_SUBMIT
// The USB client driver has submitted a URB that is 
// already attached to another irp pending in the bus 
// driver.  
//
// parameter 2 = address of IRP
// parameter 3 = address URB that caused the error
// 

#define USBBUGCODE_DOUBLE_SUBMIT    4

//
// USBBUGCODE_MINIPORT_ERROR_EX
// The USB miniport driver has generated a bugcheck. 
// This is usually in response to catastrophic hardware 
// failure. 
//
// parameter 2 = PCI Vendor,Product id for the controller
// parameter 3 = pointer to usbport.sys driver log
// parameter 4 = miniport defined parameter
// 

//#define USBBUGCODE_MINIPORT_ERROR_EX  5


#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\cmnbuf.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cmnbuf.c

Abstract:

    Code to manage common buffer -- hardware addressable memory

    a common buffer block looks like this

start    ------------ <- address returned from the hal
         padding
         ------------ <- address returned to the miniport
         mp data 
         ------------ <- ptr to header 
         header
end      ------------

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_HalAllocateCommonBuffer)
#endif

// non paged functions


PUSBPORT_COMMON_BUFFER
USBPORT_HalAllocateCommonBuffer(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG NumberOfBytes
    )

/*++

Routine Description:

    Allocates common buffer directly from the hal. 
    The common buffer is passed to the miniport, we
    always allocate a multiple of PAGE_SIZE so the 
    always starts on a page_boundry. This ensures 
    proper alignement of the TDs used by the miniport
    

Arguments:

    DeviceObject - DeviceObject of the controller to stop

Return Value:

    returns Virtual Address of common buffer or NULL if 
    unsuccessful.

--*/

{
    PDEVICE_EXTENSION devExt;
    PUSBPORT_COMMON_BUFFER header;
    PUCHAR virtualAddress, mpBuffer, baseVa;
    PHYSICAL_ADDRESS logicalAddress;
    ULONG headerLength;
    ULONG n, basePhys, mpBufferPhys, pageCount, extra;

    PAGED_CODE();

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'acm>', 0, 0, NumberOfBytes);
   
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // NULL initialize the return value in case the allocation fails
    //
    header = NULL;

    headerLength = sizeof(USBPORT_COMMON_BUFFER);

    // compute number min of pages we will need to satisfy 
    // the request
    
    n = NumberOfBytes+headerLength;
    pageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(0, n);
    
#if DBG   
    {
    ULONG pc;
    // compute number of pages we will need
    pc = n / PAGE_SIZE;
    if ((n % PAGE_SIZE)) {
        pc++;
    }
    USBPORT_ASSERT(pc == pageCount);
    }
#endif    
    
    extra = (pageCount*PAGE_SIZE)-n;
    n = (pageCount*PAGE_SIZE);
    
    USBPORT_KdPrint((1,"'ALLOC(%d) extra %d bytes\n", n, extra));

    virtualAddress = 
        HalAllocateCommonBuffer(devExt->Fdo.AdapterObject,
                                n, 
                                &logicalAddress,
                                TRUE);
#if DBG
    if (virtualAddress == NULL) {
        USBPORT_KdPrint((0,"'HalAllocateCommonBuffer failed\n"));  
        USBPORT_KdPrint((0,"'alloced bytes %d\n"));  
        DEBUG_BREAK();
    }
#endif    

    if (virtualAddress != NULL) {

        devExt->Fdo.StatCommonBufferBytes += n;
        
        basePhys = logicalAddress.LowPart & ~(PAGE_SIZE-1);
        baseVa = PAGE_ALIGN(virtualAddress);
        // hal should have given us a page aligned address since 
        // we asked for a multiple of PAGE_SIZE, 
        // i trust NT but not Win9x
        USBPORT_ASSERT(virtualAddress == baseVa);
        
        // client ptrs
        mpBuffer = baseVa;
        mpBufferPhys = basePhys;

        header = (PUSBPORT_COMMON_BUFFER) (mpBuffer+NumberOfBytes+extra);
        USBPORT_ASSERT(n == NumberOfBytes+extra+headerLength);
        // USB controllers only support 32 bit phys addresses
        // for control structures
        USBPORT_ASSERT(logicalAddress.HighPart == 0);
        
#if DBG
        RtlFillMemory(virtualAddress, n, 'x');
#endif        
        // init the header
        header->Sig = SIG_CMNBUF;
        header->Flags = 0;
        header->TotalLength = n; 
        header->LogicalAddress = logicalAddress;
        header->VirtualAddress = virtualAddress; 
        header->BaseVa = baseVa;
        header->BasePhys = basePhys;
        
        header->MiniportLength = NumberOfBytes+extra;
        header->MiniportVa = mpBuffer;
        header->MiniportPhys = mpBufferPhys;
        // zero the client part
        RtlZeroMemory(header->MiniportVa, header->MiniportLength);

    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'acm<', mpBuffer, mpBufferPhys, header);
   
    return header;
}


VOID
USBPORT_HalFreeCommonBuffer(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_COMMON_BUFFER CommonBuffer
    )

/*++

Routine Description:

    Free a common buffer for the miniport

Arguments:

Return Value:

    returns Virtual Address of common buffer or NULL if 
    unsuccessful.

--*/

{
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);    
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(CommonBuffer != NULL);
    ASSERT_COMMON_BUFFER(CommonBuffer);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'hFCB', 
            CommonBuffer, CommonBuffer->TotalLength, 
            CommonBuffer->MiniportVa);

    devExt->Fdo.StatCommonBufferBytes -= 
        CommonBuffer->TotalLength;
    
    HalFreeCommonBuffer(devExt->Fdo.AdapterObject,
                        CommonBuffer->TotalLength, 
                        CommonBuffer->LogicalAddress,
                        CommonBuffer->MiniportVa,
                        TRUE);
}


PUCHAR
USBPORTSVC_MapHwPhysicalToVirtual(
    HW_32BIT_PHYSICAL_ADDRESS HwPhysicalAddress,
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData    
    )

/*++

Routine Description:

    given a physical address return the corresponding
    virtual address.

Arguments:

    if the phys address is associated with an endpoint 
    the endpoint is passed in.

Return Value:

    Virtual Address, NULL if not found

--*/

{
    PDEVICE_EXTENSION devExt;
    PUCHAR virtualAddress;
    PHCD_ENDPOINT endpoint;
    ULONG offset;
    PDEVICE_OBJECT fdoDeviceObject;

    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);

    fdoDeviceObject = devExt->HcFdoDeviceObject;

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'mapP', HwPhysicalAddress, 0, 
             EndpointData);

    if (EndpointData == NULL) {
        TEST_TRAP();
    } else {
        PUSBPORT_COMMON_BUFFER cb;

        ENDPOINT_FROM_EPDATA(endpoint, EndpointData);
        ASSERT_ENDPOINT(endpoint);

        cb = endpoint->CommonBuffer;
        
        // mask off base physical address
        offset = HwPhysicalAddress - cb->BasePhys; 
        virtualAddress = cb->BaseVa+offset;

        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'mpPV', HwPhysicalAddress, offset, 
                  cb->BaseVa);

        USBPORT_ASSERT(HwPhysicalAddress >= cb->BasePhys && 
            HwPhysicalAddress < cb->BasePhys+cb->MiniportLength);                  

        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'mapV', HwPhysicalAddress, 0, 
                  virtualAddress);

        return virtualAddress;
    }


    // probably a bug in the miniport
    DEBUG_BREAK();
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\core.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    core.c

Abstract:

    core endpoint transfer code for the port driver

    The core of the driver is EndpointWorker.  This function
    checks the given STATE of the endpoint and takes appropriate
    action.  In some cases it moves the endpoint to a new state.

    the endpointer worker functions job is to process transfers 
    on the active list

    NOTE:
    All transfers are queued to the endpoint. The EndpointWorker 
    function is not reentrant for the same endpoint.


    Transfer Queues: 
        transfers are held in one of these queues
    
        PendingTransfers - Transfers that have not been mapped or handed
            to the miniport
            
        ActiveTransfers - Transfers that have been passed to miniport ie
                        on the HW
        
        CanceledTransfers - transfers that need to be completed as canceled                
                        these are previously 'active' transfers that are on 
                        the HW

    We INSERT at the tail and remove from the head

    Endpoint States:
        the endpoints have states, the only functions that should transition
        an endpoint state is the worker

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"


#define CW_SKIP_BUSY_TEST       0x00000001

//#define TIMEIO   

#ifdef ALLOC_PRAGMA
#endif

// non paged functions
// USBPORT_AllocTransfer
// USBPORT_QueueTransferUrb
// USBPORT_QueuePendingUrbToEndpoint
// USBPORT_QueueActiveUrbToEndpoint
// USBPORT_FreeTransfer
// USBPORT_CancelTransfer
// USBPORT_DoneTransfer
// USBPORT_CompleteTransfer
// USBPORT_FlushCancelList
// USBPORT_SetEndpointState
// USBPORT_GetEndpointState
// USBPORT_CoreEndpointWorker
// USBPORT_FlushMapTransferList
// USBPORT_FlushPendingList
// USBPORT_MapTransfer
// USBPORTSVC_InavlidateEndpoint
// USBPORT_PollEndpoint
// USBPORT_FlushDoneTransferList
// USBPORT_QueueDoneTransfer
// USBPORT_SignalWorker
// USBPORT_Worker
// USBPORT_FindUrbInList
// USBPORT_AbortEndpoint
// USBPORT_FlushAbortList


BOOLEAN
USBPORT_CoreEndpointWorker(
    PHCD_ENDPOINT Endpoint,
    ULONG Flags
    )
/*++

Routine Description:

    Core Worker .  The endpointer worker function is not
    re-entrant for the same endpoint.  This function checks 
    the endpoint busy flag and if busy defers processing 
    until a later time.

    In theory this function should only be called if we KNOW
    the endpoint has work.

    This is where the state change requests occur, in processing 
    an endpoint we determine if a new state is needed and request 
    the change.  The one exception in the CloseEndpoint routine
    which also requests a state change and synchronizes with
    this function via the BUSY flag.

    This is the ONLY place we should initiate state changes from.

    THIS ROUTINE RUNS AT DISPATCH LEVEL

Arguments:

Return Value:

    None.

--*/
{
    LONG busy;
    MP_ENDPOINT_STATE currentState;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;
    BOOLEAN isBusy = FALSE;

    USBPORT_ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    ASSERT_ENDPOINT(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'corW', 0, Endpoint, 0);

    // we check the busy flag separately so that we don't 
    // end up waiting on any spinlocks, if the endpoint is
    // 'busy' we want to exit this routine and move to 
    // another endpoint.
    // The BUSY flag is initialized to -1 if incremeted to
    // a non-zero value we bypass this endpoint
    if (TEST_FLAG(Flags, CW_SKIP_BUSY_TEST)) {
        busy = 0;
    } else {
        busy = InterlockedIncrement(&Endpoint->Busy);
    }        
    
    if (busy) {
    
        InterlockedDecrement(&Endpoint->Busy);
        // defer processing
        LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'BUSY', 0, Endpoint, 0);

        isBusy = TRUE;
        
    } else { 
    
        LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'prEP', 0, Endpoint, 0);

        // not busy
        ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le20');

        if (USBPORT_GetEndpointState(Endpoint) == ENDPOINT_CLOSED) {

            // nothing to do if closed, we even skip the poll
            LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'CLOS', 0, Endpoint, 0);

            RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue23');

            InterlockedDecrement(&Endpoint->Busy);
            return isBusy;              
        }

        // poll the endpoint first to flush
        // out any done transfers
        USBPORT_PollEndpoint(Endpoint);

        // put the endpoint on the closed list 
        // if it is the REMOVED state
        currentState = USBPORT_GetEndpointState(Endpoint);
        LOGENTRY(Endpoint, 
                fdoDeviceObject, LOG_XFERS, 'eps1', 0, currentState, 0);

        if (currentState == ENDPOINT_REMOVE) {

            LOGENTRY(Endpoint, 
                fdoDeviceObject, LOG_XFERS, 'rmEP', 0, Endpoint, 0);

            // set the state to 'CLOSED' so we don't put it on the 
            // the closed list again.
            ACQUIRE_STATECHG_LOCK(fdoDeviceObject, Endpoint);                
            Endpoint->CurrentState = Endpoint->NewState = ENDPOINT_CLOSED;
            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint);   
            
            RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue22');

            KeAcquireSpinLockAtDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

            LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'CLO+', 0, Endpoint, 0);

            // it is OK to be on the attention list and the closed 
            // list

            USBPORT_ASSERT(Endpoint->ClosedLink.Flink == NULL);
            USBPORT_ASSERT(Endpoint->ClosedLink.Blink == NULL);

            ExInterlockedInsertTailList(&devExt->Fdo.EpClosedList, 
                                        &Endpoint->ClosedLink,
                                        &devExt->Fdo.EpClosedListSpin.sl);  
                                    
            KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.EndpointListSpin.sl);
            InterlockedDecrement(&Endpoint->Busy);
            return isBusy;                                        
        }
            
        // see if we really have work
        if (IsListEmpty(&Endpoint->PendingList) &&
            IsListEmpty(&Endpoint->CancelList) && 
            IsListEmpty(&Endpoint->ActiveList)) {

            // no real work to do
            LOGENTRY(Endpoint, 
                fdoDeviceObject, LOG_XFERS, 'noWK', 0, Endpoint, 0);
        
            RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue20');

            InterlockedDecrement(&Endpoint->Busy);

            // we may still have some aborts around if the client 
            // sent them with no transfers flush them now.
            USBPORT_FlushAbortList(Endpoint);

            // no locks held flush done transfers
            return isBusy;
        }   

        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue21');

        // no locks held flush done transfers
        //USBPORT_FlushDoneTransferList(fdoDeviceObject, FALSE);

        currentState = USBPORT_GetEndpointState(Endpoint);
        LOGENTRY(Endpoint, 
                fdoDeviceObject, LOG_XFERS, 'eps2', 0, currentState, 0);

        ACQUIRE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
        if (currentState != Endpoint->NewState) {
            // we are in state transition defer processing 
            // until we reach the desired state. 
            LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'stCH', 
                currentState, Endpoint, Endpoint->NewState);
            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint);                 
            InterlockedDecrement(&Endpoint->Busy);
            return TRUE;
        }
        RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 

        // call the specific worker function
        Endpoint->EpWorkerFunction(Endpoint);

        // worker may wave completed abort requests so we flush
        // the abort list here.
        USBPORT_FlushAbortList(Endpoint);

        InterlockedDecrement(&Endpoint->Busy);        
    }

    return isBusy;
}


#if DBG
BOOLEAN
USBPORT_FindUrbInList(
    PTRANSFER_URB Urb,
    PLIST_ENTRY ListHead
    )
/*++

Routine Description:

Arguments:

Return Value:

    TRUE if found

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    BOOLEAN found = FALSE;
    PLIST_ENTRY listEntry;

    listEntry = ListHead;
    
    if (!IsListEmpty(listEntry)) {
        listEntry = ListHead->Flink;
    }

    while (listEntry != ListHead) {

        PHCD_TRANSFER_CONTEXT transfer;
            
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);

                                    
        listEntry = transfer->TransferLink.Flink;

        if (transfer->Urb == Urb) {
            found = TRUE;
            break;
        }
    }                        

    return found;
}
#endif

PHCD_TRANSFER_CONTEXT
USBPORT_UnlinkTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_URB Urb
    )
/*++

Routine Description:

    disassociates a transfer structure from a URB

Arguments:

Return Value:

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;

    USBPORT_ASSERT(TEST_FLAG(Urb->Hdr.UsbdFlags, USBPORT_TRANSFER_ALLOCATED))

    transfer = Urb->pd.HcdTransferContext;
    Urb->pd.HcdTransferContext = USB_BAD_PTR;
    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'ULtr', transfer, 0, 0);

    return transfer;
}  


USBD_STATUS
USBPORT_AllocTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_URB Urb,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PIRP Irp,
    PKEVENT CompleteEvent,
    ULONG MillisecTimeout
    )
/*++

Routine Description:

    Allocate and initialize a transfer context.

Arguments:

    FdoDeviceObject - pointer to a device object

    Urb - a transfer request

    Irp - pointer to an I/O Request Packet
     (optional)

    CompleteEvent - event to signal on completion
     (optional)

    MillisecondTimeout - 0 indicates no timeout     

Return Value:

    USBD status code

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_EXTENSION devExt;
    USBD_STATUS usbdStatus;
    PUSBD_PIPE_HANDLE_I pipeHandle;
    ULONG sgCount;
    PUCHAR currentVa;
    ULONG privateLength, sgListSize, isoListSize;
    ULONG i;
    
    // allocate a transfer context and initialize it

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(Urb != NULL);
    
    pipeHandle = Urb->UsbdPipeHandle;
    ASSERT_PIPE_HANDLE(pipeHandle);

    USBPORT_ASSERT(!TEST_FLAG(Urb->Hdr.UsbdFlags, USBPORT_TRANSFER_ALLOCATED))

    // see how much space we will need for the sg list
    if (Urb->TransferBufferLength) {
        currentVa = 
            MmGetMdlVirtualAddress(Urb->TransferBufferMDL);
        sgCount = USBPORT_ADDRESS_AND_SIZE_TO_SPAN_PAGES_4K(currentVa, Urb->TransferBufferLength);
    } else {
        // zero length transfer
        currentVa = NULL;
        sgCount = 0;
    }

    // sizeof <transfer> + <sgList>
    sgListSize = sizeof(HCD_TRANSFER_CONTEXT) +
                 sizeof(TRANSFER_SG_ENTRY32)*sgCount;
    
    // if this is an iso transfer we need to alloc the 
    // packet structure as well
    if (Urb->Hdr.Function == URB_FUNCTION_ISOCH_TRANSFER) {
        isoListSize = 
            sizeof(MINIPORT_ISO_TRANSFER) +
            sizeof(MINIPORT_ISO_PACKET)*Urb->u.Isoch.NumberOfPackets;
    } else {
        isoListSize = 0;
    }

    privateLength = sgListSize + isoListSize;
                    
    LOGENTRY(pipeHandle->Endpoint,
        FdoDeviceObject, LOG_XFERS, 'TRcs', 
        REGISTRATION_PACKET(devExt).TransferContextSize,
        privateLength, 
        sgCount);
        
    ALLOC_POOL_Z(transfer, 
                 NonPagedPool, 
                 privateLength +                
                 REGISTRATION_PACKET(devExt).TransferContextSize);

    if (transfer != NULL) {
        PUCHAR pch;
        
        LOGENTRY(pipeHandle->Endpoint,
            FdoDeviceObject, LOG_XFERS, 'alTR', transfer, Urb, Irp);

        // init the transfer context
        transfer->Sig = SIG_TRANSFER;
        transfer->Flags = 0;
        transfer->MillisecTimeout = MillisecTimeout;
        transfer->Irp = Irp;
        transfer->Urb = Urb;        
        transfer->CompleteEvent = CompleteEvent;
        //point to the master transfer for a set
        transfer->Transfer = transfer; 
        ASSERT_ENDPOINT(pipeHandle->Endpoint);
        transfer->Endpoint = pipeHandle->Endpoint;
        transfer->MiniportContext = (PUCHAR) transfer;
        transfer->MiniportContext += privateLength;
        transfer->PrivateLength = privateLength;
        KeInitializeSpinLock(&transfer->Spin);
        InitializeListHead(&transfer->DoubleBufferList);
        
        if (isoListSize) {
            pch = (PUCHAR) transfer;
            pch += sgListSize;
            transfer->IsoTransfer = (PMINIPORT_ISO_TRANSFER) pch;
        } else {
            transfer->IsoTransfer = NULL;
        }

        transfer->TotalLength = privateLength +                
             REGISTRATION_PACKET(devExt).TransferContextSize;

        transfer->SgList.SgCount = 0;

        // we don't know the direction yet
        transfer->Direction = NotSet;

        if (DeviceHandle == NULL) {
            // no oca data available for internal function
            transfer->DeviceVID = 0xFFFF;
            transfer->DevicePID = 0xFFFF;
            for (i=0; i<USB_DRIVER_NAME_LEN; i++) {
                transfer->DriverName[i] = '?'; 
            }            
        } else {
            // no oca data available for internal function
            transfer->DeviceVID = DeviceHandle->DeviceDescriptor.idVendor;
            transfer->DevicePID = DeviceHandle->DeviceDescriptor.idProduct;
            for (i=0; i<USB_DRIVER_NAME_LEN; i++) {
                transfer->DriverName[i] = DeviceHandle->DriverName[i]; 
            }  
        }
        
        if (isoListSize) {
            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_ISO);
        }            

        SET_FLAG(Urb->Hdr.UsbdFlags,  USBPORT_TRANSFER_ALLOCATED);
        usbdStatus = USBD_STATUS_SUCCESS;                    
    } else {
        usbdStatus = USBD_STATUS_INSUFFICIENT_RESOURCES;
    }

    Urb->pd.HcdTransferContext = transfer;
    Urb->pd.UrbSig = URB_SIG;

    return usbdStatus;                            
}


VOID
USBPORT_QueueTransferUrb(
    PTRANSFER_URB Urb
    )
/*++

Routine Description:

    Queues a transfer, either internal (no irp) or external
    irp

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_OBJECT fdoDeviceObject;
    PHCD_ENDPOINT endpoint;
    PDEVICE_EXTENSION devExt;
    MP_ENDPOINT_STATUS epStatus;
    PUSBD_DEVICE_HANDLE deviceHandle;

    // on entry the urb is not cancelable ie
    // no cancel routine
    transfer = Urb->pd.HcdTransferContext;
    ASSERT_TRANSFER(transfer);

    if (TEST_FLAG(Urb->TransferFlags, USBD_DEFAULT_PIPE_TRANSFER)) {
        // to maintain backward compatibility munge the urb function
        // code for control transfers that use the default pipe, just like 
        // usbd did.
        Urb->Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;
    }        
    
    endpoint = transfer->Endpoint;
    ASSERT_ENDPOINT(endpoint);

    InterlockedIncrement(&endpoint->EndpointRef);

    fdoDeviceObject = endpoint->FdoDeviceObject;
    LOGENTRY(endpoint,
        fdoDeviceObject, LOG_XFERS, 'quTR', transfer, endpoint, Urb);

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ACQUIRE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'LeN0');
    CLEAR_FLAG(endpoint->Flags, EPFLAG_VIRGIN);
    // update the status of the endpoint before releasing the lock
    epStatus = USBPORT_GetEndpointStatus(endpoint);
    RELEASE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'UeN0');   

    // copy the transfer parameters from the URB 
    // to our structure
    transfer->Tp.TransferBufferLength = 
        Urb->TransferBufferLength;
    transfer->Tp.TransferFlags = 
        Urb->TransferFlags;            
    transfer->TransferBufferMdl = 
        Urb->TransferBufferMDL;
    transfer->Tp.MiniportFlags = 0;
    
    if (endpoint->Parameters.TransferType == Control) {         
        RtlCopyMemory(&transfer->Tp.SetupPacket[0],
                      &Urb->u.SetupPacket[0],
                      8);
    }   

    // we should know the direction by now
    if (Urb->TransferFlags & USBD_TRANSFER_DIRECTION_IN) {
        transfer->Direction = ReadData;
    } else {
        transfer->Direction = WriteData;
    }
    
    // assign a sequence number
    transfer->Tp.SequenceNumber = 
        InterlockedIncrement(&devExt->Fdo.NextTransferSequenceNumber);

    // set URB bytes transferred to zero bytes transferred
    // when this urb completes this value should contain 
    // actual bytes transferred -- this will ensure we return
    // zero in the event of a cancel
    Urb->TransferBufferLength = 0;

    // Historical Note:
    // The UHCD driver failed requests to endpoints that were halted
    // we need to preserve this behavior because transfer queued to a 
    // halted endpoint will not complete unless the endpoint is resumed
    // or canceled. Some clients (HIDUSB) rely on this behavior when 
    // canceling requests as part of an unplug event.
// bugbug the miniports need to be fixed to correctly refilect the 
// ep status (USBUHCI)
//    if (epStatus == ENDPOINT_STATUS_HALT) {
//        TEST_TRAP();
//    }

    GET_DEVICE_HANDLE(deviceHandle, Urb);
    ASSERT_DEVICE_HANDLE(deviceHandle);
    
    if (transfer->Irp) {
        // client request attached to irp, this 
        // function will queue the urb to the 
        // endpoint after dealing with cancel stuff.
        USBPORT_QueuePendingTransferIrp(transfer->Irp);
        
    } else {
        // internal, no irp just queue it directly
        USBPORT_QueuePendingUrbToEndpoint(endpoint,
                                          Urb);
    }

    // the transfer is queued to the ep so we no longer 
    // need a ref for it on the device handle
    InterlockedDecrement(&deviceHandle->PendingUrbs);        


    // we have queued one new transfer, attempt to 
    // flush more to the hardware
    USBPORT_FlushPendingList(endpoint, -1);

    // allow endpoint to be deleted
    InterlockedDecrement(&endpoint->EndpointRef);
}


VOID
USBPORT_QueuePendingUrbToEndpoint(
    PHCD_ENDPOINT Endpoint,
    PTRANSFER_URB Urb
    )
/*++

Routine Description:

    Puts a transfer on the endpoint 'pending' queue 

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PIRP irp;
    PDEVICE_OBJECT fdoDeviceObject;

    // on entry the urb is not cancelable ie
    // no cancel routine

    transfer = Urb->pd.HcdTransferContext;
    ASSERT_TRANSFER(transfer);
    ASSERT_ENDPOINT(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'p2EP', transfer, Endpoint, 0);
            
    // take the endpoint spinlock
    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le30');
    
    // put the irp on the PENDING list
    InsertTailList(&Endpoint->PendingList, &transfer->TransferLink);
    Urb->Hdr.Status = USBD_STATUS_PENDING;
    
    // release the endpoint lists
    RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue30');
}


BOOLEAN
USBPORT_QueueActiveUrbToEndpoint(
    PHCD_ENDPOINT Endpoint,
    PTRANSFER_URB Urb
    )
/*++

Routine Description:

    Either puts the urb on the map list or the ATIVE list 
    for an endpoint

    ACTIVE irp lock is held

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    BOOLEAN mapped = FALSE;
    PDEVICE_OBJECT fdoDeviceObject;
    PHCD_TRANSFER_CONTEXT transfer;    

    transfer = Urb->pd.HcdTransferContext;
    ASSERT_TRANSFER(transfer);        
    ASSERT_ENDPOINT(Endpoint);
    
    fdoDeviceObject = Endpoint->FdoDeviceObject;        
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    LOGENTRY(Endpoint, 
        fdoDeviceObject, LOG_XFERS, 'a2EP', transfer, Endpoint, 0);    
    
    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le40');

    if (TEST_FLAG(Endpoint->Flags, EPFLAG_NUKED)) {
    
        // special case check of the endpoint state.  If the 
        // endpoint is 'nuked' then it does not exist on the 
        // HW we can therefore complete the request with 
        // device_no_longer_exists immediatly.  This will occur
        // if the device is removed while the controller is 
        // 'off'.

        InsertTailList(&Endpoint->CancelList, &transfer->TransferLink);                    
        
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue42');

    } else if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED)) {
                
        InsertTailList(&Endpoint->CancelList, &transfer->TransferLink);                    
        
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue42');
        
    } else if (transfer->Tp.TransferBufferLength != 0 && 
              (Endpoint->Flags & EPFLAG_MAP_XFERS)) {
        KIRQL mapirql;

        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue40');

        USBPORT_AcquireSpinLock(fdoDeviceObject,
                                &devExt->Fdo.MapTransferSpin, 
                                &mapirql);
        
        InsertTailList(&devExt->Fdo.MapTransferList, 
                       &transfer->TransferLink);

        // this prevents the devhandle from being freed while 
        // a transfer is on the mapped list
        // 328555
        REF_DEVICE(transfer->Urb);
                       
        USBPORT_ReleaseSpinLock(fdoDeviceObject,
                                &devExt->Fdo.MapTransferSpin, 
                                mapirql);                               
                                 
        mapped = TRUE;
    } else {
        // don't need to map zero length transfers
        // or endpoints that don't need mapping
        LOGENTRY(Endpoint, 
            fdoDeviceObject, LOG_XFERS, 'a2EL', transfer, Endpoint, 0);


        if (TEST_FLAG(Endpoint->Flags, EPFLAG_VBUS) &&
            transfer->Tp.TransferBufferLength != 0) {
            // prep the transfer for vbus
            TEST_TRAP();
            transfer->SgList.MdlVirtualAddress = 
                MmGetMdlVirtualAddress(transfer->TransferBufferMdl);            
        }
        InsertTailList(&Endpoint->ActiveList, 
                       &transfer->TransferLink);

        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue41');                                
    }

    return mapped;
}


VOID
USBPORT_TransferFlushDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.

    This DPC is queued whenever a transfer is completed by 
    the miniport it flushes a queue of completed transfers

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies FdoDeviceObject.

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject = DeferredContext;
    PDEVICE_EXTENSION devExt;
    ULONG cf;
    
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    MP_Get32BitFrameNumber(devExt, cf);          
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 
        'trf+', cf, 0, 0); 
     
    USBPORT_FlushDoneTransferList(fdoDeviceObject);

    MP_Get32BitFrameNumber(devExt, cf);              
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 
        'trf-', cf, 0, 0); 

}


VOID
USBPORT_QueueDoneTransfer(
    PHCD_TRANSFER_CONTEXT Transfer,
    USBD_STATUS CompleteCode
    )    
/*++

Routine Description:

    Called when a transfer is completed by hardware
    this function only completes active transfers
    ie transfers on the ACTIVE list

    Note that this function must be called while the 
    endpoint lock is held.

Arguments:

Return Value:

--*/
{
    PHCD_ENDPOINT endpoint;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    endpoint = Transfer->Endpoint;    
    
    ASSERT_ENDPOINT(endpoint);
    fdoDeviceObject = endpoint->FdoDeviceObject;

    ASSERT_ENDPOINT_LOCKED(endpoint);
    
    // the transfer should be in the ACTIVE list
    RemoveEntryList(&Transfer->TransferLink); 


    // error set when transfer is completed to client
    //SET_USBD_ERROR(Transfer->Urb, CompleteCode);
    Transfer->UsbdStatus = CompleteCode;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    LOGENTRY(endpoint, 
        fdoDeviceObject, LOG_XFERS, 'QDnT', 0, endpoint, Transfer);
    
    ExInterlockedInsertTailList(&devExt->Fdo.DoneTransferList, 
                                &Transfer->TransferLink,
                                &devExt->Fdo.DoneTransferSpin.sl);          

    // queue a DPC to flush the list
    KeInsertQueueDpc(&devExt->Fdo.TransferFlushDpc,
                     0,
                     0);
}    


VOID
USBPORT_DoneTransfer(
    PHCD_TRANSFER_CONTEXT Transfer
    )    
/*++

Routine Description:

    Called when a transfer is completed by hardware
    this function only completes active transfers

Arguments:

Return Value:

--*/
{
    PTRANSFER_URB urb;
    PHCD_ENDPOINT endpoint;
    KIRQL irql, cancelIrql;
    PIRP irp;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_TRANSFER(Transfer);
    urb = Transfer->Urb;
    ASSERT_TRANSFER_URB(urb);

    USBPORT_ASSERT(Transfer == 
                   urb->pd.HcdTransferContext);
                   
    endpoint = Transfer->Endpoint;    
    ASSERT_ENDPOINT(endpoint);
    fdoDeviceObject = endpoint->FdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    LOGENTRY(endpoint,
        fdoDeviceObject, 
        LOG_XFERS, 
        'DonT', 
        urb, 
        endpoint, 
        Transfer);

    ACQUIRE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);     
    // if we get here the request has already been removed
    // from the endpoint lists, we just have to synchronize
    // with the cancel routine before completeing
        
    irp = Transfer->Irp;
    LOGENTRY(endpoint, 
            fdoDeviceObject, 
            LOG_XFERS, 'DIRP', 
            irp, 
            endpoint, 
            Transfer);

    // we had last reference so complete the irp
    // if the cancel routine runs it will stall on
    // the ACTIVE_IRP_LOCK lock
    
    if (irp) {
        KIRQL cancelIrql;
        
        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);
         
        irp = USBPORT_RemoveActiveTransferIrp(fdoDeviceObject, irp);
        // cancel routine may be running but will not find
        // the irp on the list
        USBPORT_ASSERT(irp != NULL);

        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);  
    } else {
        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql); 
    }

    // the irp is exclusively ours now.
    SET_USBD_ERROR(Transfer->Urb, Transfer->UsbdStatus);
    USBPORT_CompleteTransfer(urb,
                             urb->Hdr.Status);

    
}


VOID
USBPORT_CompleteTransfer(
    PTRANSFER_URB Urb,
    USBD_STATUS CompleteCode
    )    
/*++

Routine Description:

    all transfer completions come thru here -- this is where 
    we actually comlete the irp.

    We assume all fields are set in the URB for completion
    except the status.
    
Arguments:

Return Value:

--*/    
{
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;
    PKEVENT event;
    NTSTATUS ntStatus;
    PIRP irp;
    PDEVICE_OBJECT fdoDeviceObject, pdoDeviceObject;
    PDEVICE_EXTENSION devExt;
    KIRQL oldIrql, statIrql;
    ULONG i;
    PUSBD_ISO_PACKET_DESCRIPTOR usbdPak;
    ULONG flushLength;
#ifdef TIMEIO
    ULONG cf1, cf2, cfTot = 0;
#endif 
#ifdef LOG_OCA_DATA
    OCA_DATA ocaData;
#endif 

    ASSERT_TRANSFER_URB(Urb);
    transfer = Urb->pd.HcdTransferContext;

    // make sure we have the correct transfer
    USBPORT_ASSERT(transfer->Urb == Urb);
    
    endpoint = transfer->Endpoint;    
    ASSERT_ENDPOINT(endpoint);
    
    irp = transfer->Irp;
    event = transfer->CompleteEvent;
    fdoDeviceObject = endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(endpoint, 
             fdoDeviceObject, 
             LOG_IRPS, 
             'cptU', 
             Urb,
             CompleteCode, 
             transfer);    

    pdoDeviceObject = devExt->Fdo.RootHubPdo;

    Urb->TransferBufferLength = transfer->MiniportBytesTransferred;
    transfer->UsbdStatus = CompleteCode;
    ntStatus =                                   
         SET_USBD_ERROR(Urb, CompleteCode);  

    // bytes transferred is set in the URB based on bytes received
    // or sent, update our counters before completion
    KeAcquireSpinLock(&devExt->Fdo.StatCounterSpin.sl, &statIrql);
    switch(endpoint->Parameters.TransferType) {
    case Bulk:
        devExt->Fdo.StatBulkDataBytes += Urb->TransferBufferLength;
        flushLength = Urb->TransferBufferLength;
        break;
    case Control:
        devExt->Fdo.StatControlDataBytes += Urb->TransferBufferLength;
        flushLength = Urb->TransferBufferLength;
        break;
    case Isochronous:
        devExt->Fdo.StatIsoDataBytes += Urb->TransferBufferLength;
        flushLength = 0;
        for (i = 0; i < Urb->u.Isoch.NumberOfPackets; i++) {
            usbdPak = &Urb->u.Isoch.IsoPacket[i];
            if (usbdPak->Length != 0) {
                flushLength = usbdPak->Offset + usbdPak->Length;
            }
        }
        break;
    case Interrupt:
        devExt->Fdo.StatInterruptDataBytes += Urb->TransferBufferLength;
        flushLength = Urb->TransferBufferLength;
        break;
    }      
    KeReleaseSpinLock(&devExt->Fdo.StatCounterSpin.sl, statIrql);                                   

    // if we have an irp remove it from our internal lists
    LOGENTRY(endpoint, 
             fdoDeviceObject, 
             LOG_IRPS, 
             'CptX', 
             irp, 
             CompleteCode, 
             ntStatus);

    // free any DMA resources associated with this transfer
    if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_MAPPED)) {
        
        BOOLEAN write = transfer->Direction == WriteData ? TRUE : FALSE; 
        PUCHAR currentVa;
        BOOLEAN flushed;

        USBPORT_ASSERT(transfer->Direction != NotSet); 
        currentVa = 
            MmGetMdlVirtualAddress(Urb->TransferBufferMDL);
            
        // IoFlushAdapterBuffers() should only be called once per call
        // to IoAllocateAdapterChannel()
        //
#ifdef TIMEIO
        MP_Get32BitFrameNumber(devExt, cf1);          
        LOGENTRY(endpoint,
                 fdoDeviceObject, LOG_IRPS, 'iPF1', 
                 0, 
                 cf1,
                 0); 
#endif          
        flushed = IoFlushAdapterBuffers(devExt->Fdo.AdapterObject,
                                         Urb->TransferBufferMDL,
                                         transfer->MapRegisterBase,
                                         currentVa,
                                         flushLength,
                                         write);
        
        USBPORT_FlushAdapterDBs(fdoDeviceObject,
                                transfer);

        LOGENTRY(endpoint, fdoDeviceObject, LOG_XFERS, 'dmaF',
                 transfer->MapRegisterBase, 
                 flushLength, 
                 flushed);
                
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
        //
        // IoFreeMapRegisters() must be called at DISPATCH_LEVEL

        IoFreeMapRegisters(devExt->Fdo.AdapterObject,
                            transfer->MapRegisterBase,
                            transfer->NumberOfMapRegisters);

#ifdef TIMEIO  
        MP_Get32BitFrameNumber(devExt, cf2);          
        LOGENTRY(endpoint,
                 fdoDeviceObject, LOG_IRPS, 'iPF2', 
                 cf1, 
                 cf2,
                 cf2-cf1);
        cfTot+=(cf2-cf1);   

        if (cf2-cf1 > 2) {
            TEST_TRAP();
        }
#endif

         KeLowerIrql(oldIrql);
    }

    if (TEST_FLAG(Urb->Hdr.UsbdFlags, USBPORT_REQUEST_MDL_ALLOCATED)) {
        IoFreeMdl(transfer->TransferBufferMdl);
    }
    
#if DBG 
        
    USBPORT_DebugTransfer_LogEntry(
                fdoDeviceObject,
                endpoint,
                transfer,
                Urb,
                irp,
                ntStatus);

#endif

    // free the context before we loose the irp
    USBPORT_UnlinkTransfer(fdoDeviceObject, Urb);
    
    if (irp) {

        // deref the PDO device object since thisis what the
        // 'irp' was passed to
        DECREMENT_PENDING_REQUEST_COUNT(pdoDeviceObject, irp);

        irp->IoStatus.Status      = ntStatus;
        irp->IoStatus.Information = 0;

        LOGENTRY(endpoint, 
                 fdoDeviceObject, 
                 LOG_IRPS, 
                 'irpC', 
                 irp,
                 ntStatus,
                 Urb);
#if DBG        
        {
        LARGE_INTEGER t;            
        KeQuerySystemTime(&t);        
        LOGENTRY(endpoint, fdoDeviceObject, LOG_XFERS, 'tIPC', 0, 
                t.LowPart, 0);
        }                
#endif    

        // put some information on the stack about this driver in the event 
        // we crash attempting to complete their IRP
        USBPORT_RecordOcaData(fdoDeviceObject, &ocaData, transfer, irp);

        //LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'irql', 0, 0,  KeGetCurrentIrql());
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

/* use to test OCA data logging */
//#if 0
//{
//static int crash = 0;
//crash++;
//if (crash > 1000) {
//RtlZeroMemory(irp, sizeof(irp));          
//}
//}
//#endif
          
        IoCompleteRequest(irp, 
                          IO_NO_INCREMENT);                       

        KeLowerIrql(oldIrql);
        
        //LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'irql', 0, 0,  KeGetCurrentIrql());
                              
    }        

    // if we have an event associated with this transfer 
    // signal it
    
    if (event) {
        LOGENTRY(endpoint, fdoDeviceObject, LOG_XFERS, 'sgEV', event, 0, 0);

        KeSetEvent(event,
                   1,
                   FALSE);

    }

    // free the transfer now that we are done with it
    LOGENTRY(endpoint, 
        fdoDeviceObject, LOG_XFERS, 'freT', transfer, transfer->MiniportBytesTransferred, 0);
    UNSIG(transfer);        
    FREE_POOL(fdoDeviceObject, transfer);
    
}


IO_ALLOCATION_ACTION
USBPORT_MapTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PVOID MapRegisterBase,
    PVOID Context 
    )
/*++

Routine Description:

    Begin a DMA transfer -- this is the adapter control routine called
    from IoAllocateAdapterChannel.

    loop calling iomap transfer and build up an sg list
    to pass to the miniport.

Arguments:

Return Value:

    see IoAllocateAdapterChannel

--*/
{
    PHCD_ENDPOINT endpoint; 
    PHCD_TRANSFER_CONTEXT transfer = Context;
    PTRANSFER_URB urb;
    PTRANSFER_SG_LIST sgList;
    PDEVICE_EXTENSION devExt;
    PUCHAR currentVa;
    ULONG length, lengthMapped;
    PHYSICAL_ADDRESS logicalAddress, baseLogicalAddress;
    PHYSICAL_ADDRESS logicalSave;
    LIST_ENTRY splitTransferList;
#ifdef TIMEIO
    ULONG cf1, cf2, cfTot = 0;
#endif 
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_TRANSFER(transfer);
    endpoint = transfer->Endpoint;
    ASSERT_ENDPOINT(endpoint);
    
    // allow more dma operations now
    InterlockedDecrement(&devExt->Fdo.DmaBusy);     
    LOGENTRY(endpoint, FdoDeviceObject, 
        LOG_XFERS, 'DMA-', devExt->Fdo.DmaBusy, 0, 0);
        
    transfer->MapRegisterBase = MapRegisterBase;
    
    urb = transfer->Urb;
    ASSERT_TRANSFER_URB(urb);
    
    currentVa = 
        MmGetMdlVirtualAddress(urb->TransferBufferMDL);

    length = transfer->Tp.TransferBufferLength;

    USBPORT_ASSERT(!(transfer->Flags & USBPORT_TXFLAG_MAPPED));

    sgList = &transfer->SgList;
    sgList->SgCount = 0;
    sgList->MdlVirtualAddress = currentVa;

    // attempt to map a system address for the MDL in case 
    // the miniport needs to double buffer
    urb->TransferBufferMDL->MdlFlags |= MDL_MAPPING_CAN_FAIL;
    sgList->MdlSystemAddress = 
        MmGetSystemAddressForMdl(urb->TransferBufferMDL);
    if (sgList->MdlSystemAddress == NULL) {
        TEST_TRAP();
        // bugbug map failure we will need to fail this transfer
        LOGENTRY(endpoint,
            FdoDeviceObject, LOG_XFERS, 'MPSf', 0, 0, 0);             
    }
    urb->TransferBufferMDL->MdlFlags &= ~MDL_MAPPING_CAN_FAIL;
    
    LOGENTRY(endpoint, 
        FdoDeviceObject, LOG_XFERS, 'MAPt', 
        sgList, transfer, transfer->Tp.TransferBufferLength);   
    lengthMapped = 0;
    
    //
    // keep calling IoMapTransfer until we get Logical Addresses 
    // for the entire client buffer
    //
    
    logicalSave.QuadPart = 0;
    sgList->SgFlags = 0;
    
    do {    
        BOOLEAN write = transfer->Direction == WriteData ? TRUE : FALSE; 
        ULONG used, lengthThisPage, offsetMask;

        USBPORT_ASSERT(transfer->Direction != NotSet); 
        sgList->SgEntry[sgList->SgCount].StartOffset =
            lengthMapped;
        
        // first map the transfer buffer

        // note that iomaptransfer maps the buffer into sections
        // represented by physically contiguous pages 
        // also the page size is platfor specific ie different on 
        // 64bit platforms
        //
        // the miniport sg list is broken in to into discrete 
        // 4k USB 'pages'.
        
        // The reason for this is the somewhat complicated scheme
        // ohci uses to support scatter gather. Breaking the transfer 
        // up in this way makes the TD transfer mapping code 
        // considerably simpler in the OHCI miniport and reduces 
        // the risks due to controller HW problems.

        LOGENTRY(endpoint,
            FdoDeviceObject, LOG_XFERS, 'IOMt', length, currentVa, 0);

#ifdef TIMEIO
        MP_Get32BitFrameNumber(devExt, cf1);          
        LOGENTRY(endpoint,
                 FdoDeviceObject, LOG_XFERS, 'iPF1', 
                 0, 
                 cf1,
                 0); 
#endif 
        logicalAddress =         
            IoMapTransfer(devExt->Fdo.AdapterObject,
                          urb->TransferBufferMDL,
                          MapRegisterBase,
                          currentVa,
                          &length,
                          write); 

#ifdef TIMEIO  
        MP_Get32BitFrameNumber(devExt, cf2);          
        LOGENTRY(endpoint,
                 FdoDeviceObject, LOG_XFERS, 'iPF2', 
                 cf1, 
                 cf2,
                 cf2-cf1);
        cfTot+=(cf2-cf1);  

        if (cf2-cf1 > 2) {
            TEST_TRAP();
        }
#endif
        // remember what we got from IoMapTransfer                           
        baseLogicalAddress = logicalAddress;
        used = length;

        offsetMask = 0x00000FFF;

        LOGENTRY(endpoint, 
            FdoDeviceObject, LOG_XFERS, 'MPbr', length, logicalAddress.LowPart, 
                    logicalAddress.HighPart);
        
        do {
        // compute the distance to the next page
            lengthThisPage = 
                USB_PAGE_SIZE - (logicalAddress.LowPart & offsetMask);

            LOGENTRY(endpoint, FdoDeviceObject, LOG_XFERS, 'MPsg', 
                sgList->SgCount, used, lengthThisPage);   
             
            // if we don't go to the end just use the length from
            // iomaptransfer
            if (lengthThisPage > used) {
                lengthThisPage = used;
            }
            
            sgList->SgEntry[sgList->SgCount].LogicalAddress.Hw64 = 
                logicalAddress;
            
            sgList->SgEntry[sgList->SgCount].Length = 
                lengthThisPage;

            LOGENTRY(endpoint, FdoDeviceObject, LOG_XFERS, 'MAPe', 
                sgList->SgCount, lengthThisPage, logicalAddress.LowPart);   

            logicalAddress.LowPart += lengthThisPage;

            sgList->SgEntry[sgList->SgCount].StartOffset =
                lengthMapped + length - used;
                
            used -= lengthThisPage;                    
                
            sgList->SgCount++;                                    

        } while (used);

        // check for special case where the MDL entries
        // all map to the same physical page
        if (logicalSave.QuadPart == baseLogicalAddress.QuadPart) {
            SET_FLAG(sgList->SgFlags, USBMP_SGFLAG_SINGLE_PHYSICAL_PAGE);
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'l=lg', 0, 
                logicalAddress.LowPart, logicalSave.LowPart);
      
        } 
        logicalSave.QuadPart = baseLogicalAddress.QuadPart;
        
        lengthMapped += length;    
        currentVa += length;                                          

        USBPORT_KdPrint((2, "'IoMapTransfer length = 0x%x log address = 0x%x\n", 
            length, logicalAddress.LowPart));

        length = transfer->Tp.TransferBufferLength - lengthMapped;
        
    } while (lengthMapped != transfer->Tp.TransferBufferLength);

#if DBG
    {
    // spew for xfers
    ULONG i;
    USBPORT_KdPrint((2, "'--- xfer length %x\n",
        transfer->Tp.TransferBufferLength));
    for (i=0; i<sgList->SgCount; i++) {
        USBPORT_KdPrint((2, "'SG[%d] length %d offset %d phys %x\n",
         i, 
         sgList->SgEntry[i].Length,
         sgList->SgEntry[i].StartOffset,
         sgList->SgEntry[i].LogicalAddress));
    }
    }
            
    if (TEST_FLAG(sgList->SgFlags, USBMP_SGFLAG_SINGLE_PHYSICAL_PAGE)) {
        USBPORT_KdPrint((2, "'*** All Phys Same\n")); 
//        TEST_TRAP();
    }
    USBPORT_KdPrint((2, "'--- \n"));
    
    currentVa = 
        MmGetMdlVirtualAddress(urb->TransferBufferMDL);

    USBPORT_ASSERT(sgList->SgCount <= 
        USBPORT_ADDRESS_AND_SIZE_TO_SPAN_PAGES_4K(currentVa, transfer->Tp.TransferBufferLength));
#endif

    if (endpoint->Parameters.DeviceSpeed == HighSpeed) {
        SET_FLAG(transfer->Flags, USBPORT_TXFLAG_HIGHSPEED);
    }        

    // if this is an iso transfer we need to set up the iso
    // data structures as well.
    if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_ISO)) {
        USBPORT_InitializeIsoTransfer(FdoDeviceObject,
                                      urb,
                                      transfer);
    }        

    SET_FLAG(transfer->Flags, USBPORT_TXFLAG_MAPPED);

    ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Le60');

    // transfer is mapped, perform the split operation
    // if necessary
    USBPORT_SplitTransfer(FdoDeviceObject,
                          endpoint,
                          transfer,
                          &splitTransferList); 
    

    // transfer is now mapped, put it on the endpoint active 
    // list for calldown to the miniport

    while (!IsListEmpty(&splitTransferList)) {

        PLIST_ENTRY listEntry;
        PHCD_TRANSFER_CONTEXT splitTransfer;
        
        listEntry = RemoveHeadList(&splitTransferList);
            
        splitTransfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);
            
        LOGENTRY(endpoint, FdoDeviceObject, LOG_XFERS, 'MP>A', 
            splitTransfer, endpoint, 0);
    
        InsertTailList(&endpoint->ActiveList, 
                       &splitTransfer->TransferLink);
                       
    }

    // deref the transfer on the device handle now that the transfer is queued
    // to the endpoint
    // 328555
    DEREF_DEVICE(transfer->Urb);

//#if DBG
//    if (!IsListEmpty(&transfer->SplitTransferList)) {
//        TEST_TRAP();
//    }
//#endif
    
    RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Ue60');

    // run the worker for this endpoint to 
    // put the transfer on the hardware

    if (USBPORT_CoreEndpointWorker(endpoint, 0)) {
        // if endpoint is busy we will check it later
//USBPERF - request interrupt instead?       
        USBPORT_InvalidateEndpoint(FdoDeviceObject, 
                                   endpoint, 
                                   IEP_SIGNAL_WORKER);
    }

#ifdef TIMEIO  
    LOGENTRY(endpoint,
             FdoDeviceObject, LOG_XFERS, 'iPF3', 
             cfTot, 
             0,
             0); 
#endif

    LOGENTRY(endpoint, FdoDeviceObject, 
        LOG_XFERS, 'iomX', 0, 0, 0);

    
    return DeallocateObjectKeepRegisters;
}


VOID
USBPORT_FlushPendingList(
    PHCD_ENDPOINT Endpoint,
    ULONG Count
    )
/*++

Routine Description:

    Put as many transfers as we can on the Hardware.

    This function moves transfers from the pending list 
    to the hardware if mapping is necessary they are 
    moved to the mapped list and then flushed to the HW.

Arguments:

    Count is a maximimum number of transfers to flush 
    on this call

Return Value:

    None.

--*/
{
    PLIST_ENTRY listEntry;
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;
    BOOLEAN mapped;
    BOOLEAN busy, irql;

    // we are done when there are no transfers in the 
    // pending list or the miniport becomes full
    BOOLEAN done = FALSE;

    ASSERT_ENDPOINT(Endpoint);
    fdoDeviceObject = Endpoint->FdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

flush_again:

    mapped = FALSE;
    transfer = NULL;

    ACQUIRE_PENDING_IRP_LOCK(devExt, irql);    
    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le70');

    LOGENTRY(Endpoint,
        fdoDeviceObject, LOG_XFERS, 'flPE', 0, Endpoint, 0);

    // the controller should not be off or suspended
    if (TEST_FDO_FLAG(devExt, 
        (USBPORT_FDOFLAG_OFF | USBPORT_FDOFLAG_SUSPENDED))) {
        // the controller should not be off or suspended
        // if we are off or suspended we just leave transfers
        // in the pending state
        done = TRUE;
        
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue70');         
        RELEASE_PENDING_IRP_LOCK(devExt, irql);

        goto USBPORT_FlushPendingList_Done;
    }
    
    // move some transfers to the active list
    // if necessary map them

    // first scan the active list, if any transfers
    // are not called down the skip this step
    busy = FALSE;

    if (!TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {    
        GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

        while (listEntry && 
               listEntry != &Endpoint->ActiveList) {
            
            transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);
                        
            LOGENTRY(Endpoint, 
                fdoDeviceObject, LOG_XFERS, 'cACT', transfer, 0, 0);                    
            ASSERT_TRANSFER(transfer);                    

            // we found a transfer that has not been called 
            // down yet, this means the miniport is full 
            if (!(transfer->Flags & USBPORT_TXFLAG_IN_MINIPORT)) {
                busy = TRUE;
                break;
            }
            listEntry = transfer->TransferLink.Flink;
        }         
    }
    
    if (busy) {
        // busy
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue70');         
        RELEASE_PENDING_IRP_LOCK(devExt, irql);

        done = TRUE;
        // busy
    } else {
        // not busy
        // we push as many transfers as we can to the HW
        GET_HEAD_LIST(Endpoint->PendingList, listEntry);

        if (listEntry) {     

            transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
                    
            ASSERT_TRANSFER(transfer);

            // if cancel routine is not running then this
            // opertion will return a ptr
            //
            // once called the pending cancel routine will not run
            
            if (transfer->Irp &&
                IoSetCancelRoutine(transfer->Irp, NULL) == NULL) {
                // pending Irp cancel routine is running or has run
                transfer = NULL;
                // if we encounter a cenceled irp bail in the unlikely
                // event that the cancel routine has been prempted
                done = TRUE;
            } 

            if (transfer) { 
                // transfer
                // cancel routine is not running and cannot run
            
                PTRANSFER_URB urb;
                PIRP irp;

                irp = transfer->Irp;
                urb = transfer->Urb;
                ASSERT_TRANSFER_URB(urb);

                // remove from the head of the endpoint 
                // pending list 
                
                RemoveEntryList(&transfer->TransferLink);
                transfer->TransferLink.Flink = 
                    transfer->TransferLink.Blink = NULL;
                
                if (irp) {
                    irp = USBPORT_RemovePendingTransferIrp(fdoDeviceObject, irp);
                        
                    USBPORT_ASSERT(irp != NULL);
                }

                
                RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue71');
                RELEASE_PENDING_IRP_LOCK(devExt, irql);
                
                // we now have a new 'ACTIVE' transfer to 
                // deal with.
                // It has been safely removed from the 'PENDING' 
                // state and can no longer be canceled.
        
                // if the transfer is marked aborted it will be 
                // handled by when it is queued to the endpoint
                
                ACQUIRE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);              

                // now if we have an irp insert it in the 
                // ActiveIrpList
                if (irp) {
                    // irp
                    PIRP irp = transfer->Irp;
                    
                    IoSetCancelRoutine(irp, USBPORT_CancelActiveTransferIrp);

                    if (irp->Cancel && 
                        IoSetCancelRoutine(irp, NULL)) {

                        // irp was canceled and our cancel routine
                        // did not run
                        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);                
        
                        USBPORT_CompleteTransfer(urb,
                                                 USBD_STATUS_CANCELED);
                                                                         
                    } else {
                        // put on our 'ACTIVE' list
                        // this function will verify that we don't already 
                        // have it on the list tied to another irp.
                        USBPORT_CHECK_URB_ACTIVE(fdoDeviceObject, urb, irp);
                        
                        USBPORT_InsertActiveTransferIrp(fdoDeviceObject, irp);

                        mapped = USBPORT_QueueActiveUrbToEndpoint(Endpoint,
                                                                  urb);
                        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);                                                                                               
                    }
                    // irp
                } else {
                    // no irp
                    mapped = USBPORT_QueueActiveUrbToEndpoint(Endpoint,
                                                              urb);
                    RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql); 
                    // no irp
                }
                // transfer                
            } else {
                // no transfer, it is being canceled
                RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue72');                                
                RELEASE_PENDING_IRP_LOCK(devExt, irql);
                // no transfer
            }
            // pending entry     
        } else {
            // no pending entries
            RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue73');    
            RELEASE_PENDING_IRP_LOCK(devExt, irql);
            // no pending entries

            done = TRUE;
        }
        // not busy        
    } 

USBPORT_FlushPendingList_Done:

    if (mapped) {
        USBPORT_FlushMapTransferList(fdoDeviceObject);
    } else {
        KIRQL oldIrql;
        BOOLEAN busy;

        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

        busy = USBPORT_CoreEndpointWorker(Endpoint, 0);

        KeLowerIrql(oldIrql);

        if (busy) {
            // if worker is busy we need to check the endpoint later
            // this puts the endpoint on our work queue
            USBPORT_InvalidateEndpoint(fdoDeviceObject, 
                                       Endpoint,
                                       IEP_SIGNAL_WORKER);
        }
    }

    if (!done) {
        LOGENTRY(Endpoint, 
            fdoDeviceObject, LOG_XFERS, 'flAG', 0, Endpoint, 0);
        goto flush_again;
    }

} 


VOID
USBPORT_FlushMapTransferList(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    pull transfers off the map list and try to map
    them

    please do not call this while holding an 
    endpoint spinlock

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql, oldIrql;    
    LONG dmaBusy;
    PDEVICE_EXTENSION devExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PLIST_ENTRY listEntry;
#ifdef TIMEIO  
    ULONG cf1, cf2, cfTot;
#endif

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, 
        LOG_XFERS, 'fMAP',0 ,0 ,0);
    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    
map_another:

    dmaBusy = InterlockedIncrement(&devExt->Fdo.DmaBusy);
    LOGENTRY(NULL, FdoDeviceObject, 
        LOG_XFERS, 'dma+', devExt->Fdo.DmaBusy, 0, 0);

    transfer = NULL;

    if (dmaBusy) {
        // defer processing
        InterlockedDecrement(&devExt->Fdo.DmaBusy);            
        LOGENTRY(NULL, FdoDeviceObject, 
        LOG_XFERS, 'dma-', devExt->Fdo.DmaBusy, 0, 0);
        KeLowerIrql(oldIrql);
        return;
    }

    USBPORT_AcquireSpinLock(FdoDeviceObject, 
                            &devExt->Fdo.MapTransferSpin, 
                            &irql);

    if (IsListEmpty(&devExt->Fdo.MapTransferList)) {
    
        USBPORT_ReleaseSpinLock(FdoDeviceObject, 
                                &devExt->Fdo.MapTransferSpin, 
                                irql);
        InterlockedDecrement(&devExt->Fdo.DmaBusy);
        LOGENTRY(NULL, FdoDeviceObject, 
            LOG_XFERS, 'dm1-', devExt->Fdo.DmaBusy, 0, 0);
    
    } else {
        PTRANSFER_URB urb;
        PVOID currentVa;
        NTSTATUS ntStatus;
         
        listEntry = RemoveHeadList(&devExt->Fdo.MapTransferList);
        
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
                    
        ASSERT_TRANSFER(transfer);
    
        USBPORT_ReleaseSpinLock(FdoDeviceObject, 
                                &devExt->Fdo.MapTransferSpin, 
                                irql);

        urb = transfer->Urb;
        ASSERT_TRANSFER_URB(urb);
        // we have a transfer, try to map it...
        // although it is removed from the list it is still 
        // referenced, the reason is we will put it on the 
        // active list as soon as it is mapped

        // we should not be mapping zero length xfers            
        USBPORT_ASSERT(transfer->Tp.TransferBufferLength != 0);

        // IoMapTransfer need lots of info about the 
        // transfer
        currentVa = 
            MmGetMdlVirtualAddress(
                urb->TransferBufferMDL);

        // save the number of map registers in our work area
        transfer->NumberOfMapRegisters = 
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                currentVa,
                transfer->Tp.TransferBufferLength);                                                            

#ifdef TIMEIO  
        MP_Get32BitFrameNumber(devExt, cf1);          
        LOGENTRY(NULL,
                 FdoDeviceObject, LOG_XFERS, 'iPF3', 
                 cf1, 
                 0,
                 0);
#endif
        USBPORT_ASSERT(transfer->Direction != NotSet); 
        // for PAE systems       
        KeFlushIoBuffers(urb->TransferBufferMDL,
                         transfer->Direction == ReadData ? TRUE : FALSE,
                         TRUE);   
#ifdef TIMEIO  
        MP_Get32BitFrameNumber(devExt, cf2);          
        LOGENTRY(NULL,
                 FdoDeviceObject, LOG_XFERS, 'iPF4', 
                 cf1, 
                 cf2,
                 cf2-cf1);
        cfTot=(cf2-cf1);  

        if (cf2-cf1 >= 2) {
            TEST_TRAP();
        }
#endif

        // first we'll need to map the MDL for this transfer
        LOGENTRY(transfer->Endpoint,
                FdoDeviceObject, LOG_XFERS, 'AChn', transfer, 
                 0, urb);

#ifdef TIMEIO
        MP_Get32BitFrameNumber(devExt, transfer->IoMapStartFrame);
#endif        
        
        ntStatus = 
            IoAllocateAdapterChannel(devExt->Fdo.AdapterObject,
                                     FdoDeviceObject,
                                     transfer->NumberOfMapRegisters,
                                     USBPORT_MapTransfer,
                                     transfer);
        
        if (!NT_SUCCESS(ntStatus)) {
            // complete the transfer with an error

            TEST_TRAP();
        }

        // transfer structure and URB may be gone at this point
        LOGENTRY(NULL,
                FdoDeviceObject, LOG_XFERS, 'mpAN', 0, 0, 0);
        goto map_another;
    }

    KeLowerIrql(oldIrql);

}             


VOID
USBPORT_FlushCancelList(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    complete any transfers on the cancel list.
    
    This functions locks the endpoint, removes 
    canceled transfers and completes them. 

    This routine is the only way a transfer on the 
    cancel list will be completed 
    ie a transfer is only place on the cancel list 
    if it cannot be completed by the miniport or
    another function

    NOTE: irps on the Cancel list are considred 'ACTIVE'
    ie they are on the ACTIVE irp list and have the 
    CancelActiveIrp cancel routine set.
    

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer = NULL;
    PLIST_ENTRY listEntry;
    PIRP irp;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql, cancelIrql;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);
    fdoDeviceObject = Endpoint->FdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ACQUIRE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);     
    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le80');

    LOGENTRY(Endpoint,
            fdoDeviceObject, LOG_XFERS, 'flCA', Endpoint, 0 , 0);

    while (!IsListEmpty(&Endpoint->CancelList)) {
         
        listEntry = RemoveHeadList(&Endpoint->CancelList);
        
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                listEntry,
                struct _HCD_TRANSFER_CONTEXT, 
                TransferLink);
                
        ASSERT_TRANSFER(transfer);

        // complete the transfer, if there is an irp
        // remove it from our active list
        irp = transfer->Irp;
        if (irp) {
            IoAcquireCancelSpinLock(&cancelIrql);
            IoSetCancelRoutine(transfer->Irp, NULL);
            IoReleaseCancelSpinLock(cancelIrql);
            // we should always find it
            irp = USBPORT_RemoveActiveTransferIrp(fdoDeviceObject, irp);
            USBPORT_ASSERT(irp != NULL);
        }
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue80');
        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);     
        
        // no more references to this irp in 
        // our lists, cancel routine cannot find it
        
        LOGENTRY(Endpoint,
            fdoDeviceObject, LOG_XFERS, 'CANt', Endpoint, transfer , 0);

        if (TEST_FLAG(Endpoint->Flags, EPFLAG_NUKED)) {
            USBPORT_CompleteTransfer(transfer->Urb,
                                     USBD_STATUS_DEVICE_GONE);
        } else {
            USBD_STATUS usbdStatus = USBD_STATUS_CANCELED; 
            
            if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_DEVICE_GONE)) {   
                usbdStatus = USBD_STATUS_DEVICE_GONE;
            }
            USBPORT_CompleteTransfer(transfer->Urb,
                                     usbdStatus);
        }
        ACQUIRE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);    
        ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le81');                                         
    }
    
    RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue81');
    RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);     

    // see if the clients have any abort requests hanging around
    USBPORT_FlushAbortList(Endpoint);

}


VOID
USBPORT_FlushDoneTransferList(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    complete any transfers on the done list.
    
    The done list is a list of active tarnsfers
    that need completing

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;
    PDEVICE_EXTENSION devExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PLIST_ENTRY listEntry;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'flDT', 0, 0, 0); 
        
    while (1) {
        transfer = NULL;
        LOGENTRY(NULL,
                 FdoDeviceObject, LOG_XFERS, 'lpDT', transfer, 0, 0); 
            
        USBPORT_AcquireSpinLock(FdoDeviceObject, 
                                &devExt->Fdo.DoneTransferSpin, 
                                &irql);

        if (IsListEmpty(&devExt->Fdo.DoneTransferList)) {
            USBPORT_ReleaseSpinLock(FdoDeviceObject, 
                                    &devExt->Fdo.DoneTransferSpin, 
                                    irql);
            break;
        } else {
             
            listEntry = RemoveHeadList(&devExt->Fdo.DoneTransferList);
            
            transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);

            LOGENTRY(transfer->Endpoint,
                FdoDeviceObject, LOG_XFERS, 'ulDT', transfer, 0, 0); 
            
            ASSERT_TRANSFER(transfer);
        }
        
        USBPORT_ReleaseSpinLock(FdoDeviceObject, 
                                &devExt->Fdo.DoneTransferSpin, 
                                irql);

        if (transfer) {
            PHCD_ENDPOINT endpoint;

            endpoint = transfer->Endpoint;
            ASSERT_ENDPOINT(endpoint);
            // we have a completed transfer
            // take proper action based on transfer type
#if DBGPERF     
            // check for significant delay between the 
            // completion frame and when we complete the 
            // irp to the client
            {
            ULONG cf;                
            MP_Get32BitFrameNumber(devExt, cf);          
            LOGENTRY(endpoint,
                     FdoDeviceObject, LOG_XFERS, 'perf', 
                     transfer->MiniportFrameCompleted, 
                     cf,
                     transfer); 
            if (transfer->MiniportFrameCompleted &&
                cf - transfer->MiniportFrameCompleted > 3) {
                BUG_TRAP();
            }
            }
#endif
            if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_SPLIT_CHILD)) {
                USBPORT_DoneSplitTransfer(transfer);
            } else {
                USBPORT_DoneTransfer(transfer);
            }

            // we have completed a transfer, request an 
            // interrupt to process the endpoint for more 
            // transfers
            USBPORT_InvalidateEndpoint(FdoDeviceObject, 
                                       endpoint,
                                       IEP_REQUEST_INTERRUPT);
            
        }           
    }

}


VOID
USBPORT_SetEndpointState(
    PHCD_ENDPOINT Endpoint,
    MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

    Request a particular endpoint state. Call the request down to the 
    miniport then wait for an SOF  

    NOTE we assume the endpoint lock is held

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_ENDPOINT_LOCKED(Endpoint);

    ACQUIRE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
    // this means we are in the middle of another state change
    // which is not good 
    USBPORT_ASSERT(Endpoint->CurrentState ==
        Endpoint->NewState);
    
    USBPORT_ASSERT(Endpoint->CurrentState !=
                   State);

    // make sure we do not go REMOVE->ACTIVE etc.. as this is invalid
    USBPORT_ASSERT(!(Endpoint->CurrentState == ENDPOINT_REMOVE && 
                     Endpoint->NewState != ENDPOINT_REMOVE));          

    if (Endpoint->Flags & EPFLAG_ROOTHUB) {
        // root hub data structures are internal 
        // so we don't need to wait to change state
        Endpoint->NewState =
            Endpoint->CurrentState = State;    
        // if we entered the remove state just put it directly
        // on the closed list, we don't need to wait 
        if (Endpoint->CurrentState == 
            ENDPOINT_REMOVE) {
            LOGENTRY(Endpoint,
                fdoDeviceObject, LOG_XFERS, 'ivRS', Endpoint, 0, 0);    
            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
            // for state changes signal the worker thread
            USBPORT_InvalidateEndpoint(fdoDeviceObject,
                                       Endpoint,
                                       IEP_SIGNAL_WORKER);
                
        } else {
            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
        }
        
    } else {
        LOGENTRY(Endpoint,
            fdoDeviceObject, LOG_XFERS, 'setS', Endpoint, 0, State); 

        if (TEST_FLAG(Endpoint->Flags, EPFLAG_NUKED)) {

            // If the endpoint is nuked this must be the case where the host
            // controller has been powered off and then powered back on and
            // now an endpoint is being closed closed or paused.  
            // However since the the miniport has no reference to it on 
            // the hw we can execute the state change immediatly without
            // calling down to the miniport.

            LOGENTRY(Endpoint,
                fdoDeviceObject, LOG_XFERS, 'nukS', Endpoint, 0, State); 

            Endpoint->CurrentState = 
                Endpoint->NewState = State; 
                
            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
            // endpoint needs to be checked, signal 
            // the PnP worker since this a PnP scenario
            USBPORT_InvalidateEndpoint(fdoDeviceObject,
                                       Endpoint,
                                       IEP_SIGNAL_WORKER);
                
        } else {


            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
            //
            // set the endpoint to the requested state
            //
            MP_SetEndpointState(devExt, Endpoint, State);
        

            Endpoint->NewState = State;
            USBPORT_ASSERT(Endpoint->CurrentState != 
                Endpoint->NewState);            
            // once removed we should never change the state again            
            USBPORT_ASSERT(Endpoint->CurrentState != ENDPOINT_REMOVE);            
                
            MP_Get32BitFrameNumber(devExt, Endpoint->StateChangeFrame);    

            // insert the endpoint on our list
            
            ExInterlockedInsertTailList(&devExt->Fdo.EpStateChangeList,
                                        &Endpoint->StateLink,
                                        &devExt->Fdo.EpStateChangeListSpin.sl);

            // request an SOF so we know when we reach the desired state
            MP_InterruptNextSOF(devExt);

        }            
    }
    
}         


MP_ENDPOINT_STATE
USBPORT_GetEndpointState(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Request the state of an endpoint. 

    We assume the enpoint lock is held

Arguments:

Return Value:

    None.

--*/
{
    MP_ENDPOINT_STATE state;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ACQUIRE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
    state = Endpoint->CurrentState;
    
    if (Endpoint->CurrentState != Endpoint->NewState) {
        state = ENDPOINT_TRANSITION;
    }

    // generates noise
    LOGENTRY(Endpoint,
        fdoDeviceObject, LOG_NOISY, 'Geps', state, Endpoint, 
        Endpoint->CurrentState); 
        
    RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 


    return state;
}         


VOID
USBPORT_PollEndpoint(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Request a particular endpoint state.    

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(Endpoint, 
            fdoDeviceObject, LOG_XFERS, 'Pol>', Endpoint, 0, 0); 
 
    if (!(Endpoint->Flags & EPFLAG_ROOTHUB) && 
        !(Endpoint->Flags & EPFLAG_NUKED)) {
        LOGENTRY(Endpoint,
            fdoDeviceObject, LOG_XFERS, 'PolE', Endpoint, 0, 0); 
        MP_PollEndpoint(devExt, Endpoint)
    }

}         


VOID
USBPORT_InvalidateEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    ULONG IEPflags
    )
/*++

Routine Description:

    internal function, called to indicate an
    endpoint needs attention

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (Endpoint == NULL) {
        // check all endpoints
    
        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'Iall', 0, 0, 0); 
#if DBG        
        {
        LARGE_INTEGER t;            
        KeQuerySystemTime(&t);        
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'tIVE', Endpoint, 
                t.LowPart, 0);
        }                
#endif                
        
        // now walk thru and add all endpoints to the 
        // attention list
        GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

        while (listEntry && 
               listEntry != &devExt->Fdo.GlobalEndpointList) {
//            BOOLEAN check;
            
            Endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    GlobalLink);
                      
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'ckE+', Endpoint, 0, 0);                    
            ASSERT_ENDPOINT(Endpoint);                    
//xxx
//            check = TRUE;
//            if (IsListEmpty(&Endpoint->PendingList) &&
                //
//                IsListEmpty(&Endpoint->CancelList) && 
//                IsListEmpty(&Endpoint->ActiveList)) {
                
//                LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'ckN+', Endpoint, 0, 0);
//                check = FALSE;
//            }
            
            if (!IS_ON_ATTEND_LIST(Endpoint) && 
                USBPORT_GetEndpointState(Endpoint) != ENDPOINT_CLOSED) {

                // if we are not on the list these 
                // link pointers should be NULL
                USBPORT_ASSERT(Endpoint->AttendLink.Flink == NULL);
                USBPORT_ASSERT(Endpoint->AttendLink.Blink == NULL);

                LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'at2+', Endpoint, 
                    &devExt->Fdo.AttendEndpointList, 0);      
                InsertTailList(&devExt->Fdo.AttendEndpointList, 
                               &Endpoint->AttendLink);
                               
            }                                

            listEntry = Endpoint->GlobalLink.Flink;              
        }
        
        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);
    
    } else {
    
        ASSERT_ENDPOINT(Endpoint);

        // insert endpoint on the 
        // 'we need to check it list'

        LOGENTRY(Endpoint,
            FdoDeviceObject, LOG_XFERS, 'IVep', Endpoint, 0, 0); 
        
        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

        if (!IS_ON_ATTEND_LIST(Endpoint) && 
            USBPORT_GetEndpointState(Endpoint) != ENDPOINT_CLOSED) {

            USBPORT_ASSERT(Endpoint->AttendLink.Flink == NULL);
            USBPORT_ASSERT(Endpoint->AttendLink.Blink == NULL);

            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'att+', Endpoint, 
                &devExt->Fdo.AttendEndpointList, 0);  
            InsertTailList(&devExt->Fdo.AttendEndpointList, 
                           &Endpoint->AttendLink);
                           
        }    

        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);
    }        

#ifdef USBPERF
    // signal or interrupt based on flags
    if (TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {
        IEPflags = IEP_SIGNAL_WORKER;
    }
    
    switch (IEPflags) {
    case IEP_SIGNAL_WORKER:
        USBPORT_SignalWorker(devExt->HcFdoDeviceObject); 
        break;
    case IEP_REQUEST_INTERRUPT:        
        // skip signal and allow ISR will process the ep
        MP_InterruptNextSOF(devExt);
        break;
    }
#else 
    // note that the flags are used only in the PERF mode 
    // that reduces thread activity.
    USBPORT_SignalWorker(devExt->HcFdoDeviceObject);
#endif    
}         


VOID
USBPORTSVC_InvalidateEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    called by miniport to indacte a particular
    endpoint needs attention

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    PHCD_ENDPOINT endpoint;
    
    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);

    fdoDeviceObject = devExt->HcFdoDeviceObject;

    if (EndpointData == NULL) {
        // check all endpoints
        USBPORT_InvalidateEndpoint(fdoDeviceObject, NULL, IEP_REQUEST_INTERRUPT);
    } else {
        ENDPOINT_FROM_EPDATA(endpoint, EndpointData);
        USBPORT_InvalidateEndpoint(fdoDeviceObject, endpoint, IEP_REQUEST_INTERRUPT);
    }
}


VOID
USBPORTSVC_CompleteTransfer(
    PDEVICE_DATA DeviceData,
    PDEVICE_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    USBD_STATUS UsbdStatus,
    ULONG BytesTransferred
    )
/*++

Routine Description:

    called to complete a transfer

    ** Must be called in the context of PollEndpoint


Arguments:

Return Value:

    None.

--*/
{   
    PHCD_ENDPOINT endpoint;
    PDEVICE_EXTENSION devExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_OBJECT fdoDeviceObject;
    PTRANSFER_URB urb;
    
    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);

    fdoDeviceObject = devExt->HcFdoDeviceObject;

    // spew for xfers
    USBPORT_KdPrint((2, "'--- xfer length %x (Complete)\n", 
        BytesTransferred));
    
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'cmpT', BytesTransferred, 
        UsbdStatus, TransferParameters); 

    TRANSFER_FROM_TPARAMETERS(transfer, TransferParameters);        
    ASSERT_TRANSFER(transfer);

    SET_FLAG(transfer->Flags, USBPORT_TXFLAG_MPCOMPLETED);
   
    urb = transfer->Urb;
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'cmpU', 0, 
        transfer, urb); 
    ASSERT_TRANSFER_URB(urb);
    
    transfer->MiniportBytesTransferred = 
            BytesTransferred;
        
    // insert the transfer on to our
    // 'done list' and signal the worker
    // thread

    // check for short split, if it is a short mark all 
    // transfers not called down yet 

    if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_SPLIT_CHILD) &&
        BytesTransferred < transfer->Tp.TransferBufferLength) {
    
        PLIST_ENTRY listEntry;
        KIRQL tIrql;
        PHCD_TRANSFER_CONTEXT tmpTransfer;
        PHCD_TRANSFER_CONTEXT splitTransfer;

        // get the parent
        splitTransfer = transfer->Transfer;
        
        ACQUIRE_TRANSFER_LOCK(fdoDeviceObject, splitTransfer, tIrql);     
        // walk the list 

        GET_HEAD_LIST(splitTransfer->SplitTransferList, listEntry);

        while (listEntry && 
               listEntry != &splitTransfer->SplitTransferList) {
           
            tmpTransfer =  (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        SplitLink);
            ASSERT_TRANSFER(tmpTransfer); 
            
            if (!TEST_FLAG(tmpTransfer->Flags, USBPORT_TXFLAG_IN_MINIPORT)) {
                SET_FLAG(tmpTransfer->Flags, USBPORT_TXFLAG_KILL_SPLIT);
            }                

            listEntry = tmpTransfer->SplitLink.Flink; 
        
        } /* while */

        RELEASE_TRANSFER_LOCK(fdoDeviceObject, splitTransfer, tIrql);
    }

#ifdef USBPERF
    USBPORT_QueueDoneTransfer(transfer,
                              UsbdStatus);

#else 
    USBPORT_QueueDoneTransfer(transfer,
                              UsbdStatus);

    USBPORT_SignalWorker(devExt->HcFdoDeviceObject);
#endif
}    


VOID
USBPORT_Worker(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    This the 'main' passive worker function for the controller.
    From this function we process endpoints, complete transfers 
    etc.

    BUGBUG - this needs more fine tunning


Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    KIRQL oldIrql;
    LIST_ENTRY busyList;

    ASSERT_PASSIVE();
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
#define IS_ON_BUSY_LIST(ep) \
    (BOOLEAN) ((ep)->BusyLink.Flink != NULL \
    && (ep)->BusyLink.Blink != NULL)

    
    MP_CheckController(devExt);

    InitializeListHead(&busyList);

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'Wrk+', 0, 0, 
                KeGetCurrentIrql());

    // flush transfers to the hardware before calling the 
    // coreworker function, core worker only deals with 
    // active transfers so this will make sure all endpoints
    // have work to do
    USBPORT_FlushAllEndpoints(FdoDeviceObject);
    
    // now process the 'need attention' list, this is our queue 
    // of endpoints that need processing, if the endpoint is 
    // busy we will skip it.

next_endpoint:

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    KeAcquireSpinLockAtDpcLevel(&devExt->Fdo.EndpointListSpin.sl);
    
    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'attL',
        &devExt->Fdo.AttendEndpointList, 0, 0);
    
    if (!IsListEmpty(&devExt->Fdo.AttendEndpointList)) {

        BOOLEAN busy;
        
        listEntry = RemoveHeadList(&devExt->Fdo.AttendEndpointList);
        
        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    AttendLink);

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'att-', endpoint, 0, 0);
        
        ASSERT_ENDPOINT(endpoint);
        endpoint->AttendLink.Flink = 
            endpoint->AttendLink.Blink = NULL;    

        KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

        busy = USBPORT_CoreEndpointWorker(endpoint, 0);  

// bugbug this causes us to reenter
        //if (!busy) {
        //    // since we polled we will want to flush complete transfers
        //    LOGENTRY(endpoint, FdoDeviceObject, LOG_XFERS, 'Wflp', endpoint, 0, 0);
        //    USBPORT_FlushDoneTransferList(FdoDeviceObject, TRUE);
        //    // we may have new transfers to map
        //   USBPORT_FlushPendingList(endpoint);
        //}            

        KeAcquireSpinLockAtDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

        if (busy && !IS_ON_BUSY_LIST(endpoint)) { 
            // the enpoint was busy...
            // place it on the tail of the temp list, we will 
            // re-insert it after we process all endpoints on
            // the 'attention' list.  Note that we add these 
            // endpoints back after the process loop on the way out 
            // of the routine since it may be a while before we can 
            // process them.
            
            LOGENTRY(endpoint, 
                FdoDeviceObject, LOG_XFERS, 'art+', endpoint, 0, 0);
            InsertTailList(&busyList,                
                           &endpoint->BusyLink);
        } 

        KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.EndpointListSpin.sl);
        KeLowerIrql(oldIrql);
        
        goto next_endpoint;
    }   

    // now put all the busy endpoints back on the attention list
    while (!IsListEmpty(&busyList)) {

        listEntry = RemoveHeadList(&busyList);
        
        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    BusyLink);

        endpoint->BusyLink.Flink = NULL;
        endpoint->BusyLink.Blink = NULL;
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'bus-', endpoint, 0, 0);
        
        ASSERT_ENDPOINT(endpoint);

        if (!IS_ON_ATTEND_LIST(endpoint)) {

            USBPORT_ASSERT(endpoint->AttendLink.Flink == NULL);
            USBPORT_ASSERT(endpoint->AttendLink.Blink == NULL);

            LOGENTRY(endpoint,
                FdoDeviceObject, LOG_XFERS, 'at3+', endpoint, 
                &devExt->Fdo.AttendEndpointList, 0);  
            InsertTailList(&devExt->Fdo.AttendEndpointList, 
                           &endpoint->AttendLink);
                           
            // tell worker to run again                           
            USBPORT_SignalWorker(FdoDeviceObject);
                           
        }                           
    }

    KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

    KeLowerIrql(oldIrql);

    USBPORT_FlushClosedEndpointList(FdoDeviceObject);

    ASSERT_PASSIVE();

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'Wrk-', 0, 0, 
        KeGetCurrentIrql());
    
}


VOID
USBPORT_AbortEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    PIRP Irp
    )
/*++

Routine Description:

    Abort all transfers currently queued to an endpoint.
    We lock the lists and mark all transfers in the queues
    as needing 'Abort', this will allow new transfers to be
    queued even though we are in the abort process.

    When enpointWorker encouters transfers that need to be
    aborted it takes appropriate action.

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;    
    PHCD_TRANSFER_CONTEXT transfer;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // this tends to be the thread tha waits
    LOGENTRY(Endpoint, 
             FdoDeviceObject, LOG_URB, 'Abr+', Endpoint, Irp, 
             KeGetCurrentThread());

    ASSERT_ENDPOINT(Endpoint);

    // lock the endpoint 

    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeB0');

    if (Irp != NULL) {
        InsertTailList(&Endpoint->AbortIrpList, 
                       &Irp->Tail.Overlay.ListEntry);
    }                               

    // mark all transfers in the queues as aborted

    // walk pending list
    GET_HEAD_LIST(Endpoint->PendingList, listEntry);

    while (listEntry && 
           listEntry != &Endpoint->PendingList) {
           
        // extract the urb that is currently on the pending 
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
        LOGENTRY(NULL, FdoDeviceObject, LOG_URB, 'aPND', transfer, 0, 0);                    
        ASSERT_TRANSFER(transfer);                    

        SET_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED);
        
        listEntry = transfer->TransferLink.Flink; 
        
    } /* while */

    // all pending transfers are now marked aborted

    // walk active list
    GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

    while (listEntry && 
           listEntry != &Endpoint->ActiveList) {
           
        // extract the urb that is currently on the active 
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
        LOGENTRY(NULL, FdoDeviceObject, LOG_URB, 'aACT', transfer, 0, 0);                    
        ASSERT_TRANSFER(transfer);                    

        SET_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED);
        if (TEST_FLAG(Endpoint->Flags, EPFLAG_DEVICE_GONE)) {
            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_DEVICE_GONE);
        }            
       
        listEntry = transfer->TransferLink.Flink; 
        
    } /* while */

    LOGENTRY(Endpoint, FdoDeviceObject, LOG_URB, 'aBRm', 0, 0, 0);    
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeB0');

    // since we may need to change state, request an interrupt 
    // to start the process
    USBPORT_InvalidateEndpoint(FdoDeviceObject, 
                               Endpoint, 
                               IEP_REQUEST_INTERRUPT);

    // call the endpoint worker function
    // to process transfers for this endpoint,
    // this will flush them to the cancel list
    USBPORT_FlushPendingList(Endpoint, -1);

    USBPORT_FlushCancelList(Endpoint);

}


ULONG
USBPORT_KillEndpointActiveTransfers(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Abort all transfers marked 'active' for an endpoint.  This function
    is used to flush any active transfers still on the hardware before
    suspending the controller or turning it off.

    Note that pending tranfers are still left queued.

Arguments:

Return Value:

    returns a count of transfers flushed

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;    
    PHCD_TRANSFER_CONTEXT transfer;
    ULONG count = 0;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
 
    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'KIL+', Endpoint, 0, 0);

    ASSERT_ENDPOINT(Endpoint);

    // lock the endpoint 

    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeP0');

    // walk active list
    GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

    while (listEntry && 
           listEntry != &Endpoint->ActiveList) {

        count++;
        // extract the urb that is currently on the active 
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'kACT', transfer, 0, 0);                    
        ASSERT_TRANSFER(transfer);                    

        SET_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED);
        
        listEntry = transfer->TransferLink.Flink; 
        
    } /* while */

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'KILm', 0, 0, 0);    
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeP0');

    USBPORT_FlushPendingList(Endpoint, -1);
    
    USBPORT_FlushCancelList(Endpoint);    

    return count;
}


VOID
USBPORT_FlushController(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Flush all active tranfers off the hardware 

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    ULONG count;
    LIST_ENTRY tmpList;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // check all endpoints

    do {

        count = 0;
        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'Kall', 0, 0, 0); 

        InitializeListHead(&tmpList);

        // copy the global list
        GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

        while (listEntry && 
               listEntry != &devExt->Fdo.GlobalEndpointList) {
            MP_ENDPOINT_STATE currentState;
            
            endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    GlobalLink);
                      
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'xxE+', endpoint, 0, 0);                    
            ASSERT_ENDPOINT(endpoint);                    

            currentState = USBPORT_GetEndpointState(endpoint);
            if (currentState != ENDPOINT_REMOVE && 
                currentState != ENDPOINT_CLOSED) {
                // skip removed endpoints as these will be going away

                // this will stall future attempts to close the 
                // endpoint
                InterlockedIncrement(&endpoint->Busy);
                InsertTailList(&tmpList, &endpoint->KillActiveLink);
            }                

            listEntry = endpoint->GlobalLink.Flink;      
         
        }

        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

        while (!IsListEmpty(&tmpList)) {

            listEntry = RemoveHeadList(&tmpList);
        
            endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    KillActiveLink);
                      
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'kiE+', endpoint, 0, 0);                    
            ASSERT_ENDPOINT(endpoint);                    

            count += USBPORT_KillEndpointActiveTransfers(FdoDeviceObject,
                                                         endpoint);

            InterlockedDecrement(&endpoint->Busy);
        }

        if (count != 0) {
            USBPORT_Wait(FdoDeviceObject, 100);        
        }
        
    } while (count != 0);
    
}


VOID
USBPORT_FlushAbortList(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Complete any pending abort requests we have 
    if no transfers are marked for aborting.
    

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer = NULL;
    PLIST_ENTRY listEntry;
    PDEVICE_OBJECT fdoDeviceObject;
    BOOLEAN abortsPending = FALSE;
    PIRP irp;
    LIST_ENTRY tmpList;
    NTSTATUS ntStatus;
    PURB urb;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);
    fdoDeviceObject = Endpoint->FdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'fABr', Endpoint, 0, 0);

    InitializeListHead(&tmpList);

    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'LeC0');

    if (!IsListEmpty(&Endpoint->AbortIrpList)) {

        GET_HEAD_LIST(Endpoint->PendingList, listEntry);
    
        while (listEntry && 
            listEntry != &Endpoint->PendingList) {
           
            // extract the urb that is currently on the pending 
            transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);
            LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'cPND', transfer, 0, 0);                    
            ASSERT_TRANSFER(transfer);                    

            if (transfer->Flags & USBPORT_TXFLAG_ABORTED) {
                abortsPending = TRUE;
            }
            
            listEntry = transfer->TransferLink.Flink; 
            
        } /* while */

        // walk active list
        GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

        while (listEntry && 
               listEntry != &Endpoint->ActiveList) {
               
            // extract the urb that is currently on the active 
            transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);
            LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'cACT', transfer, 0, 0);                    
            ASSERT_TRANSFER(transfer);                    

            if (transfer->Flags & USBPORT_TXFLAG_ABORTED) {
                LOGENTRY(Endpoint, fdoDeviceObject, LOG_IRPS, 'aACT', transfer, 0, 0);
                abortsPending = TRUE;
            }
            
            listEntry = transfer->TransferLink.Flink; 
            
        } /* while */

    }

    if (abortsPending == FALSE) {

        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'abrP', 0, 0, 0); 
        
        while (!IsListEmpty(&Endpoint->AbortIrpList)) {
        
            listEntry = RemoveHeadList(&Endpoint->AbortIrpList);

            irp = (PIRP) CONTAINING_RECORD(
                    listEntry,
                    struct _IRP, 
                    Tail.Overlay.ListEntry);                                    

            // put it on our list to complete
            InsertTailList(&tmpList, 
                           &irp->Tail.Overlay.ListEntry);

        }
    }

    RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'UeC0');

    // now complete the requests
    while (!IsListEmpty(&tmpList)) {
        PUSBD_DEVICE_HANDLE deviceHandle;
        
        listEntry = RemoveHeadList(&tmpList);

        irp = (PIRP) CONTAINING_RECORD(
                listEntry,
                struct _IRP, 
                Tail.Overlay.ListEntry);         

        urb = USBPORT_UrbFromIrp(irp);                    

        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'aaIP', irp, 0, urb); 

        ntStatus = SET_USBD_ERROR(urb, USBD_STATUS_SUCCESS);   

        GET_DEVICE_HANDLE(deviceHandle, urb);
        ASSERT_DEVICE_HANDLE(deviceHandle);
        InterlockedDecrement(&deviceHandle->PendingUrbs);

        LOGENTRY(NULL, fdoDeviceObject, LOG_IRPS, 'abrC', irp, 0, 0);             
        USBPORT_CompleteIrp(devExt->Fdo.RootHubPdo, irp, ntStatus, 0);                        
                
    }

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'abrX', 0, 0, 0); 
    
}


BOOLEAN
USBPORT_EndpointHasQueuedTransfers(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Returns TRUE if endpoint has transfers queued
    
Arguments:

Return Value:

    True if endpoint has transfers queued

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    BOOLEAN hasTransfers = FALSE;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
 
    ASSERT_ENDPOINT(Endpoint);

    // lock the endpoint 

    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeI0');

    if (!IsListEmpty(&Endpoint->PendingList)) {
        hasTransfers = TRUE;
    }

    if (!IsListEmpty(&Endpoint->ActiveList)) {
        hasTransfers = TRUE;
    }
    
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeI0');

    return hasTransfers;
}


MP_ENDPOINT_STATUS
USBPORT_GetEndpointStatus(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Request the state of an endpoint. 

    We assume the enpoint lock is held

Arguments:

Return Value:

    None.

--*/
{
    MP_ENDPOINT_STATUS status;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);
    ASSERT_ENDPOINT_LOCKED(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {
        status = ENDPOINT_STATUS_RUN;
    } else {
        MP_GetEndpointStatus(devExt, Endpoint, status);
    }        
    
    Endpoint->CurrentStatus = status;            

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'Gept', status, Endpoint, 
        0); 

    return status;
}         


VOID
USBPORT_NukeAllEndpoints(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    internal function, called to indicate an
    endpoint needs attention

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

  // check all endpoints
    
    KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'Nall', 0, 0, 0); 
    
    // now walk thru and add all endpoints to the 
    // attention list
    GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

    while (listEntry && 
           listEntry != &devExt->Fdo.GlobalEndpointList) {

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                listEntry,
                struct _HCD_ENDPOINT, 
                GlobalLink);
                  
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'ckN+', endpoint, 0, 0);                    
        ASSERT_ENDPOINT(endpoint);                    

        // this endpoins HW context has 
        // been lost
        if (!TEST_FLAG(endpoint->Flags, EPFLAG_ROOTHUB)) {
            SET_FLAG(endpoint->Flags, EPFLAG_NUKED);
        }            

        listEntry = endpoint->GlobalLink.Flink;              
        
    }

    KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

}    


VOID
USBPORT_TimeoutAllEndpoints(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Called from deadman DPC, processes timeouts for all 
    endpoints in the system.

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    LIST_ENTRY tmpList;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // check all endpoints

    // local down the global list while we build the temp list
    KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);
    
    InitializeListHead(&tmpList);

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'Tall', 0, 0, 0); 
    
    // now walk thru and add all endpoints to the 
    // attention list
    GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

    while (listEntry && 
           listEntry != &devExt->Fdo.GlobalEndpointList) {

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                listEntry,
                struct _HCD_ENDPOINT, 
                GlobalLink);
                  
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'toE+', endpoint, 0, 0);                    
        ASSERT_ENDPOINT(endpoint);                    

        USBPORT_ASSERT(endpoint->TimeoutLink.Flink == NULL); 
        USBPORT_ASSERT(endpoint->TimeoutLink.Blink == NULL);

        if (USBPORT_GetEndpointState(endpoint) != ENDPOINT_CLOSED) {
            InsertTailList(&tmpList, &endpoint->TimeoutLink);                    
        }            
        
        listEntry = endpoint->GlobalLink.Flink;              
        
    }

    KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

    while (!IsListEmpty(&tmpList)) {
    
        listEntry = RemoveHeadList(&tmpList);
        
        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    TimeoutLink);

        endpoint->TimeoutLink.Flink = 
            endpoint->TimeoutLink.Blink = NULL;
            
        USBPORT_EndpointTimeout(FdoDeviceObject, endpoint);
       
    }

}    


VOID
USBPORT_FlushAllEndpoints(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    LIST_ENTRY tmpList;
    BOOLEAN flush;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // check all endpoints

    // local down the global list while we build the temp list
    KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);
    
    InitializeListHead(&tmpList);

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'Fall', 0, 0, 0); 
    
    // now walk thru and add all endpoints to the 
    // attention list
    GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

    while (listEntry && 
           listEntry != &devExt->Fdo.GlobalEndpointList) {

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                listEntry,
                struct _HCD_ENDPOINT, 
                GlobalLink);
                  
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'toE+', endpoint, 0, 0);                    
        ASSERT_ENDPOINT(endpoint);                    

        USBPORT_ASSERT(endpoint->FlushLink.Flink == NULL); 
        USBPORT_ASSERT(endpoint->FlushLink.Blink == NULL);

        if (USBPORT_GetEndpointState(endpoint) != ENDPOINT_CLOSED) {
            InsertTailList(&tmpList, &endpoint->FlushLink);                    
        }            
        
        listEntry = endpoint->GlobalLink.Flink;              
        
    }

    KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

    while (!IsListEmpty(&tmpList)) {
    
        listEntry = RemoveHeadList(&tmpList);
        
        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    FlushLink);

        endpoint->FlushLink.Flink = 
            endpoint->FlushLink.Blink = NULL;

        ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Le70');
        flush = !IsListEmpty(&endpoint->PendingList);
        RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Le70');

        if (flush) {                            
            USBPORT_FlushPendingList(endpoint, -1);
        }            
       
    }
}    


VOID
USBPORT_EndpointTimeout(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Checks tinmeout status for pending requests

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PLIST_ENTRY listEntry;
    BOOLEAN timeout = FALSE;
    
    // on entry the urb is not cancelable ie
    // no cancel routine

    ASSERT_ENDPOINT(Endpoint);

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'toEP', 0, Endpoint, 0);
            
    // take the endpoint spinlock
    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 0);

     // walk active list
    GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

    while (listEntry && 
           listEntry != &Endpoint->ActiveList) {

        LARGE_INTEGER systemTime;
        
        // extract the urb that is currently on the active 
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'ckTO', transfer, 0, 0);                    
        ASSERT_TRANSFER(transfer);                    

        KeQuerySystemTime(&systemTime);

        if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_IN_MINIPORT) &&
            transfer->MillisecTimeout != 0 &&
            systemTime.QuadPart > transfer->TimeoutTime.QuadPart) {

            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'txTO', transfer, 0, 0); 
            DEBUG_BREAK();
            
            // mark the transfer as aborted
            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED);
            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_TIMEOUT);
        
            // set the millisec timeout to zero so we 
            // don't time it out again.
            transfer->MillisecTimeout = 0;
            timeout = TRUE;
        }    
        
        listEntry = transfer->TransferLink.Flink; 
        
    } /* while */

    // release the endpoint lists
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 0);

    if (timeout) {
        USBPORT_InvalidateEndpoint(FdoDeviceObject,
                                   Endpoint,
                                   IEP_SIGNAL_WORKER);
    }                                           
}

#ifdef LOG_OCA_DATA
VOID
USBPORT_RecordOcaData(
    PDEVICE_OBJECT FdoDeviceObject,
    POCA_DATA OcaData,
    PHCD_TRANSFER_CONTEXT Transfer,
    PIRP Irp
    )
/*++

Routine Description:

    Record some data on the stack we can use for crash analysis
    in a minidump

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG i;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    OcaData->OcaSig1 = SIG_USB_OCA1;

    OcaData->Irp = Irp;

    for (i=0; i< USB_DRIVER_NAME_LEN; i++) {
        OcaData->AnsiDriverName[i] = (UCHAR) Transfer->DriverName[i];
    }
    
    OcaData->DeviceVID = Transfer->DeviceVID;
    OcaData->DevicePID = Transfer->DevicePID;

    // probably need vid/pid/rev for HC as well
    OcaData->HcFlavor = devExt->Fdo.HcFlavor;
        
    OcaData->OcaSig2 = SIG_USB_OCA2;
}
#endif

VOID
USBPORT_DpcWorker(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    This worker function is called in the context of the ISRDpc
    it is used to process high priority endpoints.

    THIS ROUTINE RUNS AT DISPATCH LEVEL

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    KIRQL irql;
    LIST_ENTRY workList;
    BOOLEAN process;
    LONG busy;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    InitializeListHead(&workList);

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'DPw+', 0, 0, 0);

    // loop thru all the endpoints and find candidates for 
    // priority processing
    
    KeAcquireSpinLockAtDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

    GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

    while (listEntry && 
           listEntry != &devExt->Fdo.GlobalEndpointList) {

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                listEntry,
                struct _HCD_ENDPOINT, 
                GlobalLink);
                  
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'wkE+', endpoint, 0, 0);                    
        ASSERT_ENDPOINT(endpoint);                    

        USBPORT_ASSERT(endpoint->PriorityLink.Flink == NULL); 
        USBPORT_ASSERT(endpoint->PriorityLink.Blink == NULL);

        busy = InterlockedIncrement(&endpoint->Busy);
    
        if (USBPORT_GetEndpointState(endpoint) == ENDPOINT_ACTIVE && 
            (endpoint->Parameters.TransferType == Isochronous ||
             endpoint->Parameters.TransferType == Interrupt ||
             endpoint->Parameters.TransferType == Bulk ||
             endpoint->Parameters.TransferType == Control) &&
             busy == 0 && 
             !TEST_FLAG(endpoint->Flags, EPFLAG_ROOTHUB)) {
            
            InsertTailList(&workList, &endpoint->PriorityLink);                    
        }  else {   
            // endpoint is busy leave it for now
            InterlockedDecrement(&endpoint->Busy);
        }
        
        listEntry = endpoint->GlobalLink.Flink;              
        
    }


    KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

    // work list conatins endpoints that need processing 
    
    while (!IsListEmpty(&workList)) {

        listEntry = RemoveHeadList(&workList);

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    PriorityLink);

        endpoint->PriorityLink.Flink = NULL;
        endpoint->PriorityLink.Blink = NULL;
        
        ASSERT_ENDPOINT(endpoint);

        // we have a candidate, see if we really need to process it
        process = TRUE;
        ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Le20');

  
        RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Ue23');

        if (process) {

            // run the worker routine -- this posts new
            // transfers to the hardware and polls the 
            // enpoint

            USBPORT_CoreEndpointWorker(endpoint, CW_SKIP_BUSY_TEST);  

            // flush more transfers to the hardware, this will 
            // call CoreWorker a second time
            USBPORT_FlushPendingList(endpoint, -1);
        }
    }  

    // now flush done transfers, since we are in 
    // the context of a hardware interrrupt we 
    // should have some completed transfers. Although
    // a DPC was queued we want to flush now

    USBPORT_FlushDoneTransferList(FdoDeviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\device.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    device.c

Abstract:

    This module creates "Devices" on the bus for 
    bus emuerators like the hub driver

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_FreeUsbAddress)
#pragma alloc_text(PAGE, USBPORT_AllocateUsbAddress)
#pragma alloc_text(PAGE, USBPORT_SendCommand)
#endif

// non paged functions
//USBPORT_ValidateDeviceHandle
//USBPORT_RemoveDeviceHandle
//USBPORT_AddDeviceHandle
//USBPORT_ValidatePipeHandle
//USBPORT_OpenEndpoint
//USBPORT_CloseEndpoint
//USBPORT_CreateDevice
//USBPORT_RemoveDevice
//USBPORT_InitializeDevice
//USBPORT_RemovePipeHandle
//USBPORT_AddPipeHandle
//USBPORT_LazyCloseEndpoint
//USBPORT_FlushClosedEndpointList


/*
    Handle validation routines, we keep a list 
    of valid handles and match the ones passed 
    in with our list.

    Access to the device handle list for
    
    //USBPORT_CreateDevice
    //USBPORT_RemoveDevice
    //USBPORT_InitializeDevice    

    is serialized with a global semaphore so we don't 
    need a spinlock.
    
    BUGBUG
    We may be able to use try/except block 
    here but I'm not sure it works at all IRQL
    and on all platforms
*/

BOOLEAN
USBPORT_ValidateDeviceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    BOOLEAN ReferenceUrb
    )
/*++

Routine Description:

    returns true if a device handle is valid

Arguments:

Return Value:

    TRUE is handle is valid

--*/
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY listEntry;
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    KeAcquireSpinLock(&devExt->Fdo.DevHandleListSpin.sl, &irql);
     
    if (DeviceHandle == NULL) {
        // NULL is obviously not valid
        goto USBPORT_ValidateDeviceHandle_Done;       
    }

    listEntry = &devExt->Fdo.DeviceHandleList;
    
    if (!IsListEmpty(listEntry)) {
        listEntry = devExt->Fdo.DeviceHandleList.Flink;
    }

    while (listEntry != &devExt->Fdo.DeviceHandleList) {

        PUSBD_DEVICE_HANDLE nextHandle;
            
        nextHandle = (PUSBD_DEVICE_HANDLE) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_DEVICE_HANDLE, 
                    ListEntry);

                                    
        listEntry = nextHandle->ListEntry.Flink;

        if (nextHandle == DeviceHandle) {
            found = TRUE;
            if (ReferenceUrb) {
                InterlockedIncrement(&DeviceHandle->PendingUrbs);        
            }
            break;
        }
    }                      

USBPORT_ValidateDeviceHandle_Done:

#if DBG
    if (!found) {
//        USBPORT_KdPrint((1, "'bad device handle %x\n", DeviceHandle));        
        DEBUG_BREAK();
    }
#endif

    KeReleaseSpinLock(&devExt->Fdo.DevHandleListSpin.sl, irql);

    return found;
}


VOID
USBPORT_RemoveDeviceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

    TRUE is handle is valid

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    ASSERT_DEVICE_HANDLE(DeviceHandle);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, 
        FdoDeviceObject, LOG_MISC, 'remD', DeviceHandle, 0, 0);

    // synchronize with the validation function,
    // NOTE: we don't synchornize with the ADD function becuause it 
    // is already serialized
    USBPORT_InterlockedRemoveEntryList(&DeviceHandle->ListEntry,
                                       &devExt->Fdo.DevHandleListSpin.sl);  
   
    
}


ULONG
USBPORT_GetDeviceCount(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    counts devices on the BUS

Arguments:

Return Value:

    number of devices 

--*/
{
    PLIST_ENTRY listEntry;
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    ULONG deviceCount = 0;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    KeAcquireSpinLock(&devExt->Fdo.DevHandleListSpin.sl, &irql);
     
    listEntry = &devExt->Fdo.DeviceHandleList;
    
    if (!IsListEmpty(listEntry)) {
        listEntry = devExt->Fdo.DeviceHandleList.Flink;
    }

    while (listEntry != &devExt->Fdo.DeviceHandleList) {

        PUSBD_DEVICE_HANDLE nextHandle;

        nextHandle = (PUSBD_DEVICE_HANDLE) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_DEVICE_HANDLE, 
                    ListEntry);

        
        deviceCount++;
                                    
        listEntry = nextHandle->ListEntry.Flink;

    }                      

    KeReleaseSpinLock(&devExt->Fdo.DevHandleListSpin.sl, irql);

    return deviceCount;
    
}


VOID
USBPORT_AddDeviceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

    adds a device handle to our internal list

Arguments:

Return Value:

    TRUE is handle is valid

--*/
{
    PDEVICE_EXTENSION devExt;

    ASSERT_DEVICE_HANDLE(DeviceHandle);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'addD', DeviceHandle, 0, 0);
     
    InsertTailList(&devExt->Fdo.DeviceHandleList, 
        &DeviceHandle->ListEntry);        
    
}


VOID
USBPORT_RemovePipeHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PUSBD_PIPE_HANDLE_I PipeHandle
    )
/*++

Routine Description:

    Removes a pipe handle from our list of 'valid handles'

Arguments:

Return Value:

    none

--*/
{
    USBPORT_ASSERT(PipeHandle->ListEntry.Flink != NULL &&
                   PipeHandle->ListEntry.Blink != NULL);
                   
    RemoveEntryList(&PipeHandle->ListEntry);
    PipeHandle->ListEntry.Flink = NULL;
    PipeHandle->ListEntry.Blink = NULL;
}


VOID
USBPORT_AddPipeHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PUSBD_PIPE_HANDLE_I PipeHandle
    )
/*++

Routine Description:

    adds a pipe handle to our internal list

Arguments:

Return Value:

    TRUE is handle is valid

--*/
{
    ASSERT_DEVICE_HANDLE(DeviceHandle);

    USBPORT_ASSERT(PipeHandle->ListEntry.Flink == NULL &&
                   PipeHandle->ListEntry.Blink == NULL);
                   
    InsertTailList(&DeviceHandle->PipeHandleList, 
        &PipeHandle->ListEntry);        
}


BOOLEAN 
USBPORT_ValidatePipeHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PUSBD_PIPE_HANDLE_I PipeHandle
    )
/*++

Routine Description:

    returns true if a device handle is valid

Arguments:

Return Value:

    TRUE is handle is valid

--*/
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY listEntry;

    ASSERT_DEVICE_HANDLE(DeviceHandle);

    listEntry = &DeviceHandle->PipeHandleList;
    
    if (!IsListEmpty(listEntry)) {
        listEntry = DeviceHandle->PipeHandleList.Flink;
    }

    while (listEntry != &DeviceHandle->PipeHandleList) {

        PUSBD_PIPE_HANDLE_I nextHandle;
            
        nextHandle = (PUSBD_PIPE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_PIPE_HANDLE_I, 
                    ListEntry);

                                    
        listEntry = nextHandle->ListEntry.Flink;

        if (nextHandle == PipeHandle) {
            found = TRUE;
            break;
        }
    }                      

#if DBG
    if (!found) {
        USBPORT_KdPrint((1, "'bad pipe handle %x\n", PipeHandle));        
        DEBUG_BREAK();
    }
#endif

    return found;
}


NTSTATUS
USBPORT_SendCommand(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_DEFAULT_PIPE_SETUP_PACKET SetupPacket,
    PVOID Buffer,
    ULONG BufferLength,
    PULONG BytesReturned,
    USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

    Send a standard USB command on the default pipe.

    essentially what we do here is build a control 
    transfer and queue it directly

Arguments:

    DeviceHandle - ptr to USBPORT device structure the command will be sent to

    DeviceObject -

    RequestCode -

    WValue - wValue for setup packet

    WIndex - wIndex for setup packet

    WLength - wLength for setup packet

    Buffer - Input/Output Buffer for command                                                                                                                                                                                                                  
    
    BufferLength - Length of Input/Output buffer.

    BytesReturned - pointer to ulong to copy number of bytes
                    returned (optional)

    UsbStatus - USBPORT status code returned in the URB.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PTRANSFER_URB urb = NULL;
    PUSBD_PIPE_HANDLE_I defaultPipe = &(DeviceHandle->DefaultPipe);
    PDEVICE_EXTENSION devExt;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    KEVENT event;

    PAGED_CODE();
    USBPORT_KdPrint((2, "'enter USBPORT_SendCommand\n"));
    
    ASSERT_DEVICE_HANDLE(DeviceHandle);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT((USHORT)BufferLength == SetupPacket->wLength);

    LOGENTRY(defaultPipe->Endpoint, 
        FdoDeviceObject, LOG_MISC, 'SENc', 0, 0, 0);
   

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    ALLOC_POOL_Z(urb, NonPagedPool,
                 sizeof(struct _TRANSFER_URB));

    if (urb) {
        InterlockedIncrement(&DeviceHandle->PendingUrbs);        
  
        ntStatus = STATUS_SUCCESS;
        usbdStatus = USBD_STATUS_SUCCESS;
        
        urb->Hdr.Length = sizeof(struct _TRANSFER_URB);
        urb->Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;

        RtlCopyMemory(urb->u.SetupPacket,
                      SetupPacket,
                      8);
            
        urb->TransferFlags = USBD_SHORT_TRANSFER_OK;
        urb->UsbdPipeHandle = defaultPipe;
        urb->Hdr.UsbdDeviceHandle = DeviceHandle;
        urb->Hdr.UsbdFlags = 0; 

        // USBPORT is responsible for setting the transfer direction
        //
        // TRANSFER direction is implied in the command

        if (SetupPacket->bmRequestType.Dir ==  BMREQUEST_DEVICE_TO_HOST) {
            USBPORT_SET_TRANSFER_DIRECTION_IN(urb->TransferFlags);
        } else {
            USBPORT_SET_TRANSFER_DIRECTION_OUT(urb->TransferFlags);
        }            

        urb->TransferBufferLength = BufferLength;
        urb->TransferBuffer = Buffer;
        urb->TransferBufferMDL = NULL;

        if (urb->TransferBufferLength != 0) {

            if ((urb->TransferBufferMDL =
                 IoAllocateMdl(urb->TransferBuffer,
                               urb->TransferBufferLength,
                               FALSE,
                               FALSE,
                               NULL)) == NULL) {
                usbdStatus = USBD_STATUS_INSUFFICIENT_RESOURCES;
                // map the error
                ntStatus = USBPORT_SetUSBDError(NULL, usbdStatus);
            } else {
                SET_FLAG(urb->Hdr.UsbdFlags, USBPORT_REQUEST_MDL_ALLOCATED);
                MmBuildMdlForNonPagedPool(
                    urb->TransferBufferMDL);
            }
            
        }

        LOGENTRY(defaultPipe->Endpoint, FdoDeviceObject, 
                    LOG_MISC, 'sndC',  
                        urb->TransferBufferLength, 
                        SetupPacket->bmRequestType.B,
                        SetupPacket->bRequest);
        USBPORT_KdPrint((2, 
            "'SendCommand cmd = 0x%x  0x%x buffer = 0x%x length = 0x%x direction = 0x%x\n",
                         SetupPacket->bmRequestType.B,
                         SetupPacket->bRequest,    
                         urb->TransferBuffer,
                         urb->TransferBufferLength,
                         urb->TransferFlags));

        // queue the transfer
        if (NT_SUCCESS(ntStatus)) { 

            usbdStatus = USBPORT_AllocTransfer(FdoDeviceObject,
                                               urb,
                                               NULL,
                                               NULL,
                                               &event,
                                               5000);

            if (USBD_SUCCESS(usbdStatus)) {
                // do the transfer, 5 second timeout
                
                // match the decrement in queue transferurb
                InterlockedIncrement(&DeviceHandle->PendingUrbs);        
                USBPORT_QueueTransferUrb(urb);

                LOGENTRY(NULL, FdoDeviceObject, 
                    LOG_MISC, 'sWTt', 0, 0, 0);
   
                // wait for completion                                
                KeWaitForSingleObject(&event,
                                      Suspended,
                                      KernelMode,
                                      FALSE,
                                      NULL);  

                LOGENTRY(NULL, FdoDeviceObject, 
                    LOG_MISC, 'sWTd', 0, 0, 0);                                      
                // map the error
                usbdStatus = urb->Hdr.Status;                                      
            }
            
            ntStatus = 
                SET_USBD_ERROR(urb, usbdStatus); 

            if (BytesReturned) {
                *BytesReturned = urb->TransferBufferLength;
            }            

            if (UsbdStatus) {
                *UsbdStatus = usbdStatus;
            }            
        }
        // free the transfer URB

        InterlockedDecrement(&DeviceHandle->PendingUrbs);    
        FREE_POOL(FdoDeviceObject, urb);

    } else {
        if (UsbdStatus) {
            *UsbdStatus = USBD_STATUS_INSUFFICIENT_RESOURCES;
            ntStatus = USBPORT_SetUSBDError(NULL, *UsbdStatus);
        } else {   
            ntStatus = USBPORT_SetUSBDError(NULL, USBD_STATUS_INSUFFICIENT_RESOURCES);
        }            
    } 

    //LOGENTRY(defaultPipe->Endpoint, 
    //    FdoDeviceObject, LOG_MISC, 'SENd', 0, ntStatus, usbdStatus);
    
    USBPORT_KdPrint((2, "'exit USBPORT_SendCommand 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPORT_PokeEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    This function closes an existing endpoint in the miniport,
    frees the common buffer the reopens it with new requirements
    and parameters.

    This function is synchronous and assumes no active transfers 
    are pending for the endpoint.

    This function is currently used to grow the transfer parameters 
    on interrupt and control endpoints and to change the address of 
    the default control endpoint

    NOTES:
        1. for now we assume no changes to bw allocation
        2. new parameters are set before the call in the endpoint
            structure

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    ENDPOINT_REQUIREMENTS requirements;
    USB_MINIPORT_STATUS mpStatus;
    PDEVICE_EXTENSION devExt;
    PUSBPORT_COMMON_BUFFER commonBuffer;
    LONG busy;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // close the endpoint in the miniport

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'poke', Endpoint, 0, 0);

    // mark the endpoint busy so that we don't poll it until 
    // we open it again
    do {
        busy = InterlockedIncrement(&Endpoint->Busy);

        if (!busy) {
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'pNby', 0, Endpoint, busy);
            break;
        }

        // defer processing
        InterlockedDecrement(&Endpoint->Busy);
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'pbsy', 0, Endpoint, busy);
        USBPORT_Wait(FdoDeviceObject, 1);

    } while (busy != 0); 
    
    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'Ley0');
    MP_SetEndpointState(devExt, Endpoint, ENDPOINT_REMOVE);
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'Uey0');

    USBPORT_Wait(FdoDeviceObject, 2);
    // enpoint should now be out of the schedule

    // zero miniport data
    RtlZeroMemory(&Endpoint->MiniportEndpointData[0],
                  REGISTRATION_PACKET(devExt).EndpointDataSize);


    // free the old miniport common buffer
    if (Endpoint->CommonBuffer) {
        USBPORT_HalFreeCommonBuffer(FdoDeviceObject,
                                    Endpoint->CommonBuffer);    
        Endpoint->CommonBuffer = NULL;
    }        

    MP_QueryEndpointRequirements(devExt, 
                                 Endpoint, 
                                 &requirements);
                                 
    // alloc new common buffer 
    // save the requirements
    
    USBPORT_ASSERT(Endpoint->Parameters.TransferType != Bulk);
    USBPORT_ASSERT(Endpoint->Parameters.TransferType != Isochronous);  
    
    USBPORT_KdPrint((1, "'(POKE) miniport requesting %d bytes\n", 
        requirements.MinCommonBufferBytes));
    
    // allocate common buffer for this endpoint
        
    if (requirements.MinCommonBufferBytes) {           
        commonBuffer = 
            USBPORT_HalAllocateCommonBuffer(FdoDeviceObject,        
                                            requirements.MinCommonBufferBytes);
    } else {    
        commonBuffer = NULL;
    }

    if (commonBuffer == NULL && 
        requirements.MinCommonBufferBytes) {
        
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        Endpoint->CommonBuffer = NULL;
        
    } else {
        Endpoint->CommonBuffer = commonBuffer;
        ntStatus = STATUS_SUCCESS;
    }        

    if (Endpoint->CommonBuffer) {
        Endpoint->Parameters.CommonBufferVa =             
             commonBuffer->MiniportVa;
        Endpoint->Parameters.CommonBufferPhys =             
             commonBuffer->MiniportPhys;  
        Endpoint->Parameters.CommonBufferBytes = 
             commonBuffer->MiniportLength;   
    }

    if (NT_SUCCESS(ntStatus)) {        
        MP_OpenEndpoint(devExt, Endpoint, mpStatus);
    
        // in this UNIQUE situation this API is not allowed 
        // (and should not) fail
        USBPORT_ASSERT(mpStatus == USBMP_STATUS_SUCCESS);

        // we need to sync the endpoint state with 
        // the miniport, when first opened the miniport
        // puts the endpoint in status HALT.
        
        ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeK0');   
        ACQUIRE_STATECHG_LOCK(FdoDeviceObject, Endpoint); 
        if (Endpoint->CurrentState == ENDPOINT_ACTIVE) {
            RELEASE_STATECHG_LOCK(FdoDeviceObject, Endpoint); 
            MP_SetEndpointState(devExt, Endpoint, ENDPOINT_ACTIVE);
        } else {
            RELEASE_STATECHG_LOCK(FdoDeviceObject, Endpoint); 
        }
        RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeK0');   
    }

    InterlockedDecrement(&Endpoint->Busy);
    
    return ntStatus;

}


VOID 
USBPORT_WaitActive(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
{    
    MP_ENDPOINT_STATE currentState;

    ASSERT_ENDPOINT(Endpoint);
    
    do {
        ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeH0');

        currentState = USBPORT_GetEndpointState(Endpoint);
        
        RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeH0');
        
        LOGENTRY(Endpoint,
                FdoDeviceObject, LOG_XFERS, 'watA', Endpoint, 
                    currentState, 0);

        if (currentState == ENDPOINT_ACTIVE) {
            // quick release
            break;
        }

        ASSERT_PASSIVE();
        USBPORT_Wait(FdoDeviceObject, 1);
            
    } while (currentState != ENDPOINT_ACTIVE);
        
}                


NTSTATUS
USBPORT_OpenEndpoint(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_PIPE_HANDLE_I PipeHandle,
    OUT USBD_STATUS *ReturnUsbdStatus,
    BOOLEAN IsDefaultPipe
    )
/*++

Routine Description:

    open an endpoint on a USB device.

    This function creates (initializes) endpoints and 
    hooks it to a pipehandle

Arguments:

    DeviceHandle - data describes the device this endpoint is on.

    DeviceObject - USBPORT device object.

    ReturnUsbdStatus - OPTIONAL                 

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    PHCD_ENDPOINT endpoint;
    USBD_STATUS usbdStatus;
    ULONG siz;
    BOOLEAN gotBw;
    USB_HIGH_SPEED_MAXPACKET muxPacket;
    extern ULONG USB2LIB_EndpointContextSize;
    
    // this function is not pagable because we raise irql

    // we should be at passive level        
    ASSERT_PASSIVE();
    
    // devhandle should have been validated 
    // before we get here
    ASSERT_DEVICE_HANDLE(DeviceHandle);

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    siz = sizeof(*endpoint) + REGISTRATION_PACKET(devExt).EndpointDataSize;

    if (USBPORT_IS_USB20(devExt)) {
        siz += USB2LIB_EndpointContextSize;
    }            

    LOGENTRY(NULL, FdoDeviceObject, 
             LOG_PNP, 'opE+', PipeHandle, siz,
             REGISTRATION_PACKET(devExt).EndpointDataSize);   

    // allocate the endoint

    // * begin special case 
    // check for a no bandwidth endpoint ie max_oacket = 0 
    // if so return success and set the endpoint pointer 
    // in the pipe handle to a dummy value

    if (PipeHandle->EndpointDescriptor.wMaxPacketSize == 0) { 

        USBPORT_AddPipeHandle(DeviceHandle,
                              PipeHandle);

        PipeHandle->Endpoint = USB_BAD_PTR;
        ntStatus = STATUS_SUCCESS;
        SET_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW);   
        CLEAR_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_STATE_CLOSED);
                
        goto USBPORT_OpenEndpoint_Done;
    }

    // * end special case
    
    ALLOC_POOL_Z(endpoint, NonPagedPool, siz);

    if (endpoint) {

        endpoint->Sig = SIG_ENDPOINT;
        endpoint->Flags = 0;
        endpoint->EndpointRef = 0;
        endpoint->Busy = -1;
        endpoint->FdoDeviceObject = FdoDeviceObject;
        endpoint->DeviceHandle = DeviceHandle;
        endpoint->Tt = DeviceHandle->Tt;
        if (endpoint->Tt != NULL) {
            ASSERT_TT(endpoint->Tt);
            ExInterlockedInsertTailList(&DeviceHandle->Tt->EndpointList, 
                                        &endpoint->TtLink,
                                        &devExt->Fdo.TtEndpointListSpin.sl);
        }                                        

        if (USBPORT_IS_USB20(devExt)) {
            PUCHAR pch;
            
            pch = (PUCHAR) &endpoint->MiniportEndpointData[0];
            pch += REGISTRATION_PACKET(devExt).EndpointDataSize;
                  
            endpoint->Usb2LibEpContext = pch;                    
        } else {
            endpoint->Usb2LibEpContext = USB_BAD_PTR;
        }
        
#if DBG    
        USBPORT_LogAlloc(&endpoint->Log, 1);
#endif    
        LOGENTRY(endpoint, FdoDeviceObject, 
             LOG_PNP, 'ope+', PipeHandle, siz,
             REGISTRATION_PACKET(devExt).EndpointDataSize);   

        // initialize the endpoint
        InitializeListHead(&endpoint->ActiveList);
        InitializeListHead(&endpoint->CancelList);
        InitializeListHead(&endpoint->PendingList);
        InitializeListHead(&endpoint->AbortIrpList);

        USBPORT_InitializeSpinLock(&endpoint->ListSpin, 'EPL+', 'EPL-');
        USBPORT_InitializeSpinLock(&endpoint->StateChangeSpin, 'SCL+', 'SCL-');
    
        // extract some information from the 
        // descriptor
        endpoint->Parameters.DeviceAddress = 
            DeviceHandle->DeviceAddress;

        if (endpoint->Tt != NULL) {
            ASSERT_TT(endpoint->Tt);
            endpoint->Parameters.TtDeviceAddress = 
                endpoint->Tt->DeviceAddress;
        } else {
            endpoint->Parameters.TtDeviceAddress = 0xFFFF;
        }
        
        endpoint->Parameters.TtPortNumber =            
            DeviceHandle->TtPortNumber;

        muxPacket.us = PipeHandle->EndpointDescriptor.wMaxPacketSize;                    
        endpoint->Parameters.MuxPacketSize = 
            muxPacket.MaxPacket;
        endpoint->Parameters.TransactionsPerMicroframe =
            muxPacket.HSmux+1;
        endpoint->Parameters.MaxPacketSize = 
            muxPacket.MaxPacket * (muxPacket.HSmux+1);            
        
        endpoint->Parameters.EndpointAddress = 
            PipeHandle->EndpointDescriptor.bEndpointAddress;            

        if ((PipeHandle->EndpointDescriptor.bmAttributes & 
              USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_ISOCHRONOUS) { 
#ifdef ISO_LOG              
            USBPORT_LogAlloc(&endpoint->IsoLog, 4);              
#endif            
            endpoint->Parameters.TransferType = Isochronous;      
        } else if ((PipeHandle->EndpointDescriptor.bmAttributes & 
              USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_BULK) {              
            endpoint->Parameters.TransferType = Bulk;      
        } else if ((PipeHandle->EndpointDescriptor.bmAttributes & 
              USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_INTERRUPT) {              
            endpoint->Parameters.TransferType = Interrupt;             
        } else {
            USBPORT_ASSERT((PipeHandle->EndpointDescriptor.bmAttributes & 
              USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_CONTROL);
            endpoint->Parameters.TransferType = Control;              
        }

        // check for low speed
        endpoint->Parameters.DeviceSpeed = DeviceHandle->DeviceSpeed;

        // Set max transfer size based on transfer type
        //
        // Note: that the MaximumTransferSize set by the 
        // client driver in the pipe information structure
        // is no longer used.
        switch(endpoint->Parameters.TransferType) {
        case Interrupt:
            // this allows clients to put down larger 
            // interrupt buffers if they want without 
            // taking a perf hit. For some reason 
            // printers do this.
            
            // bugbug research the praticality of splitting
            // interrupt transfers for the miniports this may
            // significantly reduce the memory allocated by 
            // he uhci miniport
            endpoint->Parameters.MaxTransferSize = 1024;
                 //endpoint->Parameters.MaxPacketSize;
            break;
        case Control:
            // 4k
            // node that the old win2k 4k usb stack does not actually 
            // handle transfers larger than this correctly.
            endpoint->Parameters.MaxTransferSize = 1024*4;

            // set the default to 64k if this is not the control endpoint
            if (endpoint->Parameters.EndpointAddress != 0) {
                // the COMPAQ guys test this
               
                endpoint->Parameters.MaxTransferSize = 1024*64;
            }                
            break;
        case Bulk:
            // 64k default
            endpoint->Parameters.MaxTransferSize = 1024*64;
            break;
        case Isochronous:
            // there is no reason to have a limit here 
            // choose a really large default
            endpoint->Parameters.MaxTransferSize = 0x01000000;
            break;
        }

        endpoint->Parameters.Period = 0;
       
        // compute period required
        if (endpoint->Parameters.TransferType == Interrupt) {

            UCHAR tmp;
            UCHAR hsInterval;

            if (endpoint->Parameters.DeviceSpeed == HighSpeed) {
                // normalize the high speed period to microframes
                // for USB 20 the period specifies a power of 2  
                // ie period = 2^(hsInterval-1)
                hsInterval = PipeHandle->EndpointDescriptor.bInterval;
                if (hsInterval) {
                    hsInterval--;
                }
                // hsInterval must be 0..5
                if (hsInterval > 5) {
                    hsInterval = 5;
                }
                tmp = 1<<hsInterval;
            } else {
                tmp = PipeHandle->EndpointDescriptor.bInterval;
            }
            // this code finds the first interval 
            // <= USBPORT_MAX_INTEP_POLLING_INTERVAL
            // valid intervals are:
            // 1, 2, 4, 8, 16, 32(USBPORT_MAX_INTEP_POLLING_INTERVAL)
            
            // Initialize Period, may be adjusted down
            
            endpoint->Parameters.Period = USBPORT_MAX_INTEP_POLLING_INTERVAL;

            if ((tmp != 0) && (tmp < USBPORT_MAX_INTEP_POLLING_INTERVAL)) {

                // bInterval is in range.  Adjust Period down if necessary.

                if ((endpoint->Parameters.DeviceSpeed == LowSpeed) &&
                    (tmp < 8)) {

                    // bInterval is not valid for LowSpeed, cap Period at 8
                    
                    endpoint->Parameters.Period = 8;

                } else {

                    // Adjust Period down to greatest power of 2 less than or
                    // equal to bInterval.

                    while ((endpoint->Parameters.Period & tmp) == 0) {
                        endpoint->Parameters.Period >>= 1;
                    }
                }
            }

//!!!
//if (endpoint->Parameters.DeviceSpeed == LowSpeed) {
//    TEST_TRAP();
//    endpoint->Parameters.Period = 1;
//}
//!!!

            endpoint->Parameters.MaxPeriod = 
                endpoint->Parameters.Period;  
        }

        if (endpoint->Parameters.TransferType == Isochronous) {
            endpoint->Parameters.Period = 1;
        }            

        if (IS_ROOT_HUB(DeviceHandle)) {
            SET_FLAG(endpoint->Flags, EPFLAG_ROOTHUB); 
        }        

        if (USB_ENDPOINT_DIRECTION_IN(
            PipeHandle->EndpointDescriptor.bEndpointAddress)) {
            endpoint->Parameters.TransferDirection = In;
        } else {
            endpoint->Parameters.TransferDirection = Out;
        }

        if (USBPORT_IS_USB20(devExt)) {
            // call the engine and attempt to allocate the necessary 
            // bus time for this endoint
            gotBw = USBPORT_AllocateBandwidthUSB20(FdoDeviceObject, endpoint);
//!!!
//if (endpoint->Parameters.DeviceSpeed == LowSpeed) {
//    TEST_TRAP();
//    endpoint->Parameters.InterruptScheduleMask = 0x10; //sMask;
//    endpoint->Parameters.SplitCompletionMask = 0xc1; //cMask;
//}
//!!!
            
        } else {
            // * USB 1.1
            
            endpoint->Parameters.Bandwidth = 
                USBPORT_CalculateUsbBandwidth(FdoDeviceObject, endpoint);

            // caclualte the best schedule position
            gotBw = USBPORT_AllocateBandwidthUSB11(FdoDeviceObject, endpoint);
        }
        
        if (gotBw) {

            if (IsDefaultPipe ||   
                endpoint->Parameters.TransferType == Isochronous) {
                // iso and default pipes do not halt on errors 
                // ie they do not require a resetpipe
                endpoint->Parameters.EndpointFlags |= EP_PARM_FLAG_NOHALT;
            }   

            ntStatus = STATUS_SUCCESS;
        } else {
            LOGENTRY(endpoint,
                FdoDeviceObject, LOG_PNP, 'noBW', endpoint, 0, 0);
    
            // no bandwidth error
            ntStatus = USBPORT_SetUSBDError(NULL, USBD_STATUS_NO_BANDWIDTH);
            if (ReturnUsbdStatus != NULL) {
                *ReturnUsbdStatus = USBD_STATUS_NO_BANDWIDTH;
            }
        }
        
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    } 

    
    if (NT_SUCCESS(ntStatus)) {

        // now do the open
        
        if (TEST_FLAG(endpoint->Flags, EPFLAG_ROOTHUB)) {
            PDEVICE_EXTENSION rhDevExt;

            GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
            ASSERT_PDOEXT(rhDevExt);

            // opens for the root hub device
            // are not passed to the miniport
            usbdStatus = USBD_STATUS_SUCCESS;
            
            endpoint->EpWorkerFunction = 
                USBPORT_RootHub_EndpointWorker;

            // successful open the enpoint defaults 
            // to active
            endpoint->NewState =
                endpoint->CurrentState = ENDPOINT_ACTIVE;

            // track the hub interrupt endpoint
            if (endpoint->Parameters.TransferType == Interrupt) {
                rhDevExt->Pdo.RootHubInterruptEndpoint = 
                    endpoint;       
            }
            
        } else {
        
            USB_MINIPORT_STATUS mpStatus;
            PUSBPORT_COMMON_BUFFER commonBuffer;
            ENDPOINT_REQUIREMENTS requirements;
            ULONG ordinal;
            
            // find out what we will need from the 
            // miniport for this endpoint
            
            MP_QueryEndpointRequirements(devExt, 
                endpoint, &requirements);

            // adjust maxtransfer based on miniport 
            // feedback.
            switch (endpoint->Parameters.TransferType) {
            case Bulk:
            case Interrupt:
                LOGENTRY(endpoint,
                    FdoDeviceObject, LOG_MISC, 'MaxT', endpoint, 
                    requirements.MaximumTransferSize, 0);
    
                EP_MAX_TRANSFER(endpoint) = 
                    requirements.MaximumTransferSize;
                break;  
            }                    

            ordinal = USBPORT_SelectOrdinal(FdoDeviceObject,
                                            endpoint);

            USBPORT_KdPrint((1, "'miniport requesting %d bytes\n", 
                requirements.MinCommonBufferBytes));
                    
            // allocate common buffer for this endpoint
            if (requirements.MinCommonBufferBytes) {     
                commonBuffer = 
                   USBPORT_HalAllocateCommonBuffer(FdoDeviceObject,        
                           requirements.MinCommonBufferBytes);
            } else {
                commonBuffer = NULL;
            }
                       

            if (commonBuffer == NULL && 
                requirements.MinCommonBufferBytes) {
                
                mpStatus = USBMP_STATUS_NO_RESOURCES;
                endpoint->CommonBuffer = NULL;
                
            } else {

                ULONG mpOptionFlags;

                mpOptionFlags = REGISTRATION_PACKET(devExt).OptionFlags;
                
                endpoint->CommonBuffer = commonBuffer;
                if (commonBuffer != NULL) {
                    endpoint->Parameters.CommonBufferVa =             
                        commonBuffer->MiniportVa;
                    endpoint->Parameters.CommonBufferPhys =             
                        commonBuffer->MiniportPhys;                 
                    endpoint->Parameters.CommonBufferBytes = 
                        commonBuffer->MiniportLength;   
                }
                endpoint->Parameters.Ordinal = ordinal;
                    
                // call open request to minport
                MP_OpenEndpoint(devExt, endpoint, mpStatus);

                // note that once we call open this enpoint 
                // may show up on the Attention list

                // set our internal flags based on what the 
                // miniport passed back
//                if (endpoint->Parameters.EndpointFlags & EP_PARM_FLAG_DMA) {
                SET_FLAG(endpoint->Flags, EPFLAG_MAP_XFERS);

                if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_NO_PNP_RESOURCES)) {
                    // no mapping for the virtual bus
                    CLEAR_FLAG(endpoint->Flags, EPFLAG_MAP_XFERS);
                    SET_FLAG(endpoint->Flags, EPFLAG_VBUS);
                }
                SET_FLAG(endpoint->Flags, EPFLAG_VIRGIN);
                endpoint->EpWorkerFunction = 
                        USBPORT_DmaEndpointWorker;
//                } else {
                    // non-dma endpoint
//                    TEST_TRAP();
//                }
            }                

            // successful open the enpoint defaults 
            // to pause, we need to move it to active

            if (mpStatus == USBMP_STATUS_SUCCESS) {
                ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'LeF0');   
                // initialize endpoint state machine
                endpoint->CurrentState = ENDPOINT_PAUSE;
                endpoint->NewState = ENDPOINT_PAUSE;
                endpoint->CurrentStatus = ENDPOINT_STATUS_RUN; 
                USBPORT_SetEndpointState(endpoint, ENDPOINT_ACTIVE);    
                RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'UeF0');  

                // Wait for endpoint to go active. The reason here 
                // is that an iso driver (usbaudio) will immediatly 
                // send transfers to the endpoint, these tranfers are 
                // marked with a transmission frame on submission but 
                // will have to wait until the endpoint is active to 
                // be programmed, hence they arrive in the miniport 
                // too late on slower systems.
                USBPORT_WaitActive(FdoDeviceObject,
                                   endpoint);
            }
            
            usbdStatus = MPSTATUS_TO_USBSTATUS(mpStatus);        
        }    

        // convert usb status to nt status
        ntStatus = USBPORT_SetUSBDError(NULL, usbdStatus);
        if (ReturnUsbdStatus != NULL) {
            *ReturnUsbdStatus = usbdStatus;
        }
    }
    
    if (NT_SUCCESS(ntStatus)) {
    
        USBPORT_AddPipeHandle(DeviceHandle,
                              PipeHandle);

        // track the endpoint
        ExInterlockedInsertTailList(&devExt->Fdo.GlobalEndpointList, 
                                    &endpoint->GlobalLink,
                                    &devExt->Fdo.EndpointListSpin.sl);                               
                              
        PipeHandle->Endpoint = endpoint;
        CLEAR_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_STATE_CLOSED);
        
    } else {
        if (endpoint) {
            if (endpoint->Tt != NULL) {
                ASSERT_TT(endpoint->Tt);
                USBPORT_InterlockedRemoveEntryList(&endpoint->TtLink,
                                                   &devExt->Fdo.TtEndpointListSpin.sl);
            }    
            USBPORT_LogFree(FdoDeviceObject, &endpoint->Log);
            UNSIG(endpoint);
            FREE_POOL(FdoDeviceObject, endpoint);
        }
    }
    
USBPORT_OpenEndpoint_Done:

    return ntStatus;
}


VOID
USBPORT_CloseEndpoint(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Close an Endpoint

Arguments:

    DeviceHandle - ptr to USBPORT device data structure.

    DeviceObject - USBPORT device object.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = 0;
    PURB urb;
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    KIRQL irql;
    BOOLEAN stallClose;
    LONG busy;

    // should have been validated before we 
    // get here
    ASSERT_DEVICE_HANDLE(DeviceHandle);

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // we should have no requests queued to the 
    // endpoint
    LOGENTRY(Endpoint, FdoDeviceObject, 
                LOG_MISC, 'clEP', Endpoint, 0, 0);
             

    // remove from our 'Active' lists
    KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

    if (TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB) &&
        Endpoint->Parameters.TransferType == Interrupt) {

        KIRQL rhIrql;
        PDEVICE_EXTENSION rhDevExt;

        // remove references to th eroot hub
        
        ACQUIRE_ROOTHUB_LOCK(FdoDeviceObject, rhIrql);

        // we should have a root hub pdo since we are closing 
        // an endpoint associated with it.
        
        USBPORT_ASSERT(devExt->Fdo.RootHubPdo != NULL);
        
        GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
        ASSERT_PDOEXT(rhDevExt);
        
        rhDevExt->Pdo.RootHubInterruptEndpoint = NULL;

        RELEASE_ROOTHUB_LOCK(FdoDeviceObject, rhIrql);

    }        

    KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

    // The client is locked out at this point ie he can't access the 
    // pipe tied to the endpoint.  We need to wait for any outstanding 
    // stuff to complete -- including any state changes, after which
    // we can ask the coreworker to remove the endpoint.
    
    // the endpoint lock protects the lists -- which need to be 
    // empty

    do {
    
        stallClose = FALSE;
        ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeD1');
    
        if (!IsListEmpty(&Endpoint->PendingList)) {
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'stc1', Endpoint, 0, 0);
            stallClose = TRUE;        
        }

        if (!IsListEmpty(&Endpoint->ActiveList)) {
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'stc2', Endpoint, 0, 0);
            stallClose = TRUE;        
        }

        if (!IsListEmpty(&Endpoint->CancelList)) {
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'stc3', Endpoint, 0, 0);
            stallClose = TRUE;        
        }

        if (!IsListEmpty(&Endpoint->AbortIrpList)) {
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'stc4', Endpoint, 0, 0);
            stallClose = TRUE;        
        }

        if (Endpoint->EndpointRef) {
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'stc6', Endpoint, 0, 0);
            stallClose = TRUE;        
        }

        ACQUIRE_STATECHG_LOCK(FdoDeviceObject, Endpoint); 
        if (Endpoint->CurrentState !=
            Endpoint->NewState) {
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'stc5', Endpoint, 0, 0);
            stallClose = TRUE;                  
        }  
        RELEASE_STATECHG_LOCK(FdoDeviceObject, Endpoint); 
        RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeD1');

        // last check...
        // synchronize with worker 
        // we just need to wait for worker to finish if it is running
        // it should not pick up and run again unless it has stuff to
        // do -- in which case stallClose will already be set.
        busy = InterlockedIncrement(&Endpoint->Busy);
        if (busy) {
            // defer processing
            LOGENTRY(Endpoint, 
                FdoDeviceObject, LOG_XFERS, 'clby', 0, Endpoint, 0);
            stallClose = TRUE;
        }
        InterlockedDecrement(&Endpoint->Busy);
        
        if (stallClose) {
            LOGENTRY(Endpoint, 
                FdoDeviceObject, LOG_XFERS, 'stlC', 0, Endpoint, 0);
            USBPORT_Wait(FdoDeviceObject, 1);
        }            
             
    } while (stallClose);

    LOGENTRY(Endpoint, 
        FdoDeviceObject, LOG_XFERS, 'CLdn', 0, Endpoint, 0);

    // unlink ref to device handle since it will be removed when 
    // all endpoints are closed
    Endpoint->DeviceHandle = NULL;

    // lock the endpoint & set the state to remove and
    // free the bw
    if (USBPORT_IS_USB20(devExt)) {
        KIRQL irql;
        PTRANSACTION_TRANSLATOR tt;
        
        USBPORT_FreeBandwidthUSB20(FdoDeviceObject, Endpoint);
        
        KeAcquireSpinLock(&devExt->Fdo.TtEndpointListSpin.sl, &irql);
        tt = Endpoint->Tt;
        if (tt != NULL) {
            ASSERT_TT(tt);

            USBPORT_ASSERT(Endpoint->TtLink.Flink != NULL);                
            USBPORT_ASSERT(Endpoint->TtLink.Blink != NULL);   
            RemoveEntryList(&Endpoint->TtLink);
            Endpoint->TtLink.Flink = NULL;
            Endpoint->TtLink.Blink = NULL;
            if (TEST_FLAG(tt->TtFlags, USBPORT_TTFLAG_REMOVED) &&
                IsListEmpty(&tt->EndpointList)) {

                ULONG i, bandwidth;                    
                
                USBPORT_UpdateAllocatedBwTt(tt);
                // alloc new            
                bandwidth = tt->MaxAllocedBw;
                for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
                    devExt->Fdo.BandwidthTable[i] += bandwidth;
                }

                // last endpoint free the TT if it is marked gone
                FREE_POOL(FdoDeviceObject, tt);   

            }
        }            
        KeReleaseSpinLock(&devExt->Fdo.TtEndpointListSpin.sl, irql);
                                                   
    } else {
        USBPORT_FreeBandwidthUSB11(FdoDeviceObject, Endpoint);
    }        
   
    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeD0');
    USBPORT_SetEndpointState(Endpoint, ENDPOINT_REMOVE);         
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeD0');

    // the endpoint will be freed when it reaches the 'REMOVE' 
    // state
    // endpointWorker will be signalled when a frame has passed 
    // at that time the endpoint will be moved to the closed list
    // and the worker thread will be signalled to flush the closed
    // endpoints ie free the common buffer.

    USBPORT_SignalWorker(FdoDeviceObject);                                

    return;
}


VOID
USBPORT_ClosePipe(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_PIPE_HANDLE_I PipeHandle
    )
/*++

Routine Description:

    Close a USB pipe and the endpoint associated with it 

    This is a synchronous operation that waits for all 
    transfers associated with the pipe to be completed.

Arguments:

    DeviceHandle - ptr to USBPORT device data structure.

    DeviceObject - USBPORT device object.

    PipeHandle - USBPORT pipe handle associated with the endpoint.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = 0;
    PDEVICE_EXTENSION devExt;

    // should have beed validated before we 
    // get here
    ASSERT_DEVICE_HANDLE(DeviceHandle);
    ASSERT_PIPE_HANDLE(PipeHandle);

    LOGENTRY(NULL, FdoDeviceObject, 
                LOG_MISC, 'clPI', PipeHandle, 0, 0);

    if (PipeHandle->PipeStateFlags & USBPORT_PIPE_STATE_CLOSED) {
        // already closed
        // generally when a pertially open interface needs to 
        // be closed due to an error
        USBPORT_ASSERT(PipeHandle->ListEntry.Flink == NULL &&
                   PipeHandle->ListEntry.Blink == NULL);
    
        return;
    }
  
    // invalidate the pipe
    USBPORT_RemovePipeHandle(DeviceHandle,
                             PipeHandle);                            

    SET_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_STATE_CLOSED);                             

    // at this point the client will be unable to queue
    // any transfers to this pipe or endpoint

    // BUGBUG flush tranfers and wait, this also includes waiting 
    // for any state changes to complete

    LOGENTRY(NULL, FdoDeviceObject, 
                LOG_MISC, 'pipW', PipeHandle, 0, 0);

//    KeWait(PipeEvent) {
//    }

    // now 'close' the endpoint
    if (TEST_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {
        CLEAR_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW);
    } else {        
        USBPORT_CloseEndpoint(DeviceHandle,
                              FdoDeviceObject,
                              PipeHandle->Endpoint);
    }                              
}


VOID
USBPORT_FlushClosedEndpointList(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    walk the "closed" endpoint list and close any endpoints
    that are ready.

    endpoints are placed on the 'closed' list when they reach the 
    removed state.

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    KIRQL irql;
    BOOLEAN closed = TRUE;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, 
                LOG_NOISY, 'fCLO', FdoDeviceObject, 0, 0);

    // stall any closes
    KeAcquireSpinLock(&devExt->Fdo.EpClosedListSpin.sl, &irql);

    while (!IsListEmpty(&devExt->Fdo.EpClosedList) && 
            closed) {

        listEntry = RemoveHeadList(&devExt->Fdo.EpClosedList);            

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                            listEntry,
                            struct _HCD_ENDPOINT, 
                            ClosedLink);

        LOGENTRY(NULL, FdoDeviceObject, 
                LOG_PNP, 'fclo', endpoint, 0, 0);

        ASSERT_ENDPOINT(endpoint);
        USBPORT_ASSERT(endpoint->CurrentState == ENDPOINT_CLOSED);
        endpoint->ClosedLink.Flink = NULL;
        endpoint->ClosedLink.Blink = NULL;

        KeReleaseSpinLock(&devExt->Fdo.EpClosedListSpin.sl, irql);

        // if we are unable to close now we must bail so the 
        // worker function can run
        closed = USBPORT_LazyCloseEndpoint(FdoDeviceObject, endpoint);

        KeAcquireSpinLock(&devExt->Fdo.EpClosedListSpin.sl, &irql);

    } 

    KeReleaseSpinLock(&devExt->Fdo.EpClosedListSpin.sl, irql);


}    


BOOLEAN
USBPORT_LazyCloseEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Close an Endpoint. Put the endpoint on our list 
    of endpoints-to-close and wakeup the worker thread.

Arguments:

Return Value:

    returns true if closed

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    BOOLEAN closed;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, 
                LOG_XFERS, 'frEP', Endpoint, 0, 0);

    // endpoint is no longer on the global list, now we just need 
    // to make sure no one has a reference to it before we delete 
    // it.  
    // The endpoint may have been invalidated ie on the Attention 
    // List before being removed from the global list to avoid this 
    // potential conlict we check here until both the busy flag is
    // -1 (meaning coreworker is thru) AND AttendLink is NULL
    // if it is busy we put it back on the closed list
    
    if (IS_ON_ATTEND_LIST(Endpoint) ||
        Endpoint->Busy != -1) {
        // still have work to do, put the endpoint back on 
        // the close list
        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'CLOr', 0, Endpoint, 0);

        // it is OK to be on the attention list and the closed 
        // list

        USBPORT_ASSERT(Endpoint->ClosedLink.Flink == NULL);
        USBPORT_ASSERT(Endpoint->ClosedLink.Blink == NULL);

        ExInterlockedInsertTailList(&devExt->Fdo.EpClosedList, 
                                    &Endpoint->ClosedLink,
                                    &devExt->Fdo.EpClosedListSpin.sl);  
                                
        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);
        closed = FALSE;
        
    } else {           

        // remove from global list
        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);
        RemoveEntryList(&Endpoint->GlobalLink);  
        Endpoint->GlobalLink.Flink = NULL;
        Endpoint->GlobalLink.Blink = NULL;
        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);                
        
        // free endpoint memory
        if (Endpoint->CommonBuffer) {
            USBPORT_HalFreeCommonBuffer(FdoDeviceObject,
                                        Endpoint->CommonBuffer);
        }                       

        USBPORT_LogFree(FdoDeviceObject, &Endpoint->Log);
#ifdef ISO_LOG        
        USBPORT_LogFree(FdoDeviceObject, &Endpoint->IsoLog);
#endif 
        UNSIG(Endpoint);
        FREE_POOL(FdoDeviceObject, Endpoint);   
        closed = TRUE;
    }        

    return closed;
}    


VOID
USBPORT_FreeUsbAddress(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT DeviceAddress
    )
/*++

Routine Description:


Arguments:

Return Value:

    Valid USB address (1..127) to use for this device,
    returns 0 if no device address available.

--*/
{
    PDEVICE_EXTENSION devExt;
    USHORT address = 0, i, j;
    ULONG bit;

    PAGED_CODE();

    // we should never see a free to device address 0
    
    USBPORT_ASSERT(DeviceAddress != 0);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    for (j=0; j<4; j++) {
        bit = 1;
        for (i=0; i<32; i++) {
            address = (USHORT)(j*32+i);
            if (address == DeviceAddress) {
                devExt->Fdo.AddressList[j] &= ~bit;
                goto USBPORT_FreeUsbAddress_Done;
            }
            bit = bit<<1;
        }
    }

USBPORT_FreeUsbAddress_Done:

    USBPORT_KdPrint((3, "'USBPORT free Address %d\n", address));

}


USHORT
USBPORT_AllocateUsbAddress(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:


Arguments:

Return Value:

    Valid USB address (1..127) to use for this device,
    returns 0 if no device address available.

--*/
{
    PDEVICE_EXTENSION devExt;
    USHORT address, i, j;
    ULONG bit;

    PAGED_CODE();
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    address = 0;        

    for (j=0; j<4; j++) {
        bit = 1;
        for (i=0; i<32; i++) {

            if (!(devExt->Fdo.AddressList[j] & bit)) {
                devExt->Fdo.AddressList[j] |= bit;
                address = (USHORT)(j*32+i);
                goto USBPORT_AllocateUsbAddress_Done;
            }
            bit = bit<<1;
        }
    }

    // no free addresses?
    USBPORT_ASSERT(0);
    
 USBPORT_AllocateUsbAddress_Done:
 
    USBPORT_KdPrint((3, "'USBPORT assigning Address %d\n", address));

    return address;
}


NTSTATUS
USBPORT_InitializeHsHub(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    ULONG TtCount
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    This service initializes a high speed hub

Arguments:

    HubDeviceHandle - DeviceHandle for the creating USB Hub

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    ULONG i;

    LOGENTRY(NULL, FdoDeviceObject, 
        LOG_MISC, 'ihsb', 0, HubDeviceHandle, TtCount);

    // hub driver might pass us NULL if it could not 
    // retrieve a device handle
    if (HubDeviceHandle == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT_DEVICE_HANDLE(HubDeviceHandle)
    USBPORT_ASSERT(HubDeviceHandle->DeviceSpeed == HighSpeed);

    if (IS_ROOT_HUB(HubDeviceHandle)) {
        // no TTs for the root hub yet
        return STATUS_SUCCESS;
    }        
    
    USBPORT_ASSERT(HubDeviceHandle->DeviceDescriptor.bDeviceClass == 
                        USB_DEVICE_CLASS_HUB); 
    USBPORT_ASSERT(TEST_FLAG(HubDeviceHandle->DeviceFlags, 
                        USBPORT_DEVICEFLAG_HSHUB));

    for (i=0; i< TtCount; i++) {
        ntStatus = USBPORT_InitializeTT(FdoDeviceObject,
                                        HubDeviceHandle,
                                        (USHORT)i+1);

        if(!NT_SUCCESS(ntStatus)) {
            break;
        }
    }  

    HubDeviceHandle->TtCount = TtCount;

    return ntStatus;
}


NTSTATUS
USBPORT_CreateDevice(
    PUSBD_DEVICE_HANDLE *DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    USHORT PortStatus,
    USHORT PortNumber
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Called for each new device on the USB bus, this function sets
    up the internal data structures we need to keep track of the
    device and assigns it an address.

Arguments:

    DeviceHandle - ptr to return the ptr to the new device structure
                created by this routine

    DeviceObject - USBPORT device object for the USB bus this device is on.

    HubDeviceHandle - DeviceHandle for the creating USB Hub

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PUSBD_DEVICE_HANDLE deviceHandle;
    PUSBD_PIPE_HANDLE_I defaultPipe;
    PDEVICE_EXTENSION devExt;
    ULONG bytesReturned = 0;
    PUCHAR data = NULL;
    BOOLEAN open = FALSE;
    ULONG dataSize;
    PTRANSACTION_TRANSLATOR tt = NULL;
    USHORT ttPort;

    PAGED_CODE();
    USBPORT_KdPrint((2, "'CreateDevice\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    //
    // first validate the deviceHandle for the creating hub, we need 
    // this information for USB 1.1 devices behind a USB 2.0 hub.
    //

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'crD>', HubDeviceHandle, 
        PortNumber, PortStatus);

    // NOTE: this actually locks all device handles 
    LOCK_DEVICE(HubDeviceHandle, FdoDeviceObject);
  
    if (!USBPORT_ValidateDeviceHandle(FdoDeviceObject,
                                      HubDeviceHandle,
                                      FALSE)) {
        // this is most likely a bug in the hub driver
        DEBUG_BREAK();
        
        UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);    
        // fail the create if the hubs device handle is bugus
        // chances are that the device handle is bad becuse the
        // device is gone.
        return STATUS_DEVICE_NOT_CONNECTED;
    }   

    // start at the port for this device,
    // if this is a 1.1 device in a 1.1 hub
    // downstream of a 2.0 hub then we need 
    // the port number from the 1.1 hub
    ttPort = PortNumber;
    // port status tells us the type of device we are dealing with
    if (USBPORT_IS_USB20(devExt) && 
        !TEST_FLAG(PortStatus, PORT_STATUS_HIGH_SPEED)) {
        // walk upstream until we reach a USB 2.0 hub
        // this hub will conatin the appropriate TT
        tt = USBPORT_GetTt(FdoDeviceObject, 
                           HubDeviceHandle,
                           &ttPort);
    }
    
    UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);   

    ALLOC_POOL_Z(deviceHandle, NonPagedPool,
                 sizeof(USBD_DEVICE_HANDLE));
                              
    *DeviceHandle = NULL;
    if (deviceHandle == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        LOGENTRY(NULL, 
          FdoDeviceObject, LOG_MISC, 'CRED', 0, 0, deviceHandle);
        
        deviceHandle->PendingUrbs = 0;
        deviceHandle->HubDeviceHandle = HubDeviceHandle;
        deviceHandle->ConfigurationHandle = NULL;
        deviceHandle->DeviceAddress = USB_DEFAULT_DEVICE_ADDRESS;
        //deviceHandle->DeviceBandwidth = 0;
        
        if (PortStatus & PORT_STATUS_LOW_SPEED) {
            deviceHandle->DeviceSpeed = LowSpeed;
        } else if (PortStatus & PORT_STATUS_HIGH_SPEED) {
            deviceHandle->DeviceSpeed = HighSpeed;
        } else {
            deviceHandle->DeviceSpeed = FullSpeed;
        }
        
        deviceHandle->Sig = SIG_DEVICE_HANDLE;            
        
        // port number is maps to a specific tt but hub fw 
        // has to make sense of this.
        deviceHandle->TtPortNumber = ttPort;
        deviceHandle->Tt = tt;
        
        LOCK_DEVICE(deviceHandle, FdoDeviceObject);
    
        // buffer for our descriptor, one packet
        data = (PUCHAR) &deviceHandle->DeviceDescriptor;
        dataSize = sizeof(deviceHandle->DeviceDescriptor);
        
        // **
        // We need to talk to the device, first we open the default pipe
        // using the defined max packet size (defined by USB spec as 8
        // bytes until device receives the GET_DESCRIPTOR (device) command).
        // We set the address get the device descriptor then close the pipe
        // and re-open it with the correct max packet size.
        // **
#define USB_DEFAULT_LS_MAX_PACKET   8
        //
        // open the default pipe for the device
        //
        defaultPipe = &deviceHandle->DefaultPipe;
        if (deviceHandle->DeviceSpeed == LowSpeed) {
            INITIALIZE_DEFAULT_PIPE(*defaultPipe, USB_DEFAULT_LS_MAX_PACKET);
        } else {
            INITIALIZE_DEFAULT_PIPE(*defaultPipe, USB_DEFAULT_MAX_PACKET);
        }
        InitializeListHead(&deviceHandle->PipeHandleList);     
        InitializeListHead(&deviceHandle->TtList);     
        
        ntStatus = USBPORT_OpenEndpoint(deviceHandle,
                                        FdoDeviceObject,
                                        defaultPipe,
                                        NULL,
                                        TRUE);
        open = NT_SUCCESS(ntStatus); 
        
        bytesReturned = 0;
        
        if (NT_SUCCESS(ntStatus)) {

            //
            // Configure the default pipe for this device and assign the
            // device an address
            //
            // NOTE: if this operation fails it means that we have a device
            // that will respond to the default endpoint and we can't change
            // it.
            // we have no choice but to disable the port on the hub this
            // device is attached to.
            //


            //
            // Get information about the device
            //
            USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
            PUCHAR tmpDevDescBuf;

            // Would you believe that there exist some devices that get confused
            // if the very first Get Device Descriptor request does not have a
            // wLength value of 0x40 even though the device only has a 0x12 byte
            // Device Descriptor to return?  Any change to the way devices have
            // always been enumerated since the being of USB 1.0 time can cause
            // bizarre consequences.  Use a wLength value of 0x40 for the very
            // first Get Device Descriptor request.

            ALLOC_POOL_Z(tmpDevDescBuf, NonPagedPool,
                         USB_DEFAULT_MAX_PACKET);

            if (tmpDevDescBuf == NULL) {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else {

                // setup packet for get device descriptor
            
                USBPORT_INIT_SETUP_PACKET(setupPacket,
                                          USB_REQUEST_GET_DESCRIPTOR, // bRequest
                                          BMREQUEST_DEVICE_TO_HOST, // Dir
                                          BMREQUEST_TO_DEVICE, // Recipient
                                          BMREQUEST_STANDARD, // Type
                                          USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(USB_DEVICE_DESCRIPTOR_TYPE, 0), //  wValue
                                          0, // wIndex
                                          USB_DEFAULT_MAX_PACKET); // wLength
                  
                ntStatus = USBPORT_SendCommand(deviceHandle,
                                               FdoDeviceObject,
                                               &setupPacket,
                                               tmpDevDescBuf,
                                               USB_DEFAULT_MAX_PACKET,
                                               &bytesReturned,
                                               NULL);

                // NOTE:
                // at this point we only have the first 8 bytes of the
                // device descriptor.

                RtlCopyMemory(data, tmpDevDescBuf, dataSize);

                FREE_POOL(FdoDeviceObject, tmpDevDescBuf);
            }
        }

        // some devices babble so we ignore the error 
        // on this transaction if we got enough data
        if (bytesReturned == 8 && !NT_SUCCESS(ntStatus)) {
            USBPORT_KdPrint((1,
                "'Error returned from get device descriptor -- ignored\n"));
            ntStatus = STATUS_SUCCESS;
        }

        // validate the max packet value and descriptor
        // we need at least eight bytes a value of zero 
        // in max packet is bogus
        
        if (NT_SUCCESS(ntStatus) && 
            (bytesReturned >= 8) &&
            (deviceHandle->DeviceDescriptor.bLength >= sizeof(USB_DEVICE_DESCRIPTOR)) &&
            (deviceHandle->DeviceDescriptor.bDescriptorType == USB_DEVICE_DESCRIPTOR_TYPE) &&
            ((deviceHandle->DeviceDescriptor.bMaxPacketSize0 == 0x08) ||
             (deviceHandle->DeviceDescriptor.bMaxPacketSize0 == 0x10) ||
             (deviceHandle->DeviceDescriptor.bMaxPacketSize0 == 0x20) ||
             (deviceHandle->DeviceDescriptor.bMaxPacketSize0 == 0x40))) {

            USBPORT_AddDeviceHandle(FdoDeviceObject, deviceHandle);

            *DeviceHandle = deviceHandle;
            
        } else {

            PUCHAR p = (PUCHAR)&deviceHandle->DeviceDescriptor;
            
            // print a big debug message
            USBPORT_KdPrint((0, "'CREATEDEVICE failed enumeration %08X %02X\n",
                             ntStatus, bytesReturned));

            USBPORT_KdPrint((0, "'%02X %02X %02X %02X %02X %02X %02X %02X"
                                " %02X %02X %02X %02X %02X %02X %02X %02X"
                                " %02X %02X\n",
                             p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7],
                             p[8],p[9],p[10],p[11],p[12],p[13],p[14],p[15],
                             p[16],p[17]));

            USBPORT_DebugClient((
                "Bad Device Detected\n"));            
            DEBUG_BREAK(); 
            //
            // something went wrong, if we assigned any resources to
            // the default pipe then we free them before we get out.
            //

            // we need to signal to the parent hub that this
            // port is to be be disabled we will do this by
            // returning an error.
            ntStatus = STATUS_DEVICE_DATA_ERROR;

            // if we opened a pipe close it
            if (open) {

                USBPORT_ClosePipe(deviceHandle,
                                  FdoDeviceObject,
                                  defaultPipe);
            }

        }
        UNLOCK_DEVICE(deviceHandle, FdoDeviceObject);

        if (!NT_SUCCESS(ntStatus)) {
            ASSERT_DEVICE_HANDLE(deviceHandle)
            UNSIG(deviceHandle);
            FREE_POOL(FdoDeviceObject, deviceHandle);
        }
    }

USBPORT_CreateDevice_Done:

    CATC_TRAP_ERROR(FdoDeviceObject, ntStatus);
    
    LOGENTRY(NULL, 
        FdoDeviceObject, LOG_MISC, 'creD', 0, 0, ntStatus);
    USBPORT_ENUMLOG(FdoDeviceObject, 'cdev', ntStatus, 0);
    
    return ntStatus;
}


NTSTATUS
USBPORT_RemoveDevice(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG Flags
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Called for each device on the USB bus that needs to be removed.
    This routine frees the device handle and the address assigned
    to the device.

    Some new tricks here:

    When this function is called it is asumed the client driver has 
    received the REMOVE irp and passed it on to the bus driver. We
    remove the device handle from our list, this will cause any new 
    transfers submitted by the driver to be failed.  Any current 
    transfers the driver has will be completed with error.

    Once all transfer are flushed for all the endpoints we will close
    the endpoints and free the device handle (ie) noone has any references
    to it anymore.

    This should -- in theory -- prevent bad drivers from crashing in usbport
    or the miniport if they send requests after a remove.

Arguments:

    DeviceHandle - ptr to device data structure created by class driver
                in USBPORT_CreateDevice.

    FdoDeviceObject - USBPORT device object for the USB bus this device is on.

    Flags - 
        USBD_KEEP_DEVICE_DATA   
        USBD_MARK_DEVICE_BUSY   - we don't use this one

        

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    PUSBD_PIPE_HANDLE_I defaultPipe;
    USBD_STATUS usbdStatus;

    if (Flags & USBD_KEEP_DEVICE_DATA) {
        // keep data means keep the handle valid
        return STATUS_SUCCESS;
    }
    
    if (Flags & USBD_MARK_DEVICE_BUSY) {
        // This means stop accepting requests.  Only used by USBHUB when
        // handling a IOCTL_INTERNAL_USB_RESET_PORT request??  Need to do
        // anything special here??  Need to keep the handle valid since it
        // will be used to restore the device after the reset.
        //
        // GlenS note to JD: review this.
        //
        return STATUS_SUCCESS;
    }

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    
    // assume success
    ntStatus = STATUS_SUCCESS;

    LOCK_DEVICE(DeviceHandle, FdoDeviceObject);
    
    if (!USBPORT_ValidateDeviceHandle(FdoDeviceObject,
                                      DeviceHandle,
                                      FALSE)) {
        // this is most likely a bug in the hub 
        // driver
        DEBUG_BREAK();
        
        UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);    
        // chances are that the device handle is bad becuse the
        // device is gone.
        return STATUS_DEVICE_NOT_CONNECTED;
    }   

    LOGENTRY(NULL, 
        FdoDeviceObject, LOG_PNP, 'REMV', DeviceHandle, 0, 0);

    // handle is no longer on our lists so all attempts
    // to submit urbs by the client driver will now fail
    
    USBPORT_RemoveDeviceHandle(FdoDeviceObject,
                               DeviceHandle);

    SET_FLAG(DeviceHandle->DeviceFlags, 
             USBPORT_DEVICEFLAG_REMOVED);


    USBPORT_AbortAllTransfers(FdoDeviceObject,
                              DeviceHandle);

    // wait for any refs from non-transfer URBs to drain
    while (InterlockedDecrement(&DeviceHandle->PendingUrbs) >= 0) {
        LOGENTRY(NULL,
          FdoDeviceObject, LOG_PNP, 'dPUR', DeviceHandle, 0, 
            DeviceHandle->PendingUrbs);
   
        InterlockedIncrement(&DeviceHandle->PendingUrbs);
        USBPORT_Wait(FdoDeviceObject, 100);    
    }                               
                              
    //
    // make sure and clean up any open pipe handles
    // the device may have
    //
    
    if (DeviceHandle->ConfigurationHandle) {

        USBPORT_InternalCloseConfiguration(DeviceHandle,
                                           FdoDeviceObject,
                                           0);

    }

    defaultPipe = &DeviceHandle->DefaultPipe;

    // we should aways have a default pipe, this will free 
    // the endpoint
    USBPORT_ClosePipe(DeviceHandle,
                      FdoDeviceObject,
                      defaultPipe);

    if (DeviceHandle->DeviceAddress != USB_DEFAULT_DEVICE_ADDRESS) {
        USBPORT_FreeUsbAddress(FdoDeviceObject, DeviceHandle->DeviceAddress);
    }

    //
    // free any Tt handles associated with this device handle
    //
    while (!IsListEmpty(&DeviceHandle->TtList)) { 
    
        PTRANSACTION_TRANSLATOR tt;
        PLIST_ENTRY listEntry;
        KIRQL irql;

        
        listEntry = RemoveHeadList(&DeviceHandle->TtList);
        tt = (PTRANSACTION_TRANSLATOR) CONTAINING_RECORD(
                        listEntry,
                        struct _TRANSACTION_TRANSLATOR, 
                        TtLink);
        ASSERT_TT(tt);            

        KeAcquireSpinLock(&devExt->Fdo.TtEndpointListSpin.sl, &irql);
        SET_FLAG(tt->TtFlags, USBPORT_TTFLAG_REMOVED);
        
        if (IsListEmpty(&tt->EndpointList)) {
            ULONG i, bandwidth;
            
            USBPORT_UpdateAllocatedBwTt(tt);
            // alloc new            
            bandwidth = tt->MaxAllocedBw;
            for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
                devExt->Fdo.BandwidthTable[i] += bandwidth;
            }
            
            FREE_POOL(FdoDeviceObject, tt);
        }

        KeReleaseSpinLock(&devExt->Fdo.TtEndpointListSpin.sl, irql);
    }
    UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);  

    if (!IS_ROOT_HUB(DeviceHandle)) {
        ASSERT_DEVICE_HANDLE(DeviceHandle);
        UNSIG(DeviceHandle);
        FREE_POOL(FdoDeviceObject, DeviceHandle);
    }        

    return ntStatus;
}


NTSTATUS
USBPORT_InitializeDevice(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Called for each device on the USB bus that needs to be initialized.
    This routine allocates an address and assigns it to the device.

    NOTE: on entry the the device descriptor in DeviceHandle is expected to
        contain at least the first 8 bytes of the device descriptor, this
        information is used to open the default pipe.

    On Error the DeviceHandle structure is freed.

Arguments:

    DeviceHandle - ptr to device data structure created by class driver
                from a call to USBPORT_CreateDevice.

    DeviceObject - USBPORT device object for the USB bus this device is on.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PUSBD_PIPE_HANDLE_I defaultPipe;
    USHORT address;
    PDEVICE_EXTENSION devExt;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
    
    PAGED_CODE();
    
    USBPORT_KdPrint((2, "'InitializeDevice\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    USBPORT_ASSERT(DeviceHandle != NULL);

    LOCK_DEVICE(DeviceHandle, FdoDeviceObject);

    defaultPipe = &DeviceHandle->DefaultPipe;

    // assume success
    ntStatus = STATUS_SUCCESS;
    
    //
    // Assign Address to the device
    //

    address = USBPORT_AllocateUsbAddress(FdoDeviceObject);

    USBPORT_KdPrint((2, "'SetAddress, assigning 0x%x address\n", address));
    LOGENTRY(NULL,
        FdoDeviceObject, LOG_MISC, 'ADRa', DeviceHandle, 0, address);
   
    USBPORT_ASSERT(DeviceHandle->DeviceAddress == USB_DEFAULT_DEVICE_ADDRESS);

    // setup packet for set_address        
    USBPORT_INIT_SETUP_PACKET(setupPacket,
            USB_REQUEST_SET_ADDRESS, // bRequest
            BMREQUEST_HOST_TO_DEVICE, // Dir
            BMREQUEST_TO_DEVICE, // Recipient
            BMREQUEST_STANDARD, // Type
            address, // wValue
            0, // wIndex
            0); // wLength
      

    ntStatus = USBPORT_SendCommand(DeviceHandle,
                                   FdoDeviceObject,
                                   &setupPacket,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL);

    DeviceHandle->DeviceAddress = address;        

    if (NT_SUCCESS(ntStatus)) {

        USB_MINIPORT_STATUS mpStatus;
        
        //
        // done with addressing process...
        //
        // poke the endpoint zero to the new address and
        // the true max packet size for the default control.
        // endpoint.
        //
        defaultPipe->Endpoint->Parameters.MaxPacketSize = 
            DeviceHandle->DeviceDescriptor.bMaxPacketSize0;
        defaultPipe->Endpoint->Parameters.DeviceAddress = address;
        
        //MP_PokeEndpoint(devExt, defaultPipe->Endpoint, mpStatus);
        //ntStatus = MPSTATUS_TO_NTSTATUS(mpStatus);        
        ntStatus = USBPORT_PokeEndpoint(FdoDeviceObject, defaultPipe->Endpoint);
    }
    
    if (NT_SUCCESS(ntStatus)) {

        ULONG bytesReturned;
        USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
        
        // 10ms delay to allow devices to respond after
        // the setaddress command
        USBPORT_Wait(FdoDeviceObject, 10);

        //
        // Fetch the device descriptor again, this time
        // get the whole thing.
        //

        // setup packet for get device descriptor
        USBPORT_INIT_SETUP_PACKET(setupPacket,
            USB_REQUEST_GET_DESCRIPTOR, // bRequest
            BMREQUEST_DEVICE_TO_HOST, // Dir
            BMREQUEST_TO_DEVICE, // Recipient
            BMREQUEST_STANDARD, // Type
            USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(USB_DEVICE_DESCRIPTOR_TYPE, 0), // wValue
            0, // wIndex
            sizeof(DeviceHandle->DeviceDescriptor)); // wLength
      
        ntStatus =
            USBPORT_SendCommand(DeviceHandle,
                            FdoDeviceObject,
                            &setupPacket,
                            (PUCHAR) &DeviceHandle->DeviceDescriptor,
                            sizeof(DeviceHandle->DeviceDescriptor),
                            &bytesReturned,
                            NULL);
                            
        if (NT_SUCCESS(ntStatus) && 
            (bytesReturned != sizeof(USB_DEVICE_DESCRIPTOR)) ||
            (DeviceHandle->DeviceDescriptor.bLength < sizeof(USB_DEVICE_DESCRIPTOR)) ||
            (DeviceHandle->DeviceDescriptor.bDescriptorType != USB_DEVICE_DESCRIPTOR_TYPE) ||
            ((DeviceHandle->DeviceDescriptor.bMaxPacketSize0 != 0x08) &&
             (DeviceHandle->DeviceDescriptor.bMaxPacketSize0 != 0x10) &&
             (DeviceHandle->DeviceDescriptor.bMaxPacketSize0 != 0x20) &&
             (DeviceHandle->DeviceDescriptor.bMaxPacketSize0 != 0x40))) {
            // print a big debug message
            USBPORT_KdPrint((0, "'InitializeDevice failed enumeration\n"));

            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }
    }


    if (NT_SUCCESS(ntStatus)) {

        if (DeviceHandle->DeviceSpeed == HighSpeed && 
            DeviceHandle->DeviceDescriptor.bDeviceClass == 
                        USB_DEVICE_CLASS_HUB) {
            // note that this is a hs hub, these require special 
            // handling because of the TTs
            SET_FLAG(DeviceHandle->DeviceFlags, USBPORT_DEVICEFLAG_HSHUB);
        }
    
        UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);

    } else {

        //
        // something went wrong, if we assigned any resources to
        // the default pipe then we free them before we get out.
        //

        // we need to signal to the parent hub that this
        // port is to be be disabled we will do this by
        // returning an error.

        // if we got here then we know the default 
        // endpoint is open

        DEBUG_BREAK();
        
        USBPORT_ClosePipe(DeviceHandle,
                          FdoDeviceObject,
                          defaultPipe);

        if (DeviceHandle->DeviceAddress != USB_DEFAULT_DEVICE_ADDRESS) {
            USBPORT_FreeUsbAddress(FdoDeviceObject, DeviceHandle->DeviceAddress);
        }

        UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);

        // this device handle is no longer valid
        USBPORT_RemoveDeviceHandle(FdoDeviceObject, DeviceHandle);

        ASSERT_DEVICE_HANDLE(DeviceHandle);
        UNSIG(DeviceHandle);
        FREE_POOL(FdoDeviceObject, DeviceHandle);
    }

    LOGENTRY(NULL, 
        FdoDeviceObject, LOG_MISC, 'iniD', DeviceHandle, 0, ntStatus);
    CATC_TRAP_ERROR(FdoDeviceObject, ntStatus);
    
    USBPORT_ENUMLOG(FdoDeviceObject, 'idev', ntStatus, 0);
    
    return ntStatus;
}


NTSTATUS
USBPORT_GetUsbDescriptor(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    UCHAR DescriptorType,
    PUCHAR DescriptorBuffer,
    PULONG DescriptorBufferLength
    )
/*++

Routine Description:

Arguments:

    DeviceHandle - ptr to device data structure created by class driver
                from a call to USBPORT_CreateDevice.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PUSBD_PIPE_HANDLE_I defaultPipe;
    PDEVICE_EXTENSION devExt;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;

    USBPORT_INIT_SETUP_PACKET(setupPacket,
        USB_REQUEST_GET_DESCRIPTOR, // bRequest
        BMREQUEST_DEVICE_TO_HOST, // Dir
        BMREQUEST_TO_DEVICE, // Recipient
        BMREQUEST_STANDARD, // Type
        USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(DescriptorType, 0), // wValue
        0, // wIndex
        *DescriptorBufferLength); // wLength
        

    ntStatus =
        USBPORT_SendCommand(DeviceHandle,
                        FdoDeviceObject,
                        &setupPacket,
                        DescriptorBuffer,
                        *DescriptorBufferLength,
                        DescriptorBufferLength,
                        NULL);

                    
    return ntStatus;
}    


BOOLEAN
USBPORT_DeviceHasQueuedTransfers(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

    Returns TRUE device has queued transfers
    
Arguments:

Return Value:

    True if device has transfers queued transfers

--*/
{
    PDEVICE_EXTENSION devExt;
    BOOLEAN hasTransfers = FALSE;
    PLIST_ENTRY listEntry;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_DEVICE_HANDLE(DeviceHandle);

    listEntry = &DeviceHandle->PipeHandleList;
    
    if (!IsListEmpty(listEntry)) {
        listEntry = DeviceHandle->PipeHandleList.Flink;
    }

    while (listEntry != &DeviceHandle->PipeHandleList) {

        PUSBD_PIPE_HANDLE_I nextHandle;
            
        nextHandle = (PUSBD_PIPE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_PIPE_HANDLE_I, 
                    ListEntry);
                    
        ASSERT_PIPE_HANDLE(nextHandle);
                                    
        listEntry = nextHandle->ListEntry.Flink;

        if (!TEST_FLAG(nextHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW) &&
            USBPORT_EndpointHasQueuedTransfers(FdoDeviceObject,
                                               nextHandle->Endpoint)) {
            hasTransfers = TRUE;
            break;
        }                                           
    }           
    
    return hasTransfers;
}


VOID
USBPORT_AbortAllTransfers(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

    abort all pending transfers associated with a device handle.

    This function is synchronous -- it is called after the device 
    handle is removed from our tables so no new transfers can be 
    posted.

    The idea here is to complete any transfers that may still be
    pending when the device is removed in case the client driver
    neglected to.

    On entry to this function the device is locked.

Arguments:

    DeviceHandle - ptr to device data structure created by class driver
                in USBPORT_CreateDevice.

    FdoDeviceObject - USBPORT device object for the USB bus this device is on.

Return Value:

    NT status code.

--*/
{
    PLIST_ENTRY listEntry;
    
    ASSERT_DEVICE_HANDLE(DeviceHandle);

    listEntry = &DeviceHandle->PipeHandleList;
    
    if (!IsListEmpty(listEntry)) {
        listEntry = DeviceHandle->PipeHandleList.Flink;
    }

    while (listEntry != &DeviceHandle->PipeHandleList) {

        PUSBD_PIPE_HANDLE_I nextHandle;
            
        nextHandle = (PUSBD_PIPE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_PIPE_HANDLE_I, 
                    ListEntry);
                    
        ASSERT_PIPE_HANDLE(nextHandle);
                                    
        listEntry = nextHandle->ListEntry.Flink;

        if (!TEST_FLAG(nextHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {
            SET_FLAG(nextHandle->Endpoint->Flags, EPFLAG_DEVICE_GONE);
            USBPORT_AbortEndpoint(FdoDeviceObject,
                                  nextHandle->Endpoint,
                                  NULL);
            USBPORT_FlushMapTransferList(FdoDeviceObject);                                  
        }                                  
    }                      

    // This gaurantees that no transfers are in our lists or 
    // in the miniport when we remove the device.  
    
    // NOTE: If a driver passed a remove with transfers still pending
    // we still may crash but this should happen in the offending 
    // driver.

    // NOTE 2: The whistler hub driver will remove the device early 
    // (on connect change) so this code will be hit legit-ly in 
    // this case.
    
    // now wait for queues to empty

    while (USBPORT_DeviceHasQueuedTransfers(FdoDeviceObject, DeviceHandle)) {
        // wait, then check again
        USBPORT_Wait(FdoDeviceObject, 100);
    }
    
}   


NTSTATUS
USBPORT_CloneDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE OldDeviceHandle,
    PUSBD_DEVICE_HANDLE NewDeviceHandle
    )
/*++

Routine Description:

    Service exported for use by the hub driver




Arguments:

    NewDeviceHandle - ptr to device data structure created by class driver
                in USBPORT_CreateDevice.

    OldDeviceHandle - ptr to device data structure created by class driver
                in USBPORT_CreateDevice.

    FdoDeviceObject - USBPORT device object for the USB bus this device is on.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    USBD_STATUS usbdStatus;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    
    // assume success
    ntStatus = STATUS_SUCCESS;

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Cln>', 
        OldDeviceHandle, NewDeviceHandle, 0);

    USBPORT_KdPrint((1,"'Cloning Device\n"));
    DEBUG_BREAK();
    LOCK_DEVICE(NewDeviceHandle, FdoDeviceObject);

    // make sure we have two valid device handles
    
    if (!USBPORT_ValidateDeviceHandle(FdoDeviceObject,
                                      OldDeviceHandle,
                                      FALSE)) {
        // this is most likely a bug in the hub 
        // driver
        DEBUG_BREAK();
        
        UNLOCK_DEVICE(NewDeviceHandle, FdoDeviceObject); 
        // chances are that the device handle is bad becuse the
        // device is gone.
        return STATUS_DEVICE_NOT_CONNECTED;
    }   

    if (!USBPORT_ValidateDeviceHandle(FdoDeviceObject,
                                      NewDeviceHandle,
                                      FALSE)) {
        // this is most likely a bug in the hub 
        // driver
        DEBUG_BREAK();
        
        UNLOCK_DEVICE(NewDeviceHandle, FdoDeviceObject);    
        // chances are that the device handle is bad becuse the
        // device is gone.
        return STATUS_DEVICE_NOT_CONNECTED;
    }   
    
    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Cln+', 
        OldDeviceHandle, NewDeviceHandle, 0);


    // There are two cases where this API is called:

    // case 1 - the device driver has requested a reset of the device.
    // In this event the device has returned to the unconfigured state 
    // and has been re-addressed with the 'NewDeviceHandle'
    //
    // case 2 - the controller has been shut off -- thanks to power
    // management.  In this case the device is also in the unconfigured
    // state and associated with the 'NewDeviceHandle' device handle

    // make sure the 'new device' is unconfigured
    USBPORT_ASSERT(NewDeviceHandle->ConfigurationHandle == NULL);

#ifdef XPSE
    // before performing the clone operation remove the device handle
    // and wait for any pending URBs to drain
    USBPORT_RemoveDeviceHandle(FdoDeviceObject,
                               OldDeviceHandle);
                               
    USBPORT_AbortAllTransfers(FdoDeviceObject,
                              OldDeviceHandle);        

      // wait for any refs from non-transfer URBs to drain
    while (InterlockedDecrement(&OldDeviceHandle->PendingUrbs) >= 0) {
        LOGENTRY(NULL,
          FdoDeviceObject, LOG_PNP, 'dPR2', OldDeviceHandle, 0, 
            OldDeviceHandle->PendingUrbs);
   
        InterlockedIncrement(&OldDeviceHandle->PendingUrbs);
        USBPORT_Wait(FdoDeviceObject, 100);    
    }      
#endif    

    // make sure we are dealing with the same device
    if (RtlCompareMemory(&NewDeviceHandle->DeviceDescriptor,
                         &OldDeviceHandle->DeviceDescriptor,
                         sizeof(OldDeviceHandle->DeviceDescriptor)) !=
                         sizeof(OldDeviceHandle->DeviceDescriptor)) {

        ntStatus = STATUS_UNSUCCESSFUL;
        goto USBPORT_CloneDevice_FreeOldDevice;
    }

    // clone the config
    NewDeviceHandle->ConfigurationHandle = 
        OldDeviceHandle->ConfigurationHandle;
        
    if (OldDeviceHandle->ConfigurationHandle != NULL) {

        // set the device to the previous configuration,        
        // Send the 'set configuration' command.

        USBPORT_INIT_SETUP_PACKET(setupPacket,
                USB_REQUEST_SET_CONFIGURATION, // bRequest
                BMREQUEST_HOST_TO_DEVICE, // Dir
                BMREQUEST_TO_DEVICE, // Recipient
                BMREQUEST_STANDARD, // Type
                NewDeviceHandle->ConfigurationHandle->\
                    ConfigurationDescriptor->bConfigurationValue, // wValue
                0, // wIndex
                0); // wLength
      

        USBPORT_SendCommand(NewDeviceHandle,
                            FdoDeviceObject,
                            &setupPacket,
                            NULL,
                            0,
                            NULL,
                            &usbdStatus);

        USBPORT_KdPrint((2,"' SendCommand, SetConfiguration returned 0x%x\n", usbdStatus));

        if (USBD_ERROR(usbdStatus)) {
        
            USBPORT_KdPrint((1, "failed to 'set' the configuration on a clone\n"));

            //
            // the set_config failed, this can happen if the device has been 
            // removed or if the device has lost its brains.
            // We continue with the cloning process for the endpoints so they 
            // will be properly freed when the 'new' device handle is 
            // eventually removed. 
            // 
            
            ntStatus = SET_USBD_ERROR(NULL, usbdStatus); 

        }
    }

    // clone any alternate interface settings, since we restore the pipes to 
    // the state at the time of hibernate they may be associated with 
    // particular alternate interfaces
    
    // walk the interface chain
    if (OldDeviceHandle->ConfigurationHandle != NULL && 
        NT_SUCCESS(ntStatus)) {
        
        PUSBD_CONFIG_HANDLE cfgHandle;
        PLIST_ENTRY listEntry;
        PUSBD_INTERFACE_HANDLE_I iHandle;

        cfgHandle = NewDeviceHandle->ConfigurationHandle;
        GET_HEAD_LIST(cfgHandle->InterfaceHandleList, listEntry);

        while (listEntry &&
               listEntry != &cfgHandle->InterfaceHandleList) {

            // extract the handle from this entry
            iHandle = (PUSBD_INTERFACE_HANDLE_I) CONTAINING_RECORD(
                        listEntry,
                        struct _USBD_INTERFACE_HANDLE_I,
                        InterfaceLink);

            ASSERT_INTERFACE(iHandle);

            // see if we currently have an alt setting selected
            if (iHandle->HasAlternateSettings) {

                NTSTATUS status; 
                //
                // If we have alternate settings we need
                // to send the set interface command.
                //

                USBPORT_INIT_SETUP_PACKET(setupPacket,
                    USB_REQUEST_SET_INTERFACE, // bRequest
                    BMREQUEST_HOST_TO_DEVICE, // Dir
                    BMREQUEST_TO_INTERFACE, // Recipient
                    BMREQUEST_STANDARD, // Type
                    iHandle->InterfaceDescriptor.bAlternateSetting, // wValue
                    iHandle->InterfaceDescriptor.bInterfaceNumber, // wIndex
                    0); // wLength
          
                status = USBPORT_SendCommand(NewDeviceHandle,
                                             FdoDeviceObject,
                                             &setupPacket,
                                             NULL,
                                             0,
                                             NULL,
                                             &usbdStatus);

                LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'sIF2', 
                    0,
                    iHandle->InterfaceDescriptor.bAlternateSetting,
                    iHandle->InterfaceDescriptor.bInterfaceNumber);                 
                
            }
          
            listEntry = iHandle->InterfaceLink.Flink;
        }
    }

    // clone the TT and TT related data
    if (TEST_FLAG(NewDeviceHandle->DeviceFlags, USBPORT_DEVICEFLAG_HSHUB)) {

        // remove the TT entries from the old handle and add them
        // to the new handle

        while (!IsListEmpty(&OldDeviceHandle->TtList)) {
            PTRANSACTION_TRANSLATOR tt;
            PLIST_ENTRY listEntry;
            
            listEntry = RemoveTailList(&OldDeviceHandle->TtList);
            USBPORT_ASSERT(listEntry != NULL);
            
            tt = (PTRANSACTION_TRANSLATOR) CONTAINING_RECORD(
                        listEntry,
                        struct _TRANSACTION_TRANSLATOR, 
                        TtLink);
            ASSERT_TT(tt);                        

            tt->DeviceAddress = NewDeviceHandle->DeviceAddress;
            InsertHeadList(&NewDeviceHandle->TtList, &tt->TtLink);
        }  

        NewDeviceHandle->TtCount = OldDeviceHandle->TtCount;
    }
    
    // copy the pipe handle list, for each pipe we  will need to re-open
    // the endpoint or re-init the endpoint.
    //
    // if the device did not loose its brains then all we need to do 
    // is update the host controllers idea of what the endpoint address is.
    // this has the added advantage of allowing a reset even when transfers 
    // are queued to the HW although we don't allow that.
    
    while (!IsListEmpty(&OldDeviceHandle->PipeHandleList)) {
    
        PHCD_ENDPOINT endpoint;
        PLIST_ENTRY listEntry = OldDeviceHandle->PipeHandleList.Flink;
        PUSBD_PIPE_HANDLE_I pipeHandle;
        PTRANSACTION_TRANSLATOR transactionTranslator = NULL;

        // see if we are dealing with a TT
        if (NewDeviceHandle->Tt != NULL) {
            transactionTranslator = NewDeviceHandle->Tt;
            ASSERT_TT(transactionTranslator);
        } 

        pipeHandle = (PUSBD_PIPE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_PIPE_HANDLE_I, 
                    ListEntry);

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'CLNE', pipeHandle, 0, 0);                     
        ASSERT_PIPE_HANDLE(pipeHandle);
 
        USBPORT_RemovePipeHandle(OldDeviceHandle,
                                 pipeHandle);

        // we need to special case the default pipe because it 
        // is embedded in the DeviceHandle.
        // 
        // Since NewDeviceHandle is a newly created device 
        // the endpoint associated with it is valid, so is 
        // the one for the 'OldDeviceHandle'

        if (pipeHandle != &OldDeviceHandle->DefaultPipe) {
        
            USB_MINIPORT_STATUS mpStatus;
                
            USBPORT_AddPipeHandle(NewDeviceHandle, pipeHandle);     

            // skip re-init for sero bw endpoints becuase we have 
            // no endpoint structure -- these are ghost endpoints
            if (!TEST_FLAG(pipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {
            
                endpoint = pipeHandle->Endpoint;
                ASSERT_ENDPOINT(endpoint);

                endpoint->DeviceHandle = NewDeviceHandle;
                
                endpoint->Parameters.DeviceAddress = 
                        NewDeviceHandle->DeviceAddress;

                if (TEST_FLAG(endpoint->Flags, EPFLAG_NUKED)) {
                    // re-open
                    ENDPOINT_REQUIREMENTS requirements;
                    
                    if (transactionTranslator != NULL) {
                        endpoint->Parameters.TtDeviceAddress = 
                            transactionTranslator->DeviceAddress;
                    }
                    
                    // call open request to minport, all the endpoint 
                    // structures are still valid we just need to re-add
                    // it to the schedule.

                    RtlZeroMemory(&endpoint->MiniportEndpointData[0],
                                  REGISTRATION_PACKET(devExt).EndpointDataSize);
                    RtlZeroMemory(endpoint->Parameters.CommonBufferVa,
                                  endpoint->Parameters.CommonBufferBytes);

                    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'clRO', pipeHandle, 
                        endpoint, 0);
                        
                    // query requirements (although they should not change)
                    // just in case the miniport does some initialization here
                    MP_QueryEndpointRequirements(devExt, 
                        endpoint, &requirements);
                    
                    MP_OpenEndpoint(devExt, endpoint, mpStatus);
                    // in this UNIQUE situation this API is not allowed 
                    // (and should not) fail
                    USBPORT_ASSERT(mpStatus == USBMP_STATUS_SUCCESS);

                    CLEAR_FLAG(endpoint->Flags, EPFLAG_NUKED);

                    // we need to sync the endpoint state with 
                    // the miniport, when first opened the miniport
                    // puts the endpoint in status HALT.
                    
                    ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'LeK0');   
                    // initialize endpoint state machine
                    //if (endpoint->CurrentStatus == ENDPOINT_STATUS_RUN) {
                    //    MP_SetEndpointStatus(devExt, endpoint, ENDPOINT_STATUS_RUN);
                    //}

                    if (endpoint->CurrentState == ENDPOINT_ACTIVE) {
                        MP_SetEndpointState(devExt, endpoint, ENDPOINT_ACTIVE);
                    }
                    RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'UeK0'); 
                    
                                    
                } else {
                    USB_MINIPORT_STATUS mpStatus;

                    // if this device has an associated TT then
                    // we will need to do a little more here 
                    if (transactionTranslator != NULL) {
                        endpoint->Parameters.TtDeviceAddress = 
                            transactionTranslator->DeviceAddress;
                    }
                    
                    // this endpoint is already in the schedule,
                    // poke-it with the new address.
                        
                    MP_PokeEndpoint(devExt, endpoint, mpStatus);

                    // in this UNIQUE situation this API is not allowed 
                    // (and should not) fail
                    USBPORT_ASSERT(mpStatus == USBMP_STATUS_SUCCESS);

                    // The endpoint on the device should have had its data
                    // toggle reset back to Data0 so reset the data toggle
                    // on the host endpoint to match.
                    //
                    MP_SetEndpointDataToggle(devExt, endpoint, 0);

                    // clear halt status
                    MP_SetEndpointStatus(devExt, endpoint, ENDPOINT_STATUS_RUN);

                }    
            }                
        }
    }

    // the pipes and config have been cloned, the final step is to free the 
    // 'OldDeviceData' ie the old handle.

    // put the old 'default' pipe back on the list before 
    // we close it
    USBPORT_AddPipeHandle(OldDeviceHandle, 
                          &OldDeviceHandle->DefaultPipe);     

USBPORT_CloneDevice_FreeOldDevice:

#ifndef XPSE
    USBPORT_RemoveDeviceHandle(FdoDeviceObject,
                               OldDeviceHandle);

    USBPORT_AbortAllTransfers(FdoDeviceObject,
                              OldDeviceHandle);
#endif
    // we should aways have a default pipe, this will free 
    // the endpoint
    USBPORT_ClosePipe(OldDeviceHandle,
                      FdoDeviceObject,
                      &OldDeviceHandle->DefaultPipe);

    if (OldDeviceHandle->DeviceAddress != USB_DEFAULT_DEVICE_ADDRESS) {
        USBPORT_FreeUsbAddress(FdoDeviceObject, OldDeviceHandle->DeviceAddress);
    }                          

    UNLOCK_DEVICE(NewDeviceHandle, FdoDeviceObject);

    FREE_POOL(FdoDeviceObject, OldDeviceHandle);
            
    return ntStatus;
}


PTRANSACTION_TRANSLATOR
USBPORT_GetTt(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    PUSHORT PortNumber
    )
/*++

Routine Description:

    Walk upstream until we find the first high speed device

Arguments:

Return Value:

    ttDeviceAddress

--*/
{
    PDEVICE_EXTENSION devExt;
    PTRANSACTION_TRANSLATOR tt = NULL;
    PLIST_ENTRY listEntry;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    do {
        if (HubDeviceHandle->DeviceSpeed == UsbHighSpeed) {

            if (HubDeviceHandle->TtCount > 1) {

                GET_HEAD_LIST(HubDeviceHandle->TtList, listEntry);

                while (listEntry != NULL &&
                       listEntry != &HubDeviceHandle->TtList) {     

                    tt = (PTRANSACTION_TRANSLATOR) CONTAINING_RECORD(
                            listEntry,
                            struct _TRANSACTION_TRANSLATOR, 
                            TtLink);
                    ASSERT_TT(tt);                        

                    if (tt->Port == *PortNumber) {
                        break;
                    }

                    listEntry = tt->TtLink.Flink;
                    tt = NULL;                    
                }                
                
            } else {
                // single TT, use the one tt structure regardless of port
                GET_HEAD_LIST(HubDeviceHandle->TtList, listEntry);
                tt = (PTRANSACTION_TRANSLATOR) CONTAINING_RECORD(
                        listEntry,
                        struct _TRANSACTION_TRANSLATOR, 
                        TtLink);
                ASSERT_TT(tt);  
            } 

            // we should have selected a tt                
            USBPORT_ASSERT(tt != NULL);
            break;
        } else {
            *PortNumber = HubDeviceHandle->TtPortNumber;
        }
        HubDeviceHandle = HubDeviceHandle->HubDeviceHandle;
        ASSERT_DEVICE_HANDLE(HubDeviceHandle);
    } while (HubDeviceHandle != NULL);

    USBPORT_KdPrint((1, "TtPortNumber %d\n",
        *PortNumber));

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gTTa', HubDeviceHandle,
        *PortNumber, tt);
    
    return tt;
}


NTSTATUS
USBPORT_InitializeTT(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    USHORT Port
    )
/*++

Routine Description:

    Initialze the TT table used to track this hub

Arguments:

Return Value:

    nt status code

--*/
{
    PDEVICE_EXTENSION devExt;
    PTRANSACTION_TRANSLATOR transactionTranslator;
    USHORT siz;
    extern ULONG USB2LIB_TtContextSize;
    NTSTATUS ntStatus;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(USBPORT_IS_USB20(devExt));

    siz = sizeof(TRANSACTION_TRANSLATOR) + 
          USB2LIB_TtContextSize;
    
    ALLOC_POOL_Z(transactionTranslator, NonPagedPool, siz);

    if (transactionTranslator != NULL) {
        ULONG i;
        ULONG bandwidth;
        
        transactionTranslator->Sig = SIG_TT;
        transactionTranslator->DeviceAddress = 
            HubDeviceHandle->DeviceAddress;
        transactionTranslator->Port = Port;            
        transactionTranslator->PdoDeviceObject = 
            devExt->Fdo.RootHubPdo;      
        // each translator is a virtual 1.1 bus            
        transactionTranslator->TotalBusBandwidth = 
            USB_11_BUS_BANDWIDTH;     
        InitializeListHead(&transactionTranslator->EndpointList);

        for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
            transactionTranslator->BandwidthTable[i] =
                transactionTranslator->TotalBusBandwidth - 
                transactionTranslator->TotalBusBandwidth/10;
        }

        // reserve the basic 10% from the parent bus
        USBPORT_UpdateAllocatedBwTt(transactionTranslator);
        // alloc new            
        bandwidth = transactionTranslator->MaxAllocedBw;
        for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
            devExt->Fdo.BandwidthTable[i] -= bandwidth;
        }
        
        USB2LIB_InitTt(devExt->Fdo.Usb2LibHcContext,
                       &transactionTranslator->Usb2LibTtContext);
        
        InsertTailList(&HubDeviceHandle->TtList,
                       &transactionTranslator->TtLink);
                       
        ntStatus = STATUS_SUCCESS;            
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\ioctl.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Port driver for USB host controllers

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"
#ifdef DRM_SUPPORT
#include <ksdrmhlp.h>
#endif

#include "usbpriv.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_FdoDeviceControlIrp)
#pragma alloc_text(PAGE, USBPORT_PdoDeviceControlIrp)
#pragma alloc_text(PAGE, USBPORT_LegacyGetUnicodeName)
#pragma alloc_text(PAGE, USBPORT_GetSymbolicName)
#ifdef DRM_SUPPORT
#pragma alloc_text(PAGE, USBPORT_PdoSetContentId)
#endif
#endif

// non paged functions
// USBPORT_FdoInternalDeviceControlIrp
// USBPORT_PdoInternalDeviceControlIrp
// USBPORT_UserSendOnePacket

BOOLEAN
USBPORT_CheckLength(
    PUSBUSER_REQUEST_HEADER Header,
    ULONG ParameterLength
    )
/*++

Routine Description:

    Checks Length of user supplied buffer based on api

Arguments:

Return Value:

    FALSE if buffer too small

--*/
{
    ULONG length;
    BOOLEAN retCode = TRUE;

    length = sizeof(*Header) + ParameterLength;

    Header->ActualBufferLength = length;

    if (length > Header->RequestBufferLength) {
        //TEST_TRAP();
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;
        retCode = FALSE;
    }

    return retCode;
}


NTSTATUS
USBPORT_FdoDeviceControlIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Disptach routine for DEVICE_CONTROL Irps sent to the FDO for the HC.

    NOTE: These are user mode requests

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION devExt;
    ULONG information = 0;

    USBPORT_KdPrint((2, "'IRP_MJ_DEVICE_CONTROL\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_USB_DIAGNOSTIC_MODE_ON:
        USBPORT_KdPrint((2, "'IOCTL_USB_DIAGNOSTIC_MODE_ON\n"));
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_DIAG_MODE);
        ntStatus = STATUS_SUCCESS;
        break;

    case IOCTL_USB_DIAGNOSTIC_MODE_OFF:
        USBPORT_KdPrint((2, "'IOCTL_USB_DIAGNOSTIC_MODE_OFF\n"));
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_DIAG_MODE);
        ntStatus = STATUS_SUCCESS;;
        break;

    case IOCTL_GET_HCD_DRIVERKEY_NAME:

        USBPORT_KdPrint((2, "'IOCTL_GET_HCD_DRIVERKEY_NAME\n"));
        ntStatus = USBPORT_LegacyGetUnicodeName(FdoDeviceObject,
                                                Irp,
                                                &information);
        break;

    case IOCTL_USB_GET_ROOT_HUB_NAME:

        USBPORT_KdPrint((2, "'IOCTL_USB_GET_ROOT_HUB_NAME\n"));
        ntStatus = USBPORT_LegacyGetUnicodeName(FdoDeviceObject,
                                                Irp,
                                                &information);
        break;

    case IOCTL_USB_USER_REQUEST:

        USBPORT_KdPrint((2, "'IOCTL_USB_USER_REQUEST\n"));
        ntStatus = USBPORT_UsbFdoUserIoctl(FdoDeviceObject,
                                           Irp,
                                           &information);
        break;

// old IOCTLS no longer supported
//    case IOCTL_USB_HCD_GET_STATS_2:
//    case IOCTL_USB_HCD_GET_STATS_1:

    default:
        // bugbug pass on to PDO or complete with error?

        USBPORT_KdPrint((2, "'INVALID DEVICE CONTROL\n"));
        DEBUG_BREAK();
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    } // switch (irpStack->Parameters.DeviceIoControl.IoControlCode)

    USBPORT_CompleteIrp(FdoDeviceObject, Irp, ntStatus, information);
    //
    // DO NOT TOUCH THE IRP FROM THIS POINT ON
    //

    return ntStatus;
}


#ifdef DRM_SUPPORT

NTSTATUS
USBPORT_PdoSetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
)
 /* ++
  *
  * Description:
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    ULONG ContentId;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION ioStackLocation;
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION fdoDevExt;
    PUSBPORT_REGISTRATION_PACKET registrationPacket;
    PVOID *pHandlers;
    ULONG numHandlers;

    PAGED_CODE();

    ASSERT(irp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    ioStackLocation = IoGetCurrentIrpStackLocation(irp);
    devExt = ioStackLocation->DeviceObject->DeviceExtension;
    fdoDeviceObject = devExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(fdoDevExt, fdoDeviceObject);
    registrationPacket = &REGISTRATION_PACKET(fdoDevExt);
    pHandlers = (PVOID *)&registrationPacket->MINIPORT_OpenEndpoint;
    numHandlers = (ULONG)((((ULONG_PTR)&registrationPacket->MINIPORT_PassThru -
                    (ULONG_PTR)&registrationPacket->MINIPORT_OpenEndpoint) /
                   sizeof(PVOID)) + 1);

    ContentId = pvData->ContentId;
    // Context = pKsProperty->Context;

    // Since there is a private interface between USBPORT.SYS and the miniports,
    // we give DRM a list of function pointers in the miniport for validation,
    // in place of a device object, since the miniport does not handle IRP
    // requests.

    // If at some future time a miniport is ever written that acts as a bridge
    // to another bus or device stack, this may have to be modified such that
    // DRM is notified of that driver that the data is forwarded to.

    ntStatus = pKsProperty->DrmAddContentHandlers(ContentId, pHandlers, numHandlers);

    return ntStatus;
}

#endif


NTSTATUS
USBPORT_PdoDeviceControlIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for DEVICE_CONTROL Irps sent to the PDO for the Root Hub.

    NOTE: These are user mode requests

Arguments:

    DeviceObject - Pdo for USB Root Hub

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION rhDevExt;
    ULONG information = 0;

    USBPORT_KdPrint((2, "'IRP_MJ_DEVICE_CONTROL\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

#ifdef DRM_SUPPORT

    case IOCTL_KS_PROPERTY:
        USBPORT_KdPrint((2, "'IOCTL_KS_PROPERTY\n"));
        ntStatus = KsPropertyHandleDrmSetContentId(Irp, USBPORT_PdoSetContentId);
        break;

#endif

    default:
        USBPORT_KdPrint((2, "'INVALID DEVICE CONTROL\n"));
        DEBUG_BREAK();
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    } // switch (irpStack->Parameters.DeviceIoControl.IoControlCode)

    USBPORT_CompleteIrp(PdoDeviceObject, Irp, ntStatus, information);
    //
    // DO NOT TOUCH THE IRP FROM THIS POINT ON
    //

    return ntStatus;
}


NTSTATUS
USBPORT_FdoInternalDeviceControlIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Disptach routine for INTERNAL_DEVICE_CONTROL Irps sent to
    the FDO for the HC.

    NOTE: These are kernel mode requests

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION devExt;

    USBPORT_KdPrint((2, "'IRP_MJ_DEVICE_CONTROL\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);

    // bugbug pass on to PDO or complete with error?

    USBPORT_KdPrint((2, "'INVALID INTERNAL DEVICE CONTROL\n"));
    DEBUG_BREAK();
    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    USBPORT_CompleteIrp(FdoDeviceObject, Irp, ntStatus, 0);

    //
    // DO NOT TOUCH THE IRP FROM THIS POINT ON
    //

    return ntStatus;
}


NTSTATUS
USBPORT_PdoInternalDeviceControlIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Disptach routine for INTERNAL_DEVICE_CONTROL Irps sent to
    the PDO for the Root Hub.

    NOTE: These are kernel mode requests

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION rhDevExt;

    USBPORT_KdPrint((2, "'INTERNAL_DEVICE_CONTROL\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_INTERNAL_USB_SUBMIT_URB:

        USBPORT_KdPrint((2, "'IOCTL_INTERNAL_USB_SUBMIT_URB\n"));

        {
        PURB urb;
        //
        // all URBs are eventually passed to the root hub PDO
        // this is where we service cleint requests
        //

        // extract the urb;
        urb = irpStack->Parameters.Others.Argument1;

        // call the main urb control function
        ntStatus = USBPORT_ProcessURB(PdoDeviceObject,
                                      rhDevExt->HcFdoDeviceObject,
                                      Irp,
                                      urb);
        }
        goto USBPORT_PdoInternalDeviceControlIrp_Done;
        break;

    case IOCTL_INTERNAL_USB_GET_HUB_COUNT:

        USBPORT_KdPrint((2, "'IOCTL_INTERNAL_USB_GET_HUB_COUNT\n"));

        {
        PULONG count;

        //
        // bump the count and complete the Irp
        //
        count = irpStack->Parameters.Others.Argument1;

        ASSERT(count != NULL);
        (*count)++;
        ntStatus = STATUS_SUCCESS;
        }
        break;

    case IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE:

        {
        PUSBD_DEVICE_HANDLE *deviceHandle;

        deviceHandle = irpStack->Parameters.Others.Argument1;
        *deviceHandle = &rhDevExt->Pdo.RootHubDeviceHandle;

        ntStatus = STATUS_SUCCESS;
        }

        break;

    case IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION:

        ntStatus =
            USBPORT_IdleNotificationRequest(PdoDeviceObject, Irp);

        goto USBPORT_PdoInternalDeviceControlIrp_Done;
        break;

    case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:

        USBPORT_KdPrint((2, "'IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO\n"));

        // this api is called by the hub driver to get the
        // PDO for he root hub.
        // Since the hub may be loaded on a PDO enumerated by
        // another hub it uses this api to get the 'fastest path'
        // to the HCD for URB requests by client drivers.
        {
        PDEVICE_OBJECT *rootHubPdo, *hcdTopOfStackDeviceObject;

        rootHubPdo = irpStack->Parameters.Others.Argument1;
        hcdTopOfStackDeviceObject =
            irpStack->Parameters.Others.Argument2;

        USBPORT_ASSERT(hcdTopOfStackDeviceObject != NULL);
        USBPORT_ASSERT(rootHubPdo != NULL);

        *rootHubPdo = PdoDeviceObject;
        // the original USBD was somewhat screwy in the layout
        // of the HCD device objects in the case of the port
        // driver all requests should go to to the root hub PDO
        *hcdTopOfStackDeviceObject =
             PdoDeviceObject;

        ntStatus = STATUS_SUCCESS;
        }

        break;

#if 0
     case IOCTL_INTERNAL_USB_GET_HUB_NAME:
        TEST_TRAP();
        ntStatus = STATUS_NOT_SUPPORTED;
        break;
#endif
    default:

        USBPORT_KdPrint((2, "'INVALID INTERNAL DEVICE CONTROL %x\n",
            irpStack->Parameters.DeviceIoControl.IoControlCode));
        DEBUG_BREAK();
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // DO NOT TOUCH THE IRP FROM THIS POINT ON
    //
    USBPORT_CompleteIrp(PdoDeviceObject, Irp, ntStatus, 0);

USBPORT_PdoInternalDeviceControlIrp_Done:

    return ntStatus;
}


NTSTATUS
USBPORT_UsbFdoUserIoctl(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PULONG BytesReturned
    )
/*++

Routine Description:

    The goal here is to have all user mode APIS
    pass thru this routine so that the parameter
    validation is handled in one place.

    We define user APIS supported by the PORT FDO
    thru this single IOCTL.

    The USUSER APIs use the same buffer for input and output,
    hence the InputBufferLength and the OutputbufferLength must
    always be equal.


    We get here if the client sends the IOCTL_USB_USER_REQUEST.
    We only return NTSTATUS failure if the header portion of the
    buffer is invalid.



Arguments:

    DeviceObject - Fdo for USB HC

    BytesRetrned - ptr to bytes to return to caller, initially zero

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PUSBUSER_REQUEST_HEADER header;
    PDEVICE_EXTENSION devExt;
    PUCHAR ioBufferO;
    ULONG inputBufferLength, outputBufferLength, allocLength;
    ULONG ioBufferLength;
    PUCHAR myIoBuffer;
    BOOLEAN alloced;

    USBPORT_KdPrint((2, "'USBPORT_FdoUserIoctl\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL);
    USBPORT_ASSERT(irpStack->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_USB_USER_REQUEST);

    ioBufferO = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // one bug that the driver verifier does not catch is if we trash the
    // iobuffer passed to us.
    //
    // We shadow this buffer to one we allocate, this way DV should catch
    // us if we trash memory.
    // We do this in retail even though this a perf hit since the NT guys
    // tend to favor stability more than perf and this is not a hot-path.
    //
    // If DV is ever modified to do this for us we cann remove this code.
    //

    allocLength = max(inputBufferLength, outputBufferLength);

    if (allocLength) {
        ALLOC_POOL_Z(myIoBuffer, NonPagedPool, allocLength);
    } else {
        myIoBuffer = NULL;
    }

    if (myIoBuffer != NULL) {
        alloced = TRUE;
        RtlCopyMemory(myIoBuffer,
                      ioBufferO,
                      inputBufferLength);
    } else {
        // if alloc fails just fall back to the original
        alloced = FALSE;
        myIoBuffer = ioBufferO;
    }

    ioBufferLength = inputBufferLength;

    USBPORT_KdPrint((2,  "'ioBuffer = %x - %x\n", ioBufferO, myIoBuffer));
    USBPORT_KdPrint((2,  "'inputBufferLength %d\n", inputBufferLength));
    USBPORT_KdPrint((2,  "'outputBufferLength %d\n", outputBufferLength));
    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'uIOC', ioBufferO, inputBufferLength,
            outputBufferLength);

    // some initial parameter validation

    // bogus buffer lengths
    if (inputBufferLength != outputBufferLength) {

        ntStatus = STATUS_INVALID_PARAMETER;
        goto USBPORT_UsbFdoUserIoctl_Done;
    }

    // must have at least enough for a header
    if (ioBufferLength < sizeof(USBUSER_REQUEST_HEADER)) {

        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto USBPORT_UsbFdoUserIoctl_Done;
    }

    // no _try _except needed here since we are using method buffered and
    // we already validate the length

    //__try {
    //    UCHAR ch;
    //     // check the buffer
    //
    //   ch = *ioBufferO;
    //    ch = *(ioBufferO+sizeof(USBUSER_REQUEST_HEADER));
    //
    //} __except(EXCEPTION_EXECUTE_HANDLER) {

    //   USBPORT_KdPrint((0,"'EXCEPTION USBPORT_UsbFdoUserIoctl\n"));
    //   ntStatus = GetExceptionCode();
    //   TEST_TRAP();
    //   goto USBPORT_UsbFdoUserIoctl_Done;
    // }


    // header buffer is valid, at this point we return
    // STATUS_SUCCESS to the caller and fill in the header
    // with the appropriate error code
    ntStatus = STATUS_SUCCESS;

    // validate the header buffer parameters

    header = (PUSBUSER_REQUEST_HEADER) myIoBuffer;

    // assume success, set return values
    header->UsbUserStatusCode = UsbUserSuccess;
    *BytesReturned =
        header->ActualBufferLength = sizeof(*header);

    // length set in header should be the same
    // as length passed in the ioctl
    if (header->RequestBufferLength != ioBufferLength) {

        header->UsbUserStatusCode =
            UsbUserInvalidHeaderParameter;
        goto USBPORT_UsbFdoUserIoctl_Done;
    }

    // we have a valid header and cleint buffer, attempt to execute
    // the api

    // validate rules for Api codes
    // is this an API that only works when the root hub is disabled?
    {
    ULONG mask;
    mask = (USBUSER_OP_MASK_DEVONLY_API | USBUSER_OP_MASK_HCTEST_API);
    if ((header->UsbUserRequest & mask) &&
        devExt->Fdo.RootHubPdo != NULL) {
        // root hub only api and we have a root hub, make sure it
        // is disabled
        PDEVICE_EXTENSION rhDevExt;

        GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
        ASSERT_PDOEXT(rhDevExt);

        if (!(TEST_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_REMOVED) ||
              SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_DIAG_MODE))) {
            header->UsbUserStatusCode = UsbUserFeatureDisabled;
            ntStatus = STATUS_UNSUCCESSFUL;
            goto USBPORT_UsbFdoUserIoctl_Done;
        }

    }
    }

    switch (header->UsbUserRequest) {
    case USBUSER_OP_SEND_ONE_PACKET:
        if (USBPORT_CheckLength(header, sizeof(PACKET_PARAMETERS))) {
            USBPORT_UserSendOnePacket(FdoDeviceObject, header,
                        (PPACKET_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_OP_RAW_RESET_PORT:
        if (USBPORT_CheckLength(header, sizeof(RAW_RESET_PORT_PARAMETERS))) {
            USBPORT_UserRawResetPort(FdoDeviceObject, header,
                        (PRAW_RESET_PORT_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_SET_ROOTPORT_FEATURE:
        if (USBPORT_CheckLength(header, sizeof(RAW_ROOTPORT_FEATURE))) {
            USBPORT_UserSetRootPortFeature(FdoDeviceObject, header,
                        (PRAW_ROOTPORT_FEATURE) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_CLEAR_ROOTPORT_FEATURE:
        if (USBPORT_CheckLength(header, sizeof(RAW_ROOTPORT_FEATURE))) {
            USBPORT_UserClearRootPortFeature(FdoDeviceObject, header,
                        (PRAW_ROOTPORT_FEATURE) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_GET_ROOTPORT_STATUS:
        if (USBPORT_CheckLength(header, sizeof(RAW_ROOTPORT_PARAMETERS))) {
            USBPORT_GetRootPortStatus(FdoDeviceObject, header,
                        (PRAW_ROOTPORT_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_OP_OPEN_RAW_DEVICE:
        if (USBPORT_CheckLength(header, sizeof(USB_OPEN_RAW_DEVICE_PARAMETERS))) {
            USBPORT_UserOpenRawDevice(FdoDeviceObject, header,
                        (PUSB_OPEN_RAW_DEVICE_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_OP_CLOSE_RAW_DEVICE:
        if (USBPORT_CheckLength(header, sizeof(USB_CLOSE_RAW_DEVICE_PARAMETERS))) {
            USBPORT_UserCloseRawDevice(FdoDeviceObject, header,
                        (PUSB_CLOSE_RAW_DEVICE_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_OP_SEND_RAW_COMMAND:
        if (USBPORT_CheckLength(header, sizeof(USB_SEND_RAW_COMMAND_PARAMETERS))) {
            USBPORT_UserSendRawCommand(FdoDeviceObject, header,
                        (PUSB_SEND_RAW_COMMAND_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_GET_CONTROLLER_INFO_0:
        if (USBPORT_CheckLength(header, sizeof(USB_CONTROLLER_INFO_0))) {
            USBPORT_UserGetControllerInfo_0(FdoDeviceObject, header,
                        (PUSB_CONTROLLER_INFO_0) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_GET_CONTROLLER_DRIVER_KEY:
        if (USBPORT_CheckLength(header, sizeof(USB_UNICODE_NAME))) {
            USBPORT_UserGetControllerKey(FdoDeviceObject, header,
                        (PUSB_UNICODE_NAME) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_GET_ROOTHUB_SYMBOLIC_NAME:
        if (USBPORT_CheckLength(header, sizeof(USB_UNICODE_NAME))) {
            USBPORT_UserGetRootHubName(FdoDeviceObject, header,
                        (PUSB_UNICODE_NAME) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_PASS_THRU:
        if (USBPORT_CheckLength(header, sizeof(USB_PASS_THRU_PARAMETERS))) {
            USBPORT_UserPassThru(FdoDeviceObject, header,
                        (PUSB_PASS_THRU_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_GET_BANDWIDTH_INFORMATION:
        if (USBPORT_CheckLength(header, sizeof(USB_BANDWIDTH_INFO))) {
            USBPORT_UserGetBandwidthInformation(FdoDeviceObject, header,
                        (PUSB_BANDWIDTH_INFO) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_GET_POWER_STATE_MAP:
        if (USBPORT_CheckLength(header, sizeof(USB_POWER_INFO))) {
            USBPORT_UserPowerInformation(FdoDeviceObject, header,
                        (PUSB_POWER_INFO) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_GET_BUS_STATISTICS_0:
        if (USBPORT_CheckLength(header, sizeof(USB_BUS_STATISTICS_0))) {
            USBPORT_UserGetBusStatistics0(FdoDeviceObject, header,
                        (PUSB_BUS_STATISTICS_0) (myIoBuffer+sizeof(*header)));
        }
        break;

//    case USBUSER_GET_BUS_STATISTICS_0_AND_RESET:
//        if (USBPORT_CheckLength(header, sizeof(USB_BUS_STATISTICS_0))) {
//            USBPORT_UserGetBusStatistics0(FdoDeviceObject, header,
//                        (PUSB_BUS_STATISTICS_0) (myIoBuffer+sizeof(*header)),
//                        TRUE);
//        }
//        break;

    case USBUSER_GET_USB_DRIVER_VERSION:
        if (USBPORT_CheckLength(header, sizeof(USB_DRIVER_VERSION_PARAMETERS))) {
            USBPORT_UserGetDriverVersion(FdoDeviceObject, header,
                        (PUSB_DRIVER_VERSION_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    default:

        header->UsbUserStatusCode = UsbUserInvalidRequestCode;
    }

    // this will be at least the size of the header

    if (header->RequestBufferLength > header->ActualBufferLength) {
        // if the packet buffer is larger then just return 'actual length'
        *BytesReturned =
            header->ActualBufferLength;
    } else {
        // packet buffer is smaller -- return the size of the
        // packet buffer passed in
        *BytesReturned = header->RequestBufferLength;
    }

USBPORT_UsbFdoUserIoctl_Done:

    if (alloced) {
        // copy the data no matter what we put in it
        // USBPORT_ASSERT(outputBufferLength == inputBufferLength);
        RtlCopyMemory(ioBufferO,
                      myIoBuffer,
                      outputBufferLength);
        FREE_POOL(FdoDeviceObject, myIoBuffer);
    }

    return ntStatus;
}

VOID
USBPORT_UserSendOnePacket(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PPACKET_PARAMETERS PacketParameters
    )
/*++

Routine Description:

    Execute a single step transaction

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    PUCHAR va, mpData;
    ULONG length, mpDataLength;
    MP_PACKET_PARAMETERS mpPacket;
    USBD_STATUS usbdStatus;
    USB_USER_ERROR_CODE usbUserStatus;

    USBPORT_KdPrint((2, "'USBPORT_UserSendOnePacket\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // limit single packet to 64k
    if (PacketParameters->DataLength > 0x10000) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Tbts', 0, 0,
            PacketParameters->DataLength);
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
        return;
    }

    if (PacketParameters->Timeout >= 21474) {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
        return;
    }

    if (!USBPORT_DCA_Enabled(FdoDeviceObject)) {
        Header->UsbUserStatusCode = UsbUserFeatureDisabled;
        return;
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED)) {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
        return;
    }


    // extra length check is needed since we
    // have embedded data
    // if we get here we know packet parameters are valid
    length = sizeof(*Header) + sizeof(PACKET_PARAMETERS) - 4 +
                PacketParameters->DataLength;

    if (length > Header->RequestBufferLength) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Tsma', length, 0,
            Header->RequestBufferLength);
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;
        return;
    }

    Header->ActualBufferLength = length;

    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'ssPK', &mpPacket, 0,
        PacketParameters);

    // dump the PacketParameters
    USBPORT_KdPrint((1, "'DeviceAddress %d\n", PacketParameters->DeviceAddress));
    USBPORT_KdPrint((1, "'EndpointAddress %d\n", PacketParameters->EndpointAddress));
    USBPORT_KdPrint((1, "'MaximumPacketSize %d\n", PacketParameters->MaximumPacketSize));
    USBPORT_KdPrint((1, "'Flags %08.8x\n", PacketParameters->Flags));
    USBPORT_KdPrint((1, "'ErrorCount %d\n", PacketParameters->ErrorCount));

    // build up request for miniport

    length = devExt->Fdo.ScratchCommonBuffer->MiniportLength;
    va = devExt->Fdo.ScratchCommonBuffer->MiniportVa;
    phys = devExt->Fdo.ScratchCommonBuffer->MiniportPhys;

    mpPacket.DeviceAddress = PacketParameters->DeviceAddress;
    mpPacket.EndpointAddress = PacketParameters->EndpointAddress;
    mpPacket.MaximumPacketSize = PacketParameters->MaximumPacketSize;
    if (PacketParameters->Flags & USB_PACKETFLAG_SETUP) {
        mpPacket.Type = ss_Setup;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_ASYNC_IN) {
        USBPORT_KdPrint((1, "'Async In\n"));
        mpPacket.Type = ss_In;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_ASYNC_OUT) {
        USBPORT_KdPrint((1, "'Async Out\n"));
        mpPacket.Type = ss_Out;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_ISO_IN) {
        USBPORT_KdPrint((1, "'Iso In\n"));
        mpPacket.Type = ss_Iso_In;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_ISO_OUT) {
        USBPORT_KdPrint((1, "'Iso Out\n"));
        mpPacket.Type = ss_Iso_Out;
    } else {
        usbUserStatus = UsbUserInvalidParameter;
    }

    if (PacketParameters->Flags & USB_PACKETFLAG_LOW_SPEED) {
        USBPORT_KdPrint((1, "'LowSpeed\n"));
        mpPacket.Speed = ss_Low;
        mpPacket.HubDeviceAddress = PacketParameters->HubDeviceAddress;
        mpPacket.PortTTNumber = PacketParameters->PortTTNumber;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_FULL_SPEED) {
        USBPORT_KdPrint((1, "'FullSpeed\n"));
        mpPacket.Speed = ss_Full;
        mpPacket.HubDeviceAddress = PacketParameters->HubDeviceAddress;
        mpPacket.PortTTNumber = PacketParameters->PortTTNumber;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_HIGH_SPEED) {
        USBPORT_KdPrint((1, "'HighSpeed\n"));
        mpPacket.Speed = ss_High;
    } else {
         usbUserStatus = UsbUserInvalidParameter;
    }

    if (PacketParameters->Flags & USB_PACKETFLAG_TOGGLE0) {
        USBPORT_KdPrint((1, "'Toggle0\n"));
        mpPacket.Toggle = ss_Toggle0;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_TOGGLE1) {
        USBPORT_KdPrint((1, "'Toggle1\n"));
        mpPacket.Toggle = ss_Toggle1;
    } else {
        usbUserStatus = UsbUserInvalidParameter;
    }

    if (usbUserStatus == UsbUserSuccess) {
        mpData = &PacketParameters->Data[0];
        mpDataLength = PacketParameters->DataLength;
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'ssDT', mpData, mpDataLength, 0);


        MP_StartSendOnePacket(devExt,
                              &mpPacket,
                              mpData,
                              &mpDataLength,
                              va,
                              phys,
                              length,
                              &usbdStatus,
                              mpStatus);

        if (USBMP_STATUS_SUCCESS != mpStatus) {
            usbUserStatus = UsbUserMiniportError;
            goto USBPORT_UserSendOnePacket_Exit;
        }

        do {
            // wait 10 ms
            USBPORT_Wait(FdoDeviceObject, 10);

            // wait a user specified time
            if (PacketParameters->Timeout) {
                USBPORT_Wait(FdoDeviceObject, PacketParameters->Timeout);
            }

            MP_EndSendOnePacket(devExt,
                                &mpPacket,
                                mpData,
                                &mpDataLength,
                                va,
                                phys,
                                length,
                                &usbdStatus,
                                mpStatus);

        } while (USBMP_STATUS_BUSY == mpStatus);

        // allow one frame to pass before continuing
        USBPORT_Wait(FdoDeviceObject, 1);

        PacketParameters->DataLength = mpDataLength;
        PacketParameters->UsbdStatusCode = usbdStatus;

        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'ssDE', mpData, mpDataLength,
            PacketParameters);
    }

USBPORT_UserSendOnePacket_Exit:

    Header->UsbUserStatusCode = usbUserStatus;

}

VOID
USBPORT_UserRawResetPort(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_RESET_PORT_PARAMETERS Parameters
    )
/*++

Routine Description:

    Cycle a specific Root Port

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    RH_PORT_STATUS portStatus;
    ULONG loopCount;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort, %x\n", devExt));

    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrsp', 0, 0, Parameters->PortNumber);

    if (!USBPORT_ValidateRootPortApi(FdoDeviceObject, Parameters->PortNumber)) {
        Header->UsbUserStatusCode =
            usbUserStatus = UsbUserInvalidParameter;
        return;
    }

    USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: Setting port power\n"));

    // power the port
    devExt->Fdo.MiniportDriver->
        RegistrationPacket.MINIPORT_RH_SetFeaturePortPower(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);

    //
    // Wait the required time for the port power to stabilize.
    //
    //  512ms --> Max port power to power good time for root hub
    //  100ms --> Max time for device to have power stabilize
    //
    // After this time, the device must have signalled connect on the device
    //

    USBPORT_Wait( FdoDeviceObject, 612 );

    MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
            &portStatus, mpStatus);

    USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: Port status = %x\n",
                    portStatus ));
    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrs1', 0, 0,
             (ULONG_PTR) portStatus.ul);

    //
    // Device should have signalled connect, if not, it's an error.
    //

    if ( portStatus.Connected )
    {
        //
        // Provide another 100ms for debounce interval.
        //

        USBPORT_Wait( FdoDeviceObject, 100 );

        //
        // Reset the device
        //

        USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: Setting port reset\n"));

        // attempt a reset
        mpStatus = devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_SetFeaturePortReset(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);

        //
        // wait for reset change, this process is drive by the
        // HC root hub hardware or miniport
        //

        loopCount = 0;

        USBPORT_Wait( FdoDeviceObject, 20 );

        MPRH_GetPortStatus(devExt,
                    (USHORT)(Parameters->PortNumber), &portStatus, mpStatus);

        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrs2', 0, 0,
             (ULONG_PTR) portStatus.ul);

        //
        // Some hubs seem to be taking longer than 20 ms to signal reset change
        // This is a loop to give it up to another 20ms.
        //

        while ( !portStatus.ResetChange && loopCount < 20 )
        {
            loopCount++;

            USBPORT_Wait( FdoDeviceObject, 1 );

            MPRH_GetPortStatus(devExt,
                    (USHORT)(Parameters->PortNumber), &portStatus, mpStatus);
        }

        USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: loopCount = %d\n",
                         loopCount));

        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrs3', 0, loopCount,
             (ULONG_PTR) portStatus.ul);

        if ( portStatus.ResetChange )
        {
            USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: Clearing reset "
                                 "change\n"));

            // clear the change bit
            mpStatus = devExt->Fdo.MiniportDriver->
                RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange(
                                                    devExt->Fdo.MiniportDeviceData,
                                                    Parameters->PortNumber);

            MPRH_GetPortStatus( devExt,
                                (USHORT) (Parameters->PortNumber),
                                &portStatus,
                                mpStatus );

            LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrs4', 0, 0,
             (ULONG_PTR) portStatus.ul);

            USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: Port status = %x\n",
                            portStatus ));

            //
            // Wait an additional 10 seconds for device reset recovery
            //

            USBPORT_Wait( FdoDeviceObject, 10 );
        }
        else
        {
            USBPORT_KdPrint((2,
                        "'USBPORT_UserRawResetPort: reset change not set\n"
                        "'PortStatus = 0x%x\n", portStatus.ul));

            TEST_TRAP();
        }

    } else {
        usbUserStatus = UsbUserNoDeviceConnected;
    }

    // status is low 16 bits
    Parameters->PortStatus = (USHORT) portStatus.ul;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrs>', 0, portStatus.ul,
                                                        usbUserStatus);

    Header->UsbUserStatusCode = usbUserStatus;
}





VOID
USBPORT_GetRootPortStatus(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_ROOTPORT_PARAMETERS Parameters
    )
/*++

Routine Description:

    Cycle a specific Root Port

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    USBPRIV_ROOTPORT_STATUS portStatusInfo;

    USBPORT_KdPrint((2, "'USBPORT_GetRootPortStatus\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gRPs', 0, 0, Parameters->PortNumber);

    if (!USBPORT_ValidateRootPortApi(FdoDeviceObject, Parameters->PortNumber)) {
        Header->UsbUserStatusCode =
            usbUserStatus = UsbUserInvalidParameter;
        return;
    }

    portStatusInfo.PortNumber = (USHORT) Parameters->PortNumber;
    portStatusInfo.PortStatus.ul = 0;

    MP_PassThru(devExt,
                (LPGUID) &GUID_USBPRIV_ROOTPORT_STATUS,
                sizeof(portStatusInfo),
                &portStatusInfo, // Info,
                mpStatus);

    if (USBMP_STATUS_NOT_SUPPORTED == mpStatus) {
        MPRH_GetPortStatus(devExt, portStatusInfo.PortNumber,
                            &(portStatusInfo.PortStatus), mpStatus);
    }

    // status is low 16 bits
    Parameters->PortStatus = (USHORT) portStatusInfo.PortStatus.ul;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gRP>', 0, 0, usbUserStatus);

    Header->UsbUserStatusCode = usbUserStatus;
}

VOID
USBPORT_UserGetControllerInfo_0(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_CONTROLLER_INFO_0 ControllerInfo_0
    )
/*++

Routine Description:

    Execute a single step transaction

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
--*/
{
    PDEVICE_EXTENSION devExt;
    ROOTHUB_DATA hubData;
    RH_HUB_CHARATERISTICS rhChars;

    USBPORT_KdPrint((2, "'USBPORT_UserGetControllerInfo_0\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ControllerInfo_0->HcFeatureFlags = 0;

    MPRH_GetRootHubData(devExt, &hubData);

    ControllerInfo_0->NumberOfRootPorts =
             hubData.NumberOfPorts;

    rhChars.us = hubData.HubCharacteristics.us;

    if (rhChars.PowerSwitchType == USBPORT_RH_POWER_SWITCH_PORT) {
            ControllerInfo_0->HcFeatureFlags |=
                USB_HC_FEATURE_FLAG_PORT_POWER_SWITCHING;
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND)) {
        ControllerInfo_0->HcFeatureFlags |=
            USB_HC_FEATURE_FLAG_SEL_SUSPEND;
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_LEGACY_BIOS)) {
        ControllerInfo_0->HcFeatureFlags |=
            USB_HC_FEATURE_LEGACY_BIOS;
    }

    ControllerInfo_0->PciVendorId =
        devExt->Fdo.PciVendorId;

    ControllerInfo_0->PciDeviceId =
        devExt->Fdo.PciDeviceId;

    ControllerInfo_0->PciRevision =
        (UCHAR) devExt->Fdo.PciRevisionId;

    ControllerInfo_0->ControllerFlavor =
        devExt->Fdo.HcFlavor;

    Header->UsbUserStatusCode =
        UsbUserSuccess;
}


VOID
USBPORT_UserGetControllerKey(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_UNICODE_NAME ControllerKey
    )
/*++

Routine Description:

    Returns the Driver key associated with this symbolic link for the
    host controller.

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;
    ULONG userLength, actualLength;

    USBPORT_KdPrint((2, "'USBPORT_UserGetControllerKey\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // we should not get here unl;ess this hold true
    USBPORT_ASSERT(Header->RequestBufferLength >=
                   sizeof(USB_UNICODE_NAME)+sizeof(*Header));

    // userlength
    userLength = Header->RequestBufferLength - sizeof(*Header)
        - sizeof(USB_UNICODE_NAME);

    // note: this will cause us to return a NULL terminated
    // key
    RtlZeroMemory(ControllerKey, userLength);

    ntStatus = IoGetDeviceProperty(
        devExt->Fdo.PhysicalDeviceObject,
        DevicePropertyDriverKeyName,
        userLength,
        &ControllerKey->String[0],
        &actualLength);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'dKEY', &ControllerKey->String[0], userLength,
            actualLength);

    if (NT_SUCCESS(ntStatus)) {
        Header->UsbUserStatusCode = UsbUserSuccess;
        ControllerKey->Length = actualLength + sizeof(UNICODE_NULL);
    } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;
    } else {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
    }

    Header->ActualBufferLength =
        actualLength+sizeof(*Header)+sizeof(USB_UNICODE_NAME);

}


VOID
USBPORT_UserGetRootHubName(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_UNICODE_NAME RootHubName
    )
/*++

Routine Description:

    Returns the Driver key associated with this symbolic link for the
    host controller.

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;
    ULONG userLength, actualLength;
    UNICODE_STRING hubNameUnicodeString;

    USBPORT_KdPrint((2, "'USBPORT_UserGetRootHubName\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // we should not get here unl;ess this hold true
    USBPORT_ASSERT(Header->RequestBufferLength >=
                   sizeof(USB_UNICODE_NAME)+sizeof(*Header));

    // userlength
    userLength = Header->RequestBufferLength - sizeof(*Header)
        - sizeof(USB_UNICODE_NAME);

    // note: this will cause us to return a NULL terminated
    // key
    RtlZeroMemory(RootHubName, userLength);

    ntStatus = USBPORT_GetSymbolicName(FdoDeviceObject,
                                       devExt->Fdo.RootHubPdo,
                                       &hubNameUnicodeString);
    actualLength = 0;

    if (NT_SUCCESS(ntStatus)) {
        ULONG n;

        actualLength = hubNameUnicodeString.Length;
        n = hubNameUnicodeString.Length;
        if (n > userLength) {
            n = userLength;
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        if (n) {
            RtlCopyMemory(&RootHubName->String[0],
                          hubNameUnicodeString.Buffer,
                          n);
        }
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Huns',
            &hubNameUnicodeString, 0, 0);

        RtlFreeUnicodeString(&hubNameUnicodeString);
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gHNM', ntStatus, userLength,
            actualLength);

    if (NT_SUCCESS(ntStatus)) {
        Header->UsbUserStatusCode = UsbUserSuccess;
        RootHubName->Length = actualLength + sizeof(UNICODE_NULL);
    } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;
    } else {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
    }

    Header->ActualBufferLength =
        actualLength+sizeof(*Header)+sizeof(USB_UNICODE_NAME);

}


VOID
USBPORT_UserPassThru(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_PASS_THRU_PARAMETERS PassThru
    )
/*++

Routine Description:

   Handles pass-thru apis for the Miniport

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;
    ULONG userLength, actualLength, length;
    USB_MINIPORT_STATUS mpStatus;
    ULONG parameterLength;

    USBPORT_KdPrint((2, "'USBPORT_UserPassThru\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // we should not get here unless this hold true
    USBPORT_ASSERT(Header->RequestBufferLength >=
                   sizeof(USB_PASS_THRU_PARAMETERS)+sizeof(*Header));

    // limit pass thru blocks to 64k
    if (PassThru->ParameterLength > 0x10000) {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
        return;
    }

    // extra length check is needed since we
    // have embedded data
    // if we get here we know packet parameters are valid
    length = sizeof(*Header) + sizeof(USB_PASS_THRU_PARAMETERS) - 4 +
                PassThru->ParameterLength;

    if (length > Header->RequestBufferLength) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Tsma', length, 0,
            Header->RequestBufferLength);
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;
        return;
    }

    // userlength
    parameterLength = PassThru->ParameterLength;

    Header->ActualBufferLength =
        sizeof(*Header)+sizeof(USB_PASS_THRU_PARAMETERS) +
            parameterLength;

    // call the miniport
    MP_PassThru(devExt,
                &PassThru->FunctionGUID,
                parameterLength,
                &PassThru->Parameters,
                mpStatus);

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        Header->UsbUserStatusCode = UsbUserSuccess;
        USBPORT_KdPrint((1, "'USBPORT_UserPassThru Success\n"));
    } else {
        Header->UsbUserStatusCode = UsbUserMiniportError;
        USBPORT_KdPrint((1, "'USBPORT_UserPassThru Error\n"));
    }

}


WDMUSB_POWER_STATE
WdmUsbSystemPowerState(
    SYSTEM_POWER_STATE SystemPowerState
    )
/*++

Routine Description:

Arguments:

Return Value:

    WDMUSB_POWER_STATE that matches the WDM power state passed in
--*/
{
    switch(SystemPowerState) {
    case PowerSystemWorking:
        return WdmUsbPowerSystemWorking;
    case PowerSystemSleeping1:
        return WdmUsbPowerSystemSleeping1;
    case PowerSystemSleeping2:
        return WdmUsbPowerSystemSleeping2;
    case PowerSystemSleeping3:
        return WdmUsbPowerSystemSleeping3;
    case PowerSystemHibernate:
        return WdmUsbPowerSystemHibernate;
    case PowerSystemShutdown:
        return WdmUsbPowerSystemShutdown;
    }

    return WdmUsbPowerNotMapped;
}


WDMUSB_POWER_STATE
WdmUsbDevicePowerState(
    DEVICE_POWER_STATE DevicePowerState
    )
/*++

Routine Description:

Arguments:

Return Value:

    WDMUSB_POWER_STATE that matches the WDM power state passed in
--*/
{
    switch(DevicePowerState) {
    case PowerDeviceUnspecified:
        return WdmUsbPowerDeviceUnspecified;
    case PowerDeviceD0:
        return WdmUsbPowerDeviceD0;
    case PowerDeviceD1:
        return WdmUsbPowerDeviceD1;
    case PowerDeviceD2:
        return WdmUsbPowerDeviceD2;
    case PowerDeviceD3:
        return WdmUsbPowerDeviceD3;
    }

    return WdmUsbPowerNotMapped;
}


VOID
USBPORT_MapPowerStateInformation(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_POWER_INFO PowerInformation,
    PDEVICE_CAPABILITIES HcCaps,
    PDEVICE_CAPABILITIES RhCaps
    )
/*++

Routine Description:

Arguments:

Return Value:

    none.
--*/
{
    PHC_POWER_STATE hcPowerState = NULL;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    PowerInformation->RhDeviceWake =
        WdmUsbDevicePowerState(RhCaps->DeviceWake);
    PowerInformation->RhSystemWake =
        WdmUsbSystemPowerState(RhCaps->SystemWake);
    PowerInformation->HcDeviceWake =
        WdmUsbDevicePowerState(HcCaps->DeviceWake);
    PowerInformation->HcSystemWake =
        WdmUsbSystemPowerState(HcCaps->SystemWake);

    switch (PowerInformation->SystemState) {
    case WdmUsbPowerSystemWorking:
        PowerInformation->RhDevicePowerState =
            WdmUsbDevicePowerState(RhCaps->DeviceState[PowerSystemWorking]);
        PowerInformation->HcDevicePowerState =
            WdmUsbDevicePowerState(HcCaps->DeviceState[PowerSystemWorking]);
//        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject,
//            PowerSystemWorking);
        break;

    case WdmUsbPowerSystemSleeping1:
        PowerInformation->RhDevicePowerState =
            WdmUsbDevicePowerState(RhCaps->DeviceState[PowerSystemSleeping1]);
        PowerInformation->HcDevicePowerState =
            WdmUsbDevicePowerState(HcCaps->DeviceState[PowerSystemSleeping1]);
        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject,
                                               &devExt->Fdo.HcPowerStateTbl,
                                               PowerSystemSleeping1);
        break;

    case WdmUsbPowerSystemSleeping2:
        PowerInformation->RhDevicePowerState =
            WdmUsbDevicePowerState(RhCaps->DeviceState[PowerSystemSleeping2]);
        PowerInformation->HcDevicePowerState =
            WdmUsbDevicePowerState(HcCaps->DeviceState[PowerSystemSleeping2]);
        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject,
                                               &devExt->Fdo.HcPowerStateTbl,
                                               PowerSystemSleeping2);
        break;

    case WdmUsbPowerSystemSleeping3:
        PowerInformation->RhDevicePowerState =
            WdmUsbDevicePowerState(RhCaps->DeviceState[PowerSystemSleeping3]);
        PowerInformation->HcDevicePowerState =
            WdmUsbDevicePowerState(HcCaps->DeviceState[PowerSystemSleeping3]);
        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject,
                                               &devExt->Fdo.HcPowerStateTbl,
                                               PowerSystemSleeping3);
        break;

     case WdmUsbPowerSystemHibernate:
        PowerInformation->RhDevicePowerState =
            WdmUsbDevicePowerState(RhCaps->DeviceState[PowerSystemHibernate]);
        PowerInformation->HcDevicePowerState =
            WdmUsbDevicePowerState(HcCaps->DeviceState[PowerSystemHibernate]);
        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject,
                                               &devExt->Fdo.HcPowerStateTbl,
                                               PowerSystemHibernate);
        break;
    }


    if (hcPowerState != NULL) {
        switch(hcPowerState->Attributes) {
        case HcPower_Y_Wakeup_Y:
            PowerInformation->CanWakeup = 1;
            PowerInformation->IsPowered = 1;
            break;
        case HcPower_N_Wakeup_N:
            PowerInformation->CanWakeup = 0;
            PowerInformation->IsPowered = 0;
            break;
        case HcPower_Y_Wakeup_N:
            PowerInformation->CanWakeup = 0;
            PowerInformation->IsPowered = 1;
            break;
        case HcPower_N_Wakeup_Y:
            PowerInformation->CanWakeup = 1;
            PowerInformation->IsPowered = 0;
            break;
        }
    } else {
        PowerInformation->CanWakeup = 0;
        PowerInformation->IsPowered = 0;
    }

    PowerInformation->LastSystemSleepState =
        WdmUsbSystemPowerState(devExt->Fdo.LastSystemSleepState);
}


VOID
USBPORT_UserPowerInformation(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_POWER_INFO PowerInformation
    )
/*++

Routine Description:

   Handles power info API

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
--*/
{
    PDEVICE_EXTENSION devExt, rhDevExt;
    PDEVICE_CAPABILITIES hcDeviceCaps, rhDeviceCaps;

    USBPORT_KdPrint((2, "'USBPORT_UserPowerInformation\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    // BUGBUG this api should fail if we are not started
    if (!TEST_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_STARTED)) {

        Header->ActualBufferLength =
            sizeof(*Header)+sizeof(USB_POWER_INFO);
        Header->UsbUserStatusCode = UsbUserDeviceNotStarted;
        return;
    }

    rhDeviceCaps = &rhDevExt->DeviceCapabilities;
    hcDeviceCaps = &devExt->DeviceCapabilities;

    // we should not get here unless this holds true
    USBPORT_ASSERT(Header->RequestBufferLength >=
                   sizeof(USB_POWER_INFO)+sizeof(*Header));

    USBPORT_MapPowerStateInformation(
        FdoDeviceObject,
        PowerInformation,
        hcDeviceCaps,
        rhDeviceCaps);

    Header->ActualBufferLength =
        sizeof(*Header)+sizeof(USB_POWER_INFO);

}


VOID
USBPORT_UserOpenRawDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_OPEN_RAW_DEVICE_PARAMETERS Parameters
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    USHORT portStatus;

    USBPORT_KdPrint((2, "'USBPORT_OpenRawDevice\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    usbUserStatus = UsbUserSuccess;

    // fail request if open
    if (devExt->Fdo.RawDeviceHandle) {
        usbUserStatus = UsbUserInvalidParameter;
        goto USBPORT_UserOpenRawDevice_Done;
    }

    // fabricate port status
    portStatus = Parameters->PortStatus;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'oRAW', 0, 0, portStatus);

    // we assume that a device is connected here, we just create
    // a raw handle to it, nothing more.
    //
    // everything else must be handled by the caller.

    ntStatus = USBPORT_CreateDevice(&devExt->Fdo.RawDeviceHandle,
                                    FdoDeviceObject,
                                    NULL,
                                    portStatus,
                                    0);

    if (NT_SUCCESS(ntStatus)) {
        // mark this device handle as 'special'
        SET_FLAG(devExt->Fdo.RawDeviceHandle->DeviceFlags,
            USBPORT_DEVICEFLAG_RAWHANDLE);

        Parameters->MaxPacketEp0 =
            devExt->Fdo.RawDeviceHandle->DeviceDescriptor.bMaxPacketSize0;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'oRAs', 0, 0, ntStatus);


    usbUserStatus =
        USBPORT_NtStatus_TO_UsbUserStatus(ntStatus);

USBPORT_UserOpenRawDevice_Done:

    Header->UsbUserStatusCode = usbUserStatus;
}


VOID
USBPORT_UserCloseRawDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_CLOSE_RAW_DEVICE_PARAMETERS Parameters
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    NTSTATUS ntStatus;

    USBPORT_KdPrint((2, "'USBPORT_UserCloseRawDevice\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // fail request if closed
    if (devExt->Fdo.RawDeviceHandle == NULL) {
        usbUserStatus = UsbUserInvalidParameter;
        goto USBPORT_UserCloseRawDevice_Done;
    }


    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'cRAW', 0, 0, 0);

    ntStatus =
        USBPORT_RemoveDevice(devExt->Fdo.RawDeviceHandle,
                             FdoDeviceObject,
                             0);

    devExt->Fdo.RawDeviceHandle = NULL;

    // in this particular case the API should not fail

    USBPORT_ASSERT(ntStatus == STATUS_SUCCESS);

USBPORT_UserCloseRawDevice_Done:

    Header->UsbUserStatusCode = usbUserStatus;
}


VOID
USBPORT_UserSendRawCommand(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_SEND_RAW_COMMAND_PARAMETERS Parameters
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
    PUSBD_PIPE_HANDLE_I defaultPipe;
    NTSTATUS ntStatus;
    ULONG length;

    USBPORT_KdPrint((2, "'USBPORT_UserSendRawCommand\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'sRAW', 0, 0, 0);

    // fail request if closed
    if (devExt->Fdo.RawDeviceHandle == NULL) {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
        return;
    }

    // a control transfer can be up 0 to 64k
    if (Parameters->DataLength > 0x10000) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Tbts', 0, 0,
            Parameters->DataLength);
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
        return;
    }

    // extra length check is needed sinve we
    // have embedded data
    // if we get here we know packet parameters are valid
    length = sizeof(*Header) + sizeof(USB_SEND_RAW_COMMAND_PARAMETERS) - 4 +
                Parameters->DataLength;

    // length is the area of the buffer we may reference

    if (length > Header->RequestBufferLength) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Tsma', length, 0,
            Header->RequestBufferLength);
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;
        return;
    }

    Header->ActualBufferLength = length;

    setupPacket.bmRequestType.B = Parameters->Usb_bmRequest;
    setupPacket.bRequest = Parameters->Usb_bRequest;
    setupPacket.wValue.W = Parameters->Usb_wVlaue;
    setupPacket.wIndex.W = Parameters->Usb_wIndex;
    setupPacket.wLength = Parameters->Usb_wLength;

    // if address is different then we will need to
    // poke the endpoint

    defaultPipe = &devExt->Fdo.RawDeviceHandle->DefaultPipe;

    defaultPipe->Endpoint->Parameters.MaxPacketSize =
        Parameters->MaximumPacketSize;
    defaultPipe->Endpoint->Parameters.DeviceAddress =
        Parameters->DeviceAddress;

    MP_PokeEndpoint(devExt, defaultPipe->Endpoint, mpStatus);

    ntStatus = USBPORT_SendCommand(devExt->Fdo.RawDeviceHandle,
                                   FdoDeviceObject,
                                   &setupPacket,
                                   &Parameters->Data[0],
                                   Parameters->DataLength,
                                   &Parameters->DataLength,
                                   &Parameters->UsbdStatusCode);
    usbUserStatus =
        USBPORT_NtStatus_TO_UsbUserStatus(ntStatus);

    Header->UsbUserStatusCode = usbUserStatus;
}


VOID
USBPORT_UserGetBandwidthInformation(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_BANDWIDTH_INFO BandwidthInfo
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG asyncBW;

    USBPORT_KdPrint((2, "'USBPORT_UserGetBandwidthInformation\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gBWi', 0, 0, 0);

    BandwidthInfo->DeviceCount =
        USBPORT_GetDeviceCount(FdoDeviceObject);
    BandwidthInfo->TotalBusBandwidth =
        devExt->Fdo.TotalBusBandwidth;

    // return allocation based on 32 sec
    // segment of bus time
    BandwidthInfo->Total32secBandwidth =
        devExt->Fdo.TotalBusBandwidth * 32;

    asyncBW = BandwidthInfo->TotalBusBandwidth/10;
    BandwidthInfo->AllocedBulkAndControl =
        asyncBW * 32;

    BandwidthInfo->AllocedIso =
        devExt->Fdo.AllocedIsoBW*32;
    BandwidthInfo->AllocedInterrupt_1ms =
        devExt->Fdo.AllocedInterruptBW[0]*32;
    BandwidthInfo->AllocedInterrupt_2ms =
        devExt->Fdo.AllocedInterruptBW[1]*16;
    BandwidthInfo->AllocedInterrupt_4ms =
        devExt->Fdo.AllocedInterruptBW[2]*8;
    BandwidthInfo->AllocedInterrupt_8ms =
        devExt->Fdo.AllocedInterruptBW[3]*4;
    BandwidthInfo->AllocedInterrupt_16ms =
        devExt->Fdo.AllocedInterruptBW[4]*2;
    BandwidthInfo->AllocedInterrupt_32ms =
        devExt->Fdo.AllocedInterruptBW[5]*1;

    Header->ActualBufferLength =
        sizeof(*Header)+sizeof(USB_BANDWIDTH_INFO);
}


VOID
USBPORT_UserGetBusStatistics0(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_BUS_STATISTICS_0 BusStatistics0
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt, rhDevExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (devExt->Fdo.RootHubPdo != NULL) {
        GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
        ASSERT_PDOEXT(rhDevExt);
    } else {
        rhDevExt = NULL;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gBus', rhDevExt,
        BusStatistics0, 0);

    BusStatistics0->DeviceCount =
        USBPORT_GetDeviceCount(FdoDeviceObject);

    KeQuerySystemTime(&BusStatistics0->CurrentSystemTime);

    MP_Get32BitFrameNumber(devExt,
                           BusStatistics0->CurrentUsbFrame);

    // lock the stat counters while we read them
    KeAcquireSpinLock(&devExt->Fdo.StatCounterSpin.sl, &irql);

    BusStatistics0->BulkBytes =
        devExt->Fdo.StatBulkDataBytes;
    BusStatistics0->IsoBytes =
        devExt->Fdo.StatIsoDataBytes;
    BusStatistics0->InterruptBytes =
        devExt->Fdo.StatInterruptDataBytes;
    BusStatistics0->ControlDataBytes =
        devExt->Fdo.StatControlDataBytes;

    BusStatistics0->RootHubDevicePowerState = 4;
    BusStatistics0->RootHubEnabled = FALSE;

    BusStatistics0->WorkerSignalCount =
        devExt->Fdo.StatWorkSignalCount;
    BusStatistics0->HardResetCount =
        devExt->Fdo.StatHardResetCount;
    BusStatistics0->WorkerIdleTimeMs =
        devExt->Fdo.StatWorkIdleTime;

    BusStatistics0->CommonBufferBytes =
        devExt->Fdo.StatCommonBufferBytes;


    if (rhDevExt != NULL) {
        BusStatistics0->RootHubEnabled = TRUE;
        switch(rhDevExt->CurrentDevicePowerState) {
        case PowerDeviceD0:
            BusStatistics0->RootHubDevicePowerState = 0;
            break;
        case PowerDeviceD1:
            BusStatistics0->RootHubDevicePowerState = 1;
            break;
        case PowerDeviceD2:
            BusStatistics0->RootHubDevicePowerState = 2;
            break;
        case PowerDeviceD3:
            BusStatistics0->RootHubDevicePowerState = 3;
            break;
        }
    }

    BusStatistics0->PciInterruptCount =
        devExt->Fdo.StatPciInterruptCount;

//    if (ResetCounters) {
//        devExt->Fdo.StatControlDataBytes =
//        devExt->Fdo.StatInterruptBytes =
//        devExt->Fdo.StatIsoBytes =
//        devExt->Fdo.StatBulkBytes =
//        devExt->Fdo.PciInterruptCount = 0;
//    }

    KeReleaseSpinLock(&devExt->Fdo.StatCounterSpin.sl, irql);

    Header->ActualBufferLength =
        sizeof(*Header)+sizeof(USB_BUS_STATISTICS_0);
}

// This was taken from usbioctl.h
//
#include <pshpack1.h>
typedef struct _USB_HCD_DRIVERKEY_NAME {
    ULONG ActualLength;
    WCHAR DriverKeyName[1]; // names are returned NULL terminated
} USB_HCD_DRIVERKEY_NAME, *PUSB_HCD_DRIVERKEY_NAME;
#include <poppack.h>

NTSTATUS
USBPORT_LegacyGetUnicodeName(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PULONG BytesReturned
    )
/*++

Routine Description:

    Handles the old style IOCTL to fetch the USB host controllers
    driver key name.

    NOTE: This function may be removed  if we ever fix the UI to use the
    newer APIs.


Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PUSBUSER_CONTROLLER_UNICODE_NAME request;
    NTSTATUS ntStatus;
    ULONG need;
    PUSB_HCD_DRIVERKEY_NAME ioBufferO;
    PIO_STACK_LOCATION irpStack;
    ULONG outputBufferLength;
    ULONG ioCtl;

    PAGED_CODE();

    *BytesReturned = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ioCtl = irpStack->Parameters.DeviceIoControl.IoControlCode;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL);
    USBPORT_ASSERT(ioCtl == IOCTL_GET_HCD_DRIVERKEY_NAME ||
                   ioCtl == IOCTL_USB_GET_ROOT_HUB_NAME);

    USBPORT_KdPrint((0,"'WARNING: Caller using obsolete user mode IOCTL\n"));

    ioBufferO = Irp->AssociatedIrp.SystemBuffer;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    // Bail immediately if the output buffer is too small
    //
    if (outputBufferLength < sizeof(USB_HCD_DRIVERKEY_NAME)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // first get the driver key name using the standard API

    need = sizeof(USBUSER_CONTROLLER_UNICODE_NAME);

retry:

    ALLOC_POOL_Z(request,
                 PagedPool, need);

    if (request != NULL) {

        request->Header.RequestBufferLength = need;
        if (ioCtl == IOCTL_GET_HCD_DRIVERKEY_NAME) {
            request->Header.UsbUserRequest =
                USBUSER_GET_CONTROLLER_DRIVER_KEY;
            USBPORT_UserGetControllerKey(
                FdoDeviceObject,
                &request->Header,
                &request->UnicodeName);
        } else {
            request->Header.UsbUserRequest =
                USBUSER_GET_ROOTHUB_SYMBOLIC_NAME;
            USBPORT_UserGetRootHubName(
                FdoDeviceObject,
                &request->Header,
                &request->UnicodeName);
        }

        if (request->Header.UsbUserStatusCode ==
            UsbUserBufferTooSmall) {

            need = request->Header.ActualBufferLength;

            FREE_POOL(FdoDeviceObject, request);
            goto retry;

        } else if (request->Header.UsbUserStatusCode ==
                            UsbUserSuccess) {

            // map the result into the callers buffer

            // note: actual length is the size of the request structure
            // plus the name.
            ioBufferO->ActualLength = request->UnicodeName.Length +
                                      sizeof(ULONG);

            if (outputBufferLength >= ioBufferO->ActualLength) {
                // we can return the name
                RtlCopyMemory(&ioBufferO->DriverKeyName[0],
                              &request->UnicodeName.String[0],
                              request->UnicodeName.Length);

                *BytesReturned = ioBufferO->ActualLength;

            } else {
                ioBufferO->DriverKeyName[0] =  L'\0';
                *BytesReturned = sizeof(USB_HCD_DRIVERKEY_NAME);
            }

            ntStatus = STATUS_SUCCESS;

            FREE_POOL(FdoDeviceObject, request);

        } else {
            ntStatus = STATUS_UNSUCCESSFUL;
        }

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gUNN', ntStatus, ioBufferO,
        *BytesReturned);

    return ntStatus;
}


NTSTATUS
USBPORT_GetSymbolicName(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT DeviceObject,
    PUNICODE_STRING SymbolicNameUnicodeString
    )
/*++

Routine Description:

    Return the symbolic name for the device object with leading
    \xxx\ removed

Arguments:

    DeviceObject - Fdo OR Pdo for USB HC

Return Value:

    none

--*/
{
    PDEVICE_EXTENSION fdoDevExt;
    PDEVICE_EXTENSION devExt;
    ULONG length, offset = 0;
    WCHAR *pwch, *buffer;
    NTSTATUS ntStatus = STATUS_BOGUS;
    ULONG bufferLength;
    PUNICODE_STRING tmpUnicodeString;

    PAGED_CODE();

    GET_DEVICE_EXT(fdoDevExt, FdoDeviceObject);
    ASSERT_FDOEXT(fdoDevExt);

    GET_DEVICE_EXT(devExt, DeviceObject);

    tmpUnicodeString =
        &devExt->SymbolicLinkName;

    //
    // make sure there is enough room for the length,
    // string and the NULL
    //

    // assuming the string is \xxx\name strip of '\xxx\' where
    // x is zero or more chars

    pwch = &tmpUnicodeString->Buffer[0];

    // Under NT, if the controller is banged out in DeviceManager,
    // this will be NULL.

    if (pwch == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    bufferLength = tmpUnicodeString->Length;

    ALLOC_POOL_Z(buffer,
                 PagedPool, bufferLength);

    if (buffer != NULL) {

        USBPORT_ASSERT(*pwch == '\\');
        if (*pwch == '\\') {
            pwch++;
            while (*pwch != '\\' && *pwch) {
                pwch++;
            }
            USBPORT_ASSERT(*pwch == '\\');
            if (*pwch == '\\') {
                pwch++;
            }
            offset = (ULONG)((PUCHAR)pwch -
                (PUCHAR)&tmpUnicodeString->Buffer[0]);
        }

        length = tmpUnicodeString->Length - offset;

        RtlCopyMemory(buffer,
                      &tmpUnicodeString->Buffer[offset/2],
                      length);

        RtlInitUnicodeString(SymbolicNameUnicodeString,
                             buffer);

        ntStatus = STATUS_SUCCESS;

    } else {

        // init to null so subsequent free will not crash
        RtlInitUnicodeString(SymbolicNameUnicodeString,
                             NULL);

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    }

    return ntStatus;
}


VOID
USBPORT_UserGetDriverVersion(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_DRIVER_VERSION_PARAMETERS Parameters
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    USBPORT_KdPrint((2, "'USBPORT_UserGetDriverVersion\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gDrv', 0, 0, 0);

    Parameters->DriverTrackingCode = USBPORT_TRACKING_ID;
    /* USBDI Api set supported */
    Parameters->USBDI_Version = USBDI_VERSION;
    /* USB USER Api Set supported */
    Parameters->USBUSER_Version = USBUSER_VERSION;

    /* set to true if checked vesrion(s) on
       the stack are loaded
    */
#if DBG
    Parameters->CheckedPortDriver = TRUE;
    Parameters->CheckedMiniportDriver = TRUE;
#else
    Parameters->CheckedPortDriver = FALSE;
    Parameters->CheckedMiniportDriver = FALSE;
#endif

    Header->ActualBufferLength =
        sizeof(*Header)+sizeof(USB_DRIVER_VERSION_PARAMETERS);
}

BOOLEAN
USBPORT_ValidateRootPortApi(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG PortNumber
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    ROOTHUB_DATA hubData;

    USBPORT_KdPrint((2, "'USBPORT_ValidateRootPortApi\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    MPRH_GetRootHubData(devExt, &hubData);
    if (PortNumber > hubData.NumberOfPorts ||
        PortNumber == 0) {
        return FALSE;
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED)) {
        return FALSE;
    }

    return TRUE;
}

/*
    Determine if direct controller access is enabled.
    This should only be enabled by diagnostic
    applications.
*/

BOOLEAN
USBPORT_DCA_Enabled(
    PDEVICE_OBJECT FdoDeviceObject
    )
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usb = L"usb";
    ULONG k = 0;
    ULONG dca;

    PAGED_CODE();

    // bios hacks
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = ENABLE_DCA;
    QueryTable[k].EntryContext = &dca;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &dca;
    QueryTable[k].DefaultLength = sizeof(dca);
    k++;

    // stop
    QueryTable[k].QueryRoutine = NULL;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment


    return dca == 1 && NT_SUCCESS(ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\int.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    int.c

Abstract:

    code to handle adapter interrupts

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
// USBPORT_InterruptService
// USBPORT_IsrDpc
// USBPORT_DisableInterrupts
// USBPORT_IsrDpcWorker


BOOLEAN
USBPORT_InterruptService(
    PKINTERRUPT Interrupt,
    PVOID Context
    )

/*++

Routine Description:

    This is the interrupt service routine for the PORT driver.

Arguments:

    Interrupt - A pointer to the interrupt object for this interrupt.

    Context - A pointer to the device object.

Return Value:

    Returns TRUE if the interrupt was expected (and therefore processed);
    otherwise, FALSE is returned.

--*/

{
    PDEVICE_OBJECT fdoDeviceObject = Context;
    PDEVICE_EXTENSION devExt;
    BOOLEAN usbInt = FALSE;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // by definition, if we are in any other power state than D0 then
    // the interrupt could not be from the controller.  To handle this 
    // case we use our internal flag that indicates interrupts are 
    // disabled
    
    if (!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_EN)) {
        return FALSE;
    }

    // if the controller is gone then the interrupt cannot  
    // be from USB
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_CONTROLLER_GONE)) {
        return FALSE;
    }
    
    // check flag and calldown to miniport
    if (devExt->Fdo.MpStateFlags & MP_STATE_STARTED) {
        MP_InterruptService(devExt, usbInt);        
    } 
//#if DBG 
//      else {
//        // interrupt before we have started,
//        // it had better not be ours
//        DEBUG_BREAK();
//    }  
//#endif    

    if (usbInt) {
         devExt->Fdo.StatPciInterruptCount++;

         KeInsertQueueDpc(&devExt->Fdo.IsrDpc,
                          NULL,
                          NULL);
    } 
    
    return usbInt;
}       


VOID
USBPORT_IsrDpcWorker(
    PDEVICE_OBJECT FdoDeviceObject,
    BOOLEAN HcInterrupt
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL. 

    This routine dous our 'ISR Work' it can be called as a result
    of an interrupt or from the Deadman DPC timer.

    This function is not reentrant

    This function does not directly signal the worker thread 
    instead we leave this to invalidate endpoint.

Arguments:

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    LONG busy;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);    

    busy = InterlockedIncrement(&devExt->Fdo.WorkerDpc);
    if (busy) {
        InterlockedDecrement(&devExt->Fdo.WorkerDpc);
        return;
    }

    // noisy becuse it is called via timer
#if DBG
    {
    ULONG cf;
    MP_Get32BitFrameNumber(devExt, cf);

    if (HcInterrupt) {
        LOGENTRY(NULL, 
            FdoDeviceObject, LOG_NOISY, 'iDW+', FdoDeviceObject, cf, HcInterrupt);
    } else {
         LOGENTRY(NULL, 
            FdoDeviceObject, LOG_NOISY, 'idw+', FdoDeviceObject, cf, HcInterrupt);
    }
    }
#endif        
    // check the state list for any endpoints
    // that have changed state
    //
    // We add elements to the tail so the ones at
    // the head should be the oldest and ready 
    // for processing.
    // if we hit one that is not ready then we know
    // the others are not ready either so we bail.
    
    listEntry = 
        ExInterlockedRemoveHeadList(&devExt->Fdo.EpStateChangeList,
                                    &devExt->Fdo.EpStateChangeListSpin.sl);

    while (listEntry != NULL) {
    
        PHCD_ENDPOINT endpoint;
        ULONG frameNumber;
    
        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_ENDPOINT, 
                        StateLink);

        ASSERT_ENDPOINT(endpoint);

        // lock the endpoint before changing its state
        ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'LeG0');
        
        // see if it is time 
        MP_Get32BitFrameNumber(devExt, frameNumber);

        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'chgS', endpoint, frameNumber, 
            endpoint->StateChangeFrame);

        if (frameNumber <= endpoint->StateChangeFrame &&
            !TEST_FLAG(endpoint->Flags, EPFLAG_NUKED)) {
            // not time yet, put it back (on the head) and bail
            RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'UeG1'); 

            ExInterlockedInsertHeadList(&devExt->Fdo.EpStateChangeList,
                                        &endpoint->StateLink,
                                        &devExt->Fdo.EpStateChangeListSpin.sl);

            // request an SOF just in case
            MP_InterruptNextSOF(devExt);
            break;                                        
        }

        // this endpoint is ripe, change its state
        //
        // note: we should never move into the unknown state
        //
        // IT IS CRITICAL that this is the only place an endpoint state
        // may be changed.
        // there is one exception and that is cahnging the state to 
        // CLOSED
        RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'UeG0');       


        ACQUIRE_STATECHG_LOCK(FdoDeviceObject, endpoint); 
        USBPORT_ASSERT(endpoint->NewState != ENDPOINT_TRANSITION);
        endpoint->CurrentState = endpoint->NewState;
        RELEASE_STATECHG_LOCK(FdoDeviceObject, endpoint); 

        // endpoint needs to be checked,
        // since we are in DPC context we will be processing
        // all endpoints
        USBPORT_InvalidateEndpoint(FdoDeviceObject,
                                   endpoint,
                                   0);

        listEntry = 
            ExInterlockedRemoveHeadList(&devExt->Fdo.EpStateChangeList,
                                        &devExt->Fdo.EpStateChangeListSpin.sl);
    }

//#ifdef USBPERF
//    // always run the DPC worker from the timer to compensate for 
//    // reduced thread activity
//     USBPORT_DpcWorker(FdoDeviceObject);
//#else 
    if (HcInterrupt) {
        USBPORT_DpcWorker(FdoDeviceObject);
    } 
//#endif    

#if DBG    
    if (HcInterrupt) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'iDW-', 0, 
                0, 0);
    } else {
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'idw-', 0, 
                0, 0);
    }
#endif    

    InterlockedDecrement(&devExt->Fdo.WorkerDpc);
}


VOID
USBPORT_IsrDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL. 

    If the controller was the source of the interrupt this 
    routine will be called.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies the DeviceObject.

    SystemArgument1 - not used.
    
    SystemArgument2 - not used.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    BOOLEAN enableIrq;

    fdoDeviceObject = (PDEVICE_OBJECT) DeferredContext;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);    

    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'iDP+', fdoDeviceObject, 0, 0);

    KeAcquireSpinLockAtDpcLevel(&devExt->Fdo.IsrDpcSpin.sl);
    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'DPlk', fdoDeviceObject, 0, 0);
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_EN)) {
        enableIrq = TRUE;
    } else {        
        enableIrq = FALSE;
    }        
    MP_InterruptDpc(devExt, enableIrq);        
    KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.IsrDpcSpin.sl);
    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'DPuk', fdoDeviceObject, 0, 0);

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED)) {
        // if we take an interrupt while 'suspended' we treat 
        // this as a wakeup event.
        USBPORT_KdPrint((1, "  HC Wake Event\n"));
        USBPORT_CompletePdoWaitWake(fdoDeviceObject);
    } else {
        USBPORT_IsrDpcWorker(fdoDeviceObject, TRUE);   
    }            
    
    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'iDP-', 0, 
            0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\usbport\pnp.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    Port driver for