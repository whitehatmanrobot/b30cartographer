them
				for(DataCount = 0; DataCount < IrpHist->IrpDataCount; DataCount++)
				{
					sprintf(DataBuff, "%02x ", IrpHist->IrpData[DataCount]);
					strcat(StrBuff, DataBuff);
				}

				sprintf(DataBuff, "\n");

				strcat(StrBuff, DataBuff);

				// make sure it fits in buffer
				if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
					strcat(Buffer, StrBuff);
			}
		
			// point to the next entry in the IRP history table
			Index %= IRPHistorySize;
		}

		// if we don't have history, say so, but this should never happen (I think)
		if(!Hist)
		{
			sprintf(StrBuff, "No IRP history\n");

			// make sure it fits in buffer
			if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
				strcat(Buffer, StrBuff);
		}
	}

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);
} // Debug_ExtractIRPHist


/************************************************************************/
/*						Debug_ExtractPathHist							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Formats and places path history info into buffer.					*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	Buffer   - pointer to buffer to fill with path history.				*/
/*  BuffSize - size of Buffer.											*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_ExtractPathHist(OUT PCHAR Buffer, IN ULONG BuffSize)
{
	ULONG		Index, Size;
	PPATHHist	PHist;
	PCHAR		StrBuff;
	BOOLEAN		Hist = FALSE;
	
	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// title
	sprintf(StrBuff, "\n\n\nExecution Path History\n\n");

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);
		
	// see if path history is on
	if(DebugPathSize == 0L)
	{
		sprintf(StrBuff, "Path History is disabled\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
	}
	else
	{
		// columns	
		sprintf(StrBuff, "Time Stamp          Path\n\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
		
		Index = DebugPathIndex;

		for(Size = 0; Size < DebugPathSize; Size++)
		{
			// get pointer to current entry in path history
			PHist = &DebugPathHist[Index++];

			// parse timestamp and path and write to buffer. Check for NULL entries
			if(PHist->TimeStamp.LowPart)
			{
				// at least we have one entry
				Hist = TRUE;
			
				sprintf(StrBuff, "0x%08X%08X  %s\n", PHist->TimeStamp.HighPart, 
						PHist->TimeStamp.LowPart, PHist->Path);

				// make sure it fits in buffer
				if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
					strcat(Buffer, StrBuff);
			}
		
			// point to the next entry in path trace
			Index %= DebugPathSize;
		}

		// if we don't have history, say so, but this should never happen (I think)
		if(!Hist)
		{
			sprintf(StrBuff, "No execution path history\n");

			// make sure it fits in buffer
			if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
				strcat(Buffer, StrBuff);
		}
	}

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);
} // Debug_ExtractPathHist


/************************************************************************/
/*						Debug_ExtractErrorLog							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Formats and places error log info into buffer.						*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	Buffer   - pointer to buffer to fill with IRP history.				*/
/*  BuffSize - size of Buffer.											*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_ExtractErrorLog(OUT PCHAR Buffer, IN ULONG BuffSize)
{
	ULONG		Index, Size;
	PERRLog		ErrLog;
	PCHAR		StrBuff;
	BOOLEAN		Errors = FALSE;
	
	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// title
	sprintf(StrBuff, "\n\n\nError Log\n\n");

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);
		
	// see if error log is on
	if(ErrorLogSize == 0L)
	{
		sprintf(StrBuff, "Error Log is disabled\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
	}
	else
	{
		// columns	
		sprintf(StrBuff, "Time Stamp          Error\n\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
		
		Index = ErrorLogIndex;

		for(Size = 0; Size < ErrorLogSize; Size++)
		{
			// get pointer to current entry in error log
			ErrLog = &ErrorLog[Index++];

			// parse timestamp and error and write to buffer
			if(ErrLog->TimeStamp.LowPart)
			{
				// we have at least one error
				Errors = TRUE;
			
				sprintf(StrBuff, "0x%08X%08X  %s\n", ErrLog->TimeStamp.HighPart, 
						ErrLog->TimeStamp.LowPart, Debug_TranslateStatus(ErrLog->Status));

				// make sure it fits in buffer
				if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
					strcat(Buffer, StrBuff);
			}
		
			// point at next entry
			Index %= ErrorLogSize;
		}

		// if we don't have errors, say so
		if(!Errors)
		{
			sprintf(StrBuff, "No errors in log\n");

			// make sure it fits in buffer
			if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
				strcat(Buffer, StrBuff);
		}
	}

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);
} // Debug_ExtractErrorLog


/************************************************************************/
/*						Debug_DumpDriverLog								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Dumps all history and logging to buffer.							*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  DeviceObject - pointer to device object.							*/
/*																		*/
/*	Buffer        - pointer to buffer to fill with IRP history.			*/
/*  BuffSize      - size of pBuffer.									*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_DumpDriverLog(IN PDEVICE_OBJECT DeviceObject, OUT PCHAR Buffer, IN ULONG BuffSize)
{
	PCHAR		StrBuff;

	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// driver name and version, memory allocated
	sprintf(StrBuff, "\n\n\nDriver:	 %s\n\nVersion: %s\n\nMemory Allocated:          0x%08X\nMaximum Memory Allocated:  0x%08X\n",
			DriverName, DriverVersion, MemoryAllocated, MaxMemAllocated);

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);
		
	// memory allocation stats
	sprintf(StrBuff, "MemAlloc Count:            0x%08X\nMemFree Count:             0x%08X\nMemAlloc Fail Count:       0x%08X\nMemFree Fail Count:        0x%08X\n",
			MemAllocCnt, MemFreeCnt, MemAllocFailCnt, MemFreeFailCnt);

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);
		
	// get attached devices
	Debug_ExtractAttachedDevices(DeviceObject->DriverObject, Buffer, BuffSize);

	// get IRP history
	Debug_ExtractIRPHist(Buffer, BuffSize);

	// get execution path history
	Debug_ExtractPathHist(Buffer, BuffSize);

	// get error log
	Debug_ExtractErrorLog(Buffer, BuffSize);

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);
} // Debug_DumpDriverLog


/************************************************************************/
/*						Debug_TranslateStatus							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Translates NTSTATUS into ASCII string.								*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  NtStatus - NTSTATUS code.											*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	PCHAR - pointer to error string.									*/
/*																		*/
/************************************************************************/
PCHAR
Debug_TranslateStatus(IN NTSTATUS NtStatus)
{
	ULONG	Err;

	PAGED_CODE();

	for(Err = 0; Err < NumNTErrs; Err++)
	{
		if(NtStatus == NTErrors[Err].Code)
			return NTErrors[Err].Str;
	}

	// fell through, not an error we handle
	sprintf(UnknownStatus, "Unknown error 0x%08X", NtStatus);

	return UnknownStatus;
} // Debug_TranslateStatus


/************************************************************************/
/*						Debug_TranslateIoctl							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Translates IOCTL into ASCII string.									*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  Ioctl - ioctl code.													*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	PCHAR - pointer to error string.									*/
/*																		*/
/************************************************************************/
PCHAR
Debug_TranslateIoctl(IN LONG Ioctl)
{
	ULONG	Index;

	PAGED_CODE();

	// it's kind of repetitive to search at this point, but just in case
	// they change the actual IOCTLs we will be covered
	for(Index = 0; Index < NumIoctl; Index++)
	{
		if(Ioctl == IoctlCodes[Index].Code)
			return IoctlCodes[Index].Str;
	}

	// fell through, not an error we handle
	sprintf(UnknownIoctl, "0x%04X", Ioctl);

	return UnknownIoctl;
} // Debug_TranslateIoctl

#endif // PROFILING_ENABLED

VOID
Debug_CheckAllocations(VOID)
{
	DEBUG_TRACE1(("MemoryAllocated = 0x%08X\n", MemoryAllocated));
	DEBUG_TRACE1(("MemAllocCnt = 0x%08X   MemFreeCnt = 0x%08X\n",
				  MemAllocCnt, MemFreeCnt));
} // Debug_CheckAllocations

/************************************************************************/
/*						Debug_MemAlloc									*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Allocates block of memory. Stores length of block and a				*/
/*  signature ULONG for keeping track of amount of memory allocated		*/
/*  and checking for bogus calls to Debug_MemFree. The signature		*/
/*  can also be used to determine if someone has written past the		*/
/*	end of the block.													*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	PoolType      - Pool to allocate memory from.						*/
/*  NumberOfBytes - Number of bytes to allocate.						*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	PVOID - pointer to allocated memory.								*/
/*																		*/
/************************************************************************/
PVOID
Debug_MemAlloc(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
#ifdef _WIN64

	return ExAllocatePool(PoolType, NumberOfBytes);

#else
	PULONG	Mem;

	// allocate memory plus a little extra for our own use
	Mem = ExAllocatePool(PoolType, NumberOfBytes + (2 * sizeof(ULONG)));

	// see if we actually allocated any memory
	if(Mem)
	{
		// keep track of how much we allocated
		MemoryAllocated += NumberOfBytes;

		// see if we have a new maximum
		if(MemoryAllocated > MaxMemAllocated)
			MaxMemAllocated = MemoryAllocated;

		// store number of bytes allocated at start of memory allocated
		*Mem++ = NumberOfBytes;

		// now we are pointing at the memory allocated for caller
		// put signature word at end

		// get new pointer that points to end of buffer - ULONG
		Mem = (PULONG) (((PUCHAR) Mem) + NumberOfBytes);

		// write signature
		*Mem = MEM_ALLOC_SIGNATURE;

		// get back pointer to return to caller
		Mem = (PULONG) (((PUCHAR) Mem) - NumberOfBytes);

		// log stats
		MemAllocCnt++;
	}
	else
		// failed, log stats
		MemAllocFailCnt++;

	return (PVOID) Mem;

#endif

} // Debug_MemAlloc


/************************************************************************/
/*						Debug_MemFree									*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Frees memory allocated in call to Debug_MemAlloc. Checks for		*/
/*  signature ULONG at the end of allocated memory to make sure			*/
/*  this is a valid block to free.										*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	Mem - pointer to allocated block to free							*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID. Traps if it is an invalid block.								*/
/*																		*/
/************************************************************************/
VOID
Debug_MemFree(IN PVOID Mem)
{
#ifdef _WIN64

	ExFreePool(Mem);

#else
	PULONG	Tmp = (PULONG) Mem;
	ULONG	BuffSize;
	
	// point at size ULONG at start of buffer, and address to free
	Tmp--;

	// get the size of memory allocated by caller
	BuffSize = *Tmp;

	// point at signature and make sure it's O.K.
	((PCHAR) Mem) += BuffSize;

	if(*((PULONG) Mem) == MEM_ALLOC_SIGNATURE)
	{
		// let's go ahead and get rid of signature in case we get called
		// with this pointer again and memory is still paged in
		*((PULONG) Mem) = MEM_FREE_SIGNATURE;
		
		// adjust amount of memory allocated
		MemoryAllocated -= BuffSize;
		// free real pointer
		ExFreePool(Tmp);

		// log stats
		MemFreeCnt++;
	}
	else
	{
		// not a real allocated block, or someone wrote past the end
		MemFreeFailCnt++;
		DEBUG_TRAP();
	}
#endif
} // Debug_MemFree
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\read.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        READ.C

Abstract:

        Routines that perform read functionality

Environment:

        kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        9/25/98 : created

Authors:

        Louis J. Giliberto, Jr.


****************************************************************************/

#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "utils.h"
#include "debugwdm.h"

//
// PAGEUSBS is keyed off of UsbSer_Read, so UsbSer_Read must
// remain in PAGEUSBS for things to work properly
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEUSBS, UsbSerCancelCurrentRead)
#pragma alloc_text(PAGEUSBS, UsbSer_Read)
#pragma alloc_text(PAGEUSBS, UsbSerStartRead)
#pragma alloc_text(PAGEUSBS, UsbSerGrabReadFromRx)
#pragma alloc_text(PAGEUSBS, UsbSerReadTimeout)
#pragma alloc_text(PAGEUSBS, UsbSerIntervalReadTimeout)

#endif // ALLOC_PRAGMA


/************************************************************************/
/*                                              UsbSer_Read             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Process the IRPs sent to this device for Read calls             */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_Read(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
        NTSTATUS                        NtStatus =  STATUS_SUCCESS;
        PIO_STACK_LOCATION      IrpStack;
        PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;

        USBSER_LOCKED_PAGED_CODE();

        DEBUG_LOG_PATH("enter UsbSer_Read");
        UsbSerSerialDump(USBSERTRACERD, (">UsbSer_Read(%08X)\n", Irp));

        // set return values to something known
        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        DEBUG_TRACE2(("Read (%08X)\n", IrpStack->Parameters.Read.Length));

        UsbSerSerialDump(USBSERTRACE, ("UsbSer_Read Irp: %08X (%08X)\n", Irp,
                          IrpStack->Parameters.Read.Length));

        // make entry in IRP history table
        DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction,
                                           Irp->AssociatedIrp.SystemBuffer,
                                           IrpStack->Parameters.Read.Length);

        if (IrpStack->Parameters.Read.Length != 0) {
           NtStatus = UsbSerStartOrQueue(DeviceExtension, Irp,
                                     &DeviceExtension->ReadQueue,
                                     &DeviceExtension->CurrentReadIrp,
                                     UsbSerStartRead);
        } else {
           Irp->IoStatus.Status = NtStatus = STATUS_SUCCESS;
           Irp->IoStatus.Information = 0;


           CompleteIO(DeviceObject, Irp, IrpStack->MajorFunction,
                      Irp->AssociatedIrp.SystemBuffer,
                      Irp->IoStatus.Information);
        }

        // log an error if we got one
        DEBUG_LOG_ERROR(NtStatus);
        DEBUG_LOG_PATH("exit  UsbSer_Read");
        DEBUG_TRACE3(("status (%08X)\n", NtStatus));
        UsbSerSerialDump(USBSERTRACERD, ("<UsbSer_Read %08X\n", NtStatus));

        return NtStatus;
} // UsbSer_Read



NTSTATUS
UsbSerStartRead(IN PDEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This routine processes the active read request by initializing any timers,
   doing the initial submission to the read state machine, etc.

Arguments:

    PDevExt - Pointer to the device extension for the device to start a read on

Return Value:

    NTSTATUS

--*/
{
   NTSTATUS firstStatus = STATUS_SUCCESS;
   BOOLEAN setFirstStatus = FALSE;
   ULONG charsRead;
   KIRQL oldIrql;
   KIRQL controlIrql;
   PIRP newIrp;
   PIRP pReadIrp;
   ULONG readLen;
   ULONG multiplierVal;
   ULONG constantVal;
   BOOLEAN useTotalTimer;
   BOOLEAN returnWithWhatsPresent;
   BOOLEAN os2ssreturn;
   BOOLEAN crunchDownToOne;
   BOOLEAN useIntervalTimer;
   SERIAL_TIMEOUTS timeoutsForIrp;
   LARGE_INTEGER totalTime;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("Enter UsbSerStartRead");
   UsbSerSerialDump(USBSERTRACERD, (">UsbSerStartRead\n"));


   do {
      pReadIrp = PDevExt->CurrentReadIrp;
      readLen = IoGetCurrentIrpStackLocation(pReadIrp)->Parameters.Read.Length;


      PDevExt->NumberNeededForRead = readLen;

      DEBUG_TRACE3(("Start Reading %08X\n", PDevExt->NumberNeededForRead));

      useTotalTimer = FALSE;
      returnWithWhatsPresent = FALSE;
      os2ssreturn = FALSE;
      crunchDownToOne = FALSE;
      useIntervalTimer = FALSE;

      //
      // Always initialize the timer objects so that the
      // completion code can tell when it attempts to
      // cancel the timers whether the timers had ever
      // been Set.
      //

      ACQUIRE_SPINLOCK(PDevExt, &PDevExt->ControlLock, &controlIrql);
      timeoutsForIrp = PDevExt->Timeouts;
      PDevExt->CountOnLastRead = 0;
      RELEASE_SPINLOCK(PDevExt, &PDevExt->ControlLock, controlIrql);

      //
      // Calculate the interval timeout for the read
      //

      if (timeoutsForIrp.ReadIntervalTimeout
          && (timeoutsForIrp.ReadIntervalTimeout != MAXULONG)) {
         useIntervalTimer = TRUE;

         PDevExt->IntervalTime.QuadPart
         = UInt32x32To64(timeoutsForIrp.ReadIntervalTimeout, 10000);

         if (PDevExt->IntervalTime.QuadPart
             >= PDevExt->CutOverAmount.QuadPart) {
            PDevExt->IntervalTimeToUse = &PDevExt->LongIntervalAmount;
         } else {
            PDevExt->IntervalTimeToUse = &PDevExt->ShortIntervalAmount;
         }
      }


      if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG) {
         //
         // We need to do special return quickly stuff here.
         //
         // 1) If both constant and multiplier are
         //    0 then we return immediately with whatever
         //    we've got, even if it was zero.
         //
         // 2) If constant and multiplier are not MAXULONG
         //    then return immediately if any characters
         //    are present, but if nothing is there, then
         //    use the timeouts as specified.
         //
         // 3) If multiplier is MAXULONG then do as in
         //    "2" but return when the first character
         //    arrives.
         //

         if (!timeoutsForIrp.ReadTotalTimeoutConstant
             && !timeoutsForIrp.ReadTotalTimeoutMultiplier) {
            returnWithWhatsPresent = TRUE;
         } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                    && (timeoutsForIrp.ReadTotalTimeoutMultiplier
                        != MAXULONG)) {
            useTotalTimer = TRUE;
            os2ssreturn = TRUE;
            multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
            constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
         } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                    && (timeoutsForIrp.ReadTotalTimeoutMultiplier
                        == MAXULONG)) {
            useTotalTimer = TRUE;
            os2ssreturn = TRUE;
            crunchDownToOne = TRUE;
            multiplierVal = 0;
            constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
         }
      } else {
         //
         // If both the multiplier and the constant are
         // zero then don't do any total timeout processing.
         //

         if (timeoutsForIrp.ReadTotalTimeoutMultiplier
             || timeoutsForIrp.ReadTotalTimeoutConstant) {
            //
            // We have some timer values to calculate
            //

            useTotalTimer = TRUE;
            multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
            constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
         }
      }


      if (useTotalTimer) {
         totalTime.QuadPart
         = ((LONGLONG)(UInt32x32To64(PDevExt->NumberNeededForRead,
                                     multiplierVal) + constantVal)) * -10000;
      }


      if (PDevExt->CharsInReadBuff) {
         charsRead
         = GetData(PDevExt, ((PUCHAR)(pReadIrp->AssociatedIrp.SystemBuffer))
                   + readLen - PDevExt->NumberNeededForRead,
                   PDevExt->NumberNeededForRead,
                   &pReadIrp->IoStatus.Information);
      } else {
         charsRead = 0;
      }


      //
      // See if this read is complete
      //

      if (returnWithWhatsPresent || (PDevExt->NumberNeededForRead == 0)
          || (os2ssreturn && pReadIrp->IoStatus.Information)) {

#if DBG
if (UsbSerSerialDebugLevel & USBSERDUMPRD) {
      ULONG i;
      ULONG count;

      if (PDevExt->CurrentReadIrp->IoStatus.Status == STATUS_SUCCESS) {
         count = (ULONG)PDevExt->CurrentReadIrp->IoStatus.Information;
      } else {
         count = 0;

      }
      DbgPrint("RD3: A(%08X) G(%08X) I(%08X)\n",
               IoGetCurrentIrpStackLocation(PDevExt->CurrentReadIrp)
               ->Parameters.Read.Length, count, PDevExt->CurrentReadIrp);

      for (i = 0; i < count; i++) {
         DbgPrint("%02x ", *(((PUCHAR)PDevExt->CurrentReadIrp
                              ->AssociatedIrp.SystemBuffer) + i) & 0xFF);
      }

      if (i == 0) {
         DbgPrint("NULL (%08X)\n", PDevExt->CurrentReadIrp
                  ->IoStatus.Status);
      }

      DbgPrint("\n\n");
   }
#endif
         //
         // Update the amount of chars left in the ring buffer
         //

         pReadIrp->IoStatus.Status = STATUS_SUCCESS;

         if (!setFirstStatus) {
            firstStatus = STATUS_SUCCESS;
            setFirstStatus = TRUE;
         }
      } else {
         //
         // The irp may be given to the buffering routine
         //

         USBSER_INIT_REFERENCE(pReadIrp);

         ACQUIRE_CANCEL_SPINLOCK(PDevExt, &oldIrql);

         //
         // Check to see if it needs to be cancelled
         //

         if (pReadIrp->Cancel) {
            RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

            pReadIrp->IoStatus.Status = STATUS_CANCELLED;
            pReadIrp->IoStatus.Information = 0;

            if (!setFirstStatus) {
               setFirstStatus = TRUE;
               firstStatus = STATUS_CANCELLED;
            }

            UsbSerGetNextIrp(&PDevExt->CurrentReadIrp, &PDevExt->ReadQueue,
                             &newIrp, TRUE, PDevExt);
            continue;

         } else {

            //
            // If we are supposed to crunch the read down to
            // one character, then update the read length
            // in the irp and truncate the number needed for
            // read down to one.  Note that if we are doing
            // this crunching, then the information must be
            // zero (or we would have completed above) and
            // the number needed for the read must still be
            /// equal to the read length.
            //

            if (crunchDownToOne) {
               PDevExt->NumberNeededForRead = 1;
               IoGetCurrentIrpStackLocation(pReadIrp)->Parameters.Read.Length
               = 1;
            }

            USBSER_SET_REFERENCE(pReadIrp, USBSER_REF_RXBUFFER);
            USBSER_SET_REFERENCE(pReadIrp, USBSER_REF_CANCEL);

            if (useTotalTimer) {
               USBSER_SET_REFERENCE(pReadIrp, USBSER_REF_TOTAL_TIMER);
               KeSetTimer(&PDevExt->ReadRequestTotalTimer, totalTime,
                          &PDevExt->TotalReadTimeoutDpc);
            }

            if (useIntervalTimer) {
               USBSER_SET_REFERENCE(pReadIrp, USBSER_REF_INT_TIMER);
               KeQuerySystemTime(&PDevExt->LastReadTime);

               KeSetTimer(&PDevExt->ReadRequestIntervalTimer,
                          *PDevExt->IntervalTimeToUse,
                          &PDevExt->IntervalReadTimeoutDpc);
            }

            //
            // Mark IRP as cancellable
            //

            IoSetCancelRoutine(pReadIrp, UsbSerCancelCurrentRead);

            IoMarkIrpPending(pReadIrp);

            RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

            if (!setFirstStatus) {
               firstStatus = STATUS_PENDING;
            }
         }
         DEBUG_LOG_PATH("Exit UsbSerStartRead (1)\n");
         UsbSerSerialDump(USBSERTRACERD, ("<UsbSerStartRead (1) %08X\n",
                                        firstStatus));
         return firstStatus;
      }

      UsbSerGetNextIrp(&PDevExt->CurrentReadIrp, &PDevExt->ReadQueue,
                       &newIrp, TRUE, PDevExt);
   } while (newIrp != NULL);


   DEBUG_LOG_PATH("Exit UsbSerStartRead (2)\n");
   UsbSerSerialDump(USBSERTRACERD, ("<UsbSerStartRead (2) %08X\n",
                    firstStatus));
   return firstStatus;
}


BOOLEAN
UsbSerGrabReadFromRx(IN PVOID Context)
/*++

Routine Description:

    This routine is used to grab (if possible) the irp from the
    read callback mechanism.  If it finds that the rx still owns the irp it
    grabs the irp away and also decrements the reference count on the irp since
    it no longer belongs to the rx routine.

    NOTE: This routine assumes that it is called with the cancel spin
          lock and/or control lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)Context;

    USBSER_ALWAYS_LOCKED_CODE();

    UsbSerSerialDump(USBSERTRACERD, ("Enter UsbSerGrabReadFromRx\n"));


    USBSER_CLEAR_REFERENCE(pDevExt->CurrentReadIrp, USBSER_REF_RXBUFFER);

    UsbSerSerialDump(USBSERTRACERD, ("Exit UsbSerGrabReadFromRx\n"));

    return FALSE;
}


VOID
UsbSerCancelCurrentRead(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This routine is used to cancel the current read.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/
{

    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

    USBSER_ALWAYS_LOCKED_CODE();

    UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerCancelCurrentRead(%08X)\n",
                                      PIrp));

    //
    // We set this to indicate to the interval timer
    // that the read has encountered a cancel.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pDevExt->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;


    //
    // HACKHACK
    //

    UsbSerGrabReadFromRx(pDevExt);

    UsbSerTryToCompleteCurrent(pDevExt, PIrp->CancelIrql, STATUS_CANCELLED,
                               &pDevExt->CurrentReadIrp, &pDevExt->ReadQueue,
                               &pDevExt->ReadRequestIntervalTimer,
                               &pDevExt->ReadRequestTotalTimer,
                               UsbSerStartRead, UsbSerGetNextIrp,
                               USBSER_REF_CANCEL, TRUE);
    UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerCancelCurrentRead\n"));

}


VOID
UsbSerReadTimeout(IN PKDPC PDpc, IN PVOID DeferredContext,
                  IN PVOID SystemContext1, IN PVOID SystemContext2)

/*++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    PDpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION pDevExt = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    USBSER_ALWAYS_LOCKED_CODE();

    UsbSerSerialDump(USBSERTRACETM, (">UsbSerReadTimeout\n"));

    ACQUIRE_CANCEL_SPINLOCK(pDevExt, &oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed due to total timeout.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pDevExt->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

    //
    // HACKHACK
    //

    UsbSerGrabReadFromRx(pDevExt);

    UsbSerTryToCompleteCurrent(pDevExt, oldIrql, STATUS_TIMEOUT,
                               &pDevExt->CurrentReadIrp, &pDevExt->ReadQueue,
                               &pDevExt->ReadRequestIntervalTimer,
                               &pDevExt->ReadRequestTotalTimer, UsbSerStartRead,
                               UsbSerGetNextIrp, USBSER_REF_TOTAL_TIMER, TRUE);

    UsbSerSerialDump(USBSERTRACETM, ("<UsbSerReadTimeout\n"));
}


VOID
UsbSerIntervalReadTimeout(IN PKDPC PDpc, IN PVOID DeferredContext,
                          IN PVOID SystemContext1, IN PVOID SystemContext2)

/*++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    PDpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

   PDEVICE_EXTENSION pDevExt = DeferredContext;
   KIRQL oldIrql;
   KIRQL oldControlIrql;

   UNREFERENCED_PARAMETER(SystemContext1);
   UNREFERENCED_PARAMETER(SystemContext2);

   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACETM, (">UsbSerIntervalReadTimeout "));

   ACQUIRE_CANCEL_SPINLOCK(pDevExt, &oldIrql);


   if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) {
      UsbSerSerialDump(USBSERTRACETM, ("SERIAL_COMPLETE_READ_TOTAL\n"));

      //
      // This value is only set by the total
      // timer to indicate that it has fired.
      // If so, then we should simply try to complete.
      //

      //
      // HACKHACK
      //
      ACQUIRE_SPINLOCK(pDevExt, &pDevExt->ControlLock, &oldControlIrql);
      UsbSerGrabReadFromRx(pDevExt);
      pDevExt->CountOnLastRead = 0;
      RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldControlIrql);

      UsbSerTryToCompleteCurrent(pDevExt, oldIrql, STATUS_TIMEOUT,
                                 &pDevExt->CurrentReadIrp, &pDevExt->ReadQueue,
                                 &pDevExt->ReadRequestIntervalTimer,
                                 &pDevExt->ReadRequestTotalTimer,
                                 UsbSerStartRead, UsbSerGetNextIrp,
                                 USBSER_REF_INT_TIMER, TRUE);

   } else if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) {
      UsbSerSerialDump(USBSERTRACETM, ("SERIAL_COMPLETE_READ_COMPLETE\n"));

      //
      // This value is only set by the regular
      // completion routine.
      //
      // If so, then we should simply try to complete.
      //

      //
      // HACKHACK
      //


      ACQUIRE_SPINLOCK(pDevExt, &pDevExt->ControlLock, &oldControlIrql);
      UsbSerGrabReadFromRx(pDevExt);
      pDevExt->CountOnLastRead = 0;
      RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldControlIrql);

      UsbSerTryToCompleteCurrent(pDevExt, oldIrql, STATUS_SUCCESS,
                                &pDevExt->CurrentReadIrp, &pDevExt->ReadQueue,
                                &pDevExt->ReadRequestIntervalTimer,
                                &pDevExt->ReadRequestTotalTimer,
                                UsbSerStartRead, UsbSerGetNextIrp,
                                USBSER_REF_INT_TIMER, TRUE);

   } else if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) {
      UsbSerSerialDump(USBSERTRACETM, ("SERIAL_COMPLETE_READ_CANCEL\n"));

      //
      // This value is only set by the cancel
      // read routine.
      //
      // If so, then we should simply try to complete.
      //


      //
      // HACKHACK
      //

      ACQUIRE_SPINLOCK(pDevExt, &pDevExt->ControlLock, &oldControlIrql);
      UsbSerGrabReadFromRx(pDevExt);
      pDevExt->CountOnLastRead = 0;
      RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldControlIrql);

      UsbSerTryToCompleteCurrent(pDevExt, oldIrql, STATUS_CANCELLED,
                                &pDevExt->CurrentReadIrp, &pDevExt->ReadQueue,
                                &pDevExt->ReadRequestIntervalTimer,
                                &pDevExt->ReadRequestTotalTimer,
                                UsbSerStartRead, UsbSerGetNextIrp,
                                USBSER_REF_INT_TIMER, TRUE);

   } else if (pDevExt->CountOnLastRead || pDevExt->ReadByIsr) {
      //
      // Something has happened since we last came here.  We
      // check to see if the ISR has read in any more characters.
      // If it did then we should update the isr's read count
      // and resubmit the timer.
      //

      if (pDevExt->ReadByIsr) {
         UsbSerSerialDump(USBSERTRACETM, ("ReadByIsr\n"));

         pDevExt->CountOnLastRead = pDevExt->ReadByIsr;
         pDevExt->ReadByIsr = 0;

         //
         // Save off the "last" time something was read.
         // As we come back to this routine we will compare
         // the current time to the "last" time.  If the
         // difference is ever larger then the interval
         // requested by the user, then time out the request.
         //

         KeQuerySystemTime(&pDevExt->LastReadTime);

         KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                    *pDevExt->IntervalTimeToUse,
                    &pDevExt->IntervalReadTimeoutDpc);

         RELEASE_CANCEL_SPINLOCK(pDevExt, oldIrql);

      } else {
         //
         // Take the difference between the current time
         // and the last time we had characters and
         // see if it is greater then the interval time.
         // if it is, then time out the request.  Otherwise
         // go away again for a while.
         //

         //
         // No characters read in the interval time.  Kill
         // this read.
         //

         LARGE_INTEGER currentTime;

         UsbSerSerialDump(USBSERTRACETM, ("TIMEOUT\n"));

         KeQuerySystemTime(&currentTime);

         if ((currentTime.QuadPart - pDevExt->LastReadTime.QuadPart) >=
             pDevExt->IntervalTime.QuadPart) {

            pDevExt->CountOnLastRead = pDevExt->ReadByIsr = 0;

            //
            // HACKHACK
            //

            ACQUIRE_SPINLOCK(pDevExt, &pDevExt->ControlLock, &oldControlIrql);
            UsbSerGrabReadFromRx(pDevExt);
            RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldControlIrql);

            UsbSerTryToCompleteCurrent(pDevExt, oldIrql, STATUS_TIMEOUT,
                                       &pDevExt->CurrentReadIrp,
                                       &pDevExt->ReadQueue,
                                       &pDevExt->ReadRequestIntervalTimer,
                                       &pDevExt->ReadRequestTotalTimer,
                                       UsbSerStartRead, UsbSerGetNextIrp,
                                       USBSER_REF_INT_TIMER, TRUE);

         } else {
            KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                       *pDevExt->IntervalTimeToUse,
                       &pDevExt->IntervalReadTimeoutDpc);

            RELEASE_CANCEL_SPINLOCK(pDevExt, oldIrql);
         }
      }
   } else {
      //
      // Timer doesn't really start until the first character.
      // So we should simply resubmit ourselves.
      //

      UsbSerSerialDump(USBSERTRACETM, ("-\n"));

      KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                 *pDevExt->IntervalTimeToUse, &pDevExt->IntervalReadTimeoutDpc);

      RELEASE_CANCEL_SPINLOCK(pDevExt, oldIrql);
   }

   UsbSerSerialDump(USBSERTRACETM, ("<UsbSerIntervalReadTimeout\n"));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbmass\usbmass.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    USBMASS.C

Abstract:

    This source file contains the DriverEntry() and AddDevice() entry points
    for the USBSTOR driver and the dispatch routines which handle:

    IRP_MJ_POWER
    IRP_MJ_SYSTEM_CONTROL
    IRP_MJ_PNP

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <ntddk.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <initguid.h>
#include <usbbusif.h>
#include <stdio.h>

#include "usbmass.h"

//*****************************************************************************
// L O C A L    F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

NTSTATUS
USBSTOR_GetBusInterface (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PUSB_BUS_INTERFACE_USBDI_V1  BusInterface
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, USBSTOR_Unload)
#pragma alloc_text(PAGE, USBSTOR_AddDevice)
#pragma alloc_text(PAGE, USBSTOR_QueryFdoParams)
#pragma alloc_text(PAGE, USBSTOR_Power)
#pragma alloc_text(PAGE, USBSTOR_FdoSetPower)
#pragma alloc_text(PAGE, USBSTOR_SystemControl)
#pragma alloc_text(PAGE, USBSTOR_Pnp)
#pragma alloc_text(PAGE, USBSTOR_FdoStartDevice)
#pragma alloc_text(PAGE, USBSTOR_GetDescriptors)
#pragma alloc_text(PAGE, USBSTOR_GetStringDescriptors)
#pragma alloc_text(PAGE, USBSTOR_AdjustConfigurationDescriptor)
#pragma alloc_text(PAGE, USBSTOR_GetPipes)
#pragma alloc_text(PAGE, USBSTOR_CreateChildPDO)
#pragma alloc_text(PAGE, USBSTOR_FdoStopDevice)
#pragma alloc_text(PAGE, USBSTOR_FdoRemoveDevice)
#pragma alloc_text(PAGE, USBSTOR_FdoQueryStopRemoveDevice)
#pragma alloc_text(PAGE, USBSTOR_FdoCancelStopRemoveDevice)
#pragma alloc_text(PAGE, USBSTOR_FdoQueryDeviceRelations)
#pragma alloc_text(PAGE, USBSTOR_FdoQueryCapabilities)
#pragma alloc_text(PAGE, USBSTOR_PdoStartDevice)
#pragma alloc_text(PAGE, USBSTOR_PdoRemoveDevice)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryID)
#pragma alloc_text(PAGE, USBSTOR_PdoDeviceTypeString)
#pragma alloc_text(PAGE, USBSTOR_PdoGenericTypeString)
#pragma alloc_text(PAGE, CopyField)
#pragma alloc_text(PAGE, USBSTOR_StringArrayToMultiSz)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryDeviceId)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryHardwareIds)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryCompatibleIds)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryDeviceText)
#pragma alloc_text(PAGE, USBSTOR_PdoBusQueryInstanceId)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryDeviceRelations)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryCapabilities)
#pragma alloc_text(PAGE, USBSTOR_SyncPassDownIrp)
#pragma alloc_text(PAGE, USBSTOR_SyncSendUsbRequest)
#pragma alloc_text(PAGE, USBSTOR_GetDescriptor)
#pragma alloc_text(PAGE, USBSTOR_GetMaxLun)
#pragma alloc_text(PAGE, USBSTOR_SelectConfiguration)
#pragma alloc_text(PAGE, USBSTOR_UnConfigure)
#pragma alloc_text(PAGE, USBSTOR_ResetPipe)
#pragma alloc_text(PAGE, USBSTOR_AbortPipe)
#pragma alloc_text(PAGE, USBSTOR_GetBusInterface)
#endif



//******************************************************************************
//
// DriverEntry()
//
//******************************************************************************

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
    PAGED_CODE();

#if DBG
    // Query the registry for global parameters
    //
    USBSTOR_QueryGlobalParams();
#endif

    DBGPRINT(2, ("enter: DriverEntry\n"));

    DBGFBRK(DBGF_BRK_DRIVERENTRY);

    LOGINIT();

    //
    // Initialize the Driver Object with the driver's entry points
    //

    //
    // USBMASS.C
    //
    DriverObject->DriverUnload                          = USBSTOR_Unload;
    DriverObject->DriverExtension->AddDevice            = USBSTOR_AddDevice;

    //
    // OCRW.C
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = USBSTOR_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = USBSTOR_Close;
    DriverObject->MajorFunction[IRP_MJ_READ]            = USBSTOR_ReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]           = USBSTOR_ReadWrite;

    //
    // SCSI.C
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = USBSTOR_DeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SCSI]            = USBSTOR_Scsi;
    DriverObject->DriverStartIo                         = USBSTOR_StartIo;

    //
    // USBMASS.C
    //
    DriverObject->MajorFunction[IRP_MJ_POWER]           = USBSTOR_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = USBSTOR_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = USBSTOR_Pnp;

    DBGPRINT(2, ("exit:  DriverEntry\n"));

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// USBSTOR_Unload()
//
//******************************************************************************

VOID
USBSTOR_Unload (
    IN PDRIVER_OBJECT   DriverObject
    )
{
    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_Unload\n"));

    LOGENTRY('UNLD', DriverObject, 0, 0);

    DBGFBRK(DBGF_BRK_UNLOAD);

    LOGUNINIT();

    DBGPRINT(2, ("exit:  USBSTOR_Unload\n"));
}

//******************************************************************************
//
// USBSTOR_AddDevice()
//
//******************************************************************************

NTSTATUS
USBSTOR_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
{
    PDEVICE_OBJECT          deviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_AddDevice\n"));

    LOGENTRY('ADDD', DriverObject, PhysicalDeviceObject, 0);

    DBGFBRK(DBGF_BRK_ADDDEVICE);

    // Create the FDO
    //
    ntStatus = IoCreateDevice(DriverObject,
                              sizeof(FDO_DEVICE_EXTENSION),
                              NULL,
                              FILE_DEVICE_BUS_EXTENDER,
                              FILE_AUTOGENERATED_DEVICE_NAME,
                              FALSE,
                              &deviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    // StartIo should not be called recursively and should be deferred until
    // the previous StartIo call returns to the IO manager.  This will prevent
    // a recursive stack overflow death if a device error occurs when there
    // are many requests queued on the device queue.
    //
    IoSetStartIoAttributes(deviceObject,
                           TRUE,            // DeferredStartIo
                           FALSE            // NonCancelable
                          );

    // Initialize the FDO DeviceExtension
    //
    fdoDeviceExtension = deviceObject->DeviceExtension;

    // Set all DeviceExtension pointers to NULL and all variable to zero
    //
    RtlZeroMemory(fdoDeviceExtension, sizeof(FDO_DEVICE_EXTENSION));

    // Tag this as the FDO on top of the USB PDO
    //
    fdoDeviceExtension->Type = USBSTOR_DO_TYPE_FDO;

    // Store a back point to the DeviceObject to which the DeviceExtension
    // is attached.
    //
    fdoDeviceExtension->FdoDeviceObject = deviceObject;

    // Remember our PDO
    //
    fdoDeviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    // Attach the FDO we created to the top of the PDO stack
    //
    fdoDeviceExtension->StackDeviceObject = IoAttachDeviceToDeviceStack(
                                                deviceObject,
                                                PhysicalDeviceObject);

    // Initialize the list of child PDOs
    //
    InitializeListHead(&fdoDeviceExtension->ChildPDOs);

    // Initialize to one in AddDevice, decrement by one in REMOVE_DEVICE
    //
    fdoDeviceExtension->PendingIoCount = 1;

    // Initialize the event which is set when OpenCount is decremented to zero.
    //
    KeInitializeEvent(&fdoDeviceExtension->RemoveEvent,
                      SynchronizationEvent,
                      FALSE);

    // Set the initial system and device power states
    //
    fdoDeviceExtension->SystemPowerState = PowerSystemWorking;
    fdoDeviceExtension->DevicePowerState = PowerDeviceD0;

    KeInitializeEvent(&fdoDeviceExtension->PowerDownEvent,
                      SynchronizationEvent,
                      FALSE);

    // Initialize the spinlock which protects the PDO DeviceFlags
    //
    KeInitializeSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock);

    KeInitializeEvent(&fdoDeviceExtension->CancelEvent,
                      SynchronizationEvent,
                      FALSE);

    // Initialize timeout timer
    //
    IoInitializeTimer(deviceObject, USBSTOR_TimerTick, NULL);

    USBSTOR_QueryFdoParams(deviceObject);

    fdoDeviceExtension->LastSenseWasReset = TRUE;

    deviceObject->Flags |=  DO_DIRECT_IO;
    deviceObject->Flags |=  DO_POWER_PAGABLE;
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    DBGPRINT(2, ("exit:  USBSTOR_AddDevice\n"));

    LOGENTRY('addd', deviceObject, fdoDeviceExtension,
             fdoDeviceExtension->StackDeviceObject);

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// USBSTOR_QueryFdoParams()
//
// This is called at AddDevice() time when the FDO is being created to query
// device parameters from the registry.
//
//******************************************************************************

VOID
USBSTOR_QueryFdoParams (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION       fdoDeviceExtension;
    RTL_QUERY_REGISTRY_TABLE    paramTable[3];
    ULONG                       driverFlags;
    ULONG                       nonRemovable;
    HANDLE                      handle;
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_QueryFdoParams\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Set the default value in case the registry key does not exist.
    // Currently the flags are only used to specify the device protocol:
    // {Bulk-Only, Control/Bulk/Interrupt, Control/Bulk}
    //
    // If the driver is loaded during textmode setup then the registry key
    // will not yet exist.  That should be the only case in which the registry
    // key does not exist.  In this case DeviceProtocolUnspecified will be
    // treated as DeviceProtocolCB.  If that causes the first request to fail
    // then we will switch to DeviceProtocolBulkOnly.
    //
    driverFlags = DeviceProtocolUnspecified;

    nonRemovable = 0;

    ntStatus = IoOpenDeviceRegistryKey(
                   fdoDeviceExtension->PhysicalDeviceObject,
                   PLUGPLAY_REGKEY_DRIVER,
                   STANDARD_RIGHTS_ALL,
                   &handle);

    if (NT_SUCCESS(ntStatus))
    {
        RtlZeroMemory (&paramTable[0], sizeof(paramTable));

        paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name          = L"DriverFlags";
        paramTable[0].EntryContext  = &driverFlags;
        paramTable[0].DefaultType   = REG_BINARY;
        paramTable[0].DefaultData   = &driverFlags;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name          = L"NonRemovable";
        paramTable[1].EntryContext  = &nonRemovable;
        paramTable[1].DefaultType   = REG_BINARY;
        paramTable[1].DefaultData   = &nonRemovable;
        paramTable[1].DefaultLength = sizeof(ULONG);

        RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                               (PCWSTR)handle,
                               &paramTable[0],
                               NULL,           // Context
                               NULL);          // Environment

        ZwClose(handle);
    }

    if (driverFlags >= DeviceProtocolLast)
    {
        driverFlags = DeviceProtocolUnspecified;
    }

    fdoDeviceExtension->DriverFlags = driverFlags;

    fdoDeviceExtension->NonRemovable = nonRemovable;

    DBGPRINT(2, ("deviceFlags  %08X\n", driverFlags));

    DBGPRINT(2, ("nonRemovable %08X\n", nonRemovable));

    DBGPRINT(2, ("exit:  USBSTOR_QueryFdoParams\n"));
}

//******************************************************************************
//
// USBSTOR_Power()
//
// Dispatch routine which handles IRP_MJ_POWER
//
//******************************************************************************

NTSTATUS
USBSTOR_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: USBSTOR_Power %s %08X %08X %s\n",
                 (deviceExtension->Type == USBSTOR_DO_TYPE_FDO) ?
                 "FDO" : "PDO",
                 DeviceObject,
                 Irp,
                 PowerMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY('POWR', DeviceObject, Irp, irpStack->MinorFunction);

    if (irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
        DBGPRINT(2, ("%s IRP_MN_SET_POWER %s\n",
                     (deviceExtension->Type == USBSTOR_DO_TYPE_FDO) ?
                     "FDO" : "PDO",
                     (irpStack->Parameters.Power.Type == SystemPowerState) ?
                     PowerSystemStateString(irpStack->Parameters.Power.State.SystemState) :
                     PowerDeviceStateString(irpStack->Parameters.Power.State.DeviceState)));
    }

    if (deviceExtension->Type == USBSTOR_DO_TYPE_FDO)
    {
        // This is an FDO attached to the USB PDO.
        //
        fdoDeviceExtension = (PFDO_DEVICE_EXTENSION)deviceExtension;

        if (irpStack->MinorFunction == IRP_MN_SET_POWER)
        {
            // Handle powering the FDO down and up...
            //
            ntStatus = USBSTOR_FdoSetPower(DeviceObject,
                                           Irp);
        }
        else
        {
            // No special processing for IRP_MN_QUERY_POWER, IRP_MN_WAIT_WAKE,
            // or IRP_MN_POWER_SEQUENCE at this time.  Just pass the request
            // down to the next lower driver now.
            //
            PoStartNextPowerIrp(Irp);

            IoSkipCurrentIrpStackLocation(Irp);

            ntStatus = PoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                    Irp);
        }
    }
    else
    {
        // This is a PDO enumerated by our FDO.

        if (irpStack->MinorFunction == IRP_MN_SET_POWER)
        {
            // Handle powering the PDO down and up...
            //
            ntStatus = USBSTOR_PdoSetPower(DeviceObject,
                                           Irp);
        }
        else
        {
            if (irpStack->MinorFunction == IRP_MN_QUERY_POWER)
            {
                // Always return SUCCESS for IRP_MN_QUERY_POWER for the PDO.
                //
                ntStatus = STATUS_SUCCESS;

                Irp->IoStatus.Status = ntStatus;
            }
            else
            {
                // No special processing for IRP_MN_WAIT_WAKE or
                // IRP_MN_POWER_SEQUENCE.  Just complete the request
                // now without changing the status.
                //
                ntStatus = Irp->IoStatus.Status;
            }

            PoStartNextPowerIrp(Irp);

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_Power %08X\n", ntStatus));

    LOGENTRY('powr', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoSetPower()
//
// Dispatch routine which handles IRP_MJ_POWER, IRP_MN_SET_POWER for the FDO
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    POWER_STATE_TYPE        powerType;
    POWER_STATE             powerState;
    POWER_STATE             newState;
    BOOLEAN                 passRequest;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;

    powerState = irpStack->Parameters.Power.State;

    DBGPRINT(2, ("enter: USBSTOR_FdoSetPower %08X %s\n",
                 DeviceObject,
                 (powerType == SystemPowerState) ?
                 PowerSystemStateString(powerState.SystemState) :
                 PowerDeviceStateString(powerState.DeviceState)));

    LOGENTRY('FDSP', DeviceObject, Irp, irpStack->MinorFunction);

    // Pass the request down here, unless we request a device state power
    // Irp, in which case we pass the request down in our completion routine.
    //
    passRequest = TRUE;

    if (powerType == SystemPowerState)
    {
        // Remember the current system state.
        //
        fdoDeviceExtension->SystemPowerState = powerState.SystemState;

        // Map the new system state to a new device state
        //
        if (powerState.SystemState != PowerSystemWorking)
        {
            newState.DeviceState = PowerDeviceD3;
        }
        else
        {
            newState.DeviceState = PowerDeviceD0;
        }

        // If the new device state is different than the current device
        // state, request a device state power Irp.
        //
        if (fdoDeviceExtension->DevicePowerState != newState.DeviceState)
        {
            DBGPRINT(2, ("Requesting power Irp %08X %08X from %s to %s\n",
                         DeviceObject, Irp,
                         PowerDeviceStateString(fdoDeviceExtension->DevicePowerState),
                         PowerDeviceStateString(newState.DeviceState)));

            ASSERT(fdoDeviceExtension->CurrentPowerIrp == NULL);

            fdoDeviceExtension->CurrentPowerIrp = Irp;

            ntStatus = PoRequestPowerIrp(fdoDeviceExtension->PhysicalDeviceObject,
                                         IRP_MN_SET_POWER,
                                         newState,
                                         USBSTOR_FdoSetPowerCompletion,
                                         DeviceObject,
                                         NULL);

            passRequest = FALSE;
        }
    }
    else if (powerType == DevicePowerState)
    {
        POWER_STATE oldState;

        DBGPRINT(2, ("Received power Irp %08X %08X from %s to %s\n",
                     DeviceObject, Irp,
                     PowerDeviceStateString(fdoDeviceExtension->DevicePowerState),
                     PowerDeviceStateString(powerState.DeviceState)));

        // Update the current device state.
        //
        oldState.DeviceState = fdoDeviceExtension->DevicePowerState;
        fdoDeviceExtension->DevicePowerState = powerState.DeviceState;

        if (oldState.DeviceState == PowerDeviceD0 &&
            powerState.DeviceState > PowerDeviceD0)
        {
            // Powering down.  Stick this Irp in the device queue and
            // then wait.  When USBSTOR_StartIo() pulls this Irp out
            // of the device queue, we'll know that no transfer requests
            // are active at that time and then this power Irp can be
            // passed down the stack.

            ULONG zero;

            DBGPRINT(2, ("FDO Powering Down\n"));

            LOGENTRY('PWRD', DeviceObject, Irp, 0);

            zero = 0;  // Front of the queue please

            IoStartPacket(DeviceObject,
                          Irp,
                          &zero,
                          NULL);

            KeWaitForSingleObject(&fdoDeviceExtension->PowerDownEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else if (oldState.DeviceState > PowerDeviceD0 &&
                 powerState.DeviceState == PowerDeviceD0)
        {
            DBGPRINT(2, ("PDO Powering Up\n"));

            LOGENTRY('PWRU', DeviceObject, Irp, 0);

            IoCopyCurrentIrpStackLocationToNext(Irp);

            IoSetCompletionRoutine(Irp,
                                   USBSTOR_FdoSetPowerD0Completion,
                                   NULL,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            ntStatus = PoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                    Irp);

            passRequest = FALSE;

        }
    }

    if (passRequest)
    {
        //
        // Pass the request down to the next lower driver
        //
        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                Irp);
    }

    DBGPRINT(2, ("exit:  USBSTOR_FdoSetPower %08X\n", ntStatus));

    LOGENTRY('fdsp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoSetPowerCompletion()
//
// Completion routine for PoRequestPowerIrp() in USBSTOR_FdoSetPower.
//
// The purpose of this routine is to block passing down the SystemPowerState
// Irp until the requested DevicePowerState Irp completes.
//
//******************************************************************************

VOID
USBSTOR_FdoSetPowerCompletion(
    IN PDEVICE_OBJECT   PdoDeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIRP                    irp;
    NTSTATUS                ntStatus;

    fdoDeviceObject = (PDEVICE_OBJECT)Context;

    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    ASSERT(fdoDeviceExtension->CurrentPowerIrp != NULL);

    irp = fdoDeviceExtension->CurrentPowerIrp;

    fdoDeviceExtension->CurrentPowerIrp = NULL;

#if DBG
    {
        PIO_STACK_LOCATION  irpStack;
        SYSTEM_POWER_STATE  systemState;

        irpStack = IoGetCurrentIrpStackLocation(irp);

        systemState = irpStack->Parameters.Power.State.SystemState;

        ntStatus = IoStatus->Status;

        DBGPRINT(2, ("USBSTOR_FdoSetPowerCompletion %08X %08X %s %08X\n",
                     fdoDeviceObject, irp,
                     PowerSystemStateString(systemState),
                     ntStatus));

        LOGENTRY('fspc', fdoDeviceObject, systemState, ntStatus);
    }
#endif

    // The requested DevicePowerState Irp has completed.
    // Now pass down the SystemPowerState Irp which requested the
    // DevicePowerState Irp.

    PoStartNextPowerIrp(irp);

    IoCopyCurrentIrpStackLocationToNext(irp);

    // Mark the Irp pending since USBSTOR_FdoSetPower() would have
    // originally returned STATUS_PENDING after calling PoRequestPowerIrp().
    //
    IoMarkIrpPending(irp);

    ntStatus = PoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            irp);
}

//******************************************************************************
//
// USBSTOR_FdoSetPowerD0Completion()
//
// Completion routine used by USBSTOR_FdoSetPower when passing down a
// IRP_MN_SET_POWER DevicePowerState PowerDeviceD0 Irp for the FDO.
//
// The purpose of this routine is to delay unblocking the device queue
// until after the DevicePowerState PowerDeviceD0 Irp completes.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoSetPowerD0Completion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{

    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    DEVICE_POWER_STATE      deviceState;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceState = irpStack->Parameters.Power.State.DeviceState;
    ASSERT(deviceState == PowerDeviceD0);

    ntStatus = Irp->IoStatus.Status;

    DBGPRINT(2, ("USBSTOR_FdoSetPowerD0Completion %08X %08X %s %08X\n",
                 DeviceObject, Irp,
                 PowerDeviceStateString(deviceState),
                 ntStatus));

    LOGENTRY('fs0c', DeviceObject, deviceState, ntStatus);

    // Powering up.  Unblock the device queue which was left blocked
    // after USBSTOR_StartIo() passed down the power down Irp.

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    {
        IoStartNextPacket(DeviceObject, TRUE);
    }
    KeLowerIrql(irql);

    PoStartNextPowerIrp(Irp);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoSetPower()
//
// Dispatch routine which handles IRP_MJ_POWER, IRP_MN_SET_POWER for the PDO
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    POWER_STATE_TYPE        powerType;
    POWER_STATE             powerState;
    BOOLEAN                 completeRequest;
    NTSTATUS                ntStatus;

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;

    powerState = irpStack->Parameters.Power.State;

    DBGPRINT(2, ("enter: USBSTOR_PdoSetPower %08X %s\n",
                 DeviceObject,
                 (powerType == SystemPowerState) ?
                 PowerSystemStateString(powerState.SystemState) :
                 PowerDeviceStateString(powerState.DeviceState)));

    LOGENTRY('PDSP', DeviceObject, Irp, irpStack->MinorFunction);

    // Complete the request here, unless we are powering up or down and need
    // to wait before completing the request later.
    //
    completeRequest = TRUE;

    if (powerType == SystemPowerState)
    {
        POWER_STATE newState;

        // Update the current system state.
        //
        pdoDeviceExtension->SystemPowerState = powerState.SystemState;

        // Map the new system state to a new device state
        //
        if (powerState.SystemState != PowerSystemWorking)
        {
            newState.DeviceState = PowerDeviceD3;
        }
        else
        {
            newState.DeviceState = PowerDeviceD0;
        }

        // If the new device state is different than the current device
        // state, request a device state power Irp.
        //
        if (pdoDeviceExtension->DevicePowerState != newState.DeviceState)
        {
            DBGPRINT(2, ("Requesting power Irp %08X %08X from %s to %s\n",
                         DeviceObject, Irp,
                         PowerDeviceStateString(pdoDeviceExtension->DevicePowerState),
                         PowerDeviceStateString(newState.DeviceState)));

            ASSERT(pdoDeviceExtension->CurrentPowerIrp == NULL);

            pdoDeviceExtension->CurrentPowerIrp = Irp;

            ntStatus = PoRequestPowerIrp(DeviceObject,
                                         IRP_MN_SET_POWER,
                                         newState,
                                         USBSTOR_PdoSetPowerCompletion,
                                         NULL,
                                         NULL);

            ASSERT(ntStatus == STATUS_PENDING);

            completeRequest = FALSE;
        }
    }
    else if (powerType == DevicePowerState)
    {
        POWER_STATE oldState;

        DBGPRINT(2, ("Received power Irp %08X %08X from %s to %s\n",
                     DeviceObject, Irp,
                     PowerDeviceStateString(pdoDeviceExtension->DevicePowerState),
                     PowerDeviceStateString(powerState.DeviceState)));

        // Update the current device state.
        //
        oldState.DeviceState = pdoDeviceExtension->DevicePowerState;
        pdoDeviceExtension->DevicePowerState = powerState.DeviceState;

        if (oldState.DeviceState == PowerDeviceD0 &&
            powerState.DeviceState > PowerDeviceD0)
        {
            // Powering down.

            DBGPRINT(2, ("PDO Powering Down\n"));

            LOGENTRY('pwrd', DeviceObject, Irp, 0);
        }
        else if (oldState.DeviceState > PowerDeviceD0 &&
                 powerState.DeviceState == PowerDeviceD0)
        {
            // Powering up.

            DBGPRINT(2, ("PDO Powering Up\n"));

            LOGENTRY('pwru', DeviceObject, Irp, 0);
        }
    }

    if (completeRequest)
    {
        ntStatus = STATUS_SUCCESS;
        Irp->IoStatus.Status = ntStatus;

        PoStartNextPowerIrp(Irp);

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  USBSTOR_PdoSetPower %08X\n", ntStatus));

    LOGENTRY('pdsp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoSetPowerCompletion()
//
// Completion routine for PoRequestPowerIrp() in USBSTOR_PdoSetPower.
//
// The purpose of this routine is to block completing the SystemPowerState
// Irp until the requested DevicePowerState Irp completes.
//
//******************************************************************************

VOID
USBSTOR_PdoSetPowerCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIRP                    irp;

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    ASSERT(pdoDeviceExtension->CurrentPowerIrp != NULL);

    irp = pdoDeviceExtension->CurrentPowerIrp;

    pdoDeviceExtension->CurrentPowerIrp = NULL;

#if DBG
    {
        PIO_STACK_LOCATION  irpStack;
        SYSTEM_POWER_STATE  systemState;
        NTSTATUS            ntStatus;

        irpStack = IoGetCurrentIrpStackLocation(irp);

        systemState = irpStack->Parameters.Power.State.SystemState;

        ntStatus = IoStatus->Status;

        DBGPRINT(2, ("USBSTOR_PdoSetPowerCompletion %08X %08X %s %08X\n",
                     DeviceObject, irp,
                     PowerSystemStateString(systemState),
                     ntStatus));

        LOGENTRY('pspc', DeviceObject, systemState, ntStatus);
    }
#endif

    // The requested DevicePowerState Irp has completed.
    // Now complete the SystemPowerState Irp which requested the
    // DevicePowerState Irp.

    // Mark the Irp pending since USBSTOR_PdoSetPower() would have
    // originally returned STATUS_PENDING after calling PoRequestPowerIrp().
    //
    IoMarkIrpPending(irp);

    irp->IoStatus.Status = STATUS_SUCCESS;

    PoStartNextPowerIrp(irp);

    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

//******************************************************************************
//
// USBSTOR_SystemControl()
//
// Dispatch routine which handles IRP_MJ_SYSTEM_CONTROL
//
//******************************************************************************

NTSTATUS
USBSTOR_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: USBSTOR_SystemControl %2X\n", irpStack->MinorFunction));

    LOGENTRY('SYSC', DeviceObject, Irp, irpStack->MinorFunction);

    if (deviceExtension->Type == USBSTOR_DO_TYPE_FDO)
    {
        // This is an FDO attached to the USB PDO.
        //
        fdoDeviceExtension = DeviceObject->DeviceExtension;

        switch (irpStack->MinorFunction)
        {
            //
            // XXXXX Need to handle any of these?
            //

            default:
                //
                // Pass the request down to the next lower driver
                //
                IoSkipCurrentIrpStackLocation(Irp);

                ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                        Irp);
            break;
        }
    }
    else
    {
        // This is a PDO enumerated by our FDO.

        ntStatus = Irp->IoStatus.Status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  USBSTOR_SystemControl %08X\n", ntStatus));

    LOGENTRY('sysc', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_Pnp()
//
// Dispatch routine which handles IRP_MJ_PNP
//
//******************************************************************************

NTSTATUS
USBSTOR_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: USBSTOR_Pnp %s\n",
                 PnPMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY('PNP ', DeviceObject, Irp, irpStack->MinorFunction);

    if (deviceExtension->Type == USBSTOR_DO_TYPE_FDO)
    {
        // This is an FDO attached to the USB PDO.
        // We have some real work to do.
        //
        fdoDeviceExtension = DeviceObject->DeviceExtension;

        switch (irpStack->MinorFunction)
        {
            case IRP_MN_START_DEVICE:
                ntStatus = USBSTOR_FdoStartDevice(DeviceObject, Irp);
                break;

            case IRP_MN_STOP_DEVICE:
                ntStatus = USBSTOR_FdoStopDevice(DeviceObject, Irp);
                break;

            case IRP_MN_REMOVE_DEVICE:
                ntStatus = USBSTOR_FdoRemoveDevice(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_STOP_DEVICE:
            case IRP_MN_QUERY_REMOVE_DEVICE:
                ntStatus = USBSTOR_FdoQueryStopRemoveDevice(DeviceObject, Irp);
                break;

            case IRP_MN_CANCEL_STOP_DEVICE:
            case IRP_MN_CANCEL_REMOVE_DEVICE:
                ntStatus = USBSTOR_FdoCancelStopRemoveDevice(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                ntStatus = USBSTOR_FdoQueryDeviceRelations(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                ntStatus = USBSTOR_FdoQueryCapabilities(DeviceObject, Irp);
                break;

            case IRP_MN_SURPRISE_REMOVAL:
                //
                // The documentation says to set the status before passing the
                // Irp down the stack
                //
                Irp->IoStatus.Status = STATUS_SUCCESS;

                // nothing else special yet, just fall through to default

            default:
                //
                // Pass the request down to the next lower driver
                //
                IoSkipCurrentIrpStackLocation(Irp);

                ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                        Irp);
                break;
        }
    }
    else
    {
        // This is a PDO enumerated by our FDO.
        // We don't have too much to do.
        //
        pdoDeviceExtension = DeviceObject->DeviceExtension;
        ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

        switch (irpStack->MinorFunction)
        {
            case IRP_MN_START_DEVICE:
                ntStatus = USBSTOR_PdoStartDevice(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_ID:
                ntStatus = USBSTOR_PdoQueryID(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_DEVICE_TEXT:
                ntStatus = USBSTOR_PdoQueryDeviceText(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                ntStatus = USBSTOR_PdoQueryDeviceRelations(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                ntStatus = USBSTOR_PdoQueryCapabilities(DeviceObject, Irp);
                break;

            case IRP_MN_REMOVE_DEVICE:
                ntStatus = USBSTOR_PdoRemoveDevice(DeviceObject, Irp);
                break;

            case IRP_MN_SURPRISE_REMOVAL:
            case IRP_MN_STOP_DEVICE:
            case IRP_MN_QUERY_STOP_DEVICE:
            case IRP_MN_QUERY_REMOVE_DEVICE:
            case IRP_MN_CANCEL_STOP_DEVICE:
            case IRP_MN_CANCEL_REMOVE_DEVICE:

            case IRP_MN_QUERY_PNP_DEVICE_STATE:

                // We have no value add for IRP_MN_QUERY_PNP_DEVICE_STATE
                // at the moment.  At some point we might have reason to
                // return PNP_DEVICE_REMOVED or PNP_DEVICE_FAILED.


                DBGPRINT(2, ("Succeeding PnP for Child PDO %s\n",
                             PnPMinorFunctionString(irpStack->MinorFunction)));

                ntStatus = STATUS_SUCCESS;
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;


            default:

                DBGPRINT(2, ("Unhandled PnP Irp for Child PDO %s\n",
                             PnPMinorFunctionString(irpStack->MinorFunction)));

                ntStatus = Irp->IoStatus.Status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_Pnp %08X\n", ntStatus));

    LOGENTRY('pnp ', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoStartDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_START_DEVICE for the FDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP must be handled first by the underlying bus driver for a device
// and then by each higher driver in the device stack.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoStartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION       fdoDeviceExtension;
    USB_BUS_INTERFACE_USBDI_V1  busInterface;
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_FdoStartDevice\n"));

    DBGFBRK(DBGF_BRK_STARTDEVICE);

    LOGENTRY('STRT', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    // Pass IRP_MN_START_DEVICE Irp down the stack first before we do anything.
    //
    ntStatus = USBSTOR_SyncPassDownIrp(DeviceObject,
                                       Irp);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_START_DEVICE\n"));
        goto USBSTOR_FdoStartDeviceDone;
    }

    // Allocate Reset Pipe / Reset Port IoWorkItem
    //
    if (fdoDeviceExtension->IoWorkItem == NULL)
    {
        fdoDeviceExtension->IoWorkItem = IoAllocateWorkItem(DeviceObject);

        if (fdoDeviceExtension->IoWorkItem == NULL)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto USBSTOR_FdoStartDeviceDone;
        }
    }

    // If this is the first time the device as been started, retrieve the
    // Device and Configuration Descriptors from the device.
    //
    if (fdoDeviceExtension->DeviceDescriptor == NULL)
    {
        ntStatus = USBSTOR_GetDescriptors(DeviceObject);

        if (!NT_SUCCESS(ntStatus))
        {
            goto USBSTOR_FdoStartDeviceDone;
        }
    }

    // Now configure the device
    //
    ntStatus = USBSTOR_SelectConfiguration(DeviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Configure device failed\n"));
        goto USBSTOR_FdoStartDeviceDone;
    }

    // If the driver is loaded during textmode setup then the registry
    // value won't exist yet to indicate what type of device this is.  If
    // the Interface Descriptor indicates that the device is a Bulk-Only
    // device then believe it.
    //
    if ((fdoDeviceExtension->InterfaceDescriptor->bInterfaceClass ==
         USB_DEVICE_CLASS_STORAGE) &&
        (fdoDeviceExtension->InterfaceDescriptor->bInterfaceProtocol ==
         USBSTOR_PROTOCOL_BULK_ONLY) &&
        (fdoDeviceExtension->DriverFlags == DeviceProtocolUnspecified))
    {
        fdoDeviceExtension->DriverFlags = DeviceProtocolBulkOnly;
    }

    // Find the bulk and interrupt pipes we'll use in this configuration.
    //
    ntStatus = USBSTOR_GetPipes(DeviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        goto USBSTOR_FdoStartDeviceDone;
    }

    // Enable hacks for certain revs of the Y-E Data USB Floppy
    //
    if (fdoDeviceExtension->DeviceDescriptor->idVendor  == 0x057B &&
        fdoDeviceExtension->DeviceDescriptor->idProduct == 0x0000 &&
        fdoDeviceExtension->DeviceDescriptor->bcdDevice  < 0x0128)
    {
        SET_FLAG(fdoDeviceExtension->DeviceHackFlags, DHF_FORCE_REQUEST_SENSE);
#if 0
        SET_FLAG(fdoDeviceExtension->DeviceHackFlags, DHF_TUR_START_UNIT);
        SET_FLAG(fdoDeviceExtension->DeviceHackFlags, DHF_MEDIUM_CHANGE_RESET);
#endif
    }

    // Start timeout timer
    //
    IoStartTimer(DeviceObject);

    // Everything looks good so far, go ahead and create the list of
    // child PDOs if this is the first time we have been started and
    // the list is empty.
    //
    if (IsListEmpty(&fdoDeviceExtension->ChildPDOs))
    {
        UCHAR   maxLun;
        UCHAR   lun;

        maxLun = 0;

        // Only check devices which claim to be USB Mass Storage Class
        // Bulk-Only spec compliant for Multiple LUN support.
        //
        if ((fdoDeviceExtension->InterfaceDescriptor->bInterfaceClass ==
             USB_DEVICE_CLASS_STORAGE) &&
            (fdoDeviceExtension->InterfaceDescriptor->bInterfaceProtocol ==
             USBSTOR_PROTOCOL_BULK_ONLY))
        {
            // See if the device supports Multiple LUNs
            //
            ntStatus = USBSTOR_GetMaxLun(DeviceObject,
                                         &maxLun);

            if (NT_SUCCESS(ntStatus))
            {
                DBGPRINT(1, ("GetMaxLun returned %02x\n", maxLun));

                // We need to provide a unique InstanceID for each logical unit.
                // We use the device USB SerialNumber string as part of the
                // unique InstanceID.  Without a device USB SerialNumber string
                // we can't support multiple logical units on the device.
                //
                // The Bulk-Only USB Mass Storage class specification requires
                // a SerialNumber string so if the device does not have one it
                // is not really spec compliant anyway.
                //
                if (fdoDeviceExtension->SerialNumber == NULL)
                {
                    DBGPRINT(1, ("Multiple Lun but no SerialNumber!\n"));

                    maxLun = 0;
                }
            }
        }

        for (lun = 0; lun <= maxLun; lun++)
        {
            ntStatus = USBSTOR_CreateChildPDO(DeviceObject, lun);

            if (!NT_SUCCESS(ntStatus))
            {
                DBGPRINT(1, ("Create Child PDO %d failed\n", lun));
                goto USBSTOR_FdoStartDeviceDone;
            }
        }
    }

    if (NT_SUCCESS(USBSTOR_GetBusInterface(DeviceObject, &busInterface)))
    {
        fdoDeviceExtension->DeviceIsHighSpeed =
            busInterface.IsDeviceHighSpeed(busInterface.BusContext);

        DBGPRINT(1, ("DeviceIsHighSpeed: %s\n",
                     fdoDeviceExtension->DeviceIsHighSpeed ? "TRUE" : "FALSE"));
    }
    else
    {
        fdoDeviceExtension->DeviceIsHighSpeed = FALSE;
    }

USBSTOR_FdoStartDeviceDone:

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_FdoStartDevice %08X\n", ntStatus));

    LOGENTRY('strt', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetDescriptors()
//
// This routine is called at START_DEVICE time for the FDO to retrieve the
// Device and Configurations descriptors from the device and store them in
// the device extension.
//
//******************************************************************************

NTSTATUS
USBSTOR_GetDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PUCHAR                  descriptor;
    ULONG                   descriptorLength;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetDescriptors\n"));

    LOGENTRY('GDSC', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    //
    // Get Device Descriptor
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_DEVICE_DESCRIPTOR_TYPE,
                                     0,  // Index
                                     0,  // LanguageId
                                     2,  // RetryCount
                                     sizeof(USB_DEVICE_DESCRIPTOR),
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Device Descriptor failed\n"));
        goto USBSTOR_GetDescriptorsDone;
    }

    ASSERT(fdoDeviceExtension->DeviceDescriptor == NULL);
    fdoDeviceExtension->DeviceDescriptor = (PUSB_DEVICE_DESCRIPTOR)descriptor;

    //
    // Get Configuration Descriptor (just the Configuration Descriptor)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                     0,  // Index
                                     0,  // LanguageId
                                     2,  // RetryCount
                                     sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Configuration Descriptor failed (1)\n"));
        goto USBSTOR_GetDescriptorsDone;
    }

    descriptorLength = ((PUSB_CONFIGURATION_DESCRIPTOR)descriptor)->wTotalLength;

    ExFreePool(descriptor);

    if (descriptorLength < sizeof(USB_CONFIGURATION_DESCRIPTOR))
    {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        DBGPRINT(1, ("Get Configuration Descriptor failed (2)\n"));
        goto USBSTOR_GetDescriptorsDone;
    }

    //
    // Get Configuration Descriptor (and Interface and Endpoint Descriptors)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                     0,  // Index
                                     0,  // LanguageId
                                     2,  // RetryCount
                                     descriptorLength,
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Configuration Descriptor failed (3)\n"));
        goto USBSTOR_GetDescriptorsDone;
    }

    ASSERT(fdoDeviceExtension->ConfigurationDescriptor == NULL);
    fdoDeviceExtension->ConfigurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)descriptor;

    //
    // Get the Serial Number String Descriptor, if there is one
    //
    if (fdoDeviceExtension->DeviceDescriptor->iSerialNumber)
    {
        USBSTOR_GetStringDescriptors(DeviceObject);
    }

#if DBG
    DumpDeviceDesc(fdoDeviceExtension->DeviceDescriptor);
    DumpConfigDesc(fdoDeviceExtension->ConfigurationDescriptor);
#endif

USBSTOR_GetDescriptorsDone:

    DBGPRINT(2, ("exit:  USBSTOR_GetDescriptors %08X\n", ntStatus));

    LOGENTRY('gdsc', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetStringDescriptors()
//
// This routine is called at START_DEVICE time for the FDO to retrieve the
// Serial Number string descriptor from the device and store it in
// the device extension.
//
//******************************************************************************

USBSTOR_GetStringDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PUCHAR                  descriptor;
    ULONG                   descriptorLength;
    USHORT                  languageId;
    ULONG                   i, numIds;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetStringDescriptors\n"));

    LOGENTRY('GSDC', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    //
    // Get the list of Language IDs (descriptor header only)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     0,  // Index
                                     0,  // LanguageId
                                     2,  // RetryCount
                                     sizeof(USB_COMMON_DESCRIPTOR),
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Language IDs failed (1) %08X\n", ntStatus));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    descriptorLength = ((PUSB_COMMON_DESCRIPTOR)descriptor)->bLength;

    ExFreePool(descriptor);

    if ((descriptorLength < sizeof(USB_COMMON_DESCRIPTOR) + sizeof(USHORT)) ||
        (descriptorLength & 1))
    {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        DBGPRINT(1, ("Get Language IDs failed (2) %d\n", descriptorLength));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    //
    // Get the list of Language IDs (complete descriptor)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     0,  // Index
                                     0,  // LanguageId
                                     2,  // RetryCount
                                     descriptorLength,
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Language IDs failed (3) %08X\n", ntStatus));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    // Search the list of LanguageIDs for US-English (0x0409).  If we find
    // it in the list, that's the LanguageID we'll use.  Else just default
    // to the first LanguageID in the list.

    numIds = (descriptorLength - sizeof(USB_COMMON_DESCRIPTOR)) / sizeof(USHORT);

    languageId = ((PUSHORT)descriptor)[1];

    for (i = 2; i <= numIds; i++)
    {
        if (((PUSHORT)descriptor)[i] == 0x0409)
        {
            languageId = 0x0409;
            break;
        }
    }

    ExFreePool(descriptor);

    //
    // Get the Serial Number (descriptor header only)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     fdoDeviceExtension->DeviceDescriptor->iSerialNumber,
                                     languageId,
                                     2,  // RetryCount
                                     sizeof(USB_COMMON_DESCRIPTOR),
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Serial Number failed (1) %08X\n", ntStatus));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    descriptorLength = ((PUSB_COMMON_DESCRIPTOR)descriptor)->bLength;

    ExFreePool(descriptor);

    if ((descriptorLength < sizeof(USB_COMMON_DESCRIPTOR) + sizeof(USHORT)) ||
        (descriptorLength & 1))
    {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        DBGPRINT(1, ("Get Serial Number failed (2) %d\n", descriptorLength));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    //
    // Get the Serial Number (complete descriptor)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     fdoDeviceExtension->DeviceDescriptor->iSerialNumber,
                                     languageId,
                                     2,  // RetryCount
                                     descriptorLength,
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Serial Number failed (3) %08X\n", ntStatus));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    ASSERT(fdoDeviceExtension->SerialNumber == NULL);
    fdoDeviceExtension->SerialNumber = (PUSB_STRING_DESCRIPTOR)descriptor;

USBSTOR_GetStringDescriptorsDone:

    DBGPRINT(2, ("exit:  USBSTOR_GetStringDescriptors %08X %08X\n",
                 ntStatus, fdoDeviceExtension->SerialNumber));

    LOGENTRY('gdsc', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_AdjustConfigurationDescriptor()
//
// This routine is called at START_DEVICE time for the FDO to adjust the
// Configuration Descriptor, if necessary.
//
// Removes Endpoint Descriptors we won't use.  The Configuration Descriptor
// is modified in place.
//
//******************************************************************************

VOID
USBSTOR_AdjustConfigurationDescriptor (
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc,
    OUT PUSB_INTERFACE_DESCRIPTOR      *InterfaceDesc,
    OUT PLONG                           BulkInIndex,
    OUT PLONG                           BulkOutIndex,
    OUT PLONG                           InterruptInIndex
    )
{
    PFDO_DEVICE_EXTENSION       fdoDeviceExtension;
    PUCHAR                      descEnd;
    PUSB_COMMON_DESCRIPTOR      commonDesc;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDesc;
    PUSB_ENDPOINT_DESCRIPTOR    endpointDesc;
    LONG                        endpointIndex;
    BOOLEAN                     removeEndpoint;

    PAGED_CODE();

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;

    interfaceDesc = NULL;

    *BulkInIndex      = -1;
    *BulkOutIndex     = -1;
    *InterruptInIndex = -1;

    endpointIndex = 0;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        // Is this an Interface Descriptor?
        //
        if ((commonDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE) &&
            (commonDesc->bLength         == sizeof(USB_INTERFACE_DESCRIPTOR)))
        {
            // Only bother looking at the first Interface Descriptor
            //
            if (interfaceDesc != NULL)
            {
                break;
            }

            // Remember the first Interface Descriptor we have seen
            //
            interfaceDesc = (PUSB_INTERFACE_DESCRIPTOR)commonDesc;
        }

        // Is this an Endpoint Descriptor?
        //
        if ((commonDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE) &&
            (commonDesc->bLength         == sizeof(USB_ENDPOINT_DESCRIPTOR)) &&
            (interfaceDesc != NULL))
        {
            endpointDesc = (PUSB_ENDPOINT_DESCRIPTOR)commonDesc;

            // There is currently a bug in the composite parent driver
            // that doesn't handle the case where the number of
            // endpoints in an Interface Descriptor differs from the
            // Interface Descriptor originally returned by the deivce.
            // Until that bug is fixed avoid the bug by not stripping
            // out endpoints that won't be used.
            //
            removeEndpoint = FALSE;

            if (((endpointDesc->bmAttributes & USB_ENDPOINT_TYPE_MASK) ==
                 USB_ENDPOINT_TYPE_BULK) &&
                (USB_ENDPOINT_DIRECTION_IN(endpointDesc->bEndpointAddress)))
            {
                if (*BulkInIndex == -1)
                {
                    *BulkInIndex   = endpointIndex;
                    removeEndpoint = FALSE;
                }
            }
            else if (((endpointDesc->bmAttributes & USB_ENDPOINT_TYPE_MASK) ==
                 USB_ENDPOINT_TYPE_BULK) &&
                (USB_ENDPOINT_DIRECTION_OUT(endpointDesc->bEndpointAddress)))
            {
                if (*BulkOutIndex == -1)
                {
                    *BulkOutIndex  = endpointIndex;
                    removeEndpoint = FALSE;
                }
            }
            else if (((endpointDesc->bmAttributes & USB_ENDPOINT_TYPE_MASK) ==
                 USB_ENDPOINT_TYPE_INTERRUPT) &&
                (USB_ENDPOINT_DIRECTION_IN(endpointDesc->bEndpointAddress)))
            {
                // Only keep the Interrupt endpoint if we know for sure
                // that the device is a CBI device.  Don't trust the
                // bInterfaceProtocol value of the device.  Devices can lie.
                //
                if ((*InterruptInIndex == -1) &&
                    (fdoDeviceExtension->DriverFlags == DeviceProtocolCBI))
                {
                    *InterruptInIndex = endpointIndex;
                    removeEndpoint    = FALSE;
                }
            }

            if (removeEndpoint)
            {
                // Remove this endpoint, we won't use it.
                //
                DBGPRINT(1, ("Removing Endpoint addr %02X, attr %02X\n",
                             endpointDesc->bEndpointAddress,
                             endpointDesc->bmAttributes));

                RtlMoveMemory(endpointDesc,
                              endpointDesc + 1,
                              descEnd - (PUCHAR)(endpointDesc + 1));

                ConfigDesc->wTotalLength -= sizeof(USB_ENDPOINT_DESCRIPTOR);

                interfaceDesc->bNumEndpoints -= 1;

                descEnd -= sizeof(USB_ENDPOINT_DESCRIPTOR);

                continue;
            }
            else
            {
                DBGPRINT(1, ("Keeping Endpoint addr %02X, attr %02X\n",
                             endpointDesc->bEndpointAddress,
                             endpointDesc->bmAttributes));

                endpointIndex++;
            }
        }

        // Advance past this descriptor
        //
        (PUCHAR)commonDesc += commonDesc->bLength;
    }

    ASSERT(*BulkInIndex != -1);
    ASSERT(*BulkOutIndex != -1);
    ASSERT((*InterruptInIndex != -1) ==
           (fdoDeviceExtension->DriverFlags == DeviceProtocolCBI));

    *InterfaceDesc = interfaceDesc;
}

//******************************************************************************
//
// USBSTOR_GetPipes()
//
// This routine is called at START_DEVICE time find the Bulk IN, Bulk OUT,
// and Interrupt IN endpoints for the device.
//
//******************************************************************************

NTSTATUS
USBSTOR_GetPipes (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PUSBD_PIPE_INFORMATION  pipe;
    ULONG                   i;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetPipes\n"));

    LOGENTRY('GPIP', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    fdoDeviceExtension->BulkInPipe      = NULL;
    fdoDeviceExtension->BulkOutPipe     = NULL;
    fdoDeviceExtension->InterruptInPipe = NULL;

    // Find the Bulk IN, Bulk OUT, and Interrupt IN endpoints.
    //
    for (i=0; i<fdoDeviceExtension->InterfaceInfo->NumberOfPipes; i++)
    {
        pipe = &fdoDeviceExtension->InterfaceInfo->Pipes[i];

        if (pipe->PipeType == UsbdPipeTypeBulk)
        {
            if (USBD_PIPE_DIRECTION_IN(pipe) &&
                fdoDeviceExtension->BulkInPipe == NULL)
            {
                fdoDeviceExtension->BulkInPipe = pipe;
            }
            else if (!USBD_PIPE_DIRECTION_IN(pipe) &&
                     fdoDeviceExtension->BulkOutPipe == NULL)
            {
                fdoDeviceExtension->BulkOutPipe = pipe;
            }
        }
        else if (pipe->PipeType == UsbdPipeTypeInterrupt)
        {
            if (USBD_PIPE_DIRECTION_IN(pipe) &&
                fdoDeviceExtension->InterruptInPipe == NULL &&
                fdoDeviceExtension->DriverFlags == DeviceProtocolCBI)
            {
                fdoDeviceExtension->InterruptInPipe = pipe;
            }
        }
    }

    ntStatus = STATUS_SUCCESS;

    if (fdoDeviceExtension->BulkInPipe  == NULL)
    {
        DBGPRINT(1, ("Missing Bulk IN pipe\n"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (fdoDeviceExtension->BulkOutPipe == NULL)
    {
        DBGPRINT(1, ("Missing Bulk OUT pipe\n"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    DBGPRINT(2, ("exit:  USBSTOR_GetPipes %08X\n", ntStatus));

    LOGENTRY('gpip', ntStatus, fdoDeviceExtension->BulkInPipe,
             fdoDeviceExtension->BulkOutPipe);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_CreateChildPDO()
//
// This routine is called during START_DEVICE of the FDO to create the
// child PDO.  This is only called the first time the FDO is started,
// after the device has its USB configuration selected.
//
//******************************************************************************

NTSTATUS
USBSTOR_CreateChildPDO (
    IN PDEVICE_OBJECT   FdoDeviceObject,
    IN UCHAR            Lun
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          pdoDeviceObject;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_CreateChildPDO %d\n", Lun));

    LOGENTRY('CCPD', FdoDeviceObject, Lun, 0);

    fdoDeviceExtension = FdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Create the PDO
    //
    ntStatus = IoCreateDevice(FdoDeviceObject->DriverObject,
                              sizeof(PDO_DEVICE_EXTENSION),
                              NULL,
                              FILE_DEVICE_MASS_STORAGE,
                              FILE_AUTOGENERATED_DEVICE_NAME,
                              FALSE,
                              &pdoDeviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    // The PDO and the FDO are effectively at the same stack level.
    // Irps directed at the PDO will sometimes be passed down with
    // IoCallDriver() to the FDO->StackDeviceObject.
    //
    pdoDeviceObject->StackSize = FdoDeviceObject->StackSize;

    // Initialize the PDO DeviceExtension
    //
    pdoDeviceExtension = pdoDeviceObject->DeviceExtension;

    // Set all DeviceExtension pointers to NULL and all variable to zero
    //
    RtlZeroMemory(pdoDeviceExtension, sizeof(PDO_DEVICE_EXTENSION));

    // Tag this as a PDO which is the child of an FDO
    //
    pdoDeviceExtension->Type = USBSTOR_DO_TYPE_PDO;

    // Point back to our own DeviceObject
    //
    pdoDeviceExtension->PdoDeviceObject = pdoDeviceObject;

    // Remember the PDO's parent FDO
    //
    pdoDeviceExtension->ParentFDO = FdoDeviceObject;

    // Set the initial system and device power states
    //
    pdoDeviceExtension->SystemPowerState = PowerSystemWorking;
    pdoDeviceExtension->DevicePowerState = PowerDeviceD0;

    // Initialize the PDO's PnP device state
    //
    pdoDeviceExtension->DeviceState = DeviceStateCreated;

    // Add the child PDO we just created to the parent's list of child PDOs
    //
    InsertTailList(&fdoDeviceExtension->ChildPDOs,
                   &pdoDeviceExtension->ListEntry);

    pdoDeviceObject->Flags |=  DO_DIRECT_IO;
    pdoDeviceObject->Flags |=  DO_POWER_PAGABLE;
    pdoDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    pdoDeviceExtension->LUN = Lun;

    // Get the Inquiry Data from the device
    //
    ntStatus = USBSTOR_GetInquiryData(pdoDeviceObject);

    // If the device is a DIRECT_ACCESS_DEVICE, see if it is a floppy
    //
    if (NT_SUCCESS(ntStatus))
    {
        PINQUIRYDATA inquiryData;

        inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

        if (inquiryData->DeviceType == DIRECT_ACCESS_DEVICE)
        {
            pdoDeviceExtension->IsFloppy = USBSTOR_IsFloppyDevice(pdoDeviceObject);
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_CreateChildPDO %08X\n", ntStatus));

    LOGENTRY('ccpd', FdoDeviceObject, pdoDeviceObject, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoStopDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_STOP_DEVICE for the FDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// The PnP Manager only sends this IRP if a prior IRP_MN_QUERY_STOP_DEVICE
// completed successfully.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
// A driver must set Irp->IoStatus.Status to STATUS_SUCCESS.  A driver must
// not fail this IRP.  If a driver cannot release the device's hardware
// resources, it can fail a query-stop IRP, but once it succeeds the query-stop
// request it must succeed the stop request.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoStopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_FdoStopDevice\n"));

    LOGENTRY('STOP', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_STOPDEVICE);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    // Release the device resources allocated during IRP_MN_START_DEVICE
    //

    // Stop the timeout timer
    //
    IoStopTimer(DeviceObject);

    // Unconfigure the device
    //
    ntStatus = USBSTOR_UnConfigure(DeviceObject);

    // The documentation says to set the status before passing the
    // Irp down the stack
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_STOP_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(2, ("exit:  USBSTOR_FdoStopDevice %08X\n", ntStatus));

    LOGENTRY('stop', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE for the FDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
// A driver must set Irp->IoStatus.Status to STATUS_SUCCESS.  Drivers must not
// fail this IRP.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_FdoRemoveDevice\n"));

    LOGENTRY('REMV', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_REMOVEDEVICE);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    // Decrement by one to match the initial one in AddDevice
    //
    DECREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

    LOGENTRY('rem1', DeviceObject, 0, 0);

    // Wait for all pending requests to complete
    //
    KeWaitForSingleObject(&fdoDeviceExtension->RemoveEvent,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    LOGENTRY('rem2', DeviceObject, 0, 0);

    // The child PDOs should have received REMOVE_DEVICE before the FDO.
    // Go ahead and delete them now.
    //
    while (!IsListEmpty(&fdoDeviceExtension->ChildPDOs))
    {
        PLIST_ENTRY             listEntry;
        PPDO_DEVICE_EXTENSION   pdoDeviceExtension;

        listEntry = RemoveTailList(&fdoDeviceExtension->ChildPDOs);

        pdoDeviceExtension = CONTAINING_RECORD(listEntry,
                                               PDO_DEVICE_EXTENSION,
                                               ListEntry);

        ASSERT(pdoDeviceExtension->DeviceState == DeviceStateCreated ||
               pdoDeviceExtension->DeviceState == DeviceStateRemoved);

        LOGENTRY('remc', DeviceObject, pdoDeviceExtension->PdoDeviceObject, 0);
        IoDeleteDevice(pdoDeviceExtension->PdoDeviceObject);
    }

    // Free everything that was allocated during IRP_MN_START_DEVICE
    //

    if (fdoDeviceExtension->IoWorkItem != NULL)
    {
        IoFreeWorkItem(fdoDeviceExtension->IoWorkItem);
    }

    if (fdoDeviceExtension->DeviceDescriptor != NULL)
    {
        ExFreePool(fdoDeviceExtension->DeviceDescriptor);
    }

    if (fdoDeviceExtension->ConfigurationDescriptor != NULL)
    {
        ExFreePool(fdoDeviceExtension->ConfigurationDescriptor);
    }

    if (fdoDeviceExtension->SerialNumber != NULL)
    {
        ExFreePool(fdoDeviceExtension->SerialNumber);
    }

    if (fdoDeviceExtension->InterfaceInfo != NULL)
    {
        ExFreePool(fdoDeviceExtension->InterfaceInfo);
    }

    // The documentation says to set the status before passing the Irp down
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_REMOVE_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    LOGENTRY('rem3', DeviceObject, 0, 0);

    // Free everything that was allocated during AddDevice
    //
    IoDetachDevice(fdoDeviceExtension->StackDeviceObject);

    IoDeleteDevice(DeviceObject);

    DBGPRINT(2, ("exit:  USBSTOR_FdoRemoveDevice %08X\n", ntStatus));

    LOGENTRY('remv', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoQueryStopRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_STOP_DEVICE and
// IRP_MN_QUERY_REMOVE_DEVICE for the FDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoQueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_FdoQueryStopRemoveDevice\n"));

    LOGENTRY('QSRD', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_QUERYSTOPDEVICE);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    // The documentation says to set the status before passing the Irp down
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_QUERY_STOP/REMOVE_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(2, ("exit:  USBSTOR_FdoQueryStopRemoveDevice %08X\n", ntStatus));

    LOGENTRY('qsrd', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoCancelStopRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_CANCEL_STOP_DEVICE and
// IRP_MN_CANCEL_REMOVE_DEVICE for the FDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP must be handled first by the underlying bus driver for a device
// and then by each higher driver in the device stack.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoCancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_FdoCancelStopRemoveDevice\n"));

    LOGENTRY('CSRD', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CANCELSTOPDEVICE);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    // The documentation says to set the status before passing the Irp down
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_CANCEL_STOP/REMOVE_DEVICE Irp down the stack.
    //
    ntStatus = USBSTOR_SyncPassDownIrp(DeviceObject,
                                       Irp);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_CANCEL_STOP/REMOVE_DEVICE\n"));
        goto USBSTOR_CancelStopRemoveDeviceDone;
    }

USBSTOR_CancelStopRemoveDeviceDone:

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_FdoCancelStopRemoveDevice %08X\n", ntStatus));

    LOGENTRY('csrd', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoQueryDeviceRelations()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_DEVICE_RELATIONS for the FDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoQueryDeviceRelations (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    DEVICE_RELATION_TYPE    relationType;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    relationType = irpStack->Parameters.QueryDeviceRelations.Type;

    DBGPRINT(2, ("enter: USBSTOR_FdoQueryDeviceRelations %d\n",
                 relationType));

    LOGENTRY('FQDR', DeviceObject, Irp, relationType);

    switch (relationType)
    {
        case BusRelations:

            if (!IsListEmpty(&fdoDeviceExtension->ChildPDOs))
            {
                // If we have children to return, add them to the existing
                // relation list, if there is one, else create and add them
                // to a new relation list.
                //
                // Then in either case, pass the request down the driver stack.
                //
                PDEVICE_RELATIONS   oldRelations;
                PDEVICE_RELATIONS   newRelations;
                PLIST_ENTRY         listHead;
                PLIST_ENTRY         listEntry;
                ULONG               oldCount;
                ULONG               childCount;
                ULONG               index;

                listHead = &fdoDeviceExtension->ChildPDOs;

                // How many children?
                //
                for (listEntry =  listHead->Flink,  childCount = 0;
                     listEntry != listHead;
                     listEntry =  listEntry->Flink, childCount++)
                     ;

                oldRelations = (PDEVICE_RELATIONS)Irp->IoStatus.Information;

                if (oldRelations)
                {
                    // Add our children to the existing relation list.

                    oldCount = oldRelations->Count;

                    // A DEVICE_RELATIONS structure has room for one
                    // PDEVICE_OBJECT to start with, so subtract that
                    // out of the size we allocate.
                    //
                    newRelations = ExAllocatePoolWithTag(
                                       PagedPool,
                                       sizeof(DEVICE_RELATIONS) +
                                       sizeof(PDEVICE_OBJECT) *
                                           (oldCount + childCount - 1),
                                       POOL_TAG);

                    if (newRelations)
                    {
                        // Copy the existing relation list
                        //
                        for (index = 0; index < oldCount; index++)
                        {
                            newRelations->Objects[index] =
                                oldRelations->Objects[index];
                        }
                    }

                    // Now we're done the the existing relation list, free it
                    //
                    ExFreePool(oldRelations);
                }
                else
                {
                    // Create a new relation list for our children

                    newRelations = ExAllocatePoolWithTag(
                                       PagedPool,
                                       sizeof(DEVICE_RELATIONS) +
                                       sizeof(PDEVICE_OBJECT) *
                                           (childCount - 1),
                                       POOL_TAG);

                    oldCount = 0;
                    index = 0;
                }

                if (newRelations)
                {
                    newRelations->Count = oldCount + childCount;

                    // Add our child relations at the end of the list
                    //
                    for (listEntry =  listHead->Flink;
                         listEntry != listHead;
                         listEntry =  listEntry->Flink)
                    {
                        PPDO_DEVICE_EXTENSION   pdoDeviceExtension;

                        pdoDeviceExtension = CONTAINING_RECORD(
                            listEntry,
                            PDO_DEVICE_EXTENSION,
                            ListEntry);

                        newRelations->Objects[index++] =
                            pdoDeviceExtension->PdoDeviceObject;

                        ObReferenceObject(pdoDeviceExtension->PdoDeviceObject);

                        DBGPRINT(2, ("returning ChildPDO %08X\n",
                                     pdoDeviceExtension->PdoDeviceObject));
                    }

                    ASSERT(index == oldCount + childCount);

                    ntStatus = STATUS_SUCCESS;
                    Irp->IoStatus.Status = ntStatus;
                    Irp->IoStatus.Information = (ULONG_PTR)newRelations;
                }
                else
                {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    Irp->IoStatus.Status = ntStatus;
                    Irp->IoStatus.Information = 0;
                }
            }
            else
            {
                // If we don't have a child to return, just pass the request
                // down without doing anything.
                //
                ntStatus = STATUS_SUCCESS;
            }
            break;

        case EjectionRelations:
        case PowerRelations:
        case RemovalRelations:
        case TargetDeviceRelation:
        default:
            //
            // Pass the request down the driver stack without doing anything.
            //
            ntStatus = STATUS_SUCCESS;
            break;
    }

    if (NT_SUCCESS(ntStatus))
    {
        // Pass the Irp down the driver stack if successful so far.
        //
        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                Irp);
    }
    else
    {
        // Unsuccessful, just complete the request now.
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  USBSTOR_FdoQueryDeviceRelations %08X\n", ntStatus));

    LOGENTRY('fqdr', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoQueryCapabilities()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES for the FDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoQueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PDEVICE_CAPABILITIES    deviceCapabilities;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    DBGPRINT(2, ("enter: USBSTOR_FdoQueryCapabilities\n"));

    LOGENTRY('FQCP', DeviceObject, Irp, 0);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

    // Pass IRP_MN_QUERY_CAPABILITIES Irp down the stack first before we do
    // anything.
    //
    ntStatus = USBSTOR_SyncPassDownIrp(DeviceObject,
                                       Irp);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_QUERY_CAPABILITIES\n"));
    }
    else
    {
        if (fdoDeviceExtension->NonRemovable)
        {
            deviceCapabilities->Removable = FALSE;
        }
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_FdoQueryCapabilities %08X\n", ntStatus));

    LOGENTRY('fqcp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoStartDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_START_DEVICE for the PDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoStartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoStartDevice\n"));

    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoStartDevice %08X\n", ntStatus));

    LOGENTRY('pstr', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE for the PDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoRemoveDevice\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    pdoDeviceExtension->Claimed = FALSE;

    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoRemoveDevice %08X\n", ntStatus));

    LOGENTRY('prmd', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryID()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_ID for the PDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryID (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    UNICODE_STRING          unicodeStr;
    BOOLEAN                 multiStrings;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryID\n"));

    LOGENTRY('PQID', DeviceObject, Irp, 0);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Initialize return value to NULL
    //
    RtlInitUnicodeString(&unicodeStr, NULL);

    switch (irpStack->Parameters.QueryId.IdType)
    {
        case BusQueryDeviceID:

            ntStatus = USBSTOR_PdoQueryDeviceId(
                           DeviceObject,
                           &unicodeStr);

            multiStrings = FALSE;

            break;

        case BusQueryHardwareIDs:

            ntStatus = USBSTOR_PdoQueryHardwareIds(
                           DeviceObject,
                           &unicodeStr);

            multiStrings = TRUE;

            break;

        case BusQueryCompatibleIDs:

            ntStatus = USBSTOR_PdoQueryCompatibleIds(
                           DeviceObject,
                           &unicodeStr);

            multiStrings = TRUE;

            break;

        case BusQueryInstanceID:

            ntStatus = USBSTOR_PdoBusQueryInstanceId(
                           DeviceObject,
                           &unicodeStr);

            multiStrings = FALSE;

            break;

        default:
            ntStatus = STATUS_NOT_SUPPORTED;
            break;
    }

    if (NT_SUCCESS(ntStatus) && unicodeStr.Buffer)
    {
        PWCHAR idString;
        //
        // fix up all invalid characters
        //
        idString = unicodeStr.Buffer;

        while (*idString)
        {
            if ((*idString <= L' ')  ||
                (*idString > (WCHAR)0x7F) ||
                (*idString == L','))
            {
                *idString = L'_';
            }

            idString++;

            if ((*idString == L'\0') && multiStrings)
            {
                idString++;
            }
        }

        Irp->IoStatus.Information = (ULONG_PTR)unicodeStr.Buffer;
    }
    else
    {
        Irp->IoStatus.Information = (ULONG_PTR)NULL;
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryID %08X\n", ntStatus));

    LOGENTRY('pqid', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoDeviceTypeString()
//
// This routine returns a device type string for the PDO.
//
//******************************************************************************

PCHAR
USBSTOR_PdoDeviceTypeString (
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;

    PAGED_CODE();

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    switch (inquiryData->DeviceType)
    {
        case DIRECT_ACCESS_DEVICE:
            return pdoDeviceExtension->IsFloppy ? "SFloppy" : "Disk";

        case WRITE_ONCE_READ_MULTIPLE_DEVICE:
            return "Worm";

        case READ_ONLY_DIRECT_ACCESS_DEVICE:
            return "CdRom";

        case OPTICAL_DEVICE:
            return "Optical";

        case MEDIUM_CHANGER:
            return "Changer";

        case SEQUENTIAL_ACCESS_DEVICE:
            return "Sequential";

        default:
            return "Other";
    }
}

//******************************************************************************
//
// USBSTOR_PdoGenericTypeString()
//
// This routine returns a device type string for the PDO.
//
//******************************************************************************

PCHAR
USBSTOR_PdoGenericTypeString (
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;

    PAGED_CODE();

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    switch (inquiryData->DeviceType)
    {
        case DIRECT_ACCESS_DEVICE:
            return pdoDeviceExtension->IsFloppy ? "GenSFloppy" : "GenDisk";

        case WRITE_ONCE_READ_MULTIPLE_DEVICE:
            return "GenWorm";

        case READ_ONLY_DIRECT_ACCESS_DEVICE:
            return "GenCdRom";

        case OPTICAL_DEVICE:
            return "GenOptical";

        case MEDIUM_CHANGER:
            return "GenChanger";

        case SEQUENTIAL_ACCESS_DEVICE:
            return "GenSequential";

        default:
            return "UsbstorOther";
    }
}

//******************************************************************************
//
// CopyField()
//
// This routine will copy Count string bytes from Source to Destination.
// If it finds a nul byte in the Source it will translate that and any
// subsequent bytes into Change.  It will also replace spaces with the
// specified Change character.
//
//******************************************************************************

VOID
CopyField (
    IN PUCHAR   Destination,
    IN PUCHAR   Source,
    IN ULONG    Count,
    IN UCHAR    Change
    )
{
    ULONG   i;
    BOOLEAN pastEnd;

    PAGED_CODE();

    pastEnd = FALSE;

    for (i = 0; i < Count; i++)
    {
        if (!pastEnd)
        {
            if (Source[i] == 0)
            {
                pastEnd = TRUE;

                Destination[i] = Change;

            } else if (Source[i] == ' ')
            {
                Destination[i] = Change;
            } else
            {
                Destination[i] = Source[i];
            }
        }
        else
        {
            Destination[i] = Change;
        }
    }
    return;
}

//******************************************************************************
//
// USBSTOR_StringArrayToMultiSz()
//
// This routine will take a null terminated array of ascii strings and merge
// them together into a unicode multi-string block.
//
// This routine allocates memory for the string buffer - it is the caller's
// responsibility to free it.
//
//******************************************************************************

NTSTATUS
USBSTOR_StringArrayToMultiSz(
    PUNICODE_STRING MultiString,
    PCSTR           StringArray[]
    )
{
    ANSI_STRING     ansiEntry;
    UNICODE_STRING  unicodeEntry;
    UCHAR           i;
    NTSTATUS        ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_StringArrayToMultiSz %08X %08X\n",
                MultiString, StringArray));

    // Make sure we aren't going to leak any memory
    //
    ASSERT(MultiString->Buffer == NULL);

    RtlInitUnicodeString(MultiString, NULL);

    // First add up the sizes of the converted ascii strings to determine
    // how big the multisz will be.
    //
    for (i = 0; StringArray[i] != NULL; i++)
    {
        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        MultiString->Length += (USHORT)RtlAnsiStringToUnicodeSize(&ansiEntry);
    }

    ASSERT(MultiString->Length != 0);

    // Add room for the double NULL terminator
    //
    MultiString->MaximumLength = MultiString->Length + sizeof(UNICODE_NULL);

    // Now allocate a buffer for the multisz
    //
    MultiString->Buffer = ExAllocatePoolWithTag(PagedPool,
                                                MultiString->MaximumLength,
                                                POOL_TAG);

    if (MultiString->Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(MultiString->Buffer, MultiString->MaximumLength);

    unicodeEntry = *MultiString;

    // Now convert each ascii string in the array into a unicode string
    // in the multisz
    //
    for (i = 0; StringArray[i] != NULL; i++)
    {
        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        ntStatus = RtlAnsiStringToUnicodeString(&unicodeEntry,
                                                &ansiEntry,
                                                FALSE);

        // Since we're not allocating any memory the only failure possible
        // is if this function is bad

        ASSERT(NT_SUCCESS(ntStatus));

        // Push the buffer location up and reduce the maximum count
        //
        ((PSTR) unicodeEntry.Buffer) += unicodeEntry.Length + sizeof(WCHAR);
        unicodeEntry.MaximumLength   -= unicodeEntry.Length + sizeof(WCHAR);
    };

    DBGPRINT(2, ("exit:  USBSTOR_StringArrayToMultiSz\n"));

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// USBSTOR_PdoQueryDeviceId()
//
// This routine handles IRP_MN_QUERY_ID BusQueryDeviceID for the PDO.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryDeviceId (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;
    UCHAR                   buffer[128];
    PUCHAR                  rawIdString;
    ANSI_STRING             ansiIdString;
    ULONG                   whichString;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryDeviceId\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    RtlZeroMemory(buffer, sizeof(buffer));

    rawIdString = USBSTOR_PdoDeviceTypeString(DeviceObject);

    sprintf(buffer, "USBSTOR\\%s", rawIdString);

    rawIdString = buffer + strlen(buffer);

    for (whichString = 0; whichString < 3; whichString++)
    {
        PUCHAR  headerString;
        PUCHAR  sourceString;
        ULONG   sourceStringLength;
        ULONG   i;

        switch (whichString)
        {
            //
            // Vendor Id
            //
            case 0:
                sourceString = inquiryData->VendorId;
                sourceStringLength = sizeof(inquiryData->VendorId);
                headerString = "Ven";
                break;

            //
            // Product Id
            //
            case 1:
                sourceString = inquiryData->ProductId;
                sourceStringLength = sizeof(inquiryData->ProductId);
                headerString = "Prod";
                break;

            //
            // Product Revision Level
            //
            case 2:
                sourceString = inquiryData->ProductRevisionLevel;
                sourceStringLength = sizeof(inquiryData->ProductRevisionLevel);
                headerString = "Rev";
                break;
        }

        //
        // Start at the end of the source string and back up until we find a
        // non-space, non-null character.
        //

        for (; sourceStringLength > 0; sourceStringLength--)
        {
            if((sourceString[sourceStringLength - 1] != ' ') &&
               (sourceString[sourceStringLength - 1] != '\0'))
            {
                break;
            }
        }

        //
        // Throw the header string into the block
        //

        sprintf(rawIdString, "&%s_", headerString);
        rawIdString += strlen(headerString) + 2;

        //
        // Spew the string into the device id
        //

        for(i = 0; i < sourceStringLength; i++)
        {
            *rawIdString = (sourceString[i] != ' ') ? (sourceString[i]) :
                                                      ('_');
            rawIdString++;
        }
    }

    RtlInitAnsiString(&ansiIdString, buffer);

    ntStatus = RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryDeviceId %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryHardwareIds()
//
// This routine handles IRP_MN_QUERY_ID BusQueryHardwareIDs for the PDO.
//
//******************************************************************************

#define NUMBER_HARDWARE_STRINGS 7

NTSTATUS
USBSTOR_PdoQueryHardwareIds (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;
    PUCHAR                  devTypeString;
    PUCHAR                  genTypeString;
    ULONG                   i;
    PSTR                    strings[NUMBER_HARDWARE_STRINGS + 1];
    UCHAR                   scratch[128];
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryHardwareIds\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    devTypeString = USBSTOR_PdoDeviceTypeString(DeviceObject);

    genTypeString = USBSTOR_PdoGenericTypeString(DeviceObject);

    ntStatus = STATUS_SUCCESS;

    RtlZeroMemory(strings, sizeof(strings));

    for (i = 0; i < NUMBER_HARDWARE_STRINGS; i++)
    {
        RtlZeroMemory(scratch, sizeof(scratch));

        // First build each string in the scratch buffer
        //
        switch (i)
        {
            //
            // Bus + Dev Type + Vendor + Product + Revision
            //
            case 0:

                sprintf(scratch, "USBSTOR\\%s", devTypeString);

                CopyField(scratch + strlen(scratch),
                          inquiryData->VendorId,
                          8,
                          '_');
                CopyField(scratch + strlen(scratch),
                          inquiryData->ProductId,
                          16,
                          '_');
                CopyField(scratch + strlen(scratch),
                          inquiryData->ProductRevisionLevel,
                          4,
                          '_');
                break;

            //
            // Bus + Dev Type + Vendor + Product
            //
            case 1:

                sprintf(scratch, "USBSTOR\\%s", devTypeString);

                CopyField(scratch + strlen(scratch),
                          inquiryData->VendorId,
                          8,
                          '_');
                CopyField(scratch + strlen(scratch),
                          inquiryData->ProductId,
                          16,
                          '_');
                break;

            //
            // Bus + Dev Type + Vendor
            //
            case 2:

                sprintf(scratch, "USBSTOR\\%s", devTypeString);

                CopyField(scratch + strlen(scratch),
                          inquiryData->VendorId,
                          8,
                          '_');
                break;

            //
            // Bus + Vendor + Product + Revision[0]
            //
            case 3:

                sprintf(scratch, "USBSTOR\\");
                //
                // Fall through to the next set.
                //

            //
            // Vendor + Product + Revision[0] (win9x)
            //
            case 4:

                CopyField(scratch + strlen(scratch),
                          inquiryData->VendorId,
                          8,
                          '_');
                CopyField(scratch + strlen(scratch),
                          inquiryData->ProductId,
                          16,
                          '_');
                CopyField(scratch + strlen(scratch),
                          inquiryData->ProductRevisionLevel,
                          1,
                          '_');
                break;


            //
            // Bus + Generic Type
            //
            case 5:

                sprintf(scratch, "USBSTOR\\%s", genTypeString);
                break;

            //
            // Generic Type
            //
            case 6:

                sprintf(scratch, "%s", genTypeString);
                break;

            default:
                ASSERT(FALSE);
                break;
        }

        // Now allocate a tmp buffer for this string and copy the scratch
        // buffer to the tmp buffer
        //
        if (strlen(scratch) != 0)
        {
            strings[i] = ExAllocatePoolWithTag(
                             PagedPool,
                             strlen(scratch) + sizeof(UCHAR),
                             POOL_TAG);

            if (strings[i] == NULL)
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            else
            {
                strcpy(strings[i], scratch);
            }
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        // Now convert the array of stings to one Unicode MultiSz
        //
        ntStatus = USBSTOR_StringArrayToMultiSz(UnicodeString, strings);
    }

    // Now free up the tmp buffers for each string
    //
    for (i = 0; i < NUMBER_HARDWARE_STRINGS; i++)
    {
        if (strings[i])
        {
            ExFreePool(strings[i]);
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryHardwareIds %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryCompatibleIds()
//
// This routine handles IRP_MN_QUERY_ID BusQueryCompatibleIDs for the PDO.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryCompatibleIds (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;
    PUCHAR                  devTypeString;
    UCHAR                   s[sizeof("USBSTOR\\DEVICE_TYPE_GOES_HERE")];
    PSTR                    strings[] = {s, "USBSTOR\\RAW", NULL};
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryCompatibleIds\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    devTypeString = USBSTOR_PdoDeviceTypeString(DeviceObject);

    sprintf(s, "USBSTOR\\%s", devTypeString);

    ntStatus = USBSTOR_StringArrayToMultiSz(UnicodeString, strings);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryCompatibleIds %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryDeviceText()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_DEVICE_TEXT for the PDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryDeviceText (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;
    PIO_STACK_LOCATION      irpStack;
    DEVICE_TEXT_TYPE        textType;
    UCHAR                   ansiBuffer[256];
    ANSI_STRING             ansiText;
    UNICODE_STRING          unicodeText;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryDeviceText\n"));

    LOGENTRY('PQDT', DeviceObject, Irp, 0);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    textType = irpStack->Parameters.QueryDeviceText.DeviceTextType;

    if (textType == DeviceTextDescription)
    {
        PUCHAR  c;
        LONG    i;

        RtlZeroMemory(ansiBuffer, sizeof(ansiBuffer));

        RtlCopyMemory(ansiBuffer,
                      inquiryData->VendorId,
                      sizeof(inquiryData->VendorId));

        c = ansiBuffer;

        for (i = sizeof(inquiryData->VendorId)-1; i >= 0; i--)
        {
            if((c[i] != '\0') &&
               (c[i] != ' '))
            {
                i++;
                break;
            }
        }
        c += i;
        *c++ = ' ';

        RtlCopyMemory(c,
                      inquiryData->ProductId,
                      sizeof(inquiryData->ProductId));

        for (i = sizeof(inquiryData->ProductId)-1; i >= 0; i--)
        {
            if((c[i] != '\0') &&
               (c[i] != ' '))
            {
                i++;
                break;
            }
        }
        c += i;
        *c++ = ' ';

        sprintf(c, "USB Device");

        RtlInitAnsiString(&ansiText, ansiBuffer);

        ntStatus = RtlAnsiStringToUnicodeString(&unicodeText,
                                                &ansiText,
                                                TRUE);

        if (NT_SUCCESS(ntStatus))
        {
            Irp->IoStatus.Information = (ULONG_PTR)unicodeText.Buffer;
        }
        else
        {
            Irp->IoStatus.Information = (ULONG_PTR)NULL;
        }
    }
    else
    {
        // If a device does not provide description or location information,
        // the device's underlying bus driver completes the IRP without
        // modifying Irp->IoStatus.Status or Ipr->IoStatus.Information.
        //
        ntStatus = Irp->IoStatus.Status;
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryDeviceText %08X\n", ntStatus));

    LOGENTRY('pqdt', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoBusQueryInstanceId()
//
// This routine handles IRP_MN_QUERY_ID BusQueryInstanceID for the PDO.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoBusQueryInstanceId (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    USHORT                  length;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoBusQueryInstanceId\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceExtension = pdoDeviceExtension->ParentFDO->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    if (fdoDeviceExtension->SerialNumber == NULL)
    {
        // If we set DEVICE_CAPABILITIES.UniqueID = 0 in response to a
        // IRP_MN_QUERY_CAPABILITIES, we can return a NULL ID in response
        // to a BusQueryInstanceID.
        //
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        // Return an NULL-terminated InstanceId string with the format:
        // <USB Device SerialNumberString> + '&' + <LUN value in hex>
        //
        length = fdoDeviceExtension->SerialNumber->bLength -
                 sizeof(USB_COMMON_DESCRIPTOR) +
                 3 * sizeof(WCHAR);

        UnicodeString->Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    length,
                                    POOL_TAG);

        if (UnicodeString->Buffer == NULL)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            UnicodeString->Length = length - sizeof(WCHAR);
            UnicodeString->MaximumLength = length;

            // Copy the USB Device SerialNumberString
            //
            RtlCopyMemory(UnicodeString->Buffer,
                          &fdoDeviceExtension->SerialNumber->bString[0],
                          length - 3 * sizeof(WCHAR));

            // Append a '&'
            //
            UnicodeString->Buffer[length/sizeof(WCHAR) - 3] = (WCHAR)'&';

            // Append the LUN value in hex
            //
            if (pdoDeviceExtension->LUN <= 9)
            {
                UnicodeString->Buffer[length/sizeof(WCHAR) - 2] =
                    (WCHAR)('0' + pdoDeviceExtension->LUN);
            }
            else
            {
                UnicodeString->Buffer[length/sizeof(WCHAR) - 2] =
                    (WCHAR)('A' + pdoDeviceExtension->LUN - 0xA);
            }

            UnicodeString->Buffer[length/sizeof(WCHAR) - 1] =
                UNICODE_NULL;

            ntStatus = STATUS_SUCCESS;
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_PdoBusQueryInstanceId %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryDeviceRelations()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_DEVICE_RELATIONS for the PDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryDeviceRelations (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    DEVICE_RELATION_TYPE    relationType;
    PDEVICE_RELATIONS       newRelations;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    relationType = irpStack->Parameters.QueryDeviceRelations.Type;

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryDeviceRelations %d\n",
                 relationType));

    LOGENTRY('PQDR', DeviceObject, Irp, relationType);

    switch (relationType)
    {
        case TargetDeviceRelation:
            //
            // Return a relation list containing ourself.
            //
            newRelations = ExAllocatePoolWithTag(
                               PagedPool,
                               sizeof(DEVICE_RELATIONS),
                               POOL_TAG);

            if (newRelations)
            {
                newRelations->Count = 1;
                newRelations->Objects[0] = DeviceObject;

                ObReferenceObject(DeviceObject);

                ntStatus = STATUS_SUCCESS;
                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = (ULONG_PTR)newRelations;
            }
            else
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;
            }

            break;

        case BusRelations:
        case EjectionRelations:
        case PowerRelations:
        case RemovalRelations:
        default:
            //
            // Just complete the request with it's current status
            //
            ntStatus = Irp->IoStatus.Status;
            break;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryDeviceRelations %08X\n", ntStatus));

    LOGENTRY('pqdr', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryCapabilities()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES for the PDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PDEVICE_CAPABILITIES    deviceCapabilities;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceExtension = pdoDeviceExtension->ParentFDO->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryCapabilities\n"));

    LOGENTRY('PQCP', DeviceObject, Irp, 0);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

    // Pass IRP_MN_QUERY_CAPABILITIES Irp down the stack first before we do
    // anything.
    //
    ntStatus = USBSTOR_SyncPassDownIrp(pdoDeviceExtension->ParentFDO,
                                       Irp);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_QUERY_CAPABILITIES\n"));
    }
    else
    {
        if (fdoDeviceExtension->SerialNumber == NULL)
        {
            deviceCapabilities->UniqueID = FALSE;
        }

        deviceCapabilities->Removable = FALSE;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryCapabilities %08X\n", ntStatus));

    LOGENTRY('pqcp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_SyncPassDownIrp()
//
//******************************************************************************

NTSTATUS
USBSTOR_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;
    KEVENT                  localevent;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_SyncPassDownIrp\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Copy down Irp params for the next driver
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(Irp,
                           USBSTOR_SyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel

    // Pass the Irp down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    DBGPRINT(2, ("exit:  USBSTOR_SyncPassDownIrp %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_SyncCompletionRoutine()
//
// Completion routine used by USBSTOR_SyncPassDownIrp and
// USBSTOR_SyncSendUsbRequest
//
// If the Irp is one we allocated ourself, DeviceObject is NULL.
//
//******************************************************************************

NTSTATUS
USBSTOR_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent;

    LOGENTRY('SCR ', DeviceObject, Irp, Irp->IoStatus.Status);

    kevent = (PKEVENT)Context;

    KeSetEvent(kevent,
               IO_NO_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//******************************************************************************
//
// USBSTOR_SyncSendUsbRequest()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    KEVENT                  localevent;
    PIRP                    irp;
    PIO_STACK_LOCATION      nextStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(3, ("enter: USBSTOR_SyncSendUsbRequest\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Allocate the Irp
    //
    irp = IoAllocateIrp(fdoDeviceExtension->StackDeviceObject->StackSize, FALSE);

    LOGENTRY('SSUR', DeviceObject, irp, Urb);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = Urb;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(irp,
                           USBSTOR_SyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel



    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        LARGE_INTEGER timeout;

        // Specify a timeout of 5 seconds to wait for this call to complete.
        //
        timeout.QuadPart = -10000 * 5000;

        ntStatus = KeWaitForSingleObject(&localevent,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &timeout);

        if (ntStatus == STATUS_TIMEOUT)
        {
            ntStatus = STATUS_IO_TIMEOUT;

            // Cancel the Irp we just sent.
            //
            IoCancelIrp(irp);

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&localevent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else
        {
            ntStatus = irp->IoStatus.Status;
        }
    }

    // Done with the Irp, now free it.
    //
    IoFreeIrp(irp);

    LOGENTRY('ssur', ntStatus, Urb, Urb->UrbHeader.Status);

    DBGPRINT(3, ("exit:  USBSTOR_SyncSendUsbRequest %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetDescriptor()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    )
{
    USHORT      function;
    PURB        urb;
    NTSTATUS    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetDescriptor\n"));

    *Descriptor = NULL;

    // Set the URB function based on Recipient {Device, Interface, Endpoint}
    //
    switch (Recipient)
    {
        case USB_RECIPIENT_DEVICE:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE;
            break;
        case USB_RECIPIENT_INTERFACE:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE;
            break;
        case USB_RECIPIENT_ENDPOINT:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT;
            break;
        default:
            return STATUS_INVALID_PARAMETER;
    }

    // Allocate a descriptor buffer
    //
    *Descriptor = ExAllocatePoolWithTag(NonPagedPool,
                                        DescriptorLength,
                                        POOL_TAG);

    if (*Descriptor != NULL)
    {
        // Allocate a URB for the Get Descriptor request
        //
        urb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                    POOL_TAG);

        if (urb != NULL)
        {
            do
            {
                // Initialize the URB
                //
                urb->UrbHeader.Function = function;
                urb->UrbHeader.Length = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);
                urb->UrbControlDescriptorRequest.TransferBufferLength = DescriptorLength;
                urb->UrbControlDescriptorRequest.TransferBuffer = *Descriptor;
                urb->UrbControlDescriptorRequest.TransferBufferMDL = NULL;
                urb->UrbControlDescriptorRequest.UrbLink = NULL;
                urb->UrbControlDescriptorRequest.DescriptorType = DescriptorType;
                urb->UrbControlDescriptorRequest.Index = Index;
                urb->UrbControlDescriptorRequest.LanguageId = LanguageId;

                // Send the URB down the stack
                //
                ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject,
                                                     urb);

                if (NT_SUCCESS(ntStatus))
                {
                    // No error, make sure the length and type are correct
                    //
                    if ((DescriptorLength ==
                         urb->UrbControlDescriptorRequest.TransferBufferLength) &&
                        (DescriptorType ==
                         ((PUSB_COMMON_DESCRIPTOR)*Descriptor)->bDescriptorType))
                    {
                        // The length and type are correct, all done
                        //
                        break;
                    }
                    else
                    {
                        // No error, but the length or type is incorrect
                        //
                        ntStatus = STATUS_DEVICE_DATA_ERROR;
                    }
                }

            } while (RetryCount-- > 0);

            ExFreePool(urb);
        }
        else
        {
            // Failed to allocate the URB
            //
            ExFreePool(*Descriptor);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        // Failed to allocate the descriptor buffer
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus))
    {
        if (*Descriptor != NULL)
        {
            ExFreePool(*Descriptor);
            *Descriptor = NULL;
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_GetDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetMaxLun()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_GetMaxLun (
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PUCHAR          MaxLun
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PUCHAR                  maxLunBuf;
    ULONG                   retryCount;
    PURB                    urb;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetMaxLun\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Return zero unless we successfully return a non-zero value
    //
    *MaxLun = 0;

    // Allocate a URB for the Get Max LUN request, plus an extra byte at
    // the end for the transfer buffer.
    //
    urb = ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(URB) + 1,
                                POOL_TAG);

    if (urb != NULL)
    {
        // Get a pointer to the transfer buffer, which is the byte immediately
        // after the end of the URB.
        //
        maxLunBuf = (PUCHAR)(urb + 1);

        retryCount = 2;

        do
        {
            // Initialize the Control Transfer URB, all fields default to zero
            //
            RtlZeroMemory(urb, sizeof(URB) + 1);

            CLASS_URB(urb).Hdr.Length = sizeof(CLASS_URB(urb));

            CLASS_URB(urb).Hdr.Function = URB_FUNCTION_CLASS_INTERFACE;

            CLASS_URB(urb).TransferFlags = USBD_TRANSFER_DIRECTION_IN;

            CLASS_URB(urb).TransferBufferLength = 1;

            CLASS_URB(urb).TransferBuffer = maxLunBuf;

            // CLASS_URB(urb).TransferBufferMDL        is already zero

            // CLASS_URB(urb).RequestTypeReservedBits  is already zero

            CLASS_URB(urb).Request = BULK_ONLY_GET_MAX_LUN;

            // CLASS_URB(urb).Value                    is already zero

            // Target the request at the proper interface on the device
            //
            CLASS_URB(urb).Index = fdoDeviceExtension->InterfaceInfo->InterfaceNumber;

            // Send the URB down the stack
            //
            ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject,
                                                  urb);

            if (NT_SUCCESS(ntStatus))
            {
                // No error, make sure the length is correct
                //
                if (CLASS_URB(urb).TransferBufferLength == 1)
                {
                    // The length is correct, return the value if it looks ok
                    //
                    if (*maxLunBuf <= BULK_ONLY_MAXIMUM_LUN)
                    {
                        *MaxLun = *maxLunBuf;
                    }
                    else
                    {
                        ntStatus = STATUS_DEVICE_DATA_ERROR;
                    }

                    break;
                }
                else
                {
                    // No error, but the length or type is incorrect
                    //
                    ntStatus = STATUS_DEVICE_DATA_ERROR;
                }
            }
            else if (USBD_STATUS(CLASS_URB(urb).Hdr.Status) ==
                     USBD_STATUS(USBD_STATUS_STALL_PID))
            {
                // Some devices which do not support the Get Max LUN request
                // get confused and will STALL a CBW on the Bulk endpoint
                // it if immediately follows the Get Max LUN request.
                //
                // It should never be necessary to send a Clear_Feature
                // Endpoint_Stall for Control EP0, but doing so appears to
                // be one way to unconfuse devices which are confused by the
                // Get Max LUN request.

                // Initialize the Control Transfer URB, all fields default to zero
                //
                RtlZeroMemory(urb, sizeof(URB));

                FEATURE_URB(urb).Hdr.Length = sizeof(FEATURE_URB(urb));

                FEATURE_URB(urb).Hdr.Function = URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT;

                FEATURE_URB(urb).FeatureSelector = USB_FEATURE_ENDPOINT_STALL;

                // FEATURE_URB(urb).Index                    is already zero

                // Send the URB down the stack
                //
                USBSTOR_SyncSendUsbRequest(DeviceObject,
                                           urb);
            }

        } while (retryCount-- > 0);

        ExFreePool(urb);
    }
    else
    {
        // Failed to allocate the URB
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  USBSTOR_GetMaxLun %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_SelectConfiguration()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_SelectConfiguration (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PURB                            urb;
    PFDO_DEVICE_EXTENSION           fdoDeviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY      interfaceList;
    PUSB_INTERFACE_DESCRIPTOR       interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION     interfaceInfo;
    LONG                            i;
    LONG                            bulkInIndex;
    LONG                            bulkOutIndex;
    LONG                            interruptInIndex;
    NTSTATUS                        ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_SelectConfiguration\n"));

    LOGENTRY('SCON', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    configurationDescriptor = fdoDeviceExtension->ConfigurationDescriptor;

    // Allocate storage for an Inteface List to use as an input/output
    // parameter to USBD_CreateConfigurationRequestEx().
    //
    interfaceList = ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(USBD_INTERFACE_LIST_ENTRY) * 2,
                        POOL_TAG);

    if (interfaceList)
    {
        // Mutate configuration descriptor to suit our wishes
        //
        USBSTOR_AdjustConfigurationDescriptor(
            DeviceObject,
            fdoDeviceExtension->ConfigurationDescriptor,
            &interfaceDescriptor,
            &bulkInIndex,
            &bulkOutIndex,
            &interruptInIndex);

        // Save the Interface Descriptor pointer so we don't have
        // to parse the Configuration Descriptor again in case we
        // want to look at it.
        //
        fdoDeviceExtension->InterfaceDescriptor = interfaceDescriptor;

        if (interfaceDescriptor)
        {
            // Add the single Interface Descriptor we care about to the
            // interface list, then terminate the list.
            //
            interfaceList[0].InterfaceDescriptor = interfaceDescriptor;
            interfaceList[1].InterfaceDescriptor = NULL;

            // USBD will fail a SELECT_CONFIGURATION request if the Config
            // Descriptor bNumInterfaces does not match the number of interfaces
            // in the SELECT_CONFIGURATION request.  Since we are ignoring
            // any interfaces other than the first interface, set the Config
            // Descriptor bNumInterfaces to 1.
            //
            // This is only necessary in case this driver is loaded for an
            // entire multiple interface device and not as a single interface
            // child of the composite parent driver.
            //
            configurationDescriptor->bNumInterfaces = 1;

            // Create a SELECT_CONFIGURATION URB, turning the Interface
            // Descriptors in the interfaceList into USBD_INTERFACE_INFORMATION
            // structures in the URB.
            //
            urb = USBD_CreateConfigurationRequestEx(
                      configurationDescriptor,
                      interfaceList
                      );

            if (urb)
            {
                // Now issue the USB request to set the Configuration
                //
                ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject,
                                                     urb);

                if (NT_SUCCESS(ntStatus))
                {
                    // Save the configuration handle for this device in
                    // the Device Extension.
                    //
                    fdoDeviceExtension->ConfigurationHandle =
                        urb->UrbSelectConfiguration.ConfigurationHandle;

                    interfaceInfo = &urb->UrbSelectConfiguration.Interface;

                    // Save a copy of the interface information returned
                    // by the SELECT_CONFIGURATION request in the Device
                    // Extension.  This gives us a list of PIPE_INFORMATION
                    // structures for each pipe opened in this configuration.
                    //
                    ASSERT(fdoDeviceExtension->InterfaceInfo == NULL);

                    fdoDeviceExtension->InterfaceInfo =
                        ExAllocatePoolWithTag(NonPagedPool,
                                              interfaceInfo->Length,
                                              POOL_TAG);

                    if (fdoDeviceExtension->InterfaceInfo)
                    {
                        RtlCopyMemory(fdoDeviceExtension->InterfaceInfo,
                                      interfaceInfo,
                                      interfaceInfo->Length);
                    }
                    else
                    {
                        // Could not allocate a copy of interface information
                        //
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (NT_SUCCESS(ntStatus))
                {
                    // Reuse the SELECT_CONFIGURATION request URB as a
                    // SELECT_INTERFACE request URB and send down a request to
                    // select the default alternate interface setting that is
                    // currently in effect.  The point of this seemingly
                    // useless request is to make sure the endpoint
                    // MaximumTransferSize values are in effect.
                    //
                    // When USBHUB is loaded as a composite parent for a
                    // multiple interface device it ignores SELECT_CONFIGURATION
                    // requests from child device drivers.  In particular the
                    // MaximumTransferSize values of child driver SELECT_CONFIGURATION
                    // requests are ignored and the default 4KB value remains
                    // in effect.  The composite parent driver will respect the
                    // MaximumTransferSize values of child driver SELECT_INTERFACE
                    // requests.
                    //
                    ASSERT(GET_SELECT_INTERFACE_REQUEST_SIZE(fdoDeviceExtension->InterfaceInfo->NumberOfPipes) <
                           GET_SELECT_CONFIGURATION_REQUEST_SIZE(1, fdoDeviceExtension->InterfaceInfo->NumberOfPipes));

                    RtlZeroMemory(urb, GET_SELECT_INTERFACE_REQUEST_SIZE(fdoDeviceExtension->InterfaceInfo->NumberOfPipes));

                    urb->UrbSelectInterface.Hdr.Length =
                        (USHORT)GET_SELECT_INTERFACE_REQUEST_SIZE(fdoDeviceExtension->InterfaceInfo->NumberOfPipes);

                    urb->UrbSelectInterface.Hdr.Function =
                        URB_FUNCTION_SELECT_INTERFACE;

                    urb->UrbSelectInterface.ConfigurationHandle =
                        fdoDeviceExtension->ConfigurationHandle;

                    interfaceInfo = &urb->UrbSelectInterface.Interface;

                    RtlCopyMemory(interfaceInfo,
                                  fdoDeviceExtension->InterfaceInfo,
                                  fdoDeviceExtension->InterfaceInfo->Length);

                    // Override the USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE
                    // for all pipes.
                    //
                    for (i=0; i<(LONG)interfaceInfo->NumberOfPipes; i++)
                    {
                        if (i == bulkInIndex || i == bulkOutIndex)
                        {
                            interfaceInfo->Pipes[i].MaximumTransferSize =
                                USBSTOR_MAX_TRANSFER_SIZE;

                            DBGPRINT(1, ("Set pipe %d MaximumTransferSize to %X\n",
                                         i,
                                         interfaceInfo->Pipes[i].MaximumTransferSize));
                        }
                        else if (i == interruptInIndex)
                        {
                            interfaceInfo->Pipes[i].MaximumTransferSize =
                                sizeof(USHORT);

                            DBGPRINT(1, ("Set pipe %d MaximumTransferSize to %X\n",
                                         i,
                                         interfaceInfo->Pipes[i].MaximumTransferSize));
                        }
                    }

                    // Now issue the USB request to set the Interface
                    //
                    ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject,
                                                          urb);

                    if (NT_SUCCESS(ntStatus))
                    {
                        ASSERT(interfaceInfo->Length ==
                               fdoDeviceExtension->InterfaceInfo->Length);

                        RtlCopyMemory(fdoDeviceExtension->InterfaceInfo,
                                      interfaceInfo,
                                      fdoDeviceExtension->InterfaceInfo->Length);
                    }
                }

                // Done with the URB
                //
                ExFreePool(urb);
            }
            else
            {
                // Could not allocate urb
                //
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            // Did not parse an Interface Descriptor out of the Configuration
            // Descriptor, the Configuration Descriptor must be bad.
            //
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        // Done with the interface list
        //
        ExFreePool(interfaceList);
    }
    else
    {
        // Could not allocate Interface List
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  USBSTOR_SelectConfiguration %08X\n", ntStatus));

    LOGENTRY('scon', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_UnConfigure()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_UnConfigure (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;
    PURB                    urb;
    ULONG                   ulSize;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_UnConfigure\n"));

    LOGENTRY('UCON', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Allocate a URB for the SELECT_CONFIGURATION request.  As we are
    // unconfiguring the device, the request needs no pipe and interface
    // information structures.
    //
    ulSize = sizeof(struct _URB_SELECT_CONFIGURATION) -
             sizeof(USBD_INTERFACE_INFORMATION);

    urb = ExAllocatePoolWithTag(NonPagedPool, ulSize, POOL_TAG);

    if (urb)
    {
        // Initialize the URB.  A NULL Configuration Descriptor indicates
        // that the device should be unconfigured.
        //
        UsbBuildSelectConfigurationRequest(urb,
                                           (USHORT)ulSize,
                                           NULL);

        // Now issue the USB request to set the Configuration
        //
        ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject,
                                             urb);

        // Done with the URB now.
        //
        ExFreePool(urb);

        fdoDeviceExtension->ConfigurationHandle = 0;

        // Free the copy of the interface information that was allocated in
        // USBSTOR_SelectConfiguration().
        //
        if (fdoDeviceExtension->InterfaceInfo != NULL)
        {
            ExFreePool(fdoDeviceExtension->InterfaceInfo);

            fdoDeviceExtension->InterfaceInfo = NULL;
        }
    }
    else
    {
        // Could not allocate the URB.
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  USBSTOR_UnConfigure %08X\n", ntStatus));

    LOGENTRY('ucon', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_ResetPipe()
//
// This will reset the host pipe to Data0 and should also reset the device
// endpoint to Data0 for Bulk and Interrupt pipes by issuing a Clear_Feature
// Endpoint_Stall to the device endpoint.
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_ResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN USBD_PIPE_HANDLE Pipe
    )
{
    PURB        urb;
    NTSTATUS    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_ResetPipe\n"));

    LOGENTRY('RESP', DeviceObject, Pipe, 0);

    // Allocate URB for RESET_PIPE request
    //
    urb = ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(struct _URB_PIPE_REQUEST),
                                POOL_TAG);

    if (urb != NULL)
    {
        // Initialize RESET_PIPE request URB
        //
        urb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle = Pipe;

        // Submit RESET_PIPE request URB
        //
        ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject, urb);

        // Done with URB for RESET_PIPE request, free it
        //
        ExFreePool(urb);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  USBSTOR_ResetPipe %08X\n", ntStatus));

    LOGENTRY('resp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_AbortPipe()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_AbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN USBD_PIPE_HANDLE Pipe
    )
{
    PURB        urb;
    NTSTATUS    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_AbortPipe\n"));

    LOGENTRY('ABRT', DeviceObject, Pipe, 0);

    // Allocate URB for ABORT_PIPE request
    //
    urb = ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(struct _URB_PIPE_REQUEST),
                                POOL_TAG);

    if (urb != NULL)
    {
        // Initialize ABORT_PIPE request URB
        //
        urb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
        urb->UrbPipeRequest.PipeHandle = Pipe;

        // Submit ABORT_PIPE request URB
        //
        ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject, urb);

        // Done with URB for ABORT_PIPE request, free it
        //
        ExFreePool(urb);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  USBSTOR_AbortPipe %08X\n", ntStatus));

    LOGENTRY('abrt', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetBusInterface()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_GetBusInterface (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PUSB_BUS_INTERFACE_USBDI_V1  BusInterface
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIRP                    irp;
    KEVENT                  localevent;
    PIO_STACK_LOCATION      nextStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(1, ("enter: USBSTOR_GetBusInterface\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    RtlZeroMemory(BusInterface, sizeof(*BusInterface));

    // Allocate the Irp
    //
    irp = IoAllocateIrp((CCHAR)(fdoDeviceExtension->StackDeviceObject->StackSize),
                        FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the event we'll wait on.
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_PNP;

    nextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_GET_PORT_STATUS;

    nextStack->Parameters.QueryInterface.Interface =
        (PINTERFACE)BusInterface;

    nextStack->Parameters.QueryInterface.InterfaceSpecificData =
        NULL;

    nextStack->Parameters.QueryInterface.InterfaceType =
        &USB_BUS_INTERFACE_USBDI_GUID;

    nextStack->Parameters.QueryInterface.Size =
        sizeof(*BusInterface);

    nextStack->Parameters.QueryInterface.Version =
        USB_BUSIF_USBDI_VERSION_1;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutineEx(DeviceObject,
                             irp,
                             USBSTOR_SyncCompletionRoutine,
                             &localevent,
                             TRUE,      // InvokeOnSuccess
                             TRUE,      // InvokeOnError
                             TRUE);     // InvokeOnCancel

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED
    //
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    // Pass the Irp down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    if (NT_SUCCESS(ntStatus))
    {
        ASSERT(BusInterface->Version == USB_BUSIF_USBDI_VERSION_1);
        ASSERT(BusInterface->Size == sizeof(*BusInterface));
    }

    DBGPRINT(1, ("exit:  USBSTOR_GetBusInterface %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\usbser.h ===
/****************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        USBSER.H

Abstract:

        This header file is used for the Legacy USB Modem Driver

Environment:

        Kernel mode & user mode

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

Revision History:

        12/23/97 : created

Author:

        Tom Green

****************************************************************************/

#ifndef __USBSER_H__
#define __USBSER_H__

#ifdef DRIVER

// Various definitions
#define NAME_MAX                        80

#define MILLISECONDS_TIMEOUT(x) ((ULONGLONG) ((-x) * 10000))

#define NOTIFICATION_BUFF_SIZE  10

#define MAXIMUM_TRANSFER_SIZE           (8 * 1024)
#define RX_BUFF_SIZE             		(16 * 1024)
#define USB_RX_BUFF_SIZE				(RX_BUFF_SIZE / 4)
#define LOW_WATER_MARK					(USB_RX_BUFF_SIZE * 3)

#define DEVICE_STATE_UNKNOWN            0x0000
#define DEVICE_STATE_STARTED            0x0001
#define DEVICE_STATE_STOPPED            0x0002
#define DEVICE_STATE_REMOVED            0x0003

// device capabilities
#define DEVICE_CAP_VERSION              0x0001
#define DEVICE_CAP_UNUSED_PARAM         ((ULONG) -1)

// these describe bits in the modem status register
#define SERIAL_MSR_DCTS                 0x0001
#define SERIAL_MSR_DDSR                 0x0002
#define SERIAL_MSR_TERI                 0x0004
#define SERIAL_MSR_DDCD                 0x0008
#define SERIAL_MSR_CTS                  0x0010
#define SERIAL_MSR_DSR                  0x0020
#define SERIAL_MSR_RI                   0x0040
#define SERIAL_MSR_DCD                  0x0080

//
// These masks define access to the line status register.  The line
// status register contains information about the status of data
// transfer.  The first five bits deal with receive data and the
// last two bits deal with transmission.  An interrupt is generated
// whenever bits 1 through 4 in this register are set.
//

//
// This bit is the data ready indicator.  It is set to indicate that
// a complete character has been received.  This bit is cleared whenever
// the receive buffer register has been read.
//
#define SERIAL_LSR_DR       0x01

//
// This is the overrun indicator.  It is set to indicate that the receive
// buffer register was not read befor a new character was transferred
// into the buffer.  This bit is cleared when this register is read.
//
#define SERIAL_LSR_OE       0x02

//
// This is the parity error indicator.  It is set whenever the hardware
// detects that the incoming serial data unit does not have the correct
// parity as defined by the parity select in the line control register.
// This bit is cleared by reading this register.
//
#define SERIAL_LSR_PE       0x04

//
// This is the framing error indicator.  It is set whenever the hardware
// detects that the incoming serial data unit does not have a valid
// stop bit.  This bit is cleared by reading this register.
//
#define SERIAL_LSR_FE       0x08

//
// This is the break interrupt indicator.  It is set whenever the data
// line is held to logic 0 for more than the amount of time it takes
// to send one serial data unit.  This bit is cleared whenever the
// this register is read.
//
#define SERIAL_LSR_BI       0x10

//
// This is the transmit holding register empty indicator.  It is set
// to indicate that the hardware is ready to accept another character
// for transmission.  This bit is cleared whenever a character is
// written to the transmit holding register.
//
#define SERIAL_LSR_THRE     0x20

//
// This bit is the transmitter empty indicator.  It is set whenever the
// transmit holding buffer is empty and the transmit shift register
// (a non-software accessable register that is used to actually put
// the data out on the wire) is empty.  Basically this means that all
// data has been sent.  It is cleared whenever the transmit holding or
// the shift registers contain data.
//
#define SERIAL_LSR_TEMT     0x40

//
// This bit indicates that there is at least one error in the fifo.
// The bit will not be turned off until there are no more errors
// in the fifo.
//
#define SERIAL_LSR_FIFOERR  0x80



//
// Serial naming values
//

//
// Maximum length for symbolic link
//

#define SYMBOLIC_NAME_LENGTH    128

//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.

#define DEFAULT_DIRECTORY               L"DosDevices"

//
// Where in the DeviceMap section of the registry serial port entries
// should appear
//

#define SERIAL_DEVICE_MAP               L"SERIALCOMM"


// performance info for modem driver
typedef struct _PERF_INFO
{
        BOOLEAN                         PerfModeEnabled;
    ULONG                               BytesPerSecond;
} PERF_INFO, *PPERF_INFO;


#define SANITY_CHECK                    ((ULONG) 'ENAS')

#else

#include <winioctl.h>

#endif

// IOCTL info, needs to be visible for application

#define USBSER_IOCTL_INDEX      0x0800


#define GET_DRIVER_LOG          CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 0,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_IRP_HIST            CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 1,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_PATH_HIST           CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 2,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_ERROR_LOG           CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 3,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_ATTACHED_DEVICES    CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 4,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define SET_IRP_HIST_SIZE       CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 5,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define SET_PATH_HIST_SIZE      CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 6,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define SET_ERROR_LOG_SIZE      CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 7,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_DRIVER_INFO         CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 8,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)


#define ENABLE_PERF_TIMING      CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 9,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define DISABLE_PERF_TIMING     CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 10,       \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_PERF_DATA           CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 11,       \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define SET_DEBUG_TRACE_LEVEL   CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 12,       \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#ifdef DRIVER

// info about the driver, initialized in DriverEntry routine
PCHAR       DriverName;
PCHAR       DriverVersion;
ULONG       Usbser_Debug_Trace_Level;
ULONG       UsbSerSerialDebugLevel;
KSPIN_LOCK  GlobalSpinLock;

//
// Count of how many times the paged code has been locked
//

ULONG       PAGEUSBSER_Count;

//
// Handle to the locked paged code
//

PVOID       PAGEUSBSER_Handle;

//
// Pointer to funcion
//

PVOID       PAGEUSBSER_Function;

typedef struct _READ_CONTEXT
{
        PURB                            Urb;
        PDEVICE_OBJECT                  DeviceObject;
        PIRP                            Irp;
} READ_CONTEXT, *PREAD_CONTEXT;

// device extension for driver instance, used to store needed data

typedef struct _DEVICE_EXTENSION
{
        PDEVICE_OBJECT                  PhysDeviceObject;       // physical device object
        PDEVICE_OBJECT                  StackDeviceObject;      // stack device object
        CHAR                            LinkName[NAME_MAX];     // string name of symbolic link
        PUSB_DEVICE_DESCRIPTOR          DeviceDescriptor;       // device descriptor for device
        USBD_CONFIGURATION_HANDLE       ConfigurationHandle;    // configuration of USB device
        USBD_PIPE_HANDLE                DataInPipe;             // pipe for reading data
        USBD_PIPE_HANDLE                DataOutPipe;            // pipe for writing data
        USBD_PIPE_HANDLE                NotificationPipe;       // pipe for getting notifications from the device
        ULONG                           IRPCount;               // number of IRPs that passed through this device object
        LARGE_INTEGER                   ByteCount;              // number of bytes of data passed through this device object
        ULONG                           Instance;               // instance of device
        BOOLEAN                         IsDevice;               // is this a device or "global" device object
        BOOLEAN                         PerfTimerEnabled;       // enable perf timing
        LARGE_INTEGER                   BytesXfered;            // byte count for perf
        LARGE_INTEGER                   ElapsedTime;            // elapsed time for perf
        LARGE_INTEGER                   TimerStart;             // timer start for perf
        DEVICE_CAPABILITIES             DeviceCapabilities;
        ULONG                           PowerDownLevel;
        DEVICE_POWER_STATE              CurrentDevicePowerState;
        PIRP                            PowerIrp;
        BOOLEAN                         SelfPowerIrp;
        KEVENT                          SelfRequestedPowerIrpEvent;

        //
        // Nota Bene:  Locking hierarchy is acquire ControlLock *then*
        //             acquire CancelSpinLock.  We don't want to stall other
        //             drivers waiting for the cancel spin lock
        //

        KSPIN_LOCK                      ControlLock;            // protect extension
        ULONG                           CurrentBaud;            // current baud rate
        SERIAL_TIMEOUTS                 Timeouts;               // timeout controls for device
        ULONG                           IsrWaitMask;            // determine if occurence of events should be noticed
        SERIAL_LINE_CONTROL             LineControl;            // current value of line control reg
        SERIAL_HANDFLOW                 HandFlow;               // Handshake and control flow settings
        SERIALPERF_STATS                PerfStats;              // performance stats
        SERIAL_CHARS                    SpecialChars;           // special characters
        ULONG                           DTRRTSState;            // keep track of the current state of these lines
        ULONG                           SupportedBauds;         // "named" baud rates for device
        UCHAR                           EscapeChar;             // for LsrmstInsert IOCTL
        USHORT                          FakeModemStatus;        // looks like status register on modem
        USHORT                          FakeLineStatus;         // looks like line status register
        USHORT                          RxMaxPacketSize;        // max packet size fo the in data pipe
        PIRP                            NotifyIrp;              // Irp for notify reads
        PURB                            NotifyUrb;              // Urb for notify Irp
        PIRP                            ReadIrp;                // Irp for read requests
        PURB                            ReadUrb;                // Urb for read requests
        KEVENT                          ReadEvent;              // used to cancel a read Irp
        ULONG                           CharsInReadBuff;        // current number of characters buffered
        ULONG                           CurrentReadBuffPtr;     // pointer into read buffer
        BOOLEAN                         AcceptingRequests;      // is the device stopped or removed
        PIRP                            CurrentMaskIrp;         // current set or wait mask Irp
        ULONG                           HistoryMask;            // store mask events here
        ULONG                           OpenCnt;                // number of create calls on device
        PUCHAR                          NotificationBuff;       // buffer for notifications
        PUCHAR                          ReadBuff;               // circular buffer for read requests
        PUCHAR							USBReadBuff;			// buffer to get data from device
        UCHAR                           CommInterface;          // index of communications interface
        ULONG                           RxQueueSize;            // fake read buffer size
        ULONG                           ReadInterlock;          // state machine for starting reads from completion routine
        BOOLEAN                         ReadInProgress;
        ULONG                           DeviceState;            // current state of enumeration

        //
        // True if a symbolic link has been created and should be
        // removed upon deletion.
        //

        BOOLEAN                         CreatedSymbolicLink;

        //
        // Symbolic link name -- e.g., \\DosDevices\COMx
        //

        UNICODE_STRING                  SymbolicLinkName;

        //
        // Dos Name -- e.g., COMx
        //

        UNICODE_STRING                  DosName;

        //
        // Device Name -- e.g., \\Devices\UsbSerx
        //

        UNICODE_STRING                  DeviceName;

        //
        // Current Read Irp which is pending
        //

        PIRP                            CurrentReadIrp;

        //
        // Current Write Irp which is pending
        //

        PIRP                            CurrentWriteIrp;

        //
        // Read queue
        //

        LIST_ENTRY                      ReadQueue;

        //
        // This value holds the number of characters desired for a
        // particular read.  It is initially set by read length in the
        // IRP.  It is decremented each time more characters are placed
        // into the "users" buffer buy the code that reads characters
        // out of the typeahead buffer into the users buffer.  If the
        // typeahead buffer is exhausted by the read, and the reads buffer
        // is given to the isr to fill, this value is becomes meaningless.
        //

        ULONG                           NumberNeededForRead;

        //
        // Timer for timeout on total read request
        //

        KTIMER                          ReadRequestTotalTimer;

        //
        // Timer for timeout on the interval
        //

        KTIMER                          ReadRequestIntervalTimer;

        //
        // This is the kernal timer structure used to handle
        // total time request timing.
        //

        KTIMER                          WriteRequestTotalTimer;

        //
        // This value is set by the read code to hold the time value
        // used for read interval timing.  We keep it in the extension
        // so that the interval timer dpc routine determine if the
        // interval time has passed for the IO.
        //

        LARGE_INTEGER                   IntervalTime;

        //
        // This holds the value that we use to determine if we should use
        // the long interval delay or the short interval delay.
        //

        LARGE_INTEGER                   CutOverAmount;

        //
        // This holds the system time when we last time we had
        // checked that we had actually read characters.  Used
        // for interval timing.
        //

        LARGE_INTEGER                   LastReadTime;

        //
        // This points the the delta time that we should use to
        // delay for interval timing.
        //

        PLARGE_INTEGER                  IntervalTimeToUse;

        //
        // These two values hold the "constant" time that we should use
        // to delay for the read interval time.
        //

        LARGE_INTEGER                   ShortIntervalAmount;
        LARGE_INTEGER                   LongIntervalAmount;

        //
        // This dpc is fired off if the timer for the total timeout
        // for the read expires.  It will execute a dpc routine that
        // will cause the current read to complete.
        //
        //

        KDPC                            TotalReadTimeoutDpc;

        //
        // This dpc is fired off if the timer for the interval timeout
        // expires.  If no more characters have been read then the
        // dpc routine will cause the read to complete.  However, if
        // more characters have been read then the dpc routine will
        // resubmit the timer.
        //

        KDPC                            IntervalReadTimeoutDpc;

        //
        // This dpc is fired off if the timer for the total timeout
        // for the write expires.  It will execute a dpc routine that
        // will cause the current write to complete.
        //
        //

        KDPC                            TotalWriteTimeoutDpc;

        //
        // This keeps a total of the number of characters that
        // are in all of the "write" irps that the driver knows
        // about.  It is only accessed with the cancel spinlock
        // held.
        //

        ULONG                           TotalCharsQueued;

        //
        // This holds a count of the number of characters read
        // the last time the interval timer dpc fired.  It
        // is a long (rather than a ulong) since the other read
        // completion routines use negative values to indicate
        // to the interval timer that it should complete the read
        // if the interval timer DPC was lurking in some DPC queue when
        // some other way to complete occurs.
        //

        LONG                            CountOnLastRead;

        //
        // This is a count of the number of characters read by the
        // isr routine.  It is *ONLY* written at isr level.  We can
        // read it at dispatch level.
        //

        ULONG                           ReadByIsr;

        //
        // If non-NULL, means this write timed out and we should correct the
        // return value in the completion routine.
        //

        PIRP                            TimedOutWrite;

        //
        // If TRUE, that means we need to insert LSRMST
        //

        BOOLEAN                         EscapeSeen;


        //
        // Holds data that needs to be pushed such as LSRMST data
        //

        LIST_ENTRY                      ImmediateReadQueue;

        //
        // Pending wait-wake irp
        //

        PIRP                            PendingWakeIrp;

        //
        // True if WaitWake needs to be sent down before a powerdown
        //

        BOOLEAN                         SendWaitWake;

        //
        // SystemWake from devcaps
        //

        SYSTEM_POWER_STATE              SystemWake;

        //
        // DeviceWake from devcaps
        //

        DEVICE_POWER_STATE              DeviceWake;

        //
        // Count of Writes pending in the lower USB levels
        //

        ULONG                           PendingWriteCount;

        //
        // Counters and events to drain USB requests
        //

        KEVENT                          PendingDataInEvent;
        KEVENT                          PendingDataOutEvent;
        KEVENT                          PendingNotifyEvent;
        KEVENT                          PendingFlushEvent;

        ULONG                           PendingDataInCount;
        ULONG                           PendingDataOutCount;
        ULONG                           PendingNotifyCount;
        ULONG                           SanityCheck;

      	// selective suspend support
      	PIRP                        	PendingIdleIrp;
      	PUSB_IDLE_CALLBACK_INFO       	IdleCallbackInfo;
    	PIO_WORKITEM 					IoWorkItem;
    	IO_STATUS_BLOCK                 StatusBlock;

#ifdef SPINLOCK_TRACKING
      	LONG							CancelSpinLockCount;
      	LONG							SpinLockCount;
      	LONG							WaitingOnCancelSpinLock;
      	LONG							WaitingOnSpinLock;
#endif

#ifdef WMI_SUPPORT
      //
      // WMI Information
      //

      WMILIB_CONTEXT WmiLibInfo;

      //
      // Name to use as WMI identifier
      //

      UNICODE_STRING WmiIdentifier;

#endif

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _USBSER_IMMEDIATE_READ_PACKET {
   //
   // List of packets
   //

   LIST_ENTRY ImmediateReadQueue;

   //
   // Length of data
   //

   ULONG BufferLen;

   //
   //  Buffer itself, leave last in struct
   //

   UCHAR Buffer;



} USBSER_IMMEDIATE_READ_PACKET, *PUSBSER_IMMEDIATE_READ_PACKET;

typedef struct _USBSER_WRITE_PACKET {
   //
   // Device extension for this write
   //

   PDEVICE_EXTENSION DeviceExtension;

   //
   // Irp this packet belongs with
   //

   PIRP Irp;

   //
   // Write timer
   //

   KTIMER WriteTimer;

   //
   // Timeout value
   //

   LARGE_INTEGER WriteTimeout;

   //
   // TimerDPC
   //

   KDPC TimerDPC;

   //
   // Status
   //

   NTSTATUS Status;

   //
   // Urb for this write  N.B.: size is variable, so leave last
   //

   URB Urb;
} USBSER_WRITE_PACKET, *PUSBSER_WRITE_PACKET;


typedef NTSTATUS (*PUSBSER_START_ROUTINE)(IN PDEVICE_EXTENSION);
typedef VOID (*PUSBSER_GET_NEXT_ROUTINE) (IN PIRP *CurrentOpIrp,
                                          IN PLIST_ENTRY QueueToProcess,
                                          OUT PIRP *NewIrp,
                                          IN BOOLEAN CompleteCurrent,
                                          PDEVICE_EXTENSION Extension);

NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);

NTSTATUS
UsbSer_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Create(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Close(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Write(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Read(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

VOID
UsbSer_Unload(IN PDRIVER_OBJECT DriverObject);

NTSTATUS
UsbSer_PnPAddDevice(IN PDRIVER_OBJECT DriverObject,
                                        IN PDEVICE_OBJECT PhysicalDeviceObject);

NTSTATUS
UsbSer_PnP(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Power(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_SystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Cleanup(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSerMajorNotSupported(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSerStartOrQueue(IN PDEVICE_EXTENSION PDevExt, IN PIRP PIrp,
                   IN PLIST_ENTRY PQueue, IN PIRP *PPCurrentIrp,
                   IN PUSBSER_START_ROUTINE Starter);

VOID
UsbSerCancelQueued(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
UsbSerStartRead(IN PDEVICE_EXTENSION PDevExt);


VOID
UsbSerCancelCurrentRead(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

BOOLEAN
UsbSerGrabReadFromRx(IN PVOID Context);

VOID
UsbSerTryToCompleteCurrent(IN PDEVICE_EXTENSION PDevExt,
                           IN KIRQL IrqlForRelease, IN NTSTATUS StatusToUse,
                           IN PIRP *PpCurrentOpIrp,
                           IN PLIST_ENTRY PQueue OPTIONAL,
                           IN PKTIMER PIntervalTimer OPTIONAL,
                           IN PKTIMER PTotalTimer OPTIONAL,
                           IN PUSBSER_START_ROUTINE Starter OPTIONAL,
                           IN PUSBSER_GET_NEXT_ROUTINE PGetNextIrp OPTIONAL,
                           IN LONG RefType, IN BOOLEAN Complete);

VOID
UsbSerReadTimeout(IN PKDPC PDpc, IN PVOID DeferredContext,
                  IN PVOID SystemContext1, IN PVOID SystemContext2);

VOID
UsbSerIntervalReadTimeout(IN PKDPC PDpc, IN PVOID DeferredContext,
                          IN PVOID SystemContext1, IN PVOID SystemContext2);

VOID
UsbSerKillPendingIrps(PDEVICE_OBJECT PDevObj);

VOID
UsbSerCompletePendingWaitMasks(IN PDEVICE_EXTENSION DeviceExtension);


VOID
UsbSerKillAllReadsOrWrites(IN PDEVICE_OBJECT PDevObj,
                           IN PLIST_ENTRY PQueueToClean,
                           IN PIRP *PpCurrentOpIrp);

VOID
UsbSerRestoreModemSettings(PDEVICE_OBJECT PDevObj);

VOID
UsbSerProcessEmptyTransmit(IN PDEVICE_EXTENSION PDevExt);

VOID
UsbSerWriteTimeout(IN PKDPC Dpc, IN PVOID DeferredContext,
                   IN PVOID SystemContext1, IN PVOID SystemContext2);

NTSTATUS
UsbSerGiveWriteToUsb(IN PDEVICE_EXTENSION PDevExt, IN PIRP PIrp,
                     IN LARGE_INTEGER TotalTime);

VOID
UsbSerCancelWaitOnMask(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
UsbSerWriteComplete(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                    IN PUSBSER_WRITE_PACKET PPacket);

NTSTATUS
UsbSerFlush(IN PDEVICE_OBJECT PDevObj, PIRP PIrp);

NTSTATUS
UsbSerTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex);

NTSTATUS
UsbSerSystemControlDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
UsbSerSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer);

NTSTATUS
UsbSerSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer);

NTSTATUS
UsbSerQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex,
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer);

NTSTATUS
UsbSerQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo);


//
// The following three macros are used to initialize, set
// and clear references in IRPs that are used by
// this driver.  The reference is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//

#define USBSER_REF_RXBUFFER    (0x00000001)
#define USBSER_REF_CANCEL      (0x00000002)
#define USBSER_REF_TOTAL_TIMER (0x00000004)
#define USBSER_REF_INT_TIMER   (0x00000008)

#ifdef SPINLOCK_TRACKING

#define ACQUIRE_CANCEL_SPINLOCK(DEVEXT, IRQL)					\
{																\
	ASSERT(DEVEXT->SpinLockCount == 0);							\
	DEVEXT->WaitingOnCancelSpinLock++; 							\
	IoAcquireCancelSpinLock(IRQL);								\
	DEVEXT->CancelSpinLockCount++;								\
	DEVEXT->WaitingOnCancelSpinLock--; 							\
	ASSERT(DEVEXT->CancelSpinLockCount == 1);					\
}

#define RELEASE_CANCEL_SPINLOCK(DEVEXT, IRQL)					\
{																\
	DEVEXT->CancelSpinLockCount--;								\
	ASSERT(DEVEXT->CancelSpinLockCount == 0);					\
	IoReleaseCancelSpinLock(IRQL);								\
}

#define ACQUIRE_SPINLOCK(DEVEXT, LOCK, IRQL)					\
{																\
	DEVEXT->WaitingOnSpinLock++; 								\
	KeAcquireSpinLock(LOCK, IRQL);					    		\
	DEVEXT->SpinLockCount++;									\
	DEVEXT->WaitingOnSpinLock--; 								\
	ASSERT(DEVEXT->SpinLockCount == 1);							\
}

#define RELEASE_SPINLOCK(DEVEXT, LOCK, IRQL)					\
{																\
	DEVEXT->SpinLockCount--;									\
	ASSERT(DEVEXT->SpinLockCount == 0);							\
	KeReleaseSpinLock(LOCK, IRQL);					    		\
}

#else

#define ACQUIRE_CANCEL_SPINLOCK(DEVEXT, IRQL) 	IoAcquireCancelSpinLock(IRQL)
#define RELEASE_CANCEL_SPINLOCK(DEVEXT, IRQL) 	IoReleaseCancelSpinLock(IRQL)
#define ACQUIRE_SPINLOCK(DEVEXT, LOCK, IRQL)	KeAcquireSpinLock(LOCK, IRQL)
#define RELEASE_SPINLOCK(DEVEXT, LOCK, IRQL)	KeReleaseSpinLock(LOCK, IRQL)

#endif


#define USBSER_INIT_REFERENCE(Irp) { \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define USBSER_SET_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PUINT_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       *_arg4 |= _refType; \
   } while (0)

#define USBSER_CLEAR_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PUINT_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       *_arg4 &= ~_refType; \
   } while (0)

#define USBSER_REFERENCE_COUNT(Irp) \
    ((UINT_PTR)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))


//
// These values are used by the routines that can be used
// to complete a read (other than interval timeout) to indicate
// to the interval timeout that it should complete.
//
#define SERIAL_COMPLETE_READ_CANCEL ((LONG)-1)
#define SERIAL_COMPLETE_READ_TOTAL ((LONG)-2)
#define SERIAL_COMPLETE_READ_COMPLETE ((LONG)-3)

#if DBG

#define USBSERDUMPRD    ((ULONG)0x00000001)
#define USBSERDUMPWR    ((ULONG)0x00000002)
#define USBSERCOMPEV    ((ULONG)0x00000004)

#define USBSERTRACETM   ((ULONG)0x00100000)
#define USBSERTRACECN   ((ULONG)0x00200000)
#define USBSERTRACEPW   ((ULONG)0x00400000)
#define USBSERTRACERD   ((ULONG)0x01000000)
#define USBSERTRACEWR   ((ULONG)0x02000000)
#define USBSERTRACEIOC  ((ULONG)0x04000000)
#define USBSERTRACEOTH  ((ULONG)0x08000000)

#define USBSERBUGCHECK  ((ULONG)0x80000000)

#define USBSERTRACE     ((ULONG)0x0F700000)
#define USBSERDBGALL    ((ULONG)0xFFFFFFFF)

extern ULONG UsbSerSerialDebugLevel;

#define UsbSerSerialDump(LEVEL, STRING) \
   do { \
      ULONG _level = (LEVEL); \
      if (UsbSerSerialDebugLevel & _level) { \
         DbgPrint("UsbSer: "); \
         DbgPrint STRING; \
      } \
      if (_level == USBSERBUGCHECK) { \
         ASSERT(FALSE); \
      } \
   } while (0)
#else

#define UsbSerSerialDump(LEVEL,STRING) do {;} while (0)

#endif // DBG

#define USBSER_VENDOR_COMMAND 0
#define USBSER_CLASS_COMMAND  1

#endif  // DRIVER


#endif // __USBSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\usbserpw.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    USBSERPW.C

Abstract:

    Power Management module


Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1997-1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

    10/29/98 : created

Authors:

        Tom Green

--*/


#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "usbserpw.h"
#include "serioctl.h"
#include "utils.h"
#include "debugwdm.h"

//
// Power code is not pagable since we do not set DO_POWER_PAGABLE
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEUSBS, UsbSerSendWaitWake)
#endif // ALLOC_PRAGMA

/*++

Routine Description:

    This routine handles completion of the waitwake IRP.

Arguments:

    DeviceObject - Pointer to the device object for this device

    MinorFunction - Minor function previously supplied to PoRequestPowerIrp

    PowerState - PowerState previously supplied to PoRequestPowerIrp

    Context - a pointer to the device extension

    IoStatus - current/final status of the waitwake IRP

Return Value:

    The function value is the final status of attempting to process the
    waitwake.


--*/
NTSTATUS
UsbSerWakeCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction,
                     IN POWER_STATE PowerState, IN PVOID Context,
                     IN PIO_STATUS_BLOCK IoStatus)
{
   NTSTATUS             Status;
   PDEVICE_EXTENSION    DeviceExtension = (PDEVICE_EXTENSION)Context;
   POWER_STATE          NewPowerState;

   DEBUG_TRACE1(("UsbSerWakeCompletion\n"));

   DEBUG_TRACE1(("Status (%08X)\n", IoStatus->Status));

   Status = IoStatus->Status;

   if(NT_SUCCESS(Status))
   {
      //
      // A wakeup has occurred -- powerup our stack
      //

      DEBUG_TRACE1(("Powerup Device\n"));

      NewPowerState.DeviceState = PowerDeviceD0;

      PoRequestPowerIrp(DeviceExtension->PhysDeviceObject,
                        IRP_MN_SET_POWER, NewPowerState,
                        NULL, NULL, NULL);

   }

   DeviceExtension->PendingWakeIrp = NULL;

   return Status;
} // UsbSerWakeCompletion


/*++

Routine Description:

    This routine causes a waitwake IRP to be sent

Arguments:

    DeviceExtension - Pointer to the device extension for this device

Return Value:

    STATUS_INVALID_DEVICE_STATE if one is already pending, else result
    of call to PoRequestPowerIrp.


--*/
NTSTATUS
UsbSerSendWaitWake(PDEVICE_EXTENSION DeviceExtension)
{
   NTSTATUS     Status;
   PIRP         Irp;
   POWER_STATE  PowerState;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_TRACE1(("UsbSerSendWaitWake\n"));

   //
   // Make sure one isn't pending already -- usbser will only handle one at
   // a time.
   //

   if(DeviceExtension->PendingWakeIrp != NULL)
   {
      return STATUS_INVALID_DEVICE_STATE;
   }

   //
   // Make sure we are capable of waking the machine
   //

   if(DeviceExtension->SystemWake <= PowerSystemWorking)
   {
      return STATUS_INVALID_DEVICE_STATE;
   }

   if(DeviceExtension->DeviceWake == PowerDeviceUnspecified)
   {
      return STATUS_INVALID_DEVICE_STATE;
   }

   //
   // Send IRP to request wait wake
   //
   //

   DEBUG_TRACE1(("Request Wait Wake\n"));

   PowerState.SystemState = DeviceExtension->SystemWake;

   Status = PoRequestPowerIrp(DeviceExtension->PhysDeviceObject, IRP_MN_WAIT_WAKE,
                              PowerState, UsbSerWakeCompletion, DeviceExtension, &Irp);

   if(Status == STATUS_PENDING)
   {
      Status = STATUS_SUCCESS;
      DeviceExtension->PendingWakeIrp = Irp;
   }

   return Status;
} // UsbSerSendWaitWake


/*++

Routine Description:

    This is our FDO's dispatch table function for IRP_MJ_POWER.
    It processes the Power IRPs sent to the PDO for this device.

    For every power IRP, drivers must call PoStartNextPowerIrp and use PoCallDriver
    to pass the IRP all the way down the driver stack to the underlying PDO.


Arguments:

    DeviceObject - pointer to our device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
NTSTATUS
UsbSer_ProcessPowerIrp(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PIO_STACK_LOCATION      IrpStack;
    NTSTATUS                Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       DeviceExtension;
    BOOLEAN                 GoingToD0 = FALSE;
    POWER_STATE             SysPowerState, DesiredDevicePowerState;

    DEBUG_LOG_PATH("enter UsbSer_ProcessPowerIrp");

    DEBUG_TRACE1(("UsbSer_ProcessPowerIrp\n"));

    DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    switch(IrpStack->MinorFunction)
    {
        case IRP_MN_WAIT_WAKE:
            DEBUG_TRACE1(("IRP_MN_WAIT_WAKE\n"));

            // A driver sends IRP_MN_WAIT_WAKE to indicate that the system should
            // wait for its device to signal a wake event. The exact nature of the event
            // is device-dependent.
            // Drivers send this IRP for two reasons:
            // 1) To allow a device to wake the system
            // 2) To wake a device that has been put into a sleep state to save power
            //    but still must be able to communicate with its driver under certain circumstances.
            // When a wake event occurs, the driver completes the IRP and returns
            // STATUS_SUCCESS. If the device is sleeping when the event occurs,
            // the driver must first wake up the device before completing the IRP.
            // In a completion routine, the driver calls PoRequestPowerIrp to send a
            // PowerDeviceD0 request. When the device has powered up, the driver can
            //  handle the IRP_MN_WAIT_WAKE request.

            // DeviceCapabilities.DeviceWake specifies the lowest device power state (least powered)
            // from which the device can signal a wake event
            DeviceExtension->PowerDownLevel = DeviceExtension->DeviceWake;

            DEBUG_TRACE1(("CurrentDevicePowerState (%08X)  DeviceWakeup (%08X)\n",
                          DeviceExtension->CurrentDevicePowerState,
                          DeviceExtension->DeviceWake));

            if((PowerDeviceD0 == DeviceExtension->CurrentDevicePowerState) ||
              (DeviceExtension->DeviceWake > DeviceExtension->CurrentDevicePowerState))
            {
                //
                //    STATUS_INVALID_DEVICE_STATE is returned if the device in the PowerD0 state
                //    or a state below which it can support waking, or if the SystemWake state
                //    is below a state which can be supported. A pending IRP_MN_WAIT_WAKE will complete
                //    with this error if the device's state is changed to be incompatible with the wake
                //    request.

                //  If a driver fails this IRP, it should complete the IRP immediately without
                //  passing the IRP to the next-lower driver.
                Status = STATUS_INVALID_DEVICE_STATE;
                Irp->IoStatus.Status = Status;
                PoStartNextPowerIrp(Irp);
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
                return Status;
            }

            // If not failing outright, pass this on to our PDO for further handling
            IoCopyCurrentIrpStackLocationToNext(Irp);

            // Set a completion routine so it can signal our event when
            // the PDO is done with the Irp
            IoSetCompletionRoutine(Irp,
                                   UsbSerWaitWakeIrpCompletionRoutine,
                                   DeviceObject,// pass the event to the completion routine as the Context
                                   TRUE,        // invoke on success
                                   TRUE,        // invoke on error
                                   TRUE);       // invoke on cancellation

            DEBUG_TRACE1(("Send down wait wake\n"));

            PoStartNextPowerIrp(Irp);
            Status = PoCallDriver(DeviceExtension->StackDeviceObject,
                                  Irp);

            Status = STATUS_PENDING;

            break;

        case IRP_MN_SET_POWER:
        {

            DEBUG_TRACE1(("IRP_MN_SET_POWER\n"));

            // The system power policy manager sends this IRP to set the system power state.
            // A device power policy manager sends this IRP to set the device power state for a device.

            // Set Irp->IoStatus.Status to STATUS_SUCCESS to indicate that the device
            // has entered the requested state. Drivers cannot fail this IRP.

            switch(IrpStack->Parameters.Power.Type)
            {
                case SystemPowerState:
                    DEBUG_TRACE1(("SystemPowerState\n"));

                    // Get input system power state
                    SysPowerState.SystemState = IrpStack->Parameters.Power.State.SystemState;

                    DEBUG_TRACE1(("SystemState (%08X)\n", SysPowerState.SystemState));

#if DBG
                    {
                        ULONG Index;

                        for(Index = 0; Index < 8; Index++)
                        {
                            DEBUG_TRACE1(("DeviceState[%08X] (%08X)\n", Index,
                                           DeviceExtension->DeviceCapabilities.DeviceState[Index]));
                        }

                        DEBUG_TRACE1(("DeviceWake (%08X)\n", DeviceExtension->DeviceCapabilities.DeviceWake));
                        DEBUG_TRACE1(("SystemWake (%08X)\n", DeviceExtension->DeviceCapabilities.SystemWake));
                            
                        
                    }
#endif
                    // If system is in working state always set our device to D0
                    //  regardless of the wait state or system-to-device state power map
                    if(SysPowerState.SystemState == PowerSystemWorking)
                    {
                      DEBUG_TRACE1(("Setting to D0\n"));
                      DesiredDevicePowerState.DeviceState = PowerDeviceD0;
                    }
                    else
                    {
                        // set to corresponding system state if IRP_MN_WAIT_WAKE pending
                        if(DeviceExtension->SendWaitWake)
                        {
                            // got a WAIT_WAKE IRP pending?

                            DEBUG_TRACE1(("We want to send a wait wake Irp\n"));
                            
                            // Find the device power state equivalent to the given system state.
                            // We get this info from the DEVICE_CAPABILITIES struct in our device
                            // extension (initialized in UsbSer_PnPAddDevice() )
                            DesiredDevicePowerState.DeviceState =
                                DeviceExtension->DeviceCapabilities.DeviceState[SysPowerState.SystemState];

                        }
                        else
                        {
                            DEBUG_TRACE1(("No wait wake Irp to send\n"));

                            // if no wait pending and the system's not in working state, just turn off
                            DesiredDevicePowerState.DeviceState = PowerDeviceD3;

                        }
                    }

                    DEBUG_TRACE1(("DesiredDevicePowerState (%08X)\n", DesiredDevicePowerState.DeviceState));

                    //
                    // We've determined the desired device state; are we already in this state?
                    //

                    if(DesiredDevicePowerState.DeviceState !=
                        DeviceExtension->CurrentDevicePowerState)
                    {

                        // No, request that we be put into this state
                        // by requesting a new Power Irp from the Pnp manager
                        DeviceExtension->PowerIrp = Irp;
                        Status = PoRequestPowerIrp(DeviceExtension->PhysDeviceObject,
                                                   IRP_MN_SET_POWER,
                                                   DesiredDevicePowerState,
                                                   UsbSer_PoRequestCompletion,
                                                   DeviceObject,
                                                   NULL);

                    }
                    else
                    {
                        // Yes, just pass it on to PDO (Physical Device Object)
                        IoCopyCurrentIrpStackLocationToNext(Irp);
                        PoStartNextPowerIrp(Irp);
                        Status = PoCallDriver(DeviceExtension->StackDeviceObject,
                                              Irp);

                    }
                    break;

                case DevicePowerState:

                    DEBUG_TRACE1(("DevicePowerState\n"));

                    // For requests to D1, D2, or D3 ( sleep or off states ),
                    // sets deviceExtension->CurrentDevicePowerState to DeviceState immediately.
                    // This enables any code checking state to consider us as sleeping or off
                    // already, as this will imminently become our state.

                    // For requests to DeviceState D0 ( fully on ), sets fGoingToD0 flag TRUE
                    // to flag that we must set a completion routine and update
                    // deviceExtension->CurrentDevicePowerState there.
                    // In the case of powering up to fully on, we really want to make sure
                    // the process is completed before updating our CurrentDevicePowerState,
                    // so no IO will be attempted or accepted before we're really ready.


                    GoingToD0 = UsbSer_SetDevicePowerState(DeviceObject,
                                                           IrpStack->Parameters.Power.State.DeviceState);

                    IoCopyCurrentIrpStackLocationToNext(Irp);

                    if(GoingToD0)
                    {
                        IoSetCompletionRoutine(Irp,
                                               UsbSer_PowerIrp_Complete,
                                               DeviceObject,
                                               TRUE,            // invoke on success
                                               TRUE,            // invoke on error
                                               TRUE);           // invoke on cancellation of the Irp
                    }

                    PoStartNextPowerIrp(Irp);
                    Status = PoCallDriver(DeviceExtension->StackDeviceObject,
                                          Irp);

                    break;
                } /* case irpStack->Parameters.Power.Type */

            }
            break; /* IRP_MN_SET_POWER */

        case IRP_MN_QUERY_POWER:
            DEBUG_TRACE1(("IRP_MN_QUERY_POWER\n"));
            //
            // A power policy manager sends this IRP to determine whether it can change
            // the system or device power state, typically to go to sleep.
            //

            if(DeviceExtension->SendWaitWake)
            {
                if(IrpStack->Parameters.Power.Type == SystemPowerState
                   && DeviceExtension->DeviceCapabilities.DeviceState[IrpStack->Parameters.Power.State.SystemState]
                   > DeviceExtension->DeviceWake)
                {
                    Status = Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
                    PoStartNextPowerIrp(Irp);
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                    break;
                }
            }
            else
            {
                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);
                Status = PoCallDriver(DeviceExtension->StackDeviceObject,
                                      Irp);
                break;
            }

            // fall through to default

        default:

            //
            // All unhandled power messages are passed on to the PDO
            //

            IoCopyCurrentIrpStackLocationToNext(Irp);
            PoStartNextPowerIrp(Irp);
            Status = PoCallDriver(DeviceExtension->StackDeviceObject, Irp);

    } /* IrpStack->MinorFunction */

    DEBUG_LOG_PATH("exit  UsbSer_ProcessPowerIrp");

    return Status;
} // UsbSer_ProcessPowerIrp


/*++

Routine Description:

        This is the completion routine set in a call to PoRequestPowerIrp()
        that was made in BulkUsb_ProcessPowerIrp() in response to receiving
        an IRP_MN_SET_POWER of type 'SystemPowerState' when the device was
        not in a compatible device power state. In this case, a pointer to
        the IRP_MN_SET_POWER Irp is saved into the FDO device extension
        (deviceExtension->PowerIrp), and then a call must be
        made to PoRequestPowerIrp() to put the device into a proper power state,
        and this routine is set as the completion routine.

    We decrement our pending io count and pass the saved IRP_MN_SET_POWER Irp
        on to the next driver

Arguments:

    DeviceObject - Pointer to the device object for the class device.
        Note that we must get our own device object from the Context

    Context - Driver defined context, in this case our own functional device object ( FDO )

Return Value:

    The function value is the final status from the operation.

--*/
NTSTATUS
UsbSer_PoRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction,
                           IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus)
{
    PIRP                Irp;
    PDEVICE_EXTENSION   DeviceExtension;
    PDEVICE_OBJECT      ContextDeviceObject = Context;
    NTSTATUS            Status;

    DEBUG_LOG_PATH("enter UsbSer_PoRequestCompletion");

    DEBUG_TRACE1(("UsbSer_PoRequestCompletion\n"));

    DeviceExtension = ContextDeviceObject->DeviceExtension;

    // Get the Irp we saved for later processing in Usbser_ProcessPowerIrp()
    // when we decided to request the Power Irp that this routine
    // is the completion routine for.
    Irp = DeviceExtension->PowerIrp;

    // We will return the status set by the PDO for the power request we're completing
    Status = IoStatus->Status;

    // we must pass down to the next driver in the stack
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Calling PoStartNextPowerIrp() indicates that the driver is finished
    // with the previous power IRP, if any, and is ready to handle the next power IRP.
    // It must be called for every power IRP.Although power IRPs are completed only once,
    // typically by the lowest-level driver for a device, PoStartNextPowerIrp must be called
    // for every stack location. Drivers must call PoStartNextPowerIrp while the current IRP
    // stack location points to the current driver. Therefore, this routine must be called
    // before IoCompleteRequest, IoSkipCurrentStackLocation, and PoCallDriver.

    PoStartNextPowerIrp(Irp);

    // PoCallDriver is used to pass any power IRPs to the PDO instead of IoCallDriver.
    // When passing a power IRP down to a lower-level driver, the caller should use
    // IoSkipCurrentIrpStackLocation or IoCopyCurrentIrpStackLocationToNext to copy the IRP to
    // the next stack location, then call PoCallDriver. Use IoCopyCurrentIrpStackLocationToNext
    // if processing the IRP requires setting a completion routine, or IoSkipCurrentStackLocation
    // if no completion routine is needed.

    PoCallDriver(DeviceExtension->StackDeviceObject,
                 Irp);

    DeviceExtension->PowerIrp = NULL;

    DEBUG_LOG_PATH("exit  UsbSer_PoRequestCompletion");

    return Status;
} // UsbSer_PoRequestCompletion




/*++

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by Usbser_ProcessPowerIrp(), and that routine has  determined
        1) the request is for full powerup ( to PowerDeviceD0 ), and
        2) We are not already in that state
    A call is then made to PoRequestPowerIrp() with this routine set as the completion routine.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
NTSTATUS
UsbSer_PowerIrp_Complete(IN PDEVICE_OBJECT NullDeviceObject, IN PIRP Irp, IN PVOID Context)
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PDEVICE_OBJECT      DeviceObject;
    PIO_STACK_LOCATION  IrpStack;
    PDEVICE_EXTENSION   DeviceExtension;
    KIRQL               OldIrql;

    DEBUG_LOG_PATH("enter UsbSer_PowerIrp_Complete");

    DEBUG_TRACE1(("UsbSer_PowerIrp_Complete\n"));

    DeviceObject = (PDEVICE_OBJECT) Context;

    DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //  If the lower driver returned PENDING, mark our stack location as pending also.
    if(Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    IrpStack = IoGetCurrentIrpStackLocation (Irp);


    // Now that we know we've let the lower drivers do what was needed to power up,
    // we can set our device extension flags accordingly

    ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

    DeviceExtension->CurrentDevicePowerState = PowerDeviceD0;
    DeviceExtension->AcceptingRequests		 = TRUE;

    RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

    //
    // Restart the read and notify which we stopped when we powered down
    //

    RestartRead(DeviceExtension);
    RestartNotifyRead(DeviceExtension);

    UsbSerRestoreModemSettings(DeviceObject);

    Irp->IoStatus.Status = Status;

    DEBUG_LOG_PATH("exit  UsbSer_PowerIrp_Complete");

    return Status;
} // UsbSer_PowerIrp_Complete



/*++

Routine Description:

        Called on Usbser_PnPAddDevice() to power down until needed (i.e., till a pipe is actually opened).
        Called on Usbser_Create() to power up device to D0 before opening 1st pipe.
        Called on Usbser_Close() to power down device if this is the last pipe.

Arguments:

    DeviceObject - Pointer to the device object

    Suspend; TRUE to Suspend, FALSE to acivate.


Return Value:

    If the operation is not attemtped, SUCCESS is returned.
    If the operation is attemtped, the value is the final status from the operation.

--*/
NTSTATUS
UsbSer_SelfSuspendOrActivate(IN PDEVICE_OBJECT DeviceObject, IN BOOLEAN Suspend)
{
    NTSTATUS            Status = STATUS_SUCCESS;
    POWER_STATE         PowerState;
    PDEVICE_EXTENSION   DeviceExtension;

    DEBUG_LOG_PATH("enter UsbSer_SelfSuspendOrActivate");

    DEBUG_TRACE1(("UsbSer_SelfSuspendOrActivate\n"));

    DeviceExtension = DeviceObject->DeviceExtension;

    // Can't accept request if:
    //  1) device is removed,
    //  2) has never been started,
    //  3) is stopped,
    //  4) has a remove request pending,
    //  5) has a stop device pending
    if(!DeviceExtension->AcceptingRequests)
    {
        Status = STATUS_DELETE_PENDING;

        return Status;
    }


    // don't do anything if any System-generated Device Pnp irps are pending
    if(NULL != DeviceExtension->PowerIrp )
    {
        return Status;
    }

    // don't do anything if any self-generated Device Pnp irps are pending
    if(DeviceExtension->SelfPowerIrp )
    {
        return Status;
    }

    // dont do anything if registry CurrentControlSet\Services\BulkUsb\Parameters\PowerDownLevel
    //  has been set to  zero, PowerDeviceD0 ( 1 ), or a bogus high value
    if((DeviceExtension->PowerDownLevel == PowerDeviceD0) ||
        (DeviceExtension->PowerDownLevel == PowerDeviceUnspecified)  ||
        (DeviceExtension->PowerDownLevel >= PowerDeviceMaximum))
    {
        return Status;
    }

    if(Suspend)
        PowerState.DeviceState = DeviceExtension->PowerDownLevel;
    else
        PowerState.DeviceState = PowerDeviceD0;  // power up all the way; we're probably just about to do some IO

    Status = UsbSer_SelfRequestPowerIrp(DeviceObject, PowerState);

    DEBUG_LOG_PATH("exit  UsbSer_SelfSuspendOrActivate");

    return Status;
} // UsbSer_SelfSuspendOrActivate


/*++

Routine Description:

    This routine is called by UsbSer_SelfSuspendOrActivate() to
    actually make the system request for a powerdown/up to PowerState.
    It first checks to see if we are already in Powerstate and immediately
    returns  SUCCESS with no further processing if so


Arguments:

    DeviceObject - Pointer to the device object

    PowerState. power state requested, e.g PowerDeviceD0.


Return Value:

    The function value is the final status from the operation.

--*/
NTSTATUS
UsbSer_SelfRequestPowerIrp(IN PDEVICE_OBJECT DeviceObject, IN POWER_STATE PowerState)
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIRP                Irp = NULL;

    DEBUG_LOG_PATH("enter UsbSer_SelfRequestPowerIrp");

    DEBUG_TRACE1(("UsbSer_SelfRequestPowerIrp\n"));

    DeviceExtension =  DeviceObject->DeviceExtension;

    if(DeviceExtension->CurrentDevicePowerState == PowerState.DeviceState)
        return STATUS_SUCCESS;  // nothing to do


    // flag we're handling a self-generated power irp
    DeviceExtension->SelfPowerIrp = TRUE;

    // actually request the Irp
    Status = PoRequestPowerIrp(DeviceExtension->PhysDeviceObject,
                               IRP_MN_SET_POWER,
                               PowerState,
                               UsbSer_PoSelfRequestCompletion,
                               DeviceObject,
                               NULL);


    if(Status == STATUS_PENDING)
    {
        // status pending is the return code we wanted

        // We only need to wait for completion if we're powering up
        if((ULONG) PowerState.DeviceState < DeviceExtension->PowerDownLevel)
        {
            NTSTATUS WaitStatus;

            WaitStatus = KeWaitForSingleObject(&DeviceExtension->SelfRequestedPowerIrpEvent,
                                               Suspended,
                                               KernelMode,
                                               FALSE,
                                               NULL);

        }

        Status = STATUS_SUCCESS;

        DeviceExtension->SelfPowerIrp = FALSE;

    }
    else
    {
        // The return status was not STATUS_PENDING; any other codes must be considered in error here;
        //  i.e., it is not possible to get a STATUS_SUCCESS  or any other non-error return from this call;
    }

    DEBUG_LOG_PATH("exit  UsbSer_SelfRequestPowerIrp");

    return Status;
} // UsbSer_SelfRequestPowerIrp



/*++

Routine Description:

    This routine is called when the driver completes a self-originated power IRP
        that was generated by a call to BulkUsb_SelfSuspendOrActivate().
    We power down whenever the last pipe is closed and power up when the first pipe is opened.

    For power-up , we set an event in our FDO extension to signal this IRP done
    so the power request can be treated as a synchronous call.
    We need to know the device is powered up before opening the first pipe, for example.
    For power-down, we do not set the event, as no caller waits for powerdown complete.

Arguments:

    DeviceObject - Pointer to the device object for the class device. ( Physical Device Object )

    Context - Driver defined context, in this case our FDO ( functional device object )

Return Value:

    The function value is the final status from the operation.

--*/
NTSTATUS
UsbSer_PoSelfRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE          PowerState,
                               IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus)
{
    PDEVICE_OBJECT      ContextDeviceObject = Context;
    PDEVICE_EXTENSION   DeviceExtension = ContextDeviceObject->DeviceExtension;
    NTSTATUS            Status = IoStatus->Status;

    DEBUG_LOG_PATH("enter UsbSer_PoSelfRequestCompletion");

    DEBUG_TRACE1(("UsbSer_PoSelfRequestCompletion\n"));

    // We only need to set the event if we're powering up;
    // No caller waits on power down complete
    if((ULONG) PowerState.DeviceState < DeviceExtension->PowerDownLevel)
    {

        // Trigger Self-requested power irp completed event;
        // The caller is waiting for completion
        KeSetEvent(&DeviceExtension->SelfRequestedPowerIrpEvent, 1, FALSE);
    }

    DEBUG_LOG_PATH("exit  UsbSer_PoSelfRequestCompletion");

    return Status;
} // UsbSer_PoSelfRequestCompletion


/*++

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by Usbser_ProcessPowerIrp().


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    DeviceState - Device specific power state to set the device in to.


Return Value:

    For requests to DeviceState D0 ( fully on ), returns TRUE to signal caller
    that we must set a completion routine and finish there.

--*/
BOOLEAN
UsbSer_SetDevicePowerState(IN PDEVICE_OBJECT DeviceObject, IN DEVICE_POWER_STATE DeviceState)
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    BOOLEAN             Res = FALSE;
    KIRQL               OldIrql;
    POWER_STATE         State;

    DEBUG_LOG_PATH("enter UsbSer_SetDevicePowerState");

    DEBUG_TRACE1(("UsbSer_SetDevicePowerState\n"));

    DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    State.DeviceState = DeviceState;

    switch(DeviceState)
    {
        case PowerDeviceD3:
            DEBUG_TRACE1(("PowerDeviceD3\n"));

            //
            // Device will be going OFF,
            //

            ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
            DeviceExtension->CurrentDevicePowerState = DeviceState;
            RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

            UsbSerAbortPipes(DeviceObject);

            break;

        case PowerDeviceD1:
            DEBUG_TRACE1(("PowerDeviceD1\n"));
        case PowerDeviceD2:
            DEBUG_TRACE1(("PowerDeviceD2\n"));
            //
            // power states D1, D2 translate to USB suspend

            ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
            DeviceExtension->CurrentDevicePowerState = DeviceState;
            RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

            UsbSerAbortPipes(DeviceObject);

            if(DeviceExtension->SendWaitWake && DeviceState <= DeviceExtension->DeviceWake)
            {
                UsbSerSendWaitWake(DeviceExtension);
            }

            break;

        case PowerDeviceD0:
            DEBUG_TRACE1(("PowerDevice0\n"));


            // We'll need to finish the rest in the completion routine;
            // signal caller we're going to D0 and will need to set a completion routine
            Res = TRUE;

            // Caller will pass on to PDO ( Physical Device object )
            break;

        default:
            break;
    }

    PoSetPowerState(DeviceObject, DevicePowerState, State);

    DEBUG_LOG_PATH("exit  UsbSer_SetDevicePowerState");

    return Res;
} // UsbSer_SetDevicePowerState



NTSTATUS
UsbSerQueryCapabilities(IN PDEVICE_OBJECT DeviceObject, IN PDEVICE_CAPABILITIES DeviceCapabilities)
{
    PIO_STACK_LOCATION  NextStack;
    PIRP                Irp;
    NTSTATUS            NtStatus;
    KEVENT              Event;

    DEBUG_LOG_PATH("enter UsbSerQueryCapabilities");

    DEBUG_TRACE1(("UsbSerQueryCapabilities\n"));

    // Build an IRP for us to generate an internal query request to the PDO
    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if(!Irp)
        return STATUS_INSUFFICIENT_RESOURCES;


    NextStack = IoGetNextIrpStackLocation(Irp);

    NextStack->MajorFunction= IRP_MJ_PNP;
    NextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;


    // init an event to tell us when the completion routine's been called
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    // Set a completion routine so it can signal our event when
    //  the next lower driver is done with the Irp
    IoSetCompletionRoutine(Irp,
                           UsbSerIrpCompletionRoutine,
                           &Event,  // pass the event as Context to completion routine
                           TRUE,    // invoke on success
                           TRUE,    // invoke on error
                           TRUE);   // invoke on cancellation of the Irp


    // init Irp and query struct
    Irp->IoStatus.Status                    = STATUS_NOT_SUPPORTED;

    RtlZeroMemory(DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));

    DeviceCapabilities->Version             = DEVICE_CAP_VERSION;
    DeviceCapabilities->Size                = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Address             = DEVICE_CAP_UNUSED_PARAM;
    DeviceCapabilities->UINumber            = DEVICE_CAP_UNUSED_PARAM;
    DeviceCapabilities->SurpriseRemovalOK   = TRUE;
    
    // set our pointer to the DEVICE_CAPABILITIES struct
    NextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    NtStatus = IoCallDriver(DeviceObject, Irp);

    if(NtStatus == STATUS_PENDING)
    {
       // wait for irp to complete

       KeWaitForSingleObject(
            &Event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
    }

    IoFreeIrp(Irp);

    DEBUG_LOG_PATH("exit  UsbSerQueryCapabilities");

    return NtStatus;
} // UsbSerQueryCapabilities




NTSTATUS
UsbSerIrpCompletionRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PKEVENT Event = Context;

    DEBUG_LOG_PATH("enter UsbSerIrpCompletionRoutine");

    DEBUG_TRACE1(("UsbSerIrpCompletionRoutine\n"));

    // Set the input event
    KeSetEvent(Event,
               1,       // Priority increment  for waiting thread.
               FALSE);  // Flag this call is not immediately followed by wait.

    DEBUG_LOG_PATH("exit  UsbSerIrpCompletionRoutine");

    return STATUS_MORE_PROCESSING_REQUIRED;
} // UsbSerIrpCompletionRoutine

NTSTATUS
UsbSerWaitWakeIrpCompletionRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PDEVICE_OBJECT      DevObj = Context;
    PDEVICE_EXTENSION   DevExt = DevObj->DeviceExtension;
    NTSTATUS            Status;

    DEBUG_LOG_PATH("enter UsbSerWaitWakeIrpCompletionRoutine");

    DEBUG_TRACE1(("UsbSerWaitWakeIrpCompletionRoutine\n"));

    DEBUG_TRACE1(("Status (%08X)\n", Irp->IoStatus.Status));

    DEBUG_TRACE1(("Tell device to wake up\n"));

    // // now tell the device to actually wake up
    // UsbSer_SelfSuspendOrActivate(DevObj, FALSE);

    Status = Irp->IoStatus.Status;

    PoStartNextPowerIrp(Irp);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DEBUG_LOG_PATH("exit  UsbSerWaitWakeIrpCompletionRoutine");

    return STATUS_MORE_PROCESSING_REQUIRED;
} // UsbSerWaitWakeIrpCompletionRoutine



VOID
UsbSerFdoIdleNotificationCallback(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

    Called when it is time to idle out USB Modem


--*/
{
    POWER_STATE 	powerState;
    NTSTATUS 		ntStatus;

    DEBUG_TRACE1(("USB Modem (%08X) going idle\n", DevExt));

    if(DevExt->DeviceState == DEVICE_STATE_STOPPED || DevExt->OpenCnt) 
    {

        // Don't idle this modem if it is being stopped, or someone opened it

        DEBUG_TRACE1(("USB Modem (%08X) being stopped, abort idle\n", DevExt));
        return;
    }


    powerState.DeviceState = DevExt->DeviceWake;

	// request new device power state, wait wake Irp will be posted on request
    PoRequestPowerIrp(DevExt->PhysDeviceObject,
                      IRP_MN_SET_POWER,
                      powerState,
                      NULL,
                      NULL,
                      NULL);

} // UsbSerFdoIdleNotificationCallback


NTSTATUS
UsbSerFdoIdleNotificationRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_EXTENSION DevExt
    )
/*++

Routine Description:

    Completion routine for the Idle request IRP for the USB Modem device

--*/
{
    NTSTATUS 					ntStatus;
    PUSB_IDLE_CALLBACK_INFO 	idleCallbackInfo;

    //
    // DeviceObject is NULL because we sent the irp
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    DEBUG_TRACE1(("Idle notification IRP for USB Modem (%08X) completed (%08X)\n",
            DevExt, Irp->IoStatus.Status));

	// save completion status in device extension
    idleCallbackInfo 			= DevExt->IdleCallbackInfo;
    DevExt->IdleCallbackInfo 	= NULL;
    DevExt->PendingIdleIrp 		= NULL;

	// free up callback info
    if(idleCallbackInfo) 
    {
        DEBUG_MEMFREE(idleCallbackInfo);
    }

    ntStatus = Irp->IoStatus.Status;

    return ntStatus;
} // UsbSerFdoIdleNotificationRequestComplete


NTSTATUS
UsbSerFdoSubmitIdleRequestIrp(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

    Called when all handles to the USB modem are closed. This function allocates 
    an idle request IOCTL IRP and passes it to the parent's PDO.

--*/
{
    PIRP 					irp = NULL;
    NTSTATUS 				ntStatus = STATUS_SUCCESS;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo = NULL;

    DEBUG_TRACE1(("UsbSerFdoSubmitIdleRequestIrp (%08X)\n", DevExt));

    // if we have an Irp pending, or we are already idled, don't bother to send another
    if(DevExt->PendingIdleIrp || DevExt->CurrentDevicePowerState == DevExt->DeviceWake)
        return ntStatus;

    idleCallbackInfo = DEBUG_MEMALLOC(NonPagedPool,
        							  sizeof(struct _USB_IDLE_CALLBACK_INFO));

    if (idleCallbackInfo) 
    {

        idleCallbackInfo->IdleCallback 	= UsbSerFdoIdleNotificationCallback;
        idleCallbackInfo->IdleContext 	= (PVOID)DevExt;

        DevExt->IdleCallbackInfo = idleCallbackInfo;

        irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION,
                DevExt->PhysDeviceObject,
                idleCallbackInfo,
                sizeof(struct _USB_IDLE_CALLBACK_INFO),
                NULL,
                0,
                TRUE, /* INTERNAL */
                NULL,
                &DevExt->StatusBlock);

        if (irp == NULL) 
        {
        
            DEBUG_MEMFREE(idleCallbackInfo);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoSetCompletionRoutine(irp,
                               UsbSerFdoIdleNotificationRequestComplete,
                               DevExt,
                               TRUE,
                               TRUE,
                               TRUE);

        ntStatus = IoCallDriver(DevExt->PhysDeviceObject, irp);

        if(ntStatus == STATUS_PENDING) 
        {
            DEBUG_TRACE1(("USB Modem (%08X) Idle Irp Pending\n", DevExt));
            
            // Successfully posted an Idle IRP.

            DevExt->PendingIdleIrp 	= irp;
        }
    }

    return ntStatus;
} // UsbSerFdoSubmitIdleRequestIrp

VOID
UsbSerFdoRequestWake(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

	Called when we want to wake up the device after an idle request

--*/
{
    POWER_STATE 	powerState;

    DEBUG_TRACE1(("USB Modem (%08X) waking up\n", DevExt));

    if(DevExt->DeviceState == DEVICE_STATE_STOPPED || DevExt->CurrentDevicePowerState == PowerDeviceD0)
    {

        // Don't wake this modem if it is stopped, or already at D0

        DEBUG_TRACE1(("USB Modem (%08X) abort wake\n", DevExt));
        return;
    }


    powerState.DeviceState = PowerDeviceD0;

	// request new device power state, wake up the device
    PoRequestPowerIrp(DevExt->PhysDeviceObject,
                      IRP_MN_SET_POWER,
                      powerState,
                      NULL,
                      NULL,
                      NULL);

} // UsbSerFdoRequestWake




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\usbser.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        USBSER.C

Abstract:

        Main entry points for Legacy USB Modem Driver.
        All driver entry points here are called at

        IRQL = PASSIVE_LEVEL

Environment:

        kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        12/23/97 : created

Authors:

        Tom Green


****************************************************************************/

#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "usbserpw.h"
#include "serioctl.h"
#include "utils.h"
#include "debugwdm.h"

#ifdef ALLOC_PRAGMA

//
// INIT - only needed during init and then can be disposed
// PAGEUBS0 - always paged / never locked
// PAGEUSBS - must be locked when a device is open, else paged
//
//
// INIT is used for DriverEntry() specific code
//
// PAGEUBS0 is used for code that is not often called and has nothing
// to do with I/O performance.  An example, IRP_MJ_PNP/IRP_MN_START_DEVICE
// support functions
//
// PAGEUSBS is used for code that needs to be locked after an open for both
// performance and IRQL reasons.
//

#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGEUSBS0, UsbSer_Unload)
#pragma alloc_text(PAGEUSBS0, UsbSer_PnPAddDevice)
#pragma alloc_text(PAGEUSBS0, UsbSer_PnP)
#pragma alloc_text(PAGEUSBS0, UsbSerMajorNotSupported)

#ifdef WMI_SUPPORT
#pragma alloc_text(PAGEUSBS0, UsbSerSystemControlDispatch)
#pragma alloc_text(PAGEUSBS0, UsbSerTossWMIRequest)
#pragma alloc_text(PAGEUSBS0, UsbSerSetWmiDataItem)
#pragma alloc_text(PAGEUSBS0, UsbSerSetWmiDataBlock)
#pragma alloc_text(PAGEUSBS0, UsbSerQueryWmiDataBlock)
#pragma alloc_text(PAGEUSBS0, UsbSerQueryWmiRegInfo)
#else
#pragma alloc_text(PAGEUSBS0, UsbSer_SystemControl)
#endif

//
// PAGEUSBS is keyed off of UsbSer_Read, so UsbSer_Read must
// remain in PAGEUSBS for things to work properly
//

#pragma alloc_text(PAGEUSBS, UsbSer_Cleanup)
#pragma alloc_text(PAGEUSBS, UsbSer_Dispatch)
#pragma alloc_text(PAGEUSBS, UsbSer_Create)
#pragma alloc_text(PAGEUSBS, UsbSer_Close)

#endif // ALLOC_PRAGMA

UNICODE_STRING GlobalRegistryPath;

#ifdef WMI_SUPPORT

#define SERIAL_WMI_GUID_LIST_SIZE 1

#define WMI_SERIAL_PORT_NAME_INFORMATION 0

GUID SerialPortNameGuid = SERIAL_PORT_WMI_NAME_GUID;

WMIGUIDREGINFO SerialWmiGuidList[SERIAL_WMI_GUID_LIST_SIZE] =
{
    { &SerialPortNameGuid, 1, 0 }
};

#endif

/************************************************************************/
/* DriverEntry                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/* Installable driver initialization entry point.                       */
/* This entry point is called directly by the I/O system.               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DriverObject - pointer to the driver object                     */
/*                                                                      */
/*      RegistryPath - pointer to a unicode string representing the     */
/*                     path to driver-specific key in the registry      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
   NTSTATUS                NtStatus;

   PVOID lockPtr = MmLockPagableCodeSection(UsbSer_Read);

   PAGED_CODE();

   // setup debug trace level
#if 0
   Usbser_Debug_Trace_Level = 0;
#else
   Usbser_Debug_Trace_Level = 0;
#endif

   //
   // Serial portion

#if DBG
   UsbSerSerialDebugLevel = 0x00000000;
   PAGEUSBSER_Count = 0;
#else
   UsbSerSerialDebugLevel = 0;
#endif

   PAGEUSBSER_Handle = lockPtr;
   PAGEUSBSER_Function = UsbSer_Read;

   // Create dispatch points for device control, create, close, etc.

   DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
      UsbSer_Dispatch;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = UsbSer_Dispatch;
   DriverObject->MajorFunction[IRP_MJ_CREATE]          = UsbSer_Create;
   DriverObject->MajorFunction[IRP_MJ_CLOSE]           = UsbSer_Close;
   DriverObject->MajorFunction[IRP_MJ_WRITE]           = UsbSer_Write;
   DriverObject->MajorFunction[IRP_MJ_READ]            = UsbSer_Read;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = UsbSer_Cleanup;
   DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]
                                                      = UsbSerMajorNotSupported;
   DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]
                                                      = UsbSerMajorNotSupported;
#ifdef WMI_SUPPORT
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = UsbSerSystemControlDispatch;
#else
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = UsbSer_SystemControl;
#endif

   DriverObject->MajorFunction[IRP_MJ_PNP]            = UsbSer_PnP;
   DriverObject->MajorFunction[IRP_MJ_POWER]          = UsbSer_ProcessPowerIrp;
   DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]  = UsbSerFlush;
   DriverObject->DriverExtension->AddDevice           = UsbSer_PnPAddDevice;
   DriverObject->DriverUnload                         = UsbSer_Unload;

   KeInitializeSpinLock(&GlobalSpinLock);

   GlobalRegistryPath.MaximumLength = RegistryPath->MaximumLength;
   GlobalRegistryPath.Length = RegistryPath->Length;
   GlobalRegistryPath.Buffer
      = DEBUG_MEMALLOC(PagedPool, GlobalRegistryPath.MaximumLength);

   if (GlobalRegistryPath.Buffer == NULL) 
   {
      MmUnlockPagableImageSection(lockPtr);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(GlobalRegistryPath.Buffer,
                 GlobalRegistryPath.MaximumLength);
   RtlMoveMemory(GlobalRegistryPath.Buffer,
                 RegistryPath->Buffer, RegistryPath->Length);


   // initialize diagnostic stuff (history, tracing, error logging)

   DriverName              = "USBSER";
   DriverVersion   = "0.99";

   NtStatus = DEBUG_OPEN();

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  DriverEntry");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   //
   // Unlock pageable text
   //

   MmUnlockPagableImageSection(lockPtr);

   return NtStatus;
} // DriverEntry


/************************************************************************/
/* UsbSer_Dispatch                                                      */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Process the IRPs sent to this device. In this case IOCTLs and   */
/*  PNP IOCTLs                                                          */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
   NTSTATUS                NtStatus;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   PVOID                   IoBuffer;
   ULONG                   InputBufferLength;
   ULONG                   OutputBufferLength;
   ULONG                   IoControlCode;
   BOOLEAN                 NeedCompletion = TRUE;
   KIRQL oldIrql;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_Dispatch");

   // set return values to something known
   NtStatus = Irp->IoStatus.Status         = STATUS_SUCCESS;
   Irp->IoStatus.Information                       = 0;


   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &oldIrql);

   if (DeviceExtension->CurrentDevicePowerState != PowerDeviceD0) {
      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, oldIrql);

      NtStatus = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

      goto UsbSer_DispatchErr;
   }

   RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, oldIrql);

   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   // Get the pointer to the input/output buffer and it's length
   IoBuffer                   = Irp->AssociatedIrp.SystemBuffer;
   InputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
   OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction, IoBuffer,
                      InputBufferLength);

   switch (IrpStack->MajorFunction) {
   case IRP_MJ_DEVICE_CONTROL:

      DEBUG_LOG_PATH("IRP_MJ_DEVICE_CONTROL");

      IoControlCode = IrpStack->Parameters.DeviceIoControl.IoControlCode;

      switch (IoControlCode) {
#ifdef PROFILING_ENABLED
      case GET_DRIVER_LOG:
         DEBUG_LOG_PATH("GET_DRIVER_LOG");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information = Debug_DumpDriverLog(DeviceObject,
                                                            IoBuffer,
                                                            OutputBufferLength);
         }
         break;

      case GET_IRP_HIST:
         DEBUG_LOG_PATH("GET_IRP_HIST");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information
               = Debug_ExtractIRPHist(IoBuffer, OutputBufferLength);
         }

         break;

      case GET_PATH_HIST:
         DEBUG_LOG_PATH("GET_PATH_HIST");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information
               = Debug_ExtractPathHist(IoBuffer, OutputBufferLength);
         }

         break;

      case GET_ERROR_LOG:
         DEBUG_LOG_PATH("GET_ERROR_LOG");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information
               = Debug_ExtractErrorLog(IoBuffer, OutputBufferLength);
         }

         break;

      case GET_ATTACHED_DEVICES:
         DEBUG_LOG_PATH("GET_ATTACHED_DEVICES");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information
               = Debug_ExtractAttachedDevices(DeviceObject->DriverObject,
                                              IoBuffer, OutputBufferLength);
         }

         break;

      case GET_DRIVER_INFO:
         DEBUG_LOG_PATH("GET_DRIVER_INFO");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information
               = Debug_GetDriverInfo(IoBuffer, OutputBufferLength);
         }

         break;

      case SET_IRP_HIST_SIZE:
         DEBUG_LOG_PATH("SET_IRP_HIST_SIZE");

         // make sure we have a correct buffer length and a buffer
         if (InputBufferLength != sizeof(ULONG) || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else
            NtStatus = Debug_SizeIRPHistoryTable(*((ULONG *) IoBuffer));
         break;

      case SET_PATH_HIST_SIZE:
         DEBUG_LOG_PATH("SET_PATH_HIST_SIZE");

         // make sure we have a correct buffer length and a buffer
         if (InputBufferLength != sizeof(ULONG) || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else
            NtStatus = Debug_SizeDebugPathHist(*((ULONG *) IoBuffer));
         break;

      case SET_ERROR_LOG_SIZE:
         DEBUG_LOG_PATH("SET_ERROR_LOG_SIZE");

         // make sure we have a correct buffer length and a buffer
         if (InputBufferLength != sizeof(long) || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else
            NtStatus = Debug_SizeErrorLog(*((ULONG *) IoBuffer));
         break;
#endif // PROFILING_ENABLED
      case ENABLE_PERF_TIMING:
         DEBUG_LOG_PATH("ENABLE_PERF_TIMING");

         // enable perf timing
         DeviceExtension->PerfTimerEnabled = TRUE;

         // reset BytesXfered, ElapsedTime and TimerStart
         DeviceExtension->BytesXfered   = RtlConvertUlongToLargeInteger(0L);
         DeviceExtension->ElapsedTime   = RtlConvertUlongToLargeInteger(0L);
         DeviceExtension->TimerStart    = RtlConvertUlongToLargeInteger(0L);

         break;

      case DISABLE_PERF_TIMING:
         DEBUG_LOG_PATH("DISABLE_PERF_TIMING");

         // disable perf timing
         DeviceExtension->PerfTimerEnabled = FALSE;
         break;

      case GET_PERF_DATA:
         DEBUG_LOG_PATH("GET_PERF_DATA");
         // make sure we have enough space to return perf info
         if (OutputBufferLength < sizeof(PERF_INFO) || !IoBuffer)
            NtStatus = Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
         else {
            PPERF_INFO      Perf = (PPERF_INFO) IoBuffer;

            Perf->PerfModeEnabled           = DeviceExtension->PerfTimerEnabled;
            Perf->BytesPerSecond            = BytesPerSecond(DeviceExtension);
            Irp->IoStatus.Information       = sizeof(PERF_INFO);
         }
         break;

      case SET_DEBUG_TRACE_LEVEL:
         // make sure we have a correct buffer length and a buffer
         if (InputBufferLength != sizeof(long) || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else
            Usbser_Debug_Trace_Level = *((ULONG *) IoBuffer);
         break;

         // handle IOCTLs for a "serial" device
      case IOCTL_SERIAL_SET_BAUD_RATE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_BAUD_RATE");
         NtStatus = SetBaudRate(Irp, DeviceObject);
         break;
      case IOCTL_SERIAL_GET_BAUD_RATE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_BAUD_RATE");
         NtStatus = GetBaudRate(Irp, DeviceObject);
         break;
      case IOCTL_SERIAL_SET_LINE_CONTROL:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_LINE_CONTROL");
         NtStatus = SetLineControl(Irp, DeviceObject);
         break;
      case IOCTL_SERIAL_GET_LINE_CONTROL:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_LINE_CONTROL");
         NtStatus = GetLineControl(Irp, DeviceObject);
         break;
      case IOCTL_SERIAL_SET_TIMEOUTS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_TIMEOUTS");
         NtStatus = SetTimeouts(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_TIMEOUTS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_TIMEOUTS");
         NtStatus = GetTimeouts(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_SET_CHARS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_CHARS");
         NtStatus = SetChars(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_CHARS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_CHARS");
         NtStatus = GetChars(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_SET_DTR:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_DTR");
         NtStatus = SetClrDtr(DeviceObject, TRUE);
         break;
      case IOCTL_SERIAL_CLR_DTR:
         DEBUG_LOG_PATH("IOCTL_SERIAL_CLR_DTR");
         NtStatus = SetClrDtr(DeviceObject, FALSE);
         break;
      case IOCTL_SERIAL_RESET_DEVICE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_RESET_DEVICE");
         NtStatus = ResetDevice(Irp, DeviceObject);
         break;
      case IOCTL_SERIAL_SET_RTS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_RTS");
         NtStatus = SetRts(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_CLR_RTS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_CLR_RTS");
         NtStatus = ClrRts(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_SET_BREAK_ON:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_BREAK_ON");
         NtStatus = SetBreak(Irp, DeviceObject, 0xFFFF);
         break;
      case IOCTL_SERIAL_SET_BREAK_OFF:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_BREAK_OFF");
         NtStatus = SetBreak(Irp, DeviceObject, 0);
         break;
      case IOCTL_SERIAL_SET_QUEUE_SIZE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_QUEUE_SIZE");
         NtStatus = SetQueueSize(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_WAIT_MASK:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_WAIT_MASK");
         NtStatus = GetWaitMask(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_SET_WAIT_MASK:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_WAIT_MASK");
         NtStatus = SetWaitMask(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_WAIT_ON_MASK:
         DEBUG_LOG_PATH("IOCTL_SERIAL_WAIT_ON_MASK");
         NtStatus = WaitOnMask(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_IMMEDIATE_CHAR:
         DEBUG_LOG_PATH("IOCTL_SERIAL_IMMEDIATE_CHAR");

         NeedCompletion = FALSE;

         NtStatus = ImmediateChar(Irp, DeviceObject);

         if(NtStatus == STATUS_BUFFER_TOO_SMALL)
            NeedCompletion = TRUE;

         break;
      case IOCTL_SERIAL_PURGE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_PURGE");
         NtStatus = Purge(DeviceObject, Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_HANDFLOW:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_HANDFLOW");
         NtStatus = GetHandflow(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_SET_HANDFLOW:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_HANDFLOW");
         NtStatus = SetHandflow(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_MODEMSTATUS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_MODEMSTATUS");
         NtStatus = GetModemStatus(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_DTRRTS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_DTRRTS");
         NtStatus = GetDtrRts(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_COMMSTATUS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_COMMSTATUS");
         NtStatus = GetCommStatus(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_PROPERTIES:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_PROPERTIES");
         NtStatus = GetProperties(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_LSRMST_INSERT:
         DEBUG_LOG_PATH("IOCTL_SERIAL_LSRMST_INSERT");
         NtStatus = LsrmstInsert(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_CONFIG_SIZE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_CONFIG_SIZE");
         NtStatus = ConfigSize(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_STATS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_STATS");
         NtStatus = GetStats(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_CLEAR_STATS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_CLEAR_STATS");
         NtStatus = ClearStats(Irp, DeviceExtension);
         break;

      default:
         NtStatus = STATUS_INVALID_PARAMETER;
      }
      break;

      // breaking out here will complete the Irp

   case IRP_MJ_INTERNAL_DEVICE_CONTROL:
      DEBUG_TRACE1(("IRP_MJ_INTERNAL_DEVICE_CONTROL\n"));

      switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) 
      {
      case IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE:
         DEBUG_TRACE1(("IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE\n"));

         DeviceExtension->SendWaitWake = TRUE;
         NtStatus = STATUS_SUCCESS;
         break;

      case IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE:

         DEBUG_TRACE1(("IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE\n"));
         DeviceExtension->SendWaitWake = FALSE;

         if (DeviceExtension->PendingWakeIrp != NULL) {
            IoCancelIrp(DeviceExtension->PendingWakeIrp);
         }

         NtStatus = STATUS_SUCCESS;
         break;

      default:

         // pass through to driver below

         DEBUG_LOG_PATH("IRP_MJ_INTERNAL_DEVICE_CONTROL");

         // since I dont have a completion routine use
         // IoCopyCurrentIrp

         IoCopyCurrentIrpStackLocationToNext(Irp);
         IoMarkIrpPending(Irp);
         NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject,
                                 Irp);

         DEBUG_TRACE3(("Passed PnP Irp down, NtStatus = %08X\n",
                       NtStatus));

         NeedCompletion = FALSE;
         break;
      }

   default:
      DEBUG_LOG_PATH("MAJOR IOCTL not handled");
      Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
      break;
   }


   if (NeedCompletion && NtStatus != STATUS_PENDING) {
      Irp->IoStatus.Status = NtStatus;

      CompleteIO(DeviceObject, Irp, IrpStack->MajorFunction,
                 IoBuffer, Irp->IoStatus.Information);
   }

UsbSer_DispatchErr:;

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  UsbSer_Dispatch");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));
   return NtStatus;
} // UsbSer_Dispatch


/************************************************************************/
/* UsbSer_Create                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Process the IRPs sent to this device for Create calls           */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_Create(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
   NTSTATUS                NtStatus;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   PVOID                   IoBuffer;
   ULONG                   InputBufferLength;
   KIRQL                   OldIrql;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_Create");

   DEBUG_TRACE1(("Open\n"));

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSer_Create(%08X)\n", Irp));

   // wakeup device from previous idle
   // UsbSerFdoRequestWake(DeviceExtension);

   // set return values to something known
   NtStatus = Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information       = 0;

   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   // Get the pointer to the input/output buffer and it's length
   IoBuffer           = Irp->AssociatedIrp.SystemBuffer;
   InputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction, IoBuffer, 0);

   //
   // Serial devices do not allow multiple concurrent opens
   //

   if (InterlockedIncrement(&DeviceExtension->OpenCnt) != 1) {
      InterlockedDecrement(&DeviceExtension->OpenCnt);
      NtStatus = Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
      goto UsbSer_CreateErr;
   }

   //
   // Before we do anything, let's make sure they aren't trying
   // to create a directory.
   //

   if (IrpStack->Parameters.Create.Options & FILE_DIRECTORY_FILE) {
      InterlockedDecrement(&DeviceExtension->OpenCnt);
      NtStatus = Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
      Irp->IoStatus.Information = 0;
      goto UsbSer_CreateErr;
   }

   //
   // Lock down our code pages
   //

   PAGEUSBSER_Handle = UsbSerLockPagableCodeSection(UsbSer_Read);

   ASSERT(DeviceExtension->IsDevice);

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   DeviceExtension->IsrWaitMask = 0;
   DeviceExtension->EscapeChar  = 0;

   RtlZeroMemory(&DeviceExtension->PerfStats, sizeof(SERIALPERF_STATS));

   //
   // Purge the RX buffer
   //

   DeviceExtension->CharsInReadBuff = 0;
   DeviceExtension->CurrentReadBuffPtr = 0;
   DeviceExtension->HistoryMask = 0;
   DeviceExtension->EscapeChar = 0;

   DeviceExtension->SendWaitWake = FALSE;

   RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

   //
   // Restart the read
   //

   RestartRead(DeviceExtension);

   UsbSer_CreateErr:;

   CompleteIO(DeviceObject, Irp, IrpStack->MajorFunction,
              IoBuffer, Irp->IoStatus.Information);

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  UsbSer_Create");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSer_Create %08X\n", NtStatus));

   return NtStatus;
} // UsbSer_Create


/************************************************************************/
/* UsbSer_Close                                                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Process the IRPs sent to this device for Close calls            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_Close(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
   NTSTATUS                NtStatus;
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION      IrpStack;
   PVOID                   IoBuffer;
   ULONG                   InputBufferLength;
   ULONG                   openCount;


   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_Close");

   DEBUG_TRACE1(("Close\n"));

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSer_Close(%08X)\n", Irp));

   // set return values to something known
   NtStatus = Irp->IoStatus.Status         = STATUS_SUCCESS;
   Irp->IoStatus.Information                       = 0;

   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   // Get the pointer to the input/output buffer and it's length
   IoBuffer           = Irp->AssociatedIrp.SystemBuffer;
   InputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

   // clear DTR, this is what the serial driver does
   SetClrDtr(DeviceObject, FALSE);

   //
   // Stop waiting for wakeup
   //

   DeviceExtension->SendWaitWake = FALSE;

   if (DeviceExtension->PendingWakeIrp != NULL) {
      IoCancelIrp(DeviceExtension->PendingWakeIrp);
   }

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction, IoBuffer, 0);

   ASSERT(DeviceExtension->IsDevice);

   openCount = InterlockedDecrement(&DeviceExtension->OpenCnt);

   ASSERT(openCount == 0);

   CompleteIO(DeviceObject, Irp, IrpStack->MajorFunction,
              IoBuffer, Irp->IoStatus.Information);

   // try and idle the modem
   // UsbSerFdoSubmitIdleRequestIrp(DeviceExtension);

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  UsbSer_Close");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSer_Close %08X\n", NtStatus));

   UsbSerUnlockPagableImageSection(PAGEUSBSER_Handle);

   return NtStatus;
} // UsbSer_Close


/************************************************************************/
/* UsbSer_Unload                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Process unloading driver                                        */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DriverObject - pointer to a driver object                       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
UsbSer_Unload(IN PDRIVER_OBJECT DriverObject)
{
        PAGED_CODE();

        DEBUG_LOG_PATH("enter UsbSer_Unload");

        // release global resources here
   		if(GlobalRegistryPath.Buffer != NULL) 
   		{
      		DEBUG_MEMFREE(GlobalRegistryPath.Buffer);
      		GlobalRegistryPath.Buffer = NULL;
   		}

        // shut down debugging and release resources
        DEBUG_CLOSE();

        DEBUG_LOG_PATH("exit  UsbSer_Unload");
} // UsbSer_Unload


/************************************************************************/
/* UsbSer_PnPAddDevice                                                  */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Attach new device to driver                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DriverObject         - pointer to the driver object             */
/*                                                                      */
/*      PhysicalDeviceObject - pointer to the bus device object         */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_PnPAddDevice(IN PDRIVER_OBJECT DriverObject,
                    IN PDEVICE_OBJECT PhysicalDeviceObject)
{
   NTSTATUS             NtStatus;
   PDEVICE_OBJECT       DeviceObject = NULL;
   PDEVICE_EXTENSION    DeviceExtension;
   ULONG  Index;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_PnPAddDevice");


   NtStatus = CreateDeviceObject(DriverObject, &DeviceObject, DriverName);

   // make sure we have both a created device object and physical
   if ((DeviceObject != NULL)  && (PhysicalDeviceObject != NULL)) {
      DeviceExtension = DeviceObject->DeviceExtension;

      // Attach to the PDO
      DeviceExtension->StackDeviceObject =
         IoAttachDeviceToDeviceStack(DeviceObject, PhysicalDeviceObject);

      DEBUG_TRACE3(("StackDeviceObject (%08X)\n",
                    DeviceExtension->StackDeviceObject));

      // if we don't have a stack device object to attach to, bong it
      if (!DeviceExtension->StackDeviceObject) {
         IoDeleteDevice(DeviceObject);
         NtStatus = STATUS_NO_SUCH_DEVICE;
      } else {
         // do some device extension house keeping
         DeviceExtension->PerfTimerEnabled = FALSE;
         DeviceExtension->PhysDeviceObject = PhysicalDeviceObject;
         DeviceExtension->BytesXfered      = RtlConvertUlongToLargeInteger(0L);
         DeviceExtension->ElapsedTime      = RtlConvertUlongToLargeInteger(0L);
         DeviceExtension->TimerStart       = RtlConvertUlongToLargeInteger(0L);
         DeviceExtension->CurrentDevicePowerState = PowerDeviceD0;

         // init selective suspend stuff
         DeviceExtension->PendingIdleIrp   = NULL;
         DeviceExtension->IdleCallbackInfo = NULL;

         DeviceObject->StackSize = DeviceExtension->StackDeviceObject->StackSize
             + 1;

         // we support buffered io for read/write
         DeviceObject->Flags |= DO_BUFFERED_IO;

         // power mangement
         DeviceObject->Flags |= DO_POWER_PAGABLE;

         // we are done initializing the device object, so say so
         DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

         // get device capabilities
         UsbSerQueryCapabilities(DeviceExtension->StackDeviceObject,
                                 &DeviceExtension->DeviceCapabilities);

         // We want to determine what level to auto-powerdown to; This is the
         // lowest sleeping level that is LESS than D3;
         // If all are set to D3, auto powerdown/powerup will be disabled.

         // init to disabled
         DeviceExtension->PowerDownLevel = PowerDeviceUnspecified;

         for (Index = PowerSystemSleeping1; Index <= PowerSystemSleeping3;
              Index++) {

            if (DeviceExtension->DeviceCapabilities.DeviceState[Index]
                < PowerDeviceD3)
               DeviceExtension->PowerDownLevel
               = DeviceExtension->DeviceCapabilities.DeviceState[Index];
         }

#ifdef WMI_SUPPORT

         //
         // Register for WMI
         //

         DeviceExtension->WmiLibInfo.GuidCount = sizeof(SerialWmiGuidList) /
                                              sizeof(WMIGUIDREGINFO);
         DeviceExtension->WmiLibInfo.GuidList = SerialWmiGuidList;

         DeviceExtension->WmiLibInfo.QueryWmiRegInfo = UsbSerQueryWmiRegInfo;
         DeviceExtension->WmiLibInfo.QueryWmiDataBlock = UsbSerQueryWmiDataBlock;
         DeviceExtension->WmiLibInfo.SetWmiDataBlock = UsbSerSetWmiDataBlock;
         DeviceExtension->WmiLibInfo.SetWmiDataItem = UsbSerSetWmiDataItem;
         DeviceExtension->WmiLibInfo.ExecuteWmiMethod = NULL;
         DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

         IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_REGISTER);
#endif

      }
   }

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus); // init to disabled
   DEBUG_LOG_PATH("exit  UsbSer_PnPAddDevice");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   return NtStatus;
} // UsbSer_PnPAddDevice


/************************************************************************/
/* UsbSer_PnP                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      This routine will receive the various Plug N Play messages.  It */
/*      is here that we start our device, stop it, etc.                 */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_PnP(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{

   NTSTATUS                NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   PVOID                   IoBuffer;
   ULONG                   InputBufferLength;
   BOOLEAN                 PassDown = TRUE;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_PnP");

   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   // Get the pointer to the input/output buffer and it's length
   IoBuffer           = Irp->AssociatedIrp.SystemBuffer;
   InputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction, IoBuffer,
                      InputBufferLength);

   switch (IrpStack->MinorFunction) {

   case IRP_MN_START_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_START_DEVICE");

      NtStatus = StartDevice(DeviceObject, Irp);

      // passed Irp to driver below and completed in start device routine
      PassDown = FALSE;

      break;

   case IRP_MN_QUERY_REMOVE_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_QUERY_REMOVE_DEVICE");
      break;

   case IRP_MN_REMOVE_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_REMOVE_DEVICE");

#ifdef WMI_SUPPORT
      IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_DEREGISTER);
#endif

      NtStatus = RemoveDevice(DeviceObject, Irp);

      PassDown = FALSE;

      break;

   case IRP_MN_CANCEL_REMOVE_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_CANCEL_REMOVE_DEVICE");

      break;

   case IRP_MN_STOP_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_STOP_DEVICE");

      NtStatus = StopDevice(DeviceObject, Irp);

      break;


   case IRP_MN_QUERY_STOP_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_QUERY_STOP_DEVICE");
      break;

   case IRP_MN_CANCEL_STOP_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_CANCEL_STOP_DEVICE");
      break;

   case IRP_MN_QUERY_DEVICE_RELATIONS:
      DEBUG_LOG_PATH("IRP_MN_QUERY_DEVICE_RELATIONS");
      break;

   case IRP_MN_QUERY_INTERFACE:
      DEBUG_LOG_PATH("IRP_MN_QUERY_INTERFACE");
      break;

   case IRP_MN_QUERY_CAPABILITIES:
      DEBUG_TRACE2(("IRP_MN_QUERY_CAPABILITIES\n"));
      {
         PKEVENT pQueryCapsEvent;
         PDEVICE_CAPABILITIES pDevCaps;

         pQueryCapsEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

         if (pQueryCapsEvent == NULL) {
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
         }


         KeInitializeEvent(pQueryCapsEvent, SynchronizationEvent, FALSE);

         IoCopyCurrentIrpStackLocationToNext(Irp);

         IoSetCompletionRoutine(Irp, UsbSerSyncCompletion, pQueryCapsEvent,
                                TRUE, TRUE, TRUE);

         NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);


         //
         // Wait for lower drivers to be done with the Irp
         //

         if (NtStatus == STATUS_PENDING) {
            KeWaitForSingleObject(pQueryCapsEvent, Executive, KernelMode,
                                  FALSE, NULL);
         }

         ExFreePool(pQueryCapsEvent);

         NtStatus = Irp->IoStatus.Status;

         if (IrpStack->Parameters.DeviceCapabilities.Capabilities == NULL) {
            goto errQueryCaps;
         }

         //
         // Save off their power capabilities
         //

         IrpStack = IoGetCurrentIrpStackLocation(Irp);

         pDevCaps = IrpStack->Parameters.DeviceCapabilities.Capabilities;

         pDevCaps->SurpriseRemovalOK   = TRUE;

         DeviceExtension->SystemWake = pDevCaps->SystemWake;
         DeviceExtension->DeviceWake = pDevCaps->DeviceWake;

         UsbSerSerialDump(USBSERTRACEPW,
                          ("IRP_MN_QUERY_CAPS: SystemWake %08X "
                           "DeviceWake %08X\n", DeviceExtension->SystemWake,
                           DeviceExtension->DeviceWake));

         errQueryCaps:;

         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         return NtStatus;
      }

   case IRP_MN_QUERY_RESOURCES:
      DEBUG_LOG_PATH("IRP_MN_QUERY_RESOURCES");
      break;

   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
      DEBUG_LOG_PATH("IRP_MN_QUERY_RESOURCE_REQUIREMENTS");
      break;

   case IRP_MN_QUERY_DEVICE_TEXT:
      DEBUG_LOG_PATH("IRP_MN_QUERY_DEVICE_TEXT");
      break;

   case IRP_MN_READ_CONFIG:
      DEBUG_LOG_PATH("IRP_MN_READ_CONFIG");
      break;

   case IRP_MN_WRITE_CONFIG:
      DEBUG_LOG_PATH("IRP_MN_WRITE_CONFIG");
      break;

   case IRP_MN_EJECT:
      DEBUG_LOG_PATH("IRP_MN_EJECT");
      break;

   case IRP_MN_SET_LOCK:
      DEBUG_LOG_PATH("IRP_MN_SET_LOCK");
      break;

   case IRP_MN_QUERY_ID:
      DEBUG_LOG_PATH("IRP_MN_QUERY_ID");
      break;

   case IRP_MN_QUERY_PNP_DEVICE_STATE:
      DEBUG_LOG_PATH("IRP_MN_QUERY_PNP_DEVICE_STATE");
      break;

   case IRP_MN_QUERY_BUS_INFORMATION:
      DEBUG_LOG_PATH("IRP_MN_QUERY_BUS_INFORMATION");
      break;

   case IRP_MN_SURPRISE_REMOVAL:
   {
      PIRP      CurrentMaskIrp;
      KIRQL     CancelIrql;

      DEBUG_TRACE2(("IRP_MN_SURPRISE_REMOVAL\n"));

      ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &CancelIrql);

	  // surprise removal, so stop accepting requests
	  UsbSerFetchBooleanLocked(&DeviceExtension->AcceptingRequests,
                               FALSE, &DeviceExtension->ControlLock);

      // let's see if we have any events to signal
      CurrentMaskIrp = DeviceExtension->CurrentMaskIrp;

      // complete the queued IRP if needed
      if(CurrentMaskIrp)
      {
         // indicate to upper layers that CD dropped if needed
         if((DeviceExtension->IsrWaitMask & SERIAL_EV_RLSD) &&
             (DeviceExtension->FakeModemStatus & SERIAL_MSR_DCD))
         {

            DEBUG_TRACE2(("Sending up a CD dropped event\n"));
            
            DeviceExtension->FakeModemStatus        &= ~SERIAL_MSR_DCD;
            DeviceExtension->HistoryMask            |= SERIAL_EV_RLSD;

            CurrentMaskIrp->IoStatus.Status         = STATUS_SUCCESS;
            CurrentMaskIrp->IoStatus.Information    = sizeof(ULONG);

            DeviceExtension->CurrentMaskIrp         = NULL;

            *(PULONG) (CurrentMaskIrp->AssociatedIrp.SystemBuffer) =
                DeviceExtension->HistoryMask;

            DeviceExtension->HistoryMask = 0;

            IoSetCancelRoutine(CurrentMaskIrp, NULL);
            RELEASE_CANCEL_SPINLOCK(DeviceExtension, CancelIrql);

            IoCompleteRequest(CurrentMaskIrp, IO_NO_INCREMENT);


         }
         else
         {
            RELEASE_CANCEL_SPINLOCK(DeviceExtension, CancelIrql);
         }

      }
      else
      {
         RELEASE_CANCEL_SPINLOCK(DeviceExtension, CancelIrql);
      }


      Irp->IoStatus.Status = STATUS_SUCCESS;
      break;
   }
   default:
      DEBUG_LOG_PATH("PnP IOCTL not handled");
      DEBUG_TRACE3(("IOCTL (%08X)\n", IrpStack->MinorFunction));
      break;

   }       // case of IRP_MJ_PNP

   // All PNP POWER messages get passed to StackDeviceObject.

   if (PassDown) {
      DEBUG_TRACE3(("Passing PnP Irp down, status (%08X)\n", NtStatus));

      IoCopyCurrentIrpStackLocationToNext(Irp);

      DEBUG_LOG_PATH("Passing PnP Irp down stack");
      NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);
   }

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  UsbSer_PnP");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   return NtStatus;
} // UsbSer_PnP


#ifndef WMI_SUPPORT
/************************************************************************/
/* UsbSer_SystemControl                                                 */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      This routine will receive the various system control messages.  */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_SystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   PVOID                   IoBuffer;
   ULONG                   InputBufferLength;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_SystemControl");

   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   // Get the pointer to the input/output buffer and it's length
   IoBuffer           = Irp->AssociatedIrp.SystemBuffer;
   InputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction, IoBuffer,
                      InputBufferLength);


   // All System Control messages get passed to StackDeviceObject.

   IoCopyCurrentIrpStackLocationToNext(Irp);
   NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  UsbSer_SystemControl");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   return NtStatus;
} // UsbSer_SystemControl

#endif

/************************************************************************/
/* UsbSer_Cleanup                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_Cleanup(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
        NTSTATUS                NtStatus = STATUS_SUCCESS;

        USBSER_LOCKED_PAGED_CODE();

        DEBUG_LOG_PATH("enter UsbSer_Cleanup");
        UsbSerSerialDump(USBSERTRACEOTH, (">UsbSer_Cleanup(%08X)\n", Irp));

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        UsbSerKillPendingIrps(DeviceObject);

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        // log an error if we got one
        DEBUG_LOG_ERROR(NtStatus);
        DEBUG_LOG_PATH("exit  UsbSer_Cleanup");
        DEBUG_TRACE3(("status (%08X)\n", NtStatus));
        UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSer_Cleanup %08X\n", NtStatus));

        return NtStatus;
} // UsbSer_Cleanup


/************************************************************************/
/* UsbSerMajorNotSupported                                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*      Standard routine to return STATUS_NOT_SUPPORTED for IRP_MJ      */
/*      calls we don't handle.                                          */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSerMajorNotSupported(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
        PAGED_CODE();

        DEBUG_LOG_PATH("enter UsbSerMajorNotSupported");
        DEBUG_TRACE3(("Major (%08X)\n",
                     IoGetCurrentIrpStackLocation(Irp)->MajorFunction));

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        // log an error if we got one
        DEBUG_LOG_ERROR(STATUS_NOT_SUPPORTED);
        DEBUG_LOG_PATH("exit  UsbSerMajorNotSupported");
        DEBUG_TRACE3(("status (%08X)\n", STATUS_NOT_SUPPORTED));

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_NOT_SUPPORTED;
} // UsbSerMajorNotSupported


#ifdef WMI_SUPPORT

NTSTATUS
UsbSerSystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;
    PDEVICE_EXTENSION pDevExt
      = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PAGED_CODE();

    status = WmiSystemControl(   &pDevExt->WmiLibInfo,
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation(Irp);

            status = IoCallDriver(pDevExt->StackDeviceObject, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->StackDeviceObject, Irp);
            break;
        }        
    }
    
    return(status);

}



//
// WMI System Call back functions
//



NTSTATUS
UsbSerTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex)
{
   PDEVICE_EXTENSION pDevExt;
   NTSTATUS status;

   PAGED_CODE();

   pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;

   switch (GuidIndex) 
   {

   case WMI_SERIAL_PORT_NAME_INFORMATION:
      status = STATUS_INVALID_DEVICE_REQUEST;
      break;

   default:
      status = STATUS_WMI_GUID_NOT_FOUND;
      break;
   }

   status = WmiCompleteRequest(PDevObj, PIrp,
                                 status, 0, IO_NO_INCREMENT);

   return status;
}


NTSTATUS
UsbSerSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    PBuffer has the new values for the data item


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   return UsbSerTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
UsbSerSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    PBuffer has the new values for the data block


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   return UsbSerTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
UsbSerQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex, 
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    PBuffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG size = 0;
    PDEVICE_EXTENSION pDevExt
       = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;

    PAGED_CODE();

    switch (GuidIndex) {
    case WMI_SERIAL_PORT_NAME_INFORMATION:
       size = pDevExt->WmiIdentifier.Length;

       if (OutBufferSize < (size + sizeof(USHORT))) {
            size += sizeof(USHORT);
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

       if (pDevExt->WmiIdentifier.Buffer == NULL) {
           status = STATUS_INSUFFICIENT_RESOURCES;
           break;
        }

        //
        // First, copy the string over containing our identifier
        //

        *(USHORT *)PBuffer = (USHORT)size;
        (UCHAR *)PBuffer += sizeof(USHORT);

        RtlCopyMemory(PBuffer, pDevExt->WmiIdentifier.Buffer, size);

        //
        // Increment total size to include the WORD containing our len
        //

        size += sizeof(USHORT);
        *InstanceLengthArray = size;
                
        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest( PDevObj, PIrp,
                                  status, size, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
UsbSerQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo)
                                                  
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
   PDEVICE_EXTENSION pDevExt
       = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
   
   PAGED_CODE();

   *PRegFlags = WMIREG_FLAG_INSTANCE_PDO;
   *PRegistryPath = &GlobalRegistryPath;
   *Pdo = pDevExt->PhysDeviceObject;

   return STATUS_SUCCESS;
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\serioctl.h ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

   SERIOCTL.H

Abstract:

   Header file for routines to handle serial IOCTLs for Legacy USB Modem Driver

Environment:

   kernel mode only

Notes:

   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
   PURPOSE.

   Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

   12/27/97 : created

Authors:

   Tom Green


****************************************************************************/


#ifndef __SERIOCTL_H__
#define __SERIOCTL_H__


// prototypes

NTSTATUS
SetBaudRate(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
GetBaudRate(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
SetLineControl(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
GetLineControl(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
SetTimeouts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetTimeouts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
SetChars(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetChars(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
SetClrDtr(IN PDEVICE_OBJECT PDevObj, IN BOOLEAN Set);

NTSTATUS
ResetDevice(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
SetRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
ClrRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
SetBreak(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj, IN USHORT Time);

NTSTATUS
SetQueueSize(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetWaitMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
SetWaitMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
WaitOnMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
ImmediateChar(IN PIRP Irp, IN PDEVICE_OBJECT DeviceObject);

NTSTATUS
Purge(IN PDEVICE_OBJECT PDevObj, IN PIRP Irp,
      IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetHandflow(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
SetHandflow(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetModemStatus(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetDtrRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetCommStatus(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetProperties(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
LsrmstInsert(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
ConfigSize(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetStats(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
ClearStats(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

VOID
SerialGetProperties(IN PDEVICE_EXTENSION DeviceExtension,
               IN PSERIAL_COMMPROP Properties);

NTSTATUS
GetLineControlAndBaud(IN PDEVICE_OBJECT PDevObj);

NTSTATUS
SetLineControlAndBaud(IN PDEVICE_OBJECT PDevObj);

NTSTATUS
NotifyCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);

#endif // __SERIOCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\usbserpw.h ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

   USBSERPW.H

Abstract:

   Header file for Power Management

Environment:

   kernel mode only

Notes:

   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
   PURPOSE.

   Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

   10/29/98 : created

Authors:

   Tom Green

   
****************************************************************************/


#ifndef __USBSERPW_H__
#define __USBSERPW_H__

NTSTATUS
UsbSer_ProcessPowerIrp(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_PoRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction,
                           IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);


NTSTATUS
UsbSer_PowerIrp_Complete(IN PDEVICE_OBJECT NullDeviceObject, IN PIRP Irp, IN PVOID Context);

NTSTATUS
UsbSer_SelfSuspendOrActivate(IN PDEVICE_OBJECT DeviceObject, IN BOOLEAN Suspend);

NTSTATUS
UsbSer_SelfRequestPowerIrp(IN PDEVICE_OBJECT DeviceObject, IN POWER_STATE PowerState);

NTSTATUS
UsbSer_PoSelfRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE PowerState,
                               IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);

BOOLEAN
UsbSer_SetDevicePowerState(IN PDEVICE_OBJECT DeviceObject, IN DEVICE_POWER_STATE DeviceState);

NTSTATUS
UsbSerQueryCapabilities(IN PDEVICE_OBJECT DeviceObject, IN PDEVICE_CAPABILITIES DeviceCapabilities);

NTSTATUS
UsbSerIrpCompletionRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);

NTSTATUS
UsbSerWaitWakeIrpCompletionRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);


NTSTATUS
UsbSerSendWaitWake(PDEVICE_EXTENSION DeviceExtension);

VOID
UsbSerFdoIdleNotificationCallback(IN PDEVICE_EXTENSION DevExt);

NTSTATUS
UsbSerFdoIdleNotificationRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_EXTENSION DevExt
    );

NTSTATUS
UsbSerFdoSubmitIdleRequestIrp(IN PDEVICE_EXTENSION DevExt);

VOID
UsbSerFdoRequestWake(IN PDEVICE_EXTENSION DevExt);


#endif // __USBSERPW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\utils.h ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

   UTILS.H

Abstract:

   Header file for routines that don't fit anywhere else.

Environment:

   kernel mode only

Notes:

   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
   PURPOSE.

   Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

   12/23/97 : created

Authors:

   Tom Green


****************************************************************************/


#ifndef __UTILS_H__
#define __UTILS_H__

// state machine defines for restarting reads from completion routines
#define START_READ         0x0001
#define IMMEDIATE_READ     0x0002
#define END_READ        0x0003

//
// State machine defines for LSRMST insertion
//

#define USBSER_ESCSTATE_DATA        1
#define USBSER_ESCSTATE_NODATA      2
#define USBSER_ESCSTATE_LINESTATUS  3

NTSTATUS
UsbSerGetRegistryKeyValue(IN HANDLE Handle, IN PWCHAR PKeyNameString,
                    IN ULONG KeyNameStringLength, IN PVOID PData,
                    IN ULONG DataLength);

VOID
UsbSerUndoExternalNaming(IN PDEVICE_EXTENSION PDevExt);

NTSTATUS
UsbSerDoExternalNaming(IN PDEVICE_EXTENSION PDevExt);

NTSTATUS
StartDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
StopDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
RemoveDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
CreateDeviceObject(IN PDRIVER_OBJECT DriverObject,
               IN PDEVICE_OBJECT *DeviceObject,
               IN PCHAR DeviceName);

VOID
CompleteIO(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
         IN ULONG MajorFunction, IN PVOID IoBuffer,
         IN ULONG_PTR BufferLen);

NTSTATUS
DeleteObjectAndLink(IN PDEVICE_OBJECT DeviceObject);

VOID
StartPerfTimer(IN OUT PDEVICE_EXTENSION DeviceExtension);

VOID
StopPerfTimer(IN OUT PDEVICE_EXTENSION DeviceExtension,
            IN ULONG BytesXfered);

ULONG
BytesPerSecond(IN OUT PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
CallUSBD(IN PDEVICE_OBJECT DeviceObject, IN PURB Urb);

NTSTATUS
CallUSBD_SyncCompletionRoutine(IN PDEVICE_OBJECT   DeviceObject,
    						   IN PIRP             Irp,
    						   IN PVOID            Context);

NTSTATUS
GetDeviceDescriptor(IN PDEVICE_OBJECT DeviceObject);

NTSTATUS
ConfigureDevice(IN PDEVICE_OBJECT DeviceObject);

NTSTATUS
SelectInterface(IN PDEVICE_OBJECT DeviceObject,
            IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor);

PURB
BuildRequest(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
          IN USBD_PIPE_HANDLE PipeHandle, IN BOOLEAN Read);

VOID
BuildReadRequest(PURB Urb, PUCHAR Buffer, ULONG Length,
             IN USBD_PIPE_HANDLE PipeHandle, IN BOOLEAN Read);

NTSTATUS
ClassVendorCommand(IN PDEVICE_OBJECT DeviceObject, IN UCHAR Request,
                   IN USHORT Value, IN USHORT Index, IN PVOID Buffer,
                   IN OUT PULONG BufferLen, IN BOOLEAN Read, IN ULONG ComType);

VOID
CancelPendingWaitMasks(IN PDEVICE_EXTENSION DeviceExtension);

VOID
CancelPendingNotifyOrRead(IN PDEVICE_EXTENSION DeviceExtension,
                          IN BOOLEAN Notify);

VOID
StartRead(IN PDEVICE_EXTENSION DeviceExtension);

VOID
RestartRead(IN PDEVICE_EXTENSION DeviceExtension);

VOID
StartNotifyRead(IN PDEVICE_EXTENSION DeviceExtension);

VOID
RestartNotifyRead(IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
ReadCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);

ULONG
GetData(IN PDEVICE_EXTENSION DeviceExtension, IN PCHAR Buffer,
        IN ULONG BufferLen, IN OUT PULONG_PTR NewCount);

VOID
PutData(IN PDEVICE_EXTENSION DeviceExtension, IN ULONG BufferLen);

VOID
CheckForQueuedReads(IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
UsbSerSyncCompletion(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN PKEVENT PUsbSerSyncEvent);

VOID
UsbSerFetchBooleanLocked(PBOOLEAN PDest, BOOLEAN Src,
                         PKSPIN_LOCK PSpinLock);

VOID
UsbSerFetchPVoidLocked(PVOID *PDest, PVOID Src, PKSPIN_LOCK PSpinLock);


VOID
UsbSerRundownIrpRefs(IN PIRP *PpCurrentOpIrp, IN PKTIMER IntervalTimer OPTIONAL,
                     IN PKTIMER TotalTimer OPTIONAL,
                     IN PDEVICE_EXTENSION PDevExt);

VOID
UsbSerGetNextIrp(IN PIRP *PpCurrentOpIrp, IN PLIST_ENTRY PQueueToProcess,
                 OUT PIRP *PpNextIrp, IN BOOLEAN CompleteCurrent,
                 IN PDEVICE_EXTENSION PDevExt);

NTSTATUS
UsbSerAbortPipes(IN PDEVICE_OBJECT PDevObj);

VOID
USBSER_RestartNotifyReadWorkItem(IN PDEVICE_OBJECT DeviceObject, IN PDEVICE_EXTENSION DeviceExtension);


#if DBG
PVOID
UsbSerLockPagableCodeSection(PVOID SecFunc);

#define UsbSerLockPagableSectionByHandle(_secHandle) \
{ \
    MmLockPagableSectionByHandle((_secHandle)); \
    InterlockedIncrement(&PAGEUSBSER_Count); \
}

#define UsbSerUnlockPagableImageSection(_secHandle) \
{ \
   InterlockedDecrement(&PAGEUSBSER_Count); \
   MmUnlockPagableImageSection(_secHandle); \
}

//
// Use if code can be called non-locked at lower irql
//

#define USBSER_LOCKED_PAGED_CODE() \
    if ((KeGetCurrentIrql() > APC_LEVEL)  \
    && (PAGEUSBSER_Count == 0)) { \
    KdPrint(("USBSER: Pageable code called at IRQL %d without lock \n", \
             KeGetCurrentIrql())); \
        ASSERT(FALSE); \
        }

//
// Use if code must always be locked; e.g., the function grabs a spinlock
//

#define USBSER_ALWAYS_LOCKED_CODE() \
    if (PAGEUSBSER_Count == 0) { \
      KdPrint(("USBSER: Pagable code raises IRQL called without lock\n")); \
      ASSERT(FALSE); \
    }

#define UsbSerAcquireSpinLock(_pLock, _pIrql) \
{ \
    ASSERTMSG(PAGEUSBSER_Count, "USBSER: Acquire spinlock without paging lock\n")); \
    KeAcquireSpinLock((_pLock), (_pIrql)); \
}

#define UsbSerReleaseSpinLock(_pLock, Irql) \
{ \
    ASSERTMSG(PAGEUSBSER_Count, "USBSER: Release spinlock and paging unlocked\n")); \
    KeReleaseSpinLock((_pLock), (_pIrql)); \
}

#else

#define UsbSerLockPagableCodeSection(_secFunc) \
   MmLockPagableCodeSection((_secFunc))

#define UsbSerLockPagableSectionByHandle(_secHandle) \
{ \
   MmLockPagableSectionByHandle((_secHandle)); \
}

#define UsbSerUnlockPagableImageSection(_secHandle) \
{ \
   MmUnlockPagableImageSection(_secHandle); \
}

#define USBSER_LOCKED_PAGED_CODE()

#define USBSER_ALWAYS_LOCKED_CODE()

#define UsbSerAcquireSpinLock(_pLock, _pIrql) \
   KeAcquireSpinLock((_pLock), (_pIrql))

#define UsbSerReleaseSpinLock(_pLock, Irql) \
   KeReleaseSpinLock((_pLock), (_pIrql))


#endif // DBG
#endif // __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\usbcomm.h ===
/****************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	USBCOMM.H

Abstract:

	USB Communication Class Header File

Environment:

	Kernel mode & user mode

Notes:

	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
	KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
	PURPOSE.

	Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

Revision History:

	12/23/97 : created

Author:

	Tom Green

****************************************************************************/


#ifndef   __USBCOMM_H__
#define   __USBCOMM_H__

#include <pshpack1.h>


// USB Communication Class Code
#define USB_COMM_COMMUNICATION_CLASS_CODE		0x0002

// USB Communication Class Code
#define USB_COMM_DATA_CLASS_CODE				0x000A

// USB Communication Class SubClass Codes
#define USB_COMM_SUBCLASS_RESERVED				0x0000
#define USB_COMM_SUBCLASS_DIRECT_LINE_CONTROL	0x0001
#define USB_COMM_SUBCLASS_ABSTRACT_CONTROL		0x0002
#define USB_COMM_SUBCLASS_TELEPHONE_CONTROL		0x0003

// USB Communication Class Control Protocol Codes
#define USB_COMM_PROTOCOL_RESERVED				0x0000
#define USB_COMM_PROTOCOL_V25TER				0x0001

// Direct Line Control Model defines
#define USB_COMM_SET_AUX_LINE_STATE				0x0010
#define USB_COMM_SET_HOOK_STATE					0x0011
#define USB_COMM_PULSE_SETUP					0x0012
#define USB_COMM_SEND_PULSE						0x0013
#define USB_COMM_SET_PULSE_TIME					0x0014
#define USB_COMM_RING_AUX_JACK					0x0015

// Direct Line Control Model Notification defines
#define USB_COMM_AUX_JACK_HOOK_STATE			0x0008
#define USB_COMM_RING_DETECT					0x0009


// Abstract Control Model defines
#define USB_COMM_SEND_ENCAPSULATED_COMMAND		0x0000
#define USB_COMM_GET_ENCAPSULATED_RESPONSE		0x0001
#define USB_COMM_SET_COMM_FEATURE				0x0002
#define USB_COMM_GET_COMM_FEATURE				0x0003
#define USB_COMM_CLEAR_COMM_FEATURE				0x0004
#define USB_COMM_SET_LINE_CODING				0x0020
#define USB_COMM_GET_LINE_CODING				0x0021
#define USB_COMM_SET_CONTROL_LINE_STATE			0x0022
#define USB_COMM_SEND_BREAK						0x0023

// Abstract Control Model Notification defines
#define USB_COMM_NETWORK_CONNECTION				0x0000
#define USB_COMM_RESPONSE_AVAILABLE				0x0001
#define USB_COMM_SERIAL_STATE					0x0020


// Telephone Control Model defines
#define USB_COMM_SET_RINGER_PARMS				0x0030
#define USB_COMM_GET_RINGER_PARMS				0x0031
#define USB_COMM_SET_OPERATION_PARMS			0x0032
#define USB_COMM_GET_OPERATION_PARMS			0x0033
#define USB_COMM_SET_LINE_PARMS					0x0034
#define USB_COMM_GET_LINE_PARMS					0x0035
#define USB_COMM_DIAL_DIGITS					0x0036

// Telephone Control Model Notification defines
#define USB_COMM_CALL_STATE_CHANGE				0x0028
#define USB_COMM_LINE_STATE_CHANGE				0x0029


// Descriptor type for Functional Descriptors
#define	USB_COMM_CS_INTERFACE					0x0024
#define USB_COMM_CS_ENDPOINT					0x0025


// Communication Feature Selector Codes
#define USB_COMM_ABSTRACT_STATE					0x0001
#define USB_COMM_COUNTRY_SETTING				0x0002

// POTS Relay Configuration Values
#define USB_COMM_ON_HOOK						0x0000
#define USB_COMM_OFF_HOOK						0x0001
#define USB_COMM_SNOOPING						0x0002


// Operation Mode Values
#define USB_COMM_SIMPLE_MODE					0x0000
#define USB_COMM_STANDALONE_MODE				0x0001
#define USB_COMM_COMPUTER_CENTRIC_MODE			0x0002


// Line State Change Values for SET_LINE_PARMS
#define USB_COMM_DROP_ACTIVE_CALL				0x0000
#define USB_COMM_START_NEW_CALL					0x0001
#define USB_COMM_APPLY_RINGING					0x0002
#define USB_COMM_REMOVE_RINGING					0x0003
#define USB_COMM_SWITCH_TO_SPECIFIC_CALL		0x0004


// Call State Values for GET_LINE_PARMS
#define USB_COMM_CALL_IDLE						0x0000
#define USB_COMM_TYPICAL_DIAL_TONE				0x0001
#define USB_COMM_INTERRUPTED_DIAL_TONE			0x0002
#define USB_COMM_DIALING_IN_PROGRESS			0x0003
#define USB_COMM_RINGBACK						0x0004
#define USB_COMM_CONNECTED						0x0005
#define USB_COMM_INCOMING_CALL					0x0006


// Call State Change values for CALL_STATE_CHANGE
#define USB_COMM_CALL_RESERVED					0x0000
#define USB_COMM_CALL_CALL_HAS_BECOME_IDLE		0x0001
#define USB_COMM_CALL_DIALING					0x0002
#define USB_COMM_CALL_RINGBACK					0x0003
#define USB_COMM_CALL_CONNECTED					0x0004
#define USB_COMM_CALL_INCOMING_CALL				0x0005


// Line State Change Values for LINE_STATE_CHANGE
#define USB_COMM_LINE_LINE_HAS_BECOME_IDLE		0x0000
#define USB_COMM_LINE_LINE_HOLD_POSITION		0x0001
#define USB_COMM_LINE_HOOK_SWITCH_OFF			0x0002
#define USB_COMM_LINE_HOOK_SWITCH_ON			0x0003

// Line Coding Stop Bits
#define USB_COMM_STOPBITS_10					0x0000
#define USB_COMM_STOPBITS_15					0x0001
#define USB_COMM_STOPBITS_20					0x0002

// Line Coding Parity Type
#define USB_COMM_PARITY_NONE					0x0000
#define USB_COMM_PARITY_ODD						0x0001
#define USB_COMM_PARITY_EVEN					0x0002
#define USB_COMM_PARITY_MARK					0x0003
#define USB_COMM_PARITY_SPACE					0x0004


// Control Line State
#define USB_COMM_DTR							0x0001
#define USB_COMM_RTS							0x0002

// Serial State Notification bits
#define USB_COMM_DCD							0x0001
#define USB_COMM_DSR							0x0002
#define USB_COMM_BREAK							0x0004
#define USB_COMM_RING							0x0008
#define USB_COMM_FRAMING_ERROR					0x0010
#define USB_COMM_PARITY_ERROR					0x0020
#define USB_COMM_OVERRUN						0x0040



// Call Management Functional Descriptor

typedef struct _USB_COMM_CALL_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
	UCHAR		DataInterface;
} USB_COMM_CALL_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_CALL_MANAGEMENT_FUNC_DESCR;


// Abstract Control Management Functional Descriptor

typedef struct _USB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR;


// Direct Line Management Functional Descriptor

typedef struct _USB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR;


// Telephone Ringer Functional Descriptor

typedef struct _USB_COMM_TELEPHONE_RINGER_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		RingerVolSteps;
	UCHAR		NumRingerPatterns;
} USB_COMM_TELEPHONE_RINGER_FUNC_DESCR, *PUSB_COMM_TELEPHONE_RINGER_FUNC_DESCR;


// Telephone Operational Modes Functional Descriptor

typedef struct _USB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR, *PUSB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR;


// Telephone Call and Line State Reporting Capabilities Descriptor

typedef struct _USB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR, *PUSB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR;


// Union Functional Descriptor

typedef struct _USB_COMM_UNION_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		MasterInterface;
	UCHAR		SlaveInterface;
} USB_COMM_UNION_FUNC_DESCR, *PUSB_COMM_UNION_FUNC_DESCR;


// Country Selection Functional Descriptor

typedef struct _USB_COMM_COUNTRY_SELECTION_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		CountryCodeRelDate;
	UCHAR		CountryCode;
} USB_COMM_COUNTRY_SELECTION_FUNC_DESCR, *PUSB_COMM_COUNTRY_SELECTION_FUNC_DESCR;


// Class Specific Interface Descriptor

typedef struct _USB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		CDC;
} USB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR, *PUSB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR;


// Line Coding for GET_LINE_CODING and SET_LINE_CODING

typedef struct _USB_COMM_LINE_CODING
{
	ULONG		DTERate;
	UCHAR		CharFormat;
	UCHAR		ParityType;
	UCHAR		DataBits;
} USB_COMM_LINE_CODING, *PUSB_COMM_LINE_CODING;

// Line Status Information for GET_LINE_PARMS

typedef struct _USB_COMM_LINE_STATUS
{
	USHORT		Length;
	ULONG		RingerBitmap;
	ULONG		LineState;
	ULONG		CallState;
} USB_COMM_LINE_STATUS, *PUSB_COMM_LINE_STATUS;

// Serial Status Notification

typedef struct _USB_COMM_SERIAL_STATUS
{
	UCHAR		RequestType;
	UCHAR		Notification;
	USHORT		Value;
	USHORT		Index;
	USHORT		Length;
	USHORT		SerialState;
} USB_COMM_SERIAL_STATUS, *PUSB_COMM_SERIAL_STATUS;


#include <poppack.h>

#endif /*  __USBCOMM_H__ */    

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\utils.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        UTILS.C

Abstract:

        Routines that don't fit anywhere else.

Environment:

        kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        12/23/97 : created

Authors:

        Tom Green


****************************************************************************/

#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "usbserpw.h"
#include "serioctl.h"
#include "utils.h"
#include "debugwdm.h"


#ifdef ALLOC_PRAGMA

#if DBG
#pragma alloc_text(PAGEUBS0, UsbSerLockPagableCodeSection)
#endif

#pragma alloc_text(PAGEUBS0, UsbSerGetRegistryKeyValue)
#pragma alloc_text(PAGEUBS0, UsbSerUndoExternalNaming)
#pragma alloc_text(PAGEUBS0, UsbSerDoExternalNaming)

#pragma alloc_text(PAGEUBS0, StopDevice)
#pragma alloc_text(PAGEUBS0, StartPerfTimer)
#pragma alloc_text(PAGEUBS0, StopPerfTimer)
#pragma alloc_text(PAGEUBS0, BytesPerSecond)
#pragma alloc_text(PAGEUBS0, CallUSBD)
#pragma alloc_text(PAGEUBS0, ConfigureDevice)
#pragma alloc_text(PAGEUBS0, BuildRequest)
// #pragma alloc_text(PAGEUBS0, BuildReadRequest) -- called from restartnotify
#pragma alloc_text(PAGEUBS0, ClassVendorCommand)
#pragma alloc_text(PAGEUBS0, StartRead)
#pragma alloc_text(PAGEUBS0, StartNotifyRead)
#pragma alloc_text(PAGEUBS0, UsbSerRestoreModemSettings)
#pragma alloc_text(PAGEUBS0, StartDevice)
#pragma alloc_text(PAGEUBS0, DeleteObjectAndLink)
#pragma alloc_text(PAGEUBS0, RemoveDevice)

// #pragma alloc_text(PAGEUSBS, CancelPendingWaitMasks) -- called from STOP
#pragma alloc_text(PAGEUSBS, UsbSerTryToCompleteCurrent)
#pragma alloc_text(PAGEUSBS, UsbSerGetNextIrp)
#pragma alloc_text(PAGEUSBS, UsbSerStartOrQueue)
#pragma alloc_text(PAGEUSBS, UsbSerCancelQueued)
#pragma alloc_text(PAGEUSBS, UsbSerKillAllReadsOrWrites)
#pragma alloc_text(PAGEUSBS, UsbSerKillPendingIrps)
#pragma alloc_text(PAGEUSBS, UsbSerCompletePendingWaitMasks)
#pragma alloc_text(PAGEUSBS, UsbSerProcessEmptyTransmit)
#pragma alloc_text(PAGEUSBS, UsbSerCancelWaitOnMask)
#endif // ALLOC_PRAGMA

// we will support 256 devices, keep track of open slots here
#define NUM_DEVICE_SLOTS                256


LOCAL BOOLEAN           Slots[NUM_DEVICE_SLOTS];
LOCAL ULONG             NumDevices;
LOCAL PDEVICE_OBJECT    GlobDeviceObject;

USHORT               RxBuffSize = RX_BUFF_SIZE;


/************************************************************************/
/* UsbSerGetRegistryValues                                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Gets values from the registry                                       */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  Handle            Handle to the opened registry key                 */
/*                                                                      */
/*  PKeyNameString      ANSI string to the desired key                  */
/*                                                                      */
/*  KeyNameStringLength Length of the KeyNameString                     */
/*                                                                      */
/*  PData              Buffer to place the key value in                 */
/*                                                                      */
/*  DataLength    Length of the data buffer                             */
/*                                                                      */
/*  PDevExt - pointer to the device extension                           */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*   STATUS_SUCCESS if all works, otherwise status of system call that  */
/*   went wrong.                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSerGetRegistryKeyValue(IN HANDLE Handle, IN PWCHAR PKeyNameString,
                          IN ULONG KeyNameStringLength, IN PVOID PData,
                          IN ULONG DataLength)
{
   UNICODE_STRING keyName;
   ULONG length;
   PKEY_VALUE_FULL_INFORMATION pFullInfo;
   NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSerGetRegistryKeyValue");
   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerGetRegistryKeyValue\n"));

   RtlInitUnicodeString(&keyName, PKeyNameString);

   length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength
                                + DataLength;

   pFullInfo = DEBUG_MEMALLOC(PagedPool, length);

   if (pFullInfo) {
                status = ZwQueryValueKey(Handle, &keyName,
                                         KeyValueFullInformation, pFullInfo,
                                         length, &length);

                if (NT_SUCCESS(status)) {
                        //
                        // If there is enough room in the data buffer,
                        // copy the output
                        //

                        if (DataLength >= pFullInfo->DataLength) {
                                RtlCopyMemory(PData, ((PUCHAR)pFullInfo)
                                              + pFullInfo->DataOffset,
                                              pFullInfo->DataLength);
                        }
                }

                DEBUG_MEMFREE(pFullInfo);
        }

   DEBUG_LOG_ERROR(status);
   DEBUG_LOG_PATH("exit  UsbSerGetRegistryKeyValue");
   DEBUG_TRACE3(("status (%08X)\n", status));
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerGetRegistryKeyValue %08X\n",
                                     status));

        return status;
} // UsbSerGetRegistryKeyValue


/************************************************************************/
/* UsbSerUndoExternalNaming                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/* Remove any and all external namespace interfaces we exposed          */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*   PDevExt - pointer to the device extension                          */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*   VOID                                                               */
/*                                                                      */
/************************************************************************/
VOID
UsbSerUndoExternalNaming(IN PDEVICE_EXTENSION PDevExt)
{

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSerUndoExternalNaming");
   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerUndoExternalNaming\n"));

   if (PDevExt->SymbolicLinkName.Buffer && PDevExt->CreatedSymbolicLink) {
      IoDeleteSymbolicLink(&PDevExt->SymbolicLinkName);
   }

   if (PDevExt->SymbolicLinkName.Buffer != NULL) {
      DEBUG_MEMFREE(PDevExt->SymbolicLinkName.Buffer);
      RtlInitUnicodeString(&PDevExt->SymbolicLinkName, NULL);
   }

   if (PDevExt->DosName.Buffer != NULL) {
      DEBUG_MEMFREE(PDevExt->DosName.Buffer);
      RtlInitUnicodeString(&PDevExt->DosName, NULL);
   }

   if (PDevExt->DeviceName.Buffer != NULL) {
      RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
                             PDevExt->DeviceName.Buffer);
      DEBUG_MEMFREE(PDevExt->DeviceName.Buffer);
      RtlInitUnicodeString(&PDevExt->DeviceName, NULL);
   }

#ifdef WMI_SUPPORT
   if (PDevExt->WmiIdentifier.Buffer)
   {
      DEBUG_MEMFREE(PDevExt->WmiIdentifier.Buffer);
      PDevExt->WmiIdentifier.MaximumLength
         = PDevExt->WmiIdentifier.Length = 0;
      PDevExt->WmiIdentifier.Buffer = NULL;
   }
#endif

   DEBUG_LOG_PATH("exit  UsbSerUndoExternalNaming");
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerUndoExternalNaming\n"));
} // UsbSerUndoExternalNaming


/************************************************************************/
/*  UsbSerDoExternalNaming                                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/* Exposes interfaces in external namespace                             */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      PDevExt - pointer to the device extension                       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSerDoExternalNaming(IN PDEVICE_EXTENSION PDevExt)
{
   NTSTATUS status;
   HANDLE keyHandle;
   WCHAR *pRegName = NULL;
   UNICODE_STRING linkName;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSerDoExternalNaming");
   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerDoExternalNaming\n"));

   RtlZeroMemory(&linkName, sizeof(UNICODE_STRING));
   linkName.MaximumLength = SYMBOLIC_NAME_LENGTH * sizeof(WCHAR);
   linkName.Buffer = DEBUG_MEMALLOC(PagedPool, linkName.MaximumLength
                                    + sizeof(WCHAR));

   if (linkName.Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto UsbSerDoExternalNamingError;
   }

   RtlZeroMemory(linkName.Buffer, linkName.MaximumLength + sizeof(WCHAR));

   pRegName = DEBUG_MEMALLOC(PagedPool, SYMBOLIC_NAME_LENGTH * sizeof(WCHAR)
                             + sizeof(WCHAR));

   if (pRegName == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto UsbSerDoExternalNamingError;
   }

   status = IoOpenDeviceRegistryKey(PDevExt->PhysDeviceObject,
                                    PLUGPLAY_REGKEY_DEVICE,
                                    STANDARD_RIGHTS_READ, &keyHandle);

   if (status != STATUS_SUCCESS) {
      goto UsbSerDoExternalNamingError;
   }

   status = UsbSerGetRegistryKeyValue(keyHandle, L"PortName", sizeof(L"PortName"),
                                      pRegName, SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));

   if (status != STATUS_SUCCESS) {
      status = UsbSerGetRegistryKeyValue(keyHandle, L"Identifier",
                                         sizeof(L"Identifier"), pRegName,
                                         SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));
      if (status != STATUS_SUCCESS) {
         ZwClose(keyHandle);
         goto UsbSerDoExternalNamingError;
      }
   }

   ZwClose(keyHandle);

#ifdef WMI_SUPPORT
   {
   ULONG bufLen;

   bufLen = wcslen(pRegName) * sizeof(WCHAR) + sizeof(UNICODE_NULL);

   PDevExt->WmiIdentifier.Buffer = DEBUG_MEMALLOC(PagedPool, bufLen);

   if (PDevExt->WmiIdentifier.Buffer == NULL)
   {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto UsbSerDoExternalNamingError;
   }


   RtlZeroMemory(PDevExt->WmiIdentifier.Buffer, bufLen);

   PDevExt->WmiIdentifier.Length = 0;
   PDevExt->WmiIdentifier.MaximumLength = (USHORT)bufLen - 1;
   RtlAppendUnicodeToString(&PDevExt->WmiIdentifier, pRegName);

   }
#endif

   //
   // Create the "\\DosDevices\\<symbolicname>" string
   //

   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, DEFAULT_DIRECTORY);
   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, pRegName);

   //
   // Allocate pool and save the symbolic link name in the device extension
   //
   PDevExt->SymbolicLinkName.MaximumLength = linkName.Length + sizeof(WCHAR);
   PDevExt->SymbolicLinkName.Buffer
      = DEBUG_MEMALLOC(PagedPool, PDevExt->SymbolicLinkName.MaximumLength);

   if (PDevExt->SymbolicLinkName.Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto UsbSerDoExternalNamingError;
   }

   RtlZeroMemory(PDevExt->SymbolicLinkName.Buffer,
                 PDevExt->SymbolicLinkName.MaximumLength);

   RtlAppendUnicodeStringToString(&PDevExt->SymbolicLinkName, &linkName);

   status = IoCreateSymbolicLink(&PDevExt->SymbolicLinkName,
                                 &PDevExt->DeviceName);

   if (status != STATUS_SUCCESS) {
      goto UsbSerDoExternalNamingError;
   }

   PDevExt->CreatedSymbolicLink = TRUE;

   PDevExt->DosName.Buffer = DEBUG_MEMALLOC(PagedPool, 64 + sizeof(WCHAR));

   if (PDevExt->DosName.Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto UsbSerDoExternalNamingError;
   }

   PDevExt->DosName.MaximumLength = 64 + sizeof(WCHAR);
   PDevExt->DosName.Length = 0;

   RtlZeroMemory(PDevExt->DosName.Buffer, PDevExt->DosName.MaximumLength);

   RtlAppendUnicodeToString(&PDevExt->DosName, pRegName);
   RtlZeroMemory(((PUCHAR)(&PDevExt->DosName.Buffer[0]))
                 + PDevExt->DosName.Length, sizeof(WCHAR));

   status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP, L"SERIALCOMM",
                                  PDevExt->DeviceName.Buffer, REG_SZ,
                                  PDevExt->DosName.Buffer,
                                  PDevExt->DosName.Length + sizeof(WCHAR));

   if (status != STATUS_SUCCESS) {
      goto UsbSerDoExternalNamingError;
   }

UsbSerDoExternalNamingError:;

   //
   // Clean up error conditions
   //

   if (status != STATUS_SUCCESS) {
      if (PDevExt->DosName.Buffer != NULL) {
         DEBUG_MEMFREE(PDevExt->DosName.Buffer);
         PDevExt->DosName.Buffer = NULL;
      }

      if (PDevExt->CreatedSymbolicLink ==  TRUE) {
         IoDeleteSymbolicLink(&PDevExt->SymbolicLinkName);
         PDevExt->CreatedSymbolicLink = FALSE;
      }

      if (PDevExt->SymbolicLinkName.Buffer != NULL) {
         DEBUG_MEMFREE(PDevExt->SymbolicLinkName.Buffer);
         PDevExt->SymbolicLinkName.Buffer = NULL;
      }

      if (PDevExt->DeviceName.Buffer != NULL) {
         RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
                                PDevExt->DeviceName.Buffer);
      }
   }

   //
   // Always clean up our temp buffers.
   //

   if (linkName.Buffer != NULL) {
      DEBUG_MEMFREE(linkName.Buffer);
   }

   if (pRegName != NULL) {
      DEBUG_MEMFREE(pRegName);
   }

   DEBUG_LOG_ERROR(status);
   DEBUG_LOG_PATH("exit  UsbSerDoExternalNaming");
   DEBUG_TRACE3(("status (%08X)\n", status));
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerDoExternalNaming %08X\n", status));

   return status;

} // UsbSerDoExternalNaming



NTSTATUS
UsbSerAbortPipes(IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

   Called as part of sudden device removal handling.
    Cancels any pending transfers for all open pipes.

Arguments:

    Ptrs to our FDO

Return Value:

    NT status code

--*/
{
   NTSTATUS ntStatus = STATUS_SUCCESS;
   PURB pUrb;
   PDEVICE_EXTENSION pDevExt;
   ULONG pendingIrps;

   DEBUG_TRACE1(("UsbSerAbortPipes\n"));

   UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD,
                    (">UsbSerAbortPipes (%08X)\n", PDevObj));

   pDevExt = PDevObj->DeviceExtension;
   pUrb = DEBUG_MEMALLOC(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST));

   if (pUrb != NULL) 
   {

      pUrb->UrbHeader.Length = (USHORT)sizeof(struct _URB_PIPE_REQUEST);
      pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
      pUrb->UrbPipeRequest.PipeHandle = pDevExt->DataInPipe;

      ntStatus = CallUSBD(PDevObj, pUrb);

      if (ntStatus != STATUS_SUCCESS) {
         goto UsbSerAbortPipesErr;
      }

      //
      // Wait for all the read IRPS to drain
      //

      UsbSerSerialDump(USBSERTRACERD, ("DataInCountw %08X @ %08X\n",
                                       pDevExt->PendingDataInCount,
                                       &pDevExt->PendingDataInCount));

      //
      // Decrement for initial value
      //

      pendingIrps = InterlockedDecrement(&pDevExt->PendingDataInCount);

      if (pendingIrps) {
         DEBUG_TRACE1(("Abort DataIn Pipe\n"));
         UsbSerSerialDump(USBSERTRACEOTH, ("Waiting for DataIn Pipe\n"));
         KeWaitForSingleObject(&pDevExt->PendingDataInEvent, Executive,
                               KernelMode, FALSE, NULL);
      }

      //
      // Reset counter
      //

      InterlockedIncrement(&pDevExt->PendingDataInCount);

      UsbSerSerialDump(USBSERTRACERD, ("DataInCountx %08X @ %08X\n",
                                       pDevExt->PendingDataInCount,
                                       &pDevExt->PendingDataInCount));

      pUrb->UrbHeader.Length = (USHORT)sizeof(struct _URB_PIPE_REQUEST);
      pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
      pUrb->UrbPipeRequest.PipeHandle = pDevExt->DataOutPipe;

      ntStatus = CallUSBD(PDevObj, pUrb);

      if (ntStatus != STATUS_SUCCESS) {
         goto UsbSerAbortPipesErr;
      }

      //
      // Wait for all the write irps to drain
      //

      //
      // Decrement for initial value
      //

      pendingIrps = InterlockedDecrement(&pDevExt->PendingDataOutCount);

      if (pendingIrps) {
         UsbSerSerialDump(USBSERTRACEOTH, ("Waiting for DataOut Pipe\n"));
         KeWaitForSingleObject(&pDevExt->PendingDataOutEvent, Executive,
                               KernelMode, FALSE, NULL);
      }

      //
      // Reset counter
      //

      InterlockedIncrement(&pDevExt->PendingDataOutCount);


      pUrb->UrbHeader.Length = (USHORT)sizeof(struct _URB_PIPE_REQUEST);
      pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
      pUrb->UrbPipeRequest.PipeHandle = pDevExt->NotificationPipe;

      ntStatus = CallUSBD(PDevObj, pUrb);

      //
      // Wait for all the notify irps to drain
      //

      //
      // Decrement for initial value
      //

      pendingIrps = InterlockedDecrement(&pDevExt->PendingNotifyCount);

      if (pendingIrps) {
         UsbSerSerialDump(USBSERTRACEOTH, ("Waiting for Notify Pipe\n"));
         KeWaitForSingleObject(&pDevExt->PendingNotifyEvent, Executive,
                               KernelMode, FALSE, NULL);
      }

      //      //
      // Die my darling, die.
      //

      // IoCancelIrp(pDevExt->NotifyIrp);



      // Reset counter
      //

      InterlockedIncrement(&pDevExt->PendingNotifyCount);

UsbSerAbortPipesErr:;

      DEBUG_MEMFREE(pUrb);

   } else {
      ntStatus = STATUS_INSUFFICIENT_RESOURCES;
   }

   UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD,
                    ("<UsbSerAbortPipes %08X\n", ntStatus));

    return ntStatus;
}



/************************************************************************/
/* StartDevice                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Take care of processing needed to start device.                 */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
StartDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
        PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        KEVENT                  Event;
        PVOID                   pPagingHandle;

        PAGED_CODE();

        DEBUG_LOG_PATH("enter StartDevice");

        DEBUG_TRACE1(("StartDevice\n"));

        // pass this down to the USB stack first
        KeInitializeEvent(&Event, NotificationEvent, FALSE);

        //
        // Initialize our DPC's
        //

        KeInitializeDpc(&DeviceExtension->TotalReadTimeoutDpc,
                        UsbSerReadTimeout, DeviceExtension);
        KeInitializeDpc(&DeviceExtension->IntervalReadTimeoutDpc,
                        UsbSerIntervalReadTimeout, DeviceExtension);
        KeInitializeDpc(&DeviceExtension->TotalWriteTimeoutDpc,
                        UsbSerWriteTimeout, DeviceExtension);

        //
        // Initialize timers
        //

        KeInitializeTimer(&DeviceExtension->WriteRequestTotalTimer);
        KeInitializeTimer(&DeviceExtension->ReadRequestTotalTimer);
        KeInitializeTimer(&DeviceExtension->ReadRequestIntervalTimer);

        //
        // Store values into the extension for interval timing.
        //

        //
        // If the interval timer is less than a second then come
        // in with a short "polling" loop.
        //
        // For large (> then 2 seconds) use a 1 second poller.
        //

        DeviceExtension->ShortIntervalAmount.QuadPart  = -1;
        DeviceExtension->LongIntervalAmount.QuadPart   = -10000000;
        DeviceExtension->CutOverAmount.QuadPart        = 200000000;



        KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, UsbSerSyncCompletion, &Event, TRUE, TRUE,
                               TRUE);

        NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);

        // wait for Irp to complete if status is pending
        if(NtStatus == STATUS_PENDING)
        {
                KeWaitForSingleObject(&Event, Suspended, KernelMode, FALSE,
                                      NULL);
        }

        NtStatus = Irp->IoStatus.Status;

        if (!NT_SUCCESS(NtStatus)) {
           goto ExitStartDevice;
        }

        NtStatus = GetDeviceDescriptor(DeviceObject);

        if (!NT_SUCCESS(NtStatus)) {
           goto ExitStartDevice;
        }

        NtStatus = ConfigureDevice(DeviceObject);

        if (!NT_SUCCESS(NtStatus)) {
           goto ExitStartDevice;
        }

        //
        // Page in and lock necessary code
        //
        pPagingHandle = UsbSerLockPagableCodeSection(PAGEUSBSER_Function);

        // reset device
        ResetDevice(NULL, DeviceObject);

        // init stuff in device extension

        DeviceExtension->HandFlow.ControlHandShake      = 0;
        DeviceExtension->HandFlow.FlowReplace           = SERIAL_RTS_CONTROL;
        DeviceExtension->AcceptingRequests              = TRUE;

        InitializeListHead(&DeviceExtension->ReadQueue);
        InitializeListHead(&DeviceExtension->ImmediateReadQueue);

        UsbSerDoExternalNaming(DeviceExtension);

        // clear DTR and RTS
        SetClrDtr(DeviceObject, FALSE);
        ClrRts(NULL, DeviceExtension);

        // kick off a read
        StartRead(DeviceExtension);

        // kick off a notification read
        StartNotifyRead(DeviceExtension);

        UsbSerUnlockPagableImageSection(pPagingHandle);

ExitStartDevice:;

        if(NT_SUCCESS(NtStatus))
        {
            DeviceExtension->DeviceState = DEVICE_STATE_STARTED;

            // try and idle the modem
            // UsbSerFdoSubmitIdleRequestIrp(DeviceExtension);
        }

        Irp->IoStatus.Status = NtStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        DEBUG_LOG_PATH("exit  StartDevice");

        return NtStatus;
} // StartDevice


/************************************************************************/
/* StopDevice                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Take care of processing needed to stop device.                  */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
StopDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   Size;
    PURB                    Urb;

    PAGED_CODE();

    DEBUG_LOG_PATH("enter StopDevice");

    DEBUG_TRACE1(("StopDevice\n"));

    UsbSerFetchBooleanLocked(&DeviceExtension->AcceptingRequests,
                             FALSE, &DeviceExtension->ControlLock);

    CancelPendingWaitMasks(DeviceExtension);

    if(DeviceExtension->DeviceState == DEVICE_STATE_STARTED)
    {
        DEBUG_TRACE1(("AbortPipes\n"));
        UsbSerAbortPipes(DeviceObject);
    }

    DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;

    if(DeviceExtension->PendingIdleIrp)
    {
        IoCancelIrp(DeviceExtension->PendingIdleIrp);
    }

    Size = sizeof(struct _URB_SELECT_CONFIGURATION);

    Urb = DEBUG_MEMALLOC(NonPagedPool, Size);

    if(Urb)
    {

        UsbBuildSelectConfigurationRequest(Urb, (USHORT) Size, NULL);

        NtStatus = CallUSBD(DeviceObject, Urb);

        DEBUG_TRACE3(("Device Configuration Closed status = (%08X)  "
                      "USB status = (%08X)\n", NtStatus,
                      Urb->UrbHeader.Status));

        DEBUG_MEMFREE(Urb);
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DEBUG_LOG_PATH("exit  StopDevice");

    return NtStatus;
} // StopDevice


/************************************************************************/
/* RemoveDevice                                                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Take care of processing needed to remove device.                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
RemoveDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{

        PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        PVOID                   pPagingHandle;

        PAGED_CODE();

        DEBUG_LOG_PATH("enter RemoveDevice");

        DEBUG_TRACE1(("RemoveDevice\n"));

        //
        // Page in and lock necessary code
        //

        pPagingHandle = UsbSerLockPagableCodeSection(PAGEUSBSER_Function);

        UsbSerFetchBooleanLocked(&DeviceExtension->AcceptingRequests,
                                 FALSE, &DeviceExtension->ControlLock);

        CancelPendingWaitMasks(DeviceExtension);

        //
        // Cancel all pending USB transactions
        //

        if(DeviceExtension->DeviceState == DEVICE_STATE_STARTED)
        {
            DEBUG_TRACE1(("AbortPipes\n"));
            UsbSerAbortPipes(DeviceObject);
        }

        //
        // Once we set accepting requests to false, we shouldn't
        // have any more contention here -- if we do, we're dead
        // because we're freeing memory out from under our feet.
        //

        DEBUG_TRACE1(("Freeing Allocated Memory\n"));

        // free allocated notify URB
        if(DeviceExtension->NotifyUrb)
        {
                DEBUG_MEMFREE(DeviceExtension->NotifyUrb);
                DeviceExtension->NotifyUrb = NULL;
        }

        // free allocated Read URB
        if(DeviceExtension->ReadUrb)
        {
                DEBUG_MEMFREE(DeviceExtension->ReadUrb);
                DeviceExtension->ReadUrb = NULL;
        }

        // free allocated device descriptor
        if(DeviceExtension->DeviceDescriptor)
        {
                DEBUG_MEMFREE(DeviceExtension->DeviceDescriptor);
                DeviceExtension->DeviceDescriptor = NULL;
        }

        // free up read buffer
        if(DeviceExtension->ReadBuff)
        {
                DEBUG_MEMFREE(DeviceExtension->ReadBuff);
                DeviceExtension->ReadBuff = NULL;
        }

        if(DeviceExtension->USBReadBuff)
        {
                DEBUG_MEMFREE(DeviceExtension->USBReadBuff);
                DeviceExtension->USBReadBuff = NULL;
        }

        // free up notification buffer
        if(DeviceExtension->NotificationBuff)
        {
                DEBUG_MEMFREE(DeviceExtension->NotificationBuff);
                DeviceExtension->NotificationBuff = NULL;
        }

        DEBUG_TRACE1(("Undo Serial Name\n"));

        UsbSerUndoExternalNaming(DeviceExtension);

        //
        // Pass this down to the next driver

        IoCopyCurrentIrpStackLocationToNext(Irp);

        NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);

        DEBUG_TRACE1(("Detach Device\n"));

        // detach device from stack
        IoDetachDevice(DeviceExtension->StackDeviceObject);

        DEBUG_TRACE1(("DevExt (%08X)  DevExt Size (%08X)\n", DeviceExtension, sizeof(DEVICE_EXTENSION)));

        DEBUG_TRACE1(("Delete Object and Link\n"));

        // delete device object and symbolic link
        DeleteObjectAndLink(DeviceObject);

        DEBUG_TRACE1(("Done Removing Device\n"));

        DEBUG_LOG_PATH("exit  RemoveDevice");

        UsbSerUnlockPagableImageSection(pPagingHandle);

        DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;

        return NtStatus;
} // RemoveDevice


/************************************************************************/
/* CreateDeviceObject                                                   */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Take care of processing needed to create device obeject for     */
/*      device.                                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DriverObject - pointer to a driver object                       */
/*      DeviceObject - pointer to a device object pointer               */
/*      DeviceName   - pointer to a base name of device                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
CreateDeviceObject(IN PDRIVER_OBJECT DriverObject,
                   IN PDEVICE_OBJECT *DeviceObject,
                   IN PCHAR DeviceName)
{
   ANSI_STRING             DevName;
   ANSI_STRING             LinkName;
   NTSTATUS                NtStatus;
   UNICODE_STRING          DeviceNameUnicodeString;
   UNICODE_STRING          LinkNameUnicodeString;
   PDEVICE_EXTENSION       DeviceExtension;
   CHAR                    DeviceLinkBuffer[NAME_MAX];
   CHAR                    DeviceNameBuffer[NAME_MAX];
   ULONG                   DeviceInstance;
   ULONG                   bufferLen;
   KIRQL                   OldIrql;

   DEBUG_LOG_PATH("enter CreateDeviceObject");

   DEBUG_TRACE1(("CreateDeviceObject\n"));

   KeAcquireSpinLock(&GlobalSpinLock, &OldIrql);

   // let's get an instance
   for (DeviceInstance = 0; DeviceInstance < NUM_DEVICE_SLOTS;
        DeviceInstance++) {
      if (Slots[DeviceInstance] == FALSE)
         break;
   }

   KeReleaseSpinLock(&GlobalSpinLock, OldIrql);

   // check if we didn't have any empty slots
   if (DeviceInstance == NUM_DEVICE_SLOTS)
      NtStatus = STATUS_INVALID_DEVICE_REQUEST;
   else {
      // complete names of links and devices
      sprintf(DeviceLinkBuffer, "%s%s%03d", "\\DosDevices\\", DeviceName,
              DeviceInstance);
      sprintf(DeviceNameBuffer, "%s%s%03d", "\\Device\\", DeviceName,
              DeviceInstance);

      // init ANSI string with our link and device names
      RtlInitAnsiString(&DevName, DeviceNameBuffer);
      RtlInitAnsiString(&LinkName, DeviceLinkBuffer);

      DeviceNameUnicodeString.Length = 0;
      DeviceNameUnicodeString.Buffer = NULL;

      LinkNameUnicodeString.Length = 0;
      LinkNameUnicodeString.Buffer = NULL;

      *DeviceObject = NULL;

      // convert to UNICODE string
      NtStatus = RtlAnsiStringToUnicodeString(&DeviceNameUnicodeString,
                                              &DevName, TRUE);

      if(NT_SUCCESS(NtStatus))
      {
          NtStatus = RtlAnsiStringToUnicodeString(&LinkNameUnicodeString,
                                                  &LinkName, TRUE);

          if(NT_SUCCESS(NtStatus))
          {
              DEBUG_TRACE3(("Create Device (%s)\n", DeviceNameBuffer));

              // create the device object
              NtStatus = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),
                                        &DeviceNameUnicodeString,
                                        FILE_DEVICE_MODEM, 0, TRUE,
                                        DeviceObject);
          } else {
             goto CreateDeviceObjectError;
          }
      } else {
         goto CreateDeviceObjectError;
      }

      // created the device object O.K., create symbolic links,
      // attach device object, and fill in the device extension

      if (NT_SUCCESS(NtStatus)) {
         // create symbolic links

         DEBUG_TRACE3(("Create SymLink (%s)\n", DeviceLinkBuffer));


         NtStatus = IoCreateUnprotectedSymbolicLink(&LinkNameUnicodeString,
                                                    &DeviceNameUnicodeString);

         if (NtStatus != STATUS_SUCCESS) {
            goto CreateDeviceObjectError;
         }

         // get pointer to device extension
         DeviceExtension = (PDEVICE_EXTENSION) (*DeviceObject)->DeviceExtension;

         // let's zero out device extension
         RtlZeroMemory(DeviceExtension, sizeof(DEVICE_EXTENSION));

         // save our strings

         // save link name
         strcpy(DeviceExtension->LinkName, DeviceLinkBuffer);

         bufferLen = RtlAnsiStringToUnicodeSize(&DevName);

         DeviceExtension->DeviceName.Length = 0;
         DeviceExtension->DeviceName.MaximumLength = (USHORT)bufferLen;

         DeviceExtension->DeviceName.Buffer = DEBUG_MEMALLOC(PagedPool,
                                                             bufferLen);

         if (DeviceExtension->DeviceName.Buffer == NULL) {
            //
            // Skip out.  We have worse problems than missing
            // the name.
            //

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto CreateDeviceObjectError;
         } else {
            RtlAnsiStringToUnicodeString(&DeviceExtension->DeviceName, &DevName,
                                          FALSE);


            // save physical device object
            DeviceExtension->PhysDeviceObject  = *DeviceObject;
            DeviceExtension->Instance          = DeviceInstance;

            // initialize spinlocks
            KeInitializeSpinLock(&DeviceExtension->ControlLock);

            // mark this device slot as in use and increment number
            // of devices
            KeAcquireSpinLock(&GlobalSpinLock, &OldIrql);

            Slots[DeviceInstance]     = TRUE;
            NumDevices++;

            KeReleaseSpinLock(&GlobalSpinLock, OldIrql);

            DeviceExtension->IsDevice = TRUE;

            KeInitializeEvent(&DeviceExtension->PendingDataInEvent,
                              SynchronizationEvent, FALSE);
            KeInitializeEvent(&DeviceExtension->PendingDataOutEvent,
                              SynchronizationEvent, FALSE);
            KeInitializeEvent(&DeviceExtension->PendingNotifyEvent,
                              SynchronizationEvent, FALSE);
            KeInitializeEvent(&DeviceExtension->PendingFlushEvent,
                              SynchronizationEvent, FALSE);

            DeviceExtension->PendingDataInCount = 1;
            DeviceExtension->PendingDataOutCount = 1;
            DeviceExtension->PendingNotifyCount = 1;
            DeviceExtension->SanityCheck = SANITY_CHECK;

         }
      }

CreateDeviceObjectError:;
      // free Unicode strings
      RtlFreeUnicodeString(&DeviceNameUnicodeString);
      RtlFreeUnicodeString(&LinkNameUnicodeString);

      //
      // Delete the devobj if there was an error
      //

      if (NtStatus != STATUS_SUCCESS) {
         if (*DeviceObject) {
            IoDeleteDevice(*DeviceObject);
            *DeviceObject = NULL;
         }
      }
   }

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  CreateDeviceObject");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   return NtStatus;
} // CreateDeviceObject


/************************************************************************/
/* CompleteIO                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Complete IO request and log IRP                                     */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  DeviceObject  - pointer to device object.                           */
/*  Irp           - pointer to IRP.                                     */
/*  MajorFunction - major function of IRP.                              */
/*  IoBuffer      - buffer for data passed in and out of driver.        */
/*  BufferLen     - length of buffer                                    */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
CompleteIO(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN ULONG MajorFunction,
           IN PVOID IoBuffer, IN ULONG_PTR BufferLen)
{
   PDEVICE_EXTENSION DeviceExtension;

   DEBUG_LOG_PATH("enter CompleteIO");

   // get pointer to device extension
   DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

   // log IRP count and bytes processed in device extension
   DeviceExtension->IRPCount++;
   DeviceExtension->ByteCount
      = RtlLargeIntegerAdd(DeviceExtension->ByteCount,
                           RtlConvertUlongToLargeInteger((ULONG)Irp->IoStatus
                                                         .Information));

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, MajorFunction, IoBuffer,
                      (ULONG)BufferLen);

   // if we got here, must want to complete request on IRP
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   DEBUG_LOG_PATH("exit  CompleteIO");
} // CompleteIO


/************************************************************************/
/* DeleteObjectAndLink                                                  */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Deletes a device object and associated symbolic link                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  DeviceObject - pointer to device object.                            */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
DeleteObjectAndLink(IN PDEVICE_OBJECT DeviceObject)
{
        PDEVICE_EXTENSION       DeviceExtension;
        UNICODE_STRING          DeviceLinkUnicodeString;
        ANSI_STRING             DeviceLinkAnsiString;
        NTSTATUS                NtStatus;

        PAGED_CODE();

        DEBUG_LOG_PATH("enter DeleteObjectAndLink");

        DEBUG_TRACE1(("DeleteObjectAndLink\n"));

        // get pointer to device extension, we will get the symbolic link name
        // here
        DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

        // get rid of the symbolic link
        RtlInitAnsiString(&DeviceLinkAnsiString, DeviceExtension->LinkName);
        NtStatus = RtlAnsiStringToUnicodeString(&DeviceLinkUnicodeString,
                                                &DeviceLinkAnsiString, TRUE);

        DEBUG_TRACE1(("Delete Symbolic Link\n"));

        IoDeleteSymbolicLink(&DeviceLinkUnicodeString);

        // clear out slot and decrement number of devices
        if(DeviceExtension->Instance < NUM_DEVICE_SLOTS)
        {
                UsbSerFetchBooleanLocked(&Slots[DeviceExtension->Instance],
                                         FALSE, &GlobalSpinLock);
                NumDevices--;

                if(!NumDevices)
                    DEBUG_CHECKMEM();
        }

        DEBUG_TRACE1(("Delete Device Object\n"));

        if(DeviceExtension->SanityCheck != SANITY_CHECK)
        {
            DEBUG_TRACE1(("Device Extension Scrozzled\n"));
        }

        // wait to do this till here as this triggers unload routine
        IoDeleteDevice(DeviceObject);

        DEBUG_TRACE1(("Done Deleting Device Object and Link\n"));

        DEBUG_LOG_PATH("exit  DeleteObjectAndLink");

        return NtStatus;
} // DeleteObjectAndLink


/************************************************************************/
/* StartPerfTimer                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Start perf timer for measuring bytes/second throughput              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  DeviceExtension - pointer to device extension for device            */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
StartPerfTimer(IN OUT PDEVICE_EXTENSION DeviceExtension)
{
   PAGED_CODE();

        // set up perf stuff if perf timing enabled
        if(DeviceExtension && DeviceExtension->PerfTimerEnabled)
        {
                // get current perf counter
                DeviceExtension->TimerStart = KeQueryPerformanceCounter(NULL);
        }
} // StartPerfTimer


/************************************************************************/
/* StopPerfTimer                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Stop perf timer for measuring bytes/second throughput               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  DeviceExtension - pointer to device extension for device            */
/*  BytesXfered     - number of bytes tranferred this iteration         */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
StopPerfTimer(IN OUT PDEVICE_EXTENSION DeviceExtension,
              IN ULONG BytesXfered)
{
        LARGE_INTEGER   BytesThisTransfer;
        LARGE_INTEGER   CurrentTime;
        LARGE_INTEGER   TimeThisTransfer;

        PAGED_CODE();

        if(DeviceExtension && DeviceExtension->PerfTimerEnabled)
        {
                // get updated time
                CurrentTime = KeQueryPerformanceCounter(NULL);

                // stop perf timing with system timer
                BytesThisTransfer = RtlConvertUlongToLargeInteger(BytesXfered);

                DeviceExtension->BytesXfered
                   = RtlLargeIntegerAdd(DeviceExtension->BytesXfered,
                                        BytesThisTransfer);

                // now add the time it took to elapsed time
                TimeThisTransfer
                   = RtlLargeIntegerSubtract(CurrentTime,
                                             DeviceExtension->TimerStart);

                DeviceExtension->ElapsedTime
                   = RtlLargeIntegerAdd(DeviceExtension->ElapsedTime,
                                        TimeThisTransfer);
        }

} // StopPerfTimer


/************************************************************************/
/* BytesPerSecond                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Start perf timer for measuring bytes/second throughput              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  DeviceExtension - pointer to device extension for device            */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      ULONG - bytes/second for device                                 */
/*                                                                      */
/************************************************************************/
ULONG
BytesPerSecond(IN OUT PDEVICE_EXTENSION DeviceExtension)
{
        ULONG                   Remainder;
        LARGE_INTEGER   Result;
        LARGE_INTEGER   TicksPerSecond;

        PAGED_CODE();

        // get ticks per second from perf counter
        KeQueryPerformanceCounter(&TicksPerSecond);

        // scale the bytes xfered
        Result = RtlExtendedIntegerMultiply(DeviceExtension->BytesXfered,
                                            TicksPerSecond.LowPart);

        // Don't divide by 0
        DeviceExtension->ElapsedTime.LowPart
           = (DeviceExtension->ElapsedTime.LowPart == 0L) ? 1 :
           DeviceExtension->ElapsedTime.LowPart;

        // lets get stats here
        Result
           = RtlExtendedLargeIntegerDivide(Result,
                                           DeviceExtension->ElapsedTime.LowPart,
                                           &Remainder);

        return Result.LowPart;
} // BytesPerSecond


/************************************************************************/
/* CallUSBD                                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Call USB bus driver.                                            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Urb          - pointer to URB                                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
CallUSBD(IN PDEVICE_OBJECT DeviceObject, IN PURB Urb)
{
   NTSTATUS             NtStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION    DeviceExtension = DeviceObject->DeviceExtension;
   PIRP                 Irp;
   KEVENT               Event;
   PIO_STACK_LOCATION   NextStack;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter CallUSBD");

   // issue a synchronous request
   KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

   Irp = IoAllocateIrp(DeviceExtension->StackDeviceObject->StackSize, FALSE);

   if (Irp == NULL)
   {
     return STATUS_INSUFFICIENT_RESOURCES;
   }

    // Set the Irp parameters
    NextStack = IoGetNextIrpStackLocation(Irp);

    NextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    NextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    NextStack->Parameters.Others.Argument1 = Urb;

    // Set the completion routine, which will signal the event
    IoSetCompletionRoutine(Irp,
                           CallUSBD_SyncCompletionRoutine,
                           &Event,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel

   DEBUG_LOG_PATH("Calling USB driver stack");

   NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);

   DEBUG_LOG_PATH("Returned from calling USB driver stack");

   // block on pending request
   if(NtStatus == STATUS_PENDING)
   {
        LARGE_INTEGER timeout;

        // Specify a timeout of 30 seconds to wait for this call to complete.
        //
        timeout.QuadPart = -10000 * 30000;

        NtStatus = KeWaitForSingleObject(&Event,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &timeout);

        if(NtStatus == STATUS_TIMEOUT)
        {
            NtStatus = STATUS_IO_TIMEOUT;

            // Cancel the Irp we just sent.
            //
            IoCancelIrp(Irp);

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else
        {
            NtStatus = Irp->IoStatus.Status;
        }
   }

   IoFreeIrp(Irp);

   DEBUG_LOG_PATH("exit  CallUSBD");

   return NtStatus;
} // CallUSBD

/************************************************************************/
/* CallUSBD_SyncCompletionRoutine                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Completion routine for USB sync request.                        */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
CallUSBD_SyncCompletionRoutine(IN PDEVICE_OBJECT   DeviceObject,
                        IN PIRP             Irp,
                        IN PVOID            Context)
{
    PKEVENT kevent;

    kevent = (PKEVENT) Context;

    KeSetEvent(kevent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
} // CallUSBD_SyncCompletionRoutine


/************************************************************************/
/* GetDeviceDescriptor                                                  */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Get device descriptor for USB device.                           */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetDeviceDescriptor(IN PDEVICE_OBJECT DeviceObject)
{
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   NTSTATUS                NtStatus;
   PUSB_DEVICE_DESCRIPTOR  DeviceDescriptor;
   PURB                    Urb;
   ULONG                   Size;
   ULONG                   UrbCDRSize;
   KIRQL                   OldIrql;

   DEBUG_LOG_PATH("enter GetDeviceDescriptor");

   UrbCDRSize = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);

   Urb = DEBUG_MEMALLOC(NonPagedPool, UrbCDRSize);

   if (Urb) {
      Size = sizeof(USB_DEVICE_DESCRIPTOR);

      DeviceDescriptor = DEBUG_MEMALLOC(NonPagedPool, Size);

      if (DeviceDescriptor) {

         UsbBuildGetDescriptorRequest(Urb, (USHORT)UrbCDRSize,
                                      USB_DEVICE_DESCRIPTOR_TYPE, 0, 0,
                                      DeviceDescriptor, NULL, Size, NULL);

         NtStatus = CallUSBD(DeviceObject, Urb);

         if (NT_SUCCESS(NtStatus)) {
            DEBUG_TRACE3(("Device Descriptor  (%08X)\n", DeviceDescriptor));
            DEBUG_TRACE3(("Length             (%08X)\n",
                          Urb->UrbControlDescriptorRequest
                          .TransferBufferLength));
            DEBUG_TRACE3(("Device Descriptor:\n"));
            DEBUG_TRACE3(("-------------------------\n"));
            DEBUG_TRACE3(("bLength            (%08X)\n",
                          DeviceDescriptor->bLength));
            DEBUG_TRACE3(("bDescriptorType    (%08X)\n",
                          DeviceDescriptor->bDescriptorType));
            DEBUG_TRACE3(("bcdUSB             (%08X)\n",
                          DeviceDescriptor->bcdUSB));
            DEBUG_TRACE3(("bDeviceClass       (%08X)\n",
                          DeviceDescriptor->bDeviceClass));
            DEBUG_TRACE3(("bDeviceSubClass    (%08X)\n",
                          DeviceDescriptor->bDeviceSubClass));
            DEBUG_TRACE3(("bDeviceProtocol    (%08X)\n",
                          DeviceDescriptor->bDeviceProtocol));
            DEBUG_TRACE3(("bMaxPacketSize0    (%08X)\n",
                          DeviceDescriptor->bMaxPacketSize0));
            DEBUG_TRACE3(("idVendor           (%08X)\n",
                          DeviceDescriptor->idVendor));
            DEBUG_TRACE3(("idProduct          (%08X)\n",
                          DeviceDescriptor->idProduct));
            DEBUG_TRACE3(("bcdDevice          (%08X)\n",
                          DeviceDescriptor->bcdDevice));
            DEBUG_TRACE3(("iManufacturer      (%08X)\n",
                          DeviceDescriptor->iManufacturer));
            DEBUG_TRACE3(("iProduct           (%08X)\n",
                          DeviceDescriptor->iProduct));
            DEBUG_TRACE3(("iSerialNumber      (%08X)\n",
                          DeviceDescriptor->iSerialNumber));
            DEBUG_TRACE3(("bNumConfigurations (%08X)\n",
                          DeviceDescriptor->bNumConfigurations));
         }
      } else {
         NtStatus = STATUS_INSUFFICIENT_RESOURCES;
      }

      // save the device descriptor
      if (NT_SUCCESS(NtStatus)) {
         PVOID pOldDesc = NULL;

         ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

         if (DeviceExtension->DeviceDescriptor) {
            pOldDesc = DeviceExtension->DeviceDescriptor;
         }
         DeviceExtension->DeviceDescriptor = DeviceDescriptor;

         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

         if (pOldDesc != NULL) {
            DEBUG_MEMFREE(pOldDesc);
         }
      } else if (DeviceDescriptor) {
         DEBUG_MEMFREE(DeviceDescriptor);
      }

      DEBUG_MEMFREE(Urb);

   } else {
      NtStatus = STATUS_INSUFFICIENT_RESOURCES;
   }

   DEBUG_LOG_PATH("exit  GetDeviceDescriptor");

   return NtStatus;
} // GetDeviceDescriptor


/************************************************************************/
/* ConfigureDevice                                                      */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Initializes USB device and selects configuration.               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ConfigureDevice(IN PDEVICE_OBJECT DeviceObject)
{
   PDEVICE_EXTENSION                DeviceExtension
                                       = DeviceObject->DeviceExtension;
   NTSTATUS                         NtStatus;
   PURB                             Urb;
   ULONG                            Size;
   ULONG                            UrbCDRSize;
   PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor;
   ULONG                            NumConfigs;
   UCHAR                            Config;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter ConfigureDevice");

   UrbCDRSize = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);

   // first configure the device
   Urb = DEBUG_MEMALLOC(NonPagedPool, UrbCDRSize);

   if (Urb) {

      // there may be problems with the 82930 chip, so make this buffer bigger
      // to prevent choking
      Size = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 256;

      // get the number of configurations
      NumConfigs = DeviceExtension->DeviceDescriptor->bNumConfigurations;

      // run through all of the configurations looking for a CDC device
      for (Config = 0; Config < NumConfigs; Config++) {

         // we will probably only do this once, maybe twice
         while (TRUE) {

            ConfigurationDescriptor = DEBUG_MEMALLOC(NonPagedPool, Size);

            if (ConfigurationDescriptor) {
               UsbBuildGetDescriptorRequest(Urb, (USHORT)UrbCDRSize,
                                            USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                            Config, 0, ConfigurationDescriptor,
                                            NULL, Size, NULL);

               NtStatus = CallUSBD(DeviceObject, Urb);

               DEBUG_TRACE3(("Configuration Descriptor (%08X)   "
                             "Length (%08X)\n", ConfigurationDescriptor,
                             Urb->UrbControlDescriptorRequest
                             .TransferBufferLength));
            } else {
               NtStatus = STATUS_INSUFFICIENT_RESOURCES;
               break;
            }

            // see if we got enough data, we may get an error in URB because of
            // buffer overrun
            if (Urb->UrbControlDescriptorRequest.TransferBufferLength>0 &&
                ConfigurationDescriptor->wTotalLength > Size) {
               // size of data exceeds current buffer size, so allocate correct
               // size
               Size = ConfigurationDescriptor->wTotalLength;
               DEBUG_MEMFREE(ConfigurationDescriptor);
               ConfigurationDescriptor = NULL;
            } else {
               break;
            }
         }

         if (NT_SUCCESS(NtStatus)) {
            NtStatus = SelectInterface(DeviceObject, ConfigurationDescriptor);
            DEBUG_MEMFREE(ConfigurationDescriptor);
            ConfigurationDescriptor = NULL;
         }
         else
         {
            DEBUG_MEMFREE(ConfigurationDescriptor);
            ConfigurationDescriptor = NULL;
         }


         // found a config we like
         if (NT_SUCCESS(NtStatus))
            break;
      }

      DEBUG_MEMFREE(Urb);
   } else {
      NtStatus = STATUS_INSUFFICIENT_RESOURCES;
   }


   DEBUG_LOG_PATH("exit  ConfigureDevice");

   return NtStatus;
} // ConfigureDevice


/************************************************************************/
/* SelectInterface                                                      */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Select interface for USB device.                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject             - pointer to a device object           */
/*      ConfigurationDescriptor  - pointer to config descriptor         */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SelectInterface(IN PDEVICE_OBJECT DeviceObject,
                IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor)
{
   PDEVICE_EXTENSION             DeviceExtension
                                    = DeviceObject->DeviceExtension;
   NTSTATUS                      NtStatus;
   PURB                          Urb;
   USHORT                        Size;
   ULONG                         Index;
   PUSBD_INTERFACE_INFORMATION   Interfaces[2];
   PUSBD_INTERFACE_INFORMATION   Interface;
   PUSB_INTERFACE_DESCRIPTOR     InterfaceDescriptor[2];
   UCHAR                         AlternateSetting, InterfaceNumber;
   ULONG                         Pipe;
   KIRQL                         OldIrql;
   PUCHAR                        Temp;
   BOOLEAN                       FoundCommDevice = FALSE;

   DEBUG_LOG_PATH("enter SelectInterface");

   Urb = USBD_CreateConfigurationRequest(ConfigurationDescriptor, &Size);

   if (Urb) {
      Temp = (PUCHAR) &Urb->UrbSelectConfiguration.Interface;

      for (InterfaceNumber = 0;
           InterfaceNumber < ConfigurationDescriptor->bNumInterfaces;
           InterfaceNumber++) {
         AlternateSetting        = 0;

         InterfaceDescriptor[InterfaceNumber] =
            USBD_ParseConfigurationDescriptor(ConfigurationDescriptor,
                                              InterfaceNumber,
                                              AlternateSetting);

         Interfaces[InterfaceNumber] = (PUSBD_INTERFACE_INFORMATION) Temp;

         Interfaces[InterfaceNumber]->Length
            = GET_USBD_INTERFACE_SIZE(InterfaceDescriptor[InterfaceNumber]
                                      ->bNumEndpoints);
         Interfaces[InterfaceNumber]->InterfaceNumber
            = InterfaceDescriptor[InterfaceNumber]->bInterfaceNumber;
         Interfaces[InterfaceNumber]->AlternateSetting
            = InterfaceDescriptor[InterfaceNumber]->bAlternateSetting;

         for (Index = 0; Index < Interfaces[InterfaceNumber]->NumberOfPipes;
              Index++)
         {
                PUSBD_PIPE_INFORMATION          PipeInformation;

            PipeInformation = &Interfaces[InterfaceNumber]->Pipes[Index];

            if (USB_ENDPOINT_DIRECTION_IN(PipeInformation->EndpointAddress))
            {
               // check for data in pipe
               if (PipeInformation->PipeType == USB_ENDPOINT_TYPE_BULK)
               {
                    // set bulk pipe in max transfer size
                    PipeInformation->MaximumTransferSize
                                = USB_RX_BUFF_SIZE;
               }
            }
            else if (USB_ENDPOINT_DIRECTION_OUT(PipeInformation->EndpointAddress))
            {
               // check for data out pipe
               if (PipeInformation->PipeType == USB_ENDPOINT_TYPE_BULK)
               {

                    // set bulk pipe out max transfer size
                    PipeInformation->MaximumTransferSize
                                = MAXIMUM_TRANSFER_SIZE;
               }
            }
         }

         Temp += Interfaces[InterfaceNumber]->Length;
      }


      UsbBuildSelectConfigurationRequest(Urb, Size, ConfigurationDescriptor);

      NtStatus = CallUSBD(DeviceObject, Urb);

      if (NtStatus != STATUS_SUCCESS) {
         ExFreePool(Urb);
         goto ExitSelectInterface;
      }

      DEBUG_TRACE3(("Select Config Status (%08X)\n", NtStatus));

      DeviceExtension->ConfigurationHandle
         = Urb->UrbSelectConfiguration.ConfigurationHandle;

      for (InterfaceNumber = 0;
           InterfaceNumber < ConfigurationDescriptor->bNumInterfaces;
           InterfaceNumber++) {

         Interface = Interfaces[InterfaceNumber];

         DEBUG_TRACE3(("---------\n"));
         DEBUG_TRACE3(("NumberOfPipes     (%08X)\n", Interface->NumberOfPipes));
         DEBUG_TRACE3(("Length            (%08X)\n", Interface->Length));
         DEBUG_TRACE3(("Alt Setting       (%08X)\n",
                       Interface->AlternateSetting));
         DEBUG_TRACE3(("Interface Number  (%08X)\n",
                       Interface->InterfaceNumber));
         DEBUG_TRACE3(("Class (%08X)  SubClass (%08X)  Protocol (%08X)\n",
                       Interface->Class,
                       Interface->SubClass,
                       Interface->Protocol));

         if (Interface->Class == USB_COMM_COMMUNICATION_CLASS_CODE) {
            FoundCommDevice = TRUE;
            DeviceExtension->CommInterface = Interface->InterfaceNumber;
         }

         for (Pipe = 0; Pipe < Interface->NumberOfPipes; Pipe++) {
            PUSBD_PIPE_INFORMATION          PipeInformation;

            PipeInformation = &Interface->Pipes[Pipe];

            DEBUG_TRACE3(("---------\n"));
            DEBUG_TRACE3(("PipeType            (%08X)\n",
                          PipeInformation->PipeType));
            DEBUG_TRACE3(("EndpointAddress     (%08X)\n",
                          PipeInformation->EndpointAddress));
            DEBUG_TRACE3(("MaxPacketSize       (%08X)\n",
                          PipeInformation->MaximumPacketSize));
            DEBUG_TRACE3(("Interval            (%08X)\n",
                          PipeInformation->Interval));
            DEBUG_TRACE3(("Handle              (%08X)\n",
                          PipeInformation->PipeHandle));
            DEBUG_TRACE3(("MaximumTransferSize (%08X)\n",
                          PipeInformation->MaximumTransferSize));

            // now lets save pipe handles in device extension
            if (USB_ENDPOINT_DIRECTION_IN(PipeInformation->EndpointAddress)) {
               // check for data in pipe
               if (PipeInformation->PipeType == USB_ENDPOINT_TYPE_BULK) {
                  PVOID pOldNotBuff = NULL;
                  PVOID pOldReadBuff = NULL;
				  PVOID pOldUSBReadBuff = NULL;
				  PVOID pNewNotBuff = NULL;
                  PVOID pNewReadBuff = NULL;
                  PVOID pNewUSBReadBuff = NULL;

                  DeviceExtension->RxMaxPacketSize = RxBuffSize;

                  if (DeviceExtension->RxMaxPacketSize != 0) {
                     pNewReadBuff = DEBUG_MEMALLOC(NonPagedPool,
                                                   DeviceExtension->RxMaxPacketSize);
                  }

                  pNewNotBuff = DEBUG_MEMALLOC(NonPagedPool,
                                               NOTIFICATION_BUFF_SIZE);

                  pNewUSBReadBuff = DEBUG_MEMALLOC(NonPagedPool,
                                                   USB_RX_BUFF_SIZE);

                  ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                  DeviceExtension->DataInPipe = PipeInformation->PipeHandle;

                  if (DeviceExtension->NotificationBuff)
                     pOldNotBuff = DeviceExtension->NotificationBuff;

                  if (DeviceExtension->ReadBuff)
                     pOldReadBuff = DeviceExtension->ReadBuff;

                  if (DeviceExtension->USBReadBuff)
                     pOldUSBReadBuff = DeviceExtension->USBReadBuff;

                  DeviceExtension->RxQueueSize
                     = DeviceExtension->RxMaxPacketSize;
                  DeviceExtension->CharsInReadBuff                = 0;
                  DeviceExtension->CurrentReadBuffPtr             = 0;

                  DeviceExtension->ReadBuff = pNewReadBuff;

                  DeviceExtension->USBReadBuff = pNewUSBReadBuff;

                  DeviceExtension->NotificationBuff = pNewNotBuff;

                  RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                  if (pOldNotBuff != NULL) {
                     DEBUG_MEMFREE(pOldNotBuff);
                  }

                  if (pOldReadBuff != NULL) {
                     DEBUG_MEMFREE(pOldReadBuff);
                  }

                  if (pOldUSBReadBuff != NULL) {
                     DEBUG_MEMFREE(pOldUSBReadBuff);
                  }
               }
               // check for notification pipe
               else if (PipeInformation->PipeType
                        == USB_ENDPOINT_TYPE_INTERRUPT)
                  DeviceExtension->NotificationPipe
                  = PipeInformation->PipeHandle;
            } else {
               // check for data out pipe
               if (PipeInformation->PipeType == USB_ENDPOINT_TYPE_BULK)
                  DeviceExtension->DataOutPipe = PipeInformation->PipeHandle;
            }
         }

         DEBUG_TRACE3(("Data Out (%08X)  Data In (%08X)  Notification (%08X)\n",
                       DeviceExtension->DataOutPipe,
                       DeviceExtension->DataInPipe,
                       DeviceExtension->NotificationPipe));

      }
      ExFreePool(Urb);
   } else {
      NtStatus = STATUS_INSUFFICIENT_RESOURCES;
   }

   if (!FoundCommDevice)
      NtStatus = STATUS_NO_SUCH_DEVICE;

ExitSelectInterface:;

   DEBUG_LOG_PATH("exit  SelectInterface");

   return NtStatus;
} // SelectInterface


/************************************************************************/
/* BuildRequest                                                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Build a Urb for a USB request                                   */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to Irp                                   */
/*      PipeHandle   - USB pipe handle                                  */
/*      Read         - transfer direction                               */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      Pointer to URB                                                  */
/*                                                                      */
/************************************************************************/
PURB
BuildRequest(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
             IN USBD_PIPE_HANDLE PipeHandle, IN BOOLEAN Read)
{
   ULONG                   Size;
   ULONG                   Length;
   PURB                    Urb;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter BuildRequest");

   // length of buffer
   Length = MmGetMdlByteCount(Irp->MdlAddress);

   // allocate and zero Urb
   Size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
   Urb = DEBUG_MEMALLOC(NonPagedPool, Size);

   if (Urb) {
      RtlZeroMemory(Urb, Size);

      Urb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) Size;
      Urb->UrbBulkOrInterruptTransfer.Hdr.Function =
         URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
      Urb->UrbBulkOrInterruptTransfer.PipeHandle = PipeHandle;
      Urb->UrbBulkOrInterruptTransfer.TransferFlags =
         Read ? USBD_TRANSFER_DIRECTION_IN : 0;

      // use an MDL
      Urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = Irp->MdlAddress;
      Urb->UrbBulkOrInterruptTransfer.TransferBufferLength = Length;

      // short packet is not treated as an error.
      Urb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;

      // no linkage for now
      Urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
   }

   DEBUG_LOG_PATH("exit  BuildRequest");

   return Urb;
} // BuildRequest


/************************************************************************/
/* BuildReadRequest                                                     */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Build a Urb for a USB read request                              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Urb          - pointer to URB                                   */
/*      Buffer       - pointer to data buffer                           */
/*      Length       - length of data buffer                            */
/*      PipeHandle   - USB pipe handle                                  */
/*      Read         - transfer direction                               */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
BuildReadRequest(PURB Urb, PUCHAR Buffer, ULONG Length,
                 IN USBD_PIPE_HANDLE PipeHandle, IN BOOLEAN Read)
{
        ULONG           Size;

//        PAGED_CODE();

        DEBUG_LOG_PATH("enter BuildReadRequest");

        Size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

        // zero Urb
        RtlZeroMemory(Urb, Size);

        Urb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) Size;
        Urb->UrbBulkOrInterruptTransfer.Hdr.Function =
                                URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
        Urb->UrbBulkOrInterruptTransfer.PipeHandle = PipeHandle;
        Urb->UrbBulkOrInterruptTransfer.TransferFlags =
                                Read ? USBD_TRANSFER_DIRECTION_IN : 0;

        // we are using a tranfsfer buffer instead of an MDL
        Urb->UrbBulkOrInterruptTransfer.TransferBuffer = Buffer;
        Urb->UrbBulkOrInterruptTransfer.TransferBufferLength = Length;
        Urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;

        // short packet is not treated as an error.
        Urb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;

        // no linkage for now
        Urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

        DEBUG_LOG_PATH("exit  BuildReadRequest");

} // BuildReadRequest


/************************************************************************/
/* ClassVendorCommand                                                   */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Issue class or vendor specific command                          */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Request      - request field of class/vendor specific command   */
/*      Value        - value field of class/vendor specific command     */
/*      Index        - index field of class/vendor specific command     */
/*      Buffer       - pointer to data buffer                           */
/*      BufferLen    - data buffer length                               */
/*      Read         - data direction flag                              */
/*      Class        - True if Class Command, else vendor command       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ClassVendorCommand(IN PDEVICE_OBJECT DeviceObject, IN UCHAR Request,
                   IN USHORT Value, IN USHORT Index, IN PVOID Buffer,
                   IN OUT PULONG BufferLen, IN BOOLEAN Read, IN ULONG ComType)
{
   NTSTATUS NtStatus;
   PURB     Urb;
   ULONG    Size;
   ULONG    Length;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter VendorCommand");

   // length of buffer passed in
   Length = BufferLen ? *BufferLen : 0;

   Size = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

   // allocate memory for the Urb
   Urb = DEBUG_MEMALLOC(NonPagedPool, Size);

   if (Urb) {
      UsbBuildVendorRequest(Urb, ComType == USBSER_CLASS_COMMAND
                            ? URB_FUNCTION_CLASS_INTERFACE
                            : URB_FUNCTION_VENDOR_DEVICE, (USHORT) Size,
                            Read ? USBD_TRANSFER_DIRECTION_IN
                            : USBD_TRANSFER_DIRECTION_OUT, 0, Request, Value,
                            Index, Buffer, NULL, Length, NULL);

      NtStatus = CallUSBD(DeviceObject, Urb);

      // get length of buffer
      if (BufferLen)
         *BufferLen = Urb->UrbControlVendorClassRequest.TransferBufferLength;

      DEBUG_MEMFREE(Urb);
   } else {
      NtStatus = STATUS_INSUFFICIENT_RESOURCES;
   }


   DEBUG_LOG_PATH("exit  VendorCommand");

   return NtStatus;
} // ClassVendorCommand


/************************************************************************/
/* CancelPendingWaitMasks                                               */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Cancels any wait masks in progress.                             */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
CancelPendingWaitMasks(IN PDEVICE_EXTENSION DeviceExtension)
{
        KIRQL                                   OldIrql;
        PIRP                                    CurrentMaskIrp;

        DEBUG_LOG_PATH("enter CancelPendingWaitMasks");
        UsbSerSerialDump(USBSERTRACEOTH, (">CancelPendingWaitMasks\n"));

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

        CurrentMaskIrp = DeviceExtension->CurrentMaskIrp;

        // mark current pending wait mask as cancelled
        if(CurrentMaskIrp)
        {
                DeviceExtension->CurrentMaskIrp         = NULL;


                CurrentMaskIrp->IoStatus.Status         = STATUS_CANCELLED;
                CurrentMaskIrp->IoStatus.Information    = 0;
                IoSetCancelRoutine(CurrentMaskIrp, NULL);

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                IoCompleteRequest(CurrentMaskIrp, IO_NO_INCREMENT);
                DEBUG_TRACE1(("CancelPendingWaitMask\n"));
        } else {
           RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
        }

        DEBUG_LOG_PATH("exit  CancelPendingWaitMasks");
        UsbSerSerialDump(USBSERTRACEOTH, ("<CancelPendingWaitMasks\n"));

} // CancelPendingWaitMasks




/************************************************************************/
/* StartRead                                                            */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Kick off a read.                                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
StartRead(IN PDEVICE_EXTENSION DeviceExtension)
{
   PIRP                                    ReadIrp;
   PURB                                    ReadUrb;
   CCHAR                                   StackSize;
   ULONG                                   Size;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter StartRead");
   UsbSerSerialDump(USBSERTRACERD, (">StartRead\n"));

   // get stack size for Irp and allocate one that we will use to keep
   // read requests going
   StackSize = (CCHAR)(DeviceExtension->StackDeviceObject->StackSize + 1);

   ReadIrp = IoAllocateIrp(StackSize, FALSE);

   if (ReadIrp) {
      // get size of Urb and allocate
      Size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

      ReadUrb = DEBUG_MEMALLOC(NonPagedPool, Size);

      if (ReadUrb) {

         KeInitializeEvent(&DeviceExtension->ReadEvent, NotificationEvent,
                           FALSE);

         // save these to be freed when not needed

         UsbSerFetchPVoidLocked(&DeviceExtension->ReadIrp, ReadIrp,
                                &DeviceExtension->ControlLock);

         UsbSerFetchPVoidLocked(&DeviceExtension->ReadUrb, ReadUrb,
                                &DeviceExtension->ControlLock);

         RestartRead(DeviceExtension);
      }
   }

   UsbSerSerialDump(USBSERTRACERD, ("<StartRead\n"));
   DEBUG_LOG_PATH("exit  StartRead");
} // StartRead


/************************************************************************/
/* RestartRead                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Restart read request.                                           */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
RestartRead(IN PDEVICE_EXTENSION DeviceExtension)
{
   PIRP                 ReadIrp;
   PURB                 ReadUrb;
   PIO_STACK_LOCATION   NextStack;
   BOOLEAN              StartAnotherRead;
   KIRQL                OldIrql;
   NTSTATUS             NtStatus;

   DEBUG_LOG_PATH("enter RestartRead");
   UsbSerSerialDump(USBSERTRACERD, (">RestartRead\n"));

   do
   {
   		StartAnotherRead = FALSE;
   
   		ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   		if(!DeviceExtension->ReadInProgress && DeviceExtension->CharsInReadBuff <= LOW_WATER_MARK
       	   && DeviceExtension->AcceptingRequests) 
   		{
      		StartAnotherRead = TRUE;
      		DeviceExtension->ReadInProgress = TRUE;
	  		DeviceExtension->ReadInterlock = START_READ;
   		}

   		RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

   		if(StartAnotherRead) 
   		{
      		ReadIrp = DeviceExtension->ReadIrp;
      		ReadUrb = DeviceExtension->ReadUrb;

      		BuildReadRequest(ReadUrb, DeviceExtension->USBReadBuff,
                       	 	 USB_RX_BUFF_SIZE,
                       	 	 DeviceExtension->DataInPipe, TRUE);

      		// set Irp up for a submit Urb IOCTL
      		NextStack = IoGetNextIrpStackLocation(ReadIrp);
      		NextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
      		NextStack->Parameters.Others.Argument1 = ReadUrb;
      		NextStack->Parameters.DeviceIoControl.IoControlCode
         		= IOCTL_INTERNAL_USB_SUBMIT_URB;

      		// completion routine will take care of updating buffers and counters
      		IoSetCompletionRoutine(ReadIrp,ReadCompletion, DeviceExtension, TRUE,
                               	   TRUE, TRUE);

      		DEBUG_TRACE1(("StartRead\n"));

      		InterlockedIncrement(&DeviceExtension->PendingDataInCount);
       		UsbSerSerialDump(USBSERTRACERD, ("DataInCounty %08X @ %08X\n",
                         	 DeviceExtension->PendingDataInCount,
                         	 &DeviceExtension->PendingDataInCount));

      		NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, ReadIrp);

      		DEBUG_TRACE1(("Read Status (%08X)\n", NtStatus));

      		if(!NT_SUCCESS(NtStatus)) 
      		{
         		if(InterlockedDecrement(&DeviceExtension->PendingDataInCount) == 0) 
         		{
            		KeSetEvent(&DeviceExtension->PendingDataInEvent, IO_NO_INCREMENT,
                       	   	   FALSE);
             		UsbSerSerialDump(USBSERTRACERD, ("DataInCountz %08X @ %08X\n",
                                 	 DeviceExtension->PendingDataInCount,
                                 	 &DeviceExtension->PendingDataInCount));
         		}
      		}

      		ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      		if(DeviceExtension->ReadInterlock == IMMEDIATE_READ)
      		{
      			StartAnotherRead = TRUE;
      		}
      		else
      		{
      			StartAnotherRead = FALSE;
      		}

	  		DeviceExtension->ReadInterlock = END_READ;

      		RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      	}
   }while(StartAnotherRead)

   DEBUG_LOG_PATH("exit  RestartRead");
   UsbSerSerialDump(USBSERTRACERD, ("<RestartRead\n"));
} // RestartRead


/************************************************************************/
/* StartNotifyRead                                                      */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Kick off a notify read.                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
StartNotifyRead(IN PDEVICE_EXTENSION DeviceExtension)
{
   PIRP     NotifyIrp;
   PURB     NotifyUrb;
   CCHAR    StackSize;
   ULONG    Size;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter StartNotifyRead");
   UsbSerSerialDump(USBSERTRACERD, (">StartNotifyRead\n"));

   // get stack size for Irp and allocate one that we will use to keep
   // notification requests going
   StackSize = (CCHAR)(DeviceExtension->StackDeviceObject->StackSize + 1);

   NotifyIrp = IoAllocateIrp(StackSize, FALSE);

   if (NotifyIrp) {
      // get size of Urb and allocate
      Size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

      NotifyUrb = DEBUG_MEMALLOC(NonPagedPool, Size);

      if (NotifyUrb) {
                  // save these to be freed when not needed
         UsbSerFetchPVoidLocked(&DeviceExtension->NotifyIrp, NotifyIrp,
                                &DeviceExtension->ControlLock);
         UsbSerFetchPVoidLocked(&DeviceExtension->NotifyUrb, NotifyUrb,
                                 &DeviceExtension->ControlLock);

         RestartNotifyRead(DeviceExtension);
      }
   }

   DEBUG_LOG_PATH("exit  StartNotifyRead");
   UsbSerSerialDump(USBSERTRACERD, ("<StartNotifyRead\n"));
} // StartNotifyRead


/************************************************************************/
/* RestartNotifyRead                                                    */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Kick off a notify read.                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
RestartNotifyRead(IN PDEVICE_EXTENSION DeviceExtension)
{
   PIRP                                    NotifyIrp;
   PURB                                    NotifyUrb;
   PIO_STACK_LOCATION              NextStack;
   NTSTATUS                                NtStatus;


   DEBUG_LOG_PATH("enter RestartNotifyRead");
   UsbSerSerialDump(USBSERTRACERD, (">RestartNotifyRead\n"));

   NotifyUrb = DeviceExtension->NotifyUrb;
   NotifyIrp = DeviceExtension->NotifyIrp;

   if(DeviceExtension->AcceptingRequests) 
   {
      BuildReadRequest(NotifyUrb, DeviceExtension->NotificationBuff,
                       NOTIFICATION_BUFF_SIZE,
                       DeviceExtension->NotificationPipe, TRUE);

      // set Irp up for a submit Urb IOCTL
      NextStack = IoGetNextIrpStackLocation(NotifyIrp);
      NextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
      NextStack->Parameters.Others.Argument1 = NotifyUrb;
      NextStack->Parameters.DeviceIoControl.IoControlCode
         = IOCTL_INTERNAL_USB_SUBMIT_URB;

      // completion routine will take care of updating buffers and counters
      IoSetCompletionRoutine(NotifyIrp, NotifyCompletion, DeviceExtension,
                             TRUE, TRUE, TRUE);

      DEBUG_TRACE1(("Start NotifyRead\n"));

      InterlockedIncrement(&DeviceExtension->PendingNotifyCount);

      NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, NotifyIrp);

      if (!NT_SUCCESS(NtStatus)) 
      {
         if (InterlockedDecrement(&DeviceExtension->PendingNotifyCount) == 0) 
         {
            KeSetEvent(&DeviceExtension->PendingNotifyEvent, IO_NO_INCREMENT, FALSE);
         }
      }

      DEBUG_TRACE1(("Status (%08X)\n", NtStatus));
   }

   DEBUG_LOG_PATH("exit  RestartNotifyRead");
   UsbSerSerialDump(USBSERTRACERD, ("<RestartNotifyRead\n"));
} // RestartNotifyRead


/************************************************************************/
/* ReadCompletion                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Read completion routine.                                        */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to Irp                                   */
/*      Context      - pointer to driver defined context                */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ReadCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
   PDEVICE_EXTENSION    DeviceExtension = (PDEVICE_EXTENSION) Context;
   PURB                 Urb;
   ULONG                Count;
   KIRQL                OldIrql;
   
   DEBUG_LOG_PATH("enter ReadCompletion");

   UsbSerSerialDump(USBSERTRACERD, (">ReadCompletion(%08X)\n", Irp));

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   Urb = DeviceExtension->ReadUrb;

   Count = Urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

   if (NT_SUCCESS(Irp->IoStatus.Status)
       && (DeviceExtension->CurrentDevicePowerState == PowerDeviceD0)) 
   {

      DeviceExtension->HistoryMask |= SERIAL_EV_RXCHAR | SERIAL_EV_RX80FULL;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      //
      // Scan for RXFLAG char if needed
      //

      if(DeviceExtension->IsrWaitMask & SERIAL_EV_RXFLAG) 
      {
         ULONG i;

         for(i = 0; i < Count; i++) 
         {
            if(*((PUCHAR)(DeviceExtension->USBReadBuff + i))
                == DeviceExtension->SpecialChars.EventChar) 
            {
               DeviceExtension->HistoryMask |= SERIAL_EV_RXFLAG;
               break;
            }
         }
      }

	  PutData(DeviceExtension, Count);

      // got some data, let's see if we can satisfy any queued reads
      CheckForQueuedReads(DeviceExtension);

      DEBUG_TRACE1(("ReadCompletion (%08X)\n", DeviceExtension->CharsInReadBuff));

      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      DeviceExtension->ReadInProgress = FALSE;

      if(DeviceExtension->ReadInterlock == END_READ)
      {

		 DeviceExtension->ReadInterlock = IMMEDIATE_READ;
         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
		 RestartRead(DeviceExtension);
      }
      else
      {
		 DeviceExtension->ReadInterlock = IMMEDIATE_READ;
         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
      }

   }
   else 
   {
      //
      // the device is not accepting requests, so signal anyone who
      // cancelled this or is waiting for it to stop
      //
	  DeviceExtension->ReadInterlock = IMMEDIATE_READ;

      DeviceExtension->ReadInProgress = FALSE;

      DeviceExtension->AcceptingRequests = FALSE;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
      KeSetEvent(&DeviceExtension->ReadEvent, 1, FALSE);

      DEBUG_TRACE1(("RC Irp Status (%08X)\n", Irp->IoStatus.Status));
   }


   //
   // Notify everyone if this is the last IRP
   //

   if (InterlockedDecrement(&DeviceExtension->PendingDataInCount) == 0) 
   {
   
      UsbSerSerialDump(USBSERTRACEOTH, ("DataIn pipe is empty\n"));
      KeSetEvent(&DeviceExtension->PendingDataInEvent, IO_NO_INCREMENT, FALSE);
   }

   UsbSerSerialDump(USBSERTRACERD, ("DataInCount %08X @ %08X\n",
                                    DeviceExtension->PendingDataInCount,
                                    &DeviceExtension->PendingDataInCount));


   DEBUG_LOG_PATH("exit  ReadCompletion");
   UsbSerSerialDump(USBSERTRACERD, ("<ReadCompletion\n"));

   return STATUS_MORE_PROCESSING_REQUIRED;
} // ReadCompletion


/************************************************************************/
/* GetData                                                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Get data from circular buffer.                                  */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to device extension                   */
/*      Buffer          - pointer to buffer                             */
/*      BufferLen       - size of buffer                                */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      ULONG                                                           */
/*                                                                      */
/************************************************************************/
ULONG
GetData(IN PDEVICE_EXTENSION DeviceExtension, IN PCHAR Buffer,
        IN ULONG BufferLen, IN OUT PULONG_PTR NewCount)
{
   ULONG count;
   KIRQL OldIrql;

   DEBUG_LOG_PATH("enter GetData");

   UsbSerSerialDump(USBSERTRACERD, (">GetData\n"));

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   BufferLen = min(DeviceExtension->CharsInReadBuff, BufferLen);

   if(BufferLen) 
   {

	  count = min(BufferLen, (DeviceExtension->RxMaxPacketSize - DeviceExtension->CurrentReadBuffPtr));

      memcpy(Buffer,
             &DeviceExtension->ReadBuff[DeviceExtension->CurrentReadBuffPtr],
             count);

	  Buffer 								+= count;
      DeviceExtension->CurrentReadBuffPtr 	+= count;
      DeviceExtension->CharsInReadBuff 		-= count;
      DeviceExtension->NumberNeededForRead 	-= count;
      BufferLen								-= count;
      *NewCount += count;

      // if there is still something left in the buffer, then we wrapped
      if(BufferLen)
      {
      		memcpy(Buffer, DeviceExtension->ReadBuff, BufferLen);
        	DeviceExtension->CurrentReadBuffPtr 	= BufferLen;
        	DeviceExtension->CharsInReadBuff 		-= BufferLen;
        	DeviceExtension->NumberNeededForRead 	-= BufferLen;
        	*NewCount 								+= BufferLen;
      }
		
   }

   DEBUG_TRACE2(("Count (%08X)  CharsInReadBuff (%08X)\n", count, DeviceExtension->CharsInReadBuff));

#if DBG
   if (UsbSerSerialDebugLevel & USBSERDUMPRD) {
      ULONG i;

      DbgPrint("RD: ");

      for (i = 0; i < count; i++) {
         DbgPrint("%02x ", Buffer[i] & 0xFF);
      }

      DbgPrint("\n\n");
   }
#endif

   RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

   RestartRead(DeviceExtension);

   DEBUG_LOG_PATH("exit  GetData");
   UsbSerSerialDump(USBSERTRACERD, ("<GetData\n"));

   return count;
} // GetData

/************************************************************************/
/* PutData                                                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Put data in circular buffer.                                    */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to device extension                   */
/*      BufferLen       - size of buffer                                */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
PutData(IN PDEVICE_EXTENSION DeviceExtension, IN ULONG BufferLen)
{
   KIRQL OldIrql;
   ULONG count;
   ULONG BuffPtr;

   if(BufferLen)
   {
       ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

	   // get current pointer into circular buffer
	   BuffPtr = (DeviceExtension->CharsInReadBuff +  DeviceExtension->CurrentReadBuffPtr) % 
	   			  DeviceExtension->RxMaxPacketSize;

	   // figure out amount to copy into read buffer, in case we would right past end of buffer
	   count = min(BufferLen, (DeviceExtension->RxMaxPacketSize - BuffPtr));

	   memcpy(&DeviceExtension->ReadBuff[BuffPtr], 
	          DeviceExtension->USBReadBuff, count);

	   // update counters 
	   BufferLen 							-= count;
	   DeviceExtension->CharsInReadBuff     += count;
	   DeviceExtension->ReadByIsr 			+= count;
   

	   // if there is still something left in the buffer, then we wrapped
	   if(BufferLen)
	   {
	        // count still holds the amount copied from buffer on first copy
	        // and BufferLen holds the amount remaining to copy
	   		memcpy(DeviceExtension->ReadBuff, 
	          	   &DeviceExtension->USBReadBuff[count], BufferLen);
          	   
	   		DeviceExtension->CharsInReadBuff	+= BufferLen;
	   		DeviceExtension->ReadByIsr 			+= BufferLen;
	   }

       RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
	}
} // PutData



VOID
UsbSerRundownIrpRefs(IN PIRP *PpCurrentOpIrp, IN PKTIMER IntervalTimer OPTIONAL,
                     IN PKTIMER TotalTimer OPTIONAL,
                     IN PDEVICE_EXTENSION PDevExt)

/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the cancel
          spin lock held.

Arguments:

    PpCurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

    PDevExt - Pointer to device extension

Return Value:

    None.

--*/


{
//   PAGED_CODE();

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerRundownIrpRefs(%08X)\n",
                                     *PpCurrentOpIrp));

    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //

    if ((*PpCurrentOpIrp)->CancelRoutine) {

        USBSER_CLEAR_REFERENCE(*PpCurrentOpIrp, USBSER_REF_CANCEL);

        IoSetCancelRoutine(*PpCurrentOpIrp, NULL);

    }

    if (IntervalTimer) {

        //
        // Try to cancel the operations interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if (KeCancelTimer(IntervalTimer)) {
            USBSER_CLEAR_REFERENCE(*PpCurrentOpIrp, USBSER_REF_INT_TIMER);
        }
    }

    if (TotalTimer) {

        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //        //
        // If we have an escape char event pending, we can't overstuff,
        // so subtract one from the length
        //


        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if (KeCancelTimer(TotalTimer)) {
            USBSER_CLEAR_REFERENCE(*PpCurrentOpIrp, USBSER_REF_TOTAL_TIMER);
        }
    }

//    USBSER_CLEAR_REFERENCE(*PpCurrentOpIrp, USBSER_REF_RXBUFFER);

    UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerRundownIrpRefs\n"));
}


VOID
UsbSerTryToCompleteCurrent(IN PDEVICE_EXTENSION PDevExt,
                           IN KIRQL IrqlForRelease, IN NTSTATUS StatusToUse,
                           IN PIRP *PpCurrentOpIrp,
                           IN PLIST_ENTRY PQueue OPTIONAL,
                           IN PKTIMER PIntervalTimer OPTIONAL,
                           IN PKTIMER PTotalTimer OPTIONAL,
                           IN PUSBSER_START_ROUTINE Starter OPTIONAL,
                           IN PUSBSER_GET_NEXT_ROUTINE PGetNextIrp OPTIONAL,
                           IN LONG RefType,
                           IN BOOLEAN Complete)

/*++

Routine Description:

    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Extension - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.

    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{
   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD | USBSERTRACEWR,
                    (">UsbSerTryToCompleteCurrent(%08X)\n", *PpCurrentOpIrp));
    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //

    USBSER_CLEAR_REFERENCE(*PpCurrentOpIrp, RefType);

    //
    // Try to run down all other references to this irp.
    //

    UsbSerRundownIrpRefs(PpCurrentOpIrp, PIntervalTimer, PTotalTimer, PDevExt);

    //
    // See if the ref count is zero after trying to kill everybody else.
    //

    if (!USBSER_REFERENCE_COUNT(*PpCurrentOpIrp)) {

        PIRP pNewIrp;


        //
        // The ref count was zero so we should complete this
        // request.
        //
        // The following call will also cause the current irp to be
        // completed.
        //

        (*PpCurrentOpIrp)->IoStatus.Status = StatusToUse;

        if (StatusToUse == STATUS_CANCELLED) {

            (*PpCurrentOpIrp)->IoStatus.Information = 0;

        }

        if (PGetNextIrp) {

            RELEASE_CANCEL_SPINLOCK(PDevExt, IrqlForRelease);

            (*PGetNextIrp)(PpCurrentOpIrp, PQueue, &pNewIrp, Complete, PDevExt);


            if (pNewIrp) {

                Starter(PDevExt);
            }

        } else {

            PIRP pOldIrp = *PpCurrentOpIrp;

            //
            // There was no get next routine.  We will simply complete
            // the irp.  We should make sure that we null out the
            // pointer to the pointer to this irp.
            //

            *PpCurrentOpIrp = NULL;

            RELEASE_CANCEL_SPINLOCK(PDevExt, IrqlForRelease);

            if (Complete) {
               IoCompleteRequest(pOldIrp, IO_SERIAL_INCREMENT);
            }

        }

    } else {

        RELEASE_CANCEL_SPINLOCK(PDevExt, IrqlForRelease);

        UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD | USBSERTRACEWR,
            ("Current IRP still has reference of %08X\n",
            ((UINT_PTR)((IoGetCurrentIrpStackLocation((*PpCurrentOpIrp))->
                         Parameters.Others.Argument4)))));
    }

    UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD | USBSERTRACEWR,
                     ("<UsbSerTryToCompleteCurrent\n"));
}


/************************************************************************/
/* CheckForQueuedReads                                                  */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      See if we have any queued reads that we can satisfy.            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
CheckForQueuedReads(IN PDEVICE_EXTENSION DeviceExtension)
{
   ULONG charsRead = 0;
   PULONG pWaitMask;
   KIRQL  oldIrql;

   //
   // May be paged if we do counter
   //

   DEBUG_LOG_PATH("enter CheckForQueuedReads");
   UsbSerSerialDump(USBSERTRACERD, (">CheckForQueuedReads\n"));

   ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &oldIrql);

   if ((DeviceExtension->CurrentReadIrp != NULL)
       && (USBSER_REFERENCE_COUNT(DeviceExtension->CurrentReadIrp)
           & USBSER_REF_RXBUFFER))
   {
           
      RELEASE_CANCEL_SPINLOCK(DeviceExtension, oldIrql);

      DEBUG_TRACE3(("Reading 0x%x\n", DeviceExtension->NumberNeededForRead));

      charsRead
         = GetData(DeviceExtension,
                              ((PUCHAR)(DeviceExtension->CurrentReadIrp
                                        ->AssociatedIrp.SystemBuffer))
                              + (IoGetCurrentIrpStackLocation(DeviceExtension
                                                              ->CurrentReadIrp))
                              ->Parameters.Read.Length
                              - DeviceExtension->NumberNeededForRead,
                              DeviceExtension->NumberNeededForRead,
                   &DeviceExtension->CurrentReadIrp->IoStatus.Information);

      ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &oldIrql);

      //
      // See if this read is complete
      //

      if (DeviceExtension->NumberNeededForRead == 0) {
         DEBUG_TRACE3(("USBSER: Completing read\n"));

         if(DeviceExtension->CurrentReadIrp)
         {
            DeviceExtension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
         }

         //
         // Mark the read as completed and try to service the next one
         //


         DeviceExtension->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

#if DBG
   if (UsbSerSerialDebugLevel & USBSERDUMPRD) {
      ULONG i;
      ULONG count;

      if (DeviceExtension->CurrentReadIrp->IoStatus.Status == STATUS_SUCCESS) {
         count = (ULONG)DeviceExtension->CurrentReadIrp->IoStatus.Information;
      } else {
         count = 0;

      }
      DbgPrint("RD2: A(%08X) G(%08X) I(%08X)\n",
               IoGetCurrentIrpStackLocation(DeviceExtension->CurrentReadIrp)
               ->Parameters.Read.Length, count, DeviceExtension->CurrentReadIrp);

      for (i = 0; i < count; i++) {
         DbgPrint("%02x ", *(((PUCHAR)DeviceExtension->CurrentReadIrp
                              ->AssociatedIrp.SystemBuffer) + i) & 0xFF);
      }

      if (i == 0) {
         DbgPrint("NULL (%08X)\n", DeviceExtension->CurrentReadIrp
                  ->IoStatus.Status);
      }

      DbgPrint("\n\n");
   }
#endif

      
         UsbSerTryToCompleteCurrent(DeviceExtension, oldIrql, STATUS_SUCCESS,
                                    &DeviceExtension->CurrentReadIrp,
                                    &DeviceExtension->ReadQueue,
                                    &DeviceExtension->ReadRequestIntervalTimer,
                                    &DeviceExtension->ReadRequestTotalTimer,
                                    UsbSerStartRead, UsbSerGetNextIrp,
                                    USBSER_REF_RXBUFFER,
                                    TRUE);
                                    
         ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &oldIrql);
      }
   } 

   if (DeviceExtension->IsrWaitMask & SERIAL_EV_RXCHAR) {
      DeviceExtension->HistoryMask |= SERIAL_EV_RXCHAR;
   }

   if (DeviceExtension->CurrentMaskIrp != NULL) {
      pWaitMask = (PULONG)DeviceExtension->CurrentMaskIrp->
         AssociatedIrp.SystemBuffer;

      //
      // Process events
      //

      if (DeviceExtension->IsrWaitMask & DeviceExtension->HistoryMask) {
         PIRP pMaskIrp;

         DEBUG_TRACE3(("Completing events\n"));

         *pWaitMask = DeviceExtension->HistoryMask;
         DeviceExtension->HistoryMask = 0;
         pMaskIrp = DeviceExtension->CurrentMaskIrp;

         pMaskIrp->IoStatus.Information = sizeof(ULONG);
         pMaskIrp->IoStatus.Status = STATUS_SUCCESS;
         DeviceExtension->CurrentMaskIrp = NULL;
         IoSetCancelRoutine(pMaskIrp, NULL);

         RELEASE_CANCEL_SPINLOCK(DeviceExtension, oldIrql);


         IoCompleteRequest(pMaskIrp, IO_SERIAL_INCREMENT);

      }
      else
      {
         RELEASE_CANCEL_SPINLOCK(DeviceExtension, oldIrql);
      }
   }
   else
   {
      RELEASE_CANCEL_SPINLOCK(DeviceExtension, oldIrql);
   }
   

   DEBUG_LOG_PATH("exit  CheckForQueuedReads");

   UsbSerSerialDump(USBSERTRACERD, ("<CheckForQueuedReads\n"));
} // CheckForQueuedReads


VOID
UsbSerGetNextIrp(IN PIRP *PpCurrentOpIrp, IN PLIST_ENTRY PQueueToProcess,
                 OUT PIRP *PpNextIrp, IN BOOLEAN CompleteCurrent,
                 IN PDEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This function gets the next IRP off a queue, marks it as current,
    and possibly completes the current IRP.

Arguments:

    PpCurrentOpIrp    - A pointer to the pointer to the current IRP.
    PQueueToProcess  - A pointer to the queue to get the next IRP from.
    PpNextIrp         - A pointer to the pointer to the next IRP to process.
    CompleteCurrent  - TRUE if we should complete the IRP that is current at
                       the time we are called.
    PDevExt          - A pointer to the device extension.

Return Value:

    NTSTATUS

--*/
{
   KIRQL oldIrql;
   PIRP pOldIrp;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("Enter UsbSerGetNextIrp");
   UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD | USBSERTRACEWR,
                    (">UsbSerGetNextIrp(%08)\n", *PpCurrentOpIrp));

   ACQUIRE_CANCEL_SPINLOCK(PDevExt, &oldIrql);

   pOldIrp = *PpCurrentOpIrp;

#if DBG
   if (pOldIrp != NULL) {
      if (CompleteCurrent) {
         ASSERT(pOldIrp->CancelRoutine == NULL);
      }
   }
#endif

   //
   // Check to see if there is a new irp to start up
   //

   if (!IsListEmpty(PQueueToProcess)) {
      PLIST_ENTRY pHeadOfList;

      pHeadOfList = RemoveHeadList(PQueueToProcess);

      *PpCurrentOpIrp = CONTAINING_RECORD(pHeadOfList, IRP,
                                         Tail.Overlay.ListEntry);

      IoSetCancelRoutine(*PpCurrentOpIrp, NULL);
   } else {
      *PpCurrentOpIrp = NULL;
   }

   *PpNextIrp = *PpCurrentOpIrp;

   RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

   //
   // Complete the current one if so requested
   //

   if (CompleteCurrent) {
      if (pOldIrp != NULL) {
         IoCompleteRequest(pOldIrp, IO_SERIAL_INCREMENT);
      }
   }

   DEBUG_LOG_PATH("Exit UsbSerGetNextIrp");
   UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD | USBSERTRACEWR,
                    ("<UsbSerGetNextIrp\n"));
}


NTSTATUS
UsbSerStartOrQueue(IN PDEVICE_EXTENSION PDevExt, IN PIRP PIrp,
                   IN PLIST_ENTRY PQueue, IN PIRP *PPCurrentIrp,
                   IN PUSBSER_START_ROUTINE Starter)
/*++

Routine Description:

    This function is used to either start processing an I/O request or to
    queue it on the appropriate queue if a request is already pending or
    requests may not be started.

Arguments:

    PDevExt       - A pointer to the DeviceExtension.
    PIrp          - A pointer to the IRP that is being started or queued.
    PQueue        - A pointer to the queue to place the IRP on if necessary.
    PPCurrentIrp  - A pointer to the pointer to the currently active I/O IRP.
    Starter       - Function to call if we decide to start this IRP.


Return Value:

    NTSTATUS

--*/
{
   KIRQL oldIrql;
   NTSTATUS status;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("Enter UsbSerStartOrQueue");

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerStartOrQueue(%08X)\n", PIrp));

   ACQUIRE_CANCEL_SPINLOCK(PDevExt, &oldIrql);

   if (IsListEmpty(PQueue) && (*PPCurrentIrp == NULL)) {
      //
      // Nothing pending -- start the new irp
      //

      *PPCurrentIrp = PIrp;
      RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

      status = Starter(PDevExt);

      DEBUG_LOG_PATH("Exit UsbSerStartOrQueue(1)");
      UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerStartOrQueue(1) %08X\n",
                                        status));
      return status;
   }

   //
   // We're queueing the irp, so we need a cancel routine -- make sure
   // the irp hasn't already been cancelled.
   //

   if (PIrp->Cancel) {
      //
      // The IRP was apparently cancelled.  Complete it.
      //

      RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

      PIrp->IoStatus.Status = STATUS_CANCELLED;

      IoCompleteRequest(PIrp, IO_NO_INCREMENT);

      DEBUG_LOG_PATH("Exit UsbSerStartOrQueue(2)");
      UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerStartOrQueue(2) %08X\n",
                                        STATUS_CANCELLED));
      return STATUS_CANCELLED;
   }

   //
   // Mark as pending, attach our cancel routine
   //

   PIrp->IoStatus.Status = STATUS_PENDING;
   IoMarkIrpPending(PIrp);

   InsertTailList(PQueue, &PIrp->Tail.Overlay.ListEntry);
   IoSetCancelRoutine(PIrp, UsbSerCancelQueued);

   RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

   DEBUG_LOG_PATH("Exit UsbSerStartOrQueue(3)");
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerStartOrQueue(3) %08X\n",
                                     STATUS_PENDING));
   return STATUS_PENDING;
}


VOID
UsbSerCancelQueued(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This function is used as a cancel routine for queued irps.  Basically
    for us this means read IRPs.

Arguments:

    PDevObj - A pointer to the serial device object.

    PIrp    - A pointer to the IRP that is being cancelled

Return Value:

    VOID

--*/
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("Enter UsbSerCancelQueued");

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerCancelQueued(%08X)\n", PIrp));

   //
   // The irp was cancelled -- remove it from the queue
   //

   PIrp->IoStatus.Status = STATUS_CANCELLED;
   PIrp->IoStatus.Information = 0;

   RemoveEntryList(&PIrp->Tail.Overlay.ListEntry);

   RELEASE_CANCEL_SPINLOCK(pDevExt, PIrp->CancelIrql);

   IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

   DEBUG_LOG_PATH("Exit UsbSerCancelQueued");
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerCancelQueued\n"));
}


VOID
UsbSerKillAllReadsOrWrites(IN PDEVICE_OBJECT PDevObj,
                           IN PLIST_ENTRY PQueueToClean,
                           IN PIRP *PpCurrentOpIrp)

/*++

Routine Description:

    This function is used to cancel all queued and the current irps
    for reads or for writes.

Arguments:

    PDevObj - A pointer to the serial device object.

    PQueueToClean - A pointer to the queue which we're going to clean out.

    PpCurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{

    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

    USBSER_ALWAYS_LOCKED_CODE();

    UsbSerSerialDump(USBSERTRACERD | USBSERTRACEWR,
                     (">UsbSerKillAllReadsOrWrites(%08X)\n", *PpCurrentOpIrp));
    //
    // We acquire the cancel spin lock.  This will prevent the
    // irps from moving around.
    //

    ACQUIRE_CANCEL_SPINLOCK(pDevExt, &cancelIrql);

    //
    // Clean the list from back to front.
    //

    while (!IsListEmpty(PQueueToClean)) {

        PIRP pCurrentLastIrp = CONTAINING_RECORD(PQueueToClean->Blink, IRP,
                                                 Tail.Overlay.ListEntry);

        RemoveEntryList(PQueueToClean->Blink);

        cancelRoutine = pCurrentLastIrp->CancelRoutine;
        pCurrentLastIrp->CancelIrql = cancelIrql;
        pCurrentLastIrp->CancelRoutine = NULL;
        pCurrentLastIrp->Cancel = TRUE;

        cancelRoutine(PDevObj, pCurrentLastIrp);

        ACQUIRE_CANCEL_SPINLOCK(pDevExt, &cancelIrql);

    }

    //
    // The queue is clean.  Now go after the current if
    // it's there.
    //

    if (*PpCurrentOpIrp) {


        cancelRoutine = (*PpCurrentOpIrp)->CancelRoutine;
        (*PpCurrentOpIrp)->Cancel = TRUE;

        //
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.
        //

        if (cancelRoutine) {

            (*PpCurrentOpIrp)->CancelRoutine = NULL;
            (*PpCurrentOpIrp)->CancelIrql = cancelIrql;

            //
            // This irp is already in a cancelable state.  We simply
            // mark it as canceled and call the cancel routine for
            // it.
            //

            cancelRoutine(PDevObj, *PpCurrentOpIrp);

        } else {

            RELEASE_CANCEL_SPINLOCK(pDevExt, cancelIrql);

        }

    } else {

        RELEASE_CANCEL_SPINLOCK(pDevExt, cancelIrql);

    }

    UsbSerSerialDump(USBSERTRACERD | USBSERTRACEWR,
                     ("<UsbSerKillAllReadsOrWrites\n"));
}


VOID
UsbSerKillPendingIrps(PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

   Kill all IRPs queued in our driver

Arguments:

   PDevObj - a pointer to the device object

Return Value:

    VOID

--*/
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   KIRQL cancelIrql;

   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerKillPendingIrps\n"));

   //
   // Kill all reads; we do not queue writes
   //

   UsbSerKillAllReadsOrWrites(PDevObj, &pDevExt->ReadQueue,
                              &pDevExt->CurrentReadIrp);

   //
   // Get rid of any pending waitmasks
   //

   ACQUIRE_CANCEL_SPINLOCK(pDevExt, &cancelIrql);

   if (pDevExt->CurrentMaskIrp != NULL) {
      PDRIVER_CANCEL cancelRoutine;

      cancelRoutine = pDevExt->CurrentMaskIrp->CancelRoutine;
      pDevExt->CurrentMaskIrp->Cancel = TRUE;

      ASSERT(cancelRoutine);

      if (cancelRoutine) {
         pDevExt->CurrentMaskIrp->CancelRoutine = NULL;
         pDevExt->CurrentMaskIrp->CancelIrql = cancelIrql;

         cancelRoutine(PDevObj, pDevExt->CurrentMaskIrp);
      } else {
         RELEASE_CANCEL_SPINLOCK(pDevExt, cancelIrql);
      }

   }else {
         RELEASE_CANCEL_SPINLOCK(pDevExt, cancelIrql);
   }

   //
   // Cancel any pending wait-wake irps
   //

   if (pDevExt->PendingWakeIrp != NULL) {
      IoCancelIrp(pDevExt->PendingWakeIrp);
      pDevExt->PendingWakeIrp = NULL;
   }


   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerKillPendingIrps\n"));
}


/************************************************************************/
/* CompletePendingWaitMasks                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Completes any wait masks in progress with no events set.        */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
UsbSerCompletePendingWaitMasks(IN PDEVICE_EXTENSION DeviceExtension)
{
   KIRQL OldIrql;
   PIRP CurrentMaskIrp;
   KIRQL cancelIrql;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter CompletePendingWaitMasks");

   UsbSerSerialDump(USBSERTRACEOTH, (">CompletePendingWaitMasks\n"));

   ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &cancelIrql);
   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   CurrentMaskIrp = DeviceExtension->CurrentMaskIrp;

   if (CurrentMaskIrp) {

      CurrentMaskIrp->IoStatus.Status         = STATUS_SUCCESS;
      CurrentMaskIrp->IoStatus.Information    = sizeof(ULONG);
      *((PULONG)CurrentMaskIrp->AssociatedIrp.SystemBuffer) = 0;

      DeviceExtension->CurrentMaskIrp         = NULL;

      IoSetCancelRoutine(CurrentMaskIrp, NULL);

   }

   // complete the queued IRP if needed
   if (CurrentMaskIrp) {
      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
      RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);

      IoCompleteRequest(CurrentMaskIrp, IO_NO_INCREMENT);
      DEBUG_TRACE1(("CompletePendingWaitMask\n"));
   }
   else
   {
      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
      RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);
   }

   DEBUG_LOG_PATH("exit  CompletePendingWaitMasks");
   UsbSerSerialDump(USBSERTRACEOTH, ("<CompletePendingWaitMasks\n"));
} // CancelPendingWaitMasks


VOID
UsbSerRestoreModemSettings(PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

   Restores the modem's settings upon a powerup.

Arguments:

   PDevExt - a pointer to the device extension

Return Value:

    VOID

--*/
{
   PAGED_CODE();

   (void)SetLineControlAndBaud(PDevObj);
}


VOID
UsbSerProcessEmptyTransmit(IN PDEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This function is called whenever our tx queue is empty in order
    to set the proper events, etc.

Arguments:

    PDevExt - Pointer to DeviceExtension for the device

Return Value:

    VOID

--*/
{
   KIRQL oldIrql;
   PULONG pWaitMask;

   USBSER_ALWAYS_LOCKED_CODE();

   //
   // Set the event if needed
   //

   PDevExt->HistoryMask |= SERIAL_EV_TXEMPTY;

   if (PDevExt->IsrWaitMask & SERIAL_EV_TXEMPTY) {
      PIRP pMaskIrp;

      DEBUG_TRACE3(("Completing events\n"));

      ACQUIRE_CANCEL_SPINLOCK(PDevExt, &oldIrql);

      if (PDevExt->CurrentMaskIrp != NULL) {
         pWaitMask = (PULONG)PDevExt->CurrentMaskIrp->
                     AssociatedIrp.SystemBuffer;

         *pWaitMask = PDevExt->HistoryMask;
         PDevExt->HistoryMask = 0;
         pMaskIrp = PDevExt->CurrentMaskIrp;

         pMaskIrp->IoStatus.Information = sizeof(ULONG);
         pMaskIrp->IoStatus.Status = STATUS_SUCCESS;
         PDevExt->CurrentMaskIrp = NULL;

         IoSetCancelRoutine(pMaskIrp, NULL);

         RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

         IoCompleteRequest(pMaskIrp, IO_SERIAL_INCREMENT);
      } else {
         RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);
      }

   }
}


VOID
UsbSerCancelWaitOnMask(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This function is used as a cancel routine for WaitOnMask IRPs.

Arguments:

    PDevObj - Pointer to Device Object
    PIrp    - Pointer to IRP that is being canceled; must be the same as
              the current mask IRP.

Return Value:

    VOID

--*/
{
   PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;

   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerCancelWaitOnMask(%08X)\n", PIrp));

   ASSERT(pDevExt->CurrentMaskIrp == PIrp);

   PIrp->IoStatus.Status = STATUS_CANCELLED;
   PIrp->IoStatus.Information = 0;

   pDevExt->CurrentMaskIrp = NULL;
   RELEASE_CANCEL_SPINLOCK(pDevExt, PIrp->CancelIrql);
   IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerCancelWaitOnMask(%08X)"));
}


NTSTATUS
UsbSerSyncCompletion(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN PKEVENT PUsbSerSyncEvent)
/*++

Routine Description:

    This function is used to signal an event.  It is used as a completion
    routine.

Arguments:

    PDevObj - Pointer to Device Object
    PIrp - Pointer to IRP that is being completed
    PUsbSerSyncEvent - Pointer to event that we should set

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
   KeSetEvent(PUsbSerSyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}


#if DBG
PVOID
UsbSerLockPagableCodeSection(PVOID SecFunc)
/*++

Routine Description:

    This function is used to lockdown code pages and increment a lock counter
    for debugging.

Arguments:

    SecFunc - Function in code section to be locked down.

Return Value:

    PVOID - Handle for locked down section.

--*/
{  PVOID handle;

   PAGED_CODE();

   handle = MmLockPagableCodeSection(SecFunc);

   // can this be paged?
   InterlockedIncrement(&PAGEUSBSER_Count);

   return handle;
}
#endif




VOID
UsbSerFetchBooleanLocked(PBOOLEAN PDest, BOOLEAN Src, PKSPIN_LOCK PSpinLock)
/*++

Routine Description:

    This function is used to assign a BOOLEAN value with spinlock protection.

Arguments:

    PDest - A pointer to Lval.

    Src - Rval.

    PSpinLock - Pointer to the spin lock we should hold.

Return Value:

    None.

--*/
{
  KIRQL tmpIrql;

  KeAcquireSpinLock(PSpinLock, &tmpIrql);
  *PDest = Src;
  KeReleaseSpinLock(PSpinLock, tmpIrql);
}


VOID
UsbSerFetchPVoidLocked(PVOID *PDest, PVOID Src, PKSPIN_LOCK PSpinLock)
/*++

Routine Description:

    This function is used to assign a PVOID value with spinlock protection.

Arguments:

    PDest - A pointer to Lval.

    Src - Rval.

    PSpinLock - Pointer to the spin lock we should hold.

Return Value:

    None.

--*/
{
  KIRQL tmpIrql;

  KeAcquireSpinLock(PSpinLock, &tmpIrql);
  *PDest = Src;
  KeReleaseSpinLock(PSpinLock, tmpIrql);
}

/*++

Routine Description:

    Work item to kick off another notify read

Arguments:

    DeviceObject - pointer to the device object

    DeviceExtension - context for this call

Return Value:

    None.

--*/

VOID
USBSER_RestartNotifyReadWorkItem(IN PDEVICE_OBJECT DeviceObject, IN PDEVICE_EXTENSION DeviceExtension)
{
    KIRQL 			oldIrql;
    PIO_WORKITEM 	ioWorkItem;

    ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &oldIrql);

	ioWorkItem = DeviceExtension->IoWorkItem;

	DeviceExtension->IoWorkItem = NULL;

    RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, oldIrql);

    IoFreeWorkItem(ioWorkItem);

	RestartNotifyRead(DeviceExtension);
} // USBER_RestartNotifyReadWorkItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\dll\service.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    service.c

Abstract: USB Test DLL

Author:

    Chris Robinson

ynvironment:

    Kernel mode

Revision History:

--*/

#include <windows.h>
#include <cfgmgr32.h>
#include <usbioctl.h>
#include "usbtest.h"
#include "local.h"

#define WIN9X_NTKERN_NAME   "\\\\.\\ntkern"
#define FULL_DRIVER_NAME_LENGTH 1024

//
// Structure used to interface between App and VxD for Win9x.  This was
//  pulled from dos\dos386\ntkern\vxd\dioc.h in the Win9x tree.
//

#define INTERFACE_BUF_SIZE 1024

#include <pshpack1.h>

typedef struct tag_DIOC_Interface 
{
    DWORD dwReturn;
    DWORD dwEAX;
    DWORD dwEBX;
    DWORD dwECX;
    DWORD dwEDX;
    DWORD dwESI;
    DWORD dwEDI;
    DWORD dwCF;
    WORD  wDS;
    WORD  wBufSize;                  
    char  szBuf[INTERFACE_BUF_SIZE];

} DIOC_VXD_INTERFACE , *PDIOC_VXD_INTERFACE ;

#include <poppack.h>


//*****************************************************************************
//
// OpenWin2kService
//
//*****************************************************************************

SC_HANDLE
OpenWin2kService(
    IN  PSTR    ServiceName,
    IN  PSTR    ServiceDescription,
    IN  PSTR    DriverPath,
    IN  BOOL    CreateIfNonExistant
)
{
    SC_HANDLE   scManagerHandle;
    SC_HANDLE   scServiceHandle;
    DWORD       errorCode;

    //
    // Initialize the variables for proper cleanup on exit
    //

    scServiceHandle = NULL;

    //
    // Try to get a handle to the service manager
    //

    scManagerHandle = OpenSCManager(NULL, 
                                    NULL, 
                                    SC_MANAGER_ALL_ACCESS);

    if (NULL == scManagerHandle)
    {
        errorCode = GetLastError();

        goto OpenWin2kService_Exit;
    }

    //
    // Get a handle to the service itself.  We want EXECUTE access so that
    //  it can be started.
    //

    scServiceHandle = OpenService(scManagerHandle,
                                  ServiceName,
                                  GENERIC_EXECUTE);

    
    if (NULL == scServiceHandle)
    {   
        errorCode = GetLastError();

        if (ERROR_SERVICE_DOES_NOT_EXIST == errorCode && CreateIfNonExistant)
        {
            scServiceHandle = CreateWin2kService(scManagerHandle,
                                                 ServiceName,
                                                 ServiceDescription,
                                                 DriverPath);
        }
    }

    CloseServiceHandle(scManagerHandle);

OpenWin2kService_Exit:

    SetLastError(errorCode);

    return (scServiceHandle);
}

//*****************************************************************************
//
// CreateWin2kService
//
//*****************************************************************************

SC_HANDLE
CreateWin2kService(
    IN  SC_HANDLE   scManagerHandle,
    IN  PSTR        ServiceName,
    IN  PSTR        ServiceDescription,
    IN  PSTR        DriverPath
)
{
    SC_HANDLE   scServiceHandle;

    //
    // Initialize the variables for proper cleanup on exit
    //

    scServiceHandle = NULL;

    //
    // Check the handle to the service manager
    //

    if (NULL == scManagerHandle)
    {
        goto CreateWin2kService_Exit;
    }

    //
    // Create the service...In the process, this will return a handle that
    //  can be used just as if an OpenService() had been performed.
    //

    scServiceHandle = CreateService(scManagerHandle,
                                    ServiceName,
                                    ServiceDescription,
                                    GENERIC_EXECUTE,
                                    SERVICE_KERNEL_DRIVER,
                                    SERVICE_DEMAND_START,
                                    SERVICE_ERROR_IGNORE,
                                    DriverPath,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);

CreateWin2kService_Exit:

    return (scServiceHandle);
}


//*****************************************************************************
//
// IsWindows9x
//
//*****************************************************************************

BOOLEAN
IsWindows9x(
    VOID
)
{
    OSVERSIONINFO   osVersion;

    //
    // Get the OS version information
    //

    osVersion.dwOSVersionInfoSize = sizeof(osVersion);

    GetVersionEx(&osVersion);

    //
    // For the version to be Windows98 or later:
    //  1) dwPlatformId = VER_PLATFORM_WIN32_WINDOWS
    //  2) dwMajorVersion > 4
    //      or
    //  3) dwMajorVersion = 4 and dwMinorVersion > 0
    //

    return (VER_PLATFORM_WIN32_WINDOWS == osVersion.dwPlatformId &&
            ((4 > osVersion.dwMajorVersion) || 
             (4 == osVersion.dwMajorVersion) && (0 < osVersion.dwMinorVersion)));
}

//*****************************************************************************
//
// LoadWin9xWdmDriver
//
//*****************************************************************************

BOOLEAN
LoadWin9xWdmDriver(
    IN  PSTR    DriverPath
)
/*++

Routine Description:

  LoadWin9xWdmDriver
   
Arguments:
  

Return Value:

--*/
{
    BOOL                bReturn    = TRUE;
    HANDLE              vxdHandle  = INVALID_HANDLE_VALUE;
    DWORD               nBytes     = 0;
    DIOC_VXD_INTERFACE  vxdDataIn  = {0};
    DIOC_VXD_INTERFACE  vxdDataOut = {0};
    CHAR                fullDriverName[FULL_DRIVER_NAME_LENGTH];

    OutputDebugString("Entering LoadWin9xWdmDriver\n");

    //
    // Open a handle to NTKern.VxD
    //

    vxdHandle = CreateFile(WIN9X_NTKERN_NAME,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                           NULL);
                            
    
    //
    // create file failed
    //         

    if (INVALID_HANDLE_VALUE == vxdHandle) 
    {
        OutputDebugString("NTKERN vxd handle creation failed\n");

        bReturn = FALSE;
        goto LoadWin9xWdmDriver_Exit;
    }
    
    //
    // NtKern expects two strings in "vxdDataIn.szBuf".  The first string should be
    // the full pathname of the driver (including .sys).  If no path is given, NtKern
    // will default to \windows\system32\drivers. The second string, which is optional,
    // is the registry key.  If a null is passed in, NtKern will use the default path.
    // "vxdDataIn.dwEAX" should contain the offset the second string.  Both strings 
    // should be null terminated.
    //

    //
    // We will force the assumption that the driver being loaded is in 
    //  \\SystemRoot\system32\drivers.  Since on load, the full path will
    //  be stored in the object representing this driver.  Therefore, we 
    //  need to specify the whole path (ie. Windows directory + 
    //  \system32\drivers\drivername).  Hence, we will construct that path
    //  here.
    //

    GetWindowsDirectory(fullDriverName, FULL_DRIVER_NAME_LENGTH);
    strcat(fullDriverName, "\\system32\\drivers\\");
    strcat(fullDriverName, DriverPath);

    //
    // Prepare the parameters for the driver search
    //

    ZeroMemory(vxdDataIn.szBuf, sizeof(vxdDataIn.szBuf));
    lstrcpy(vxdDataIn.szBuf, fullDriverName);
    vxdDataIn.dwEAX = lstrlen(vxdDataIn.szBuf) + sizeof(char);

    OutputDebugString("Looking for driver ");
    OutputDebugString(vxdDataIn.szBuf);
    OutputDebugString("\n");

    //
    // Call the find function to see if the driver is already loaded, if it is
    //  we don't need to proceed any further.
    //

    bReturn = DeviceIoControl(vxdHandle,
                              0x1003,                    // NTKERN_DIOC_FIND_DRIVER_A
                              &vxdDataIn,                // input buffer
                              sizeof(DIOC_VXD_INTERFACE),// input size
                              &vxdDataOut,               // output buffer
                              sizeof(DIOC_VXD_INTERFACE),// output size
                              &nBytes,                   // bytes returned.
                              NULL);                     // lpOverlapped
    {
        CHAR msg[512];

        wsprintf(msg, "On find driver dwReturn is %08x\n", vxdDataOut.dwReturn);

        OutputDebugString(msg);
    }

    if (bReturn)
    {
        //
        // If a successful check then the driver is already loaded
        //

        if (NT_SUCCESS(vxdDataOut.dwReturn))
        {
            OutputDebugString("Driver ");
            OutputDebugString(DriverPath);
            OutputDebugString(" already loaded\n");
    
            goto LoadWin9xWdmDriver_Exit;
        }

        //
        // OK, the driver is not currently loaded, try to load it
        //

        ZeroMemory(vxdDataIn.szBuf, sizeof(vxdDataIn.szBuf));
        lstrcpy(vxdDataIn.szBuf, DriverPath);
        vxdDataIn.dwEAX = lstrlen(vxdDataIn.szBuf) + sizeof(char);
        
        OutputDebugString("Attempting to load driver ");
        OutputDebugString(vxdDataIn.szBuf);
        OutputDebugString("\n");
        
        bReturn = DeviceIoControl(vxdHandle,
                                  0x1000,                    // NTKERN_DIOC_LOAD_DRIVER_A
                                  &vxdDataIn,                // input buffer
                                  sizeof(DIOC_VXD_INTERFACE),// input size
                                  &vxdDataOut,               // output buffer
                                  sizeof(DIOC_VXD_INTERFACE),// output size
                                  &nBytes,                   // bytes returned.
                                  NULL);                     // lpOverlapped

        if (bReturn)
        {
            if (!NT_SUCCESS(vxdDataOut.dwReturn))
            {
                if (STATUS_OBJECT_NAME_COLLISION != vxdDataOut.dwReturn)
                {
                    CHAR    err[512];

                    wsprintf(err, "Error loading %s with error %08x\n",
                             DriverPath, 
                             vxdDataOut.dwReturn);

                    OutputDebugString(err);

                    bReturn = FALSE;
                }
            }
        }
    }
      
LoadWin9xWdmDriver_Exit:
  
    return bReturn;
}

//*****************************************************************************
//
// UnloadWin9xWdmDriver
//
//*****************************************************************************

BOOLEAN
UnloadWin9xWdmDriver(
    VOID
)
/*++

Routine Description:

  UnloadWin9xWdmDriver()
   
Arguments:
  

Return Value:

--*/
{

    //
    // Currently, this feature is not available on the Win9x platform
    //  so just return false
    //

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);

    return (FALSE);
}

//*****************************************************************************
//
// LoadWin2kWdmDriver
//
//*****************************************************************************

BOOLEAN
LoadWin2kWdmDriver(
    IN  PSTR    ServiceName,
    IN  PSTR    ServiceDescription,
    IN  PSTR    DriverPath
)
/*++

Routine Description:

  LoadWin2kWdmDriver()
   
Arguments:
  

Return Value:

--*/
{
    SC_HANDLE   scServiceHandle;
    BOOL        success;

    //
    // Get a handle to the service itself.  We want EXECUTE access so that
    //  it can be started.
    //

    scServiceHandle = OpenWin2kService(ServiceName,
                                       ServiceDescription,
                                       DriverPath,
                                       TRUE);

    //
    // If error, we cannot go any further
    //

    if (NULL == scServiceHandle)
    {
        success = FALSE;

        goto LoadWin2kWdmDriver_Exit;
    }

    //
    // Try to start the service
    //

    success = StartService(scServiceHandle, 0, NULL);

    //
    // If the service sucessfully start, open the file so that we can 
    //  perform the tests that rely on that handle.
    //

    if (!success && ERROR_SERVICE_ALREADY_RUNNING == GetLastError())
    {
        success = TRUE;
    }

LoadWin2kWdmDriver_Exit:

    return (success);
}


//*****************************************************************************
//
// UnloadWin2kWdmDriver
//
//*****************************************************************************

BOOLEAN
UnloadWin2kWdmDriver(
    IN  PSTR    ServiceName
)
/*++

Routine Description:

  UnloadWin2kWdmDriver()
   
Arguments:
  

Return Value:

--*/
{
    SC_HANDLE      scServiceHandle;
    BOOL           success;
    SERVICE_STATUS serviceStatus;

    //
    // Initialize the variables for proper cleanup on exit
    //

    success         = FALSE;

    //
    // Get a handle to the service itself.  We want EXECUTE access so that
    //  it can be started.
    //

    scServiceHandle = OpenWin2kService(USBTEST_SERVICE_NAME,
                                       NULL,
                                       NULL,
                                       FALSE);

    //
    // If the service was opened, try to stop the service
    //   If not, just return unsuccessful status (FALSE)
    //

    if (NULL != scServiceHandle)
    {
        //
        // Try to stop the service
        //
    
        success = ControlService(scServiceHandle, 
                                 SERVICE_CONTROL_STOP, 
                                 &serviceStatus);

        CloseServiceHandle(scServiceHandle);
    }

    return (success);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\dll\usbtest.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usbtest.c

Abstract: USB Test DLL

Author:

    Chris Robinson

Environment:

    Kernel mode

Revision History:


--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <wtypes.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <winioctl.h>
#include <usbioctl.h>
#include <string.h>

#define INITGUID
#include "usbhlfil.h"
#include "usbtest.h"
#include "usbtsys.h"
#include "local.h"

//*****************************************************************************
// G L O B A L S    P R I V A T E    T O    T H I S    F I L E
//*****************************************************************************

//
// Handle to the USBTestDriver (USBTEST.SYS).  This handle is unique per 
//  process that loads this DLL and is opened automatically when the process 
//  attachs to the DLL.
//

static  HANDLE  USBTestHandle = INVALID_HANDLE_VALUE;

//*****************************************************************************
//
// Entry32()
//
//*****************************************************************************

STDAPI_ (BOOL)
Entry32(
    HINSTANCE hInst, 
    DWORD dwReason, 
    LPVOID lpReserved
)
/*++

Routine Description:

    Entry point for the DLL system.

Arguments:

    hInst        - Handle to the instance of the DLL

    dwReason     - Reason for the entry point being called 

Return Value:

    TRUE if SUCCESSFUL
    FALSE otherwise
--*/
{
    BOOLEAN success;
    
    switch (dwReason) {

        //
        // When a process attachs to the DLL, start the USBTestService
        //  and then get a handle to it.  If the service is already 
        //  started, then there are no problems.  We use this handle in
        //  further subsequent calls that require the USBTest.sys.  A process
        //  can also explicitly start and stop the test driver as well usually
        //  to load a new version of the driver.  Whether the driver gets
        //  successfully started, we will return TRUE but those functions
        //  that rely on the driver will fail in the future.
        //

        case DLL_PROCESS_ATTACH:
            success = StartUSBTest();
            break;

        //
        // On process detach, close the handle and attempt to stop the
        //  test service.   The service may not get stopped since there
        //  may be other open handles to the device in other processes but
        //  there is no way we can know whether this is true.  We'll return
        //  TRUE no matter what however.
        //

        case DLL_PROCESS_DETACH:
            success = StopUSBTest();
            break;
            
        default:
            break;
    }
    return (TRUE);
}

//*****************************************************************************
//
// GetHubLowerFilterHandle()
//
//*****************************************************************************

HANDLE __stdcall
GetHubLowerFilterHandle(
    IN  PCHAR  HubInstanceName
)
/*++

Routine Description:

    Returns a handle to the usb hub lower filter driver if it is loaded 
       for the given instance of the hub.

Arguments:

    HubInstanceName - Symbolic link name for the hub for which the 
                        caller would like a lower hub filter handle to

Return Value:

    If successful, a handle to the hub lower filter driver
    In not, INVALID_HANDLE_VALUE
--*/
{
    PCHAR  filterLinks;
    PCHAR  filterLinkWalk;
    BOOLEAN success;
    BOOLEAN found;
    BOOLEAN wasError;
    HANDLE  handle;
    WCHAR   filterHubNameW[512];
    PCHAR   filterHubNameA;
    ULONG   bytesReturned;

    //
    // Build a list of usbhub lower filter driver symbolic link names
    //

    wasError = !FindDevicesByClass((LPGUID) &GUID_CLASS_USBHLFIL, &filterLinks);

    //
    // Initialize the variables for walking this list of links
    //

    found           = FALSE;
    filterLinkWalk  = filterLinks;

    //
    // Search until we encounter an error, hit the end of the list, or 
    //  find the symbolic link in the list
    //

    while (!wasError && *filterLinkWalk != '\0' && !found)
    {
        //
        // Open a handle to the hub filter
        //

        handle = CreateFile(filterLinkWalk,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);

        if (INVALID_HANDLE_VALUE == handle)
        {
            wasError = TRUE;
            continue;
        }


        //
        // Get the name of the hub from the hub driver...Currently
        //  only using a static buffer to hold the name
        //

        success = DeviceIoControl(handle,
                                  IOCTL_GET_HUB_NAME,
                                  filterHubNameW,
                                  512*sizeof(WCHAR),
                                  filterHubNameW,
                                  512*sizeof(WCHAR),
                                  &bytesReturned,
                                  NULL);
        if (!success)
        {
            {
                DWORD error;

                error = GetLastError();
            }
            wasError = TRUE;
            continue;
        }

        //
        // Convert that hub name which is unicode to an ascii string
        //

        filterHubNameA = WideStrToMultiStr(filterHubNameW);

        if (NULL == filterHubNameA)
        {
            wasError = TRUE;
            CloseHandle(handle);
            continue;
        }

        //
        // Compare the passed in string with the name of the current
        //  hub being examined
        //

        found = (0 == strcmp((PCHAR) filterHubNameA, HubInstanceName));
           
        if (!found) 
        {
            CloseHandle(handle);
        }

        //
        // Continue to the next link...
        //

        filterLinkWalk += (strlen(filterLinkWalk)+1);
    }

    //
    // Free up the links
    //

    if (NULL != filterLinks)
    {
        GlobalFree(filterLinks);
    }

    //
    // Return the appropriate value
    //

    return (found ? handle : INVALID_HANDLE_VALUE);
}

//*****************************************************************************
//
// FindDevicesByClass()
//
//*****************************************************************************

BOOLEAN __stdcall
FindDevicesByClass(
    IN  CONST GUID  *ClassGuid,
    IN  PCHAR       *SymbolicLinks
)
/*++

Routine Description:

    Builds a list of symbolic links to devices that have exposed interfaces
        of a specified class type

Arguments:

    ClassGuid       - The class guid of the device the caller is interested
                        in getting links for

    SymbolicLinks   - A function allocated structure that contains the 
                        a list of symbolic links for all devices found on
                        the system.  The caller is responsible for freeing
                        this list.  This list is terminated by a second NULL 
                        character following the last symbolic link.
Return Value:

    If successful, TRUE and SymbolicLinks points to a valid memory structure
    In unsuccessful, FALSE and SymbolicLinks is NULL
--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA    functionClassDeviceData;
    HDEVINFO                            hardwareDeviceInfo;
    SP_DEVICE_INTERFACE_DATA            deviceInfoData;
    PCHAR                               newSymLinks;
    PCHAR                               symLinks;
    ULONG                               symLinkSize;
    ULONG                               devInstance;
    ULONG                               requiredSize;
    ULONG                               linkSize;
    BOOLEAN                             success;
    BOOLEAN                             wasError;

    //
    // Look for all the devices on the system of the specified class
    //

    hardwareDeviceInfo = SetupDiGetClassDevs( ClassGuid,
                                              NULL,
                                              NULL,
                                              DIGCF_PRESENT |
                                                DIGCF_DEVICEINTERFACE);

    if (INVALID_HANDLE_VALUE == hardwareDeviceInfo) 
    {
        symLinks = NULL;
        wasError = TRUE;

        goto FindDevicesByClass_Exit;
    }

    //
    // Get the more specific info for each of these devices.  We don't
    //  know how many devices so we need to loop until GetLastError() 
    //  returns ERROR_NO_MORE_ITEMS;
    //

    deviceInfoData.cbSize = sizeof(deviceInfoData);

    //
    // Intialize the device instance to get the first device instance
    //  This will be incremented at the end of the loop for the next
    //  iteration
    //

    devInstance = 0;

    //
    // Setup the symbol link information structures.  The initial
    //  structure of strings is NULL.  symLinkSize is biased to one character
    //  however so that we always allocate enough space for the terminating
    //  extra NULL character;
    
    symLinks    = NULL;
    symLinkSize = sizeof(*symLinks);

    //
    // Initialize the wasError variable...If this is still true once we
    //  leave the loop then there were no errors during the processing of the
    //  loop
    //

    wasError = FALSE;

    while (1)
    {
        //
        // Try to get the information on the next device of the device class
        //

        success = SetupDiEnumDeviceInterfaces(hardwareDeviceInfo,
                                              0,
                                              ClassGuid,
                                              devInstance,
                                              &deviceInfoData);

        //
        // Break out of the loop if the above function call failed.
        //

        if (!success)
        {
            wasError = (ERROR_NO_MORE_ITEMS != GetLastError());

            break;
        }

        //
        // If a dev instance was successfully retrieved, get the symbolic
        //  link for the string and add it to our list of symbolic links
        //

        //
        // Get the length of the structure required to hold the detail
        //  data which includes the device path (ie. symbolic link).
        //

        success = SetupDiGetDeviceInterfaceDetail(hardwareDeviceInfo,
                                                  &deviceInfoData,
                                                  NULL,
                                                  0,
                                                  &requiredSize,
                                                  NULL);

        //
        // Expect a return value of FALSE but also an error code 
        //  indicating the buffer is too small.  If this, isn't the
        //  case break out of the loop
        //

        if (!success && ERROR_INSUFFICIENT_BUFFER != GetLastError())
        {
            wasError = TRUE;
            break;
        }

        //
        // Allocate space for the detailed info now that we know just how
        //  big it needs to be.
        //

        functionClassDeviceData = ALLOC(requiredSize);

        if (NULL == functionClassDeviceData)
        {
            wasError = TRUE;
            break;
        }

        //
        // Call the function again...This time, we should complete with success
        //

        functionClassDeviceData -> cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        success = SetupDiGetDeviceInterfaceDetail(hardwareDeviceInfo,
                                                  &deviceInfoData,
                                                  functionClassDeviceData,
                                                  requiredSize,
                                                  NULL,
                                                  NULL);

        if (!success) 
        {
            FREE(functionClassDeviceData);
            wasError = TRUE;
            break;
        }

        //
        // Add the DevicePath in this new device to our list of symbolic links
        //

        //
        // Get the size of the newest link that we found
        //

        linkSize = requiredSize -
                       offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA, DevicePath);

        //
        // Allocate a new structure that is the size of the previous links
        //  plus the new one
        //

        newSymLinks = GlobalAlloc(GPTR, symLinkSize+linkSize);

        if (NULL == newSymLinks)
        {
            wasError = TRUE;
            GlobalFree(functionClassDeviceData);
            break;
        }

        //
        // Copy the old symbolic links we had stored if they did exist and
        //  free the old structure
        //

        if (NULL != symLinks)
        {
            CopyMemory(newSymLinks, symLinks, symLinkSize);
            GlobalFree(symLinks);
        }

        //
        // Save the new structure 
        //

        symLinks = newSymLinks;

        //
        // Copy the newest link just past the end of our old links
        //  Remember that symLinkSize was biased to 1 character initially.
        //    and that this value has not been incremented yet to 
        //    take into account the new link
        //

        CopyMemory((symLinks + symLinkSize-sizeof(*symLinks)),
                   functionClassDeviceData -> DevicePath,
                   linkSize);

        //
        // OK, add the size of the new link to the total size count
        //

        symLinkSize += linkSize;

        //
        // Free the function data
        //

        FREE(functionClassDeviceData);

        //
        // Increment the device instance and loop again
        //

        devInstance++;
    }

    //
    // If there was an error, cleanup any symbol links that may have been
    //  stored to this point.
    //

    if (wasError)
    {
        if (NULL != symLinks) 
        {
            GlobalFree(symLinks);
            symLinks = NULL;
        }

        goto FindDevicesByClass_Exit;
    }

    //
    // The last thing that needs to be done is adding the terminating 
    //  extra NULL character
    //

    *(symLinks+(symLinkSize/sizeof(*symLinks))) = '\0';

FindDevicesByClass_Exit:

    *SymbolicLinks = symLinks;

    if (INVALID_HANDLE_VALUE != hardwareDeviceInfo)
    {
        SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
    }

    return (!wasError);
}
   
//*****************************************************************************
//
// BuildUSBDeviceTree()
//
//*****************************************************************************

PUSB_DEVICE_TREE __stdcall
BuildUSBDeviceTree(
    VOID
)
/*++

Routine Description:

    Builds a memory representation of the current USB device tree by calling
        the IOCTLs of the usb hub driver that are visible to user-mode.  Each
        node that is created has a type (host controller, hub, device, etc.) 
        and pointers to its child nodes if they exist.  The other functions
        in this DLL make use of this tree structure.

    The caller of this function should call DestroyUSBDeviceTree() when
        the allocated tree structure is no longer needed.

Arguments:

Return Value:

    If successful, a pointer to a USB_DEVICE_TREE
    In unsuccessful, NULL is returned and GetLastError() will have
                     a meaningful error code.
--*/
{
    PUSB_DEVICE_TREE    root;
    PUSB_DEVICE_NODE    hcNode;
    HANDLE              hcHandle;
    DEVINST             hcInstance;
    PCHAR               hcName;
    PCHAR               hcDesc;
    ULONG               index;
    ULONG               errorCode;
    BOOL                success;

    //
    // Initialize error code to NO_ERROR...If, upon leaving the function, this
    //  code is anything else, it indicates an error occurred somewhere in the
    //  function
    //

    errorCode = ERROR_SUCCESS;

    //
    // Allocate the root node for the tree
    //

    root = CreateUSBDeviceNode(Computer, MAXIMUM_ROOT_HUBS);

    if (NULL == root) 
    {
        errorCode = ERROR_OUTOFMEMORY;

        goto BuildUSBDeviceTree_Exit;
    }

    root -> NumberOfChildren        = 0;
    root -> Description             = ALLOC(sizeof("My Computer"));
    
    if (NULL != root -> Description) 
    {
        strcpy(root -> Description, "My Computer");
    }
    else 
    {
        errorCode = ERROR_OUTOFMEMORY;

        goto BuildUSBDeviceTree_Exit;
    }

    //
    // Create HC nodes for all the host controllers on the system.
    //

    for (index = 0; index < MAXIMUM_ROOT_HUBS; index++)
    {
        //
        // Try to open the next host controller
        //

        //
        // Create the host controller name for this instance
        //

        hcName = ALLOC(HC_NAME_LENGTH);

        if (NULL == hcName)
        {
            errorCode = ERROR_OUTOFMEMORY;

            goto BuildUSBDeviceTree_Exit;
        }

        wsprintf(hcName, "\\\\.\\HCD%d", index);

        //
        // Open a handle to the host controller
        //

        hcHandle = CreateFile(hcName,
                              GENERIC_WRITE,
                              FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);


        //
        // If the CreateFile failed, then just forego the rest of the loop
        //  and try the next host controller
        //

        if (INVALID_HANDLE_VALUE == hcHandle)
        {
            FREE(hcName);

            continue;
        }

        //
        // Get the description for this device
        //

        hcInstance = GetHCDDeviceInstance(hcHandle); 

        //
        // Create the host controller node
        //

        hcNode = CreateUSBDeviceNode(HostController, 1);

        if (NULL == hcNode)
        {
            //
            // Do some cleanup of things that have already been allocated
            //

            CloseHandle(hcHandle);

            FREE(hcName);

            errorCode = ERROR_OUTOFMEMORY;

            goto BuildUSBDeviceTree_Exit;
        }

        //
        // Save the node information into root computer structure
        //

        hcNode -> Parent           = root;
        hcNode -> HCHandle         = hcHandle;
        hcNode -> DeviceInstance   = hcInstance;
        hcNode -> NumberOfChildren = 0;
        hcNode -> SymbolicLink     = hcName;

        success = GetDeviceInfo(hcInstance, FALSE, hcNode);

        if (!success)
        {
            DestroyUSBDeviceNode(hcNode, NULL);

            errorCode = ERROR_OUTOFMEMORY;
        }

        //
        // Enumerate the devices attached to this host controller
        //

        success = EnumerateHostController(hcNode);

        if (!success) 
        {
            errorCode = GetLastError();

            DestroyUSBDeviceNode(hcNode, NULL);

            goto BuildUSBDeviceTree_Exit;
        }

        root -> Children[root -> NumberOfChildren] = hcNode;
        root -> NumberOfChildren++;
    }

BuildUSBDeviceTree_Exit:

    if (ERROR_SUCCESS != errorCode)
    {
        if (NULL != root) 
        {
            DestroyUSBDeviceTree(root);
        }

        root = NULL;
    }

    SetLastError(errorCode);

    return (root);
}

//*****************************************************************************
//
// CompareUSBDeviceTrees()
//
//*****************************************************************************

BOOLEAN __stdcall
CompareUSBDeviceTrees(
    IN  PUSB_DEVICE_TREE    Tree1,
    IN  PUSB_DEVICE_TREE    Tree2,
    OUT PULONG              NumberDifferences,
    OUT PNODE_PAIR_LIST     NodePairList
)
/*++

Routine Description:

    Compares to USB devices that have been created.  It will note how many
        nodes have changed and include a list of which nodes have changed

Arguments:

    Tree1               -- Pointer to the one of the device trees to compare
                        
    Tree2               -- Pointer to the other device tree to be used
                            in the comparison

    NumberDifferences   -- Count of the number of differences found between
                            the two device trees.  

    NodePairList        -- List of nodes that are different.  The number of
                            nodes in this list will be <= to NumberDifferences
                            depending on whether space could be allocated
                            for all the different nodes.  The caller must
                            call InitializeNodePairList() for this parameter
                            before calling this function

Return Value:

    TRUE if the device trees are the same
    FALSE if there are differences in the tree.  NumberDifferences
            indicates how many nodes are different and NodePairList
            will contain some or all of the nodes that were different
            depending on memory constraints
--*/
{
    *NumberDifferences = 0;

    CompareUSBDeviceNodes(Tree1, 
                          Tree2, 
                          NumberDifferences,
                          NodePairList);

    return (0 == *NumberDifferences);
}

//*****************************************************************************
//
// InitializeNodePairList()
//
//*****************************************************************************

VOID
InitializeNodePairList(
    IN PNODE_PAIR_LIST  NodePairList
)
/*++

Routine Description:

    Initializes a node pair list that will be used in a call to 
        CompareUSBDeviceTrees();

Arguments:

    NodePairList        -- The list that needs to be initialized


Return Value:

    NONE

--*/
{

    NodePairList -> MaxNodePairs     = 1;
    NodePairList -> CurrentNodePairs = 0;
    NodePairList -> NodePairs        = ALLOC(NodePairList -> MaxNodePairs *
                                             sizeof(PUSB_DEVICE_NODE) * 2);

    if (NULL == NodePairList -> NodePairs)
    {
        NodePairList -> MaxNodePairs = 0;
    }

    return;
}

//*****************************************************************************
//
// DestroyNodePairList
//
//*****************************************************************************

VOID
DestroyNodePairList(
    IN PNODE_PAIR_LIST  NodePairList
)
/*++

Routine Description:

    Destroys a node pair list that was used in a
        call to CompareUSBDeviceTrees()

Arguments:

    NodePairList    -- The list that needs to be cleaned up


Return Value:

    NONE

--*/
{
    //
    // Free up the memory that had been allocated for the pairs if one
    //  had been created
    //

    if (NULL != NodePairList -> NodePairs)
    {
        FREE(NodePairList -> NodePairs);
    }

    return;
}

//*****************************************************************************
//
// DestroyUSBDeviceTree()
//
//*****************************************************************************

VOID __stdcall
DestroyUSBDeviceTree(
    IN  PUSB_DEVICE_TREE    Tree
)
/*++

Routine Description:

    Frees all the memory that was allocated in a call to BuildUSBDeviceTree().
        This function used WalkUSBDeviceTree with the appropriate callbacks
        to perform the clean up.

Arguments:

    Tree    -- A pointer to the USB_DEVICE_TREE structure that needs to
                be cleaned up.

Return Value:

    NONE

--*/
{
    ULONG   index;

    //
    // To destroy the whole tree, we just destroy the Tree node...This 
    //  could change in the future, hence the abstraction...The
    //  WalkUSBDeviceTree() function is used with a post callback since we
    //  need to clean up child nodes of the device before we can free
    //  the memory allocated for a specific node
    //

    WalkUSBDeviceTree(Tree, NULL, DestroyUSBDeviceNode, NULL);

    return;
}

//*****************************************************************************
//
// WriteUSBDeviceTreeToFile()
//
//*****************************************************************************

BOOLEAN __stdcall
WriteUSBDeviceTreeToFile(
    IN  HANDLE              File,
    IN  PUSB_DEVICE_TREE    Tree
)
/*++

Routine Description:

    Writes a given USB device tree to a file in order to save a given 
        structure.  This function uses a special binary format to save
        the relevant pieces of information for each device node.  See 
        the WriteUSBDeviceNodeToFile() function for more information on
        this format.

Arguments:

    File    -- A handle to the file used for saving the structure.  This
                file handle must have been opened with GENERIC_WRITE access.

    Tree    -- A pointer to the USB_DEVICE_TREE structure that needs to
                be saved to disk

Return Value:

    TRUE if the whole tree was successfully written to the file
    FALSE if otherwise

--*/
{
    BOOL    success;

    //
    // Make use of the WalkUSBDeviceTree() function in order to write each
    //  of the nodes to disk.  A prewalk callback function is used since
    //  the device file format contains the information for a given node and
    //  then the information for all of its children.
    //

    success = WalkUSBDeviceTree(Tree,
                                WriteUSBDeviceNodeToFile,
                                NULL,
                                (PVOID) File);

    return (success);
}

//*****************************************************************************
//
// ReadUSBDeviceTreeFromFile()
//
//*****************************************************************************

BOOLEAN __stdcall
ReadUSBDeviceTreeFromFile(
    IN  HANDLE              File,
    OUT PUSB_DEVICE_TREE    *Tree
)
/*++

Routine Description:

    Reads a given USB device tree from a file in order to reload a previous
        device tree.  This function assumes the special binary format used by
        the WriteUSBDeviceTreeToFile() function.  On reading the file, it 
        creates a new USB_DEVICE_TREE structure to represent the information
        stored on the disk.

Arguments:

    File    -- A handle to the file used for reading the structure.  This
                file handle must have been opened with GENERIC_READ access.

    Tree    -- A pointer to the USB_DEVICE_TREE structure pointer that will
                point to the device tree created from the file.  This 
                structure should be destroyed with DestroyUSBDeviceTree when
                it is no longer needed.

Return Value:

    TRUE if the whole tree was successfully read from the file
    FALSE if otherwise

--*/
{
    *Tree = ReadUSBDeviceNodeFromFile(File);

    return (NULL != *Tree);
}

//*****************************************************************************
//
// WriteUSBDeviceTreeToTextFile()
//
//*****************************************************************************

BOOLEAN __stdcall
WriteUSBDeviceTreeToTextFile(
    IN  HANDLE              File,
    IN  PUSB_DEVICE_TREE    Tree
)
/*++

Routine Description:

    Writes a given USB device tree to a file in text format as a tree 
        structure.  

Arguments:

    File    -- A handle to the text file used for saving the output.  The
                file handle must have been opened with GENERIC_WRITE access.

    Tree    -- A pointer to the USB_DEVICE_TREE structure that needs to
                be written to disk

Return Value:

    TRUE if the whole tree was successfully written to the file
    FALSE if otherwise

--*/
{
    NODE_TO_TEXT_CONTEXT    context;
    BOOLEAN                 success;
    

    //
    // Initialize the context
    //

    context.File        = File;
    context.Indentation = 0;

    //
    // Use the WalkUSBDeviceTree() function to display the tree.  It uses
    //  both a pre-walk callback and a post-walk callback.  The pre-walk 
    //  callback outputs the line for the given node and updates the
    //  indent size.  The post-walk callback "undoes" the modifications 
    //  made to the indentation size.
    //

    success = WalkUSBDeviceTree(Tree, 
                                WriteUSBDeviceNodeToTextFilePre,
                                WriteUSBDeviceNodeToTextFilePost,
                                &context);

    return (success);
}

//*****************************************************************************
//                  
// WalkUSBDeviceTree
//
//*****************************************************************************

BOOLEAN __stdcall
WalkUSBDeviceTree(
    IN  PUSB_DEVICE_TREE            Tree,
    IN  PUSB_DEVICE_NODE_CALLBACK   PreWalkCallback  OPTIONAL,
    IN  PUSB_DEVICE_NODE_CALLBACK   PostWalkCallback OPTIONAL,
    IN  PVOID                       Context          OPTIONAL
)
/*++

Routine Description:

    Walks a given in a depth-first fashion.  The caller can specify either
        a PreWalkCallback function, a PostWalkCallback function, or both.  
        The PreWalkCallback function is called before the function visits
        each of the child nodes for a given node and the PostWalkCallback
        function will be called all the children of a node have been visited.

    The callback functions that are called should return TRUE or FALSE to 
        indicate whether processing should continue further.  If FALSE is
        returned, this function assumes an error occurred in the callback
        function and the callback function would like to terminate the walk.

Arguments:

    Tree                -- A pointer to the USB_DEVICE_TREE structure to be walked

    PreWalkCallback     -- A pointer to a callback function that will be called
                            before the child nodes of a node are walked.

    PostWalkCallback    -- A pointer to a callback function that will be called
                            after the child nodes of a node have been walked.

    Context             -- A pointer to a context structure that will be 
                            passed to the callback functions.

    
Return Value:

    TRUE if the whole tree was successfully walked
    FALSE if otherwise

--*/
{
    BOOLEAN success;

    //
    // Simply call the corresponding node walk function...
    //

    success = WalkUSBDeviceNode(Tree, 
                                PreWalkCallback, 
                                PostWalkCallback, 
                                Context);

    return (success);
}

//*****************************************************************************
//
// CycleUSBPort
//
//*****************************************************************************

BOOLEAN __stdcall
CycleUSBPort(
    IN  PUSB_DEVICE_NODE    Node
)
/*++

Routine Description:

    Cycles a user specified port.  This function requires that USBTEST.SYS 
        be loaded on the system.  USBTEST.SYS is used to send the internal
        CYCLE_PORT ioctl that is only exposed at kernel mode.  The caller
        of this function must pass in the node of the device which it
        would like to simulate a PnP on.  This function will determine
        the parent hub and issue the request as appropriate for that hub.

Arguments:

    Tree                -- A pointer to the USB_DEVICE_NODE to be cycled

    PreWalkCallback     -- A pointer to a callback function that will be called
                            before the child nodes of a node are walked.

    PostWalkCallback    -- A pointer to a callback function that will be called
                            after the child nodes of a node have been walked.

    Context             -- A pointer to a context structure that will be 
                            passed to the callback functions.

    
Return Value:

    TRUE  if the ioctl was successfully submitted
    FALSE if otherwise and GetLastError() contains the appropriate error code

--*/
{
    PCYCLE_PORT_PARAMETERS  cyclePortParams;
    PUSB_DEVICE_NODE        parentHubNode;
    ULONG                   paramSize;
    BOOLEAN                 success;
    BOOLEAN                 isRootHub;
    ULONG                   nBytes;

    //
    // Check to see if we have a handle to the service.  If not, we cannot
    //  perform the test.
    //

    if (INVALID_HANDLE_VALUE == USBTestHandle)
    {
        SetLastError(ERROR_INVALID_HANDLE);

        return (FALSE);
    }

    //
    // Get the parent hub node
    //

    if (NULL == Node || NULL == Node -> Parent)
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        return (FALSE);
    }

    parentHubNode = Node -> Parent;

    //
    // Cannot cycle a port if the parent is not actually a hub
    //

    if (Hub != parentHubNode -> NodeType)
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        return (FALSE);
    }

    //
    // If this is a root hub, then we cannot cycle the port.  This is due
    //  to the fact that the USBD driver will not allow a create file for
    //  the root hub port to succeed.  
    //

    if (NULL == parentHubNode -> ConnectionInformation)
    {
        isRootHub = TRUE;
    }

    //
    // Calculate the amount of space needed for the cycle port
    //  parameters buffer
    //

    paramSize = sizeof(CYCLE_PORT_PARAMETERS) +
                    strlen(parentHubNode -> SymbolicLink) + 1;

    //
    // Allocate the space for the parameters
    //

    cyclePortParams = ALLOC(paramSize);

    if (NULL == cyclePortParams)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return (FALSE);
    }

    //
    // Set the relevant information in the parameters structure
    //

    cyclePortParams -> NodeIndex =
                  Node -> ConnectionInformation -> ConnectionIndex;

    strcpy(&(cyclePortParams -> HubName[0]), parentHubNode -> SymbolicLink);

    //
    // Send this down to the USB test driver
    //

    success = DeviceIoControl(USBTestHandle,
                              IOCTL_USBTEST_CYCLE_PORT,
                              cyclePortParams,
                              paramSize,
                              NULL,
                              0,
                              &nBytes,
                              NULL);

    FREE(cyclePortParams);

    //
    // If the port failed to cycle due to an error cycling the root hub
    //  then return status success so we don't confuse the calling routine.
    //
    
    if (!success && ERROR_NOT_SUPPORTED == GetLastError() && isRootHub)
    {
        success = TRUE;
    }

    return (success);
}

//*****************************************************************************
//
// StartUSBTest
//
//*****************************************************************************

BOOLEAN __stdcall
StartUSBTest(
    VOID
)
/*++

Routine Description:

    This function attempts to start the USBTEST.SYS driver.  If successful,
        it maintains a handle that can be used in future calls to communicate
        with the test driver.  Since the loading mechanisms are different
        on Win9x and Win2k platforms, it detects the type of OS that is being
        run and then calls the appropriate loading function as implemented in
        service.c

Arguments:

    NONE

Return Value:

    TRUE  if the driver was successfully loaded or was already loaded
    FALSE if otherwise and GetLastError() contains the appropriate error code

--*/
{
    BOOL        success;
    BOOL        isWin9x;

    //
    // If USBTestHandle already contains a valid handle value then just 
    //  return TRUE as the service has already been started
    //
    
    if (INVALID_HANDLE_VALUE != USBTestHandle)
    {
        return (TRUE);
    }

    //
    // Call the appropriate driver loading routine based on whether this is 
    //  Win9x or Win2k
    //

    isWin9x = IsWindows9x();

    if (isWin9x)
    {
        success = LoadWin9xWdmDriver("usbtest.sys");

    }
    else
    {
        success = LoadWin2kWdmDriver(USBTEST_SERVICE_NAME,
                                     USBTEST_SERVICE_DESC,
                                     USBTEST_DRIVER_PATH);
    }

    //
    // If the driver was successfully loaded, get a handle to the driver
    //

    if (success)
    {
        USBTestHandle = CreateFile(USBTESTNAME,
                                   0,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL);

        if (INVALID_HANDLE_VALUE == USBTestHandle)
        {
            success = FALSE;
        }
    }
    else
    {
        USBTestHandle = INVALID_HANDLE_VALUE;
    }

    return (success);
}

//*****************************************************************************
//
// StopUSBTest
//
//*****************************************************************************

BOOLEAN __stdcall
StopUSBTest(
    VOID
)
/*++

Routine Description:

    This function attempts to stop the USBTEST.SYS driver if it has been
        loaded.  Like loading, the unloading methods differ between Win9x and
        Win2k so the OS is detected and the appropriate function is called.

    Currently, the ability to statically unload a WDM on Win9x is not 
        implemented.

Arguments:

    NONE

Return Value:

    TRUE  if the driver was successfully loaded or was already loaded
    FALSE if otherwise and GetLastError() contains the appropriate error code

--*/
{
    BOOL            success;
    BOOL            isWin9x;

    //
    // Close the open handle if we have it
    //

    if (INVALID_HANDLE_VALUE != USBTestHandle)
    {
        CloseHandle(USBTestHandle);

        USBTestHandle = INVALID_HANDLE_VALUE;
    }

    //
    // Unload the driver now...For Win2k, this means stopping the service
    //  For Win9x, this cannot be done yet as it is not implemented in the
    //  NTKern code
    //

    isWin9x = IsWindows9x();

    if (isWin9x)
    {
        success = UnloadWin9xWdmDriver();
    }
    else
    {
        success = UnloadWin2kWdmDriver(USBTEST_SERVICE_NAME);
    }

    return (success);
}


//*****************************************************************************
//
// StopUSBTest
//
//*****************************************************************************

BOOLEAN __stdcall
ParseReportDescriptor(
    IN  PCHAR               ReportDescriptor,
    IN  ULONG               DescriptorLength,
    OUT PHIDP_DEVICE_DESC   *DeviceDesc
)
/*++

Routine Description:

    This function uses the USBTEST.SYS driver to have the HID parser parse
        a given report descriptor.  This is similar to what the hidview
        parser stress test does with USBDIAG but eliminates the need for 
        the USBDIAG driver to be loaded.

Arguments:

    ReportDescriptor    -- A pointer a buffer that contains the descriptor
                            that is to be parsed.

    DescriptorLength    -- The length of the above report descriptor

    DeviceDesc          -- A pointer to a HIDP_DEVICE_DESC pointer.  This
                            function allocates a structure to contain the
                            data returned by the parser.  The caller
                            is responsible for freeing this structure when it
                            is no longer needed.

Return Value:

    TRUE  if the descriptor was successfully parsed.
    FALSE if otherwise and GetLastError() contains the appropriate error code

--*/
{
    PHIDP_COLLECTION_DESC   hidCollectionDesc;
    PHIDP_DEVICE_DESC       hidDeviceDesc;
    BOOL                    success;
    ULONG                   nBytes;
    PCHAR                   dataBuffer;
    ULONG                   dataBufferLength;
    DWORD                   errorCode;

    //
    // Initialize this variable since we'll set DeviceDesc to it on exit
    //

    hidDeviceDesc = NULL;

    //
    // Check that the USBTest service is started and open
    //

    if (INVALID_HANDLE_VALUE == USBTestHandle)
    {
        errorCode = ERROR_INVALID_HANDLE;
        success   = FALSE;

        goto ParseReportDescriptor_Exit;
    }
        
    //
    // Start by allocating a buffer big enough to hold the report descriptor
    //

    dataBufferLength = DescriptorLength;
    success          = FALSE;

    while (!success)
    {
        dataBuffer = ALLOC(dataBufferLength);
 
        if (NULL == dataBuffer) 
        {
            errorCode = ERROR_OUTOFMEMORY;
            success   = FALSE;
    
            break;
        }

        //
        // Copy the report descriptor into the allocated buffer
        //

        RtlCopyMemory(dataBuffer, ReportDescriptor, DescriptorLength);

        //
        // Call USBTest to parse the report descriptor
        //

        success = DeviceIoControl(USBTestHandle,
                                  IOCTL_USBTEST_PARSE,
                                  dataBuffer,
                                  DescriptorLength,
                                  dataBuffer,
                                  dataBufferLength,
                                  &nBytes,
                                  NULL);

        if (!success) 
        {
            //
            // If the buffer was too small, the needed size is returned
            //  in the buffer as a ULONG.  Extract that value and 
            //  try the request again
            //

            errorCode = GetLastError();

            dataBufferLength = *((PULONG) dataBuffer);

            FREE(dataBuffer);

            if (ERROR_MORE_DATA != errorCode)
            {
                break;
            }
        }
    }


    if (!success)
    {
        goto ParseReportDescriptor_Exit;
    }

    //
    // At this point, we have the device description data.  However,
    //  the pointers that are stored in the buffer are offsets into the
    //  buffer.  Let's repatch those for actual pointers
    //

    hidDeviceDesc     = (PHIDP_DEVICE_DESC) dataBuffer;

    //
    // Resolve the collection data first
    //

    hidDeviceDesc -> CollectionDesc = (PHIDP_COLLECTION_DESC) (dataBuffer +
                                   ((ULONG) hidDeviceDesc -> CollectionDesc));

    //
    // Next the preparsed data
    //

    hidCollectionDesc = hidDeviceDesc -> CollectionDesc;

    hidCollectionDesc -> PreparsedData = (PHIDP_PREPARSED_DATA) (dataBuffer +
                                  ((ULONG) hidCollectionDesc -> PreparsedData));

    //
    // Now the report IDs
    //

    hidDeviceDesc -> ReportIDs = (PHIDP_REPORT_IDS) (dataBuffer + 
                                  ((ULONG) hidDeviceDesc -> ReportIDs));

    //
    // Indicate success for the error code and leave
    //

    errorCode = ERROR_SUCCESS;

ParseReportDescriptor_Exit:
    
    *DeviceDesc = hidDeviceDesc;

    SetLastError(errorCode);

    return (success);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\dll\devnode.c ===
/*++

Copyright (c) 1998-1998 Microsoft Corporation

Module Name:

    DEVNODE.C

--*/


#include <windows.h>
#include <basetyps.h>
#include <cfgmgr32.h>

#include <wchar.h>
#include <string.h>
#include <winioctl.h>
#include <usbioctl.h>

#include "usbtest.h"
#include "local.h"

//*****************************************************************************
// D E F I N E S  
//*****************************************************************************

#define INDENT_SIZE 4

#define DEFAULT_DEVICE_DESC ""
#define DEFAULT_DEVICE_NAME ""
#define DEFAULT_HUB_NAME    ""
#define DEFAULT_CLASS_NAME  "USB"
#define ROOT_HUB_DESC       "RootHub"

#define USB_COMPOSITE_ID    "USB\\COMPOSITE"

#define CalculateNodeVariableLength(nh)                                     \
    (  (nh).NodeInfoExists*sizeof(USB_NODE_INFORMATION) +                   \
       (nh).ConnectionInfoExists*sizeof(USB_NODE_CONNECTION_INFORMATION) +  \
       (nh).SymbolicLinkLength +                                            \
       (nh).DescriptionLength  +                                            \
       (nh).ClassNameLength                                                 \
    )

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

#include <pshpack1.h>

typedef struct _FILE_NODE_HEADER
{
    UCHAR   NodeType;
    UCHAR   NumberOfChildren;
    UCHAR   NodeInfoExists;
    UCHAR   ConnectionInfoExists;

    USHORT  SymbolicLinkLength;
    USHORT  DescriptionLength;
    USHORT  ClassNameLength;
    USHORT  Reserved;
    ULONG   DeviceStatus;
    ULONG   DeviceProblem;
} FILE_NODE_HEADER, *PFILE_NODE_HEADER;

#include <poppack.h>

//*****************************************************************************
// G L O B A L S
//*****************************************************************************

CHAR buf[512];  // XXXXX How big does this have to be? Dynamically size it?

PCHAR ConnectionStatuses[] =
{
    "NoDeviceConnected",
    "DeviceConnected",
    "DeviceFailedEnumeration",
    "DeviceGeneralFailure",
    "DeviceCausedOvercurrent",
    "DeviceNotEnoughPower"
};

//*****************************************************************************
//
// DriverNameToDeviceInstance()
//
// Returns the config manager's device instance for the DevNode with 
//   the matching DriverName.
//
// Returns TRUE if the matching devnode is found..
// Returns FALSE if the matching devnode is not found and 
//  DeviceInstance will be set to 0.
//
//*****************************************************************************

BOOL
DriverNameToDeviceInstance(
    IN  PCHAR   DriverName,
    OUT DEVINST *DeviceInstance
)
{
    DEVINST     devInst;
    DEVINST     devInstNext;
    CONFIGRET   cr;
    ULONG       walkDone = 0;
    ULONG       len;
    PCHAR       devDesc;

    //
    // Initialize the DeviceInstance parameter to 0 so it is set 
    //  appropriately on error
    //

    *DeviceInstance = 0;

    //
    // Get Root DevNode
    //

    cr = CM_Locate_DevNode(&devInst,
                           NULL,
                           0);

    if (cr != CR_SUCCESS)
    {
        return (FALSE);
    }

    //
    // Do a depth first search for the DevNode with a matching
    // DriverName value
    //

    while (!walkDone)
    {
        //
        // Get the DriverName value
        //

        len = sizeof(buf);
        cr = CM_Get_DevNode_Registry_Property(devInst,
                                              CM_DRP_DRIVER,
                                              NULL,
                                              buf,
                                              &len,
                                              0);

        //
        // If the DriverName value matches, return the DeviceDescription
        //

        if (cr == CR_SUCCESS && strcmp(DriverName, buf) == 0)
        {
            *DeviceInstance = devInst;
            return (TRUE);
        }

        //
        // This DevNode didn't match, go down a level to the first child.
        //

        cr = CM_Get_Child(&devInstNext,
                          devInst,
                          0);

        if (cr == CR_SUCCESS)
        {
            devInst = devInstNext;
            continue;
        }

        //
        // Can't go down any further, go across to the next sibling.  If
        // there are no more siblings, go back up until there is a sibling.
        // If we can't go up any further, we're back at the root and we're
        // done.
        //

        for (;;)
        {
            cr = CM_Get_Sibling(&devInstNext,
                                devInst,
                                0);

            if (cr == CR_SUCCESS)
            {
                devInst = devInstNext;
                break;
            }

            cr = CM_Get_Parent(&devInstNext,
                               devInst,
                               0);


            if (cr == CR_SUCCESS)
            {
                devInst = devInstNext;
            }
            else
            {
                walkDone = 1;
                break;
            }
        }
    }

    return (FALSE);
}

//*****************************************************************************
//
// GetDeviceDesc()
//
// Returns the Device Description for this particular device instance
// Returns NULL if the device description could not be obtained.
//
// The caller is responsible for freeing the return value when it is
//  no longer needed.
//
//*****************************************************************************

PCHAR
GetDeviceDesc(
    DEVINST DeviceInstance
)
{
    CONFIGRET   cr;
    ULONG       len;
    PCHAR       devDesc;

    devDesc = NULL;

    if (0 != DeviceInstance)
    {
         len = sizeof(buf);
         cr = CM_Get_DevNode_Registry_Property(DeviceInstance,
                                               CM_DRP_DEVICEDESC,
                                               NULL,
                                               buf,
                                               &len,
                                               0);
         
         if (cr == CR_SUCCESS)
         {
             devDesc = ALLOC(strlen(buf)+1);
         
             if (NULL != devDesc)
             {
                 strcpy(devDesc, buf);
             }
         }
    }

    if (NULL == devDesc)
    {
        devDesc = ALLOC(sizeof(DEFAULT_DEVICE_DESC));

        if (NULL != devDesc)
        {
            strcpy(devDesc, DEFAULT_DEVICE_DESC);
        }
    }

    return (devDesc);
}

//*****************************************************************************
//
// GetSymbolicLink
//
// Returns the SymbolicLink of the device instance 
// Returns NULL if the the symbolic link could not be retrieved
//
// The caller is responsible for freeing the return value when it is
//  no longer needed.
//
//*****************************************************************************

PCHAR 
GetSymbolicLink(
    DEVINST DeviceInstance
)
{
    HKEY        instKey;
    HKEY        paramKey;
    CONFIGRET   cr;
    ULONG       len;
    PCHAR       symLink;
    LONG        result;

    symLink = NULL;

    if (0 != DeviceInstance)
    {
        cr = CM_Open_DevNode_Key(DeviceInstance,
                                 KEY_QUERY_VALUE,
                                 0,
                                 RegDisposition_OpenExisting,
                                 &instKey,
                                 0);
    
        if (CR_SUCCESS == cr) 
        {

            //
            // If we successfully got a handle to the instance key, then
            //  get a handle to the device parameters sub key
            //
    
            len = sizeof(buf);
            result = RegQueryValueEx(instKey,
                                     "SymbolicName",
                                     NULL,
                                     NULL,
                                     buf,
                                     &len);

            //
            // Don't need the instance key anymore...
            //
        
            RegCloseKey(instKey);

            if (ERROR_SUCCESS == result)
            {
                symLink = ALLOC(strlen(buf) - strlen("\\??\\") + 1);

                if (NULL != symLink)
                {
                    strcpy(symLink, buf+strlen("\\??\\"));
                }
            }
        }
    }

    if (NULL == symLink)
    {
        symLink = ALLOC(sizeof(DEFAULT_DEVICE_NAME));

        if (NULL != symLink)
        {
            strcpy(symLink, DEFAULT_DEVICE_NAME);
        }
    }

    return (symLink);
}

//*****************************************************************************
//
// GetDeviceClassName
//
// Returns the Class Name of the device instance
// Returns NULL if the the class name could not be retrieved
//
// The caller is responsible for freeing the return value when it is
//  no longer needed.
//
//*****************************************************************************

PCHAR 
GetDeviceClassName(
    DEVINST DeviceInstance
)
{
    CONFIGRET   cr;
    ULONG       len;
    PCHAR       className;


    className = NULL;

    if (0 != DeviceInstance)
    {

        len = sizeof(buf);
        cr = CM_Get_DevNode_Registry_Property(DeviceInstance,
                                              CM_DRP_CLASS,
                                              NULL,
                                              buf,
                                              &len,
                                              0);
        if (cr == CR_SUCCESS)
        {
            className = ALLOC(strlen(buf)+1);
        
            if (NULL != className)
            {
                strcpy(className, buf);
            }
        }
    }
    
    if (NULL == className)
    {
        className = ALLOC(sizeof(DEFAULT_CLASS_NAME));

        if (NULL != className)
        {
            strcpy(className, DEFAULT_CLASS_NAME);
        }
    }

    return (className);
}

//*****************************************************************************
//
// GetDeviceState
//
// Returns the state for a given device instance which includes the
//      config manager's device status and device problem code
//
// Returns FALSE if an error occured and device state/problem will be zero
//
//*****************************************************************************

BOOL
GetDeviceState(
    IN  DEVINST DeviceInstance,
    OUT PULONG  DeviceStatus,
    OUT PULONG  DeviceProblem
)
{
    CONFIGRET   cr;

    //
    // Validate the parameters to the call
    //

    if (NULL == DeviceStatus || NULL == DeviceProblem || 0 == DeviceInstance)
    {
        return (FALSE);
    }

    //
    // Call config man to get the device status and device problem.  Expecting
    //  CR_SUCCESS on return.  If anything else, return FALSE and set the 
    //  DeviceStatus and DeviceProblem fields to 0.
    //

    cr = CM_Get_DevNode_Status(DeviceStatus,
                               DeviceProblem,
                               DeviceInstance,
                               0);

    if (CR_SUCCESS != cr)
    {
        *DeviceStatus  = 0;
        *DeviceProblem = 0;
    }

    return (CR_SUCCESS == cr);
}

//*****************************************************************************
//
// GetDeviceInfo
//
// Takes a device instance and a device node as input and sets all the fields
//  of the device node that are retrieved from the registry via the device
//  instance.  If there is an error trying to get a certain piece of
//  (ie. it does't exist), a default is used.  The only time a return
//  code of FALSE will be returned is when a memory allocation failed.  
//  In this manor, the tree can be established with some sort of default 
//  values, but we won't have to worry about having NULL pointers within
//  the tree.
//
//*****************************************************************************

BOOL
GetDeviceInfo(
    IN     DEVINST DeviceInstance,
    IN     BOOL    IsHub,
    IN OUT PUSB_DEVICE_NODE DeviceNode
)
{
    PCHAR   className;
    PCHAR   deviceDesc;
    PCHAR   symbolicLink;
    ULONG   statusCode;
    ULONG   problemCode;
    BOOL    success;

    //
    // Initialize for later checks
    //

    className    = NULL;
    deviceDesc   = NULL;
    symbolicLink = NULL;
    statusCode   = 0;
    problemCode  = 0;

    success      = TRUE;

    //
    // Try to get the string information initially based 
    //   on the device instance.  If any of these are NULL, then it
    //   either didn't exist or there was a memory allocation failure.
    //   Either way, we'll at least try to create default names. 
    //

    if (NULL == DeviceNode -> ClassName)
    {
        className = GetDeviceClassName(DeviceInstance);

        success = (NULL != className);
    }
    
    if (NULL == DeviceNode -> Description)
    {
        deviceDesc   = GetDeviceDesc(DeviceInstance);

        success = (success && (NULL != deviceDesc));
    }

    if (NULL == DeviceNode -> SymbolicLink)
    {
        symbolicLink = GetSymbolicLink(DeviceInstance);

        success = (success && (NULL != symbolicLink));
    }

    //
    // Get the device state.  Success will be ignored since default
    //  values of 0 are returned for status and problem codes if there
    //  was an error.  That's good enough for here.
    //

    GetDeviceState(DeviceInstance,
                   &statusCode,
                   &problemCode);

    //
    // If no device instance was specified or an error occurred trying to get
    //  one of the strings, then the default value should be attempted to be 
    //  used.
    //

    if (!success)
    {
        if (NULL != className)
        {
            FREE(className);
        }

        if (NULL != deviceDesc)
        {   
            FREE(deviceDesc);
        }

        if (NULL != symbolicLink)
        {
            FREE(symbolicLink);
        }
    }
    else 
    {
        if (NULL == DeviceNode -> ClassName) 
        {
            DeviceNode -> ClassName     = className;
        }

        if (NULL == DeviceNode -> Description)
        {
            DeviceNode -> Description   = deviceDesc;
        }

        if (NULL == DeviceNode -> SymbolicLink)
        {
            DeviceNode -> SymbolicLink  = symbolicLink;
        }

        DeviceNode -> DeviceStatus  = statusCode;
        DeviceNode -> DeviceProblem = problemCode;
    }

    return (success);
}

//*****************************************************************************
//
// WideStrToMultiStr()
//
//*****************************************************************************

PCHAR
WideStrToMultiStr(
   PWCHAR WideStr
)
{
    ULONG nBytes;
    PCHAR MultiStr;

    // Get the length of the converted string
    //
    nBytes = WideCharToMultiByte(
                 CP_ACP,
                 0,
                 WideStr,
                 -1,
                 NULL,
                 0,
                 NULL,
                 NULL);

    if (nBytes == 0)
    {
        return NULL;
    }

    // Allocate space to hold the converted string
    //
    MultiStr = ALLOC(nBytes);

    if (MultiStr == NULL)
    {
        return NULL;
    }

    // Convert the string
    //
    nBytes = WideCharToMultiByte(
                 CP_ACP,
                 0,
                 WideStr,
                 -1,
                 MultiStr,
                 nBytes,
                 NULL,
                 NULL);

    if (nBytes == 0)
    {
        FREE(MultiStr);
        return NULL;
    }

    return MultiStr;
}

DEVINST
GetHCDDeviceInstance(
    IN  HANDLE  HCHandle
)
{
    USB_HCD_DRIVERKEY_NAME  driverKeyName;
    PUSB_HCD_DRIVERKEY_NAME driverKeyNameW;
    PCHAR                   driverKeyNameA;
    BOOL                    success;
    ULONG                   nBytes;
    DEVINST                 deviceInstance;

    //
    // Initialize the allocated memory structure first
    //

    driverKeyNameW  = NULL;
    driverKeyNameA  = NULL;
    deviceInstance  = 0;

    //
    // Get the number of bytes needed for the driver key name
    //

    success = DeviceIoControl(HCHandle,
                              IOCTL_GET_HCD_DRIVERKEY_NAME,
                              &driverKeyName,
                              sizeof(driverKeyName),
                              &driverKeyName,
                              sizeof(driverKeyName),
                              &nBytes,
                              NULL);

    if (!success) 
    {
        goto GetHCDDeviceInstance_Exit;
    }

    //
    // Allocate space to hold the driver key name
    //

    nBytes = driverKeyName.ActualLength;

    if (nBytes <= sizeof(driverKeyName)) 
    {
        goto GetHCDDeviceInstance_Exit;
    }

    //
    // Allocate the correct amount of space for the driver key name
    //

    driverKeyNameW = ALLOC(nBytes);

    if (NULL == driverKeyNameW)
    {
        goto GetHCDDeviceInstance_Exit;
    }

    //
    // Get the name of the driver key of the host controller
    //

    success = DeviceIoControl(HCHandle,
                              IOCTL_GET_HCD_DRIVERKEY_NAME,
                              driverKeyNameW,
                              nBytes,
                              driverKeyNameW,
                              nBytes,
                              &nBytes,
                              NULL);

    
    if (!success)
    {
        goto GetHCDDeviceInstance_Exit;
    }

    //
    // Convert the name to ASCII
    //

    driverKeyNameA = WideStrToMultiStr(driverKeyNameW -> DriverKeyName);

    if (NULL == driverKeyNameA)
    {
        goto GetHCDDeviceInstance_Exit;
    }

    success = DriverNameToDeviceInstance(driverKeyNameA, &deviceInstance);

GetHCDDeviceInstance_Exit:

    //
    // Free up the driver key names that were allocated
    //

    if (NULL != driverKeyNameW)
    {
        FREE(driverKeyNameW);
    }

    if (NULL != driverKeyNameA)
    {
        FREE(driverKeyNameA);
    }

    return (deviceInstance);
}

//*****************************************************************************
//
// IsCompositeDevice()
//
//*****************************************************************************

BOOL
IsCompositeDevice(
    IN  DEVINST DeviceInstance,
    OUT PBOOL   IsComposite,
    OUT PULONG  NumberChildren
)
{
    CONFIGRET   cr;
    DEVINST     child;
    DEVINST     nextChild;

    PTCHAR      property;
    PTCHAR      walk;
    ULONG       len;

    //
    // Get the compatible IDs for this device...We will want to look
    //  for USB\COMPOSITE in this list.  
    //

    //
    // Retrieve the compatible ids
    //

    len = 0;
    cr = CM_Get_DevNode_Registry_Property(DeviceInstance,
                                         CM_DRP_COMPATIBLEIDS,
                                         NULL,
                                         NULL,
                                         &len,
                                         0);

    if (CR_BUFFER_SMALL != cr)
    {
        return (FALSE);
    }

    property = ALLOC(len);

    if (NULL == property)
    {
        return (FALSE);
    }

    cr = CM_Get_DevNode_Registry_Property(DeviceInstance,
                                         CM_DRP_COMPATIBLEIDS,
                                         NULL,
                                         property,
                                         &len,
                                         0);

    if (CR_SUCCESS != cr) 
    {
        FREE(property);
        return (FALSE);
    }

    //
    // Successfully got the compatible ids, now search them
    //

    *IsComposite = FALSE;
    for (walk = property; *walk != '\0'; walk += (lstrlen(walk)+1))
    {
        if (0 == _stricmp(walk, USB_COMPOSITE_ID)) 
        {
            *IsComposite = TRUE;
            break;
        }
    }

    FREE(property);

    //
    // If not a composite, just return with the number of children = 0
    //

    if (!*IsComposite)
    {
        *NumberChildren = 0;
        
        return (TRUE);
    }

    //
    // If it is a composite device, count the number of child nodes
    //

    cr = CM_Get_Child(&child,
                      DeviceInstance,
                      0);

    //
    // This is bad, there should be at least one child
    //

    if (CR_SUCCESS != cr)
    {
        return (FALSE);
    }

    //
    // OK, there are child nodes for this device which means it's a composite
    //  Find out how many child nodes there are...This should be the number
    //  of interfaces that were enumerated by the parent device.
    //
    
    *NumberChildren = 1;
    
    while (1)
    {
        cr = CM_Get_Sibling(&nextChild, child, 0);

        //
        // Once we get this return code, we've determined the number of
        //  children
        //

        if (CR_NO_SUCH_DEVNODE == cr)
        {
            return (TRUE);
        }

        if (CR_SUCCESS == cr)
        {
            (*NumberChildren)++;
            child = nextChild;
        }
        else 
        {
            //
            // This is some error that we are not expecting...
            //  return FALSE again.
            //

            return (FALSE);
        }
    }
    return (FALSE);
}
    

//*****************************************************************************
//
// CreateUSBDeviceNode()
//
//*****************************************************************************

PUSB_DEVICE_NODE 
CreateUSBDeviceNode(
    IN  USB_DEVICE_NODE_TYPE    NodeType,
    IN  ULONG                   NumberOfChildren
)
{
    PUSB_DEVICE_NODE    newNode;
    ULONG               index;

    newNode = ALLOC(sizeof(USB_DEVICE_NODE) + 
                       NumberOfChildren * sizeof(PUSB_DEVICE_NODE));

    if (NULL != newNode)
    {
        newNode -> NodeType              = NodeType;
        newNode -> SymbolicLink          = NULL;
        newNode -> Description           = NULL;
        newNode -> Parent                = NULL;
        newNode -> NodeInformation       = NULL;
        newNode -> ConnectionInformation = NULL;
        newNode -> DeviceInstance        = 0;
        newNode -> DeviceStatus          = 0;
        newNode -> DeviceProblem         = 0;
        newNode -> HCHandle              = INVALID_HANDLE_VALUE;
        newNode -> NumberOfChildren      = NumberOfChildren;
       
        
        for (index = 0; index < NumberOfChildren; index++) 
        {
            newNode -> Children[index] = NULL;
        }
    }

    return (newNode);
}

//*****************************************************************************
//
// DestroyUSBDeviceNode()
//
//*****************************************************************************

BOOLEAN
DestroyUSBDeviceNode(
    IN  PUSB_DEVICE_NODE    Node,
    IN  PVOID               Context
)
{
    //
    // Do cleanup work for the node...
    //

    if (NULL != Node -> SymbolicLink)
    {
        FREE(Node -> SymbolicLink);
    }

    if (NULL != Node -> Description)
    {
        FREE(Node -> Description);
    }

    if (NULL != Node -> ClassName)
    {
        FREE(Node -> ClassName);
    }

    if (NULL != Node -> NodeInformation)
    {
        FREE(Node -> NodeInformation);
    }

    //
    // Special case for Interface nodes since they share the connection
    //  information with the parent so we don't free it.
    //

    if (NULL != Node -> ConnectionInformation && Node -> NodeType != MIInterface)
    {
        FREE(Node -> ConnectionInformation);
    }

    if (INVALID_HANDLE_VALUE != Node -> HCHandle)
    {
        CloseHandle(Node -> HCHandle);
    }

    FREE(Node);

    return (TRUE);
}

//*****************************************************************************
//
// WriteUSBDeviceNodeToTextFilePre()
//
//*****************************************************************************

BOOLEAN
WriteUSBDeviceNodeToTextFilePre(
    PUSB_DEVICE_NODE        Node,
    PNODE_TO_TEXT_CONTEXT   Context
)
{
    PCHAR   displayString;
    DWORD   nBytes;
    BOOL    success;
    ULONG   indent;

    //
    // Initialize displayString to point to the beginning of the buffer
    //

    displayString = &(buf[0]);

    //
    // Indent the string first
    //

    indent = Context -> Indentation;

    if (indent > 0)
    {
        FillMemory(displayString, indent, ' '); 
    }

    displayString = &buf[indent];
    *displayString = '\0';
    
    //
    // Check for an error code on the node.  If there is a problem, indicate
    //  an error in the display string.
    //

    //
    // Add the node connection information if the node is not a composite
    //  interface.  If a composite interface, this information has already
    //  been displayed for the parent.
    //

    if (Node -> ConnectionInformation && MIInterface != Node -> NodeType) 
    {
        CHAR    str[32];

        wsprintf(str,
                 "[Port%d] ", 
                 Node -> ConnectionInformation -> ConnectionIndex);

        strcat(displayString, str);

        strcat(displayString, 
               ConnectionStatuses[Node -> ConnectionInformation -> ConnectionStatus]);

        strcat(displayString, ": ");
    }
    else if (MIInterface == Node -> NodeType)
    {
        //
        // If it's an interface on a composite device, display some interface
        //  information.
        //

        strcat(displayString, "[Interface]: ");
    }

    if (0 != Node -> DeviceProblem)
    {
        CHAR    str[10];

        wsprintf(str, "(!:%d) ", Node -> DeviceProblem);

        strcat(displayString, str);
    }

    if (NULL != Node -> Description)
    {
        strcat(displayString, Node -> Description);

        strcat(displayString, " ");
    }

    if (Node -> ConnectionInformation && 
        Node -> ConnectionInformation -> ConnectionStatus == DeviceConnected)
    {
        CHAR    str[32];

        wsprintf(str, 
                 "(VID: %04X, PID: %04X) ", 
                 Node -> ConnectionInformation -> DeviceDescriptor.idVendor,
                 Node -> ConnectionInformation -> DeviceDescriptor.idProduct);

        strcat(displayString, str);

        if (Node -> ClassName)
        {
            strcat(displayString, "(Class: ");
        
            strcat(displayString, Node -> ClassName);
        
            strcat(displayString, ")");
        }
    }

    if (Node -> NodeType == MIParent)
    {
        CHAR    str[40];

        wsprintf(str, 
                 " (Composite: %d interfaces)", 
                 Node -> NumberOfChildren);

        strcat (displayString, str);

    }

    strcat(displayString, "\r\n");

    success = WriteFile(Context -> File,
                        buf,
                        strlen(buf),
                        &nBytes,
                        NULL);

    //
    // Increment the indentation for the children
    //

    Context -> Indentation += INDENT_SIZE;

    return (success);
}

//*****************************************************************************
//
// WriteUSBDeviceNodeToTextFilePost()
//
//*****************************************************************************

BOOLEAN
WriteUSBDeviceNodeToTextFilePost(
    PUSB_DEVICE_NODE        Node,
    PNODE_TO_TEXT_CONTEXT   Context
)
{
    Context -> Indentation -= INDENT_SIZE;

    return (TRUE);
}

//*****************************************************************************
//
// WalkUSBDeviceNode
//
//*****************************************************************************

BOOLEAN
WalkUSBDeviceNode(
    IN  PUSB_DEVICE_NODE            Node,
    IN  PUSB_DEVICE_NODE_CALLBACK   PreWalkCallback,
    IN  PUSB_DEVICE_NODE_CALLBACK   PostWalkCallback,
    IN  PVOID                       Context
)
{
    BOOLEAN continueWalk;
    ULONG   index;

    //
    // In walking with a USB device node, the following steps are going to
    //  be performed:
    //
    //  1) Calling the PreWalkCallback if it exists and getting continuation
    //      status to determine if walk should proceed.
    //
    //  2) If walk proceeds, recursively call WalkUSBDeviceNode() on all
    //      child nodes if continuation status is positive.
    //  
    //  3) Call the PostWalkCallback function if we are to proceed further
    //      and once again get continuation status.
    //
    //  4) Return the continuation status
    //

    //
    // Step 1
    //

    continueWalk = TRUE;

    if (NULL != PreWalkCallback)
    {
        continueWalk = (*PreWalkCallback)(Node, Context);
    }

    //
    // Step 2
    //

    for (index = 0; index < Node -> NumberOfChildren && continueWalk; index++)
    {
        continueWalk = WalkUSBDeviceNode(Node -> Children[index], 
                                         PreWalkCallback, 
                                         PostWalkCallback,
                                         Context);

    }

    //
    // Step 3
    //

    if (continueWalk && NULL != PostWalkCallback)
    {
        continueWalk = (*PostWalkCallback)(Node, Context);
    }

    //
    // Step 4
    //

    return (continueWalk);
}

BOOL
EnumerateHostController(
    IN  PUSB_DEVICE_NODE    HCNode
)
{
    PUSB_DEVICE_NODE    rootHubNode;
    PCHAR               rootHubName;
    DEVINST             rootHubInstance;
    CONFIGRET           cr;

    //
    // Get the device instance for the root hub.  It is assumed that this
    //  is the first child of the host controller instance.  
    //

    cr = CM_Get_Child(&rootHubInstance,
                      HCNode -> DeviceInstance,
                      0);

    if (CR_SUCCESS != cr) 
    {
        rootHubInstance = 0;
    }
    
    //
    // Get the root hub name 
    //

    rootHubName = GetRootHubName(HCNode -> HCHandle);

    if (NULL == rootHubName)
    {
        return (FALSE);
    }

    //
    // Enumerate the hub and in the process creating a root hub node if
    //  successful...At this point, just mark the device instance, device
    //  status, and device problem fields as 0.  This may not be exactly what
    //  we want to do in the future.
    //

    rootHubNode = EnumerateHub(rootHubInstance, rootHubName, NULL);

    //
    // If not successful, free the rootHubName and return FALSE
    //

    if (NULL == rootHubNode)
    {
        FREE(rootHubName);

        goto EnumerateHostController_Exit;
    }

    //
    // Otherwise, add the new node to the tree
    //

    rootHubNode -> Parent      = HCNode;

    HCNode -> Children[0]      = rootHubNode;
    HCNode -> NumberOfChildren = 1;

EnumerateHostController_Exit:

    return (NULL != rootHubNode);
}


PUSB_DEVICE_NODE
EnumerateNonHub(
    DEVINST                             DeviceInstance,
    PUSB_NODE_CONNECTION_INFORMATION    ConnectionInfo
)
{
    PUSB_DEVICE_NODE        deviceNode;
    BOOL                    success;

    //
    // Allocate a device node
    //

    deviceNode = CreateUSBDeviceNode(Device, 0);

    if (NULL == deviceNode)
    {
        goto EnumerateNonHub_Exit;
    }

    //
    // Change the default settings for a USB Device node to contain the 
    //  necessary device info
    //

    deviceNode -> ConnectionInformation = ConnectionInfo;
    deviceNode -> DeviceInstance        = DeviceInstance;

    success = GetDeviceInfo(DeviceInstance, FALSE, deviceNode);

    if (!success) 
    {
        DestroyUSBDeviceNode(deviceNode, NULL);

        deviceNode = NULL;
    }

EnumerateNonHub_Exit:

    return (deviceNode);
}

PUSB_DEVICE_NODE
EnumerateCompositeDevice(
    DEVINST                             DeviceInstance,
    PUSB_NODE_CONNECTION_INFORMATION    ConnectionInfo,
    ULONG                               NumberInterfaces
)
{
    PUSB_DEVICE_NODE        compositeNode;
    PUSB_DEVICE_NODE        deviceNode;
    DEVINST                 childInstance;
    DEVINST                 nextChild;
    ULONG                   index;
    BOOL                    success;
    CONFIGRET               cr;
    ULONG                   nBytes;

    //
    // Initialize the memory pointer variables to NULL to properly 
    //   cleanup on exit
    //

    success    = FALSE;    

    //
    // Allocate a device node
    //

    compositeNode = CreateUSBDeviceNode(MIParent, NumberInterfaces);

    if (NULL == compositeNode)
    {
        goto EnumerateCompositeDevice_Exit;
    }

    //
    // Initialize the number of children for the deviceNode to zero
    //  since this is the running count of successfully enumerated
    //  ports.  If an error occurs somewhere in this function, we'll
    //  need this information to cleanup the previously allocated nodes
    //

    compositeNode -> NumberOfChildren      = 0;
    compositeNode -> ConnectionInformation = ConnectionInfo;
    compositeNode -> DeviceInstance        = DeviceInstance;

    success = GetDeviceInfo(DeviceInstance, FALSE, compositeNode);

    if (!success)
    {
        DestroyUSBDeviceNode(compositeNode, NULL);

        compositeNode = NULL;

        goto EnumerateCompositeDevice_Exit;
    }

    //
    // Start enumerating the interfaces...Begin by getting the first child
    //  For each child, we need to get device name, class name, and device
    //  description.  Then get the next sibling..
    //

    cr = CM_Get_Child(&childInstance, DeviceInstance, 0);
     
    for (index = 1; index <= NumberInterfaces && (CR_SUCCESS == cr); index++) 
    {
        //
        // If the device instance is valid, try to get the device 
        //  description, the class name for the interface, along with
        //  a device name for the interface.  
        // 

        deviceNode = CreateUSBDeviceNode(MIInterface, 0);

        //
        // If we couldn't create a device node, bail out as an error
        //

        if (NULL == deviceNode)
        {
            success = FALSE;
            break;
        }
   
        //
        // Add the device node to the tree
        //

        deviceNode -> Parent                = compositeNode;
        deviceNode -> ConnectionInformation = ConnectionInfo;
        deviceNode -> DeviceInstance        = childInstance;

        success = GetDeviceInfo(childInstance, FALSE, deviceNode);

        if (!success)
        {
            break;
        }

        //
        // Store the new interface node in the composite 
        //   node's list of children
        //

        compositeNode -> Children[compositeNode -> NumberOfChildren] = deviceNode;
        compositeNode -> NumberOfChildren++;

        //
        // Get the next sibling
        //

        cr = CM_Get_Sibling(&childInstance, childInstance, 0);
    }
    
    //
    // If the case is true, then we succesfully got the information for 
    //  all interfaces, so set success appropriately.
    //

    if (CR_NO_SUCH_DEVNODE == cr && index > NumberInterfaces)
    {
        success = TRUE;
    }

EnumerateCompositeDevice_Exit:

    //
    // If there was an error, cycle through all the device nodes that were
    //  successfully created during this enumeration process and clean them
    //  up.
    //

    if (!success && NULL != compositeNode)
    {
        for (index = 0; index < compositeNode -> NumberOfChildren; index++)
        {
            DestroyUSBDeviceNode(compositeNode -> Children[index], NULL);
        }

        compositeNode -> NumberOfChildren = 0;

        DestroyUSBDeviceNode(compositeNode, NULL);

        compositeNode = NULL;
    }

    return (compositeNode);
}

PUSB_DEVICE_NODE
EnumerateHub(
    DEVINST                             DeviceInstance,
    PCHAR                               HubName,
    PUSB_NODE_CONNECTION_INFORMATION    ConnectionInfo
)
{
    PUSB_NODE_INFORMATION   hubNodeInfo;
    PUSB_DEVICE_NODE        hubNode;
    HANDLE                  hubHandle;
    PCHAR                   deviceName;
    ULONG                   nBytes;
    ULONG                   nPorts;
    BOOL                    success;

    //
    // Initialize the handle value since it may need to be closed on
    //  exiting the function.  Also initialize the hubNode to NULL since
    //  this is what is returned by the function and NULL will indicate an
    //  error.
    //

    hubHandle   = INVALID_HANDLE_VALUE;
    hubNode     = NULL;

    //
    // Create the full device name for the hub name passed in...
    //

    deviceName = (PCHAR) ALLOC(strlen(HubName) + sizeof("\\\\.\\"));

    if (NULL == deviceName)
    {
        goto EnumerateHub_Exit;
    }

    wsprintf(deviceName, "\\\\.\\%s", HubName);

    //
    // Open a handle to the hub device
    //

    hubHandle = CreateFile(deviceName,
                           GENERIC_WRITE,
                           FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);

    //
    // Free the device name, it is no longer needed
    //

    FREE(deviceName);

    if (INVALID_HANDLE_VALUE == hubHandle)
    {
        goto EnumerateHub_Exit;
    }

    //
    // Allocate space for the node information
    //

    hubNodeInfo = ALLOC(sizeof(USB_NODE_INFORMATION));

    if (NULL == hubNodeInfo) 
    {
        goto EnumerateHub_Exit;
    }

    //
    // Query the hub for the node information
    //

    success = DeviceIoControl(hubHandle,
                              IOCTL_USB_GET_NODE_INFORMATION,
                              hubNodeInfo,
                              sizeof(USB_NODE_INFORMATION),
                              hubNodeInfo,
                              sizeof(USB_NODE_INFORMATION),
                              &nBytes,
                              NULL);
    
    if (!success)
    {
        FREE(hubNodeInfo);

        goto EnumerateHub_Exit;
    }

    //
    // If we got this far, we now have the hub node information.  This tells
    //  us how many ports we have on this hub allowing for the creation of 
    //  a new device node to represent the hub in the tree.
    //

    nPorts = hubNodeInfo -> u.HubInformation.HubDescriptor.bNumberOfPorts;

    hubNode = CreateUSBDeviceNode(Hub, nPorts);

    if (NULL == hubNode)
    {
        success = FALSE;

        FREE(hubNodeInfo);

        goto EnumerateHub_Exit;
    }

    //
    // Enumerate each of the ports
    //

    success = EnumerateHubPorts(hubNode, hubHandle, nPorts);

    if (!success)
    {
        FREE(hubNodeInfo);

        goto EnumerateHub_Exit;
    }

    //
    // Change the default settings for a USB Device node to contain the 
    //  necessary hub info
    //

    hubNode -> SymbolicLink          = HubName;
    hubNode -> NodeInformation       = hubNodeInfo;
    hubNode -> ConnectionInformation = ConnectionInfo;
    hubNode -> DeviceInstance        = DeviceInstance;

    success = GetDeviceInfo(DeviceInstance, TRUE, hubNode);

EnumerateHub_Exit:

    if (!success)
    {
        if (NULL != hubNode)
        {
            DestroyUSBDeviceNode(hubNode, NULL);
        
            hubNode = NULL;
        }
    }    

    if (INVALID_HANDLE_VALUE != hubHandle)
    {
        CloseHandle(hubHandle);
    }

    return (hubNode);
}

BOOL
EnumerateHubPorts(
    IN  PUSB_DEVICE_NODE    HubNode,
    IN  HANDLE              HubHandle,
    IN  ULONG               NumberOfPorts
)
{
    PUSB_NODE_CONNECTION_INFORMATION    connectInfo;
    PUSB_DEVICE_NODE                    deviceNode;
    DEVINST                             deviceInstance;
    ULONG                               index;
    BOOL                                success;
    BOOL                                isCompositeDevice;
    PCHAR                               driverKeyName;
    PCHAR                               hubName;
    ULONG                               nBytes;
    ULONG                               numChildInterfaces;
    CONFIGRET                           cr;
    ULONG                               deviceStatus;
    ULONG                               deviceProblem;

    //
    // Initialize the memory pointer variables to NULL to properly 
    //   cleanup on exit
    //

    driverKeyName = NULL;
    hubName       = NULL;
    connectInfo   = NULL;

    //
    // Initialize the number of children for the hubNode to zero
    //  since this is the running count of successfully enumerated
    //  ports.  If an error occurs somewhere in this function, we'll
    //  need this information to cleanup the previously allocated nodes
    //

    HubNode -> NumberOfChildren = 0;

    //
    // Start enumerating the ports...The connection info used by the hub 
    //  driver references the hub ports using 1 based indexing instead of
    //  0 based
    //

    for (index = 1; index <= NumberOfPorts; index++) 
    {
        //
        // Allocate space for the connection information...We don't care about
        //  the open pipes so just allocate the default size
        //

        connectInfo = ALLOC(sizeof(USB_NODE_CONNECTION_INFORMATION));

        //
        // If there's a failure, indicate it as such
        //

        if (NULL == connectInfo)
        {
            success = FALSE;
            break;
        }

        //
        // Setup the connection info for the current port being queried
        //

        connectInfo -> ConnectionIndex = index;

        // 
        // Query the hub for the connection info
        //

        success = DeviceIoControl(HubHandle,
                                  IOCTL_USB_GET_NODE_CONNECTION_INFORMATION,
                                  connectInfo,
                                  sizeof(USB_NODE_CONNECTION_INFORMATION),
                                  connectInfo,
                                  sizeof(USB_NODE_CONNECTION_INFORMATION),
                                  &nBytes,
                                  NULL);

        if (!success)
        {
            break;
        }

        //
        // If no device is connected, just create a default port
        //  node with just the connection status
        //

        if (NoDeviceConnected == connectInfo -> ConnectionStatus)
        {
            deviceNode = CreateUSBDeviceNode(EmptyPort, 0);

            if (NULL == deviceNode)
            {
                success = FALSE;
                break;
            }

            if (!GetDeviceInfo(0, FALSE, deviceNode))
            {
                DestroyUSBDeviceNode(deviceNode, NULL);

                success = FALSE;

                break;
            }

            deviceNode -> ConnectionInformation = connectInfo;
        }
        else 
        {
            //
            // Otherwise, a device is connected, get the device instance
            //
            
            driverKeyName = GetDriverKeyName(HubHandle, index);
            
            //
            // Get a handle to the device instance that could be used in
            //  future calls for registry information
            //

            if (NULL != driverKeyName)
            {
                success = DriverNameToDeviceInstance(driverKeyName, 
                                                     &deviceInstance);
            }
            else
            {
                deviceInstance = 0;
            }

            //
            // If the device instance is valid, determine if this
            //  device is a composite device.  
            // 

            isCompositeDevice = FALSE;

            if (0 != deviceInstance)
            {

                //
                // Get the symbolic link (HubName) for the hub here since
                //  we need the handle to the hub and the index.  All other
                //  symlinks will be retrieved when the node is created
                //  in the specific node enumeration code.  This isn't the
                //  most elegant way but it works.
                //

                if (connectInfo -> DeviceIsHub) 
                {
                    hubName = GetExternalHubName(HubHandle, index);

                    if (NULL == hubName)
                    {
                        hubName = ALLOC(sizeof(DEFAULT_HUB_NAME));
        
                        if (NULL == hubName)
                        {
                            success = FALSE;

                            FREE(driverKeyName);

                            break;
                        }
        
                        strcpy(hubName, DEFAULT_HUB_NAME);
                    }
                }
                else
                {
                    // 
                    // If not a hub, need to determine if this is a composite
                    //  device or not.
                    //

                    success = IsCompositeDevice(deviceInstance,
                                                &isCompositeDevice,
                                                &numChildInterfaces);

                    //
                    // If an error occurred above, then at this point
                    //  we want to just mark this as a non-composite device
                    //

                    if (!success) 
                    {
                        isCompositeDevice = FALSE;
                    }
                }
            }
            
            if (NULL != driverKeyName)
            {
                FREE(driverKeyName);
            }

            //
            // If it is a hub, enumerate it as such.
            //   Otherwise, enumerate as a non-hub device
            //
            
            if (connectInfo -> DeviceIsHub)
            {
                //
                // Enumerate the hub...
                //
            
                deviceNode = EnumerateHub(deviceInstance,
                                          hubName,
                                          connectInfo);
            }
            else if (isCompositeDevice)
            {
                //
                // If a composite device, call the specific enumeration
                //  routine.
                //

                deviceNode = EnumerateCompositeDevice(deviceInstance,
                                                      connectInfo,
                                                      numChildInterfaces);
            }
            else 
            {
                //
                // Not a hub or composite device, enumerate as such
                //
                                             
                deviceNode = EnumerateNonHub(deviceInstance, connectInfo);
            
            }
        }

        //
        // If we couldn't create a device node, bail out as an error
        //

        if (NULL == deviceNode)
        {
            success = FALSE;
            break;
        }
   
        //
        // Add the device node to the tree
        //

        deviceNode -> Parent = HubNode;

        HubNode -> Children[HubNode -> NumberOfChildren] = deviceNode;
        HubNode -> NumberOfChildren++;

        //
        // If we get to this point, then the device node was properly set
        //  up and we stored these three pointers into the device node which
        //  means we don't want to free them on exit.
        //

        hubName     = NULL;
        connectInfo = NULL;
    }
    
    //
    // Cleanup any previously allocated structures that may need to be freed
    //

    if (NULL != connectInfo)
    {
        FREE(connectInfo);
    }

    if (NULL != hubName)
    {
        FREE(hubName);
    }

    //
    // If there was an error, cycle through all the device nodes that were
    //  successfully created during this enumeration process and clean them
    //  up.
    //

    if (!success)
    {
        for (index = 0; index < HubNode -> NumberOfChildren; index++)
        {
            DestroyUSBDeviceNode(HubNode -> Children[index], NULL);
        }

        HubNode -> NumberOfChildren = 0;
    }

    return (success);
}

//*****************************************************************************
//
// WriteUSBDeviceNodeToFile()
//
//*****************************************************************************

BOOLEAN 
WriteUSBDeviceNodeToFile(
    IN  PUSB_DEVICE_NODE    Node,
    IN  HANDLE              File
)
{
    //
    // To write a node to the file, we will write a node completely to the 
    //  disk and then write each of the children to disk.  The information 
    //  for each node data packet that is written to disk contains two parts,
    //  the fixed length node header and the variable length data.  Each 
    //  part is laid out as follows:
    //
    //
    //          Node Header
    //          -----------
    //          NodeType 
    //          NumberOfChildren
    //          NodeInformationExists
    //          ConnectionInformationExists
    //          SymbolicLinkLength
    //          DescriptionLength
    //          ClassNameLength
    //          DeviceStatus
    //          DeviceProblem
    //
    //          Variable Data
    //          -------------
    //          SymbolicLink
    //          Description
    //          ClassName
    //          NodeInformation
    //          ConnectionInformation
    //

    FILE_NODE_HEADER    nodeHeader;
    PCHAR               dataBuffer;
    PCHAR               bufferWalk;
    BOOL                success;
    ULONG               bufferLength;
    ULONG               variableLength;
    ULONG               nBytes;
    ULONG               index;

    //
    // Create the header for this node
    //

    nodeHeader.NodeType             = Node -> NodeType;
    nodeHeader.NumberOfChildren     = (UCHAR) Node -> NumberOfChildren;
    nodeHeader.NodeInfoExists       = (Node -> NodeInformation != NULL);
    nodeHeader.ConnectionInfoExists = (Node -> ConnectionInformation != NULL);

    nodeHeader.SymbolicLinkLength   = (NULL != Node -> SymbolicLink) 
                                           ? strlen(Node -> SymbolicLink)+1 : 0;

    nodeHeader.DescriptionLength    = (NULL != Node -> Description)
                                           ? strlen(Node -> Description)+1 : 0;

    nodeHeader.ClassNameLength      = (NULL != Node -> ClassName)
                                           ? strlen(Node -> ClassName)+1 : 0;

    nodeHeader.DeviceStatus         = Node -> DeviceStatus;
    nodeHeader.DeviceProblem        = Node -> DeviceProblem;

    //
    // Calculate the size of the variable length section
    //

    variableLength = CalculateNodeVariableLength(nodeHeader);

    bufferLength = sizeof(FILE_NODE_HEADER) + variableLength;

    //
    // Allocate a data buffer to hold all the information for this node
    //

    dataBuffer = ALLOC(bufferLength);

    if (NULL == dataBuffer)
    {
        success = FALSE;
        goto WriteUSBDeviceNodeToFile_Exit;
    }

    //
    // Copy the necessary data to the buffer
    //

    bufferWalk = dataBuffer;

    CopyMemory(bufferWalk, &nodeHeader, sizeof(FILE_NODE_HEADER));
    bufferWalk += sizeof(FILE_NODE_HEADER);

    if (nodeHeader.SymbolicLinkLength)
    {
        CopyMemory(bufferWalk, 
                   Node -> SymbolicLink, 
                   nodeHeader.SymbolicLinkLength);

        bufferWalk += nodeHeader.SymbolicLinkLength;
    }

    if (nodeHeader.DescriptionLength)
    {
        CopyMemory(bufferWalk, 
                   Node -> Description, 
                   nodeHeader.DescriptionLength);

        bufferWalk += nodeHeader.DescriptionLength;
    }

    if (nodeHeader.ClassNameLength)
    {
        CopyMemory(bufferWalk, 
                   Node -> ClassName,
                   nodeHeader.ClassNameLength);

        bufferWalk += nodeHeader.ClassNameLength;
    }

    if (nodeHeader.NodeInfoExists)
    {
        CopyMemory(bufferWalk,
                   Node -> NodeInformation,
                   sizeof(USB_NODE_INFORMATION));

        bufferWalk += sizeof(USB_NODE_INFORMATION);
    }

    if (nodeHeader.ConnectionInfoExists)
    {
        CopyMemory(bufferWalk,
                   Node -> ConnectionInformation,
                   sizeof(USB_NODE_CONNECTION_INFORMATION));
    }

    success = WriteFile(File,
                        dataBuffer,
                        bufferLength,
                        &nBytes,
                        NULL);

WriteUSBDeviceNodeToFile_Exit:

    if (NULL != dataBuffer)
    {
        FREE(dataBuffer);
    }

    return (success);
}

//*****************************************************************************
//
// ReadUSBDeviceNodeFromFile()
//
//*****************************************************************************

PUSB_DEVICE_NODE 
ReadUSBDeviceNodeFromFile(
    IN  HANDLE  File
)
{
    PUSB_NODE_INFORMATION               nodeInfo;
    PUSB_NODE_CONNECTION_INFORMATION    connectInfo;
    PUSB_DEVICE_NODE                    deviceNode;
    PUSB_DEVICE_NODE                    childNode;
    FILE_NODE_HEADER                    nodeHeader;
    BOOL                                success;
    ULONG                               variableLength;
    ULONG                               nBytes;
    ULONG                               index;

    PCHAR                               dataBuffer;
    PCHAR                               bufferWalk;
    PCHAR                               symbolicLink;
    PCHAR                               description;
    PCHAR                               className;

    //
    // Initialize the deviceNode to NULL in case of an error
    //

    deviceNode   = NULL;
    dataBuffer   = NULL;
    symbolicLink = NULL;
    description  = NULL;
    className    = NULL;
    nodeInfo     = NULL;
    connectInfo  = NULL;

    //
    // Read in the node header
    //

    success = ReadFile(File,
                       &nodeHeader,
                       sizeof(nodeHeader),
                       &nBytes,
                       NULL);

    if (!success)
    {
        goto ReadUSBDeviceNodeFromFile_Exit;
    }

    variableLength = CalculateNodeVariableLength(nodeHeader);

    //
    // Allocate space for a data buffer 
    //

    dataBuffer = ALLOC(variableLength);
    
    if (NULL == dataBuffer)
    {
        goto ReadUSBDeviceNodeFromFile_Exit;
    }
   
    //
    // Read in the variable length portion of the node
    //

    success = ReadFile(File,
                       dataBuffer,
                       variableLength,
                       &nBytes,
                       NULL);

    if (!success)
    {
        goto ReadUSBDeviceNodeFromFile_Exit;
    }

    //
    // Allocate space to hold all the variable length information
    //  for the device node
    //

    if (nodeHeader.SymbolicLinkLength)
    {
        symbolicLink = ALLOC(nodeHeader.SymbolicLinkLength);

        if (NULL == symbolicLink)
        {
            goto ReadUSBDeviceNodeFromFile_Exit;
        }
    }

    if (nodeHeader.DescriptionLength)
    {
        description = ALLOC(nodeHeader.DescriptionLength);

        if (NULL == description)
        {
            goto ReadUSBDeviceNodeFromFile_Exit;
        }
    }

    if (nodeHeader.ClassNameLength)
    {
        className = ALLOC(nodeHeader.ClassNameLength);

        if (NULL == className)
        {
            goto ReadUSBDeviceNodeFromFile_Exit;
        }
    }

    if (nodeHeader.NodeInfoExists)
    {
        nodeInfo   = ALLOC(sizeof(USB_NODE_INFORMATION));

        if (NULL == nodeInfo)
        {
            goto ReadUSBDeviceNodeFromFile_Exit;
        }
    }

    if (nodeHeader.ConnectionInfoExists)
    {
        connectInfo   = ALLOC(sizeof(USB_NODE_CONNECTION_INFORMATION));

        if (NULL == connectInfo)
        {
            goto ReadUSBDeviceNodeFromFile_Exit;
        }
    }

    //
    // Create the device node itself
    //

    deviceNode = CreateUSBDeviceNode(nodeHeader.NodeType, 
                                     nodeHeader.NumberOfChildren);

    if (NULL == deviceNode) 
    {
        goto ReadUSBDeviceNodeFromFile_Exit;
    }

    //
    // Setup the deviceNode structure and copy the variable data into the 
    //  buffers that have been allocated for that data
    //

    bufferWalk = dataBuffer;

    if (nodeHeader.SymbolicLinkLength)
    {
        strcpy(symbolicLink, bufferWalk);

        bufferWalk += nodeHeader.SymbolicLinkLength;
    }

    if (nodeHeader.DescriptionLength)
    {
        strcpy(description, bufferWalk);

        bufferWalk += nodeHeader.DescriptionLength;
    }

    if (nodeHeader.ClassNameLength)
    {
        strcpy(className, bufferWalk);

        bufferWalk += nodeHeader.ClassNameLength;
    }

    if (nodeHeader.NodeInfoExists)
    {
        memcpy(nodeInfo, bufferWalk, sizeof(USB_NODE_INFORMATION));

        bufferWalk += sizeof(USB_NODE_INFORMATION);
    }

    if (nodeHeader.ConnectionInfoExists)
    {
        memcpy(connectInfo, bufferWalk, sizeof(USB_NODE_CONNECTION_INFORMATION));
    }

    //
    // Setup the fields with the new values
    //

    deviceNode -> SymbolicLink          = symbolicLink;
    deviceNode -> Description           = description;
    deviceNode -> ClassName             = className;
    deviceNode -> NodeInformation       = nodeInfo;
    deviceNode -> ConnectionInformation = connectInfo;
    deviceNode -> DeviceInstance        = 0;
    deviceNode -> DeviceStatus          = nodeHeader.DeviceStatus;
    deviceNode -> DeviceProblem         = nodeHeader.DeviceProblem;

    //
    // NULL the local variables so we don't double free them
    //

    symbolicLink = NULL;
    description  = NULL;
    className    = NULL;
    connectInfo  = NULL;
    nodeInfo     = NULL;

    //
    // Create the child nodes and add to the tree if successful
    //

    for (index = 0; index < deviceNode -> NumberOfChildren; index++)
    {
        childNode = ReadUSBDeviceNodeFromFile(File);

        //
        // If an error occurred, let's bail.  But first the deviceNode
        //  must be destoryed and NULL'd
        //

        if (NULL == childNode)
        {
            deviceNode -> NumberOfChildren = index;

            DestroyUSBDeviceNode(deviceNode, NULL);

            deviceNode = NULL;

            break;
        }

        //
        // Add the child node to the deviceNode
        //

        childNode -> Parent = deviceNode;

        deviceNode -> Children[index] = childNode;
    }

ReadUSBDeviceNodeFromFile_Exit:

    //
    // Do any cleanup that might be necessary
    //

    if (NULL != symbolicLink)
    {
        FREE(symbolicLink);
    }

    if (NULL != description)
    {
        FREE(description);
    }

    if (NULL != className)
    {
        FREE(className);
    }

    if (NULL != nodeInfo)
    {
        FREE(nodeInfo);
    }

    if (NULL != connectInfo)
    {
        FREE(connectInfo);
    }

    if (NULL != dataBuffer)
    {
        FREE(dataBuffer);
    }

    return (deviceNode);
}

//*****************************************************************************
//
// CompareUSBDeviceNodes()
//
//*****************************************************************************

VOID
CompareUSBDeviceNodes(
    IN  PUSB_DEVICE_NODE    Node1,
    IN  PUSB_DEVICE_NODE    Node2,
    OUT PULONG              NumberOfDifferences,
    OUT PNODE_PAIR_LIST     NodeDifferenceList
)
{
    ULONG   index;

    //
    // Compare the types of the two nodes and the number of children.
    //   If no match, they can't be the same.
    //

    if (Node1 -> NodeType != Node2 -> NodeType ||
             Node1 -> NumberOfChildren != Node2 -> NumberOfChildren)
    {
        goto CompareUSBDeviceNodes_NoMatch;
    }

    //
    // The node's DeviceProblem code should also match.  The assumption is that
    //  if the node was once problematic, it should always be problematic.  
    //  Obviously, if it was operating correctly and now isn't that's a definite
    //  error.  Likewise, if there was previously an error, that error should
    //  continue to persist.  If the device starts working, why wasn't it working
    //  the first time around.
    //
    // The jury is still out on the status field.  Investigation needs to be 
    //  done to insure that all flags don't change across enumerations.  It
    //  appears by the definition of the flags in CFG.H that some may actually
    //  be different.  Until that thought is proven wrong, avoid checking 
    //  the status field as well.
    //

    if (Node1 -> DeviceProblem != Node2 -> DeviceProblem)
    {
        goto CompareUSBDeviceNodes_NoMatch;
    }

    //
    // Now do more specific compare based on the type of the nodes
    //

    switch (Node1 -> NodeType)
    {
        case Computer:
        case HostController:

            //
            // If the child count matched we are OK, proceed with comparing
            //  the children
            //

            break;

        case Hub:

            //
            // For a hub, we want to compare the VID/PID combination, if
            //  an external hub.  If that checks out then check the children
            //
            
            if (NULL == Node1 -> ConnectionInformation)
            {
                // 
                // Root hub...Node2 also better have this field NULL
                //

                if (NULL != Node2 -> ConnectionInformation)
                {
                    goto CompareUSBDeviceNodes_NoMatch;
                }

            }
            else 
            {
                //
                // External hub on node1...Node2 had better be an
                //  external hub as well.
                //

                if (NULL == Node2 -> ConnectionInformation)
                {
                    goto CompareUSBDeviceNodes_NoMatch;
                }
                    
                //
                // OK, now compare the VID/PID of these devices
                //

                if ( (Node1 -> ConnectionInformation->DeviceDescriptor.idVendor !=
                        Node2 -> ConnectionInformation->DeviceDescriptor.idVendor) ||
                     (Node1 -> ConnectionInformation->DeviceDescriptor.idProduct !=
                        Node2 -> ConnectionInformation->DeviceDescriptor.idProduct))
                {        
                    goto CompareUSBDeviceNodes_NoMatch;
                }
            }

            //
            // If we got this far, need to compare the children though
            //  

            break;

        case MIParent:

            //
            // For a parent the VID/PID should be the same as well as the 
            //  NumberOfInterfaces for the parent
            //

            if ( (Node1 -> ConnectionInformation->DeviceDescriptor.idVendor !=
                    Node2 -> ConnectionInformation->DeviceDescriptor.idVendor) ||
                 (Node1 -> ConnectionInformation->DeviceDescriptor.idProduct !=
                    Node2 -> ConnectionInformation->DeviceDescriptor.idProduct))
            {        
                goto CompareUSBDeviceNodes_NoMatch;
            }

            //
            // Compare the number of child interfaces...
            //

            if (Node1 -> NumberOfChildren != Node2 -> NumberOfChildren)
            {
                goto CompareUSBDeviceNodes_NoMatch;
            }
            break;

        case Device:
        case MIInterface:

            //
            // For a device the VID/PID should be the same 
            //

            if ( (Node1 -> ConnectionInformation->DeviceDescriptor.idVendor !=
                    Node2 -> ConnectionInformation->DeviceDescriptor.idVendor) ||
                 (Node1 -> ConnectionInformation->DeviceDescriptor.idProduct !=
                    Node2 -> ConnectionInformation->DeviceDescriptor.idProduct))
            {        
                goto CompareUSBDeviceNodes_NoMatch;
            }
            break;

        default:
            break;

    }

    //
    // For all cases, we need to check each of the children for the device
    //  to check the children.
    //

    for (index = 0; index < Node1 -> NumberOfChildren; index++)
    {
        CompareUSBDeviceNodes(Node1 -> Children[index],
                              Node2 -> Children[index],                 
                              NumberOfDifferences,
                              NodeDifferenceList);

    }

    return;

CompareUSBDeviceNodes_NoMatch:

    (*NumberOfDifferences)++;

    AddNodePair(Node1, Node2, NodeDifferenceList);

    return;
}

//*****************************************************************************
//
// AddNodePair()
//
//*****************************************************************************

VOID
AddNodePair(
    IN  PUSB_DEVICE_NODE    Node1,
    IN  PUSB_DEVICE_NODE    Node2,
    IN  PNODE_PAIR_LIST     NodePairList
)
{
    PUSB_DEVICE_NODE        *newList;
    ULONG                   newMaxCount;

    //
    // Check if we need to resize the list
    //

    if (0 != NodePairList -> MaxNodePairs && 
             NodePairList -> MaxNodePairs == NodePairList -> CurrentNodePairs)
    {
        //
        //   Need to allocate some more memory, so let's create a new
        //      list that will hold twice as many pairs
        //

        newMaxCount = 2 * NodePairList -> MaxNodePairs;

        //
        // Maximum count is always the count of node pairs so we
        //  need twice as many node pointers in the list
        //

        newList = ALLOC(newMaxCount * 2 * sizeof(PUSB_DEVICE_NODE));

        //
        // If we couldn't resize, oh well, we won't be able to add
        //  this pair
        //

        if (NULL == newList)
        {
            goto AddNodePair_Exit;
        }

        //
        // Copy the pairs over from the previous list
        //

        CopyMemory(newList, 
                   NodePairList -> NodePairs,
                   NodePairList -> MaxNodePairs * 2 * sizeof(PUSB_DEVICE_NODE));

        //
        // Free the previous list
        //

        FREE(NodePairList -> NodePairs);

        //
        // Save the new maximum value and the pointer to the new list
        //

        NodePairList -> MaxNodePairs = newMaxCount;
        NodePairList -> NodePairs    = newList;
    }

    //
    // Add the new pair and increment the current count
    //

    NodePairList -> NodePairs[NodePairList -> CurrentNodePairs*2]   = Node1;
    NodePairList -> NodePairs[NodePairList -> CurrentNodePairs*2+1] = Node2;

    NodePairList -> CurrentNodePairs++;

AddNodePair_Exit:

    return;
}

//*****************************************************************************
//
// GetRootHubName()
//
//*****************************************************************************

PCHAR GetRootHubName (
    HANDLE HostController
)
{
    BOOL                success;
    ULONG               nBytes;
    USB_ROOT_HUB_NAME   rootHubName;
    PUSB_ROOT_HUB_NAME  rootHubNameW;
    PCHAR               rootHubNameA;

    rootHubNameW = NULL;
    rootHubNameA = NULL;

    //
    // Get the length of the name of the Root Hub attached to the
    // Host Controller
    //

    success = DeviceIoControl(HostController,
                              IOCTL_USB_GET_ROOT_HUB_NAME,
                              0,
                              0,
                              &rootHubName,
                              sizeof(rootHubName),
                              &nBytes,
                              NULL);

    if (!success)
    {
        goto GetRootHubName_Exit;
    }

    //
    // Allocate space to hold the Root Hub name
    //

    nBytes = rootHubName.ActualLength;

    rootHubNameW = ALLOC(nBytes);

    if (rootHubNameW == NULL)
    {
        goto GetRootHubName_Exit;
    }

    //
    // Get the name of the Root Hub attached to the Host Controller
    //

    success = DeviceIoControl(HostController,
                              IOCTL_USB_GET_ROOT_HUB_NAME,
                              NULL,
                              0,
                              rootHubNameW,
                              nBytes,
                              &nBytes,
                              NULL);

    if (!success)
    {
        goto GetRootHubName_Exit;
    }

    //
    // Convert the Root Hub name
    //

    rootHubNameA = WideStrToMultiStr(rootHubNameW->RootHubName);

GetRootHubName_Exit:

    //
    // Free the rootHubNameW structure if it has been allocated
    //

    if (rootHubNameW != NULL)
    {
        FREE(rootHubNameW);
        rootHubNameW = NULL;
    }

    return rootHubNameA;
}

//*****************************************************************************
//
// GetExternalHubName()
//
//*****************************************************************************

PCHAR
GetExternalHubName (
    HANDLE  HubHandle,
    ULONG   ConnectionIndex
)
{
    BOOL                        success;
    ULONG                       nBytes;
    USB_NODE_CONNECTION_NAME    externalHubName;
    PUSB_NODE_CONNECTION_NAME   externalHubNameW;
    PCHAR                       externalHubNameA;

    externalHubNameW = NULL;
    externalHubNameA = NULL;

    ///
    // Get the length of the name of the device hub attached to the
    // specified port.
    //

    externalHubName.ConnectionIndex = ConnectionIndex;

    success = DeviceIoControl(HubHandle,
                              IOCTL_USB_GET_NODE_CONNECTION_NAME,
                              &externalHubName,
                              sizeof(externalHubName),
                              &externalHubName,
                              sizeof(externalHubName),
                              &nBytes,
                              NULL);

    if (!success)
    {
        goto GetExternalHubName_Exit;
    }

    //
    // Allocate space to hold the externalHubName
    //

    nBytes = externalHubName.ActualLength;

    if (nBytes <= sizeof(externalHubName))
    {
        goto GetExternalHubName_Exit;
    }

    externalHubNameW = ALLOC(nBytes);

    if (externalHubNameW == NULL)
    {
        goto GetExternalHubName_Exit;
    }

    //
    // Get the name of the device attached to the specified port
    //

    externalHubNameW -> ConnectionIndex = ConnectionIndex;

    success = DeviceIoControl(HubHandle,
                              IOCTL_USB_GET_NODE_CONNECTION_NAME,
                              externalHubNameW,
                              nBytes,
                              externalHubNameW,
                              nBytes,
                              &nBytes,
                              NULL);

    if (!success)
    {
        goto GetExternalHubName_Exit;
    }

    //
    // Convert the device name
    //

    externalHubNameA = WideStrToMultiStr(externalHubNameW->NodeName);

GetExternalHubName_Exit:

    //
    // All done, free the uncoverted device hub name and return the
    // converted device name
    //

    if (externalHubNameW != NULL)
    {
        FREE(externalHubNameW);
    }

    return (externalHubNameA);
}

//*****************************************************************************
//
// GetDriverKeyName()
//
//*****************************************************************************

PCHAR
GetDriverKeyName (
    HANDLE  HubHandle,
    ULONG   ConnectionIndex
)
{
    BOOL                                  success;
    ULONG                                 nBytes;
    USB_NODE_CONNECTION_DRIVERKEY_NAME    driverKeyName;
    PUSB_NODE_CONNECTION_DRIVERKEY_NAME   driverKeyNameW;
    PCHAR                                 driverKeyNameA;

    driverKeyNameW = NULL;
    driverKeyNameA = NULL;

    ///
    // Get the length of the name of the device hub attached to the
    // specified port.
    //

    driverKeyName.ConnectionIndex = ConnectionIndex;

    success = DeviceIoControl(HubHandle,
                              IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME,
                              &driverKeyName,
                              sizeof(driverKeyName),
                              &driverKeyName,
                              sizeof(driverKeyName),
                              &nBytes,
                              NULL);

    if (!success)
    {
        goto GetDriverKeyName_Exit;
    }

    //
    // Allocate space to hold the driverKeyName
    //

    nBytes = driverKeyName.ActualLength;

    if (nBytes < sizeof(driverKeyName))
    {
        goto GetDriverKeyName_Exit;
    }

    driverKeyNameW = ALLOC(nBytes);

    if (driverKeyNameW == NULL)
    {
        goto GetDriverKeyName_Exit;
    }

    //
    // Get the name of the device attached to the specified port
    //

    driverKeyNameW -> ConnectionIndex = ConnectionIndex;

    success = DeviceIoControl(HubHandle,
                              IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME,
                              driverKeyNameW,
                              nBytes,
                              driverKeyNameW,
                              nBytes,
                              &nBytes,
                              NULL);

    if (!success)
    {
        goto GetDriverKeyName_Exit;
    }

    //
    // Convert the device name
    //

    driverKeyNameA = WideStrToMultiStr(driverKeyNameW->DriverKeyName);

GetDriverKeyName_Exit:

    //
    // All done, free the uncoverted device hub name and return the
    // converted device name
    //

    if (driverKeyNameW != NULL)
    {
        FREE(driverKeyNameW);
    }

    return (driverKeyNameA);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\dll\local.h ===
#ifndef _LOCAL_H_
#define _LOCAL_H_

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#define USBTEST_SERVICE_NAME    "USBTest"
#define USBTEST_SERVICE_DESC    "USB Test Driver"
#define USBTEST_DRIVER_PATH     "%windir%\\system32\\drivers\\usbtest.sys"

#define NT_SUCCESS(Status)           ((NTSTATUS)(Status) >= 0)
#define STATUS_OBJECT_NAME_COLLISION ((NTSTATUS)0xC0000035L)

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _NODE_TO_TEXT_CONTEXT
{
    HANDLE  File;
    ULONG   Indentation;
} NODE_TO_TEXT_CONTEXT, *PNODE_TO_TEXT_CONTEXT;


//*****************************************************************************
// L O C A L  F U N C T I O N  P R O T O T Y P E S
//*****************************************************************************

//*****************************************************************************
// DEVNODE.C
//*****************************************************************************

BOOL
DriverNameToDeviceInstance(
    IN  PCHAR   DriverName,
    OUT DEVINST *DeviceInstance
);

PCHAR
GetDeviceDesc(
    DEVINST DeviceInstance
);

PCHAR 
GetSymbolicLink(
    DEVINST DeviceInstance
);

PCHAR 
GetDeviceClassName(
    DEVINST DeviceInstance
);

BOOL
GetDeviceInfo(
    IN     DEVINST DeviceInstance,
    IN     BOOL    IsHub,
    IN OUT PUSB_DEVICE_NODE DeviceNode
);

PCHAR
WideStrToMultiStr(
   PWCHAR WideStr
);

DEVINST
GetHCDDeviceInstance(
    IN  HANDLE  HCHandle
);

PCHAR
GetRootHubName(
    HANDLE HostController
);

PCHAR
GetExternalHubName (
    HANDLE  HubHandle,
    ULONG   ConnectionIndex
);

PCHAR
GetDriverKeyName (
    HANDLE  HubHandle,
    ULONG   ConnectionIndex
);

PUSB_DEVICE_NODE
CreateUSBDeviceNode(
    IN  USB_DEVICE_NODE_TYPE    NodeType,
    IN  ULONG                   NumberOfChildren
);

BOOLEAN
DestroyUSBDeviceNode(
    IN  PUSB_DEVICE_NODE    Node,
    IN  PVOID               Context
);

BOOLEAN
WriteUSBDeviceNodeToTextFilePre(
    PUSB_DEVICE_NODE        Node,
    PNODE_TO_TEXT_CONTEXT   Context
);

BOOLEAN
WriteUSBDeviceNodeToTextFilePost(
    PUSB_DEVICE_NODE        Node,
    PNODE_TO_TEXT_CONTEXT   Context
);


BOOLEAN 
WriteUSBDeviceNodeToTextFile(
    IN  HANDLE              File,
    IN  PUSB_DEVICE_NODE    Node,
    IN  ULONG               Indentation
);

BOOLEAN
WalkUSBDeviceNode(
    IN  PUSB_DEVICE_NODE            Node,
    IN  PUSB_DEVICE_NODE_CALLBACK   PreWalkCallback,
    IN  PUSB_DEVICE_NODE_CALLBACK   PostWalkCallback,
    IN  PVOID                       Context
);

BOOLEAN 
WriteUSBDeviceNodeToFile(
    IN  PUSB_DEVICE_NODE    Node,
    IN  HANDLE              File
);

PUSB_DEVICE_NODE 
ReadUSBDeviceNodeFromFile(
    IN  HANDLE              File
);

VOID
CompareUSBDeviceNodes(
    IN  PUSB_DEVICE_NODE    Node1,
    IN  PUSB_DEVICE_NODE    Node2,
    OUT PULONG              NumberOfDifferences,
    OUT PNODE_PAIR_LIST     NodeDifferenceList
);

VOID
InitializeNodePairList(
    IN PNODE_PAIR_LIST  NodePairList
);

VOID
AddNodePair(
    IN  PUSB_DEVICE_NODE    Node1,
    IN  PUSB_DEVICE_NODE    Node2,
    IN  PNODE_PAIR_LIST     NodePairList
);

VOID
DestroyNodePairList(
    IN PNODE_PAIR_LIST  NodePairList
);

BOOL
EnumerateHostController(
    IN  PUSB_DEVICE_NODE    HCNode
);

PUSB_DEVICE_NODE
EnumerateNonHub(
    DEVINST                             DeviceInstance,
    PUSB_NODE_CONNECTION_INFORMATION    ConnectionInfo
);

PUSB_DEVICE_NODE
EnumerateCompositeDevice(
    DEVINST                             DeviceInstance,
    PUSB_NODE_CONNECTION_INFORMATION    ConnectionInfo,
    ULONG                               NumberInterfaces
);

PUSB_DEVICE_NODE
EnumerateHub(
    DEVINST                             DeviceInstance,
    PCHAR                               HubName,
    PUSB_NODE_CONNECTION_INFORMATION    ConnectionInfo
);

BOOL
EnumerateHubPorts(
    IN  PUSB_DEVICE_NODE    HubNode,
    IN  HANDLE              HubHandle,
    IN  ULONG               NumberOfPorts
);

//*****************************************************************************
// SERVICE.C
//*****************************************************************************

SC_HANDLE
OpenWin2kService(
    IN  PSTR    ServiceName,
    IN  PSTR    ServiceDescription,
    IN  PSTR    DriverPath,
    IN  BOOL    CreateIfNonExistant
);

SC_HANDLE
CreateWin2kService(
    IN  SC_HANDLE   scManagerHandle,
    IN  PSTR        ServiceName,
    IN  PSTR        ServiceDescription,
    IN  PSTR        DriverPath
);

BOOLEAN
IsWindows9x(
    VOID
);

BOOLEAN
LoadWin9xWdmDriver(
    IN  PSTR    DriverPath
);

BOOLEAN
UnloadWin9xWdmDriver(
    VOID
);

BOOLEAN
LoadWin2kWdmDriver(
    IN  PSTR    ServiceName,
    IN  PSTR    ServiceDescription,
    IN  PSTR    DriverPath
);

BOOLEAN
UnloadWin2kWdmDriver(
    IN  PSTR    ServiceName
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\exe\cycler\cycler.c ===
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>
#include <tchar.h>
#include <winioctl.h>
#include <usbioctl.h>
#include <cfgmgr32.h>
#include "usbtest.h"

#define SLEEP_TIME  10000   

#define VER_PRODUCTVERSION_STR  "0.90"

#define SURPRISE_REMOVE_WINNAME "Unsafe Removal of Device"

typedef struct _CYCLE_TEST_CONTEXT
{
    PUSB_DEVICE_TREE    LastKnownTree;
} CYCLE_TEST_CONTEXT, *PCYCLE_TEST_CONTEXT;

//
// Global variables
//

ULONG   TestIterations = 1;
BOOL    CycleHubs      = FALSE;
BOOL    Verbose        = FALSE;
BOOL    Abort;

//
// Local Function Declarations
//

BOOL
ParseArgs (
    int     argc,
    char   *argv[]
);

VOID
Usage(
    VOID
);

VOID
Version(
    VOID
);

 
//
// Some Local function definitions
//

VOID
DisplayDifferentNode(
    PUSB_DEVICE_NODE    Node
)
{
    PUSB_DEVICE_NODE    Parent;
    ULONG               ParentIndex;

    Parent = Node -> Parent;

    if (NULL != Parent)
    {
        ParentIndex = 0;
        while (Parent -> Children[ParentIndex] != Node)
        {
            ParentIndex++;
        }
    }

    switch(Node -> NodeType)
    {
        case Computer:
            printf("Computer: NumberOfHCs = %d",
                   Node -> NumberOfChildren);
            break;

        case HostController:
            printf("Host Controller: %s",
                   Node -> Description);

        case Hub:
            if (NULL == Node -> NodeInformation)
            {
                printf("Host Controller %s --> RootHub: %d ports",
                       Parent -> Description,
                       Node -> NumberOfChildren);
            }
            else 
            {
                printf("Hub: %s --> %d ports",
                       Node -> Description,
                       Node -> NumberOfChildren);
            }
            break;

        case MIParent:
            printf("%s port %d --> %s: %d interfaces",
                   Parent -> Description,
                   ParentIndex+1,
                   Node -> Description,
                   Node -> NumberOfChildren);
            break;

        case MIInterface:
            printf("%s interface --> %s",
                   Parent -> Description,
                   Node -> Description);
            break;

        case Device:
            printf("%s port %d --> %s",
                   Parent -> Description,
                   ParentIndex+1,
                   Node -> Description);
            break;

        case EmptyPort:
            printf("%s port %d --> EmptyPort",
                   Parent -> Description,
                   ParentIndex+1);
            break;
    }

    if (0 != Node -> DeviceProblem)
    {
        printf(" (!:%d)", Node -> DeviceProblem);
    }

    printf("\n");
    return;
}

VOID
DisplayDifferenceList(
    ULONG           NumDifferences,
    PNODE_PAIR_LIST DifferenceList
)
{
    ULONG   index;

    if (0 != NumDifferences)
    {
        printf("Node Differences (%d)\n"
               "--------------------\n",
               NumDifferences);

        for (index = 0; index < DifferenceList -> CurrentNodePairs; index++)
        {
            printf("\n"
                   "Node Pair %d\n"
                   "-----------\n",
                   index+1);

            DisplayDifferentNode(DifferenceList -> NodePairs[index*2]);
            DisplayDifferentNode(DifferenceList -> NodePairs[index*2+1]);
        }
    }

    return;
}

VOID
DismissSurpriseRemovals(
    VOID
)
{
    TCHAR               surpriseRemoveWinName[] = _T(SURPRISE_REMOVE_WINNAME);
    HWND                surpriseRemoveWindow;
    HWND                prevWindow;
    ULONG               retryCount;
    BOOL                success;

    //
    // To try to dismiss this window, we search first try to find an instance
    //  of this window and then post a message to the window to shut itself 
    //  down.  
    //

    prevWindow = INVALID_HANDLE_VALUE;

    while (1)
    {
        retryCount = 0;

        do
        {
            surpriseRemoveWindow = FindWindow(WC_DIALOG, surpriseRemoveWinName);
        } 
        while (surpriseRemoveWindow == prevWindow && retryCount++ < 3);


        if (NULL == surpriseRemoveWindow || surpriseRemoveWindow == prevWindow) 
        {
            //
            // There are either no more windows or we keep getting the
            //  same window returned to us.  We'll break out of the loop now
            //  just to make sure we don't hang this test trying to close
            //  the same non-responding window over and over.
            //

            if (surpriseRemoveWindow == prevWindow)
            {
                OutputDebugString("CYCLER: Keep getting the same removal window\n");
                OutputDebugString("        Either window isn't responding or\n");
                OutputDebugString("        sleep time needs to be increased\n");
            }

            break;
        }

        // 
        // Found a new window let's post a message to close it
        //
        // NOTE: PostMessage() doesn't always post the message if that 
        //  window's messageQueue happens to be full.  We will only try
        //  this 3 times though and then give up...
        //

        retryCount = 0;

        do 
        {
           success = PostMessage(surpriseRemoveWindow,
                                 WM_COMMAND,
                                 IDOK,
                                 0);
       
        } while (!success && retryCount++ < 3);

        //
        // If successful, wait for the window to shutdown
        //

        if (success)
        {
            Sleep(500);
        }
        
        prevWindow = surpriseRemoveWindow;
    }

    return;
}

BOOLEAN
CycleTestCallbackPre(
    IN  PUSB_DEVICE_NODE    Node,
    IN  PCYCLE_TEST_CONTEXT Context
)
{
    return (TRUE);
}

BOOLEAN
CycleTestCallbackPost(
    IN  PUSB_DEVICE_NODE    Node,
    IN  PCYCLE_TEST_CONTEXT Context
)
{
    BOOLEAN             success;
    ULONG               nBytes;
    PUSB_DEVICE_TREE    currentTree;
    ULONG               numDifferences;
    NODE_PAIR_LIST      differenceList;

    success = TRUE;

    //
    // Determine if this port should be cycled.  If cycleHubs was specified,
    //  then we cycle any USBDevice (NonHub and ExternalHub).  Otherwise,
    //  just cycle the port if a NonHubDevice is attached (composite/regular)
    //

    if ( (IsNonHubDevice(Node)) || (CycleHubs && IsExternalHub(Node)))
    {
        printf("Attempting to cycle %s\n", Node -> Description);
    
        success = CycleUSBPort(Node);
    
        if (!success)
        {
            printf("Error %d occurred trying to cycle the port!\n",
                   GetLastError());
        }
        else
        {
            printf("Cycle completed with success\n");

            printf("Sleeping for %d ms\n", SLEEP_TIME);

            Sleep(SLEEP_TIME);

            //
            // Dismiss the surprise removal dialog box that might show up
            //

            DismissSurpriseRemovals();

            currentTree = BuildUSBDeviceTree();
    
            if (NULL == currentTree)
            {
                printf("Error %d occurred trying to build current tree\n"
                       "Comparison after cycle port not done\n",
                       GetLastError());

                success = FALSE;
            }
            else
            {
                printf("Comparing the current tree with the last tree\n");
    
                InitializeNodePairList(&differenceList);
    
                success = CompareUSBDeviceTrees(Context -> LastKnownTree,
                                                currentTree,
                                                &numDifferences,
                                                &differenceList);
    
                if (0 != numDifferences)
                {
                    printf("There are %d difference between device trees"
                           "after port cycle\n",
                           numDifferences);
    
                    DisplayDifferenceList(numDifferences, &differenceList);

                    Context -> LastKnownTree = currentTree;
                }
                else 
                {
                    printf("Device trees are the same after port cycle\n");
                }

                DestroyUSBDeviceTree(currentTree);
    
                DestroyNodePairList(&differenceList);
            }
        }    
    }

    return (success);
}

BOOL
DoTreeCycle(
    ULONG   IterationNumber
)
{
    CYCLE_TEST_CONTEXT  context;
    BOOL                success;

    printf("Starting cycle iteration %d\n", IterationNumber);

    success = TRUE;

    context.LastKnownTree = BuildUSBDeviceTree();

    if (NULL == context.LastKnownTree) 
    {
        printf("Error %d occurred building the current device tree\n", 
                GetLastError());

        success = FALSE;

        goto DoTreeCycle_Exit;
    }

    success = WalkUSBDeviceTree(context.LastKnownTree, 
                                CycleTestCallbackPre,
                                CycleTestCallbackPost,
                                &context);

    DestroyUSBDeviceTree(context.LastKnownTree);

DoTreeCycle_Exit:

    printf("Ending cycle iteration %d\n", IterationNumber);

    return (success);
}

//*****************************************************************************
//
// CtrlHandlerRoutine()
//
//*****************************************************************************

BOOL WINAPI
CtrlHandlerRoutine (
    DWORD dwCtrlType
    )
{
    BOOL handled;

    switch (dwCtrlType)
    {
        case CTRL_C_EVENT:
        case CTRL_BREAK_EVENT:
            Abort = TRUE;
            handled = TRUE;
            break;

        default:
            handled = FALSE;
            break;
    }

    return handled;
}

int __cdecl
main(
    int argc,
    char *argv[]
)
{
    ULONG               index;
    BOOL                success;
    
    if (!ParseArgs(argc, argv)) 
    {
        return (1);
    }

    //
    // Set a CTRL-C / CTRL-BREAK handler
    //

    Abort = FALSE;

    SetConsoleCtrlHandler(CtrlHandlerRoutine, TRUE);

    for (index = 1; index <= TestIterations && !Abort; index++)
    {
        success = DoTreeCycle(index);

        if (!success) 
        {
            printf("Cycle test failed on iteration %d\n", index);
            break;
        }
    }

    if (Abort)
    {
        printf("Cycle test aborted!\n");
    }

    //
    // Return an errorlevel code of 1 if the test failed and some point
    //

    return (success ? 0 : 1);
}

//*****************************************************************************
//
// ParseArgs()
//
//*****************************************************************************

BOOL
ParseArgs (
    int     argc,
    char   *argv[]
)
{
    int i, j;

    if (argc < 2)
    {
        Usage();
        return FALSE;
    }

    for (i=1; i<argc; i++)
    {
        if (argv[i][0] == '-' ||  argv[i][0] == '/')
        {
            switch(argv[i][1])
            {
                case 'H':
                case 'h':
                    CycleHubs = TRUE;
                    break;

                case 'I':
                case 'i':
                    if ('\0' != argv[i][2]) 
                    {
                        TestIterations = atoi(&argv[i][2]);
                    }
                    else 
                    {
                        i++;
                        if (i == argc)
                        {
                            Usage();

                            return FALSE;
                        }
                        else
                        {
                            TestIterations = atoi(argv[i]);
                        }
                    }
                    break;
                
                case '?':
                   Usage();
                   return (FALSE);

                case 'V':
                case 'v':
                   Verbose = TRUE;
                   break;
                
               default:
                   Usage();
                   return FALSE;
            }
        }
    }

    //
    // Dump parsed args if desired
    //

    if (Verbose)
    {
        printf( "Iterations:  %d\n", TestIterations);

        printf( "Verbose:     %d\n", Verbose);
    }

    return TRUE;
}

/*****************************************************************************
//
// Usage()
//
//****************************************************************************/

VOID
Usage(
    VOID
)
{
    Version();
    printf( "usage:\n");
    printf( "-h  cycle ports with attached hubs\n");
    printf( "-i  [n] where n is the number of iterations to perform\n");
    printf( "-V      verbose output\n");
}

/*****************************************************************************
//
// Version()
//
//****************************************************************************/

void
Version ()
{
    printf( "CYCLER.EXE %s\n", VER_PRODUCTVERSION_STR);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\write.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        WRITE.C

Abstract:

        Routines that perform write functionality

Environment:

        kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        9/25/98 : created

Authors:

        Louis J. Giliberto, Jr.


****************************************************************************/


#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "utils.h"
#include "debugwdm.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEUSBS, UsbSer_Write)
#pragma alloc_text(PAGEUSBS, UsbSerGiveWriteToUsb)
#endif // ALLOC_PRAGMA


NTSTATUS
UsbSerFlush(IN PDEVICE_OBJECT PDevObj, PIRP PIrp)
{
   NTSTATUS status = STATUS_SUCCESS;
   PDEVICE_EXTENSION pDevExt;
   ULONG pendingIrps;

   UsbSerSerialDump(USBSERTRACEWR, (">UsbSerFlush(%08X)\n", PIrp));

   pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;

   //
   // All we will do is wait until the write pipe has nothing pending.
   // We do this by checking the outstanding count, and if it hits 1 or 0,
   // then the completion routine will set an event we are waiting for.
   //

   InterlockedIncrement(&pDevExt->PendingDataOutCount);

   pendingIrps = InterlockedDecrement(&pDevExt->PendingDataOutCount);

   if ((pendingIrps) && (pendingIrps != 1)) {
      //
      // Wait for flush
      //

      KeWaitForSingleObject(&pDevExt->PendingFlushEvent, Executive,
                            KernelMode, FALSE, NULL);
   } else {
      if (pendingIrps == 0) {
         //
         // We need to wake others since our decrement caused the event
         //

         KeSetEvent(&pDevExt->PendingDataOutEvent, IO_NO_INCREMENT, FALSE);
      }
   }

   PIrp->IoStatus.Status = STATUS_SUCCESS;

   IoCompleteRequest(PIrp, IO_NO_INCREMENT);

   UsbSerSerialDump(USBSERTRACEWR, ("<UsbSerFlush %08X \n", STATUS_SUCCESS));

   return STATUS_SUCCESS;
}



NTSTATUS
UsbSer_Write(IN PDEVICE_OBJECT PDevObj, PIRP PIrp)
/*++

Routine Description:

   Process the IRPs sent to this device for writing.

Arguments:

    PDevObj - Pointer to the device object for the device written to
    PIrp    - Pointer to the write IRP.

Return Value:

    NTSTATUS

--*/
{
   KIRQL oldIrql;
   LARGE_INTEGER totalTime;
   SERIAL_TIMEOUTS timeouts;
   NTSTATUS status;
   PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACEWR, (">UsbSer_Write(%08X)\n", PIrp));

   PIrp->IoStatus.Information = 0L;
   totalTime.QuadPart = (LONGLONG)0;

   //
   // Quick check for a zero length write.  If it is zero length
   // then we are already done!
   //

   if (pIrpSp->Parameters.Write.Length == 0) {
      status = PIrp->IoStatus.Status = STATUS_SUCCESS;
      IoCompleteRequest(PIrp, IO_NO_INCREMENT);
      goto UsbSer_WriteExit;
   }


   //
   // Make sure the device is accepting request and then...
   // Calculate the timeout value needed for the
   // request.  Note that the values stored in the
   // timeout record are in milliseconds.  Note that
   // if the timeout values are zero then we won't start
   // the timer.
   //

   ACQUIRE_SPINLOCK(pDevExt, &pDevExt->ControlLock, &oldIrql);

   if (pDevExt->CurrentDevicePowerState != PowerDeviceD0) {
      RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldIrql);
      status = PIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
      IoCompleteRequest(PIrp, IO_NO_INCREMENT);
      goto UsbSer_WriteExit;
   }

   timeouts = pDevExt->Timeouts;
   RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldIrql);

   if (timeouts.WriteTotalTimeoutConstant
       || timeouts.WriteTotalTimeoutMultiplier) {

      //
      // We have some timer values to calculate.
      //


      totalTime.QuadPart
         = ((LONGLONG)((UInt32x32To64((pIrpSp->MajorFunction == IRP_MJ_WRITE)
                                      ? (pIrpSp->Parameters.Write.Length)
                                      : 1,
                                      timeouts.WriteTotalTimeoutMultiplier)
                        + timeouts.WriteTotalTimeoutConstant))) * -10000;

   }

   //
   // The Irp may be going to the write routine shortly.  Now
   // is a good time to init its ref counts.
   //

   USBSER_INIT_REFERENCE(PIrp);

   //
   // We need to see if this Irp should be cancelled.
   //

   ACQUIRE_CANCEL_SPINLOCK(pDevExt, &oldIrql);

   if (PIrp->Cancel) {
      RELEASE_CANCEL_SPINLOCK(pDevExt, oldIrql);
      status = PIrp->IoStatus.Status = STATUS_CANCELLED;
   } else {
//       IoMarkIrpPending(PIrp);
//       status = STATUS_PENDING;

      //
      // We give the IRP to the USB subsystem -- he will need
      // to know how to cancel it himself
      //

      IoSetCancelRoutine(PIrp, NULL);
      RELEASE_CANCEL_SPINLOCK(pDevExt, oldIrql);

      status = UsbSerGiveWriteToUsb(pDevExt, PIrp, totalTime);
   }

UsbSer_WriteExit:;

   UsbSerSerialDump(USBSERTRACEWR, ("<UsbSer_Write %08X\n", status));

   return status;
}


NTSTATUS
UsbSerWriteComplete(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                    IN PUSBSER_WRITE_PACKET PPacket)
/*++

Routine Description:

    This routine is the completion routine for all write requests.
    When a write completes, we go through here in order to free up
    the URB.

Arguments:

    PDevObj - Pointer to device object

    PIrp - Irp we are completing

    PUrb - Urb which will be freed


Return Value:

    NTSTATUS -- as stored in the Irp.

--*/
{
   NTSTATUS status;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   KIRQL cancelIrql;
   PURB pUrb = &PPacket->Urb;
   PDEVICE_EXTENSION pDevExt = PPacket->DeviceExtension;
   ULONG curCount;

   UsbSerSerialDump(USBSERTRACEWR, (">UsbSerWriteComplete(%08X)\n", PIrp));

   status = PIrp->IoStatus.Status;

   if (status == STATUS_SUCCESS) {

        // see if we are reusing an IOCTL IRP
        if(pIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL)
        {
            PIrp->IoStatus.Information = 0L;
        }
        else
        {
            PIrp->IoStatus.Information
                = pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;
            pIrpStack->Parameters.Write.Length = (ULONG)PIrp->IoStatus.Information;
        }

   } else if (status == STATUS_CANCELLED) {
      //
      // If it comes back as cancelled, it may really have timed out. We
      // can tell by looking at the packet attached to it.
      //

      if (PPacket->Status) {
         status = PIrp->IoStatus.Status = PPacket->Status;
         UsbSerSerialDump(USBSERTRACEWR, ("Modified Write Status %08X\n",
                                          PIrp->IoStatus.Status));
      }
   }

   //
   // Cancel the write timer
   //

   if (PPacket->WriteTimeout.QuadPart != 0) {
      KeCancelTimer(&PPacket->WriteTimer);
   }

   DEBUG_MEMFREE(PPacket);

   //
   // Reset the pend if necessary
   //

   if (PIrp->PendingReturned) {
      IoMarkIrpPending(PIrp);
   }

   //
   // See if we should mark the transmit as empty
   //

   if (InterlockedDecrement(&pDevExt->PendingWriteCount) == 0) {
      UsbSerProcessEmptyTransmit(pDevExt);
   }

   //
   // Notify everyone if this is the last IRP
   //

   curCount = InterlockedDecrement(&pDevExt->PendingDataOutCount);

   if ((curCount == 0) || (curCount == 1)) {
      UsbSerSerialDump(USBSERTRACEWR, ("DataOut Pipe is flushed\n"));
      KeSetEvent(&pDevExt->PendingFlushEvent, IO_NO_INCREMENT, FALSE);

      if (curCount == 0) {
         UsbSerSerialDump(USBSERTRACEWR, ("DataOut Pipe is empty\n"));
         KeSetEvent(&pDevExt->PendingDataOutEvent, IO_NO_INCREMENT, FALSE);
      }
   }

   //
   // Finish off this IRP
   //


   ACQUIRE_CANCEL_SPINLOCK(pDevExt, &cancelIrql);

   UsbSerTryToCompleteCurrent(pDevExt, cancelIrql, status,
                              &PIrp, NULL, NULL,
                              &pDevExt->WriteRequestTotalTimer, NULL,
                              NULL, USBSER_REF_RXBUFFER, FALSE);


   UsbSerSerialDump(USBSERTRACEWR, ("<UsbSerWriteComplete %08X\n", status));
   return status;
}



NTSTATUS
UsbSerGiveWriteToUsb(IN PDEVICE_EXTENSION PDevExt, IN PIRP PIrp,
                     IN LARGE_INTEGER TotalTime)
/*++

Routine Description:

    This function passes a write IRP down to USB to perform the write
    to the device.

Arguments:

    PDevExt   - Pointer to device extension

    PIrp      - Write IRP

    TotalTime - Timeout value for total timer


Return Value:

    NTSTATUS

--*/
{
   NTSTATUS status;
   PURB pTxUrb;
   PIO_STACK_LOCATION pIrpSp;
   KIRQL cancelIrql;
   PUSBSER_WRITE_PACKET pWrPacket;

   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACEWR, (">UsbSerGiveWriteToUsb(%08X)\n",
                                    PIrp));

   USBSER_SET_REFERENCE(PIrp, USBSER_REF_RXBUFFER);


   pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   //
   // Allocate memory for URB / Write packet
   //

   pWrPacket = DEBUG_MEMALLOC(NonPagedPool, sizeof(USBSER_WRITE_PACKET));

   if (pWrPacket == NULL) {
      status = PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

      ACQUIRE_CANCEL_SPINLOCK(PDevExt, &cancelIrql);

      UsbSerTryToCompleteCurrent(PDevExt, cancelIrql, status, &PIrp,
                                 NULL,
                                 &PDevExt->WriteRequestTotalTimer, NULL, NULL,
                                 NULL, USBSER_REF_RXBUFFER, TRUE);

      return status;
   }

   RtlZeroMemory(pWrPacket, sizeof(USBSER_WRITE_PACKET));

   pTxUrb = &pWrPacket->Urb;
   pWrPacket->DeviceExtension = PDevExt;
   pWrPacket->Irp = PIrp;
   pWrPacket->WriteTimeout = TotalTime;

   if (TotalTime.QuadPart != 0) {
      KeInitializeTimer(&pWrPacket->WriteTimer);
      KeInitializeDpc(&pWrPacket->TimerDPC, UsbSerWriteTimeout, pWrPacket);
      KeSetTimer(&pWrPacket->WriteTimer, TotalTime, &pWrPacket->TimerDPC);
   }

   //
   // Build USB write request
   //

   BuildReadRequest(pTxUrb, PIrp->AssociatedIrp.SystemBuffer,
                    pIrpSp->Parameters.Write.Length, PDevExt->DataOutPipe,
                    FALSE);

#if DBG
   if (UsbSerSerialDebugLevel & USBSERDUMPWR) {
      ULONG i;

      DbgPrint("WR: ");

      for (i = 0; i < pIrpSp->Parameters.Write.Length; i++) {
         DbgPrint("%02x ", *(((PUCHAR)PIrp->AssociatedIrp.SystemBuffer) + i) & 0xFF);
      }

      DbgPrint("\n\n");
   }
#endif

   //
   // Set Irp up for a submit Urb IOCTL
   //

   IoCopyCurrentIrpStackLocationToNext(PIrp);

   pIrpSp = IoGetNextIrpStackLocation(PIrp);

   pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
   pIrpSp->Parameters.Others.Argument1 = pTxUrb;
   pIrpSp->Parameters.DeviceIoControl.IoControlCode
      = IOCTL_INTERNAL_USB_SUBMIT_URB;

   IoSetCompletionRoutine(PIrp, UsbSerWriteComplete, pWrPacket, TRUE, TRUE,
                          TRUE);

   //
   // Increment the pending write count
   //

   InterlockedIncrement(&PDevExt->PendingWriteCount);
   InterlockedIncrement(&PDevExt->PendingDataOutCount);

   //
   // Send IRP down
   //

   status = IoCallDriver(PDevExt->StackDeviceObject, PIrp);


#if 0

   // this is done in the completion routine, so we don't need to do it here

   if (!NT_SUCCESS(status)) {
      ULONG outCount;

      if (InterlockedDecrement(&PDevExt->PendingWriteCount) == 0) {
         UsbSerProcessEmptyTransmit(PDevExt);
      }

      outCount = InterlockedDecrement(&PDevExt->PendingDataOutCount);

      if ((outCount == 0) || (outCount == 1)) {
         KeSetEvent(&PDevExt->PendingFlushEvent, IO_NO_INCREMENT, FALSE);

         if (outCount == 0) {
            KeSetEvent(&PDevExt->PendingDataOutEvent, IO_NO_INCREMENT, FALSE);
         }
      }
   }

#endif

   UsbSerSerialDump(USBSERTRACEWR, ("<UsbSerGiveWriteToUsb %08X\n", status));

   return status;
}


VOID
UsbSerWriteTimeout(IN PKDPC PDpc, IN PVOID DeferredContext,
                   IN PVOID SystemContext1, IN PVOID SystemContext2)
/*++

Routine Description:

    This function is called when the write timeout timer expires.

Arguments:

    PDpc             - Unused

    DeferredContext  - Actually the write packet

    SystemContext1   - Unused

    SystemContext2   - Unused


Return Value:

    VOID

--*/
{
   PUSBSER_WRITE_PACKET pPacket = (PUSBSER_WRITE_PACKET)DeferredContext;

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(SystemContext1);
   UNREFERENCED_PARAMETER(SystemContext2);

   UsbSerSerialDump(USBSERTRACETM, (">UsbSerWriteTimeout\n"));

   if (IoCancelIrp(pPacket->Irp)) {
      pPacket->Status = STATUS_TIMEOUT;
   }

   UsbSerSerialDump(USBSERTRACETM, ("<UsbSerWriteTimeout\n"));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\exe\pstress\pstress.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    PSTRESS.C

Abstract:

    This application is a console app for performing the parser stress 
       functionality that was originally included with hidview.exe.  It takes
       a path to some report descriptor binary files and continually passes 
       them to the kernel mode driver USBTEST.SYS for parsing by HIDPARSE.SYS.
       It requires both USBTEST.SYS and USBTEST.DLL to run correctly.

Environment:

    user mode

Revision History:

    09-21-99 : created

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>
#include <winioctl.h>
#include <usbioctl.h>
#include <cfgmgr32.h>
#include "usbtest.h"

//*****************************************************************************
// D E F I N E S  
//*****************************************************************************

#define VER_PRODUCTVERSION_STR  "0.90"

#define DEFAULT_DESC_PATH       "."
#define FILE_WILDCARD_STRING    "*.bin"
#define REPORT_DESC_HEADER      "REPORT"
#define DESCRIPTOR_HEADER_SIZE  11

//*****************************************************************************
// G L O B A L S  
//*****************************************************************************

//
// PSTRESS command line parameters
//

ULONG   TestIterations;
CHAR    DescPath[MAX_PATH+1];
BOOL    Verbose;

//
// Global boolean that is set by ctrl-c handled to indicate test thread should
//  terminate.
//

BOOL    Abort;

//
// Name of the current file that is being parsed
//

CHAR    CurrentParserFile[MAX_PATH+1];

//*****************************************************************************
// L O C A L   F U N C T I O N   D E C L A R A T I O N S                                                                             
//*****************************************************************************

BOOL
ParseArgs (
    int     argc,
    char   *argv[]
);

VOID
Usage(
    VOID
);

VOID
Version(
    VOID
);

BOOL
DoParserStress(
    VOID
);

BOOL WINAPI
CtrlHandlerRoutine (
    DWORD dwCtrlType
);

//*****************************************************************************
// F U N C T I O N   D E F I N I T I O N S
//*****************************************************************************

int __cdecl
main(
    int argc,
    char *argv[]
)
{
    ULONG               index;
    BOOL                success;
    
    
    TestIterations = 1;

    if (!ParseArgs(argc, argv)) 
    {
        return 1;
    }

    //
    // Set a CTRL-C / CTRL-BREAK handler
    //

    Abort = FALSE;

    SetConsoleCtrlHandler(CtrlHandlerRoutine, TRUE);

    success = DoParserStress();

    if (!success)
    {
        printf("Error %d occurred running parser stress\n", GetLastError());
    }

    //
    // Return an errorlevel code of 1 if the test failed and some point
    //

    return (success ? 0 : 1);
}

//*****************************************************************************
//
// ParseArgs()
//
//*****************************************************************************

BOOL
ParseArgs (
    int     argc,
    char   *argv[]
)
{
    int i, j;
    ULONG   pathLength;
    PCHAR   path;

    if (argc < 2)
    {
        Usage();
        return FALSE;
    }

    for (i=1; i<argc; i++)
    {
        if (argv[i][0] == '-' ||  argv[i][0] == '/')
        {
            switch(argv[i][1])
            {
                case 'I':
                case 'i':
                    if ('\0' != argv[i][2]) 
                    {
                        TestIterations = atoi(&argv[i][2]);
                    }
                    else 
                    {
                        i++;
                        if (i == argc)
                        {
                            Usage();

                            return FALSE;
                        }
                        else
                        {
                            TestIterations = atoi(argv[i]);
                        }
                    }
                    break;
                
                //
                // Set the path for the descriptor binary files
                //

                case 'P':
                case 'p':
                    if ('\0' != argv[i][2]) 
                    {
                        path = &(argv[i][2]);
                    }
                    else 
                    {
                        i++;

                        if (i == argc) 
                        {
                            Usage();

                            return (FALSE);
                        }
                        path = &(argv[i][0]);
                    }

                    //
                    // Perform a check on the path length taking
                    //  into account we will be appending a WILDCARD string
                    //  and may also be needing to add a backslash
                    //

                    pathLength = strlen(path);

                    if (':' != path[pathLength-1] &&
                        '\\' != path[pathLength-1])
                    {
                        pathLength++;
                    }

                    if (MAX_PATH-strlen(FILE_WILDCARD_STRING) < pathLength)
                    {
                        Usage();

                        return FALSE;
                    }

                    //
                    // Copy the path and get the path length again since we
                    //  may have modified it above.
                    //

                    strcpy(DescPath, path);
                    pathLength = strlen(DescPath);

                    //
                    // If the path is not terminated by a colon or a backslash
                    //  append the backslash
                    //

                    if (':' != DescPath[pathLength-1] &&
                        '\\' != DescPath[pathLength-1])
                    {
                        strcat(DescPath, "\\");
                    }
                    break;

                case 'V':
                case 'v':
                    Verbose = TRUE;
                    break;
                 
                default:
                    Usage();
                    return FALSE;
            }
        }
    }

    //
    // Dump parsed args if desired
    //

    if (Verbose)
    {
        printf( "Iterations:  %d\n", TestIterations);

        printf( "Verbose:     %d\n", Verbose);
    }

    return TRUE;
}

/*****************************************************************************
//
// Usage()
//
//****************************************************************************/

VOID
Usage(
    VOID
)
{
    Version();
    printf( "usage:\n");
    printf( "-i [n] where n is the number of iterations to perform\n");
    printf( "-p path where path points to the directory of binary files\n");
    printf( "-V      verbose output\n");
}

//*****************************************************************************
//
// Version()
//
//*****************************************************************************

void
Version ()
{
    printf( "CYCLER.EXE %s\n", VER_PRODUCTVERSION_STR);
    return;
}


//*****************************************************************************
//
// DoParserStress()
//
//*****************************************************************************

BOOL
DoParserStress(
    VOID
)
{
    HANDLE              fileSearchHandle;
    WIN32_FIND_DATA     fileData;
    PHIDP_DEVICE_DESC   hidDeviceDesc;
    BOOL                success;
    ULONG               iteration;
    ULONG               pathLength;
    ULONG               fileOffset;
    DWORD               errorCode;
    ULONG               nBytes;
    HANDLE              fileHandle;
    PCHAR               dataBuffer;
    PCHAR               repDesc;
    ULONG               descSize;

    //
    // Open up a handle to the file search routine if we need to
    //

    pathLength = strlen(DescPath);

    strcpy(CurrentParserFile, DescPath);

    fileOffset = strlen(CurrentParserFile);

    strcat(DescPath, FILE_WILDCARD_STRING);

    fileSearchHandle = FindFirstFile(DescPath, &fileData);

    if (INVALID_HANDLE_VALUE == fileSearchHandle)
    {
        printf("Failed to open desc path %s\n", DescPath);

        return (FALSE);
    }

    iteration = 1;

    while (iteration <= TestIterations && success && !Abort)
    {
        //
        // On entering this loop, fileData contains the next file that 
        //  we want to process
        //

        CurrentParserFile[fileOffset] = '\0';

        if (fileOffset+strlen(fileData.cFileName) > MAX_PATH) 
        {
            iteration++;
            continue;
        }

        strcat(CurrentParserFile, fileData.cFileName);

        printf("Going to parse file %s\n", CurrentParserFile);

        //
        // Open handle to the file we want to send to parse
        //

        fileHandle = CreateFile(CurrentParserFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL);

        if (INVALID_HANDLE_VALUE == fileHandle)
        {
            success = FALSE;
            continue;
        }

        //
        // Get the number of bytes to read in
        //

        if (0 != fileData.nFileSizeHigh)
        {
            //
            // Report descriptor file is bigger than 4GB...Hmm...probably an
            //  error...just skip it
            //

            iteration++;
            continue;
        }

        descSize = fileData.nFileSizeLow;

        dataBuffer = ALLOC(descSize);

        if (NULL == dataBuffer)
        {
            SetLastError(ERROR_OUTOFMEMORY);

            success = FALSE;
            continue;
        }

        //
        // Read in the file
        //

        success = ReadFile(fileHandle,
                           dataBuffer,
                           descSize,
                           &nBytes,
                           NULL);

        CloseHandle(fileHandle);

        if (!success)
        {
            continue;
        }

        //
        // Attempt to parse the report descriptor
        //

        repDesc = dataBuffer;
        if (0 == memcmp(repDesc,
                        REPORT_DESC_HEADER, 
                        strlen(REPORT_DESC_HEADER)))
        {
            repDesc  += DESCRIPTOR_HEADER_SIZE;
            descSize -= DESCRIPTOR_HEADER_SIZE;
        }

        success = ParseReportDescriptor(repDesc, descSize, &hidDeviceDesc);

        printf("hidDeviceDesc: %08x\n", hidDeviceDesc);

        FREE(hidDeviceDesc);

        errorCode = GetLastError();

        FREE(dataBuffer);

        if (!success)
        {
            SetLastError(errorCode);

            continue;
        }

        // 
        // Get the next file to process
        //

        success = FindNextFile(fileSearchHandle, &fileData);

        if (!success)
        {
            errorCode = GetLastError();

            if (ERROR_NO_MORE_FILES == errorCode)
            {
                FindClose(fileSearchHandle);

                fileSearchHandle = FindFirstFile(DescPath, &fileData);
            
                success = (INVALID_HANDLE_VALUE != fileSearchHandle);
            }
        }    

        iteration++;
    }

    return (success);
}

//*****************************************************************************
//
// CtrlHandlerRoutine()
//
//*****************************************************************************

BOOL WINAPI
CtrlHandlerRoutine (
    DWORD dwCtrlType
)
{
    BOOL handled;

    switch (dwCtrlType)
    {
        case CTRL_C_EVENT:
        case CTRL_BREAK_EVENT:
            Abort = TRUE;
            handled = TRUE;
            break;

        default:
            handled = FALSE;
            break;
    }

    return handled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\exe\treelog\treelog.c ===
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>
#include <tchar.h>
#include <winioctl.h>
#include <usbioctl.h>
#include <cfgmgr32.h>
#include "usbtest.h"

#define VER_PRODUCTVERSION_STR  "0.90"
#define MIN_ARGS    2

#define DEFAULT_TREEFILE_NAME   ".\\usbtree.bin"
#define NEWLINE                 "\r\n"

#define TREELOG_EXIT(s)         { success = (s); goto Treelog_Exit; }

//
// Global variables
//

BOOL    BreakOnError         = FALSE;
BOOL    Verbose              = FALSE;
BOOL    LogTree              = FALSE;
BOOL    NewTree              = FALSE;
BOOL    DumpDescriptions     = FALSE;
BOOL    FileNameSet          = FALSE;


CHAR    LogFileName[MAX_PATH+1] = "";

//
// Local Function Declarations
//

BOOL
ParseArgs (
    int     argc,
    char   *argv[]
);

VOID
Usage(
    VOID
);

VOID
Version(
    VOID
);

//
// Some Local function definitions
//

BOOL
WriteLog(
    IN  HANDLE  logFile,
    IN  PSTR    formatString,
    ...
)
{
    CHAR    logMsg[256];
    DWORD   bytesWritten;
    BOOL    success;

    va_list args;

    va_start(args, formatString);

    vsprintf(logMsg, formatString, args);

    success = WriteFile(logFile,
                        logMsg,
                        strlen(logMsg),
                        &bytesWritten,
                        NULL);

    return (success);
}


VOID
DisplayDifferentNode(
    HANDLE              LogFile,
    PUSB_DEVICE_NODE    Node
)
{
    PUSB_DEVICE_NODE    Parent;
    ULONG               ParentIndex;

    Parent = Node -> Parent;

    if (NULL != Parent)
    {
        ParentIndex = 0;
        while (Parent -> Children[ParentIndex] != Node)
        {
            ParentIndex++;
        }
    }

    switch (Node -> NodeType)
    {
        case Computer:
            WriteLog(LogFile, 
                     "Computer: NumberOfHCs = %d" NEWLINE,
                     Node -> NumberOfChildren);
            break;

        case HostController:
            WriteLog(LogFile,
                     "Host Controller: %s" NEWLINE,
                     Node -> Description);

        case Hub:
            if (NULL == Node -> NodeInformation)
            {
                WriteLog(LogFile,
                         "Host Controller %s --> RootHub: %d ports" NEWLINE,
                         Parent -> Description,
                         Node -> NumberOfChildren);
            }
            else 
            {
                WriteLog(LogFile,
                         "Hub: %s --> %d ports" NEWLINE,
                         Node -> Description,
                         Node -> NumberOfChildren);
            }
            break;

        case MIParent:
            WriteLog(LogFile,
                     "%s port %d --> %s: %d interfaces" NEWLINE,
                     Parent -> Description,
                     ParentIndex+1,
                     Node -> Description,
                     Node -> NumberOfChildren);
            break;

        case MIInterface:
            printf("%s interface --> %s\n",
                   Parent -> Description,
                   Node -> Description);
            break;

        case Device:
            WriteLog(LogFile,
                     "%s port %d --> %s" NEWLINE,
                     Parent -> Description,
                     ParentIndex+1,
                     Node -> Description);
            break;

        case EmptyPort:
            WriteLog(LogFile,
                     "%s port %d --> EmptyPort" NEWLINE,
                     Parent -> Description,
                     ParentIndex+1);
            break;
    }

    return;
}

VOID
DisplayDifferenceList(
    HANDLE          LogFile,
    ULONG           NumDifferences,
    PNODE_PAIR_LIST DifferenceList
)
{
    ULONG   index;

    if (0 != NumDifferences)
    {
        printf("Node Differences (%d)" NEWLINE
               "--------------------" NEWLINE,
               NumDifferences);

        for (index = 0; index < DifferenceList -> CurrentNodePairs; index++)
        {
            WriteLog(LogFile, NEWLINE
                     "Node Pair %d" NEWLINE
                     "-----------" NEWLINE,
                     index+1);

            DisplayDifferentNode(LogFile, DifferenceList -> NodePairs[index*2]);
            DisplayDifferentNode(LogFile, DifferenceList -> NodePairs[index*2+1]);
        }
    }

    return;
}

BOOLEAN
WriteDescriptionsCallbackPre(
    IN  PUSB_DEVICE_NODE Node,
    IN  HANDLE *         Context
)
{
    HANDLE  logFile;

    logFile = *Context;

    switch (Node -> NodeType)
    {
        case HostController:
        case Hub:
        case MIParent:
        case MIInterface:
        case Device:
            WriteLog(logFile, 
                     "%s",
                     Node -> Description);

            if (NULL != Node -> ConnectionInformation)
            {
                WriteLog(logFile, 
                         " %04X %04X", 
                         Node -> ConnectionInformation -> DeviceDescriptor.idVendor,
                         Node -> ConnectionInformation -> DeviceDescriptor.idProduct);
                
            }
            WriteLog(logFile, NEWLINE);
            break;

        default:
            break;
    }
    
    return (TRUE);
}

BOOL
WriteDescriptionsToLogFile(
    IN  HANDLE           LogFile,
    IN  PUSB_DEVICE_TREE Tree
)
{
    BOOL success;

    success = WalkUSBDeviceTree(Tree,
                                WriteDescriptionsCallbackPre,
                                NULL,
                                &LogFile);

    return (success);
}

int __cdecl
main(
    int argc,
    char *argv[]
)
{
    ULONG               index;
    BOOL                success;
    HANDLE              logFile;
    HANDLE              treeFile;
    DWORD               treeFileSize;
    PUSB_DEVICE_TREE    currentUSBTree;
    PUSB_DEVICE_TREE    savedUSBTree;
    SYSTEMTIME          localTime;
    NODE_PAIR_LIST      nodeList;
    ULONG               numNodes;

    //
    // Initialize, so that cleanup occurs appropriately on exit.
    //

    logFile        = INVALID_HANDLE_VALUE;
    treeFile       = INVALID_HANDLE_VALUE;
    currentUSBTree = NULL;
    savedUSBTree   = NULL;

    //
    // Try to parse the args
    //

    if (!ParseArgs(argc, argv)) 
    {
        TREELOG_EXIT(FALSE);
    }

    //
    // Try to open the log file...Specify sharing flags of 0 to get exclusive 
    //  access to this file.  
    //

#if 1
    logFile = CreateFile(LogFileName,
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_FLAG_WRITE_THROUGH,
                         NULL);

#else
    
    logFile = GetStdHandle(STD_OUTPUT_HANDLE);

#endif

    if (INVALID_HANDLE_VALUE == logFile)
    {
        TREELOG_EXIT(FALSE);
    }

    SetFilePointer(logFile, 0, NULL, FILE_END);

    //
    // Get and log the time
    //

    GetLocalTime(&localTime);

    success = WriteLog(logFile,
                       "%02d/%02d/%2d:  %02d:%02d:%02d" NEWLINE, 
                       localTime.wMonth,
                       localTime.wDay,
                       localTime.wYear,
                       localTime.wHour,
                       localTime.wMinute,
                       localTime.wSecond);

    currentUSBTree = BuildUSBDeviceTree();

    if (NULL == currentUSBTree)
    {
        WriteLog(logFile, 
                 "Error %d occurred building current USB device tree" NEWLINE,
                 GetLastError());

        TREELOG_EXIT(FALSE);
    }

    if (LogTree)
    {
        WriteUSBDeviceTreeToTextFile(logFile, currentUSBTree);
    }

    if (DumpDescriptions)
    {
        WriteDescriptionsToLogFile(logFile, currentUSBTree);

        TREELOG_EXIT(TRUE);
    }

    treeFile = CreateFile(DEFAULT_TREEFILE_NAME,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_FLAG_WRITE_THROUGH,
                          NULL);

    if (INVALID_HANDLE_VALUE == treeFile)
    {
        WriteLog(logFile, 
                 "Error %d occurred trying to open tree file" NEWLINE,
                 GetLastError());

        TREELOG_EXIT(FALSE);
    }

    //
    // Get the size of the tree file
    //

    treeFileSize = GetFileSize(treeFile, NULL);

    //
    // Write a new tree structure to the file if the file size 
    //

    if (NewTree || 0 == treeFileSize)
    {
        success = WriteUSBDeviceTreeToFile(treeFile, currentUSBTree);

        if (!success)
        {
            WriteLog(logFile, 
                     "Error %d occurred writing tree to tree file" NEWLINE,
                     GetLastError());

            TREELOG_EXIT(FALSE);
        }

        //
        // Reset the file pointer to the beginning of the file
        //

        SetFilePointer(treeFile, 0, NULL, FILE_BEGIN);
    }

    //
    // Retrieve the USB Tree that is stored in the file
    //

    success = ReadUSBDeviceTreeFromFile(treeFile, &savedUSBTree);

    if (!success)
    {
        WriteLog(logFile, 
                 "Error %d occurred reading saved device tree from tree file" NEWLINE,
                 GetLastError());

        TREELOG_EXIT(FALSE);
    }

    //
    // Add comparison of savedUSBTree to currentUSBTree and
    //  if different, log the node pairs....
    //

    InitializeNodePairList(&nodeList);

    success = CompareUSBDeviceTrees(currentUSBTree,
                                    savedUSBTree,
                                    &numNodes,
                                    &nodeList);

    //
    // If success is FALSE, then there are some differences in the tree
    //  write those differences to the log file.
    //

    if (!success) 
    {
        WriteLog(logFile, "Failed device tree comparison" NEWLINE);

        DisplayDifferenceList(logFile, numNodes, &nodeList);

        //
        // If the caller set break on error, then we need to break into the 
        //  debugger...
        //

        if (BreakOnError)
        {
            OutputDebugString("USB Device tree comparison failed" NEWLINE);

            DebugBreak();
        }
    }
    else 
    {
        WriteLog(logFile, "Pass: Trees are identical" NEWLINE);
    }

    DestroyNodePairList(&nodeList);
          
Treelog_Exit:

    if (INVALID_HANDLE_VALUE != treeFile)
    {
        CloseHandle(treeFile);
    }

    if (INVALID_HANDLE_VALUE != logFile)
    {
        CloseHandle(logFile);
    }

    if (NULL != currentUSBTree)
    {
        DestroyUSBDeviceTree(currentUSBTree);
    }

    if (NULL != savedUSBTree)
    {
        DestroyUSBDeviceTree(savedUSBTree);
    }

    //
    // Return an errorlevel code of 1 if the test failed and some point
    //

    return (success ? 0 : 1);
}

//*****************************************************************************
//
// ParseArgs()
//
//*****************************************************************************

BOOL
ParseArgs (
    int     argc,
    char   *argv[]
)
{
    int     i;
    char    *filename;

    if (argc < MIN_ARGS)
    {
        Usage();
        return FALSE;
    }

    for (i=1; i<argc; i++)
    {
        if (argv[i][0] == '-' ||  argv[i][0] == '/')
        {
            switch(argv[i][1])
            {
                case 'B':
                case 'b':
                    BreakOnError = TRUE;
                    break;

                case 'D':
                case 'd':
                    DumpDescriptions = TRUE;
                    break;

                case 'F':
                case 'f':
                    if ('\0' != argv[i][2]) 
                    {
                        filename = argv[i]+2;
                    }
                    else
                    {
                        i++;

                        if (i == argc)
                        {
                            Usage();

                            return FALSE;
                        }
                        
                        filename = argv[i];
                    }

                    if (strlen(filename) > MAX_PATH)
                    {
                        Usage();

                        return FALSE;
                    }

                    strcpy(LogFileName, filename);
                    FileNameSet = TRUE;
                    break;

                case 'L':
                case 'l':
                    LogTree = TRUE;
                    break;
                
                case 'N':
                case 'n':
                    NewTree = TRUE;
                    break;

                case '?':
                case 'H':
                case 'h':
                   Usage();
                   return (FALSE);

                case 'V':
                case 'v':
                   Verbose = TRUE;
                   break;
                
               default:
                   Usage();
                   return FALSE;
            }
        }
    }

    //
    // Dump parsed args if desired
    //

    if (Verbose)
    {
        printf( "BreakOnError:  %d" NEWLINE, BreakOnError);
        printf( "LogTree:       %d" NEWLINE, LogTree);
        printf( "NewTree:       %d" NEWLINE, NewTree);
        printf( "LogFileName:   %s" NEWLINE, LogFileName);
        printf( "Verbose:       %d" NEWLINE, Verbose);
    }

    return TRUE;
}

/*****************************************************************************
//
// Usage()
//
//****************************************************************************/

VOID
Usage(
    VOID
)
{
    Version();
    printf( "usage:" NEWLINE);
    printf( "-b             break into debugger on error" NEWLINE);
    printf( "-d             dump a list of device descriptions" NEWLINE);
    printf( "-f filename    log file name and path" NEWLINE
            "               filename must be less than %d chars" NEWLINE,
                            MAX_PATH);
    printf( "-l             log current tree to log file" NEWLINE);
    printf( "-n             create a new tree for comparison" NEWLINE);
    printf( "-V             verbose output" NEWLINE);
}

/*****************************************************************************
//
// Version()
//
//****************************************************************************/

void
Version ()
{
    printf( "TREELOG.EXE %s" NEWLINE, VER_PRODUCTVERSION_STR);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\inc\usbtsys.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    USBTSYSh

Abstract:

    This module contains the PUBLIC definitions for the code that interfaces
    with the USB test driver.  Most of the functionality of the USBTest driver
    should be abstracted into the USBTest.DLL.  

Environment:

    Kernel mode

Revision History:

    Jul-99 : created by Chris Robinson

--*/

#ifndef _USBTSYS_H
#define _USBTSYS_H

//*****************************************************************************
// K E R N E L   M O D E   I N C L U D E S
//*****************************************************************************

#include <basetyps.h>
#include <pshpack4.h>

//*****************************************************************************
// K E R N E L   M O D E   D E F I N E S  
//*****************************************************************************

//
// Define the class guid for these objects
//
// {5D58BA4A-E29E-4bf2-94C7-F2F2B6FE909C}
//

DEFINE_GUID(GUID_CLASS_USBTEST,
0x5d58ba4a, 0xe29e, 0x4bf2, 0x94, 0xc7, 0xf2, 0xf2, 0xb6, 0xfe, 0x90, 0x9c);

#define USBTESTNAME  "\\\\.\\USBTest"

//
// Define the IOCTLs visible to a user-mode application
//

#define IOCTL_USBTEST_INDEX        0x07F

#define IOCTL_USBTEST_CYCLE_PORT  CTL_CODE(FILE_DEVICE_UNKNOWN,\
                                            IOCTL_USBTEST_INDEX+1, \
                                            METHOD_BUFFERED, \
                                            FILE_ANY_ACCESS)

#define IOCTL_USBTEST_PARSE       CTL_CODE(FILE_DEVICE_UNKNOWN,\
                                            IOCTL_USBTEST_INDEX+2, \
                                            METHOD_BUFFERED, \
                                            FILE_ANY_ACCESS)


//*****************************************************************************
// K E R N E L   M O D E   T Y P E D E F S
//*****************************************************************************

typedef struct _CYCLE_PORT_PARAMETERS
{
    ULONG   NodeIndex;
    CHAR    HubName[0];
} CYCLE_PORT_PARAMETERS, *PCYCLE_PORT_PARAMETERS;


#include <poppack.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\inc\usbtest.h ===
/*++

Copyright (c) 1999    Microsoft Corporation

Module Name:

    USBTEST.H

Abstract:

    This file contains the definitions for the interface between user-mode
    applications and USBTEST.DLL.  USBTEST.DLL contains some common 
    processing routines and contains and interface to abstract communication
    with USBTEST.SYS.  

Environment:

    User mode

Revision History:

--*/

#ifndef _USBTEST_H
#define _USBTEST_H

//*****************************************************************************
// D E F I N E S  
//*****************************************************************************

#define MAXIMUM_ROOT_HUBS   16
#define HC_NAME_LENGTH      16

#define ALLOC(size) GlobalAlloc(GPTR, (size))
#define FREE(buf)   GlobalFree((buf))

#define IsExternalHub(node)  ( (Hub == (node) -> NodeType) &&               \
                                (NULL != (node) -> ConnectionInformation) )

#define IsRootHub(node)      ( (Hub == (node) -> NodeType) &&               \
                                (NULL == (node) -> ConnectionInformation) )

#define IsNonHubDevice(node) ( (MIParent == (node) -> NodeType) ||          \
                                (Device == (node) -> NodeType) )

#define IsUSBDevice(node)    ( (IsNonHubDevice(node)) || (IsExtenalHub(node)) )

#define POOL_TYPE ULONG

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <hidsdi.h>
#include <hidpddi.h>

//*****************************************************************************
// U S E R   M O D E   T Y P E D E F S
//*****************************************************************************

typedef enum _USB_DEVICE_NODE_TYPE {
    Computer, 
    HostController, 
    Hub, 
    MIParent,
    Device,
    MIInterface,
    EmptyPort
} USB_DEVICE_NODE_TYPE;

//
// Definition of one node in the USB device tree
//

typedef struct _USB_DEVICE_NODE
{
    USB_DEVICE_NODE_TYPE                NodeType;
    PCHAR                               SymbolicLink;
    PCHAR                               Description;
    PCHAR                               ClassName;
    DEVINST                             DeviceInstance;
    ULONG                               DeviceStatus;
    ULONG                               DeviceProblem;
                                        
    struct _USB_DEVICE_NODE             *Parent;

    PUSB_NODE_INFORMATION               NodeInformation;
    PUSB_NODE_CONNECTION_INFORMATION    ConnectionInformation;

    HANDLE                              HCHandle;

    ULONG                               NumberOfChildren;
    struct _USB_DEVICE_NODE             *Children[0];
}
USB_DEVICE_NODE, *PUSB_DEVICE_NODE;

//
// Definition of the device tree.  Currently this is just another node but
//   we may want to add fields that are only tree specific in the future.  
//   The routines that depend on the tree structure will abstract out any
//   future changes.
//

typedef USB_DEVICE_NODE USB_DEVICE_TREE;
typedef USB_DEVICE_TREE *PUSB_DEVICE_TREE;

//
// Definition of the node callback routine that can be specified for each
//  node when walking a usb device tree.

typedef BOOLEAN USB_DEVICE_NODE_CALLBACK(PUSB_DEVICE_NODE, PVOID);
typedef USB_DEVICE_NODE_CALLBACK *PUSB_DEVICE_NODE_CALLBACK;

//
// Definition of the node list structure used by the dll to report differences
//  between trees when comparing two trees
//

typedef struct _NODE_PAIR_LIST 
{
    ULONG               MaxNodePairs;
    ULONG               CurrentNodePairs;
    PUSB_DEVICE_NODE    *NodePairs;
} NODE_PAIR_LIST, *PNODE_PAIR_LIST;

#ifdef __cplusplus
extern "C" {
#endif

//*****************************************************************************
// U S E R   M O D E   F U N C T I O N   D E C L A R A T I O N S
//*****************************************************************************

BOOLEAN __stdcall
FindDevicesByClass(
    IN  CONST GUID    *ClassGuid,
    IN  PCHAR         *SymbolicLinks
);

HANDLE __stdcall
GetHubLowerFilterHandle(
    IN  PCHAR  HubInstanceName
);

PUSB_DEVICE_TREE __stdcall
BuildUSBDeviceTree(
    VOID
);

BOOLEAN __stdcall
CompareUSBDeviceTrees(
    IN  PUSB_DEVICE_TREE    Tree1,
    IN  PUSB_DEVICE_TREE    Tree2,
    OUT PULONG              NumberDifferences,
    OUT PNODE_PAIR_LIST     NodePairList
);

VOID
InitializeNodePairList(
    IN PNODE_PAIR_LIST  NodePairList
);

VOID
DestroyNodePairList(
    IN PNODE_PAIR_LIST  NodePairList
);

VOID __stdcall
DestroyUSBDeviceTree(
    IN  PUSB_DEVICE_TREE    Tree
);

BOOLEAN __stdcall
WriteUSBDeviceTreeToFile(
    IN  HANDLE              File,
    IN  PUSB_DEVICE_TREE    Tree
);

BOOLEAN __stdcall
ReadUSBDeviceTreeFromFile(
    IN  HANDLE              File,
    IN  PUSB_DEVICE_TREE    *Tree
);

BOOLEAN __stdcall
WriteUSBDeviceTreeToTextFile(
    IN  HANDLE              File,
    IN  PUSB_DEVICE_TREE    Tree
);

BOOLEAN __stdcall
WalkUSBDeviceTree(
    IN  PUSB_DEVICE_TREE            Tree,
    IN  PUSB_DEVICE_NODE_CALLBACK   PreWalkCallback,
    IN  PUSB_DEVICE_NODE_CALLBACK   PostWalkCallback,
    IN  PVOID                       Context
);

BOOLEAN __stdcall
CycleUSBPort(
    IN  PUSB_DEVICE_NODE    Node
);

BOOLEAN __stdcall
ParseReportDescriptor(
    IN  PCHAR               ReportDescriptor,
    IN  ULONG               DescriptorLength,
    OUT PHIDP_DEVICE_DESC   *DeviceDesc
);

BOOLEAN __stdcall
StartUSBTest(
    VOID
);

BOOLEAN __stdcall
StopUSBTest(
    VOID
);

#ifdef __cplusplus
}       // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\sys\usbtest\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract: USB Test driver

Author:

    Chris Robinson

Environment:

    Kernel mode

Revision History:


--*/
#include <wdm.h>
#include <usbioctl.h>

#include <wmilib.h>

#define WMI_SUPPORT
#include <usbhub.h>
#include <pshpack1.h>
#include <hidpddi.h>
#include <poppack.h>
#include "usbtsys.h"
#include "local.h"

NTSTATUS
USBTest_Ioctl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
)
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER(DeviceObject);
    
    USBTEST_ENTER_FUNCTION("USBTest_Ioctl");

    //
    // Get the current irp stack location
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    USBTest_KdPrint(1, ("Processing Ioctl with control code %x\n",
                        irpStack -> Parameters.DeviceIoControl.IoControlCode));
        
    //
    // Initialize the information field for this Irp.  A handling function
    //  may choose to edit this.  If it doesn't, then it won't want to 
    //  return any data and therefore we'll go with 0.  The Status field
    //  of the block will be set after the call to handling function
    //

    Irp -> IoStatus.Information = 0;

    //
    // Process the IOCTL accordingly
    //

    switch (irpStack -> Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_USBTEST_CYCLE_PORT:
            status = USBTest_CyclePort(DeviceObject, Irp);
            break;

        case IOCTL_USBTEST_PARSE:
            status = USBTest_ParseReportDescriptor(DeviceObject, Irp);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    //
    // Setup the status field and complete the IRP.  The information
    //  was initialized above but the handling function may have changed
    //  it.  
    //

    Irp -> IoStatus.Status      = status;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    USBTEST_EXIT_FUNCTION("USBTest_Ioctl");
    USBTEST_EXIT_STATUS(status);

    return (status);
}

NTSTATUS
USBTest_CyclePort(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
)
{
    PCYCLE_PORT_PARAMETERS      params;
    PCYCLE_PORT_WORKER_CONTEXT  cyclePortContext;
    PIO_WORKITEM                cyclePortWorkItem;
    KEVENT                      cyclePortEvent;
    NTSTATUS                    status;

    USBTEST_ENTER_FUNCTION("USBTest_CyclePort");

    //
    // Since Win9x checks the requestor mode of this request and this
    //  routine is processing a user-mode request, it is doing some
    //  parameter checking in the call to IoGetDeviceObjectPointer which
    //  is causing the routine to fail with a page fault.  The file
    //  handle being passed in by IoGetDeviceObjectPointer() to IoCreateFile()
    //  is kernel-mode and failing the user-mode probe.  Therefore, we need
    //  to insure that the requesting mode is kernel-mode so this check is
    //  not done.  Therefore, we queue a workitem to actually issue the cycle
    //  port internal ioctl and wait for that to complete before we complete 
    //  the original user-mode request.
    //

    //
    // Setup the context for the worker function.  We need to pass in
    //  the cycle port parameters and an event to be signalled when the
    //  work item completes.
    //

    cyclePortContext = ExAllocatePool(PagedPool, sizeof(cyclePortContext));

    if (NULL == cyclePortContext)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto USBTest_CyclePort_Exit;
    }

    //
    // Initialize the event to be signaled.
    //

    KeInitializeEvent(&cyclePortEvent, 
                      NotificationEvent,
                      FALSE);

    cyclePortContext -> DoneEvent = &cyclePortEvent;
    cyclePortContext -> Params    = Irp -> AssociatedIrp.SystemBuffer;

    //
    // Now, create the workitem
    //

    cyclePortWorkItem = IoAllocateWorkItem(DeviceObject);

    if (NULL == cyclePortWorkItem)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;

        ExFreePool(cyclePortContext);

        goto USBTest_CyclePort_Exit;
    }

    //
    // Queue the work item and wait for our event to be signaled
    //

    IoQueueWorkItem(cyclePortWorkItem,
                    USBTest_CyclePortWorker,
                    DelayedWorkQueue,
                    cyclePortContext);

    KeWaitForSingleObject(&cyclePortEvent,
                          UserRequest,
                          KernelMode,
                          FALSE,
                          NULL);

    //
    // Now that the internal ioctl may have been issued, retrieve the status
    //  value to complete the irp with from the context.
    //
    
    status = cyclePortContext -> Status;

    //
    // Cleanup the stuff that was allocated
    //

    ExFreePool(cyclePortContext);

    IoFreeWorkItem(cyclePortWorkItem);

USBTest_CyclePort_Exit:

    USBTEST_EXIT_FUNCTION("USBTest_CyclePort");
    USBTEST_EXIT_STATUS(status);

    return (status);
}

VOID
USBTest_CyclePortWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
)
{
    PCYCLE_PORT_WORKER_CONTEXT  cyclePortContext;
    PCYCLE_PORT_PARAMETERS      cyclePortParams;
    PKEVENT                     cyclePortEvent;
    PIO_STACK_LOCATION          irpStack;
    NTSTATUS                    status;
    PCHAR                       hubNameA;
    PWCHAR                      hubNameW;
    ANSI_STRING                 ansiHubName;
    UNICODE_STRING              fullUniHubName;
    UNICODE_STRING              partialUniHubName;
    UNICODE_STRING              win2kDriverName;
    UNICODE_STRING              win9xDriverName;
    BOOLEAN                     isHubDriver;
    ULONG                       nameSize;
    PFILE_OBJECT                hubFileObject;
    PDEVICE_OBJECT              hubDeviceObject;
    PDEVICE_OBJECT              portDeviceObject;
    PDRIVER_OBJECT              driverObject;
    PDEVICE_EXTENSION_HUB       hubExtension;
    PPORT_DATA                  portData;
    KEVENT                      event;
    IO_STATUS_BLOCK             statusBlock;
    ULONG                       portIndex;
    PIRP                        irp;

    UNREFERENCED_PARAMETER(DeviceObject);

    USBTEST_ENTER_FUNCTION("USBTest_CyclePortWorker");

    //
    // Extract the context and the items from the context
    //

    cyclePortContext = (PCYCLE_PORT_WORKER_CONTEXT) Context;
    cyclePortEvent   = cyclePortContext -> DoneEvent;
    cyclePortParams  = cyclePortContext -> Params;

    //
    // Extract the information on which port to cycle
    //

    portIndex = cyclePortParams -> NodeIndex-1;
    hubNameA  = &(cyclePortParams -> HubName[0]);

    USBTest_KdPrint(2, ("Attempting to cycle port %d on hub %s\n", 
                        portIndex+1,
                        hubNameA));

    //
    // Convert the symbolic string name passed in by the user mode
    //  app to a form that will be recognizable by IoGetDeviceObjectPointer.
    //  The string that will be passed in is an ASCII string and needs to
    //  be converted to UNICODE.  Plus, the \??\ prefix needs to be added
    //

    RtlInitAnsiString(&ansiHubName, hubNameA);

    //
    // Allocate space for the full device name...the passed in name with
    //  the prefix added.
    //

    nameSize = RtlAnsiStringToUnicodeSize(&ansiHubName) + sizeof(L"\\DosDevices\\");

    hubNameW = ExAllocatePool(PagedPool, nameSize);

    if (NULL == hubNameW)
    {
        status = STATUS_NO_MEMORY;

        goto USBTest_CyclePortWorker_Exit;
    }

    RtlZeroMemory(hubNameW, nameSize);

    //
    // Convert the ansi string to a unicode string
    //

    status = RtlAnsiStringToUnicodeString(&partialUniHubName,
                                          &ansiHubName, 
                                          TRUE);
    if (!NT_SUCCESS(status))
    {
        USBTest_KdPrint(2, ("Failed to convert the ansi string to a unicode"
                            " string\n"));

        ExFreePool(hubNameW);

        goto USBTest_CyclePortWorker_Exit;
    }

    //
    // Initialize the unicode device string
    //

    fullUniHubName.Buffer        = hubNameW;
    fullUniHubName.Length        = 0;
    fullUniHubName.MaximumLength = (USHORT) nameSize;

    //
    // Make the unicode symbolic link name
    //

    RtlAppendUnicodeToString(&fullUniHubName, L"\\DosDevices\\");
    RtlAppendUnicodeStringToString(&fullUniHubName, &partialUniHubName);

    status = IoGetDeviceObjectPointer(&fullUniHubName,
                                      0,
                                      &hubFileObject,
                                      &hubDeviceObject);

    //    
    // Free the fullDeviceName and the partial device name as they are no
    //  longer needed
    //

    RtlFreeUnicodeString(&partialUniHubName);

    ExFreePool(hubNameW);

    //
    // Check the status of the IoGetDeviceObjectPointer() call
    //

    if (!NT_SUCCESS(status)) 
    {
        USBTest_KdPrint(2, ("Failed to get device and file object pointers "
                            "with status %x\n",
                            status));

        goto USBTest_CyclePortWorker_Exit;
    }

    //
    // Make sure we have the hub device object and not some filter on top
    //    On Win2k, the DriverName is \\Driver\Usbhub
    //    On Win9x, the DriverName is \\Driver\usbhub.sys
    //    
    //  Since I'd like to keep this driver platform independent...I will check
    //  for one or the other.
    //

    RtlInitUnicodeString(&win2kDriverName, L"\\Driver\\Usbhub");
    RtlInitUnicodeString(&win9xDriverName, L"\\Driver\\usbhub.sys");

    while (NULL != hubDeviceObject)
    {
        driverObject = hubDeviceObject -> DriverObject;

        USBTest_KdPrint(2, ("Comparing driver object name: %x\n", 
                            driverObject -> DriverName.Buffer));

        //
        // Check for either of the two driver names
        // 

        isHubDriver = (0 == RtlCompareUnicodeString(&driverObject->DriverName,
                                                    &win2kDriverName,
                                                    TRUE)) ||
                      (0 == RtlCompareUnicodeString(&driverObject->DriverName,
                                                    &win9xDriverName,
                                                    TRUE));

        if (isHubDriver)
        {
            break;
        }

        //
        // OK, this driver was a filter, go to the next device object 
        //  in the device stack
        //

        hubDeviceObject = hubDeviceObject -> NextDevice;
    }

    //
    // If we have NULL device object then something went seriously wrong,
    //  Most likely we are either not comparing the driver name string to
    //  the appropriate value for the hub or we just never got an
    //  instance of a hub.  The former we can solve, the latter will be really
    //  bad
    //

    ASSERT(NULL != hubDeviceObject);

    //
    // Get the hub device extension
    //

    hubExtension = hubDeviceObject -> DeviceExtension;

    USBTest_KdPrint(2, ("Hub extension: %x\n", hubExtension));

    //
    // Make sure this device extension is of type EXTENSION_TYPE_HUB
    //

    ASSERT(EXTENSION_TYPE_HUB == hubExtension -> ExtensionType);

    //
    // Get the port data for this hub...This will let us get access to
    //  the PDO of the device on the port we want to cycle.
    //

    portData = hubExtension -> PortData;
    portData += portIndex;

    //
    // Get the port device object
    //

    portDeviceObject = portData -> DeviceObject;

    //
    // Allocate an irp to send to the hub driver to send the cycle port
    //  request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_CYCLE_PORT,
                                        portDeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE,
                                        &event,
                                        &statusBlock);


    if (NULL == irp)
    {
        USBTest_KdPrint(2, ("Irp not allocated for cycle port ioctl\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;

        goto USBTest_CyclePortWorker_Exit;
    }

    status = IoCallDriver(portDeviceObject, irp);

    if (STATUS_PENDING == status)
    {
        USBTest_KdPrint(2, ("Pending returned for cycle port ioctl\n"));

        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = statusBlock.Status;
    }

USBTest_CyclePortWorker_Exit:

    //
    // Set the status of this call in the context
    //

    cyclePortContext -> Status = status;

    //
    // Signal the event that the dispatch thread is waiting on and leave...
    //

    KeSetEvent(cyclePortEvent, 
               IO_NO_INCREMENT, 
               FALSE);

    USBTEST_EXIT_FUNCTION("USBTest_CyclePortWorker");
    USBTEST_EXIT_STATUS(status);

    return;
}

NTSTATUS
USBTest_ParseReportDescriptor(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PIO_STACK_LOCATION      irpStack;
    PHIDP_COLLECTION_DESC   hidCollectionDesc;
    PHIDP_COLLECTION_DESC   currentCollection;
    PHIDP_REPORT_IDS        hidReportIDs;
    PHIDP_PREPARSED_DATA    hidPreparsedData;
    PHIDP_DEVICE_DESC       returnedDesc;
    HIDP_DEVICE_DESC        hidDeviceDesc;
    NTSTATUS                status;
    PCHAR                   ioBuffer;
    ULONG                   inputBufferLength;
    ULONG                   outputBufferLength;
    ULONG                   hidCollectionLength;
    ULONG                   hidReportIDLength;
    ULONG                   totalPreparsedDataLength;
    ULONG                   numCollections;
    ULONG                   index;
    ULONG                   outputSize;

    UNREFERENCED_PARAMETER(DeviceObject);

    USBTEST_ENTER_FUNCTION("USBTest_ParseReportDescriptor");

    //
    // Get the IRP stack location which will contain the parameters for this
    //  call
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the information on the buffer to be used: 
    //   -- pointer to the buffer, input length, and output length
    //

    ioBuffer           = Irp -> AssociatedIrp.SystemBuffer;

    inputBufferLength  = irpStack -> Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack -> Parameters.DeviceIoControl.OutputBufferLength;

    //
    // The input buffer contains the raw report descriptor that is to be
    //  parsed.  To parse the descriptor we need to call 
    //  HidP_GetCollectionDescription().  This call will fill in the 
    //  HIDP_DEVICE_DESC structure that is passed in.  The call will 
    //  allocate two buffers for the collection information and the report
    //  ID information that will need to be freed before exit.
    //

    status = HidP_GetCollectionDescription(ioBuffer,
                                           inputBufferLength,
                                           PagedPool,
                                           &hidDeviceDesc);

    //
    // If the call failed, leave the function but return this status
    //  to the calling app.
    //

    if (!NT_SUCCESS(status)) 
    {
        USBTest_KdPrint(2, ("Error %x occurred parsing report descriptor\n",
                            status));

        goto USBTest_ParseReportDescriptor_Exit;
    }

    //
    // Now that we have parsed the function, we need to return the results
    //  to the calling app.  Unfortunately, the memory that was allocated
    //  by HidP_GetCollectionDescription is from kernel-mode.  Therefore
    //  we'll copy the data returned by the parser into the output buffer
    //  and then store relative pointers (offsets) to the data in the 
    //  buffer for the pointers that are in the structures.  The user-mode
    //  app must then handle recreating the user-mode pointers.  The order
    //  of the structures will be as follows to be consistent with the
    //  behavior in usbdiag:
    //
    //  -- HIDP_DEVICE_DESC -- pointers to collection information
    //                         and report ID information are offsets into
    //                         this buffer
    //
    //  -- HIDP_REPORT_IDS  -- Variable length array of report ID information
    //
    //  -- HIDP_COLLECTION_DESC -- Variable length array of collection info
    //                              Pointers to preparsed data blocks will be
    //                              offsets into the buffer
    //
    //  -- HIDP_PREPARSED_DATA  -- One variable length structure for each
    //                                collection that was found
    //

    //
    // Extract the pointers to the collection description array, the preparsed
    //  data and the report ID array
    //

    hidCollectionDesc      = hidDeviceDesc.CollectionDesc;
    numCollections         = hidDeviceDesc.CollectionDescLength;
    hidCollectionLength    = numCollections * sizeof(HIDP_COLLECTION_DESC);
                           
    hidReportIDs           = hidDeviceDesc.ReportIDs;
    hidReportIDLength      = hidDeviceDesc.ReportIDsLength *
                                                   sizeof(HIDP_REPORT_IDS);

    //
    // Calculate the total preparsed data length
    //

    totalPreparsedDataLength = 0;

    for (index = 0; index < numCollections; index++)
    {
        totalPreparsedDataLength += 
                         hidCollectionDesc[index].PreparsedDataLength;
    }

    //
    // Before copying the data, calculate the size of output buffer that is 
    //  needed.  If the output buffer is not big enough, then we will return
    //  only the needed size 
    //

    outputSize = sizeof(HIDP_DEVICE_DESC) +
                   hidReportIDLength      +
                   hidCollectionLength    +
                   totalPreparsedDataLength;

    USBTest_KdPrint(2, ("RIDLen: %d  CollLen: %d, PpdLen: %d\n",
                        hidReportIDLength,
                        hidCollectionLength,
                        totalPreparsedDataLength));

    USBTest_KdPrint(2, ("Needed output size: %d, outputBufferLength: %d\n",
                        outputSize, outputBufferLength));

    if (outputBufferLength < outputSize)
    {
        //
        // Check if the buffer is at least big enough to hold a ULONG, if
        //  so, store the needed size and return only 4 bytes otherwise return
        //  0 bytes
        //  

        if (outputBufferLength >= sizeof(ULONG)) 
        {
            //
            // Return the STATUS_BUFFER_OVERFLOW warning so that the
            //  proper number of bytes is copied to the user-mode buffer
            //

            status = STATUS_BUFFER_OVERFLOW;

            *((PULONG) ioBuffer) = outputSize;

            Irp -> IoStatus.Information = sizeof(ULONG);
        }
        else 
        {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp -> IoStatus.Information = 0;
        }

        goto USBTest_ParseReportDescriptor_Exit;
    }

    //
    // OK, we've got enough room to copy all the information into the output
    //  buffer.  So let's do it..
    //

    //
    // First, zero out the output buffer memory
    //

    RtlZeroMemory(ioBuffer, outputBufferLength);

    //
    // Save a pointer to the beginning of the buffer
    //

    returnedDesc = (PHIDP_DEVICE_DESC) ioBuffer;

    //
    // Copy all the parse data into the proper spots in the output buffer,
    //  starting with the device description
    //

    RtlCopyMemory(ioBuffer, &hidDeviceDesc, sizeof(HIDP_DEVICE_DESC));

    ioBuffer += sizeof(HIDP_DEVICE_DESC);

    //
    // Now the report IDs structure changing the pointer in the device
    //  description to an offset in the process
    //

    RtlCopyMemory(ioBuffer, hidReportIDs, hidReportIDLength);

    ((ULONG) returnedDesc -> ReportIDs) = (ioBuffer - (PCHAR) returnedDesc);

    ioBuffer += hidReportIDLength;

    ASSERT( ((ULONG) (ioBuffer - (PCHAR) returnedDesc)) == sizeof(HIDP_DEVICE_DESC)+hidReportIDLength);
    //
    // Next all the collection descriptions...Patch the device description
    //  pointer field as well.  Also save a pointer to this array in
    //  output buffer so that the preparsed data fields can be appropriately
    //  back patched at a later time.
    //

    RtlCopyMemory(ioBuffer, hidCollectionDesc, hidCollectionLength);

    ((ULONG) returnedDesc -> CollectionDesc) =
                                  (ioBuffer - (PCHAR) returnedDesc);

    currentCollection = (PHIDP_COLLECTION_DESC) ioBuffer;

    ioBuffer += hidCollectionLength;

    ASSERT( ((ULONG) (ioBuffer - (PCHAR) returnedDesc)) == sizeof(HIDP_DEVICE_DESC)+hidReportIDLength+hidCollectionLength);

    //
    // Now the preparsed data...After a block is copied, save the offset to
    //  that block in the appropriate collection description.  
    //

    for (index = 0; index < numCollections; index++) 
    {
        USBTest_KdPrint(2, ("Copying %d bytes of ppd to buffer at %d IRQL\n", 
                      hidCollectionDesc[index].PreparsedDataLength,
                      KeGetCurrentIrql()));
                            
        RtlCopyMemory(ioBuffer, 
                      hidCollectionDesc[index].PreparsedData,
                      hidCollectionDesc[index].PreparsedDataLength);
                                                                    
        USBTest_KdPrint(2, ("Finished copying ppd to buffer\n"));

        //
        // Patch the preparsed data field in the appropriate hid collection
        //

        ((ULONG) currentCollection -> PreparsedData) =
                                            (ioBuffer - (PCHAR) returnedDesc);


        USBTest_KdPrint(2, ("Finished patching the preparsed data field\n"));

        ioBuffer += hidCollectionDesc[index].PreparsedDataLength;

        USBTest_KdPrint(2, ("ioBuffer has been incremented\n"));

        currentCollection++;

        USBTest_KdPrint(2, ("Going to process next collection\n"));
    }

    //
    // Set the information structure to the number of bytes we are returning
    //

    USBTest_KdPrint(2, ("Result: %d\n", 
                        ((ULONG) (ioBuffer - (PCHAR) returnedDesc)) ));

    ASSERT( ((ULONG) (ioBuffer - (PCHAR) returnedDesc)) == outputSize);

    Irp -> IoStatus.Information = outputSize;

    status = STATUS_SUCCESS;

USBTest_ParseReportDescriptor_Exit:

    //
    // Call HidP_FreeCollectionDescription() so that it can cleanup
    //

    HidP_FreeCollectionDescription(&hidDeviceDesc);

    USBTEST_EXIT_FUNCTION("USBTest_ParseReportDescriptor");
    USBTEST_EXIT_STATUS(status);

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\sys\usbtest\local.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    Local.h

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements the USB Test Driver

Environment:

    Kernel mode

Revision History:

    Jul-99 : created by Chris Robinson

--*/


#ifndef _USBTEST_LOCAL_H
#define _USBTEST_LOCAL_H

#include <pshpack4.h>

#include <poppack.h>

#define USBTEST_TAG (ULONG) 'tbsU'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, USBTEST_TAG);

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect

#if DBG

extern ULONG    USBTest_Debug_Level;

#define USBTest_KdPrint(l, _x_) \
               if ((l) <= USBTest_Debug_Level) { \
                   DbgPrint _x_; \
               }

#define USBTEST_ENTER_FUNCTION(_x_) USBTest_KdPrint(1, ("Entering " _x_ "\n"))
#define USBTEST_EXIT_FUNCTION(_x_)  USBTest_KdPrint(1, ("Exiting " _x_ "\n"))

#define USBTEST_EXIT_STATUS(_x_)    USBTest_KdPrint(1, ("Exit status: %x\n", _x_))
#define USBTEST_EXIT_POINTER(_x_)   USBTest_KdPrint(1, ("Exit pointer: %08x\n", _x_))
#define USBTEST_EXIT_ULONG(_x_)     USBTest_KdPrint(1, ("Exit ulong: %x\n", _x_))

#define TRAP() DbgBreakPoint()

#else


#define USBTest_KdPrint(l, _x_)

#define USBTEST_ENTER_FUNCTION(_x_) 
#define USBTEST_EXIT_FUNCTION(_x_)  

#define USBTEST_EXIT_STATUS(_x_)  
#define USBTEST_EXIT_POINTER(_x_)   
#define USBTEST_EXIT_ULONG(_x_)     

#define TRAP()

#endif

#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#define MAX(a,b) (((a) < (b)) ? (b) : (a))

//
// Structures and macros for accessing a list
//

#define INITIALIZE_LIST(list)    InitializeListHead(&((list) -> List)); \
                                 KeInitializeSpinLock(&((list) -> ListSpin)); \
                                 (list) -> ElementCount = 0
                                 
#define LOCK_LIST(list, irql)    KeAcquireSpinLock(&((list)->ListSpin), \
                                                   &(irql))

#define UNLOCK_LIST(list, irql)  KeReleaseSpinLock(&((list)->ListSpin), \
                                                   (irql))

#define APPEND_LIST_ELEMENT(list, e) InsertTailList(&((list) -> List), e); \
                                                   ((list) -> ElementCount)++

#define PREPEND_LIST_ELEMENT(list, e) InsertHeadList(&((list) -> List), e); \
                                                     ((list) -> ElementCount)++

#define REMOVE_FIRST_ELEMENT(list)   RemoveHeadList(&((list) -> List)) \
                                     ((list) -> ElementCount)-- \

#define REMOVE_LAST_ELEMENT(list)    RemoveTailList(&((list) -> List)); \
                                     ((list) -> ElementCount)--

#define IS_LIST_EMPTY(list)         (0 == (list) -> ElementCount) 

#define GET_ELEMENT_COUNT(list)     ((list) -> ElementCount)

typedef struct _LIST
{
    LIST_ENTRY  List;
    KSPIN_LOCK  ListSpin;
    ULONG       ElementCount;
} LIST, *PLIST;

//
// Data for each of the ports on this hub
//

typedef struct _FILTER_PORT_DATA
{
    USHORT  PortStatus;
    USHORT  PortChange;
} FILTER_PORT_DATA, *PFILTER_PORT_DATA;

typedef struct _CYCLE_PORT_WORKER_CONTEXT
{
    PCYCLE_PORT_PARAMETERS  Params;
    PKEVENT                 DoneEvent;
    PIRP                    Irp;
    NTSTATUS                Status;
} CYCLE_PORT_WORKER_CONTEXT, *PCYCLE_PORT_WORKER_CONTEXT;

//
// A device extension for the device object placed into the attachment
// chain.
//

#define HUB_STATUS_DEFAULT  0x00000000

#define STATUS_STARTED   1
#define STATUS_PAUSED    2
#define STATUS_REMOVED   3

typedef struct _FILTER_DATA
{
    ULONG               Status;

    PDEVICE_OBJECT      Self;              // Pointer to this filter device
                                           //  object
    PDEVICE_OBJECT      PDO;               // PDO of the usb hub
    PDEVICE_OBJECT      TopOfStack;        // The top of the device stack just
                                           // beneath this filter device object.

    UNICODE_STRING      SymbolicLink;

    KEVENT              PnPCompleteEvent;  // an event to sync PnP IRPs.
    KEVENT              PauseEvent;        // an event to synch outstanding IO 
                                           //   to zero

    IO_REMOVE_LOCK      RemoveLock;        // Use a remove lock to synchronize
                                           // completion of outstanding IO 
                                           // requests


    ULONG               OutstandingIO;     // 1 biased count of reasons why
                                           // this object should stick around

    KSPIN_LOCK          PortDataSpinLock;  // Spinlock to protect access to the
                                           //  port data and irps that need 
                                           //  to be tracked
    PIRP                QueuedHubIrp;      // The irp that was sent from the 
                                           //  hub driver which we have queued
                                           //  and issued a secondary irp in
                                           //  its place.
    PIRP                SentHubIrp;        // The secondary irp allocated in
                                           //  by the driver to function as 
                                           //  as the request to the hub 
                                           //  interrupt endpoint.

    ULONG               HubStatus;         // A byte value which corresponds
                                           //   to the hub status data that
                                           //   needs to be returned to the 
                                           //   hub driver

    ULONG               PortsRemoved;      // Bitmap to track which ports
                                           //  unplugs are being simulated for
                                           //

    ULONG               NumberOfPorts;     // Number of ports on this hub
    PFILTER_PORT_DATA   PortData;          // Data allocated to track 
                                           //   the status of each of the ports
} FILTER_DATA, *PFILTER_DATA;

//
// Context structure for handling hub interrupt urb completion
//

typedef struct _HUB_URB_CONTEXT
{
    PIRP            OriginalIrp;
    KEVENT          SyncEvent;
    IO_STATUS_BLOCK StatusBlock;
} HUB_URB_CONTEXT, *PHUB_URB_CONTEXT;

//
// Define the structure related to parsing control transfer data
//  The parsing routine will take a setup packet and extract the relevant
//  information into this structure.
//

#define REQUEST_TARGET_MASK         0x03

#define REQUEST_TARGET_DEVICE       0
#define REQUEST_TARGET_INTERFACE    1
#define REQUEST_TARGET_ENDPOINT     2
#define REQUEST_TARGET_OTHER        3

#define REQUEST_TYPE_MASK           0x60

#define REQUEST_TYPE_STANDARD       0
#define REQUEST_TYPE_CLASS          1
#define REQUEST_TYPE_VENDOR         2
#define REQUEST_TYPE_OTHER          3

#define MAKE_REQUEST_VALUE(type, target, req)    (((type) << 16) + \
                                                  ((target) << 8) + \
                                                  ((req)))

//
// Hub requests 
//

//
// Request codes, defined in Chapter 11
//

#define REQUEST_GET_STATUS          0
#define REQUEST_CLEAR_FEATURE       1
#define REQUEST_GET_STATE           2
#define REQUEST_SET_FEATURE         3
#define REQUEST_SET_ADDRESS         5
#define REQUEST_GET_DESCRIPTOR      6
#define REQUEST_SET_DESCRIPTOR      7
#define REQUEST_GET_CONFIGURATION   8
#define REQUEST_SET_CONFIGURATION   9
#define REQUEST_GET_INTERFACE       10
#define REQUEST_SET_INTERFACE       11
#define REQUEST_SYNCH_FRAME         12

//
// Hub feature selector, defined in Chapter 11
//

#define FEATURE_C_HUB_LOCAL_POWER   0
#define FEATURE_C_HUB_OVER_CURRENT  1
#define FEATURE_PORT_CONNECT        0
#define FEATURE_PORT_ENABLE         1
#define FEATURE_PORT_SUSPEND        2
#define FEATURE_PORT_OVER_CURRENT   3
#define FEATURE_PORT_RESET          4
#define FEATURE_PORT_POWER          8
#define FEATURE_PORT_LOW_SPEED      9
#define FEATURE_C_PORT_CONNECT      16
#define FEATURE_C_PORT_ENABLE       17
#define FEATURE_C_PORT_SUSPEND      18
#define FEATURE_C_PORT_OVER_CURRENT 19
#define FEATURE_C_PORT_RESET        20

typedef struct _CONTROL_REQUEST
{
    //
    // The type of the request (standard, class, vendor, or other)
    //

    ULONG   Type;

    //
    // The USB function that is being performed
    //

    ULONG   Function;

    //
    // 
    //
    // The target (device, interface, or endpoint) for this request
    //

    ULONG   Target;

    //
    // Define a union of the relevant parameters for each of the 
    //  different control functions
    //

    union
    {
        //
        // GET_DESCRIPTOR
        //

        struct
        {
            ULONG   DescriptorType;
            ULONG   DescriptorIndex;
        };

        //
        // SET_ADDRESS
        //

        struct
        {
            ULONG   DeviceAddress;
        };

        //
        // SET_CONFIGURATION
        //

        struct 
        {
            ULONG   ConfigurationValue;
        };

        //
        // Other functions
        //

        struct 
        {
            USHORT  Value;
            USHORT  Index;
            USHORT  Length;
        };
    };
} CONTROL_REQUEST, *PCONTROL_REQUEST;

//typedef NTSTATUS (*PCONTROL_REQUEST_ROUTINE) ( PDEVICE_OBJECT,
//                                               PIRP, 
//                                               PCONTROL_REQUEST,
//                                               PURBLOG_CONTEXT);
//

#define HANDLED_REQUEST_TERMINATE   0xFFFFFFFF

typedef struct _HANDLED_REQUEST
{
    ULONG                       RequestValue;
//    PCONTROL_REQUEST_ROUTINE    RequestRoutine;
}
HANDLED_REQUEST, *PHANDLED_REQUEST;

//
// USBTEST.C
//

NTSTATUS
USBTest_Create(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
USBTest_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

VOID
USBTest_Unload(
    IN PDRIVER_OBJECT DriverObject
);

//
// IOCTL.C
//

NTSTATUS
USBTest_Ioctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
USBTest_CyclePort(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
);


VOID
USBTest_CyclePortWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
);

NTSTATUS
USBTest_ParseReportDescriptor(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\intrface.c ===
/*--         
Copyright (c) 1998, 1999  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/

#include "usbverfy.h"

VOID
UsbVerify_InterfaceListNewPipe(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PUSBD_PIPE_INFORMATION       PipeInformation
    )
/*++

Assumes that the pipe list lock is held.

  --*/
{
    USB_VERIFY_LOG_ENTRY entry;

    UsbVerify_Print(DeviceExtension, PRINT_PIPE_INFO,
            ("Pipe Info:\n"
             "\tMaximumPacketSize %d\n"
             "\tEndpointAddress %d\n"
             "\tInterval %d\n"
             "\tPipeType %d\n"
             "\tPipeHandle 0x%x\n"
             "\tMaximumTransferSize %d\n"
             "\tPipeFlags 0x%x\n\n",
             (ULONG) PipeInformation->MaximumPacketSize,
             (ULONG) PipeInformation->EndpointAddress,
             (ULONG) PipeInformation->Interval,
             PipeInformation->PipeType,
             PipeInformation->PipeHandle,
             PipeInformation->MaximumTransferSize,
             PipeInformation->PipeFlags));

    if (DeviceExtension->LogFlags & LOG_PIPES) {
        ZeroLogEntry(&entry);

        entry.Type = LOG_PIPES;
        entry.u.Pipe.NewPipe = TRUE;
        RtlCopyMemory(&entry.u.Pipe.PipeInfo,
                      PipeInformation,
                      sizeof(*PipeInformation));

        UsbVerify_Log(DeviceExtension, &entry);
    }
}

#define UsbVerify_LogInterface(devExt, newInt, intNum, altSetting)  \
    if ((devExt)->LogFlags & LOG_INTERFACES) {                      \
        USB_VERIFY_LOG_ENTRY entry;                                 \
        ZeroLogEntry(&entry);                                       \
        entry.Type = LOG_INTERFACES;                                \
        entry.u.Interface.NewInterface = newInt;                    \
        entry.u.Interface.Number = intNum;                          \
        entry.u.Interface.AlternateSetting = altSetting;            \
        UsbVerify_Log(devExt, &entry);                              \
    }

VOID
UsbVerify_LogInterfaceRemoval(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PUSBD_INTERFACE_INFORMATION Interface
    )
{
    UsbVerify_LogInterface(DeviceExtension,
                           FALSE, 
                           Interface->InterfaceNumber, 
                           Interface->AlternateSetting);

    if (DeviceExtension->LogFlags & LOG_PIPES) {
        USB_VERIFY_LOG_ENTRY entry;
        ULONG                pipeIndex;

        ZeroLogEntry(&entry);

        entry.u.Pipe.NewPipe = FALSE;
        entry.u.Pipe.RemovalCause = RemoveSelectInterface;

        for (pipeIndex = 0;
             pipeIndex < Interface->NumberOfPipes;
             pipeIndex++) {
    
            entry.u.Pipe.PipeInfo.PipeHandle = 
                Interface->Pipes[pipeIndex].PipeHandle;
    
            UsbVerify_Log(DeviceExtension, &entry);
        }
    }
}

VOID
UsbVerify_ClearInterfaceList(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    USB_VERIFY_REMOVAL_CAUSE     Cause
    )
/*++

Assumes that the pipe list lock is being held

  --*/
{
    LONG intIndex;
    ULONG pipeIndex;
    PUSBD_INTERFACE_INFORMATION interface;

    UsbVerify_AssertInterfaceListLocked(DeviceExtension);

    for (intIndex = 0; intIndex < DeviceExtension->InterfaceListSize; intIndex++) {
        interface = DeviceExtension->InterfaceList[intIndex];

        UsbVerify_LogInterfaceRemoval(DeviceExtension, interface);
        ExFreePool(interface);
    }                 

    if (DeviceExtension->InterfaceList) {
        ExFreePool(DeviceExtension->InterfaceList);
        DeviceExtension->InterfaceList = NULL;
    }

    DeviceExtension->InterfaceListSize = -1;
    DeviceExtension->InterfaceListCount = -1;
}

VOID
UsbVerify_InitializeInterfaceList(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    ULONG NumberOfInterfaces,
    BOOLEAN RemoveOldEntries 
    )
/*++

Assumes that the pipe list lock is being held

  --*/
{
    PUSBD_INTERFACE_INFORMATION *oldInterfaceList = NULL;

    UsbVerify_AssertInterfaceListLocked(DeviceExtension);

    UsbVerify_ASSERT(NumberOfInterfaces > 0, DeviceExtension->Self, NULL, NULL);

    if (RemoveOldEntries) {
        if (DeviceExtension->InterfaceList) {
            UsbVerify_ClearInterfaceList(DeviceExtension, RemoveNewList);
        }
    }
    else {
        oldInterfaceList = DeviceExtension->InterfaceList;
    }

    DeviceExtension->InterfaceList = AllocStruct(NonPagedPool,
                                                 PUSBD_INTERFACE_INFORMATION,
                                                 NumberOfInterfaces);

    if (DeviceExtension->InterfaceList != NULL) {
        RtlZeroMemory(DeviceExtension->InterfaceList,
                      NumberOfInterfaces * sizeof(PUSBD_INTERFACE_INFORMATION));

        if (oldInterfaceList) {
            UsbVerify_ASSERT(DeviceExtension->InterfaceListSize > 0,
                             DeviceExtension->Self, NULL, NULL);

            RtlCopyMemory(DeviceExtension->InterfaceList,
                          oldInterfaceList,
                          DeviceExtension->InterfaceListSize);
            //
            // Keep DeviceExtension->InterfaceListCount the same
            //
        }
        else {
            DeviceExtension->InterfaceListCount = 0;
        }

        DeviceExtension->InterfaceListSize = NumberOfInterfaces;
    }
    else {
        DeviceExtension->InterfaceListSize = -1;
        DeviceExtension->InterfaceListCount = -1;
    }

    if (oldInterfaceList) {
        //
        // No need to free the interfaces contained in this list b/c we copied
        // them over to the new list
        //
        ExFreePool(oldInterfaceList);
    }
}

VOID
UsbVerify_InterfaceListAddInterface(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PUSBD_INTERFACE_INFORMATION NewInterface
    )
{
    PUSBD_INTERFACE_INFORMATION *listEntry = NULL, interface;
    LONG intIndex;

    UsbVerify_Print(DeviceExtension, PRINT_PIPE_NOISE,
                    ("New Interface, # of pipes %d\n", NewInterface->NumberOfPipes));

    UsbVerify_AssertInterfaceListLocked(DeviceExtension);

    UsbVerify_ASSERT(DeviceExtension->InterfaceListCount <=
                     DeviceExtension->InterfaceListSize,
                     DeviceExtension->Self, NULL, NULL);

    if (DeviceExtension->InterfaceList) {
        //
        // First, see if this interface already exists in our list (keyed by
        // Interface Number).  We iterate over the entire list (InterfaceListSize)
        // because there may be holes in the array beyond InterfaceListCount
        //
        for (intIndex = 0;
             intIndex < DeviceExtension->InterfaceListSize && listEntry == NULL;
             intIndex++) {

            if (DeviceExtension->InterfaceList[intIndex] != NULL &&
                DeviceExtension->InterfaceList[intIndex]->InterfaceNumber ==
                NewInterface->InterfaceNumber) {
                listEntry = DeviceExtension->InterfaceList + intIndex;
            }
        }

        if (listEntry) {
            //
            // We are replacing a known interface, free the old one and log the
            // removal of the pipes and interface
            //
            UsbVerify_Print(DeviceExtension, PRINT_LIST_INFO,
                            ("removing interface from prev list\n"));

            interface = *listEntry; 
            UsbVerify_LogInterfaceRemoval(DeviceExtension, interface);
            *listEntry = NULL;

            DeviceExtension->InterfaceListCount--;
            ExFreePool(interface);
        }
        else {
            //
            // Go over the list again, finding the first open slot
            //
            for (intIndex = 0;
                 intIndex < DeviceExtension->InterfaceListSize && listEntry == NULL;
                 intIndex++) {
    
                if (DeviceExtension->InterfaceList[intIndex] == NULL) {
                    listEntry = DeviceExtension->InterfaceList + intIndex;
                }
            }

            //
            // No emptry entry was found, grow the list
            //
            if (listEntry == NULL) {
                ULONG oldSize = DeviceExtension->InterfaceListSize;

                //
                // Grow the list, but keep all the interfaces in it
                //
                UsbVerify_InitializeInterfaceList(DeviceExtension,
                                                  oldSize+1,
                                                  FALSE);
                
                if (DeviceExtension->InterfaceList) {
                    listEntry = DeviceExtension->InterfaceList + oldSize;
                }
            }
        }
    }
    else {
        //
        // No interface list, create one
        //
        UsbVerify_InitializeInterfaceList(DeviceExtension, 1, FALSE);

        if (DeviceExtension->InterfaceList) {
            listEntry = DeviceExtension->InterfaceList;
        }

    }

    //
    // Finally!  We have a slot to store our information
    //
    if (listEntry) {
        UsbVerify_ASSERT(*listEntry == NULL, DeviceExtension->Self, NULL, NULL);

        interface = ExAllocatePool(NonPagedPool, NewInterface->Length);
        if (interface) {
            RtlCopyMemory(interface, NewInterface, NewInterface->Length);
            *listEntry = interface;

            DeviceExtension->InterfaceListCount++;

            UsbVerify_LogInterface(DeviceExtension,
                                   TRUE,
                                   interface->InterfaceNumber, 
                                   interface->AlternateSetting);
        }
    }
    else {
        UsbVerify_Print(DeviceExtension, PRINT_LIST_ERROR, ("listEntry blank!\n"));
        DbgBreakPoint();
    }

}

PUSBD_PIPE_INFORMATION
UsbVerify_ValidatePipe(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    USBD_PIPE_HANDLE PipeHandle
    )
{
    KIRQL irql;
    LONG intIndex;
    ULONG pipeIndex;
    PUSBD_INTERFACE_INFORMATION interface;
    PUSBD_PIPE_INFORMATION pPipeInfo = NULL;

    UsbVerify_AssertInterfaceListLocked(DeviceExtension);

    if (DeviceExtension->InterfaceList) {

        //
        // Linearly search through the list until we find the pipe we want
        //
        for (intIndex = 0;
             intIndex < DeviceExtension->InterfaceListSize && pPipeInfo == NULL;
             intIndex++) {

            interface = DeviceExtension->InterfaceList[intIndex];

            for (pipeIndex = 0;
                 pipeIndex < interface->NumberOfPipes && pPipeInfo == NULL;
                 pipeIndex++) {

                if (interface->Pipes[pipeIndex].PipeHandle == PipeHandle) {
                    pPipeInfo = interface->Pipes + pipeIndex;
                }
            }

        }
    }

    return pPipeInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\exe\viewer\viewer.c ===
#include <stdio.h>
#include <wtypes.h>
#include <winioctl.h>
#include <usbioctl.h>
#include <cfgmgr32.h>
#include "usbtest.h"

const GUID __declspec(selectany) GUID_CLASS_USBHUB = {
             0xf18a0e88, 0xc30c, 0x11d0, { 0x88, 0x15, 0x00,
             0xa0, 0xc9, 0x06, 0xbe, 0xd8 } };

#define MAX_DEVICE_TREES            16
#define MAX_DEVICE_TREE_NAME_LENGTH 31

#define SLEEP_TIME  10000   

#define isUSBDevice(node)                                                   \
    ( (Hub == (node) -> NodeType && NULL != (node) -> ConnectionInformation) ||   \
       (MIParent == (node) -> NodeType) || (Device == (node) -> NodeType))

typedef struct _USB_DEVICE_LIST
{
    ULONG               DeviceCount;
    ULONG               NextDevice;
    PUSB_DEVICE_NODE    Devices[0];
} USB_DEVICE_LIST, *PUSB_DEVICE_LIST;

typedef struct _CYCLE_TEST_CONTEXT
{
    PUSB_DEVICE_TREE    LastKnownTree;
} CYCLE_TEST_CONTEXT, *PCYCLE_TEST_CONTEXT;

ULONG               DeviceTreeCount;
PUSB_DEVICE_TREE    DeviceTrees[MAX_DEVICE_TREES];
CHAR                DeviceTreeNames[MAX_DEVICE_TREES][MAX_DEVICE_TREE_NAME_LENGTH];

ULONG   SleepTime;

VOID
DisplayMainMenu(
    VOID
)
{
    printf("\n"
           "USB Device Tree Viewer\n"
           "----------------------\n"
           " 1) Build Device Tree\n"
           " 2) Destroy Device Tree\n"
           " 3) Write Device Tree To Disk\n"
           " 4) Read Device Tree From Disk\n"
           " 5) Dump Device Tree To Screen\n"
           " 6) Dump Device Tree To Text File\n"
           " 7) List Device Trees\n"
           " 8) Compare 2 Device Trees\n"
           " 9) Cycle 1 Port\n"
           "10) Run Cycle Test\n"
           "11) Start USBTest\n"
           "12) Stop  USBTest\n"
           "13) Display attached hubs\n"
           " 0) Quit\n");

    return;
}

ULONG
GetMenuChoice(
    ULONG   ChoiceMin,
    ULONG   ChoiceMax
)
{
    ULONG   choice;

    printf("\n");

    do 
    {
        printf("Enter choice: ");

        scanf("%d", &choice);

        fflush(stdin);
    } 
    while (choice < ChoiceMin || choice > ChoiceMax);

    return (choice);
}

ULONG
GetDeviceTreeIndex(
    PCHAR   TreeName
)
{
    ULONG index;

    for (index = 0; index < DeviceTreeCount; index++)
    {
        if (0 == strcmp(TreeName, DeviceTreeNames[index]))
        {
            break;
        }
    }

    return (index);
}

VOID
GetDeviceTreeName(
    PCHAR   TreeName
)
{
    ULONG   index;

    printf("Enter name for device tree: ");
    
    scanf("%s", TreeName);

    return;
}

VOID
DisplayDeviceTreeNames(
    VOID
)
{
    ULONG   index;

    printf("\n"
           "Current Device Trees\n"
           "--------------------\n");

    for (index = 0; index < DeviceTreeCount; index++)
    {
        printf("%d) %s\n", index+1, DeviceTreeNames[index]);
    }

    return;
}

ULONG
SelectDeviceTree(
    VOID
)
{
    ULONG   choice;

    DisplayDeviceTreeNames();

    choice = GetMenuChoice(0, DeviceTreeCount);

    return (choice-1);
}

VOID
GetFileName(
    PCHAR   FileName
)
{
    printf("Enter filename: ");

    scanf("%s", FileName);

    return;
}

VOID
AddDeviceTree(
    PUSB_DEVICE_TREE    DeviceTree
)
{
    PCHAR   deviceTreeName;
    ULONG   index;

    deviceTreeName = DeviceTreeNames[DeviceTreeCount];

    GetDeviceTreeName(deviceTreeName);

    index = GetDeviceTreeIndex(deviceTreeName);

    if (index < DeviceTreeCount)
    {
        printf("A tree with that name already exists\n");
    
        DestroyUSBDeviceTree(DeviceTree);

        return;
    }

    DeviceTrees[DeviceTreeCount++] = DeviceTree;
}

VOID
DumpDeviceTree(
    HANDLE  OutHandle
)
{
    ULONG   index;
    BOOLEAN success;

    index = SelectDeviceTree();

    if (index > DeviceTreeCount)
    {
        return;
    }

    success = WriteUSBDeviceTreeToTextFile(OutHandle, DeviceTrees[index]);

    if (!success)
    {
        printf("Error occurred dumping device tree\n");
    }
}

VOID
BuildDeviceTree(
    VOID
)
{
    PUSB_DEVICE_TREE    deviceTree;
    PCHAR               deviceTreeName;
    ULONG               index;

    deviceTree = BuildUSBDeviceTree();

    if (NULL == deviceTree)
    {
        printf("Error %d occurred building device tree\n", GetLastError());

        return;
    }

    AddDeviceTree(deviceTree);

    return;
}

VOID
DestroyDeviceTree(
    VOID
)
{
    ULONG   index;

    index = SelectDeviceTree();

    if (index > DeviceTreeCount) 
    {
        return;
    }

    DestroyUSBDeviceTree(DeviceTrees[index]);

    DeviceTreeCount--;

    memmove(&(DeviceTrees[index]), 
            &(DeviceTrees[index+1]),
            (DeviceTreeCount - index) * sizeof(PUSB_DEVICE_TREE));

    memmove(&(DeviceTreeNames[index]),
            &(DeviceTreeNames[index+1]),
            (DeviceTreeCount - index) * MAX_DEVICE_TREE_NAME_LENGTH);

    return;
}

VOID
WriteDeviceTreeToDataFile(
    VOID
)
{
    HANDLE  outfile;
    CHAR    fileName[256];
    ULONG   index;
    BOOLEAN success;

    index = SelectDeviceTree();

    if (index > DeviceTreeCount)
    {
        return;
    }

    GetFileName(fileName);

    outfile = CreateFile(fileName,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_ALWAYS,
                         0,
                         NULL);

    if (INVALID_HANDLE_VALUE == outfile)
    {
        printf("Error occurred opening file for output!\n");
        return;
    }

    success = WriteUSBDeviceTreeToFile(outfile, DeviceTrees[index]);

    CloseHandle(outfile);

    if (!success) 
    {
        printf("Error occurred writing the tree to the data file\n");
    }
    else
    {
        printf("Tree successfully written to data file\n");
    }

    return;
}

VOID
ReadDeviceTreeFromDataFile(
    VOID
)
{
    PUSB_DEVICE_TREE    deviceTree;
    HANDLE              infile;
    CHAR                fileName[256];
    BOOLEAN             success;

    GetFileName(fileName);

    infile = CreateFile(fileName,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL);

    if (INVALID_HANDLE_VALUE == infile)
    {
        printf("Error occurred opening file for input!\n");
        return;
    }

    success = ReadUSBDeviceTreeFromFile(infile, &deviceTree);

    CloseHandle(infile);

    if (!success) 
    {
        printf("Error occurred reading the tree from the data file\n");
    }
    else
    {
        printf("Tree successfully read from data file\n");
    }

    AddDeviceTree(deviceTree);

    return;
}

VOID
DumpDeviceTreeToScreen(
    VOID
)
{
    DumpDeviceTree(GetStdHandle(STD_OUTPUT_HANDLE));

    return;
}

VOID
DumpDeviceTreeToTextFile(
    VOID
)
{
    CHAR    fileName[256];
    HANDLE  outfile;

    GetFileName(fileName);

    outfile = CreateFile(fileName,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_ALWAYS,
                         0,
                         NULL);

    if (INVALID_HANDLE_VALUE == outfile)
    {
        printf("Error occurred trying to open file for output\n");
        return;
    }

    DumpDeviceTree(outfile);

    CloseHandle(outfile);

    return;
}

VOID
ListDeviceTrees(
    VOID
)
{
    DisplayDeviceTreeNames();

    return;
}

VOID
DisplayDifferentNode(
    PUSB_DEVICE_NODE    Node
)
{
    PUSB_DEVICE_NODE    Parent;
    ULONG               ParentIndex;

    Parent = Node -> Parent;

    if (NULL != Parent)
    {
        ParentIndex = 0;
        while (Parent -> Children[ParentIndex] != Node)
        {
            ParentIndex++;
        }
    }

    switch(Node -> NodeType)
    {
        case Computer:
            printf("Computer: NumberOfHCs = %d",
                   Node -> NumberOfChildren);
            break;

        case HostController:
            printf("Host Controller: %s",
                   Node -> Description);

        case Hub:
            if (NULL == Node -> NodeInformation)
            {
                printf("Host Controller %s --> RootHub: %d ports",
                       Parent -> Description,
                       Node -> NumberOfChildren);
            }
            else 
            {
                printf("Hub: %s --> %d ports",
                       Node -> Description,
                       Node -> NumberOfChildren);
            }
            break;

        case MIParent:
            printf("%s port %d --> %s: %d interfaces",
                   Parent -> Description,
                   ParentIndex+1,
                   Node -> Description,
                   Node -> NumberOfChildren);
            break;

        case MIInterface:
            printf("%s interface --> %s",
                   Parent -> Description,
                   Node -> Description);
            break;

        case Device:
            printf("%s port %d --> %s",
                   Parent -> Description,
                   ParentIndex+1,
                   Node -> Description);
            break;

        case EmptyPort:
            printf("%s port %d --> EmptyPort",
                   Parent -> Description,
                   ParentIndex+1);
            break;
    }

    if (0 != Node -> DeviceProblem)
    {
        printf(" (!:%d)", Node -> DeviceProblem);
    }

    printf("\n");

    return;
}

VOID
CompareDeviceTrees(
    VOID
)
{
    ULONG           index;
    ULONG           index1;
    ULONG           index2;
    ULONG           numDifferences;
    BOOLEAN         success;
    NODE_PAIR_LIST  differenceList;

    index1 = SelectDeviceTree();
    index2 = SelectDeviceTree();

    if (index1 > DeviceTreeCount || index2 > DeviceTreeCount)
    {
        return;
    }

    InitializeNodePairList(&differenceList);

    success = CompareUSBDeviceTrees(DeviceTrees[index1],
                                    DeviceTrees[index2],
                                    &numDifferences,
                                    &differenceList);

    if (0 != numDifferences)
    {
        printf("Node Differences (%d)\n"
               "--------------------\n",
               numDifferences);

        for (index = 0; index < differenceList.CurrentNodePairs; index++)
        {
            printf("\n"
                   "Node Pair %d\n"
                   "-----------\n",
                   index+1);

            DisplayDifferentNode(differenceList.NodePairs[index*2]);
            DisplayDifferentNode(differenceList.NodePairs[index*2+1]);
        }
    }
    else
    {
        printf("There are no differences in the device trees\n");
    }

    DestroyNodePairList(&differenceList);

    return;
}

BOOLEAN
CountUSBDevices(
    PUSB_DEVICE_NODE    DeviceNode,
    PULONG              DeviceCount
)
{
    ULONG   deviceCount;
    ULONG   index;

    deviceCount = 0;

    if (isUSBDevice(DeviceNode)) 
    {
       (*DeviceCount)++;
    }

    return (TRUE);
}

BOOLEAN
AddUSBDevices(
    PUSB_DEVICE_NODE    DeviceNode,
    PUSB_DEVICE_LIST    DeviceList
)
{
    if (isUSBDevice(DeviceNode))
    {
        DeviceList -> Devices[DeviceList -> NextDevice++] = DeviceNode;
    }

    return (TRUE);
}

BOOL
CreateDeviceList(
    PUSB_DEVICE_TREE    DeviceTree,
    PUSB_DEVICE_LIST    *DeviceList
)
{
    ULONG   deviceCount;
    ULONG   nextDevice;

    //
    // Count the number of devices in the tree
    //

    deviceCount = 0;

    WalkUSBDeviceTree(DeviceTree, CountUSBDevices, NULL, &deviceCount);

    printf("Device count = %d\n", deviceCount);

    *DeviceList = ALLOC(sizeof(USB_DEVICE_LIST) + 
                        deviceCount * sizeof(PUSB_DEVICE_NODE));

    if (NULL != *DeviceList)
    {
        (*DeviceList) -> DeviceCount = deviceCount;

        nextDevice = 0;


        WalkUSBDeviceTree(DeviceTree, AddUSBDevices, NULL, *DeviceList);
    }

    return (NULL != *DeviceList);
}

VOID
DisplayDeviceList(
    PUSB_DEVICE_LIST    DeviceList
)
{
    ULONG   index;

    printf("\n"
           "Current Device List\n"
           "-------------------\n");

    for (index = 0; index < DeviceList -> DeviceCount; index++)
    {
        printf("%d) %s\n", 
               index+1,
               DeviceList -> Devices[index] -> Description);

    }

    return;
}

VOID
CyclePort(
    VOID
)
{
    PUSB_DEVICE_TREE    currentTree;
    PUSB_DEVICE_NODE    node;
    PUSB_DEVICE_LIST    deviceList;
    ULONG               nBytes;
    BOOLEAN             success;
    ULONG               choice;

    deviceList = NULL;

    currentTree = BuildUSBDeviceTree();

    if (NULL == currentTree)
    {
        printf("Unable to build current device tree\n");

        return;
    }

    success = CreateDeviceList(currentTree, &deviceList);

    if (!success)
    {
        printf("Error occurred creating the current device list\n");

        goto CyclePort_Exit;
    }

    if (0 == deviceList -> DeviceCount) 
    {
        printf("There are no devices currently in the tree\n");

        goto CyclePort_Exit;
    }
    
    DisplayDeviceList(deviceList);
    
    choice = GetMenuChoice(0, deviceList -> DeviceCount);

    if (0 == choice)
    {
        printf("No device selected\n");

        goto CyclePort_Exit;
    }

    node = deviceList -> Devices[choice-1];

    success = CycleUSBPort(node);

    if (!success)
    {
        printf("Error %d occurred trying to cycle the port!\n",
               GetLastError());
    }
    else
    {
        printf("Port cycle completed with success\n");
    }

CyclePort_Exit:

    if (NULL != deviceList)
    {
        FREE(deviceList);
    }

    DestroyUSBDeviceTree(currentTree);

    return;
}

BOOLEAN
CycleTestCallbackPre(
    IN  PUSB_DEVICE_NODE    Node,
    IN  PCYCLE_TEST_CONTEXT Context
)
{
    return (TRUE);
}

BOOLEAN
CycleTestCallbackPost(
    IN  PUSB_DEVICE_NODE    Node,
    IN  PCYCLE_TEST_CONTEXT Context
)
{
    BOOLEAN             success;
    ULONG               nBytes;
    PUSB_DEVICE_TREE    currentTree;
    ULONG               numDifferences;
    NODE_PAIR_LIST      differenceList;

    success = TRUE;

    if (isUSBDevice(Node))
    {
        printf("Attempting to cycle %s\n", Node -> Description);
    
        success = CycleUSBPort(Node);
    
        if (!success)
        {
            printf("Error %d occurred trying to cycle the port!\n",
                   GetLastError());
        }
        else
        {
            printf("Cycle completed with success\n");

            printf("Sleeping for %d ms\n", SleepTime);

            Sleep(SleepTime);

            printf("Done with sleeping time...Building the device tree\n");

            currentTree = BuildUSBDeviceTree();
    
            if (NULL == currentTree)
            {
                printf("Error %d occurred trying to build current tree\n"
                       "Comparison after cycle port not done\n",
                       GetLastError());

                success = FALSE;
            }
            else
            {
                printf("Comparing the current tree with the last tree\n");
    
                InitializeNodePairList(&differenceList);
    
                success = CompareUSBDeviceTrees(Context -> LastKnownTree,
                                                currentTree,
                                                &numDifferences,
                                                &differenceList);
    
                if (0 != numDifferences)
                {
                    printf("There are %d difference between device trees"
                           "after port cycle\n",
                           numDifferences);
    
                    Context -> LastKnownTree = currentTree;
                }
                else 
                {
                    printf("Device trees are the same after port cycle\n");
                }

                DestroyUSBDeviceTree(currentTree);
    
                DestroyNodePairList(&differenceList);
            }
        }    
    }

    return (success);
}


VOID
DoCycleTest(
    VOID
)
{
    CYCLE_TEST_CONTEXT  context;

    printf("Enter the number of seconds to sleep to reenumerate: ");
    
    SleepTime = GetMenuChoice(1, 120);
                                 
    SleepTime *= 1000;

    printf("Starting the cycle test\n");

    context.LastKnownTree = BuildUSBDeviceTree();

    if (NULL == context.LastKnownTree) 
    {
        printf("Error %d occurred building the current device tree\n", 
                GetLastError());

        goto DoCycleTest_Exit;
    }

    WalkUSBDeviceTree(context.LastKnownTree, 
                      CycleTestCallbackPre,
                      CycleTestCallbackPost,
                      &context);

    DestroyUSBDeviceTree(context.LastKnownTree);

DoCycleTest_Exit:

    printf("Stopping cycle test\n");

    return;
}

VOID
DisplayUSBHubs(
    VOID
)
{
    PCHAR   hubLinks;
    PCHAR   hubLinkWalk;
    BOOLEAN wasError;
    HANDLE  hubHandle;

    ULONG   index;

    printf("\n"
           "Current Hub List\n"
           "-------------------\n");


    wasError = !FindDevicesByClass((LPGUID) &GUID_CLASS_USBHUB, &hubLinks);

    if (wasError)
    {
        printf("Error getting the list of USB hubs\n");

        return;
    }

    hubLinkWalk = hubLinks;

    while (*hubLinkWalk != '\0') 
    {
        *(hubLinkWalk+2) = '.';

        printf("Hub: %s -- ", hubLinkWalk);
 
        //
        // Try to open a handle to the device
        //

        hubHandle = CreateFile(hubLinkWalk,
                               GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL);

        printf("Handle value %08x\n", hubHandle);

        hubLinkWalk += (strlen(hubLinkWalk)+1);

        if (INVALID_HANDLE_VALUE != hubHandle)
            CloseHandle(hubHandle);
        else 
            printf("GetLastError(): %d\n", GetLastError());

    }

    GlobalFree(hubLinks);

    return;
}



int __cdecl
main(
    int argc,
    char *argv[]
)
{
    PUSB_DEVICE_TREE    deviceTree;
    PUSB_DEVICE_TREE    deviceTree2;
    ULONG               index;
    BOOL                success;
    HANDLE              outfile;
    ULONG               menuChoice;

    outfile     = INVALID_HANDLE_VALUE;
    deviceTree2 = NULL;

    do
    {
        DisplayMainMenu();

        menuChoice = GetMenuChoice(0, 13);

        switch (menuChoice)
        {
            case 1:
                if (MAX_DEVICE_TREES == DeviceTreeCount)
                {
                    printf("Maximum number (%d) of device trees reached\n",
                            MAX_DEVICE_TREES);
                }
                else 
                {
                    BuildDeviceTree();
                }
                break;

            case 2:
                if (0 == DeviceTreeCount)
                {
                    printf("There are no devices trees to destroy!\n");
                }
                else
                {
                    DestroyDeviceTree();
                }
                break;

            case 3:
                if (0 == DeviceTreeCount)
                {
                    printf("There are no devices trees to write!\n");
                }
                else
                {
                    WriteDeviceTreeToDataFile();
                }
                break;

            case 4:
                if (MAX_DEVICE_TREES == DeviceTreeCount)
                {
                    printf("Maximum number (%d) of device trees reached\n",
                           MAX_DEVICE_TREES);
                }
                else 
                {
                    ReadDeviceTreeFromDataFile();
                }
                break;

            case 5:
                if (0 == DeviceTreeCount)
                {
                    printf("There are no devices trees to dump!\n");
                }
                else
                {
                    DumpDeviceTreeToScreen();
                }
                break;

            case 6:
                if (0 == DeviceTreeCount)

                {
                    printf("There are no devices trees to dump!\n");
                }
                else
                {
                    DumpDeviceTreeToTextFile();
                }
                break;

            case 7:
                if (0 == DeviceTreeCount)

                {
                    printf("There are no devices trees to list!\n");
                }
                else
                {
                    ListDeviceTrees();
                }
                break;

            case 8:
                if (DeviceTreeCount < 2)
                {
                    printf("Need at least two device trees to compare!\n");
                }
                else
                {
                    CompareDeviceTrees();
                }
                break;
                
            case 9:
                CyclePort();
                break;

            case 10:
                DoCycleTest();
                break;

            case 11:
                if (!StartUSBTest())
                {
                    printf("USB could not be started...");
                    break;
                }
                break;

            case 12:
                StopUSBTest();
                break;

            case 13:
                DisplayUSBHubs();
                break;

            case 0:
                break;

            default:
                printf("Choice not yet implemented\n");
        }
    }
    while (menuChoice != 0);

    for (index = 0; index < DeviceTreeCount; index++)
    {
        DestroyUSBDeviceTree(DeviceTrees[index]);
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbtest\sys\usbtest\usbtest.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usbtest.c

Abstract: USB Test Driver

Author:

    Chris Robinson

Environment:

    Kernel mode

Revision History:


--*/
#include <wdm.h>

#define INITGUID
#include "usbtsys.h"
#include "local.h"

#define USBTEST_NTNAME   L"\\Device\\USBTest_Driver"
#define USBTEST_SYMNAME  L"\\DosDevices\\USBTest"

#define USBTEST_VERSION  "1.0e"

//
// Global Debug Variables
//

ULONG USBTest_Debug_Level = 2;

//
// Global variables
//

PDEVICE_OBJECT  USBTest_DeviceObject;
UNICODE_STRING  USBTest_SymLink;

//
// Function Declarations 
//

NTSTATUS   
DriverEntry (
    IN PDRIVER_OBJECT, 
    IN PUNICODE_STRING
);


#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, USBTest_Create)
#pragma alloc_text (PAGE, USBTest_Close)
#pragma alloc_text (PAGE, USBTest_Unload)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    PDEVICE_OBJECT      deviceObject;
    PDRIVER_DISPATCH    *dispatch;
    UNICODE_STRING      ntName;
    UNICODE_STRING      symName;
    NTSTATUS            status;
    ULONG               i;


    UNREFERENCED_PARAMETER (DriverObject);
    UNREFERENCED_PARAMETER (RegistryPath);

    USBTEST_ENTER_FUNCTION("USBTest DriverEntry");
    USBTest_KdPrint(1, ("USB Test Driver Version %s\n", USBTEST_VERSION));

    //
    // Create the dispatch points -- We are a statically loading driver
    //  and not a filter.  Therefore we just handle those IRPs that 
    //  are specifically sent to us (IRP_MJ_CREATE/CLOSE and 
    //  IRP_MJ_DEVICE_CONTROL).  
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = USBTest_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = USBTest_Close;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = USBTest_Ioctl;
//    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = USBTest_Ioctl;

    DriverObject->DriverUnload                         = USBTest_Unload;

    //
    // Create a global device object which a user mode app can get
    //  a handle to so that specific tests can be performed.
    //

    //
    // Create the name for this device
    //

    RtlInitUnicodeString(&ntName, USBTEST_NTNAME);
    
    status = IoCreateDevice(DriverObject,
                            0,
                            &ntName,
                            FILE_DEVICE_UNKNOWN,
                            0,
                            FALSE,
                            &USBTest_DeviceObject);

    if (!NT_SUCCESS(status))
    {
        goto USBTest_DriverEntry_Exit;
    }

    //
    // Create the user mode symbolic link for this device
    //

    RtlInitUnicodeString(&USBTest_SymLink, USBTEST_SYMNAME);

    status = IoCreateSymbolicLink(&USBTest_SymLink, &ntName);

    if (!NT_SUCCESS(status))
    {
        IoDeleteDevice(USBTest_DeviceObject);
        goto USBTest_DriverEntry_Exit;
    }

    //
    // Do some initialization of the device extension
    //

USBTest_DriverEntry_Exit:

    USBTEST_EXIT_FUNCTION("USBTest DriverEntry");
    USBTEST_EXIT_STATUS(status);

    return (STATUS_SUCCESS);
}

NTSTATUS
USBTest_Create(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
)
/*++

Routine Description:

   Process the Create IRP sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE ();

    USBTEST_ENTER_FUNCTION("USBTest_Create");

    //
    // To handle a Create request, this routine does the bare 
    //  minimum which does the following:
    //  1) Sets the Irp status to STATUS_SUCCESS
    //  2) Sets the Irp information field to 0
    //  3) Completes the request
    //  4) Returns STATUS_SUCCESS
    //

    status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    USBTEST_EXIT_FUNCTION("USBTest_Create");
    USBTEST_EXIT_STATUS(status);

    return (status);
}

NTSTATUS
USBTest_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
)
/*++

Routine Description:

   Process the Close IRP sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE ();

    USBTEST_ENTER_FUNCTION("USBTest_Close");

    //
    // To handle a Close request, this routine does the bare 
    //  minimum which does the following:
    //  1) Sets the Irp status to STATUS_SUCCESS
    //  2) Sets the Irp information field to 0
    //  3) Completes the request
    //  4) Returns STATUS_SUCCESS
    //

    status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    USBTEST_EXIT_FUNCTION("USBTest_Close");
    USBTEST_EXIT_STATUS(status);

    return (status);
}

VOID
USBTest_Unload(
    IN PDRIVER_OBJECT DriverObject
)
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE ();

    UNREFERENCED_PARAMETER(DriverObject);

    USBTEST_ENTER_FUNCTION("USBTest_Unload");

    IoDeleteSymbolicLink(&USBTest_SymLink);

    IoDeleteDevice(USBTest_DeviceObject);

    USBTEST_EXIT_FUNCTION("USBTest_Unload");

    return;
}

#if 0
NTSTATUS
Usbhlfil_SendIrpDownStack(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
{
    PFILTER_DATA    filterData;
    NTSTATUS        status;

    ULF_ENTER_FUNCTION("Usbhlfil_SendIrpDownStack");

    //
    // Get the extension of the filter device object
    //

    filterData = (PFILTER_DATA) DeviceObject -> DeviceExtension;

    //
    // We are passing the IRP on down the stack...The caller of this function
    //  has already set up the IRP stack.  Unless this device is being removed,
    //  we will send it to the next device in the stack, otherwise, we
    //  complete it here.
    //

#ifndef USE_RL

    if (STATUS_REMOVED == filterData->Status)
    {
        status = STATUS_DELETE_PENDING;

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status      = status;

        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }
    else
    {
        //
        // Increment the number of outstanding requests to this device
        //

#ifndef USE_RL
        InterlockedIncrement (&filterData->OutstandingIO);
#endif
#endif

        ULF_KdPrint(2, ("Sending IRP %p down stack\n", Irp));

        status = IoCallDriver (filterData->TopOfStack, Irp);

        ULF_KdPrint(2, ("Returned with IRP %p and status %08x\n", 
                        Irp, status));

#ifndef USE_RL
    }
#endif
    //
    // Decrement the number of outstanding requests.  If this value
    //  goes to zero, then we set the PauseEvent which puts the device
    //  object into a paused state.
    //

#ifndef USE_RL
    if (0 == InterlockedDecrement (&filterData->OutstandingIO))
    {
        KeSetEvent (&filterData->PauseEvent, 0, FALSE);
    }
#endif

    ULF_KdPrint(2, ("Exiting Usbhlfil_SendIrpDownStack for IRP %p\n", Irp));

    ULF_EXIT_FUNCTION("Usbhlfil_SendIrpDownStack");
    ULF_EXIT_STATUS(status);

    return (status);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\ioctl.c ===
/*--         
Copyright (c) 1998, 1999  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/

#include "usbverfy.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, UsbVerify_IoCtl)
#endif

NTSTATUS
UsbVerify_IoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.
    
Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION              irpStack;
    PUSB_VERIFY_DEVICE_EXTENSION    devExt;
    KEVENT                          event;
    NTSTATUS                        status = STATUS_SUCCESS;

    devExt = GetExtension(DeviceObject);
    Irp->IoStatus.Information = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
    default:
        break;
    }

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
    }

    return UsbVerify_DispatchPassThrough(DeviceObject, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\sources.inc ===
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=$(BASEDIR)\private\ntos\inc;      \
         ..\..\inc

SOURCES=..\usbverfy.c \
        ..\pnp.c      \
        ..\power.c    \
        ..\ioctl.c    \
        ..\ioctli.c   \
        ..\log.c      \
        ..\intrface.c \
        ..\urb.c      \
        ..\usbverfy.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\str.h ===
#ifndef  __STR_H
#define  __STR_H

enum {
    IDS_INVALID_PIPE = 0,
    IDS_URB_LINK_NOT_IMPLEMENTED,
    IDS_STALE_URB
};

#define USB_VERIFY_FLAGS_SZ              L"_UsbVerifyFlags"
#define USB_LOG_FLAGS_SZ                 L"_UsbVerifyLogFlags"
#define USB_VERIFY_LOGSIZE_SZ            L"_UsbVerifyLogSize"
#define USB_PRINT_FLAGS_SZ               L"_UsbPrintFlags"
#define USB_WARNINGS_AS_ERRORS_SZ        L"_WarningsAsErrors"

#endif // __STR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\power.c ===
/*--         
Copyright (c) 1998, 1999  Microsoft Corporation

Module Name:

    power.c

Abstract:

Environment:

    Kernel mode only.

 Notes:


--*/

#include "usbverfy.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, UsbVerify_Power)
#endif

NTSTATUS
UsbVerify_Power(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power irps   Does nothing except
    record the state of the device.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION             irpStack;
    PUSB_VERIFY_DEVICE_EXTENSION   devExt;
    POWER_STATE                    powerState;
    POWER_STATE_TYPE               powerType;

    PAGED_CODE();

    devExt = GetExtension(DeviceObject);
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;
    powerState = irpStack->Parameters.Power.State;

    switch (irpStack->MinorFunction) {
    case IRP_MN_SET_POWER:
        if (powerType  == DevicePowerState) {
            devExt->PowerState = powerState.DeviceState;
        }

    case IRP_MN_QUERY_POWER:
    case IRP_MN_WAIT_WAKE:
    case IRP_MN_POWER_SEQUENCE:
    default:
        break;
    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(devExt->TopOfStack, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\pnp.c ===
/*--         
Copyright (c) 1998, 1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/

#include "usbverfy.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, UsbVerify_AddDevice)
#pragma alloc_text (PAGE, UsbVerify_InitializeFromRegistry)
#pragma alloc_text (PAGE, UsbVerify_OpenServiceParameters)
#pragma alloc_text (PAGE, UsbVerify_PnP)
#pragma alloc_text (PAGE, UsbVerify_QueryKey)
#pragma alloc_text (PAGE, UsbVerify_StartDevice)
#endif

// {F16328AF-4480-4b18-B028-51301BEB166D}
const GUID GUID_USB_VERIFY  = 
{ 0xf16328afL, 0x4480, 0x4b18, { 0xb0, 0x28, 0x51, 0x30, 0x1b, 0xeb, 0x16, 0x6d } };

NTSTATUS
UsbVerify_QueryKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    )
{
    PKEY_VALUE_FULL_INFORMATION fullInfo;
    NTSTATUS                    status;
    UNICODE_STRING              valueName;
    ULONG                       length;

    PAGED_CODE();

    RtlInitUnicodeString(&valueName, ValueNameString);

    length = sizeof (KEY_VALUE_FULL_INFORMATION)
           + valueName.MaximumLength + DataLength;

    fullInfo = ExAllocatePool (PagedPool, length);

    if (fullInfo) {
        status = ZwQueryValueKey(Handle,
                                 &valueName,
                                 KeyValueFullInformation,
                                 fullInfo,
                                 length,
                                 &length);

        if (NT_SUCCESS(status)) {
//            ASSERT(DataLength == fullInfo->DataLength);
            RtlCopyMemory(Data,
                          ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                          fullInfo->DataLength);
        }

        ExFreePool(fullInfo);
    }
    else {
        status = STATUS_NO_MEMORY;
    }

    return status;
}

HANDLE
UsbVerify_OpenServiceParameters(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension
    )
{
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING    parameters;
    HANDLE            hService, hParameters = NULL;
    NTSTATUS          status;

    PAGED_CODE();

    InitializeObjectAttributes(
        &oa,
        UsbVerify_GetRegistryPath(DeviceExtension->Self->DriverObject),
        OBJ_CASE_INSENSITIVE,
        NULL,
        (PSECURITY_DESCRIPTOR) NULL);

    //
    // Try to create/open the service key.  The key should always exist
    //  for Win2k but may or may not need to be created if this is Win9x.
    //  However, for simplicity's sake, ZwCreateKey() will be used on
    //  both OSs as it acts like open if the key is already created.
    //
    // Previous code was:
    //
    //  status = ZwOpenKey(&hService, KEY_ALL_ACCESS, &oa);
    //

    status = ZwCreateKey (&hService, 
                          KEY_ALL_ACCESS, 
                          &oa,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          NULL);

    if (NT_SUCCESS (status)) 
    {
        RtlInitUnicodeString(&parameters, L"Parameters");
        InitializeObjectAttributes (&oa,
                                    &parameters,
                                    OBJ_CASE_INSENSITIVE,
                                    hService,
                                    (PSECURITY_DESCRIPTOR) NULL);

        ZwOpenKey (&hParameters, KEY_ALL_ACCESS, &oa);
        ZwClose(hService);
    }
    else 
    {
        DbgPrint("ZwCreateKey failed with status 0x%08x\n", status);
    }

    return hParameters;
}

VOID
UsbVerify_InitializeFromRegistry(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    HANDLE Handle
    )
{
    PAGED_CODE();

    UsbVerify_QueryKey(Handle,
                       USB_VERIFY_FLAGS_SZ,
                       &DeviceExtension->VerifyFlags,
                       sizeof(DeviceExtension->VerifyFlags));

    UsbVerify_QueryKey(Handle,
                       USB_LOG_FLAGS_SZ,
                       &DeviceExtension->LogFlags,
                       sizeof(DeviceExtension->LogFlags));

    UsbVerify_QueryKey(Handle,
                       USB_VERIFY_LOGSIZE_SZ,
                       &DeviceExtension->LogSize,
                       sizeof(DeviceExtension->LogSize));

    UsbVerify_QueryKey(Handle,
                       USB_PRINT_FLAGS_SZ,
                       &DeviceExtension->PrintFlags,
                       sizeof(DeviceExtension->PrintFlags));

    UsbVerify_QueryKey(Handle,
                       USB_WARNINGS_AS_ERRORS_SZ,
                       &DeviceExtension->TreatWarningsAsErrors,
                       sizeof(DeviceExtension->TreatWarningsAsErrors));

}

NTSTATUS
UsbVerify_AddDevice(
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
{
    PUSB_VERIFY_DEVICE_EXTENSION    devExt;
    PDEVICE_OBJECT                  device;
    HANDLE                          hKey, hParameters;
    NTSTATUS                        status = STATUS_SUCCESS;

    PAGED_CODE();

    status = IoCreateDevice(Driver,                   
                            sizeof(USB_VERIFY_DEVICE_EXTENSION), 
                            NULL,                    
                            FILE_DEVICE_NULL,    
                            0,                   
                            FALSE,              
                            &device            
                            );

    if (!NT_SUCCESS(status)) {
        return (status);
    }

    RtlZeroMemory(device->DeviceExtension, sizeof(USB_VERIFY_DEVICE_EXTENSION));

    devExt = GetExtension(device);
    devExt->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);

    ASSERT(devExt->TopOfStack);

    devExt->Self = device;
    devExt->PDO = PDO;
    devExt->PowerState = PowerDeviceD0;

    devExt->VerifyState = Uninitialized;

    UsbVerify_InitializeInterfaceListLock(devExt);
    devExt->InterfaceList = NULL;
    devExt->InterfaceListCount = -1;
    devExt->InterfaceListSize = -1;

    UsbVerify_InitializeUrbListLock(devExt);
    UsbVerify_InitializeUrbList(devExt);

    UsbVerify_InitLog(devExt);

    //
    // Preinitialize in case the values are missing from the reg
    // 
    devExt->VerifyFlags = VERIFY_FLAGS_DEFAULT;
    devExt->LogFlags    = LOG_FLAGS_DEFAULT;
    devExt->LogSize     = LOG_SIZE_DEFAULT;
    devExt->PrintFlags  = PRINT_FLAGS_DEFAULT;

    devExt->TreatWarningsAsErrors = FALSE;

    //
    // Read values from the sevices\parameters key first. 
    // Then read from the devnode.
    //
    // The devnode values will override the global values
    //

    hParameters = UsbVerify_OpenServiceParameters(devExt);

    if (hParameters != NULL) {
        UsbVerify_InitializeFromRegistry(devExt, hParameters);
        ZwClose(hParameters);
    }

    status = IoOpenDeviceRegistryKey(devExt->PDO,
                                     PLUGPLAY_REGKEY_DEVICE, 
                                     STANDARD_RIGHTS_READ,
                                     &hKey);

    if (NT_SUCCESS(status)) {

        UsbVerify_InitializeFromRegistry(devExt, hKey);
        ZwClose(hKey);

    }

    device->Flags |= (DO_BUFFERED_IO | DO_POWER_PAGABLE);
    device->Flags &= ~DO_DEVICE_INITIALIZING;

#ifdef DO_INTERFACE
    status = IoRegisterDeviceInterface(PDO,
                                       (LPGUID)&GUID_USB_VERIFY,
                                       NULL,
                                       &devExt->SymbolicLinkName);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(device);
    }
#endif
    
    if (NT_SUCCESS(status))
    {
        NTSTATUS       temp;
        WCHAR          dd[512];
        ULONG          len;
        UNICODE_STRING uniDD;
        ANSI_STRING    ansiDD;

        temp = IoGetDeviceProperty(devExt -> PDO,
                                   DevicePropertyDeviceDescription,
                                   sizeof(dd),
                                   dd,
                                   &len);

        if (NT_SUCCESS(temp))
        {    
            RtlInitUnicodeString(&uniDD, dd);

            temp = RtlUnicodeStringToAnsiString(&ansiDD, &uniDD, TRUE);

            if (NT_SUCCESS(temp))
            {
                DbgPrint("Usbverifier loaded on %s\n", ansiDD.Buffer);
                RtlFreeAnsiString(&ansiDD);
            }
        }
    }

    return status;
}

NTSTATUS
UsbVerify_SendIrpSynchronously(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    KEVENT      event;
    NTSTATUS    status;

    IoCopyCurrentIrpStackLocationToNext(Irp);
    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE
                      );

    IoSetCompletionRoutine(Irp,
                           (PIO_COMPLETION_ROUTINE) UsbVerify_Complete, 
                           &event,
                           TRUE,
                           TRUE,
                           TRUE); // No need for Cancel

    status = IoCallDriver(DeviceObject, Irp);

    if (STATUS_PENDING == status) {
        KeWaitForSingleObject(
           &event,
           Executive, // Waiting for reason of a driver
           KernelMode, // Waiting in kernel mode
           FALSE, // No allert
           NULL); // No timeout

        status = Irp->IoStatus.Status;
    }

    return status;
}

#define UsbVerify_LogPnpEvent(devExt, irp)          \
if ((devExt)->LogFlags & LOG_PNP) {                 \
    USB_VERIFY_LOG_ENTRY logEntry;                  \
    RtlZeroMemory(&logEntry, sizeof(logEntry));     \
    logEntry.Type = LOG_PNP;                        \
    logEntry.u.PnpEvent.MinorFunction = IoGetCurrentIrpStackLocation((irp))->MinorFunction; \
    UsbVerify_Log(devExt, &logEntry);               \
}

NTSTATUS
UsbVerify_PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for plug and play irps 

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PUSB_VERIFY_DEVICE_EXTENSION devExt; 
    PIO_STACK_LOCATION          stack;
    NTSTATUS                    status = STATUS_SUCCESS;

    PAGED_CODE();

    devExt = GetExtension(DeviceObject);
    stack = IoGetCurrentIrpStackLocation(Irp);

    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE: 

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        
        status = UsbVerify_SendIrpSynchronously(devExt->TopOfStack, Irp);

        if (NT_SUCCESS(status))
        {

            //
            // As we are successfully now back from our start device
            // we can do work.
            //

            UsbVerify_LogPnpEvent(devExt, Irp);
            UsbVerify_StartDevice(devExt);
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completion routine with MORE_PROCESSING_REQUIRED.  
        //

        Irp->IoStatus.Status      = status;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_SURPRISE_REMOVAL:
        //
        // Same as a remove device, but don't call IoDetach or IoDeleteDevice
        //
        devExt->VerifyState = SurpriseRemoved;
        UsbVerify_LogPnpEvent(devExt, Irp);

        // Remove code here

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        
        devExt->VerifyState = Removed;
        UsbVerify_LogPnpEvent(devExt, Irp);

        UsbVerify_ASSERT(devExt->HasFrameLengthControl == FALSE,
                         devExt->Self,
                         Irp,
                         NULL);

        //
        // NOTE: it is unclear where we should check for any URBs that are still
        //          pending.  I am concerned that many USB clients will leave
        //          URBs pended and will let USBD clean up the URBs upon removal.
        //          I am not sure if this is by design or not.  
        //
        //        If we don't check before the remove is sent, we definitely/
        //          need to check afterwards
        //
        
        // UsbVerify_CheckPendingUrbs(devExt); 

        status = UsbVerify_SendIrpSynchronously(devExt->TopOfStack, Irp);

        UsbVerify_RemoveDevice(devExt);        

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    // 
    // We just want to log these events
    // 
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_STOP_DEVICE:
        UsbVerify_LogPnpEvent(devExt, Irp);

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: 
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);
        break;
    }

    return status;
}

VOID
UsbVerify_StartDevice(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    DeviceExtension->VerifyState = Started;

    if (!DeviceExtension->Initialized) {
#ifdef DO_INTERFACE
        IoSetDeviceInterfaceState(&DeviceExtension->SymbolicLinkName, TRUE);
#endif
        DeviceExtension->Initialized = TRUE;
    }
}

VOID
UsbVerify_RemoveDevice(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension
    )
{
    KIRQL irql;

#ifdef DO_INTERFACE
    IoSetDeviceInterfaceState(&DeviceExtension->SymbolicLinkName, FALSE);
    RtlFreeUnicodeString(&DeviceExtension->SymbolicLinkName);
#endif

    UsbVerify_FreePendingUrbsList(DeviceExtension); 

    UsbVerify_CheckReplacedUrbs(DeviceExtension);

    UsbVerify_LockInterfaceList(DeviceExtension, irql);    
    UsbVerify_ClearInterfaceList(DeviceExtension, RemoveDeviceRemoved);
    UsbVerify_UnlockInterfaceList(DeviceExtension, irql);    

    UsbVerify_DestroyLog(DeviceExtension);

    //
    // Clean up all allocated memory
    //

    IoDetachDevice(DeviceExtension->TopOfStack); 
    IoDeleteDevice(DeviceExtension->Self);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\ioctli.c ===
/*--         
Copyright (c) 1998, 1999  Microsoft Corporation

Module Name:

    ioctli.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/

#include "usbverfy.h"
#include "stdio.h"

#ifdef ALLOC_PRAGMA
//#pragma alloc_text (PAGE, UsbVerify_InternIoCtl)
#endif



NTSTATUS
UsbVerify_InternIoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.
    
Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION              stack;
    KEVENT                          event;
    NTSTATUS                        status = STATUS_SUCCESS;

    stack = IoGetCurrentIrpStackLocation(Irp);

    switch (stack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_INTERNAL_USB_SUBMIT_URB:
        return UsbVerify_UsbSubmitUrb(DeviceObject, Irp);

    default:
        break;
    }

    return UsbVerify_DispatchPassThrough(DeviceObject, Irp);
}

VOID
UsbVerify_SelectConfiguration(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
{
    PUSBD_INTERFACE_INFORMATION interface;
    PURB                        urb;
    KIRQL                       irql;
    UCHAR                       interfaceIndex;

    urb = URB_FROM_IRP(Irp);

    DeviceExtension->ValidConfigurationHandle =
        urb->UrbSelectConfiguration.ConfigurationHandle;

    interface = &urb->UrbSelectConfiguration.Interface;

    UsbVerify_Print(DeviceExtension, PRINT_LIST_TRACE, ("begin select config\n"));

    UsbVerify_Print(DeviceExtension, PRINT_LIST_NOISE,
                    ("select config, initializing inteface list\n"));

    UsbVerify_LockInterfaceList(DeviceExtension, irql);

    UsbVerify_InitializeInterfaceList(
        DeviceExtension,
        urb->UrbSelectConfiguration.ConfigurationDescriptor->bNumInterfaces,
        TRUE);

    UsbVerify_Print(DeviceExtension, PRINT_LIST_NOISE, ("adding %d interfaces\n",
                    (urb->UrbSelectConfiguration.ConfigurationDescriptor->bNumInterfaces
                    )));

    //
    // Add each interface to the list
    //
    for (interfaceIndex = 0;
         interfaceIndex < urb->UrbSelectConfiguration.ConfigurationDescriptor->bNumInterfaces;
         interfaceIndex++) {

        UsbVerify_InterfaceListAddInterface(DeviceExtension, interface);

        interface = (PUSBD_INTERFACE_INFORMATION)
            (((PUCHAR) interface) + interface->Length);
    }
        
    UsbVerify_UnlockInterfaceList(DeviceExtension, irql);

    UsbVerify_Print(DeviceExtension, PRINT_LIST_TRACE, ("end select config\n"));
}

VOID
UsbVerify_SelectInterface(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
{
    PUSBD_INTERFACE_INFORMATION interface;
    PURB                        urb;
    KIRQL                       irql;
     
    UsbVerify_Print(DeviceExtension, PRINT_LIST_TRACE,
                    ("begin select interface\n"));

    urb = URB_FROM_IRP(Irp);
    interface = &urb->UrbSelectInterface.Interface;

    UsbVerify_ASSERT(DeviceExtension->ValidConfigurationHandle ==
                     urb->UrbSelectInterface.ConfigurationHandle,
                     DeviceExtension->Self,
                     Irp,
                     urb);

    //
    // Add the pipes in this interface to our pipe list
    //
    UsbVerify_LockInterfaceList(DeviceExtension, irql);

    UsbVerify_Print(DeviceExtension, PRINT_LIST_INFO,
                    ("Adding new interface %p from select interface\n", interface));

    //
    // This will handle the removal of the old interface if it exists
    //
    UsbVerify_InterfaceListAddInterface(DeviceExtension, interface);

    UsbVerify_UnlockInterfaceList(DeviceExtension, irql);

    UsbVerify_Print(DeviceExtension, PRINT_LIST_TRACE, ("end select interface\n"));
}

NTSTATUS
UsbVerify_FrameLength(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp,
    PURB OrigUrb,
    PBOOLEAN Completed
    )
{
    NTSTATUS    status;
    PURB        urb = URB_FROM_IRP(Irp);

    switch (urb->UrbHeader.Function) {
    case URB_FUNCTION_SET_FRAME_LENGTH:

        UsbVerify_ASSERT(DeviceExtension->HasFrameLengthControl == TRUE,
                         DeviceExtension->Self,
                         Irp,
                         urb
                         );

        status = STATUS_SUCCESS;
        *Completed = FALSE;
        break;

    case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
    case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
        //
        // This will send the URB down and perform any generic post processing 
        // we would perform on the URB
        //
        status = UsbVerify_SendUrbSynchronously(DeviceExtension, Irp, OrigUrb);

        //
        // Because we may replace URBs with our own copies, the memory pointed
        // to by "urb" may have been freed, so get the urb again
        // 
        urb = URB_FROM_IRP(Irp);        

        if (NT_SUCCESS(status)) {
            if (urb->UrbHeader.Function == URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL) {
                DeviceExtension->HasFrameLengthControl = TRUE;
            }
            else {
                DeviceExtension->HasFrameLengthControl = FALSE;
            }
        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        *Completed = TRUE;
    }

    return status;
}

VOID
UsbVerify_ControlTransfer(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
{
    PURB                    urb = URB_FROM_IRP(Irp);
    PUSBD_PIPE_INFORMATION  pPipeInfo;
    KIRQL                   irql;

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_PIPES)) {
        UsbVerify_LockInterfaceList(DeviceExtension, irql);

        pPipeInfo = UsbVerify_ValidatePipe(DeviceExtension,
                                       urb->UrbControlTransfer.PipeHandle);

        UsbVerify_ASSERT(pPipeInfo != NULL,
                         DeviceExtension->Self,
                         Irp,
                         urb);

        if (!pPipeInfo) {
            UsbVerify_LogError(IDS_INVALID_PIPE, DeviceExtension, Irp, urb);
        }
        else {
            UsbVerify_ASSERT(pPipeInfo->PipeType == UsbdPipeTypeControl,
                             DeviceExtension->Self,
                             Irp,
                             urb);
        }

        UsbVerify_UnlockInterfaceList(DeviceExtension, irql);
    }

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_NOT_IMPLEMENTED)) {
        if (urb->UrbControlTransfer.UrbLink != NULL) {
            UsbVerify_LogError(IDS_URB_LINK_NOT_IMPLEMENTED, DeviceExtension, Irp, urb);
        }
    }

    //
    // TODO:  figure out if we need to validate anything else in the URB 
    // 
}

VOID
UsbVerify_BulkOrInterruptTransfer(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
{
    PURB                    urb = URB_FROM_IRP(Irp);
    PUSBD_PIPE_INFORMATION  pPipeInfo;
    KIRQL                   irql;

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_PIPES)) {
        UsbVerify_LockInterfaceList(DeviceExtension, irql);

        pPipeInfo =
            UsbVerify_ValidatePipe(DeviceExtension,
                                   urb->UrbBulkOrInterruptTransfer.PipeHandle);

        UsbVerify_ASSERT(pPipeInfo != NULL,
                         DeviceExtension->Self,
                         Irp,
                         urb);

        if (!pPipeInfo) {
            UsbVerify_LogError(IDS_INVALID_PIPE, DeviceExtension, Irp, urb);
        }
        else {
            UsbVerify_ASSERT(pPipeInfo->PipeType == UsbdPipeTypeBulk ||
                             pPipeInfo->PipeType == UsbdPipeTypeInterrupt,
                             DeviceExtension->Self,
                             Irp,
                             urb);
        }

        UsbVerify_UnlockInterfaceList(DeviceExtension, irql);
    }

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_NOT_IMPLEMENTED)) {
        if (urb->UrbBulkOrInterruptTransfer.UrbLink != NULL) {
            UsbVerify_LogError(IDS_URB_LINK_NOT_IMPLEMENTED, DeviceExtension, Irp, urb);
        }
    }

    //
    // TODO:  figure out if we need to validate anything else in the URB 
    // 
}

VOID
UsbVerify_IsochTransfer(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
{
    PURB                    urb = URB_FROM_IRP(Irp);
    PUSBD_PIPE_INFORMATION  pPipeInfo;
    KIRQL                   irql;

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_PIPES)) { 
        UsbVerify_LockInterfaceList(DeviceExtension, irql);

        pPipeInfo =
            UsbVerify_ValidatePipe(DeviceExtension,
                                   urb->UrbIsochronousTransfer.PipeHandle);

        UsbVerify_ASSERT(pPipeInfo != NULL,
                         DeviceExtension->Self,
                         Irp,
                         urb);

        if (!pPipeInfo) {
            UsbVerify_LogError(IDS_INVALID_PIPE, DeviceExtension, Irp, urb);
        }
        else {
            UsbVerify_ASSERT(pPipeInfo->PipeType == UsbdPipeTypeIsochronous,
                             DeviceExtension->Self,
                             Irp,
                             urb);
        }

        UsbVerify_UnlockInterfaceList(DeviceExtension, irql);
    }

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_NOT_IMPLEMENTED)) {
        if (urb->UrbIsochronousTransfer.UrbLink != NULL) {
            UsbVerify_LogError(IDS_URB_LINK_NOT_IMPLEMENTED, DeviceExtension, Irp, urb);
        }
    }

    //
    // TODO:  figure out if we need to validate anything else in the URB 
    // 
}

VOID
UsbVerify_UrbPipeRequest(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
{
    CHAR                    dbgBuf[256];
    PUSBD_PIPE_INFORMATION  pPipeInfo;
    PURB                    urb, verifyUrb;
    PUSB_VERIFY_TRACK_URB   verify;
    PLIST_ENTRY             entry;
    KIRQL                   irql;
    ULONG                   pipeFlag;
    USBD_PIPE_HANDLE        pipe;

    urb = URB_FROM_IRP(Irp);

    if (urb->UrbHeader.Function == URB_FUNCTION_RESET_PIPE &&
        UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_TRACK_URBS)) {
        //
        // Make sure there are not pending URBs on this pipe
        //
        UsbVerify_LockUrbList(DeviceExtension, irql);

        for (entry = DeviceExtension->UrbList.Flink;
             entry != &DeviceExtension->UrbList;
             entry = entry->Flink) {
    
            pipe = NULL;
            verify = CONTAINING_RECORD(entry, USB_VERIFY_TRACK_URB, Link); 
            verifyUrb = verify->Urb;
            
            //
            // If any of these ASSERT fire, that means that a reset or abort was
            // sent down a pipe that had pending requests on it.  BAD BAD BAD.
            //
            switch (verify->Urb->UrbHeader.Function) {
            case URB_FUNCTION_ISOCH_TRANSFER:
                if (verifyUrb->UrbIsochronousTransfer.PipeHandle == urb->UrbPipeRequest.PipeHandle) {
                    sprintf(dbgBuf,
                            "Reset sent on a pipe with a pending Isoch transfer, !urb 0x%x",
                            verifyUrb
                            );
    
                    UsbVerify_ASSERT_MSG(
                        verifyUrb->UrbIsochronousTransfer.PipeHandle != urb->UrbPipeRequest.PipeHandle,
                        dbgBuf,
                        DeviceExtension->Self,
                        Irp,
                        urb);
                }
                break;

            case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
                if (verifyUrb->UrbBulkOrInterruptTransfer.PipeHandle == urb->UrbPipeRequest.PipeHandle) {
                    sprintf(dbgBuf,
                            "Reset sent on a pipe with a pending Bulk or Interrupt transfer, !urb 0x%x",
                            verifyUrb
                            );
    
                    UsbVerify_ASSERT_MSG(
                        verifyUrb->UrbBulkOrInterruptTransfer.PipeHandle != urb->UrbPipeRequest.PipeHandle,
                        dbgBuf,
                        DeviceExtension->Self,
                        Irp,
                        urb);
                }
                break;

            case URB_FUNCTION_CONTROL_TRANSFER:
                if (verifyUrb->UrbControlTransfer.PipeHandle == urb->UrbPipeRequest.PipeHandle) {
                    sprintf(dbgBuf,
                            "Reset sent on a pipe with a pending Control transfer, !urb 0x%x",
                            verifyUrb
                            );

                    UsbVerify_ASSERT_MSG(
                        verifyUrb->UrbControlTransfer.PipeHandle != urb->UrbPipeRequest.PipeHandle,
                        dbgBuf,
                        DeviceExtension->Self,
                        Irp,
                        urb);
                }
                break;

            default:
                ;
            }
        }

        UsbVerify_UnlockUrbList(DeviceExtension, irql);
    }

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_PIPES)) {

        if (urb->UrbHeader.Function == URB_FUNCTION_RESET_PIPE) {
            pipeFlag = USB_VERIFY_PF_RESETTING;
        }
        else {
            pipeFlag = USB_VERIFY_PF_ABORTING;
        }

        UsbVerify_LockInterfaceList(DeviceExtension, irql);
        
        pPipeInfo = UsbVerify_ValidatePipe(DeviceExtension,
                                           urb->UrbPipeRequest.PipeHandle);

        if (pPipeInfo == NULL) {
            UsbVerify_ASSERT_MSG(
                pPipeInfo != NULL,
                "Abort or reset sent down an invalid pipe",
                DeviceExtension->Self,
                Irp,
                urb);
        }
        else {
            UsbVerify_ASSERT_MSG(
                (pPipeInfo->PipeFlags & pipeFlag) == 0,
                (pipeFlag == USB_VERIFY_PF_ABORTING)
                  ? "Abort sent on a pipe with an abort already pending"
                  : "Reset sent on a pipe with a reset already pending", 
                DeviceExtension->Self,
                Irp,
                urb);
                             
            pPipeInfo->PipeFlags  |= pipeFlag; 
        }

        UsbVerify_UnlockInterfaceList(DeviceExtension, irql);
    }
}


NTSTATUS
UsbVerify_UsbSubmitUrb(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
{
    PUSB_VERIFY_DEVICE_EXTENSION    devExt;
    NTSTATUS                        status = STATUS_SUCCESS;
    PURB                            origUrb, urb; 
    KIRQL                           irql;

    devExt = GetExtension(DeviceObject);

    //
    // This function can change the URB embedded in the irp so we grab the urb
    // AFTER calling this function.  The original urb will be stored in origUrb
    // if the urb was replaced.
    //
    UsbVerify_PreProcessUrb(devExt, Irp, &origUrb);

    urb = URB_FROM_IRP(Irp);

    UsbVerify_Print(devExt, PRINT_URB_NOISE,
                     ("Urb 0x%x from irp 0x%x, function is %x\n",
                      urb, Irp, (ULONG) urb->UrbHeader.Function));

    switch (urb->UrbHeader.Function) {
    case URB_FUNCTION_SELECT_CONFIGURATION:
        //
        // We always maintain the InterfaceList, not matter if VERIFY_PIPES is set
        // or not.  VERIFY_PIPES just controls if check against the list or not
        //
        UsbVerify_LockInterfaceList(devExt, irql);

        UsbVerify_ClearInterfaceList (
            devExt,
            ((urb->UrbSelectConfiguration.ConfigurationDescriptor == NULL)
                ? RemoveSelectConfigZero
                : RemoveSelectConfig) );

        UsbVerify_UnlockInterfaceList(devExt, irql);

        //
        // Only create a new pipe list if the request has a valid ConfigDesc
        //
        if (urb->UrbSelectConfiguration.ConfigurationDescriptor != NULL) {
            //
            // This will send the URB down and perform any generic post processing 
            // we would perform on the URB
            //
            status = UsbVerify_SendUrbSynchronously(devExt, Irp, origUrb);
    
            if (NT_SUCCESS(status)) {
                UsbVerify_SelectConfiguration(devExt, Irp);
            }
    
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
            return status;
        }
        else {
            devExt->ValidConfigurationHandle = NULL;
        }

        break;

    case URB_FUNCTION_SELECT_INTERFACE:
        //
        // This will send the URB down and perform any generic post processing 
        // we would perform on the URB
        //
        status = UsbVerify_SendUrbSynchronously(devExt, Irp, origUrb);

        if (NT_SUCCESS(status)) {
            //
            // This will remove the old interface if exists and add the new one
            //
            UsbVerify_SelectInterface(devExt, Irp);
        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
        return status;

    case URB_FUNCTION_RESET_PIPE:
    case URB_FUNCTION_ABORT_PIPE:
        UsbVerify_UrbPipeRequest(devExt, Irp);
        // send the irp asynch
        break;

    case URB_FUNCTION_CONTROL_TRANSFER:
        UsbVerify_ControlTransfer(devExt, Irp);
        break;

    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
        UsbVerify_BulkOrInterruptTransfer(devExt, Irp);
        break;

    case URB_FUNCTION_ISOCH_TRANSFER:
        UsbVerify_IsochTransfer(devExt, Irp);
        break;

    //
    // Frame length related URBs
    // 
    case URB_FUNCTION_SET_FRAME_LENGTH:
    case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
    case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
        {
            BOOLEAN completed;

            status = UsbVerify_FrameLength(devExt, Irp, origUrb, &completed);
            if (completed) {
                return status;
            }
        }

        break;

    //
    // These functions correspond
    // to the standard commands on the default pipe
    //
    // direction is implied
    //

    case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
                                                           
    case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
    case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
    case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
        if (UsbVerify_CheckVerifyFlags(devExt, VERIFY_NOT_IMPLEMENTED)) {
            if (urb->UrbControlDescriptorRequest.UrbLink != NULL) {
                UsbVerify_LogError(IDS_URB_LINK_NOT_IMPLEMENTED, devExt, Irp, urb);
            }
        }
        break;

    //
    // TODO:  figure out if we can check anything on the URB other than UrbLink
    //
    case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
    case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
    case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
    case URB_FUNCTION_SET_FEATURE_TO_OTHER:

    case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
    case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
    case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
    case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
        if (UsbVerify_CheckVerifyFlags(devExt, VERIFY_NOT_IMPLEMENTED)) {
            if (urb->UrbControlFeatureRequest.UrbLink != NULL) {
                UsbVerify_LogError(IDS_URB_LINK_NOT_IMPLEMENTED, devExt, Irp, urb);
            }
        }
        break;

    case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
    case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
    case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
    case URB_FUNCTION_GET_STATUS_FROM_OTHER:
        if (UsbVerify_CheckVerifyFlags(devExt, VERIFY_NOT_IMPLEMENTED)) {
            if (urb->UrbControlGetStatusRequest.UrbLink != NULL) {
                UsbVerify_LogError(IDS_URB_LINK_NOT_IMPLEMENTED, devExt, Irp, urb);
            }
        }
        break;
    
    case URB_FUNCTION_VENDOR_DEVICE:
    case URB_FUNCTION_VENDOR_INTERFACE:
    case URB_FUNCTION_VENDOR_ENDPOINT:
    case URB_FUNCTION_VENDOR_OTHER:

    case URB_FUNCTION_CLASS_DEVICE:
    case URB_FUNCTION_CLASS_INTERFACE:
    case URB_FUNCTION_CLASS_ENDPOINT:
    case URB_FUNCTION_CLASS_OTHER:
        if (UsbVerify_CheckVerifyFlags(devExt, VERIFY_NOT_IMPLEMENTED)) {
            if (urb->UrbControlVendorClassRequest.UrbLink != NULL) {
                UsbVerify_LogError(IDS_URB_LINK_NOT_IMPLEMENTED, devExt, Irp, urb);
            }
        }
        break;

    case URB_FUNCTION_GET_FRAME_LENGTH:
    case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
    default:
        break;
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           (PIO_COMPLETION_ROUTINE) UsbVerify_UrbComplete, 
                           origUrb,
                           TRUE,
                           TRUE,
                           TRUE); // No need for Cancel

    return IoCallDriver(devExt->TopOfStack, Irp);
}

VOID
UsbVerify_PostVerifyUrb(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PUSB_VERIFY_DEVICE_EXTENSION    devExt;
    PUSBD_PIPE_INFORMATION          pPipeInfo;
    PURB                            urb;
    KIRQL                           irql;
    ULONG                           pipeFlag = 0x0;

    urb = URB_FROM_IRP(Irp);
    devExt = GetExtension(DeviceObject);

    switch (urb->UrbHeader.Function) {
    case URB_FUNCTION_RESET_PIPE:
        pipeFlag = USB_VERIFY_PF_RESETTING;

    case URB_FUNCTION_ABORT_PIPE:
        if (pipeFlag == 0x0) {
            pipeFlag = USB_VERIFY_PF_ABORTING;
        }

        UsbVerify_LockInterfaceList(devExt, irql);

        pPipeInfo = UsbVerify_ValidatePipe(devExt,
                                           urb->UrbPipeRequest.PipeHandle);

        UsbVerify_ASSERT(pPipeInfo != NULL, DeviceObject, Irp, urb);

        if (pPipeInfo) {
            //
            // Make sure that the flag was set on the way down, otherwise there
            // is an internal logic error.
            //
            UsbVerify_ASSERT((pPipeInfo->PipeFlags & pipeFlag) == pipeFlag,
                             DeviceObject,
                             Irp,
                             urb);

            pPipeInfo->PipeFlags &= ~pipeFlag;
        }

        UsbVerify_UnlockInterfaceList(devExt, irql);
        break;

    default:
        // do nothing
        ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\log.c ===
/*--         
Copyright (c) 1998, 1999  Microsoft Corporation

Module Name:

    log.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/

#include "usbverfy.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, UsbVerify_DestroyLog)
#endif

PCHAR ErrorStrings[] =
{
    { "Urb is using an invalid pipe." },
    { "Urb is had the UrbLink set (currently unimplemented)." },
    { "The device has been removed and the urb was not cancelled." },  // IDS_STALE_URB
};

VOID
UsbVerify_ResizeLog(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    ULONG NewSize
    )
{
    PUSB_VERIFY_LOG_ENTRY oldLog;
    ULONG                 oldLogSize;

    oldLog = DeviceExtension->Log;
    oldLogSize = DeviceExtension->LogSize;

    DeviceExtension->Log = AllocStruct(NonPagedPool, USB_VERIFY_LOG_ENTRY, NewSize);
    if (DeviceExtension->Log) {
        DeviceExtension->LogSize = NewSize;
        DeviceExtension->CurrentLogEntry = DeviceExtension->Log + oldLogSize;

        if (oldLog) {
            RtlCopyMemory(DeviceExtension->Log, oldLog, oldLogSize);
        }
    }
    else {
        // 
        // no more memory, restore the old log and never log again
        //
        DeviceExtension->LogFlags = 0x0;
        DeviceExtension->CurrentLogEntry = NULL;

        DeviceExtension->Log = oldLog;
        DeviceExtension->LogSize = oldLogSize;
    }
}

VOID 
UsbVerify_Log (
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PUSB_VERIFY_LOG_ENTRY LogEntry
    )
{
    LARGE_INTEGER tick;

    if (DeviceExtension->CurrentLogEntry >=
        DeviceExtension->Log + DeviceExtension->LogSize) {
        UsbVerify_ResizeLog(DeviceExtension, DeviceExtension->LogSize * 2);
    }

    if (DeviceExtension->CurrentLogEntry) {
        KeQueryTickCount(&LogEntry->CurrentTick);
        *DeviceExtension->CurrentLogEntry = *LogEntry;
        DeviceExtension->CurrentLogEntry++;
    }
}

VOID
UsbVerify_LogError(
    ULONG StringIndex,
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp,
    PURB Urb
    )
{
    //
    // NOTE: figure out the semantics of logging the error.  
    //
    // do we want to select (via a flag) what are actions are?  ie, record the
    //  error, dump it to the debugger, etc etc
    //

    //
    // For right now, dump it to the debugger
    //
    UsbVerify_Assert(ErrorStrings[StringIndex],
                     DeviceExtension->Self,
                     Irp,
                     Urb,
                     NULL);
}

VOID 
UsbVerify_InitLog (
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS    status;
    HANDLE      hKey, hParameters;
    ULONG       logSize;

    logSize = LOG_SIZE_DEFAULT;

    hParameters = UsbVerify_OpenServiceParameters(DeviceExtension);
    if (hParameters != NULL) {
        UsbVerify_QueryKey(hParameters,
                           USB_VERIFY_LOGSIZE_SZ,
                           &logSize,
                           sizeof(logSize));

        ZwClose(hParameters);
    }

    //
    // Devnode value has higher precedence over the services\parameters value
    // so query this after
    //
    status = IoOpenDeviceRegistryKey(DeviceExtension->PDO,
                                     PLUGPLAY_REGKEY_DEVICE, 
                                     STANDARD_RIGHTS_READ,
                                     &hKey);

    if (NT_SUCCESS(status)) {
        UsbVerify_QueryKey(hKey,
                           USB_VERIFY_LOGSIZE_SZ,
                           &logSize,
                           sizeof(logSize));
                           
        ZwClose(hKey);
    }

    UsbVerify_ResizeLog(DeviceExtension, logSize);
}

VOID
UsbVerify_DestroyLog(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    if (DeviceExtension->Log) {
        ExFreePool(DeviceExtension->Log);
        DeviceExtension->Log = NULL;
    }
}

UCHAR ShutUp = 0x0;
ULONG GlobalAssertState = 0x0;

ULONG
DbgPrompt(
    IN PCHAR Prompt,
    OUT PCHAR Response,
    IN ULONG MaximumResponseLength
    );

VOID
UsbVerify_Assert(
    PCHAR Msg,
    PDEVICE_OBJECT DeviceObject,
    PIRP  Irp,
    PURB  Urb,
    PULONG AssertState
    )
{
    ULONG                           state = 0x0;
    BOOLEAN                         done, validResponse;
    CHAR                            response[2];
    PUSB_VERIFY_DEVICE_EXTENSION    devExt;

    if (AssertState != NULL) {
        state = *AssertState;
    }

    //
    // Check to see if the assert has been disabled or all asserts have been
    // disabled
    //
    if ((state & ASSERT_REMOVED) !=  0 || 
        (GlobalAssertState & ASSERT_REMOVED) != 0) {
        return;
    }

    done = FALSE;
    while (done == FALSE) {

        if (ShutUp == 0) {
            // BEEP!
            DbgPrint("%c", 7);
        }
    
        DbgPrint("\nASSERTION ""%s"" failed\n", Msg);
    
        if (ARGUMENT_PRESENT(DeviceObject)) 
        {
            //
            // Display the device object, device extension, 
            //  top of stack device object and physical device object.
            //

            devExt = 
                (PUSB_VERIFY_DEVICE_EXTENSION) DeviceObject -> DeviceExtension;

            DbgPrint("\t!DevObj 0x%x DevExt 0x%x\n",
                     DeviceObject, devExt);

            DbgPrint("\t!DevObj 0x%x --> TopOfStackObject\n",
                     devExt -> TopOfStack);

            DbgPrint("\t!DevObj 0x%x --> PhysicalDeviceObject\n",
                     devExt -> PDO);
        }

        if (ARGUMENT_PRESENT(Irp)) {
            DbgPrint("\t!Irp 0x%x\n", Irp);
        }
    
        if (ARGUMENT_PRESENT(Urb)) {
            DbgPrint("\t!Urb 0x%x\n", Urb);
        }

        if (state & ASSERT_AS_WARNING) {
            break;
        }

#if WIN95_BUILD
        if (AssertState) {
            DbgPrint("e %x to change assert\n", AssertState);
            DbgPrint("set 0x01 to convert into a warning\n"
                     "set 0x10 to remove the assert\n");
        }
        DbgPrint("\nset %x to 1 to disable ALL asserts\n", &GlobalAssertState);
        DbgBreakPoint();

        done = TRUE;
#else

        //
        // Wait for input...
        //
        validResponse = FALSE;
        while (validResponse == FALSE) {

            done = TRUE;

            if (ARGUMENT_PRESENT(AssertState)) {
                DbgPrompt( "Break, Ignore, convert to Warning, Remove, Disable all (biwrd)? ", response, sizeof( response ));
            }
            else {
                DbgPrompt( "Break, Ignore (bi)? ", response, sizeof( response ));
            }
    
            switch (response[0]) {
    
            case 'B':
            case 'b':
                DbgPrint("Breaking in... (press g<enter> to return to assert menu)\n");
                DbgBreakPoint();
                validResponse = TRUE;
                done = FALSE;
                break;
    
            case 'I':
            case 'i':
                validResponse = TRUE;
                break;
    
            case 'W':
            case 'w':
                if (ARGUMENT_PRESENT(AssertState)) {
                   DbgPrint("Assert is now a warning (OS will print text, beep, and return)\n");
                   state |= ASSERT_AS_WARNING;
                   validResponse = TRUE;
                }
                break;

            case 'R':
            case 'r':
                if (ARGUMENT_PRESENT(AssertState)) {
                   DbgPrint("Breakpoint removed\n") ;
                   state |= ASSERT_REMOVED;
                   validResponse = TRUE;
                }
                break;
    
            case 'D':
            case 'd':
                GlobalAssertState |= ASSERT_REMOVED;
                DbgPrint("USB Verification asserts disabled.\n");
                validResponse = TRUE;
                break;
    
            }
        }
#endif
    }

#if WIN95_BUILD
#else
    DbgPrint("\n");

    if (AssertState) {
        *AssertState = state;
    }
#endif
}

VOID
UsbVerify_Warning(
    PCHAR Msg,
    PDEVICE_OBJECT DeviceObject,
    PIRP  Irp,
    PURB  Urb,
    PULONG WarningState
    )
{
    PUSB_VERIFY_DEVICE_EXTENSION devExt = GetExtension(DeviceObject);

    if (devExt->TreatWarningsAsErrors) {
        UsbVerify_Assert(Msg, DeviceObject, Irp, Urb, WarningState);
        return;
    }

    if (ShutUp == 0) {
        // BEEP!
        DbgPrint("%c", 7);
    }

    DbgPrint("WARNING %s failed\n", Msg);

    if (ARGUMENT_PRESENT(DeviceObject)) {
        //
        // NOTE: we should get the PDO / top of the stack for this DO and print
        //         it as well
        //
        DbgPrint("\tDeviceObject = 0x%x, DevExt 0x%x\n", DeviceObject, devExt);
    }

    if (ARGUMENT_PRESENT(Irp)) {
        DbgPrint("\tIrp = 0x%x\n", Irp);
    }

    if (ARGUMENT_PRESENT(Urb)) {
        DbgPrint("\tUrb = 0x%x\n", Urb);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\urb.c ===
/*--         
Copyright (c) 1998, 1999  Microsoft Corporation

Module Name:

    urb.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/

#include "usbverfy.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, UsbVerify_CheckReplacedUrbs)
#endif

#define COMPUTE_SIZE ((USHORT) 0xFFFF)

USHORT FunctionToUrbLength[] =
{
/* URB_FUNCTION_SELECT_CONFIGURATION           0x0000 */ COMPUTE_SIZE, // sizeof(struct _URB_SELECT_CONFIGURATION),
/* URB_FUNCTION_SELECT_INTERFACE               0x0001 */ COMPUTE_SIZE, // sizeof(struct _URB_SELECT_INTERFACE),
/* URB_FUNCTION_ABORT_PIPE                     0x0002 */ sizeof(struct _URB_PIPE_REQUEST),
/* URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL      0x0003 */ sizeof(struct _URB_FRAME_LENGTH_CONTROL),
/* URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL   0x0004 */ sizeof(struct _URB_FRAME_LENGTH_CONTROL),
/* URB_FUNCTION_GET_FRAME_LENGTH               0x0005 */ sizeof(struct _URB_GET_FRAME_LENGTH),
/* URB_FUNCTION_SET_FRAME_LENGTH               0x0006 */ sizeof(struct _URB_SET_FRAME_LENGTH),
/* URB_FUNCTION_GET_CURRENT_FRAME_NUMBER       0x0007 */ sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER),
/* URB_FUNCTION_CONTROL_TRANSFER               0x0008 */ sizeof(struct _URB_CONTROL_TRANSFER),
/* URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER     0x0009 */ sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
/* URB_FUNCTION_ISOCH_TRANSFER                 0x000A */ COMPUTE_SIZE, // sizeof(struct _URB_ISOCH_TRANSFER),
/* URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE     0x000B */ sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
/* URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE       0x000C */ sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
/* URB_FUNCTION_SET_FEATURE_TO_DEVICE          0x000D */ sizeof(struct _URB_CONTROL_FEATURE_REQUEST ),
/* URB_FUNCTION_SET_FEATURE_TO_INTERFACE       0x000E */ sizeof(struct _URB_CONTROL_FEATURE_REQUEST ),
/* URB_FUNCTION_SET_FEATURE_TO_ENDPOINT        0x000F */ sizeof(struct _URB_CONTROL_FEATURE_REQUEST ),

/* URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE        0x0010 */ sizeof(struct _URB_CONTROL_FEATURE_REQUEST ),
/* URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE     0x0011 */ sizeof(struct _URB_CONTROL_FEATURE_REQUEST ),
/* URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT      0x0012 */ sizeof(struct _URB_CONTROL_FEATURE_REQUEST ),
/* URB_FUNCTION_GET_STATUS_FROM_DEVICE         0x0013 */ sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST ),
/* URB_FUNCTION_GET_STATUS_FROM_INTERFACE      0x0014 */ sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST ),
/* URB_FUNCTION_GET_STATUS_FROM_ENDPOINT       0x0015 */ sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST ),
/* URB_FUNCTION_RESERVED0                      0x0016 */ 0x0, 
/* URB_FUNCTION_VENDOR_DEVICE                  0x0017 */ sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ),
/* URB_FUNCTION_VENDOR_INTERFACE               0x0018 */ sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ),
/* URB_FUNCTION_VENDOR_ENDPOINT                0x0019 */ sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ),
/* URB_FUNCTION_CLASS_DEVICE                   0x001A */ sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ),
/* URB_FUNCTION_CLASS_INTERFACE                0x001B */ sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ),
/* URB_FUNCTION_CLASS_ENDPOINT                 0x001C */ sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ),
/* URB_FUNCTION_RESERVED                       0x001D */ 0x0,
/* URB_FUNCTION_RESET_PIPE                     0x001E */ sizeof(struct _URB_PIPE_REQUEST ),
/* URB_FUNCTION_CLASS_OTHER                    0x001F */ sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ),

/* URB_FUNCTION_VENDOR_OTHER                   0x0020 */ sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ),
/* URB_FUNCTION_GET_STATUS_FROM_OTHER          0x0021 */ sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST ),
/* URB_FUNCTION_CLEAR_FEATURE_TO_OTHER         0x0022 */ sizeof(struct _URB_CONTROL_FEATURE_REQUEST ),
/* URB_FUNCTION_SET_FEATURE_TO_OTHER           0x0023 */ sizeof(struct _URB_CONTROL_FEATURE_REQUEST ),
/* URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT   0x0024 */ sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
/* URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT     0x0025 */ sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
/* URB_FUNCTION_GET_CONFIGURATION              0x0026 */ sizeof(struct _URB_CONTROL_GET_CONFIGURATION_REQUEST ),
/* URB_FUNCTION_GET_INTERFACE                  0x0027 */ sizeof(struct _URB_CONTROL_GET_INTERFACE_REQUEST ),
/* URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE  0x0028 */ sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
/* URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE    0x0029 */ sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST ),

};

#define FUNCTION_TO_URB_LENGTH_MAX (sizeof(FunctionToUrbLength) / sizeof(USHORT))

USHORT
UsbVerify_DetermineInterfaceSize(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PURB Urb,
    PUSBD_INTERFACE_INFORMATION Interface
    )
{
    USHORT  minimumLength;

    //
    // This assert is an iffy one.  It is possible that a device can
    //  set a zero BW interface which could be either an alternate setting
    //  that contains 1 EP with a MaxPacketSize of 0 or an 0 EP interface.
    //  Right now we'll leave this in and just choke on most streaming 
    //  devices that rachet down on shutting off. 
    //
    //  NOTE: This assert needs to be revisited for further determination
    //          of its validity.  At a minimum, the above behavior should
    //          be documented somewhere.
    //

    UsbVerify_ASSERT(Interface->NumberOfPipes > 0,
                     DeviceExtension->Self, 
                     NULL,
                     Urb);

    //
    // Calculate the minimum required length of the interface field.  This must
    //  equal the sizeof interface plus any room for the pipe information.
    //  We subtract the sizeof(USBD_PIPE_INFORMATION) from the interface
    //  size since an interface doesn't have to have any pipes but 
    //  sizeof(USBD_INTERFACE_INFORMATION) returns the size of one pipe.
    //

    minimumLength = sizeof(USBD_INTERFACE_INFORMATION) -
                    sizeof(USBD_PIPE_INFORMATION) +
                    Interface -> NumberOfPipes * sizeof(USBD_PIPE_INFORMATION);


    if (Interface->Length) 
    {
        //
        // Check that the reported interface length is at least the size
        //  of the minimum length.
        //
        // NOTE: Need to find a better way to report the mimimum length
        //          to the user.  This is the same problem as with
        //          verifying the overall URB length.
        //
        // NOTE: Should this be an == instead of >= to perform tighter
        //          restrictions.  Doing so would help verify that the
        //          length field is accurate and not just some bogus
        //          number that happened to be bigger than minimum length.
        //          Are there reasons a client may legally specify a larger
        //          size?
        //

        UsbVerify_ASSERT(Interface->Length >= minimumLength,
                         DeviceExtension->Self, 
                         NULL,
                         Urb);

        return Interface->Length;
    }
    else {

        //
        // Size of the Interface field
        //

        return (minimumLength);
    }
}

USHORT
UsbVerify_DetermineUrbLength(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PURB Urb
    )
{
    USHORT length, function;

    function = Urb->UrbHeader.Function;

    if (function < FUNCTION_TO_URB_LENGTH_MAX) {
        length = FunctionToUrbLength[function];

        if (length != 0 && length != COMPUTE_SIZE) {
            return length;
        }
    }
    else {
        UsbVerify_Print(DeviceExtension, PRINT_ALWAYS,
                        ("Uknnown function 0x%x with length of 0!\n",
                         (ULONG) function));

        return (USHORT) 0x0;
    }


    //
    // Check to see if the user is allowed to send this URB
    //
    if (length == 0) {
        UsbVerify_Assert("Client driver is not allowed to send this urb!",
                         DeviceExtension->Self, NULL, Urb, NULL); 
        return 0;
    }

    //
    // length == COMPUTE_SIZE.  This means we need to do some math to figure
    // out the size that is required
    //
    switch (function) {
    case URB_FUNCTION_SELECT_CONFIGURATION:

        //
        // The UrbSelectConfiguration size should be at least equal to 
        //  sizeof(UrbSelectConfiguration).  This would be true only when
        //  the configuration is being deselected (ConfigurationDescriptor ==
        //  NULL).  Otherwise, calculate the variable length portion that is
        //  the interface information.  Since, sizeof(UrbSelectConfiguration)
        //  contains the size of the Interface field, subtract that off because 
        //  the value returned by UsbVerify_DeterminteInterfaceSize contains
        //  the size of the Interface field as well as the memory hanging
        //  on after it.
        //

        length = (USHORT) (sizeof(Urb->UrbSelectConfiguration));

        if (NULL != Urb->UrbSelectConfiguration.ConfigurationDescriptor)
        {
            length -= sizeof(Urb->UrbSelectConfiguration.Interface);

            length += UsbVerify_DetermineInterfaceSize(DeviceExtension,
                                 Urb,
                                 &Urb->UrbSelectConfiguration.Interface);
        }

        UsbVerify_Print(DeviceExtension, PRINT_URB_INFO,
                        ("select config computed size = 0x%x bytes\n", (ULONG) length));

        break;

    case URB_FUNCTION_SELECT_INTERFACE:

        //
        // The sizeof UrbSelectInterface contains the size of the Interface
        // field.  We want to get subtract that off because the value returned by
        // UsbVerify_DeterminteInterfaceSize contains the size of the Interface
        // field as well as the memory hanging on after it
        //
        length = (USHORT)
            (sizeof(Urb->UrbSelectInterface) -
             sizeof(Urb->UrbSelectInterface.Interface)) +
            UsbVerify_DetermineInterfaceSize(DeviceExtension,
                                             Urb,
                                             &Urb->UrbSelectInterface.Interface);

        UsbVerify_Print(DeviceExtension, PRINT_URB_INFO,
                        ("select interface computed size = 0x%x bytes\n", (ULONG) length));

        break;

    case URB_FUNCTION_ISOCH_TRANSFER:
        UsbVerify_ASSERT(Urb->UrbIsochronousTransfer.NumberOfPackets > 0,
                         DeviceExtension->Self,
                         NULL,
                         Urb);
        length = sizeof(Urb->UrbIsochronousTransfer) + 
                 (sizeof(Urb->UrbIsochronousTransfer.IsoPacket[0]) *
                     (Urb->UrbIsochronousTransfer.NumberOfPackets - 1));

        UsbVerify_Print(DeviceExtension, PRINT_URB_INFO,
                        ("isoch transfer computed size = 0x%x bytes\n", (ULONG) length));

        break;

    default:
        UsbVerify_Print(DeviceExtension, PRINT_URB_ERROR,
                        ("need to add a case for funciton 0x%x\n", (ULONG) function));
        DbgBreakPoint();
        length = 0;
    }

    return length;
}


VOID
UsbVerify_PreProcessUrb(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp,
    PURB *OriginalUrb
    )
{
    PURB urb, newUrb = NULL;
    USHORT  expectedUrbLength;

    urb = URB_FROM_IRP(Irp);
    *OriginalUrb = NULL;

    //
    // All URBs must definitely be sent only after START_DEVICE has been sent 
    // down and up the stack.  Most USB clients do not handle SURPRISE_REMOVE,
    // they will continue to send requests in that state.
    //
    UsbVerify_ASSERT((DeviceExtension->VerifyState == Started) ||
                     (DeviceExtension->VerifyState == SurpriseRemoved),
                     DeviceExtension->Self,
                     Irp,
                     urb);

    UsbVerify_ASSERT(DeviceExtension->PowerState == PowerDeviceD0,
                     DeviceExtension->Self,
                     Irp,
                     urb);

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_TEST_MEMORY)) {
        //
        // NOTE implement this
        //
        // MmProbeForWrite () ? 
        // ExQueryPoolBlockSize () ?
        // any Mm function to verify the pool?
    }

    //
    // Check the length that the calling driver passed in to the urb 
    //  function.  We should be able to determine the expected length in
    //  all cases and the length field should match that length.
    //

    expectedUrbLength = UsbVerify_DetermineUrbLength(DeviceExtension, urb);

    UsbVerify_Print(DeviceExtension, PRINT_URB_INFO,
                    ("expected urb length = 0x%x bytes\n", expectedUrbLength));

    UsbVerify_ASSERT(urb->UrbHeader.Length == expectedUrbLength,
                     DeviceExtension->Self,
                     Irp,
                     urb);

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_REPLACE_URBS)) {

        if (0 == expectedUrbLength)
        {
            goto LowMemory;
        }

        //
        // Can't use AllocStruct because the urb size can be easily be bigger
        // then sizeof(URB)
        //

        newUrb = (PURB) ExAllocatePool (NonPagedPool, expectedUrbLength);

        if (newUrb != NULL) {
            // 
            // Copy the contents into the new urb and then fill the original with
            // USB_VERIFY_FULL.  We will copy back the contents when we are done
            // in the completion routine.
            // 

            RtlCopyMemory(newUrb, urb, expectedUrbLength);

            newUrb -> UrbHeader.Length = expectedUrbLength;

            RtlFillMemory(urb, expectedUrbLength, USB_VERIFY_FILL);

            //
            // Replace the caller supplied URB with ours
            //

            URB_FROM_IRP(Irp) = newUrb;

            *OriginalUrb = urb;

            UsbVerify_Print(DeviceExtension, PRINT_URB_INFO,
                            ("Replacing urb\n"
                             "\t Original URB 0x%x\n"
                             "\t Verify   URB 0x%x\n"
                             "\t in IRP 0x%x on device 0x%x\n",
                             urb, newUrb, Irp, DeviceExtension->Self));
        }
        else {
LowMemory:
            //
            // No memory!  Behave as if the replace urb flag is not set 
            //
            InterlockedIncrement(&DeviceExtension->ReplaceUrbsLowMemoryCount);
        }
    }

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_TRACK_URBS)) {
        PUSB_VERIFY_TRACK_URB verify;
        PLIST_ENTRY           entry;
        KIRQL                 irql;

        //
        // Make sure the client is reusing the same URB in two different IRPs.
        // According to JD, some driver writers actually try to do this!
        //
        UsbVerify_LockUrbList(DeviceExtension, irql);

        for (entry = DeviceExtension->UrbList.Flink;
             entry != &DeviceExtension->UrbList;
             /* increment handled before we free the struct */ ) {

            verify = CONTAINING_RECORD(entry, USB_VERIFY_TRACK_URB, Link); 

            //
            // Any previous client sent URBs will be in verify->Urb (we are NOT
            // replacing URBs( or in verify->OriginalUrb (we ARE replacing URBs)
            //
            UsbVerify_ASSERT(verify->Urb != urb && verify->OriginalUrb != urb,
                             DeviceExtension->Self,
                             Irp,
                             urb);

            entry = entry->Flink;
        }

        UsbVerify_UnlockUrbList(DeviceExtension, irql);

        verify = AllocStruct(NonPagedPool, USB_VERIFY_TRACK_URB, 1);

        if (verify) {
            RtlZeroMemory(verify, sizeof(*verify));

            verify->Irp = Irp;
            if (newUrb) {
                verify->Urb = newUrb; 
                verify->OriginalUrb = urb;
            }
            else {
                verify->Urb = urb;
                verify->OriginalUrb = NULL;
            }

            KeQueryTickCount(&verify->ArrivalTime);

            UsbVerify_LockUrbList(DeviceExtension, irql);
            InsertTailList(&DeviceExtension->UrbList, &verify->Link);
            UsbVerify_UnlockUrbList(DeviceExtension, irql);
        }
        else {
            InterlockedIncrement(&DeviceExtension->UrbListLowMemoryCount);
        }
    }

    InterlockedIncrement(&DeviceExtension->UrbListCount);
}

VOID 
UsbVerify_PostProcessUrb(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PURB OldUrb
    )
{
    PUSB_VERIFY_DEVICE_EXTENSION    devExt;
    PURB                            urb;
    ULONG                           urbListCount;

    devExt = GetExtension(DeviceObject);

    //
    // This urb may be an urb we sent in place of OldUrb, if OldUrb != NULL
    //
    urb = URB_FROM_IRP(Irp);

    //
    // We always keep (at least) a count of pending urbs
    //
    urbListCount = InterlockedDecrement(&devExt->UrbListCount);
    UsbVerify_ASSERT(urbListCount >= 0, devExt->Self, Irp, urb);

    if (UsbVerify_CheckVerifyFlags(devExt, VERIFY_TRACK_URBS)) {

        PUSB_VERIFY_TRACK_URB           verify;
        PLIST_ENTRY                     entry;
        KIRQL                           irql;
        BOOLEAN                         found = FALSE;

        UsbVerify_LockUrbList(devExt, irql);

        for (entry = devExt->UrbList.Flink;
             entry != &devExt->UrbList;
             entry = entry->Flink) {

            verify = CONTAINING_RECORD(entry, USB_VERIFY_TRACK_URB, Link); 
            if (verify->Irp == Irp) {
                UsbVerify_ASSERT(urb == verify->Urb, devExt->Self, Irp, urb);

                RemoveEntryList(&verify->Link);
                found = TRUE;

                break;
            }
        }

        UsbVerify_UnlockUrbList(devExt, irql);

        if (found) {
            ExFreePool(verify);
        }
        else {
            ULONG urbListLowMemoryCount;
     
            //
            // We go through the troule of assigning the return value to a local 
            // variable so it will be easier to inspect this value in the debugger
            // if we need to view this value
            //
            urbListLowMemoryCount =
                InterlockedDecrement(&devExt->UrbListLowMemoryCount);

            UsbVerify_ASSERT(urbListLowMemoryCount >= 0, devExt->Self, Irp, urb);
        }
    }

    if (UsbVerify_CheckVerifyFlags(devExt, VERIFY_REPLACE_URBS)) {
        if (ARGUMENT_PRESENT(OldUrb)) {
            PUCHAR buffer, bufferEnd;
            

            buffer = (PUCHAR) OldUrb;
            bufferEnd = buffer + urb->UrbHeader.Length;
    
            //
            // Make sure the caller hasn't scribbled on the URB.
            //
            // NTOE:  is there a way for us to mark the memory as READ ONLY?
            //
            for ( ; buffer < bufferEnd; buffer++) {
                UsbVerify_ASSERT(*buffer == USB_VERIFY_FILL,
                                 devExt->Self,
                                 Irp,
                                 OldUrb);
            }
    
            UsbVerify_Print(devExt, PRINT_URB_INFO,
                            ("returning original URB\n"
                             "\t Original URB 0x%x\n"
                             "\t Verify URB   0x%x\n"
                             "\t in IRP 0x%x on device 0x%x\n",
                            OldUrb, urb, Irp, devExt->Self));

            //
            // Copy the contents from our replacement URB into the caller's URB
            //  NOTE: the length field in the urb that we use in this copy
            //      is the calculated expected urb length.  There may
            //      be problems if the client was expecting more data in the
            //      original urb or had not allocated enough space to hold 
            //      everything.
            //

            RtlCopyMemory(OldUrb, urb, urb->UrbHeader.Length);
    
            //
            // We are done with our replacement URB.  Free it and set up urb to
            // point to valid pool.
            //

            ExFreePool(urb);
            urb = OldUrb;
    
            //
            // This is necessary because we are more often than not going to play
            // with this urb after this function call.  The current URB in the IRP
            // has just been freed, so we need to put the old and valid one back
            //
            URB_FROM_IRP(Irp) = OldUrb;
        }
        else {
            ULONG replaceUrbsLowMemoryCount;

            //
            // We go through the troule of assigning the return value to a local 
            // variable so it will be easier to inspect this value in the debugger
            // if we need to view this value
            //
            replaceUrbsLowMemoryCount = 
                InterlockedDecrement(&devExt->ReplaceUrbsLowMemoryCount);

            UsbVerify_ASSERT(replaceUrbsLowMemoryCount >= 0,
                             devExt->Self, Irp, urb);
        }
    }

    if (UsbVerify_CheckVerifyFlags(devExt, VERIFY_TEST_MEMORY)) {
        //
        // NOTE: implement this
        //
        // MmProbeForWrite () ? 
        // ExQueryPoolBlockSize () ?
        // any Mm function to verify the pool?
    }

    //
    // NOTE: should we check anything else on the way back up?  Pipes for instance?
    //
}

VOID
UsbVerify_FreePendingUrbsList(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension 
    )
{
    PUSB_VERIFY_TRACK_URB   verify;
    PLIST_ENTRY             entry;
    ULONG                   urbListCount,
                            urbListLowMemoryCount;
    KIRQL                   irql;

    //
    // We go through the trouble of assigning the return value to a local 
    // variable so it will be easier to inspect this value in the debugger
    // if we need to view this value
    //

    //
    // NOTE: Looks like alot of clients don't cancel any of their pending requests
    //        until after they have the remove device.  Perhaps this should be
    //        guarded by a VerifyFlags (instead of the #if 0) ?
    //
    urbListCount = InterlockedCompareExchange(&DeviceExtension->UrbListCount,
                                              0,
                                              0);

    UsbVerify_ASSERT(urbListCount == 0,
                     DeviceExtension->Self,
                     NULL,
                     NULL);
    
    urbListLowMemoryCount =
        InterlockedCompareExchange(&DeviceExtension->UrbListLowMemoryCount,
                                   0,
                                   0);

    UsbVerify_ASSERT(urbListLowMemoryCount == 0,
                     DeviceExtension->Self,
                     NULL,
                     NULL);

    if (UsbVerify_CheckVerifyFlags(DeviceExtension, VERIFY_TRACK_URBS)) {

        UsbVerify_LockUrbList(DeviceExtension, irql);

        for (entry = DeviceExtension->UrbList.Flink;
             entry != &DeviceExtension->UrbList;
             /* increment handled before we free the struct */ ) {

            verify = CONTAINING_RECORD(entry, USB_VERIFY_TRACK_URB, Link); 

            UsbVerify_ASSERT(verify->Urb != NULL && verify->Irp != NULL,
                             //     "pended URB after remove device",
                             DeviceExtension->Self,
                             verify->Irp,
                             verify->Urb);

            UsbVerify_LogError(IDS_STALE_URB,
                               DeviceExtension,
                               verify->Irp,
                               verify->Urb);

            entry = entry->Flink;

            RemoveEntryList(&verify->Link);
            ExFreePool(verify);
        }

        UsbVerify_UnlockUrbList(DeviceExtension, irql);
    }
}

VOID
UsbVerify_CheckReplacedUrbs(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension 
    )
{
    ULONG replaceUrbsLowMemoryCount;

    PAGED_CODE();

    //
    // We go through the troule of assigning the return value to a local 
    // variable so it will be easier to inspect this value in the debugger
    // if we need to view this value
    //
    replaceUrbsLowMemoryCount
        = InterlockedCompareExchange(&DeviceExtension->ReplaceUrbsLowMemoryCount,
                                     0,
                                     0);

    UsbVerify_ASSERT(replaceUrbsLowMemoryCount == 0,
                     DeviceExtension->Self,
                     NULL,
                     NULL);
}

NTSTATUS
UsbVerify_UrbComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    Sanity check an URB on the way back up    
    
  --*/
{
    PUSB_VERIFY_DEVICE_EXTENSION devExt = GetExtension(DeviceObject);

    UsbVerify_PostVerifyUrb(DeviceObject, Irp);

    UsbVerify_PostProcessUrb(DeviceObject, Irp, (PURB) Context);

    //
    // We are done with the irp, return the status code in the irp so the irp
    // will progress up the stack
    //
    UsbVerify_Print(devExt, PRINT_URB_NOISE,
                    ("UrbComplete, returning 0x%x\n", Irp->IoStatus.Status));

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // the IO completion code looks for STATUS_MORE_PROCESSING_REQUIRED, so any
    // other value will do (don't waste valuable cycles dereffing
    // Irp->IoStatus.Status)
    //
    return STATUS_SUCCESS;
}

NTSTATUS
UsbVerify_SendUrbSynchronously(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension, 
    PIRP Irp,
    PURB OldUrb
    )
{
    KEVENT      event;
    NTSTATUS    status;

    IoCopyCurrentIrpStackLocationToNext(Irp);
    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE
                      );

    //
    // Don't use UsbVerify_UrbComplete because its context must be an PURB, not
    // a PKEVENT
    //
    IoSetCompletionRoutine(Irp,
                           (PIO_COMPLETION_ROUTINE) UsbVerify_Complete, 
                           &event,
                           TRUE,
                           TRUE,
                           TRUE); // No need for Cancel

    status = IoCallDriver(DeviceExtension->TopOfStack, Irp);

    if (STATUS_PENDING == status) {
        KeWaitForSingleObject(
           &event,
           Executive, // Waiting for reason of a driver
           KernelMode, // Waiting in kernel mode
           FALSE, // No allert
           NULL); // No timeout

        status = Irp->IoStatus.Status;
    }

    UsbVerify_PostProcessUrb(DeviceExtension->Self, Irp, OldUrb);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\usbvguid.h ===
#ifndef USBVER_GUID_H
#define USBVER_GUID_H

// {F16328AF-4480-4b18-B028-51301BEB166D}
DEFINE_GUID(GUID_USB_VERIFY, 0xf16328afL, 0x4480, 0x4b18, 0xb0, 0x28, 0x51, 0x30, 0x1b, 0xeb, 0x16, 0x6d );

#endif // USBVER_GUID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\usbverfy.h ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    usbverfy.h

Abstract:

    This module contains the common private declarations for the mouse
    packet filter

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef USBVERIFY_H
#define USBVERIFY_H

#include <wdm.h>
#include <usbioctl.h>
#include <usbdi.h>

#include "str.h"

#define DO_INTERFACE

#define USBVERIFY_POOL_TAG (ULONG) 'vBSU'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, USBVERIFY_POOL_TAG)

#define USB_VERIFY_FILL 0xEA     // 0xFF instead?

#define USB_VERIFY_WIN9X_SERVICE_PATH   L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\USBVer9x"

#if DBG

#define TRAP()                      DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_)       KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)           KeLowerIrql(_x_)

#else   // DBG

#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#endif

// #define USB_VERIFY_NOT_IMPLEMENTED 1 

#define AllocStruct(memtype, type, count) \
    ((type*) ExAllocatePool(memtype, sizeof(type) * count))

typedef enum _USB_VERIFY_STATE {
    Uninitialized = 0,
    Started,
    Stopped,
    SurpriseRemoved,
    Removed
} USB_VERIFY_STATE, *PUSB_VERIFY_STATE;

typedef enum _USB_VERIFY_REMOVAL_CAUSE {
    RemoveSelectConfigZero = 0,
    RemoveSelectConfig,
    RemoveSelectInterface,
    RemoveDeviceRemoved,
    RemoveNewList
} USB_VERIFY_REMOVAL_CAUSE;

#define LOG_PNP                     0x00000001
#define LOG_PIPES                   0x00000010
#define LOG_INTERFACES              0x00000020

// BUGBUG determine which flags we want on by default
#define LOG_FLAGS_DEFAULT           0xFF //  0x0

#define LOG_SIZE_DEFAULT            0x100

// For all pnp log entries:
// Arg0:  -  ,  Arg1:  -
#define LOG_PNP_START               'TRTS'
#define LOG_PNP_STOP                'POTS'
#define LOG_PNP_REMOVE              'vomR'
#define LOG_PNP_SURPRISE_REMOVE     'vmRS'

// Arg0:  PipeHandle, Arg1:  PipeType
#define LOG_PIPE_NEW                'PweN'

// (cont of LOG_PIPE_NEW)
// Arg0:  MaximumPacketSize, Arg1:  UW, Interval; LW, EndpointAddress
#define LOG_PIPE_NEW2               '2PwN'

// (cont of LOG_PIPE_NEW)
// Arg0:  MaximumTranswerSize, Arg1:  PipeFlags
#define LOG_PIPE_NEW3               '3PwN'

// Arg0:  Pipe  ,  Arg1:  USB_VERIFY_REMOVAL_CAUSE 
#define LOG_PIPE_REMOVE             'PmeR'

// Arg0:  InterfaceNumber, Arg1:  AlternateSettting
#define LOG_INTERFACE_NEW           'intN'
#define LOG_INTERFACE_REMOVE        'tniR'

#define LOG
#define LOG_URB_SELECT_CONFIG       'gfcS'
#define LOG_URB_SELECT_INTERFACE    'ftnS'

//
// Verify flags
// 
#define UsbVerify_CheckVerifyFlags(de, f) ((de)->VerifyFlags & (f))

#define VERIFY_TEST_MEMORY          0x00000001
#define VERIFY_PIPES                0x00000002
#define VERIFY_NOT_IMPLEMENTED      0x00000004

#define VERIFY_REPLACE_URBS         0x00000010
#define VERIFY_TRACK_URBS           0x00000020

// BUGBUG  determine what functionality we want on by default
#define VERIFY_FLAGS_DEFAULT        0xFF // 0x0

#define UsbVerify_Print(de, _flags_, _x_) \
            if (!(_flags_)  || (de)->PrintFlags & (_flags_) ) { \
                DbgPrint ("usbverfy:  "); \
                DbgPrint _x_; \
            }

#define PRINT_ALWAYS                 0x00000000

#define PRINT_PIPE_NOISE             0x00000001
#define PRINT_PIPE_TRACE             0x00000002
#define PRINT_PIPE_INFO              0x00000004
#define PRINT_PIPE_ERROR             0x00000008

#define PRINT_URB_NOISE              0x00000010
#define PRINT_URB_TRACE              0x00000020
#define PRINT_URB_INFO               0x00000040
#define PRINT_URB_ERROR              0x00000080

#define PRINT_LIST_NOISE             0x00000100
#define PRINT_LIST_TRACE             0x00000200
#define PRINT_LIST_INFO              0x00000400
#define PRINT_LIST_ERROR             0x00000800

#define PRINT_FLAGS_DEFAULT          (PRINT_PIPE_ERROR | PRINT_URB_ERROR | PRINT_LIST_ERROR) 

typedef enum _USB_VERIFY_LOG_TYPE {
    LogTypeNewPipe,
    LogTypeRemovePipe,
    LogTypePnpEvent
} USB_VERIFY_LOG_TYPE;

typedef struct _USB_VERIFY_LOG_PNP_EVENT {
    UCHAR MinorFunction;
} USB_VERIFY_LOG_PNP_EVENT;

typedef struct _USB_VERIFY_LOG_PIPE {
    USHORT NewPipe; 
    USHORT RemovalCause;
    USBD_PIPE_INFORMATION PipeInfo;
} USB_VERIFY_LOG_PIPE;

typedef struct _USB_VERIFY_LOG_INTERFACE {
    USHORT NewInterface;
    UCHAR Number;
    UCHAR AlternateSetting;
} USB_VERIFY_LOG_INTERFACE;

typedef struct _USB_VERIFY_LOG_ENTRY {

    ULONG Type;

    LARGE_INTEGER CurrentTick;

    union {
        USB_VERIFY_LOG_PNP_EVENT PnpEvent;
        USB_VERIFY_LOG_PIPE Pipe;
        USB_VERIFY_LOG_INTERFACE Interface;
    } u;

} USB_VERIFY_LOG_ENTRY, *PUSB_VERIFY_LOG_ENTRY;

#define ZeroLogEntry(entry) RtlZeroMemory(entry, sizeof(USB_VERIFY_LOG_ENTRY))

//
// The field that are in the first four DWORDs are important.  We want to keep
// the most used fields there b/c when a we run a !dflink, it will print the 
// first 4 DWORDS in the struct (the LINK_ENTRY + 2 DWORDS)
//
typedef struct _USB_VERIFY_TRACK_URB {

    //
    // list entry into the linked list
    //
    LIST_ENTRY Link;

    //
    // Keep Irp and Urb right after Link.  when you run !dflink or !dblink, it
    // will dump the 2 dwords after the LIST_ENTRY structure.
    //

    //
    // The irp we are tracking
    //
    PIRP Irp;

    //
    // The URB contained in the irp.  If we are replacing URBS
    // (VERIFY_REPLACE_URBS is set), then original Urb will be the context for
    // the completion routine (and in the OriginalUrb field below).
    //
    PURB Urb;

    //
    // If we are placing URBs, then this will contain the clients original URB.
    // Otherwise, it is NULL.
    //
    PURB OriginalUrb;

    //
    // Time stamp of when we inserted the irp into our list
    //
    LARGE_INTEGER ArrivalTime;

} USB_VERIFY_TRACK_URB, *PUSB_VERIFY_TRACK_URB;

//
// Assertion based defines
//

#define USB_VERIFY_ASSERT_COUNT 1

typedef struct _USB_VERIFY_ASSERT_NAME
{
    ULONG   Number;           
    PWCHAR  Name;
} USB_VERIFY_ASSERT_NAME, *PUSB_VERIFY_ASSERT_NAME;

typedef ULONG USB_VERIFY_ASSERT_STATE;

typedef USB_VERIFY_ASSERT_STATE USB_VERIFY_ASSERT_TABLE[USB_VERIFY_ASSERT_COUNT];

typedef USB_VERIFY_ASSERT_TABLE *PUSB_VERIFY_ASSERT_TABLE;

typedef struct _USB_VERIFY_DEVICE_EXTENSION
{
    //
    // A backpointer to the device object for which this is the extension
    //
    PDEVICE_OBJECT  Self;

    //
    // "THE PDO"  (ejected by the bus)
    //
    PDEVICE_OBJECT  PDO;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT  TopOfStack;

    //
    // Control over exactly what we verify 
    //
    ULONG VerifyFlags;

    //
    // Control over exactly what we print
    //
    ULONG PrintFlags;

    //
    // Events to log
    //
    ULONG LogFlags;

    PUSB_VERIFY_LOG_ENTRY Log;
 
    ULONG LogSize;

    PUSB_VERIFY_LOG_ENTRY CurrentLogEntry;

    //
    // Lock that synchronizes access to the InterfaceList
    //
    KSPIN_LOCK InterfaceListSpinLock;

    //
    // The actual pipe list, an array of interface pointers (each of which contain
    // an array of pipes)
    //
    PUSBD_INTERFACE_INFORMATION *InterfaceList;

    //
    // Number of items in the InterfaceList which are valid (InUse == TRUE) 
    //
    LONG InterfaceListCount;

    //
    // Total size of the InterfaceList 
    //
    LONG InterfaceListSize;

    ULONG InterfaceListLocked;

    //
    // Lock that synchronizes access to the UrbList
    //
    KSPIN_LOCK UrbListSpinLock;

    //
    // Linked list of URBs (actually, the IRPs that contain them)
    //
    LIST_ENTRY UrbList;

    //
    // Number of URBs in UrbList
    //
    ULONG UrbListCount;

    ULONG UrbListLowMemoryCount;

    ULONG UrbListLocked;

    ULONG ReplaceUrbsLowMemoryCount;

    USBD_CONFIGURATION_HANDLE ValidConfigurationHandle;

    //
    // current power state of the device
    //
    DEVICE_POWER_STATE PowerState;

    //
    // State of the stack and this device object
    //
    USB_VERIFY_STATE VerifyState;

#ifdef DO_INTERFACE
    UNICODE_STRING SymbolicLinkName;
#endif

    //
    // Number of creates sent down
    //
    ULONG EnableCount;

    ULONG TreatWarningsAsErrors;

    //
    // Status of where the take frame control urb has been sent or not
    //
    BOOLEAN HasFrameLengthControl;

    BOOLEAN Initialized;


} USB_VERIFY_DEVICE_EXTENSION, *PUSB_VERIFY_DEVICE_EXTENSION;

#define GetExtension(dev) ((PUSB_VERIFY_DEVICE_EXTENSION) (dev)->DeviceExtension)

#define UsbVerify_InitializeUrbList(de)     InitializeListHead(&(de)->UrbList);

#define UsbVerify_InitializeInterfaceListLock(de) KeInitializeSpinLock(&(de)->InterfaceListSpinLock);
#define UsbVerify_LockInterfaceList(de, irql)     {                                                  \
                                                  KeAcquireSpinLock(&(de)->InterfaceListSpinLock, &irql); \
                                                  (de)->InterfaceListLocked = TRUE;                       \
                                                  }
#define UsbVerify_UnlockInterfaceList(de, irql)   {                                                  \
                                                  (de)->InterfaceListLocked = FALSE;                      \
                                                  KeReleaseSpinLock(&(de)->InterfaceListSpinLock, irql);  \
                                                  }

#define UsbVerify_AssertInterfaceListLocked(de)   \
        UsbVerify_ASSERT((de)->InterfaceListLocked, (de)->Self, NULL, NULL)


#define UsbVerify_InitializeUrbListLock(de)  KeInitializeSpinLock(&(de)->UrbListSpinLock);
#define UsbVerify_LockUrbList(de, irql)      {                                                  \
                                             KeAcquireSpinLock(&(de)->UrbListSpinLock, &irql);  \
                                             (de)->UrbListLocked = TRUE;                        \
                                             }
#define UsbVerify_UnlockUrbList(de, irql)    {                                                  \
                                             (de)->UrbListLocked = FALSE;                       \
                                             KeReleaseSpinLock(&(de)->UrbListSpinLock, irql);  \
                                             }

#define UsbVerify_ASSERT( exp, devObj, irp, urb )                            \
    if (!(exp)) {                                                            \
        static ULONG _UsbVerifyAssertState = 0x0;                            \
        UsbVerify_Assert( #exp, devObj, irp, urb, &_UsbVerifyAssertState);   \
    }                                    
    
#define UsbVerify_ASSERT_MSG( exp, msg, devObj, irp, urb )                   \
    if (!(exp)) {                                                            \
        static ULONG _UsbVerifyAssertState = 0x0;                            \
        UsbVerify_Assert( msg, devObj, irp, urb, &_UsbVerifyAssertState);    \
    }                                    

#define UsbVerify_WARNING( exp, devObj, irp, urb )                           \
    if (!(exp)) {                                                            \
        static ULONG _UsbVerifyWarningState = 0x0;                           \
        UsbVerify_Warning( #exp, devObj, irp, urb, &_UsbVerifyWarningState); \
    }
    
#define UsbVerify_WARNING_MSG( exp, msg, devObj, irp, urb )                  \
    if (!(exp)) {                                                            \
        static ULONG _UsbVerifyWarningState = 0x0;                           \
        UsbVerify_Warning( msg, devObj, irp, urb, &_UsbVerifyWarningState);  \
    }

#define ASSERT_AS_WARNING   0x00000001
#define ASSERT_REMOVED      0x00000010

#define USB_VERIFY_PF_RESETTING     0x10000000
#define USB_VERIFY_PF_ABORTING      0x20000000

//
// Prototypes
//

VOID
UsbVerify_Assert(
    PCHAR Msg,
    PDEVICE_OBJECT DeviceObject,
    PIRP  Irp,
    PURB  Urb,
    PULONG AssertState
    );

VOID
UsbVerify_Warning(
    PCHAR Msg,
    PDEVICE_OBJECT DeviceObject,
    PIRP  Irp,
    PURB  Urb,
    PULONG WarningState
    );

NTSTATUS
UsbVerify_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
UsbVerify_Complete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
UsbVerify_UrbComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
UsbVerify_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UsbVerify_DispatchPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
   
NTSTATUS
UsbVerify_InternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UsbVerify_UsbSubmitUrb(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
UsbVerify_IoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UsbVerify_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UsbVerify_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UsbVerify_Unload (
    IN PDRIVER_OBJECT DriverObject
    );

VOID
UsbVerify_InitLog(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension
    );

VOID
UsbVerify_DestroyLog(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension
    );

VOID 
UsbVerify_Log (
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PUSB_VERIFY_LOG_ENTRY LogEntry
    );

/*
PUNICODE_STRING
UsbVerify_GetRegistryPath(
    PDRIVER_OBJECT DriverObject
    );
*/
#define UsbVerify_GetRegistryPath(DriverObject) \
   (PUNICODE_STRING)IoGetDriverObjectExtension(DriverObject, (PVOID) 1)

NTSTATUS
UsbVerify_QueryKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    );

VOID
UsbVerify_InitializeFromRegistry(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    HANDLE Handle
    );
   
HANDLE
UsbVerify_OpenServiceParameters(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension
    );

VOID
UsbVerify_RemoveDevice(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension
    );

VOID
UsbVerify_StartDevice(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
UsbVerify_SendIrpSynchronously(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
UsbVerify_SendUrbSynchronously(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp,
    PURB OldUrb
    );

VOID
UsbVerify_PostVerifyUrb(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
UsbVerify_PostProcessUrb(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PURB OldUrb
    );

VOID
UsbVerify_PreProcessUrb(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp,
    PURB *OriginalIrb
    );

VOID
UsbVerify_FreePendingUrbsList(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension 
    );

VOID
UsbVerify_CheckReplacedUrbs(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension 
    );

VOID
UsbVerify_LogError(
    ULONG StringIndex,
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp,
    PURB Urb
    );

VOID
UsbVerify_InitializeInterfaceList(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    ULONG NumberOfInterfaces,
    BOOLEAN RemoveOldEntries 
    );

VOID
UsbVerify_InterfaceListAddInterface(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    PUSBD_INTERFACE_INFORMATION NewInterface
    );

VOID
UsbVerify_ClearInterfaceList(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    USB_VERIFY_REMOVAL_CAUSE     Cause
    );

PUSBD_PIPE_INFORMATION
UsbVerify_ValidatePipe(
    PUSB_VERIFY_DEVICE_EXTENSION DeviceExtension,
    USBD_PIPE_HANDLE PipeHandle
    );

#endif  // USBVERIFY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbverfy\sys\usbverfy.c ===
/*--         
Copyright (c) 1998, 1999  Microsoft Corporation

Module Name:

    usbverfy.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/

#include "usbverfy.h"

NTSTATUS DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, UsbVerify_CreateClose)
#pragma alloc_text (PAGE, UsbVerify_Unload)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    PUNICODE_STRING regPath = NULL;
    NTSTATUS        status;
    ULONG           i;

    DbgPrint("Entering USBVerify: Driver Entry\n");

    status = IoAllocateDriverObjectExtension(DriverObject,
                                             (PVOID) 1,
                                             sizeof(UNICODE_STRING),
                                             (PVOID *) &regPath);

    ASSERT(NT_SUCCESS(status));

    if (regPath)
    {

#if WIN95_BUILD
        regPath -> MaximumLength = sizeof(USB_VERIFY_WIN9X_SERVICE_PATH) +
                                    sizeof(UNICODE_NULL);

        regPath -> Length         = sizeof(USB_VERIFY_WIN9X_SERVICE_PATH);
#else
        regPath->MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
        regPath->Length        = RegistryPath->Length;
#endif
        regPath->Buffer = ExAllocatePool(NonPagedPool,
                                         regPath->MaximumLength);    
    
        if (regPath->Buffer) {
            RtlZeroMemory(regPath->Buffer,
                          regPath->MaximumLength);
        
#if WIN95_BUILD
            RtlCopyMemory(regPath->Buffer,
                          USB_VERIFY_WIN9X_SERVICE_PATH,
                          sizeof(USB_VERIFY_WIN9X_SERVICE_PATH));
#else
            RtlMoveMemory(regPath->Buffer,
                          RegistryPath->Buffer,
                          RegistryPath->Length);
#endif
        }
        else {
            regPath->MaximumLength = regPath->Length = 0;
        }
    }

    //
    // Fill in all the dispatch entry points with the pass through function
    // and the explicitly fill in the functions we are going to intercept
    // 

    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = UsbVerify_DispatchPassThrough;
    }

    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE] =        UsbVerify_CreateClose;
    DriverObject->MajorFunction [IRP_MJ_PNP] =          UsbVerify_PnP;
    DriverObject->MajorFunction [IRP_MJ_POWER] =        UsbVerify_Power;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = UsbVerify_IoCtl;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                                        UsbVerify_InternIoCtl;
    //
    // If you are planning on using this function, you must create another
    // device object to send the requests to.  Please see the considerations 
    // comments for UsbVerify_DispatchPassThrough for implementation details.
    //
    // DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = UsbVerify_IoCtl;

    DriverObject->DriverUnload = UsbVerify_Unload;
    DriverObject->DriverExtension->AddDevice = UsbVerify_AddDevice;

    return STATUS_SUCCESS;
}

NTSTATUS
UsbVerify_Complete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:

    Generic completion routine that allows the driver to send the irp down the 
    stack, catch it on the way up, and do more processing at the original IRQL.
    
--*/
{
    PKEVENT             event;

    event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    //
    // We could switch on the major and minor functions of the IRP to perform
    // different functions, but we know that Context is an event that needs
    // to be set.
    //
    KeSetEvent(event, 0, FALSE);

    //
    // Allows the caller to use the IRP after it is completed
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
UsbVerify_CreateClose (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

    Maintain a simple count of the creates and closes sent against this device
    
--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PUSB_VERIFY_DEVICE_EXTENSION   devExt;

    PAGED_CODE();

    devExt = GetExtension(DeviceObject);
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    status = Irp->IoStatus.Status;

    switch (irpStack->MajorFunction) {
    case IRP_MJ_CREATE:
    
        if ( 1 >= InterlockedIncrement(&devExt->EnableCount)) {
            //
            // First time enable here
            //
        }
        else {
            //
            // More than one create was sent down
            //
        }
    
        break;

    case IRP_MJ_CLOSE:

        ASSERT(0 < devExt->EnableCount);
    
        if (0 >= InterlockedDecrement(&devExt->EnableCount)) {
            //
            // successfully closed the device, do any appropriate work here
            //
        }

        break;
    }

    Irp->IoStatus.Status = status;

    //
    // Pass on the create and the close
    //
    return UsbVerify_DispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
UsbVerify_DispatchPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        )
/*++
Routine Description:

    Passes a request on to the lower driver.
     
Considerations:
     
    If you are creating another device object (to communicate with user mode
    via IOCTLs), then this function must act differently based on the intended 
    device object.  If the IRP is being sent to the solitary device object, then
    this function should just complete the IRP (becuase there is no more stack
    locations below it).  If the IRP is being sent to the PnP built stack, then
    the IRP should be passed down the stack. 
    
    These changes must also be propagated to all the other IRP_MJ dispatch
    functions (such as create, close, cleanup, etc.) as well!

--*/
{
    //
    // Pass the IRP to the target
    //
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(GetExtension(DeviceObject)->TopOfStack, Irp);
}           

VOID
UsbVerify_Unload(
   IN PDRIVER_OBJECT DriverObject
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/

{
    PUNICODE_STRING regPath;

    PAGED_CODE();

    ASSERT(NULL == DriverObject->DeviceObject);

    regPath = UsbVerify_GetRegistryPath(DriverObject); 
    if (regPath && regPath->Buffer) {
        ExFreePool(regPath->Buffer);
    }

    DbgPrint("Usbverifier being unloaded!\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\valueadd\local.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    VALIDATE.H

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements the validate lower level filter driver.

Environment:

    Kernel mode

Revision History:

    Feb-97 : created by Kenneth Ray

--*/


#ifndef _VALUEADD_LOCAL_H
#define _VALUEADD_LOCAL_H

#include "usb100.h"
#include "usbdi.h"
#include "usbdlib.h"

#define HIDV_POOL_TAG (ULONG) 'ulaV'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, HIDV_POOL_TAG);
// ExAllocatePool is only called in the descript.c and hidparse.c code.
// all other modules are linked into the user DLL.  They cannot allocate any
// memory.


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect

#if DBG
#define VA_KdPrint(_x_) \
               DbgPrint ("USB_VA: "); \
               DbgPrint _x_;

#define TRAP() DbgBreakPoint()

#else
#define VA_KdPrint(_x_)
#define TRAP()

#endif

#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#define MAX(a,b) (((a) < (b)) ? (b) : (a))

//
// A device extension for the controling device object
//
typedef struct _VA_CONTROL_DATA
{
    LIST_ENTRY          UsbDevices; // A list of the Device device extensions
    ULONG               NumUsbDevices;
    KSPIN_LOCK          Spin; // a sync spin lock for this data.
} VA_CONTROL_DATA, *PVA_CONTROL_DATA;


//
// A device extension for the device object placed into the attachment
// chain.
//

typedef struct _VA_USB_DATA
{
    BOOLEAN             Started; // This device has been started
    BOOLEAN             Removed; // This device has been removed
    UCHAR               Reseved2[2];

    PDEVICE_OBJECT      Self; // a back pointer to the actual DeviceObject
    PDEVICE_OBJECT      PDO; // The PDO to which this filter is attached.
    PDEVICE_OBJECT      TopOfStack; // The top of the device stack just
                                    // beneath this filter device object.
    ULONG               PrintMask;

    LIST_ENTRY          List; // A link point for a list of hid device extensions

    KEVENT              StartEvent; // an event to sync the start IRP.
    KEVENT              RemoveEvent; // an event to synch outstandIO to zero
    ULONG               OutstandingIO; // 1 biased count of reasons why
                                       // this object should stick around

    USB_DEVICE_DESCRIPTOR   DeviceDesc;
    WCHAR                   FriendlyName;

}  VA_USB_DATA, *PVA_USB_DATA;

struct _VA_GLOBALS {
    PDEVICE_OBJECT          ControlObject;
};

extern struct _VA_GLOBALS Global;


//
// Print Masks
//

#define VA_PRINT_COMMAND        0x00000001
#define VA_PRINT_CONTROL        0x00000002
#define VA_PRINT_TRANSFER       0x00000004
#define VA_PRINT_DESCRIPTOR     0x00000008
#define VA_PRINT_FEATURE        0x00000010
#define VA_PRINT_FUNCTION       0x00000020

#define VA_PRINT_BEFORE         0x10000000
#define VA_PRINT_AFTER          0x20000000
#define VA_PRINT_ALL            0x000000FF


NTSTATUS
VA_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_Pass (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_Ioctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_Read (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_Write (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


VOID
VA_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
VA_StartDevice (
    IN PVA_USB_DATA     UsbData,
    IN PIRP             Irp
    );


VOID
VA_StopDevice (
    IN PVA_USB_DATA HidDevice,
    IN BOOLEAN      TouchTheHardware
    );


NTSTATUS
VA_CallUSBD(
    IN PVA_USB_DATA     UsbData,
    IN PURB             Urb,
    IN PIRP             Pirp
    );

NTSTATUS
VA_FilterURB (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\valueadd\valueadd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    validate.c

Abstract: USB lower filter driver

Author:

    Kenneth D. Ray

Environment:

    Kernel mode

Revision History:


--*/
#include <WDM.H>
#include "valueadd.H"
#include "local.h"

struct _VA_GLOBALS Global;


NTSTATUS    DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, VA_CreateClose)
#pragma alloc_text (PAGE, VA_AddDevice)
#pragma alloc_text (PAGE, VA_Unload)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_OBJECT      deviceObject;
    UNICODE_STRING      uniNtNameString;
    UNICODE_STRING      uniWin32NameString;
    PVA_CONTROL_DATA    deviceData;
    ULONG               i;
    PDRIVER_DISPATCH  * dispatch;

    UNREFERENCED_PARAMETER (RegistryPath);

    VA_KdPrint (("Entered the Driver Entry\n"));
    RtlInitUnicodeString (&uniNtNameString, VA_FILTER_NTNAME);

    //
    // Create a controling device object.  All control commands to the
    // filter driver come via IOCTL's to this device object.  It lives
    // for the lifetime of the filter driver.
    //

    status = IoCreateDevice (
                 DriverObject,
                 sizeof (VA_CONTROL_DATA),
                 &uniNtNameString,
                 FILE_DEVICE_UNKNOWN,
                 0,                     // No standard device characteristics
                 FALSE,                 // This isn't an exclusive device
                 &deviceObject
                 );


    if(!NT_SUCCESS (status)) {
        VA_KdPrint (("Couldn't create the device\n"));
        return status;
    }
    //
    // Create W32 symbolic link name
    //
    RtlInitUnicodeString (&uniWin32NameString, VA_FILTER_SYMNAME);
    status = IoCreateSymbolicLink (&uniWin32NameString, &uniNtNameString);

    if (!NT_SUCCESS(status)) {
        VA_KdPrint (("Couldn't create the symbolic link\n"));
        IoDeleteDevice (DriverObject->DeviceObject);
        return status;
    }

    VA_KdPrint (("Initializing\n"));

    deviceData = (PVA_CONTROL_DATA) deviceObject->DeviceExtension;
    InitializeListHead (&deviceData->UsbDevices);
    KeInitializeSpinLock (&deviceData->Spin);
    deviceData->NumUsbDevices = 0;

    Global.ControlObject = deviceObject;

    //
    // Create dispatch points
    //

    for (i=0, dispatch = DriverObject->MajorFunction;
         i <= IRP_MJ_MAXIMUM_FUNCTION;
         i++, dispatch++) {

        *dispatch = VA_Pass;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = VA_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = VA_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = VA_FilterURB;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = VA_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = VA_Power;
    DriverObject->DriverExtension->AddDevice           = VA_AddDevice;
    DriverObject->DriverUnload                         = VA_Unload;

    return status;
}


NTSTATUS
VA_Pass (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The default dispatch routine.  If this filter does not recognize the
    IRP, then it should send it down, unmodified.
    No completion routine is required.

    As we have NO idea which function we are happily passing on, we can make
    NO assumptions about whether or not it will be called at raised IRQL.
    For this reason, this function must be in put into non-paged pool
    (aka the default location).

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PVA_USB_DATA    usbData;
    NTSTATUS        status;

    usbData = (PVA_USB_DATA) DeviceObject->DeviceExtension;

    if(DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    //
    // This IRP was sent to the filter driver.
    // Since we do not know what to do with the IRP, we should pass
    // it on along down the stack.
    //

    InterlockedIncrement (&usbData->OutstandingIO);
    if (usbData->Removed) {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (usbData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
        KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
    }
    return status;
}

NTSTATUS
VA_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Process the Create and close IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status = STATUS_SUCCESS;
    PVA_USB_DATA        usbData;

    PAGED_CODE ();
    TRAP ();

    VA_KdPrint (("Create\n"));

    stack = IoGetCurrentIrpStackLocation (Irp);
    usbData = (PVA_USB_DATA) DeviceObject->DeviceExtension;

    if (DeviceObject == Global.ControlObject) {
        //
        // We allow people to blindly access our control object.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    }
    //
    // Call the next driver in the routine.  We have no value add
    // for start and stop.
    //
    InterlockedIncrement (&usbData->OutstandingIO);

    if (usbData->Removed) {
        status = (IRP_MJ_CREATE == stack->MajorFunction) ?
                    STATUS_DELETE_PENDING:
                    STATUS_SUCCESS; // aka a close

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (usbData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
        KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
    }
    return status;
}

NTSTATUS
VA_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new PDO, for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    DeviceObject - pointer to a device object.

    PhysicalDeviceObject -  pointer to a device object pointer created by the
                            underlying bus driver.

Return Value:

    NT status code.

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PVA_USB_DATA            usbData;
    PVA_CONTROL_DATA        controlData;

#define IS_THIS_OUR_DEVICE(DO) TRUE

    PAGED_CODE ();

    VA_KdPrint (("AddDevice\n"));

    controlData = (PVA_CONTROL_DATA) Global.ControlObject->DeviceExtension;

    //
    // Inquire about this device to see if we really want to filter.
    // Usually this test will not be performed by filter drivers since
    // they will not have registered via INF to load unless they wanted
    // to actually filter the PDO.
    //
    // Remember that you CANNOT send an IRP to the PDO because it has not
    // been started as of yet, but you can make PlugPlay queries to find
    // out things like hardware, compatible ID's, etc.
    // (IoGetDeviceProperty)
    //
    if (!IS_THIS_OUR_DEVICE(deviceObject)) {
        //
        // This is not a device we want to filter.  (Maybe we placed a general
        // entry in the inf file and we are more picky here.)
        //
        // In this case we do not create a device object,
        // and we do not attach.
        //
        // We DO still return status success, otherwise the device node will
        // fail and the device being attached will not function.
        //
        // We must return STATUS_SUCCESS, otherwise this particular device
        // cannot be used by the system
        //

        return STATUS_SUCCESS;
    }

    //
    // Create a filter device object.
    //

    status = IoCreateDevice (DriverObject,
                             sizeof (VA_USB_DATA),
                             NULL, // No Name
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             &deviceObject);
    //
    // It is important that you choose correctly the file type for this
    // device object.  Here we use FILE_DEVICE_UNKNOWN because this is 
    // a generic filter, however as will all filters, the creator needs 
    // to understand to which stack this filter is attaching.  
    // E.G. if you are writing a CD filter driver you need to use
    // FILE_DEVICE_CD_ROM.  IoCreateDevice actually creates device object
    // with different properties dependent on this field.  
    //

    if (!NT_SUCCESS (status)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //
        return status;
    }

    //
    // Initialize the the device extension.
    //
    usbData = (PVA_USB_DATA) deviceObject->DeviceExtension;

    usbData->Started = usbData->Removed = FALSE;
    usbData->Self = deviceObject;
    usbData->PDO = PhysicalDeviceObject;
    usbData->TopOfStack = NULL;
    usbData->PrintMask = VA_PRINT_ALL;
    ExInterlockedInsertHeadList (&controlData->UsbDevices,
                                 &usbData->List,
                                 &controlData->Spin);
    InterlockedIncrement (&controlData->NumUsbDevices);

    KeInitializeEvent(&usbData->RemoveEvent, SynchronizationEvent, FALSE);
    usbData->OutstandingIO = 1; // biassed to 1.  Transition to zero during
                                // remove device means IO is finished.

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    //
    usbData->TopOfStack = IoAttachDeviceToDeviceStack (deviceObject,
                                                       PhysicalDeviceObject);
    //
    // if this attachment fails then top of stack will be null.
    // failure for attachment is an indication of a broken plug play system.
    //
    ASSERT (NULL != usbData->TopOfStack);

    return STATUS_SUCCESS;

#undef IS_THIS_OUR_DEVICE
}



VOID
VA_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    UNICODE_STRING      uniWin32NameString;

    PAGED_CODE ();

    //
    // We should not be unloaded until all the PDOs have been removed from
    // our queue.  The control device object should be the only thing left.
    //
    ASSERT (Global.ControlObject == DriverObject->DeviceObject);
    ASSERT (NULL == Global.ControlObject->NextDevice);
    VA_KdPrint (("unload\n"));

    //
    // Get rid of our control device object.
    //
    RtlInitUnicodeString (&uniWin32NameString, VA_FILTER_SYMNAME);
    IoDeleteSymbolicLink (&uniWin32NameString);
    IoDeleteDevice (DriverObject->DeviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\valueadd\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: USB lower filter driver
    This module contains the plug and play dispatch entries needed for this
    filter.

Author:

    Kenneth D. Ray

Environment:

    Kernel mode

Revision History:


--*/
#include <WDM.H>
#include "local.H"
#include "valueadd.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, VA_Power)
#pragma alloc_text (PAGE, VA_PnP)
#pragma alloc_text (PAGE, VA_StartDevice)
#pragma alloc_text (PAGE, VA_StopDevice)
#pragma alloc_text (PAGE, VA_CallUSBD)
#endif


NTSTATUS
VA_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The power dispatch routine.
    This filter does not recognize power IRPS.  It merely sends them down,
    unmodified to the next device on the attachment stack.

    As this is a POWER irp, and therefore a special irp, special power irp
    handling is required.

    No completion routine is required.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PVA_USB_DATA  usbData;
    NTSTATUS      status;

    PAGED_CODE ();

    TRAP ();

    usbData = (PVA_USB_DATA) DeviceObject->DeviceExtension;

    if (DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }
    //
    // This IRP was sent to the filter driver.
    // Since we do not know what to do with the IRP, we should pass
    // it on along down the stack.
    //

    InterlockedIncrement (&usbData->OutstandingIO);

    if (usbData->Removed) {
        status = STATUS_DELETE_PENDING;
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    } else {
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Power IRPS come synchronously; drivers must call
        // PoStartNextPowerIrp, when they are ready for the next power irp.
        // This can be called here, or in the completetion routine.
        //
        PoStartNextPowerIrp (Irp);

        //
        // NOTE!!! PoCallDriver NOT IoCallDriver.
        //
        status =  PoCallDriver (usbData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
        KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
    }
    return status;
}



NTSTATUS
VA_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );



NTSTATUS
VA_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PVA_USB_DATA        usbData;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    PVA_CONTROL_DATA    controlData;
    KIRQL               oldIrql;

    PAGED_CODE ();

    usbData = (PVA_USB_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if(DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    InterlockedIncrement (&usbData->OutstandingIO);
    if (usbData->Removed) {

        //
        // Someone sent us another plug and play IRP after the remove IRP.
        // This should never happen.
        //
        ASSERT (FALSE);

        if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
            KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
        }
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&usbData->StartEvent, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                VA_PnPComplete,
                                usbData,
                                TRUE,
                                TRUE,
                                TRUE); // No need for Cancel

        status = IoCallDriver (usbData->TopOfStack, Irp);
        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &usbData->StartEvent,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout

            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS (status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            status = VA_StartDevice (usbData, Irp);
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_STOP_DEVICE:
        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //

        //
        // Do what ever
        //

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
        VA_StopDevice (usbData, TRUE);
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (usbData->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has dictacted the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!usbData->Removed);

        //
        // We will no longer receive requests for this device as it has been
        // removed.
        //
        usbData->Removed = TRUE;

        if (usbData->Started) {
            // Stop the device without touching the hardware.
            VA_StopDevice(usbData, FALSE);
        }

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        controlData = (PVA_CONTROL_DATA) Global.ControlObject->DeviceExtension;
        KeAcquireSpinLock (&controlData->Spin, &oldIrql);
        RemoveEntryList (&usbData->List);
        InterlockedDecrement (&controlData->NumUsbDevices);
        KeReleaseSpinLock (&controlData->Spin, oldIrql);

        ASSERT (0 < InterlockedDecrement (&usbData->OutstandingIO));
        if (0 < InterlockedDecrement (&usbData->OutstandingIO)) {
            KeWaitForSingleObject (
                &usbData->RemoveEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }

        //
        // Send on the remove IRP
        //

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (usbData->TopOfStack, Irp);

        IoDetachDevice (usbData->TopOfStack);

        //
        // Clean up memory
        //

        IoDeleteDevice (usbData->Self);
        return STATUS_SUCCESS;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (usbData->TopOfStack, Irp);
        break;
    }


    if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
        KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
    }

    return status;
}


NTSTATUS
VA_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;
    PVA_USB_DATA        usbData;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (DeviceObject);

    status = STATUS_SUCCESS;
    usbData = (PVA_USB_DATA) Context;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    switch (stack->MajorFunction) {
    case IRP_MJ_PNP:

        switch (stack->MinorFunction) {
        case IRP_MN_START_DEVICE:

            KeSetEvent (&usbData->StartEvent, 0, FALSE);

            //
            // Take the IRP back so that we can continue using it during
            // the IRP_MN_START_DEVICE dispatch routine.
            // NB: we will have to call IoCompleteRequest
            //
            return STATUS_MORE_PROCESSING_REQUIRED;

        default:
            break;
        }
        break;

    case IRP_MJ_POWER:
    default:
        break;
    }
    return status;
}

NTSTATUS
VA_StartDevice (
    IN PVA_USB_DATA     UsbData,
    IN PIRP             Irp
    )
/*++

Routine Description:

Arguments:


--*/
{
    NTSTATUS    status;
    PURB        purb;
    struct _URB_CONTROL_DESCRIPTOR_REQUEST  urb;

    PAGED_CODE();

    ASSERT (!UsbData->Removed);
    //
    // The PlugPlay system should not have started a removed device!
    //

    if (UsbData->Started) {
        return STATUS_SUCCESS;
    }

    //
    // Learn about the device
    //

    purb = (PURB) &urb;

    UsbBuildGetDescriptorRequest (purb,
                                  (USHORT) sizeof (urb),
                                  USB_DEVICE_DESCRIPTOR_TYPE,
                                  0, // index
                                  0, // language id
                                  &UsbData->DeviceDesc,
                                  NULL, // no MDL
                                  sizeof (UsbData->DeviceDesc),
                                  NULL); // no linked urbs here

    status = VA_CallUSBD (UsbData, purb, Irp);

    if (!NT_SUCCESS (status)) {
        VA_KdPrint (("Get Device Descriptor failed (%x)\n", status));
        TRAP ();
        goto VA_START_DEVICE_REJECT;
    } else {
        VA_KdPrint (("-------------------------\n"));
        VA_KdPrint (("Device Descriptor = %x, len %x\n",
                         &UsbData->DeviceDesc,
                         urb.TransferBufferLength));

        VA_KdPrint (("USB Device Descriptor:\n"));
        VA_KdPrint (("bLength %d\n", UsbData->DeviceDesc.bLength));
        VA_KdPrint (("bDescriptorType 0x%x\n", UsbData->DeviceDesc.bDescriptorType));
        VA_KdPrint (("bcdUSB 0x%x\n", UsbData->DeviceDesc.bcdUSB));
        VA_KdPrint (("bDeviceClass 0x%x\n", UsbData->DeviceDesc.bDeviceClass));
        VA_KdPrint (("bDeviceSubClass 0x%x\n", UsbData->DeviceDesc.bDeviceSubClass));
        VA_KdPrint (("bDeviceProtocol 0x%x\n", UsbData->DeviceDesc.bDeviceProtocol));
        VA_KdPrint (("bMaxPacketSize0 0x%x\n", UsbData->DeviceDesc.bMaxPacketSize0));
        VA_KdPrint (("idVendor 0x%x\n", UsbData->DeviceDesc.idVendor));
        VA_KdPrint (("idProduct 0x%x\n", UsbData->DeviceDesc.idProduct));
        VA_KdPrint (("bcdDevice 0x%x\n", UsbData->DeviceDesc.bcdDevice));
        VA_KdPrint (("iManufacturer 0x%x\n", UsbData->DeviceDesc.iManufacturer));
        VA_KdPrint (("iProduct 0x%x\n", UsbData->DeviceDesc.iProduct));
        VA_KdPrint (("iSerialNumber 0x%x\n", UsbData->DeviceDesc.iSerialNumber));
        VA_KdPrint (("bNumConfigurations 0x%x\n", UsbData->DeviceDesc.bNumConfigurations));
        VA_KdPrint (("-------------------------\n"));
    }


    return status;

VA_START_DEVICE_REJECT:

//#define CondFree(addr) if ((addr)) ExFreePool ((addr))
//    CondFree(usbData->Ppd);
//#undef CondFree

    return status;
}

VOID
VA_StopDevice (
    IN PVA_USB_DATA UsbData,
    IN BOOLEAN      TouchTheHardware
    )
/*++

Routine Description:
    The PlugPlay system has dictacted the removal of this device.  We have
    no choise but to detach and delete the device objecct.
    (If we wanted to express and interest in preventing this removal,
    we should have filtered the query remove and query stop routines.)

    Note! we might receive a remove WITHOUT first receiving a stop.

Arguments:
    UsbData - The device extension for the usb device being started.
    TouchTheHardware - Can we actually send non PnP irps to this thing?

--*/
{
    TRAP();
    PAGED_CODE ();
    ASSERT (!UsbData->Removed);
    //
    // The PlugPlay system should not have started a removed device!
    //


    if (!UsbData->Started) {
        return;
    }

    if (TouchTheHardware) {
        //
        // Undo any value add thing required to allow this device to actually
        // stop.  If there is some shutdown procedure required, or any
        // settings required for this device before system shutdown or
        // device removal, now is the best time for it.
        //
        ;
    } else {
        //
        // The device is no longer around, so we cannot actually control it.
        // We should instead do what ever necessary in lieu of that.
        //
        ;
    }

    UsbData->Started = FALSE;

    return;
}

NTSTATUS
VA_Complete (
    IN PDEVICE_OBJECT   Device,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*+
Routine Description:
    Get the IRP back

--*/
{
    UNREFERENCED_PARAMETER (Device);
    KeSetEvent ((PKEVENT) Context, 0, FALSE);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
VA_CallUSBD(
    IN PVA_USB_DATA     UsbData,
    IN PURB             Urb,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Synchronously passes a URB to the USBD class driver
    This can only be called at PASSIVE_LEVEL and on a thread where you can
    wait on an event.  (EG a plug play irp)

Arguments:

    DeviceObject - pointer to the device object for this instance of an 82930

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    KEVENT              event;
    PIO_STACK_LOCATION  nextStack;

    PAGED_CODE ();

    VA_KdPrint (("enter VA_CallUSBD\n"));

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(Irp);
    ASSERT(nextStack != NULL);

    //
    // pass the URB to the USB driver stack
    //
    nextStack->Parameters.Others.Argument1 = Urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    IoSetCompletionRoutine (Irp, VA_Complete, &event, TRUE, TRUE, TRUE);

    VA_KdPrint (("calling USBD\n"));

    status = IoCallDriver(UsbData->TopOfStack, Irp);

    VA_KdPrint (("return from IoCallDriver USBD %x\n", status));

    if (STATUS_PENDING == status) {

        VA_KdPrint (("Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        VA_KdPrint (("KeWait (0x%x)\n", status));
    }

    VA_KdPrint (("URB status = %x status = %x irp status %x\n",
                 Urb->UrbHeader.Status, status, Irp->IoStatus.Status));

    return Irp->IoStatus.Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\valueadd\valueadd.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    VALIDATE.H

Abstract:

    This module contains the PUBLIC definitions for the to allow user
    apps to access this filter driver.

Environment:

    Kernel & user mode

Revision History:

    Feb-97 : created by Kenneth Ray

--*/


#ifndef _VALUEADD_H
#define _VALUEADD_H

#define VA_FILTER_NTNAME  L"\\Device\\USB_Valueadd_Driver"
#define VA_FILTER_SYMNAME L"\\DosDevices\\USBValueadd"
#define VA_FILTER_W32Name "\\\\.\\USBValueadd"


#define STIM_CODE(_x_) CTL_CODE(                             \
                           FILE_DEVICE_UNKNOWN,              \
                           (0x800 | _x_),                    \
                           METHOD_BUFFERED,                  \
                           FILE_ANY_ACCESS                   \
                           )

// #define IOCTL_HIDV_      CTL_CODE(1)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\valueadd\usb.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usb.c

Abstract: USB lower filter driver

Author:

    Kenneth D. Ray

Environment:

    Kernel mode

Revision History:


--*/

#include <wdm.h>
#include "valueadd.h"
#include "local.h"
#include "usbdi.h"
#include "usbdlib.h"

VOID
VA_PrintURB (
    IN PURB     Urb,
    IN ULONG    PrintMask
    );

NTSTATUS
VA_FilterURB_Comp (
    IN PDEVICE_OBJECT   Device,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
VA_FilterURB (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The default dispatch routine.  If this filter does not recognize the
    IRP, then it should send it down, unmodified.
    No completion routine is required.

    As we have NO idea which function we are happily passing on, we can make
    NO assumptions about whether or not it will be called at raised IRQL.
    For this reason, this function must be in put into non-paged pool
    (aka the default location).

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PVA_USB_DATA        usbData;
    NTSTATUS            status;
    PIO_STACK_LOCATION  stack;
    PURB                urb;

    stack = IoGetCurrentIrpStackLocation (Irp);
    usbData = (PVA_USB_DATA) DeviceObject->DeviceExtension;

    ASSERT (IRP_MJ_INTERNAL_DEVICE_CONTROL == stack->MajorFunction);

    if(DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    //
    // This IRP was sent to the filter driver.
    // Since we do not know what to do with the IRP, we should pass
    // it on along down the stack.
    //

    InterlockedIncrement (&usbData->OutstandingIO);
    if (usbData->Removed) {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {

        switch (stack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_INTERNAL_USB_SUBMIT_URB:

            urb = stack->Parameters.Others.Argument1;

            if (VA_PRINT_BEFORE & usbData->PrintMask) {
                VA_PrintURB (urb, usbData->PrintMask);
            }

            if (VA_PRINT_AFTER & usbData->PrintMask) {

                //
                // Copy the stack arguments
                //

                IoCopyCurrentIrpStackLocationToNext (Irp);

                //
                // Hook the IRP so that we might print after
                //
                IoSetCompletionRoutine (Irp,
                                        VA_FilterURB_Comp,
                                        usbData,
                                        TRUE,
                                        TRUE,
                                        TRUE);


            } else {
                //
                // Send the IRP on unchanged.
                //
                IoSkipCurrentIrpStackLocation (Irp);
            }

            status = IoCallDriver (usbData->TopOfStack, Irp);
            break;

        default:
            //
            // Send the IRP on unchanged.
            //
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (usbData->TopOfStack, Irp);
            break;
        }

    }

    if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
        KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
    }
    return status;
}

NTSTATUS
VA_FilterURB_Comp (
    IN PDEVICE_OBJECT   Device,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PVA_USB_DATA        usbData;
    PURB                urb;

    UNREFERENCED_PARAMETER (Device);
    urb = IoGetCurrentIrpStackLocation(Irp)->Parameters.Others.Argument1;

    usbData = (PVA_USB_DATA) Context;

    VA_PrintURB (urb, usbData->PrintMask);

    return STATUS_SUCCESS;
}

VOID
VA_PrintURB (
    IN PURB     Urb,
    IN ULONG    PrintMask
    )
/*++

Routine Description:
    Print to the debugger the given Urb

--*/
{
    BOOLEAN     again   = TRUE;
    ULONG       i;

#define HEADER(URB) \
        VA_KdPrint (("URB: Len (%x) Status (%x) Dev Handle (%x) Flags (%x)\n",\
                    URB->UrbHeader.Length, \
                    URB->UrbHeader.Status, \
                    URB->UrbHeader.UsbdDeviceHandle, \
                    URB->UrbHeader.UsbdFlags))

    while (Urb && again) {
        again = FALSE;

        switch (Urb->UrbHeader.Function) {
        case URB_FUNCTION_SELECT_INTERFACE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Select Interface: ConfigHandle (%x) Interface (%x)\n",
                             Urb->UrbSelectInterface.ConfigurationHandle,
                             Urb->UrbSelectInterface.Interface));
            }
            break;

        case URB_FUNCTION_SELECT_CONFIGURATION:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Select Config: Config Desc (%x) Hand (%x) Int (%x)\n",
                             Urb->UrbSelectConfiguration.ConfigurationDescriptor,
                             Urb->UrbSelectConfiguration.ConfigurationHandle,
                             Urb->UrbSelectConfiguration.Interface));
            }
            break;

        case URB_FUNCTION_ABORT_PIPE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Abort Pipe: (%x)\n",
                             Urb->UrbPipeRequest.PipeHandle));
            }
            break;

        case URB_FUNCTION_RESET_PIPE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Reset Pipe: (%x)\n",
                             Urb->UrbPipeRequest.PipeHandle));
            }
            break;

        case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Frame Length Control \n"));
            }
            break;

        case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Release Frame Length Control \n"));
            }
            break;

        case URB_FUNCTION_GET_FRAME_LENGTH:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Frame Length (%x) Num (%x) \n",
                             Urb->UrbGetFrameLength.FrameLength,
                             Urb->UrbGetFrameLength.FrameNumber));
            }
            break;

        case URB_FUNCTION_SET_FRAME_LENGTH:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Set Frame Length Delta (0x%x) \n",
                             Urb->UrbSetFrameLength.FrameLengthDelta));
            }
            break;

        case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Current Frame Number (%x) \n",
                             Urb->UrbGetCurrentFrameNumber.FrameNumber));
            }
            break;

        case URB_FUNCTION_CONTROL_TRANSFER:
            if (PrintMask & VA_PRINT_CONTROL) {
                HEADER(Urb);
                VA_KdPrint (("Control Xfer: Pipe (%x) Flags (%x) "
                             "Len (%x) Buffer (%x) MDL (%x) HCA (%x) "
                             "SetupPacket: %02.02x %02.02x %02.02x %02.02x "
                             "%02.02x %02.02x %02.02x %02.02x\n",
                             Urb->UrbControlTransfer.PipeHandle,
                             Urb->UrbControlTransfer.TransferFlags,
                             Urb->UrbControlTransfer.TransferBufferLength,
                             Urb->UrbControlTransfer.TransferBuffer,
                             Urb->UrbControlTransfer.TransferBufferMDL,
                             &Urb->UrbControlTransfer.hca,
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[0],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[1],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[2],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[3],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[4],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[5],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[6],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[7]));
            }
            Urb = Urb->UrbControlTransfer.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
            if (PrintMask & VA_PRINT_TRANSFER) {
                HEADER(Urb);
                VA_KdPrint (("Bulk | Interrupt Xfer: Pipe (%x) Flags (%x) "
                             "Len (%x) Buffer (%x) MDL (%x) HCA (%x)\n",
                             Urb->UrbBulkOrInterruptTransfer.PipeHandle,
                             Urb->UrbBulkOrInterruptTransfer.TransferFlags,
                             Urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
                             Urb->UrbBulkOrInterruptTransfer.TransferBuffer,
                             Urb->UrbBulkOrInterruptTransfer.TransferBufferMDL,
                             &Urb->UrbControlTransfer.hca));
            }
            Urb = Urb->UrbBulkOrInterruptTransfer.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_ISOCH_TRANSFER:
            if (PrintMask & VA_PRINT_TRANSFER) {
                PUSBD_ISO_PACKET_DESCRIPTOR  packet;

                HEADER(Urb);
                VA_KdPrint (("Isoch Xfer: Pipe (%x) Flags (%x) "
                             "Len (%x) Buffer (%x) MDL (%x) HCA (%x) "
                             "StartFrame (%x) NumPkts (%x) ErrorCount (%x)\n",
                             Urb->UrbIsochronousTransfer.PipeHandle,
                             Urb->UrbIsochronousTransfer.TransferFlags,
                             Urb->UrbIsochronousTransfer.TransferBufferLength,
                             Urb->UrbIsochronousTransfer.TransferBuffer,
                             Urb->UrbIsochronousTransfer.TransferBufferMDL,
                             &Urb->UrbIsochronousTransfer.hca,
                             Urb->UrbIsochronousTransfer.StartFrame,
                             Urb->UrbIsochronousTransfer.NumberOfPackets,
                             Urb->UrbIsochronousTransfer.ErrorCount));

                for (i = 0, packet = &Urb->UrbIsochronousTransfer.IsoPacket[0];
                     i < Urb->UrbIsochronousTransfer.NumberOfPackets;
                     i++, packet++) {

                    VA_KdPrint (("Offset: (%x), Length (%x), Status (%x)\n",
                                 packet->Offset,
                                 packet->Length,
                                 packet->Status));
                }
            }
            break;

        case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                HEADER(Urb);
                VA_KdPrint (("Device Desc: Length (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbControlDescriptorRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                VA_KdPrint (("Endpoint Desc: Length (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbControlDescriptorRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                HEADER(Urb);
                VA_KdPrint (("Interface Desc: Length (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbBulkOrInterruptTransfer.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                HEADER(Urb);
                VA_KdPrint (("SET Device Desc: Length (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbControlDescriptorRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                HEADER(Urb);
                VA_KdPrint (("SET End Desc: Length (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbControlDescriptorRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                HEADER(Urb);
                VA_KdPrint (("SET Intrfc Desc: Len (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbControlDescriptorRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Set Dev Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Set Interface Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Set Endpoint Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_OTHER:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Set Other Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Clear Device Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Clear Interface Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Clear Endpoint Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Clear Other Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;


        case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Device Status: len (%x) Buffer (%x) MDL (%x) "
                             "Index (%x)\n",
                             Urb->UrbControlGetStatusRequest.TransferBufferLength,
                             Urb->UrbControlGetStatusRequest.TransferBuffer,
                             Urb->UrbControlGetStatusRequest.TransferBufferMDL,
                             Urb->UrbControlGetStatusRequest.Index));
            }
            Urb = Urb->UrbControlGetStatusRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Interface Status: len (%x) Buffer (%x) MDL (%x) "
                             "Index (%x)\n",
                             Urb->UrbControlGetStatusRequest.TransferBufferLength,
                             Urb->UrbControlGetStatusRequest.TransferBuffer,
                             Urb->UrbControlGetStatusRequest.TransferBufferMDL,
                             Urb->UrbControlGetStatusRequest.Index));
            }
            Urb = Urb->UrbControlGetStatusRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Endpoint Status: len (%x) Buffer (%x) MDL (%x) "
                             "Index (%x)\n",
                             Urb->UrbControlGetStatusRequest.TransferBufferLength,
                             Urb->UrbControlGetStatusRequest.TransferBuffer,
                             Urb->UrbControlGetStatusRequest.TransferBufferMDL,
                             Urb->UrbControlGetStatusRequest.Index));
            }
            Urb = Urb->UrbControlGetStatusRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_STATUS_FROM_OTHER:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Other Status: len (%x) Buffer (%x) MDL (%x) "
                             "Index (%x)\n",
                             Urb->UrbControlGetStatusRequest.TransferBufferLength,
                             Urb->UrbControlGetStatusRequest.TransferBuffer,
                             Urb->UrbControlGetStatusRequest.TransferBufferMDL,
                             Urb->UrbControlGetStatusRequest.Index));
            }
            Urb = Urb->UrbControlGetStatusRequest.UrbLink;
            again = TRUE;
            break;


        case URB_FUNCTION_VENDOR_DEVICE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Vendor Device Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbBulkOrInterruptTransfer.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_VENDOR_INTERFACE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Vendor Intfc Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_VENDOR_ENDPOINT:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Vendor Endpt Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_VENDOR_OTHER:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Vendor Other Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_DEVICE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Class Device Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_INTERFACE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Class Intface Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_ENDPOINT:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Class Endpnt Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_OTHER:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Class Other Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_CONFIGURATION:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Configuration: len (%x) Buffer (%x) MDL (%x) "
                             "\n",
                             Urb->UrbControlGetConfigurationRequest.TransferBufferLength,
                             Urb->UrbControlGetConfigurationRequest.TransferBuffer,
                             Urb->UrbControlGetConfigurationRequest.TransferBufferMDL));
            }
            Urb = Urb->UrbControlGetConfigurationRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_INTERFACE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Interface: len (%x) Buffer (%x) MDL (%x) "
                             "\n",
                             Urb->UrbControlGetInterfaceRequest.TransferBufferLength,
                             Urb->UrbControlGetInterfaceRequest.TransferBuffer,
                             Urb->UrbControlGetInterfaceRequest.TransferBufferMDL));
            }
            Urb = Urb->UrbControlGetInterfaceRequest.UrbLink;
            again = TRUE;
            break;

        default:
            VA_KdPrint (("WARNING\n", Urb));
            VA_KdPrint (("WARNING Unkown Urb (%x)\n", Urb));
            VA_KdPrint (("WARNING\n", Urb));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\common.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    common.c

Abstract:

    Common code for the Windows CE
    USB Serial Host and Filter drivers

Author:

    Jeff Midkiff (jeffmi)     08-24-99

--*/
#include <stdio.h>

#include "wceusbsh.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWCE0, QueryRegistryParameters)
#pragma alloc_text(PAGEWCE0, CreateDevObjAndSymLink)
#pragma alloc_text(PAGEWCE0, DeleteDevObjAndSymLink)
#pragma alloc_text(PAGEWCE0, IsWin9x)

#pragma alloc_text(PAGEWCE1, LogError)
#endif


NTSTATUS
QueryRegistryParameters(
   IN PUNICODE_STRING RegistryPath
    )
/*++

This routine queryies the Registry for our Parameters key.
We are given the RegistryPath to our driver during DriverEntry,
but don't yet have an extension, so we store the values in globals
until we get our device extension.

The values are setup from our INF.

On WinNT this is under
   HKLM\SYSTEM\ControlSet\Services\wceusbsh\Parameters

On Win98 this is under
   HKLM\System\CurrentControlSet\Services\Class\WCESUSB\000*


Returns - nothing; use defaults

--*/
{
    #define NUM_REG_ENTRIES 6
    RTL_QUERY_REGISTRY_TABLE rtlQueryRegTbl[ NUM_REG_ENTRIES + 1 ];

    ULONG sizeOfUl = sizeof( ULONG );
    ULONG ulAlternateSetting = DEFAULT_ALTERNATE_SETTING;
    LONG  lIntTimout = DEFAULT_INT_PIPE_TIMEOUT;
    ULONG ulMaxPipeErrors = DEFAULT_MAX_PIPE_DEVICE_ERRORS;
    ULONG ulDebugLevel = DBG_OFF;
    ULONG ulExposeComPort = FALSE;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT( RegistryPath != NULL );

    RtlZeroMemory( rtlQueryRegTbl, sizeof(rtlQueryRegTbl) );

    //
    // Setup the query table
    // Note: the 1st table entry is the \Parameters subkey,
    // and the last table entry is NULL
    //
    rtlQueryRegTbl[0].QueryRoutine = NULL;
    rtlQueryRegTbl[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    rtlQueryRegTbl[0].Name = L"Parameters";
    rtlQueryRegTbl[0].EntryContext = NULL;
    rtlQueryRegTbl[0].DefaultType = (ULONG_PTR)NULL;
    rtlQueryRegTbl[0].DefaultData = NULL;
    rtlQueryRegTbl[0].DefaultLength = (ULONG_PTR)NULL;

    rtlQueryRegTbl[1].QueryRoutine = NULL;
    rtlQueryRegTbl[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    rtlQueryRegTbl[1].Name = L"DebugLevel";
    rtlQueryRegTbl[1].EntryContext = &DebugLevel;
    rtlQueryRegTbl[1].DefaultType = REG_DWORD;
    rtlQueryRegTbl[1].DefaultData = &ulDebugLevel;
    rtlQueryRegTbl[1].DefaultLength = sizeOfUl;

    rtlQueryRegTbl[2].QueryRoutine = NULL;
    rtlQueryRegTbl[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    rtlQueryRegTbl[2].Name = L"AlternateSetting";
    rtlQueryRegTbl[2].EntryContext = &g_ulAlternateSetting;
    rtlQueryRegTbl[2].DefaultType = REG_DWORD;
    rtlQueryRegTbl[2].DefaultData = &ulAlternateSetting;
    rtlQueryRegTbl[2].DefaultLength = sizeOfUl;

    rtlQueryRegTbl[3].QueryRoutine = NULL;
    rtlQueryRegTbl[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    rtlQueryRegTbl[3].Name = L"InterruptTimeout";
    rtlQueryRegTbl[3].EntryContext = &g_lIntTimout;
    rtlQueryRegTbl[3].DefaultType = REG_DWORD;
    rtlQueryRegTbl[3].DefaultData = &lIntTimout;
    rtlQueryRegTbl[3].DefaultLength = sizeOfUl;

    rtlQueryRegTbl[4].QueryRoutine = NULL;
    rtlQueryRegTbl[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    rtlQueryRegTbl[4].Name = L"MaxPipeErrors";
    rtlQueryRegTbl[4].EntryContext = &g_ulMaxPipeErrors;
    rtlQueryRegTbl[4].DefaultType = REG_DWORD;
    rtlQueryRegTbl[4].DefaultData = &ulMaxPipeErrors;
    rtlQueryRegTbl[4].DefaultLength = sizeOfUl;

    rtlQueryRegTbl[5].QueryRoutine = NULL;
    rtlQueryRegTbl[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
    rtlQueryRegTbl[5].Name = L"ExposeComPort";
    rtlQueryRegTbl[5].EntryContext = &g_ExposeComPort;
    rtlQueryRegTbl[5].DefaultType = REG_DWORD;
    rtlQueryRegTbl[5].DefaultData = &ulExposeComPort;
    rtlQueryRegTbl[5].DefaultLength = sizeOfUl;

    //
    // query the Registry
    //
    status = RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,  // RelativeTo
                RegistryPath->Buffer,                           // Path
                rtlQueryRegTbl,                                 // QueryTable
                NULL,                                           // Context
                NULL );                                         // Environment

    if ( !NT_SUCCESS( status ) )  {
      //
      // if registry query failed then use defaults
      //
      DbgDump( DBG_INIT,  ("RtlQueryRegistryValues error: 0x%x\n", status) );

      g_ulAlternateSetting = ulAlternateSetting;
      g_lIntTimout = lIntTimout;
      g_ulMaxPipeErrors = ulMaxPipeErrors;
      DebugLevel = DBG_OFF;

    }

   DbgDump( DBG_INIT, ("DebugLevel = 0x%x\n", DebugLevel));

   DbgDump( DBG_INIT, ("AlternateSetting = %d\n", g_ulAlternateSetting));
   DbgDump( DBG_INIT, ("MaxPipeErrors = %d\n", g_ulMaxPipeErrors));
   DbgDump( DBG_INIT, ("INT Timeout = %d\n", g_lIntTimout));

   return status;
}


VOID
ReleaseSlot(
   IN LONG Slot
   )
{
   LONG lNumDevices = InterlockedDecrement(&g_NumDevices);
   UNREFERENCED_PARAMETER( Slot );

   ASSERT( lNumDevices >= 0);

   return;
}


NTSTATUS
AcquireSlot(
   OUT PULONG PSlot
   )
{
   NTSTATUS status = STATUS_SUCCESS;

   *PSlot = InterlockedIncrement(&g_NumDevices);

   if (*PSlot == (ULONG)0) {
      status = STATUS_INVALID_DEVICE_REQUEST;
   }

   return status;
}


NTSTATUS
CreateDevObjAndSymLink(
    IN PDRIVER_OBJECT PDrvObj,
    IN PDEVICE_OBJECT PPDO,
    IN PDEVICE_OBJECT *PpDevObj,
    IN PCHAR PDevName
    )
/*++

Routine Description:

    Creates a named device object and symbolic link
    for the next available device instance. Saves both the \\Device\\PDevName%n
    and \\DosDevices\\PDevName%n in the device extension.

    Also registers our device interface with PnP system.

Arguments:

    PDrvObj - Pointer to our driver object
    PPDO - Pointer to the PDO for the stack to which we should add ourselves
    PDevName - device name to use

Return Value:

    NTSTATUS

--*/
{
   PDEVICE_EXTENSION pDevExt = NULL;
   NTSTATUS status;
   ULONG deviceInstance;
   ULONG bufferLen;
   BOOLEAN gotSlot = FALSE;

   ANSI_STRING asDevName;
   ANSI_STRING asDosDevName;

   UNICODE_STRING usDeviceName = {0}; // seen only in kernel-mode namespace
   UNICODE_STRING usDosDevName = {0}; // seen in user-mode namespace

   CHAR dosDeviceNameBuffer[DOS_NAME_MAX];
   CHAR deviceNameBuffer[DOS_NAME_MAX];

   DbgDump(DBG_INIT, (">CreateDevObjAndSymLink\n"));
   PAGED_CODE();
   ASSERT( PPDO );

   //
   // init the callers device obj
   //
   *PpDevObj = NULL;

   //
   // Get the next device instance number
   //
   status = AcquireSlot(&deviceInstance);
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("AcquireSlot error: 0x%x\n", status));
      goto CreateDeviceObjectError;
   } else {
      gotSlot = TRUE;
   }

   //
   // concat device name & instance number
   //
   ASSERT( *PDevName != (CHAR)NULL);
   sprintf(dosDeviceNameBuffer, "%s%s%03d", "\\DosDevices\\", PDevName,
           deviceInstance);
   sprintf(deviceNameBuffer, "%s%s%03d", "\\Device\\", PDevName,
           deviceInstance);

   // convert names to ANSI string
   RtlInitAnsiString(&asDevName, deviceNameBuffer);
   RtlInitAnsiString(&asDosDevName, dosDeviceNameBuffer);

   usDeviceName.Length = 0;
   usDeviceName.Buffer = NULL;

   usDosDevName.Length = 0;
   usDosDevName.Buffer = NULL;

   //
   // convert names to UNICODE
   //
   status = RtlAnsiStringToUnicodeString(&usDeviceName, &asDevName, TRUE);
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("RtlAnsiStringToUnicodeString error: 0x%x\n", status));
      goto CreateDeviceObjectError;
   }

   status = RtlAnsiStringToUnicodeString(&usDosDevName, &asDosDevName, TRUE);
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("RtlAnsiStringToUnicodeString error: 0x%x\n", status));
      goto CreateDeviceObjectError;
   }

   //
   // create the named devive object
   // Note: we may want to change this to a non-exclusive later
   // so xena to come in without the filter.
   //
   status = IoCreateDevice( PDrvObj,
                            sizeof(DEVICE_EXTENSION),
                            &usDeviceName,
                            FILE_DEVICE_SERIAL_PORT,
                            0,
                            TRUE,       // Note: SerialPorts are exclusive
                            PpDevObj);

   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("IoCreateDevice error: 0x%x\n", status));
      TEST_TRAP();
      goto CreateDeviceObjectError;
   }

   //
   // get pointer to device extension
   //
   pDevExt = (PDEVICE_EXTENSION) (*PpDevObj)->DeviceExtension;

   RtlZeroMemory(pDevExt, sizeof(DEVICE_EXTENSION)); // (redundant)

   //
   // init SERIAL_PORT_INTERFACE
   //
   pDevExt->SerialPort.Type = WCE_SERIAL_PORT_TYPE;

   //
   // create symbolic link
   //
   status = IoCreateUnprotectedSymbolicLink(&usDosDevName, &usDeviceName);
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("IoCreateUnprotectedSymbolicLink error: 0x%x\n", status));
      goto CreateDeviceObjectError;
   }

   DbgDump(DBG_INIT, ("SymbolicLink: %ws\n", usDosDevName.Buffer));

   //
   // Make the device visible via a device association as well.
   // The reference string is the eight digit device index
   //
   status = IoRegisterDeviceInterface(
                PPDO,
                (LPGUID)&GUID_WCE_SERIAL_USB,
                NULL,
                &pDevExt->DeviceClassSymbolicName );

   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("IoRegisterDeviceInterface error: 0x%x\n", status));
      pDevExt->DeviceClassSymbolicName.Buffer = NULL;
      goto CreateDeviceObjectError;
   }

   DbgDump(DBG_INIT, ("DeviceClassSymbolicName: %ws\n", pDevExt->DeviceClassSymbolicName.Buffer));

   //
   // save the Dos Device link name in our extension
   //
   strcpy(pDevExt->DosDeviceName, dosDeviceNameBuffer);

   pDevExt->SymbolicLink = TRUE;


   //
   // save (kernel) device name in extension
   //
   bufferLen = RtlAnsiStringToUnicodeSize(&asDevName);

   pDevExt->DeviceName.Length = 0;
   pDevExt->DeviceName.MaximumLength = (USHORT)bufferLen;

   pDevExt->DeviceName.Buffer = ExAllocatePool(PagedPool, bufferLen);
   if (pDevExt->DeviceName.Buffer == NULL) {
      //
      // Skip out.  We have worse problems than missing
      // the name if we have no memory at this point.
      //
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("CreateDevObjAndSymLink ERROR: 0x%x\n", status));
      goto CreateDeviceObjectError;
   }

   RtlAnsiStringToUnicodeString(&pDevExt->DeviceName, &asDevName, FALSE);
   // save 1's based device instance number
   pDevExt->SerialPort.Com.Instance = deviceInstance;

CreateDeviceObjectError:;

   //
   // free Unicode strings
   //
   RtlFreeUnicodeString(&usDeviceName);
   RtlFreeUnicodeString(&usDosDevName);

   //
   // Delete the devobj if there was an error
   //
   if (status != STATUS_SUCCESS) {

      if ( *PpDevObj ) {

         DeleteDevObjAndSymLink( *PpDevObj );

         *PpDevObj = NULL;

      }

      if (gotSlot) {
         ReleaseSlot(deviceInstance);
      }
   }

   DbgDump(DBG_INIT, ("<CreateDevObjAndSymLink 0x%x\n", status));

   return status;
}



NTSTATUS
DeleteDevObjAndSymLink(
   IN PDEVICE_OBJECT PDevObj
   )
{
   PDEVICE_EXTENSION pDevExt;
   UNICODE_STRING    usDevLink;
   ANSI_STRING       asDevLink;
   NTSTATUS          NtStatus = STATUS_SUCCESS;

   DbgDump(DBG_INIT, (">DeleteDevObjAndSymLink\n"));
   PAGED_CODE();
   ASSERT( PDevObj );

   pDevExt = (PDEVICE_EXTENSION) PDevObj->DeviceExtension;
   ASSERT( pDevExt );

   // get rid of the symbolic link
   if ( pDevExt->SymbolicLink ) {

      RtlInitAnsiString( &asDevLink, pDevExt->DosDeviceName );

      NtStatus = RtlAnsiStringToUnicodeString( &usDevLink,
                                              &asDevLink, TRUE);

      ASSERT(STATUS_SUCCESS == NtStatus);
      NtStatus = IoDeleteSymbolicLink(&usDevLink);

   }

    if (pDevExt->DeviceClassSymbolicName.Buffer)
    {
        NtStatus = IoSetDeviceInterfaceState(&pDevExt->DeviceClassSymbolicName, FALSE);
        if (NT_SUCCESS(NtStatus)) {
            DbgDump(DBG_WRN, ("IoSetDeviceInterfaceState.3: OFF\n"));
        }

        ExFreePool( pDevExt->DeviceClassSymbolicName.Buffer );
        pDevExt->DeviceClassSymbolicName.Buffer = NULL;
   }

   if (pDevExt->DeviceName.Buffer != NULL) {
      ExFreePool(pDevExt->DeviceName.Buffer);
      RtlInitUnicodeString(&pDevExt->DeviceName, NULL);
   }

   //
   // Wait to do this untill here as this triggers the unload routine
   // at which point everything better have been deallocated
   //
   IoDeleteDevice( PDevObj );

   DbgDump(DBG_INIT, ("<DeleteDevObjAndSymLink\n"));

   return NtStatus;
}

#if 0

VOID
SetBooleanLocked(
   IN OUT PBOOLEAN PDest,
   IN BOOLEAN      Src,
   IN PKSPIN_LOCK  PSpinLock
   )
/*++

Routine Description:

    This function is used to assign a BOOLEAN value with spinlock protection.

Arguments:

    PDest - A pointer to Lval.

    Src - Rval.

    PSpinLock - Pointer to the spin lock we should hold.

Return Value:

    None.

--*/
{
  KIRQL tmpIrql;

  KeAcquireSpinLock(PSpinLock, &tmpIrql);
  *PDest = Src;
  KeReleaseSpinLock(PSpinLock, tmpIrql);
}
#endif


VOID
SetPVoidLocked(
   IN OUT PVOID *PDest,
   IN OUT PVOID Src,
   IN PKSPIN_LOCK PSpinLock
   )
{
  KIRQL tmpIrql;

  KeAcquireSpinLock(PSpinLock, &tmpIrql);
  *PDest = Src;
  KeReleaseSpinLock(PSpinLock, tmpIrql);
}


//
// Note: had to use ExWorkItems to be binary compatible with Win98.
// The WorkerRoutine must take as it's only parameter a PWCE_WORK_ITEM
// and extract any parameters. When the WorkerRoutine is complete is MUST
// call DequeueWorkItem to free it back to the worker pool & signal any waiters.
//
NTSTATUS
QueueWorkItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PWCE_WORKER_THREAD_ROUTINE WorkerRoutine,
   IN PVOID Context,
   IN ULONG Flags
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_INVALID_PARAMETER;
   PWCE_WORK_ITEM pWorkItem;
   KIRQL irql;

   DbgDump(DBG_WORK_ITEMS, (">QueueWorkItem\n" ));

   //
   // N.B: you need to ensure your driver does not queue anything when it is stopped.
   //
   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   if ( !CanAcceptIoRequests(PDevObj, FALSE, TRUE) ) {

      status = STATUS_DELETE_PENDING;
      DbgDump(DBG_ERR, ("QueueWorkItem: 0x%x\n", status));

   } else if ( PDevObj && WorkerRoutine ) {

      pWorkItem = ExAllocateFromNPagedLookasideList( &pDevExt->WorkItemPool );

      if ( pWorkItem ) {

         status = AcquireRemoveLock(&pDevExt->RemoveLock, pWorkItem);
         if ( !NT_SUCCESS(status) ) {
             DbgDump(DBG_ERR, ("QueueWorkItem: 0x%x\n", status));
             TEST_TRAP();
             ExFreeToNPagedLookasideList( &pDevExt->WorkItemPool, pWorkItem );
             KeReleaseSpinLock(&pDevExt->ControlLock, irql);
             return status;
         }

         RtlZeroMemory( pWorkItem, sizeof(*pWorkItem) );

         // bump the pending count
         InterlockedIncrement(&pDevExt->PendingWorkItemsCount);

         DbgDump(DBG_WORK_ITEMS, ("PendingWorkItemsCount: %d\n", pDevExt->PendingWorkItemsCount));

         //
         // put the worker on our pending list
         //
         InsertTailList(&pDevExt->PendingWorkItems,
                        &pWorkItem->ListEntry );

         //
         // store parameters
         //
         pWorkItem->DeviceObject = PDevObj;
         pWorkItem->Context = Context;
         pWorkItem->Flags = Flags;

         ExInitializeWorkItem( &pWorkItem->Item,
                               (PWORKER_THREAD_ROUTINE)WorkerRoutine,
                               (PVOID)pWorkItem // Context passed to WorkerRoutine
                              );

         // finally, queue the worker
         ExQueueWorkItem( &pWorkItem->Item,
                          CriticalWorkQueue );

         status = STATUS_SUCCESS;

      } else {
         status = STATUS_INSUFFICIENT_RESOURCES;
         DbgDump(DBG_ERR, ("AllocateWorkItem failed!\n"));
         TEST_TRAP()
      }
   }

   KeReleaseSpinLock(&pDevExt->ControlLock, irql);

   DbgDump(DBG_WORK_ITEMS, ("<QueueWorkItem 0x%x\n", status ));

   return status;
}


VOID
DequeueWorkItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PWCE_WORK_ITEM PWorkItem
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   KIRQL irql;

   DbgDump(DBG_WORK_ITEMS, (">DequeueWorkItem\n" ));

   //
   // remove the worker from the pending list
   //
   KeAcquireSpinLock( &pDevExt->ControlLock,  &irql );

   RemoveEntryList( &PWorkItem->ListEntry );

   KeReleaseSpinLock( &pDevExt->ControlLock, irql);

   //
   // free the worker back to pool
   //
   ExFreeToNPagedLookasideList( &pDevExt->WorkItemPool, PWorkItem );

   //
   // signal event if this is the last one
   //
   if (0 == InterlockedDecrement( &pDevExt->PendingWorkItemsCount) ) {
      DbgDump(DBG_WORK_ITEMS, ("PendingWorkItemsEvent signalled\n" ));
      KeSetEvent( &pDevExt->PendingWorkItemsEvent, IO_NO_INCREMENT, FALSE);
   }
   DbgDump(DBG_WORK_ITEMS, ("PendingWorkItemsCount: %d\n", pDevExt->PendingWorkItemsCount));
   ASSERT(pDevExt->PendingWorkItemsCount >= 0);

   ReleaseRemoveLock(&pDevExt->RemoveLock, PWorkItem);

   DbgDump(DBG_WORK_ITEMS, ("<DequeueWorkItem\n" ));

   return;
}


#pragma warning( push )
#pragma warning( disable : 4706 ) // assignment w/i conditional expression
NTSTATUS
WaitForPendingItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PKEVENT PPendingEvent,
   IN PULONG  PPendingCount
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   LARGE_INTEGER  timeOut = {0,0};
   LONG itemsLeft;
   NTSTATUS status = STATUS_SUCCESS;

   DbgDump(DBG_PNP, (">WaitForPendingItem\n"));

   if ( !PDevObj || !PPendingEvent || !PPendingCount ) {

      status = STATUS_INVALID_PARAMETER;
      DbgDump(DBG_ERR, ("WaitForPendingItem: STATUS_INVALID_PARAMETER\n"));
      TEST_TRAP();

   } else {

      //
      // wait for pending item to signal it's complete
      //
      while ( itemsLeft = InterlockedExchange( PPendingCount, *PPendingCount) ) {

         DbgDump(DBG_PNP|DBG_EVENTS, ("Pending Items Remain: %d\n", itemsLeft ) );

         timeOut.QuadPart = MILLISEC_TO_100NANOSEC( DEFAULT_PENDING_TIMEOUT );

         DbgDump(DBG_PNP|DBG_EVENTS, ("Waiting for %d msec...\n", timeOut.QuadPart/10000));

         PAGED_CODE();

         KeWaitForSingleObject( PPendingEvent,
                                Executive,
                                KernelMode,
                                FALSE,
                                &timeOut );

      }

      DbgDump(DBG_PNP, ("Pending Items: %d\n", itemsLeft ) );
   }

   DbgDump(DBG_PNP, ("<WaitForPendingItem (0x%x)\n", status));

   return status;
}
#pragma warning( pop )


BOOLEAN
CanAcceptIoRequests(
   IN PDEVICE_OBJECT DeviceObject,
   IN BOOLEAN        AcquireLock,
   IN BOOLEAN        CheckOpened
   )
/*++

Routine Description:

  Check device extension status flags.
  Can NOT accept a new I/O request if device:
      1) is removed,
      2) has never been started,
      3) is stopped,
      4) has a remove request pending, or
      5) has a stop device pending

  ** Called with the SpinLock held, else AcquireLock should be TRUE **

Arguments:

    DeviceObject - pointer to the device object
    AcquireLock  - if TRUE then we need to acquire the lock
    CheckOpened  - normally set to TRUE during I/O.
                   Special cases where FALSE include:
                   IRP_MN_QUERY_PNP_DEVICE_STATE
                   IRP_MJ_CREATE

Return Value:

    TRUE/FALSE

--*/
{
    PDEVICE_EXTENSION pDevExt = DeviceObject->DeviceExtension;
    BOOLEAN bRc = FALSE;
    KIRQL   irql;

    if (AcquireLock) {
        KeAcquireSpinLock(&pDevExt->ControlLock, &irql);
    }

    if ( !InterlockedCompareExchange(&pDevExt->DeviceRemoved, FALSE, FALSE) &&
          InterlockedCompareExchange(&pDevExt->AcceptingRequests, TRUE, TRUE) &&
          InterlockedCompareExchange((PULONG)&pDevExt->PnPState, PnPStateStarted, PnPStateStarted) &&
          (CheckOpened ? InterlockedCompareExchange(&pDevExt->DeviceOpened, TRUE, TRUE) : TRUE)
       )
    {
        bRc = TRUE;
    }
#if defined(DBG)
    else DbgDump(DBG_WRN|DBG_PNP, ("CanAcceptIoRequests = FALSE\n"));
#endif

    if (AcquireLock) {
        KeReleaseSpinLock(&pDevExt->ControlLock, irql);
    }

    return bRc;
}


BOOLEAN
IsWin9x(
   VOID
   )
/*++

Routine Description:

    Determine whether or not we are running on Win9x (vs. NT).

Arguments:


Return Value:

    TRUE iff we're running on Win9x.

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING keyName;
    HANDLE hKey;
    NTSTATUS status;
    BOOLEAN result;

    PAGED_CODE();

    /*
     *  Try to open the COM Name Arbiter, which exists only on NT.
     */
    RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
    InitializeObjectAttributes( &objectAttributes,
                                &keyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                (PSECURITY_DESCRIPTOR)NULL);

    status = ZwOpenKey(&hKey, KEY_QUERY_VALUE, &objectAttributes);
    if (NT_SUCCESS(status)){
        status = ZwClose(hKey);
        ASSERT(NT_SUCCESS(status));
        result = FALSE;
    }
    else {
        result = TRUE;
    }

    return result;
}



VOID
LogError(
   IN PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT DeviceObject OPTIONAL,
   IN ULONG SequenceNumber,
   IN UCHAR MajorFunctionCode,
   IN UCHAR RetryCount,
   IN ULONG UniqueErrorValue,
   IN NTSTATUS FinalStatus,
   IN NTSTATUS SpecificIOStatus,
   IN ULONG LengthOfInsert1,
   IN PWCHAR Insert1,
   IN ULONG LengthOfInsert2,
   IN PWCHAR Insert2
   )

/*++

Routine Description:

    Stolen from serial.sys

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    None.

--*/

{
   PIO_ERROR_LOG_PACKET errorLogEntry;

   PVOID objectToUse = NULL;
   SHORT dumpToAllocate = 0;
   PUCHAR ptrToFirstInsert = NULL;
   PUCHAR ptrToSecondInsert = NULL;

   PAGED_CODE();

   DbgDump(DBG_ERR, (">LogError\n"));

   if (Insert1 == NULL) {
      LengthOfInsert1 = 0;
   }

   if (Insert2 == NULL) {
      LengthOfInsert2 = 0;
   }

   if (ARGUMENT_PRESENT(DeviceObject)) {

      objectToUse = DeviceObject;

   } else if (ARGUMENT_PRESENT(DriverObject)) {

      objectToUse = DriverObject;

   }

   errorLogEntry = IoAllocateErrorLogEntry(
                                          objectToUse,
                                          (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                                  dumpToAllocate
                                                  + LengthOfInsert1 +
                                                  LengthOfInsert2)
                                          );

   if ( errorLogEntry != NULL ) {

      errorLogEntry->ErrorCode = SpecificIOStatus;
      errorLogEntry->SequenceNumber = SequenceNumber;
      errorLogEntry->MajorFunctionCode = MajorFunctionCode;
      errorLogEntry->RetryCount = RetryCount;
      errorLogEntry->UniqueErrorValue = UniqueErrorValue;
      errorLogEntry->FinalStatus = FinalStatus;
      errorLogEntry->DumpDataSize = dumpToAllocate;
         ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

      ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

      if (LengthOfInsert1) {

         errorLogEntry->NumberOfStrings = 1;
         errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                (PUCHAR)errorLogEntry);
         RtlCopyMemory(
                      ptrToFirstInsert,
                      Insert1,
                      LengthOfInsert1
                      );

         if (LengthOfInsert2) {

            errorLogEntry->NumberOfStrings = 2;
            RtlCopyMemory(
                         ptrToSecondInsert,
                         Insert2,
                         LengthOfInsert2
                         );

         }

      }

      IoWriteErrorLogEntry(errorLogEntry);

   }

   DbgDump(DBG_ERR, ("<LogError\n"));
   return;
}


#if defined(DBG)
PCHAR
PnPMinorFunctionString (
   UCHAR MinorFunction
   )
{
    switch (MinorFunction) {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        default:
            return ((PCHAR)("unknown IRP_MN_ 0x%x\n", MinorFunction));
    }
}
#endif

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\comport.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    COMPORT.C

Abstract:

   Most of this code was liberated from posusb.sys

Author:

    Jeff Midkiff (jeffmi)     08-24-99

-- */

#include "wceusbsh.h"

void NumToDecString(PWCHAR String, USHORT Number, USHORT stringLen);
LONG MyLog(ULONG base, ULONG num);
PVOID MemDup(PVOID dataPtr, ULONG length);
LONG WStrNCmpI(PWCHAR s1, PWCHAR s2, ULONG n);
ULONG LAtoD(PWCHAR string);


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWCE0, GetFreeComPortNumber)
#pragma alloc_text(PAGEWCE0, ReleaseCOMPort)
#pragma alloc_text(PAGEWCE0, DoSerialPortNaming)
#pragma alloc_text(PAGEWCE0, UndoSerialPortNaming)
#pragma alloc_text(PAGEWCE0, NumToDecString)
#pragma alloc_text(PAGEWCE0, MyLog)
#pragma alloc_text(PAGEWCE0, MemDup)
#pragma alloc_text(PAGEWCE0, WStrNCmpI)
#pragma alloc_text(PAGEWCE0, LAtoD)
#endif


LONG 
GetFreeComPortNumber(
   VOID
   )
/*++

Routine Description:

    Find the index of the next unused serial COM port name in the system
    (e.g. COM3, COM4, etc).

Arguments:


Return Value:

    Return COM port number or -1 if unsuccessful.

--*/

{
    LONG comNumber = -1;

    DbgDump(DBG_INIT, (">GetFreeComPortNumber\n"));
    PAGED_CODE();
    
    if (g_isWin9x){
        /*
         *  Windows 98
         *      Find the first unused name under Hardware\DeviceMap\SerialComm.
         *
         *      BUGBUG:
         *          This algorithm does not find all the COM ports reserved
         *          by modems.  May want to port tomgreen's AllocateCommPort
         *          function from \faulty\Wdm10\usb\driver\ccport\utils.c
         */
        HANDLE hKey;
        UNICODE_STRING keyName;
        NTSTATUS status;
        OBJECT_ATTRIBUTES objectAttributes;

        RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\Hardware\\DeviceMap\\SerialComm");
        
       InitializeObjectAttributes( &objectAttributes,
                                    &keyName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,               
                                    (PSECURITY_DESCRIPTOR)NULL);

        status = ZwOpenKey(&hKey, KEY_QUERY_VALUE | KEY_SET_VALUE, &objectAttributes);
        
       if (NT_SUCCESS(status)){
            #define MAX_COMPORT_NAME_LEN (sizeof("COMxxxx")-1)
            UCHAR keyValueBytes[sizeof(KEY_VALUE_FULL_INFORMATION)+(MAX_COMPORT_NAME_LEN+1)*sizeof(WCHAR)+sizeof(ULONG)];
            PKEY_VALUE_FULL_INFORMATION keyValueInfo = (PKEY_VALUE_FULL_INFORMATION)keyValueBytes;
            ULONG i, actualLen;
            ULONG keyIndex = 0;

            /*
             *  This bitmask represents the used COM ports.
             *  Bit i set indicates com port i+1 is reserved.
             *  Initialize with COM1 and COM2 reserved.
             *
             *  BUGBUG - only works for up to 32 ports.
             */
            ULONG comNameMask = 3;

            do {
                status = ZwEnumerateValueKey(
                            hKey,
                            keyIndex++,
                            KeyValueFullInformation,
                            keyValueInfo,
                            sizeof(keyValueBytes),
                            &actualLen); 
                if (NT_SUCCESS(status)){
                    if (keyValueInfo->Type == REG_SZ){
                        PWCHAR valuePtr = (PWCHAR)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset);
                        if (!WStrNCmpI(valuePtr, L"COM", 3)){
                            /*
                             *  valuePtr+3 points the index portion of the COMx string,
                             *  but we can't call LAtoD on it because it is
                             *  NOT NULL-TERMINATED.
                             *  So copy the index into our own buffer, 
                             *  null-terminate that, 
                             *  and call LAtoD to get the numerical index.
                             */
                            WCHAR comPortIndexString[4+1];
                            ULONG thisComNumber;
                            for (i = 0; (i < 4) && (i < keyValueInfo->DataLength/sizeof(WCHAR)); i++){
                                comPortIndexString[i] = valuePtr[3+i];
                            }
                            comPortIndexString[i] = UNICODE_NULL;

                            thisComNumber = LAtoD(comPortIndexString);
                            if (thisComNumber == 0){
                                ASSERT(thisComNumber != 0);
                            }
                            else if (thisComNumber <= sizeof(ULONG)*8){
                                comNameMask |= 1 << (thisComNumber-1);
                            }
                            else {
                                ASSERT(thisComNumber <= sizeof(ULONG)*8);
                            }
                        }
                    }
                }
            } while (NT_SUCCESS(status));

            /*
             *  First clear bit in comNameMask represents the first available COM name.
             */
            for (i = 0; i < sizeof(ULONG)*8; i++){
                if (!(comNameMask & (1 << i))){
                    WCHAR comName[] = L"COMxxxx";
                    ULONG comNumLen;

                    /*
                     *  Save the COM port number that we're returning.
                     */
                    comNumber = i+1;
                    DbgDump(DBG_INIT, ("GetFreeComPortNumber: got free COM port #%d\n", comNumber));

                    /*
                     *  Write a temporary COMx=COMx holder value to the SERIALCOMM key
                     *  so that no other PDOs get this COM port number.
                     *  This value will get overwritten by <symbolicLinkName=COMx> when the pdo is started.
                     */
                    comNumLen = MyLog(10, comNumber)+1;
                    ASSERT(comNumLen <= 4);
                    NumToDecString(comName+3, (USHORT)comNumber, (USHORT)comNumLen);
                    comName[3+comNumLen] = UNICODE_NULL;
                       
                    status = RtlWriteRegistryValue( RTL_REGISTRY_DEVICEMAP, 
                                                    L"SERIALCOMM",
                                                    comName, 
                                                    REG_SZ,
                                                    comName,
                                                    (3 + comNumLen + 1) * sizeof(WCHAR));

                    ASSERT(NT_SUCCESS(status));

                    break;
                }
            }
        }
        else {
            DbgDump(DBG_ERR, ("GetFreeComPortNumber: ZwOpenKey failed with status 0x%x\n", status));
        }
    }
    else {
    
        /*
         *  Windows NT.  
         *      Use the COM Name Arbiter bitmap.
         */

        HANDLE hKey;
        OBJECT_ATTRIBUTES objectAttributes;
        UNICODE_STRING keyName;
        NTSTATUS status;


        RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
        
       InitializeObjectAttributes( &objectAttributes,
                                    &keyName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,               
                                    (PSECURITY_DESCRIPTOR)NULL);

        status = ZwOpenKey( &hKey,
                            KEY_QUERY_VALUE | KEY_SET_VALUE,
                            &objectAttributes);

        if (NT_SUCCESS(status)){
            UNICODE_STRING valueName;
            PVOID rawData;
            ULONG dataSize;

            RtlInitUnicodeString(&valueName, L"ComDB");

            ASSERT(hKey);

            dataSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION);

            /*
             *  Allocate one extra byte in case we have to add a byte to ComDB
             */
            rawData = ExAllocatePool(NonPagedPool, dataSize+1);

            if (rawData){
                status = ZwQueryValueKey(   hKey, 
                                            &valueName, 
                                            KeyValuePartialInformation,
                                            rawData,
                                            dataSize,
                                            &dataSize);
                if (status == STATUS_BUFFER_OVERFLOW){
                    ExFreePool(rawData);
                    ASSERT(dataSize > FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                    /*
                     *  Allocate one extra byte in case we have to add a byte to ComDB
                     */
                    rawData = ExAllocatePool(NonPagedPool, dataSize+1);
                    if (rawData){
                        status = ZwQueryValueKey(   hKey, 
                                                    &valueName, 
                                                    KeyValuePartialInformation,
                                                    rawData,
                                                    dataSize,
                                                    &dataSize);
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (NT_SUCCESS(status)){
                    PKEY_VALUE_PARTIAL_INFORMATION keyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)rawData;
                    ULONG b, i;
                    BOOLEAN done = FALSE;

                    ASSERT(dataSize >= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
                    
                    ASSERT(keyPartialInfo->Type == REG_BINARY);

                    /*
                     *  The ComDB value is just a bit mask where bit n set indicates
                     *  that COM port # n+1 is taken.
                     *  Get the index of the first unset bit; starting with bit 2 (COM3).
                     */
                    for (b = 0; (b < dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) && !done; b++){
                    
                        for (i = (b == 0) ? 2 : 0; (i < 8) && !done; i++){
                            if (keyPartialInfo->Data[b] & (1 << i)){
                                /*
                                 *  This COM port (#8*b+i+1) is taken, go to the next one.
                                 */
                            }
                            else {
                                /*
                                 *  Found a free COM port.  
                                 *  Write the value back with the new bit set.
                                 *  Only write back the number of bytes we read earlier.
                                 *  Only use this COM port if the write succeeds.
                                 *
                                 *  Note:   careful with the size of the KEY_VALUE_PARTIAL_INFORMATION
                                 *          struct.  Its real size is 0x0D bytes, 
                                 *          but the compiler aligns it to 0x10 bytes.
                                 *          So use FIELD_OFFSET, not sizeof, to determine
                                 *          how many bytes to write.
                                 */
                                keyPartialInfo->Data[b] |= (1 << i);
                                status = ZwSetValueKey( hKey, 
                                                        &valueName,
                                                        0,
                                                        REG_BINARY,
                                                        (PVOID)keyPartialInfo->Data, 
                                                        dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
                                if (NT_SUCCESS(status)){
                                    comNumber = 8*b + i + 1;
                                    DbgDump(DBG_INIT, ("GetFreeComPortNumber: got free COM port #0x%x\n", comNumber));
                                }
                                else {
                                    DbgDump(DBG_ERR, ("GetFreeComPortNumber: ZwSetValueKey failed with 0x%x\n", status));
                                }

                                done = TRUE;
                            }
                        }
                    }

                    if ((b == dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) && !done){
                        /*
                         *  No more available bits in ComDB, so add a byte.
                         */
                        ASSERT(comNumber == -1);
                        ASSERT(b > 0);
                        DbgDump(DBG_WRN, ("ComDB overflow -- adding new byte"));

                        keyPartialInfo->Data[b] = 1;
                        dataSize++;

                        status = ZwSetValueKey( hKey, 
                                                &valueName,
                                                0,
                                                REG_BINARY,
                                                (PVOID)keyPartialInfo->Data, 
                                                dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
                        if (NT_SUCCESS(status)){
                            comNumber = 8*b + 1;
                            DbgDump(DBG_INIT, ("GetFreeComPortNumber: got free COM port #0x%x.", comNumber));
                        }
                        else {
                            DbgDump(DBG_ERR, ("GetFreeComPortNumber: ZwSetValueKey #2 failed with 0x%x.", status));
                        }
                    }

                    ASSERT(comNumber != -1);
                }
                else {
                    DbgDump(DBG_ERR, ("GetFreeComPortNumber: ZwQueryValueKey failed with 0x%x.", status));
                }

                /*
                 *  Check that we didn't fail the second allocation before freeing this buffer.
                 */
                if (rawData){
                    ExFreePool(rawData);
                }
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            status = ZwClose(hKey);
            ASSERT(NT_SUCCESS(status));
        }
        else {
            DbgDump(DBG_ERR, ("GetFreeComPortNumber: ZwOpenKey failed with 0x%x.", status));
        }

    }

    ASSERT(comNumber != -1);

   DbgDump(DBG_INIT, ("<GetFreeComPortNumber\n"));
    
   return comNumber;
}


//
// the only time we want this is when we  uninstall...
//
VOID 
ReleaseCOMPort( 
   LONG comPortNumber
   )
{
    DbgDump(DBG_INIT, (">ReleaseCOMPort: %d\n", comPortNumber));
    PAGED_CODE();
   
    if (g_isWin9x){
        /*
         *  We punt on this for Win9x.  
         *  That's ok since the SERIALCOMM keys are dynamically-generated at each boot,
         *  so if start fails a COM port number will just be unavailable until the next boot.
         */
        DbgDump(DBG_WRN, ("ReleaseCOMPort: not implemented for Win9x\n")); // BUGBUG
    }
    else {

        HANDLE hKey = NULL;
        OBJECT_ATTRIBUTES objectAttributes;
        UNICODE_STRING keyName;
        NTSTATUS status;

        if ( !(comPortNumber > 0)) {
            DbgDump(DBG_ERR, ("ReleaseCOMPort - INVALID_PARAMETER: %d\n", comPortNumber )); // BUGBUG
            return;
        }

        RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
        InitializeObjectAttributes( &objectAttributes,
                                    &keyName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,               
                                    (PSECURITY_DESCRIPTOR)NULL);

        status = ZwOpenKey(&hKey, KEY_QUERY_VALUE | KEY_SET_VALUE, &objectAttributes);
        if (NT_SUCCESS(status)){
            UNICODE_STRING valueName;
            PVOID rawData;
            ULONG dataSize;

            RtlInitUnicodeString(&valueName, L"ComDB");

            ASSERT(hKey);

            dataSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION);
            rawData = ExAllocatePool(NonPagedPool, dataSize);

            if (rawData){
                status = ZwQueryValueKey(   hKey, 
                                            &valueName, 
                                            KeyValuePartialInformation,
                                            rawData,
                                            dataSize,
                                            &dataSize);
                if (status == STATUS_BUFFER_OVERFLOW){
                    ExFreePool(rawData);
                    ASSERT(dataSize > FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                    rawData = ExAllocatePool(NonPagedPool, dataSize);
                    if (rawData){
                        status = ZwQueryValueKey(   hKey, 
                                                    &valueName, 
                                                    KeyValuePartialInformation,
                                                    rawData,
                                                    dataSize,
                                                    &dataSize);
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (NT_SUCCESS(status)){
                    PKEY_VALUE_PARTIAL_INFORMATION keyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)rawData;

                    ASSERT(dataSize > FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                    ASSERT(keyPartialInfo->Type == REG_BINARY);

                    /*
                     *  The ComDB value is just a bit mask where bit n set indicates
                     *  that COM port # n+1 is taken.
                     *  Get the index of the first unset bit; starting with bit 2 (COM3).
                     *
                     *  Note:   careful with the size of the KEY_VALUE_PARTIAL_INFORMATION
                     *          struct.  Its real size is 0x0D bytes, 
                     *          but the compiler aligns it to 0x10 bytes.
                     *          So use FIELD_OFFSET, not sizeof, to determine
                     *          how many bytes to write.
                     */
                    ASSERT(comPortNumber >= 3);
                    if ((comPortNumber > 0) && (comPortNumber <= (LONG)(dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data))*8)){
                        //ASSERT(keyPartialInfo->Data[(comPortNumber-1)/8] & (1 << ((comPortNumber-1) & 7)));
                        keyPartialInfo->Data[(comPortNumber-1)/8] &= ~(1 << ((comPortNumber-1) & 7));
                        status = ZwSetValueKey( hKey, 
                                                &valueName,
                                                0,
                                                REG_BINARY,
                                                (PVOID)keyPartialInfo->Data, 
                                                dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
                        if (NT_SUCCESS(status)){
                            DbgDump(DBG_INIT, ("ReleaseCOMPort: released COM port # 0x%x\n", comPortNumber));
                        }
                        else {
                            DbgDump(DBG_ERR, ("ReleaseCOMPort: ZwSetValueKey failed with 0x%x\n", status));
                        }
                    }
                    else {
                        ASSERT((comPortNumber > 0) && (comPortNumber <= (LONG)(dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data))*8));
                    }
                }
                else {
                    DbgDump(DBG_ERR, ("ReleaseCOMPort: ZwQueryValueKey failed with 0x%x\n", status));
                }

                /*
                 *  Check that we didn't fail the second allocation before freeing this buffer.
                 */
                if (rawData){
                    ExFreePool(rawData);
                }
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            status = ZwClose(hKey);
            ASSERT(NT_SUCCESS(status));
        }
        else {
            DbgDump(DBG_ERR, ("ReleaseCOMPort: ZwOpenKey failed with 0x%x\n", status));
        }
    }
    
    DbgDump(DBG_INIT, ("<ReleaseCOMPort\n"));
    
    return;
}


//
// Note: this is NT specific.
// Win98 is entirely different.
//
NTSTATUS
DoSerialPortNaming(
    IN PDEVICE_EXTENSION PDevExt,
    IN LONG  ComPortNumber
    )
{
   NTSTATUS status;
    PWCHAR pwcComPortName=NULL;
    static WCHAR comNamePrefix[] = L"\\DosDevices\\COM";
    WCHAR buf[sizeof(comNamePrefix)/sizeof(WCHAR) + 4];
    LONG numLen = MyLog(10, ComPortNumber)+1;

   DbgDump(DBG_INIT, (">DoSerialPortNaming %d\n", ComPortNumber));
   PAGED_CODE();

   ASSERT(PDevExt);
   ASSERT((numLen > 0) && (numLen <= 4));
   ASSERT_SERIAL_PORT(PDevExt->SerialPort);

    RtlCopyMemory(buf, comNamePrefix, sizeof(comNamePrefix));

    NumToDecString( buf+sizeof(comNamePrefix)/sizeof(WCHAR)-1, 
                        (USHORT)ComPortNumber,
                        (USHORT)numLen );

    buf[sizeof(comNamePrefix)/sizeof(WCHAR) - 1 + numLen] = UNICODE_NULL;

    pwcComPortName = MemDup(buf, sizeof(buf));

    if (pwcComPortName) {
      //
      // create symbolic link for the SerialPort interface
      // 
        RtlInitUnicodeString( &PDevExt->SerialPort.Com.SerialPortName, pwcComPortName);

      ASSERT( PDevExt->DeviceName.Buffer );
      ASSERT( PDevExt->SerialPort.Com.SerialPortName.Buffer );
        status = IoCreateSymbolicLink( &PDevExt->SerialPort.Com.SerialPortName, &PDevExt->DeviceName );

        if (NT_SUCCESS(status)) {
         //
         // let the system know there is another SERIALCOMM entry under HKLM\DEVICEMAP\SERIALCOMM
         //
            UNICODE_STRING comPortSuffix;

         PDevExt->SerialPort.Com.SerialSymbolicLink = TRUE;

            /*
             *  Create the '\Device\WCEUSBSI000x = COMx' entry 
             */
            RtlInitUnicodeString(&comPortSuffix, PDevExt->SerialPort.Com.SerialPortName.Buffer+(sizeof(L"\\DosDevices\\")-sizeof(WCHAR))/sizeof(WCHAR));
         
         //ASSERT( PDevExt->SerialPort.Com.SerialCOMMname.Buffer );
         status = RtlWriteRegistryValue( RTL_REGISTRY_DEVICEMAP, 
                                         L"SERIALCOMM",
                                         PDevExt->DeviceName.Buffer,
                                         REG_SZ,
                                         comPortSuffix.Buffer,
                                         comPortSuffix.Length + sizeof(WCHAR) );

         if (NT_SUCCESS(status)){

                PDevExt->SerialPort.Com.PortNumber = ComPortNumber;

                if (g_isWin9x){
                    NTSTATUS tmpStatus;

                    /*
                     *  Delete the temporary 'COMx=COMx' holder value we created earlier.
                     */
                    tmpStatus = RtlDeleteRegistryValue( RTL_REGISTRY_DEVICEMAP, 
                                                        L"SERIALCOMM",
                                                        comPortSuffix.Buffer);
                    //ASSERT(NT_SUCCESS(tmpStatus));
#if DBG
                    if ( !NT_SUCCESS(tmpStatus) ) {
                        DbgDump(DBG_WRN, ("RtlDeleteRegistryValue error: 0x%x\n", tmpStatus));
                    }
#endif
                }
         
         } else {

            DbgDump(DBG_ERR, ("RtlWriteRegistryValue error: 0x%x\n", status));

            LogError( NULL,
                   PDevExt->DeviceObject,
                   0, 0, 0, 
                   ERR_SERIALCOMM,
                   status, 
                   SERIAL_REGISTRY_WRITE_FAILED,
                   PDevExt->DeviceName.Length + sizeof(WCHAR),
                   PDevExt->DeviceName.Buffer,
                   0,
                   NULL
                   );

         }

        } else {
         DbgDump(DBG_ERR, ("IoCreateSymbolicLink error: 0x%x\n", status));

         LogError( NULL,
                   PDevExt->DeviceObject,
                   0, 0, 0, 
                   ERR_COMM_SYMLINK,
                   status, 
                   SERIAL_NO_SYMLINK_CREATED,
                   PDevExt->SerialPort.Com.SerialPortName.Length + sizeof(WCHAR),
                   PDevExt->SerialPort.Com.SerialPortName.Buffer,
                   PDevExt->DeviceName.Length + sizeof(WCHAR),
                   PDevExt->DeviceName.Buffer
                   );

         TEST_TRAP();

      }
    
   } else {
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("DoSerialPortNaming error: 0x%x\n", status));
      LogError( NULL,
                PDevExt->DeviceObject,
                0, 0, 0, 
                ERR_COMM_SYMLINK,
                status, 
                SERIAL_INSUFFICIENT_RESOURCES,
                0, NULL, 0, NULL );

    }

   DbgDump(DBG_INIT, ("<DoSerialPortNaming (0x%x)\n", status));
    
   return status;
}



VOID
UndoSerialPortNaming(
   IN PDEVICE_EXTENSION PDevExt
   )
{
   DbgDump(DBG_INIT, (">UndoSerialPortNaming\n"));
   PAGED_CODE();

   ASSERT(PDevExt);
   ASSERT_SERIAL_PORT(PDevExt->SerialPort);

   if (!g_ExposeComPort) {
       DbgDump(DBG_INIT, ("!g_ExposeComPort\n"));
       return;
   }

   // remove our entry from ComDB
   ReleaseCOMPort( PDevExt->SerialPort.Com.PortNumber );

   if (PDevExt->SerialPort.Com.SerialPortName.Buffer && PDevExt->SerialPort.Com.SerialSymbolicLink) {
      IoDeleteSymbolicLink(&PDevExt->SerialPort.Com.SerialPortName);
   }

   if (PDevExt->SerialPort.Com.SerialPortName.Buffer != NULL) {
      ExFreePool(PDevExt->SerialPort.Com.SerialPortName.Buffer);
      RtlInitUnicodeString(&PDevExt->SerialPort.Com.SerialPortName, NULL);
   }

   if (PDevExt->SerialPort.Com.SerialCOMMname.Buffer != NULL) {
      ExFreePool(PDevExt->SerialPort.Com.SerialCOMMname.Buffer);
      RtlInitUnicodeString(&PDevExt->SerialPort.Com.SerialCOMMname, NULL);
   }

   if (PDevExt->DeviceName.Buffer != NULL) {
      RtlDeleteRegistryValue( RTL_REGISTRY_DEVICEMAP, 
                              SERIAL_DEVICE_MAP,
                              PDevExt->DeviceName.Buffer);
      
      ExFreePool(PDevExt->DeviceName.Buffer);
      RtlInitUnicodeString(&PDevExt->DeviceName, NULL);
   }

   DbgDump(DBG_INIT, ("<UndoSerialPortNaming\n"));
}


void NumToDecString(PWCHAR String, USHORT Number, USHORT stringLen)
{
    const static WCHAR map[] = L"0123456789";
    LONG         i      = 0;

    PAGED_CODE();
    ASSERT(stringLen);

    for (i = stringLen-1; i >= 0; i--) {
        String[i] = map[Number % 10];
        Number /= 10;
    }
}


LONG MyLog(ULONG base, ULONG num)
{
    LONG result;
    ASSERT(num);
    
    PAGED_CODE();
    
    for (result = -1; num; result++){
        num /= base;
    }

    return result;
}


PVOID MemDup(PVOID dataPtr, ULONG length)
{
    PVOID newPtr;

    PAGED_CODE();

    newPtr = (PVOID)ExAllocatePool(NonPagedPool, length); // BUGBUG allow paged
    if (newPtr){
        RtlCopyMemory(newPtr, dataPtr, length);
    }
    return newPtr;
}


LONG WStrNCmpI(PWCHAR s1, PWCHAR s2, ULONG n)
{
    ULONG result;
    
    PAGED_CODE();
    
    while (n && *s1 && *s2 && ((*s1|0x20) == (*s2|0x20))){
        s1++, s2++;
        n--;
    }

    if (n){
        result = ((*s1|0x20) > (*s2|0x20)) ? 1 : ((*s1|0x20) < (*s2|0x20)) ? -1 : 0;
    }
    else {
        result = 0;
    }

    return result;
}


ULONG LAtoD(PWCHAR string)
/*++

Routine Description:

      Convert a decimal string (without the '0x' prefix) to a ULONG.

Arguments:

    string - null-terminated wide-char decimal-digit string 
                

Return Value:

    ULONG value

--*/
{
    ULONG i, result = 0;

    PAGED_CODE();

    for (i = 0; string[i]; i++){
        if ((string[i] >= L'0') && (string[i] <= L'9')){
            result *= 10;
            result += (string[i] - L'0');
        }
        else {
            ASSERT(0);
            break;
        }
    }

    return result;
}


#if 0
VOID
NumToHexString(
   PWCHAR String, 
   USHORT Number, 
   USHORT stringLen
   )
{
    const static WCHAR map[] = L"0123456789ABCDEF";
    LONG         i      = 0;

    PAGED_CODE();
    ASSERT(stringLen);

    for (i = stringLen-1; i >= 0; i--) {
        String[i] = map[Number & 0x0F];
        Number >>= 4;
    }
}


LONG 
GetComPort(
   PDEVICE_OBJECT PDevObj,
   ULONG ComInterfaceIndex
   )
/*++

Routine Description:

    Get the serial COM port index for a serial interface we're about to create.
    If this is the first plug-in, call GetFreeComPortNumber to reserve a new
    static COM port for this device and store it in our software key.
    If this is not the first plug-in, it should be sitting in the registry.

   ComInterfaceIndex - is our zero-based device interface index, 0000, 0001, etc.

Arguments:


Return Value:

    Return COM port number or -1 if unsuccessful.

--*/
{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    LONG comNumber = -1;
    NTSTATUS status;
    HANDLE hRegDevice;
    
    DbgDump(DBG_INIT, (">GetComPort\n"));
    PAGED_CODE();

    status = IoOpenDeviceRegistryKey( pDevExt->PDO, 
                                      /*PLUGPLAY_REGKEY_DEVICE,*/ PLUGPLAY_REGKEY_DRIVER, 
                                      KEY_READ, 
                                      &hRegDevice);

    if (NT_SUCCESS(status)){
        UNICODE_STRING keyName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;
        //
        // PLUGPLAY_REGKEY_DEVICE is under HKLM\System\CCS\Enum\USB\ROOT_HUB\4&574193&0
        // PLUGPLAY_REGKEY_DRIVER is under HKLM\System\CCS\Class\{Your_GUID}\000x
        //
        WCHAR interfaceKeyName[] = L"COMPortForInterfaceXXXX";

        NumToHexString( interfaceKeyName+sizeof(interfaceKeyName)/sizeof(WCHAR)-1-4, 
                        (USHORT)ComInterfaceIndex, 
                        4);

        RtlInitUnicodeString(&keyName, interfaceKeyName); 
        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) +
                            keyName.Length*sizeof(WCHAR) +
                            sizeof(ULONG);

        keyValueInfo = ExAllocatePool(PagedPool, keyValueTotalSize);
        
        if (keyValueInfo){
            status = ZwQueryValueKey( hRegDevice,
                                      &keyName,
                                      KeyValueFullInformation,
                                      keyValueInfo,
                                      keyValueTotalSize,
                                      &actualLength); 

            if (NT_SUCCESS(status)){

                ASSERT(keyValueInfo->Type == REG_DWORD);
                ASSERT(keyValueInfo->DataLength == sizeof(ULONG));
                                
                comNumber = (LONG)*((PULONG)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset));
                DbgDump(DBG_INIT, ("GetComPort: read COM port# 0x%x for interface 0x%x from registry\n", (ULONG)comNumber, ComInterfaceIndex));
            }
            else {

                /*
                 *  No COM port number recorded in registry.
                 *  Allocate a new static COM port from the COM name arbiter
                 *  and record it in our software key for the next PnP.
                 */
                comNumber = GetFreeComPortNumber();
                if (comNumber == -1){
                    DbgDump(DBG_ERR, ("GetComPort: GetFreeComPortNumber failed\n"));
                }
                else {
                    status = ZwSetValueKey( hRegDevice,
                                            &keyName,
                                            0,
                                            REG_DWORD,
                                            &comNumber,
                                            sizeof(ULONG));
                    if (!NT_SUCCESS(status)){
                        DbgDump(DBG_ERR, ("GetComPort: ZwSetValueKey failed with status 0x%x\n", status));
                    }
                }
            }

            ExFreePool(keyValueInfo);
        }
        else {
            ASSERT(keyValueInfo);
        }

        ZwClose(hRegDevice);
    }
    else {
        DbgDump(DBG_ERR, ("GetComPort: IoOpenDeviceRegistryKey failed with 0x%x\n", status));
    }

   DbgDump(DBG_INIT, ("<GetComPort %d\n", comNumber));
   
   return comNumber;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\perf.c ===
/* Copyright (c) 1999-2000 Microsoft Corporation */
///======================================================================
// 
// Perf.c
//
// This file contains the performance counter initialization
// and dump routines. The only part of this file you
// must modify is the performance counter name table. Match
// the names with the counters you define in perf.h
//
///======================================================================

#include "wdm.h"
#include "perf.h"

#include "debug.h"

#if PERFORMANCE

//**********************************************************************
//
// Modify this section for your counters
//

//
// The names that correspond to the performance
// counter indexes in perf.h
//
static char CounterNames[NUM_PERF_COUNTERS][32] = {
   //
   // Write path
   //
   "Write",
   "WriteComplete",
   "WriteTimeout",
   
   //
   // Read path
   //
   "StartUsbReadWorkItem",
   "UsbRead",
   "UsbReadCompletion",
   "CheckForQueuedUserReads",
   "GetUserData",
   "PutUserData",
   "CancelUsbReadIrp",
   "Read",
   "StartOrQueueIrp",
   "StartUserRead",
   "GetNextUserIrp",
   "CancelCurrentRead",
   "CancelQueuedIrp",
   "ReadTimeout",
   "IntervalReadTimeout",
   "CancelUsbReadWorkItem",

   //
   // USB Path
   //
   "UsbReadWritePacket",

   //
   // Serial path
   //
   "ProcessSerialWaits",

   //
   // Utils
   //
   "TryToCompleteCurrentIrp",
   "RundownIrpRefs",
   "RecycleIrp",
   "ReuseIrp",
   "CalculateTimeout",

};

//
// End of user-modified portion
// 
//**********************************************************************


// print macro that only turns on when debugging is on

//#if DBG
#define PerfPrint(arg) DbgPrint arg
//#else
//#define PerfPrint(arg) 
//#endif


//
// The array of performance counters
//
PERF_COUNTER PerfCounter[NUM_PERF_COUNTERS];

//
// Number of cycles for a PERF_ENTRY and PERF_EXIT
//
static LARGE_INTEGER  PerfEntryExitCycles;

//
// Number of cycles per second
//
static LARGE_INTEGER  PerfCyclesPerSecond;

//
// The resolution of the NT-supplied performance
// counter
//
static LARGE_INTEGER  PerfFreq;

#endif


//----------------------------------------------------------------------
//
// InitPerfCounters
//
// This function initializes the performance counter statistic
// array, estimates how many cycles on this processor equal a second,
// and determines how many cycles it takes to execute a 
// PERF_ENTRY/PERF_EXIT pair.
//
//----------------------------------------------------------------------
VOID
InitPerfCounters()
{
#if PERFORMANCE
    volatile ULONG  i;
    LARGE_INTEGER  calStart;
    LARGE_INTEGER  calEnd;
    LARGE_INTEGER  perfStart, perfEnd;
    LARGE_INTEGER  seconds;
    KIRQL prevIrql;

    //
    // Number of calibration loops
    //
#define CALIBRATION_LOOPS 500000

    //
    // This define is for a dummy performance counter that we
    // use just to calibrate the performance macro overhead
    //
#define TEST 0

    //
    // Calibrate the overhead of PERF_ENTRY and PERF_EXIT, so that
    // they can be subtracted from the output
    //
    DbgDump(DBG_INIT, ("CALIBRATING PEFORMANCE TIMER....\n"));
    KeRaiseIrql( DISPATCH_LEVEL, &prevIrql );
    perfStart = KeQueryPerformanceCounter( &PerfFreq );
    RDTSC(calStart);
    for( i = 0; i < CALIBRATION_LOOPS; i++ ) {
        PERF_ENTRY(TEST);
        PERF_EXIT(TEST);
    }
    RDTSC(calEnd);
    perfEnd = KeQueryPerformanceCounter(NULL);
    KeLowerIrql( prevIrql );

    //
    // Calculate the cycles/PERF_ENTRY, and the number of cycles/second
    //
    PerfEntryExitCycles.QuadPart = (calEnd.QuadPart - calStart.QuadPart)/CALIBRATION_LOOPS;

    seconds.QuadPart = ((perfEnd.QuadPart - perfStart.QuadPart) * 1000 )/ PerfFreq.QuadPart;

    PerfCyclesPerSecond.QuadPart =
        seconds.QuadPart ? ((calEnd.QuadPart - calStart.QuadPart) * 1000) / seconds.QuadPart : 0;

    DbgDump(DBG_INIT, ("Machine's Cycles Per Second   : %I64d\n", PerfCyclesPerSecond.QuadPart ));
    DbgDump(DBG_INIT, ("Machine's Cycles in PERF_XXXX : %I64d\n", PerfEntryExitCycles.QuadPart ));
    DbgDump(DBG_INIT, ("Machine's NT Performance counter frequency: %I64d\n", PerfFreq.QuadPart ));

    //
    // Initialize the array
    //
    for( i = 0; i < NUM_PERF_COUNTERS; i++ ) {
        PerfCounter[i].Count = 0;
        KeInitializeSpinLock( &PerfCounter[i].Lock );
        PerfCounter[i].TotalCycles.QuadPart = 0;
    }
#endif
}


// *******************************************************************
// Name:
//   DumpPerfCounters()
//
// Description:
//   Dumps the performance counters
//
// Assumptions:
//
// Returns:
//
// *******************************************************************
VOID
DumpPerfCounters()
{
#if PERFORMANCE
    int    i;
    LARGE_INTEGER totCycles;
    LARGE_INTEGER totLengthMs;
    LARGE_INTEGER avgLengthMs;

   if (DebugLevel & DBG_PERF ) {

       PerfPrint(("\n"));
       PerfPrint(("Machine's Cycles Per Second   : %I64d\n", PerfCyclesPerSecond.QuadPart ));
       PerfPrint(("Machine's Cycles in PERF_XXXX : %I64d\n", PerfEntryExitCycles.QuadPart ));
       PerfPrint(("Machine's NT Performance counter frequency: %I64d\n", PerfFreq.QuadPart ));
       PerfPrint(("\n===================================================================================\n"));
       PerfPrint((" %-30s      Count          TTL Time        Avg Time (uS)\n", "Function" ));
       PerfPrint(("===================================================================================\n"));

       for( i = 0; i < NUM_PERF_COUNTERS; i++ ) {

           totCycles = PerfCounter[i].TotalCycles;
           totCycles.QuadPart -= (PerfCounter[i].Count * PerfEntryExitCycles.QuadPart);
           totLengthMs.QuadPart = PerfCyclesPerSecond.QuadPart ? (totCycles.QuadPart * 1000000)/
               PerfCyclesPerSecond.QuadPart : 0;
           avgLengthMs.QuadPart = PerfCounter[i].Count ? totLengthMs.QuadPart / PerfCounter[i].Count : 0;

           PerfPrint((" %-30s %10d %15I64d %14I64d\n",
                     CounterNames[i], PerfCounter[i].Count,
                     totLengthMs.QuadPart, avgLengthMs.QuadPart ));

/*
           PerfPrint((" %-30s %10s %15I64d %14I64d (CY)\n",
                     "", "",
                     totCycles.QuadPart,
                     totCycles.QuadPart ? totCycles.QuadPart / PerfCounter[i].Count: 0 ));

           PerfPrint(("------------------------------------------------------------------------------\n"));   
*/
       }
       
       PerfPrint(("------------------------------------------------------------------------------\n"));   
   }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\pnp.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

        PNP.C

Abstract:

        WinCE Host PnP functions

Environment:

        kernel mode only

Revision History:

        07-14-99 : created

Authors:

        Jeff Midkiff (jeffmi)

-- */

#include "wceusbsh.h"

NTSTATUS
StartDevice(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

NTSTATUS
StopDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
RemoveDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
SyncCompletion(
    IN PDEVICE_OBJECT PDevObj,
    IN PIRP PIrp,
    IN PKEVENT PSyncEvent
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWCE1, StartDevice)
#pragma alloc_text(PAGEWCE1, StopIo)
#pragma alloc_text(PAGEWCE1, StopDevice)
#pragma alloc_text(PAGEWCE1, RemoveDevice)
#pragma alloc_text(PAGEWCE1, Power)
#endif



NTSTATUS
StartDevice(
    IN PDEVICE_OBJECT PDevObj,
    IN PIRP PIrp
    )
/*++

Routine Description:

   This routine handles IRP_MN_START_DEVICE to either
   to start a newly enumerated device or to restart
   an existing device that was stopped.

   PnP Manager postpones exposing device interfaces
   and blocks create requests for the device until
   the start IRP succeeds.

   See:  Setup, Plug & Play, Power Management: Preliminary Windows 2000 DDK
         Section 3.1 Starting a Device

Arguments:

   DeviceObject
   Irp

Return Value:

    NTSTATUS

--*/
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   PNP_STATE oldPnPState;
   KEVENT event;

   DbgDump(DBG_PNP, (">StartDevice (%x)\n", PDevObj));
   PAGED_CODE();

   oldPnPState = pDevExt->PnPState;

   //
   // Pass the Start Irp down the stack.
   // We do are Start on the way back up.
   //
   KeInitializeEvent( &event, SynchronizationEvent, FALSE );

   IoCopyCurrentIrpStackLocationToNext( PIrp );

   IoSetCompletionRoutine( PIrp,
                           SyncCompletion,
                           &event,
                           TRUE, TRUE, TRUE );

   status = IoCallDriver( pDevExt->NextDevice, PIrp );

   //
   // SyncCompletion simple signals the event
   // and returns STATUS_MORE_PROCESSING_REQUIRED,
   // so we still own the Irp.
   //
   if ( status == STATUS_PENDING ) {
      KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL );
   }

   status = PIrp->IoStatus.Status;

   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_PNP, ("ERROR: StartDevice returned 0x%x\n", status));
      goto ExitStartDevice;
   }

   //
   // The USB stack started OK, start our device...
   //

   //
   // Initialize our DPC's
   //
   KeInitializeDpc(&pDevExt->TotalReadTimeoutDpc,
                   ReadTimeout,
                   pDevExt);

   KeInitializeDpc( &pDevExt->IntervalReadTimeoutDpc,
                    IntervalReadTimeout,
                    pDevExt);

   //
   // Initialize timers
   //
   KeInitializeTimer(&pDevExt->ReadRequestTotalTimer);
   KeInitializeTimer(&pDevExt->ReadRequestIntervalTimer);

   //
   // Get our USB_DEVICE_DESCRIPTOR
   //
   status = UsbGetDeviceDescriptor(PDevObj);
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("UsbGetDeviceDescriptor error: 0x%x\n", status));
      goto ExitStartDevice;
   }

   //
   // Configure USB stack
   //
   status = UsbConfigureDevice( PDevObj );
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("UsbConfigureDevice error: 0x%x\n", status));
      goto ExitStartDevice;
   }

   // set state
   InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateStarted);
   InterlockedExchange(&pDevExt->DeviceRemoved, FALSE);
   InterlockedExchange(&pDevExt->AcceptingRequests, TRUE);

   //
   // reset logical Serial interface
   //
   status = SerialResetDevice(pDevExt, PIrp, FALSE);
   if ( STATUS_SUCCESS != status ) {
      DbgDump(DBG_ERR, ("SerialResetDevice ERROR: 0x%x\n", status));
      TEST_TRAP();
   }

   //
   // allocate our read endpoint context
   //
   status = AllocUsbRead( pDevExt );
   if ( STATUS_SUCCESS != status ) {
      DbgDump(DBG_ERR, ("AllocUsbRead ERROR: 0x%x\n", status));
      TEST_TRAP();
   }

   //
   // allocate our interrupt endpoint context
   //
   if ( pDevExt->IntPipe.hPipe ) {
       status = AllocUsbInterrupt( pDevExt );
       if ( STATUS_SUCCESS != status ) {
          DbgDump(DBG_ERR, ("AllocUsbRead ERROR: 0x%x\n", status));
          TEST_TRAP();
       }
   }

   //
   // Now set the interface state active
   //
   status = IoSetDeviceInterfaceState(&pDevExt->DeviceClassSymbolicName, TRUE);
   if ( STATUS_SUCCESS != status ) {
      DbgDump(DBG_ERR, ("IoSetDeviceInterfaceState error: 0x%x\n", status));
      TEST_TRAP();
   } else{
      DbgDump(DBG_WRN, ("IoSetDeviceInterfaceState: ON\n"));
   }

ExitStartDevice:
   if ( STATUS_SUCCESS != status ) {
      pDevExt->PnPState = oldPnPState;
      UsbFreeReadBuffer( PDevObj );
   }

   //
   // complete the Irp
   //
   PIrp->IoStatus.Status = status;

   DbgDump(DBG_PNP, ("<StartDevice(0x%x)\n", status));

   return status;
}


NTSTATUS
StopIo(
   IN PDEVICE_OBJECT DeviceObject
   )
{
   PDEVICE_EXTENSION pDevExt = DeviceObject->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   KIRQL irql;


   DbgDump(DBG_PNP|DBG_INIT, (">StopIo\n"));
   PAGED_CODE();

   if ((pDevExt->PnPState < PnPStateInitialized) ||  (pDevExt->PnPState > PnPStateMax)) {
        DbgDump(DBG_ERR, ("StopIo:STATUS_INVALID_PARAMETER\n"));
        return STATUS_INVALID_PARAMETER;
   }

   InterlockedExchange(&pDevExt->DeviceOpened, FALSE);

    //
    // cancel any pending user Read Irps
    //
    KillAllPendingUserReads( DeviceObject,
                          &pDevExt->UserReadQueue,
                          &pDevExt->UserReadIrp);

    //
    // cancel our USB INT irp
    //
    if (pDevExt->IntIrp)
    {
        status = CancelUsbInterruptIrp(DeviceObject);
        if (STATUS_SUCCESS == status) {

            InterlockedExchange(&pDevExt->IntState, IRP_STATE_COMPLETE);

        } else {
            DbgDump(DBG_ERR, ("CancelUsbInterruptIrp ERROR: 0x%x\n", status));
            TEST_TRAP();
        }
    }

    //
    // cancel our USB Read irp
    //
    if (pDevExt->UsbReadIrp)
    {
        status = CancelUsbReadIrp(DeviceObject);
        if (STATUS_SUCCESS == status) {

            InterlockedExchange(&pDevExt->UsbReadState, IRP_STATE_COMPLETE);

        } else {
            DbgDump(DBG_ERR, ("CancelUsbReadIrp ERROR: 0x%x\n", status));
            TEST_TRAP();
        }
    }

    //
    // cancel pending USB Writes
    //
    CleanUpPacketList( DeviceObject,
                    &pDevExt->PendingWritePackets,
                    &pDevExt->PendingDataOutEvent );

    //
    // cancel pending USB Reads
    //
    CleanUpPacketList(DeviceObject,
                      &pDevExt->PendingReadPackets,
                      &pDevExt->PendingDataInEvent );


    //
    // cancel the pending serial port Irp
    //
    if (pDevExt->SerialPort.ControlIrp) {
        if ( !IoCancelIrp(pDevExt->SerialPort.ControlIrp) ) {
            //
            // We can get here if we are holding the Irp, i.e. we didn't set a cancel routine.
            // Wait for the default timeout, which was set on the corresponding Urb (Set/Clear DTR/RTS).
            //
            LARGE_INTEGER timeOut;

            timeOut.QuadPart = MILLISEC_TO_100NANOSEC( DEFAULT_PENDING_TIMEOUT );

            DbgDump(DBG_ERR, ("!IoCancelIrp(%p)\n", pDevExt->SerialPort.ControlIrp));

            KeDelayExecutionThread(KernelMode, FALSE, &timeOut);

            TEST_TRAP();
        }
    }

    //
    // cancel the pending serial port wait mask Irp
    //
    if (pDevExt->SerialPort.CurrentWaitMaskIrp) {
        if ( !IoCancelIrp(pDevExt->SerialPort.CurrentWaitMaskIrp) ) {
            // We should never get here because we set a cancel routine on this Irp
            DbgDump(DBG_ERR, ("!IoCancelIrp(%p)\n", pDevExt->SerialPort.CurrentWaitMaskIrp));
            TEST_TRAP();
        }
    }

    //
    // wait for pending Work Items to complets
    //
    status = WaitForPendingItem(DeviceObject,
                              &pDevExt->PendingWorkItemsEvent,
                              &pDevExt->PendingWorkItemsCount );
    if ( STATUS_SUCCESS != status ) {
        DbgDump(DBG_ERR, ("WaitForPendingItem ERROR: 0x%x\n", status));
        TEST_TRAP();
    }

   ASSERT( 0 == pDevExt->PendingReadCount );
   ASSERT( 0 == pDevExt->PendingWriteCount );
   ASSERT( 0 == pDevExt->PendingDataOutCount );
   ASSERT( 0 == pDevExt->PendingIntCount );
   ASSERT( 0 == pDevExt->PendingWorkItemsCount );
   ASSERT( NULL == pDevExt->SerialPort.ControlIrp );
   ASSERT( NULL == pDevExt->SerialPort.CurrentWaitMaskIrp );

   DbgDump(DBG_PNP|DBG_INIT, ("<StopIo(%x)\n", status));
   return status;
}



NTSTATUS
StopDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

   This routine handles IRP_MN_STOP_DEVICE.

Arguments:

   DeviceObject
   Irp

Return Value:

    NTSTATUS

--*/
{
   PDEVICE_EXTENSION pDevExt = DeviceObject->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;

   UNREFERENCED_PARAMETER( Irp );

   DbgDump(DBG_PNP, (">StopDevice (%x)\n", DeviceObject));
   PAGED_CODE();

   //
   // if we are not already in stopped state
   //
   if ((pDevExt->PnPState != PnPStateStopped) ||
       (pDevExt->PnPState != PnPStateSupriseRemove)) {

      //
      // Signal that we are no longer AcceptingRequests
      //
      InterlockedExchange(&pDevExt->AcceptingRequests, FALSE);

      //
      // set the interface state inactive
      //
      if (pDevExt->DeviceClassSymbolicName.Buffer )
      {
          status = IoSetDeviceInterfaceState(&pDevExt->DeviceClassSymbolicName, FALSE);
          if (NT_SUCCESS(status)) {
              DbgDump(DBG_WRN, ("IoSetDeviceInterfaceState.2: OFF\n"));
          }
      }

      status = StopIo(DeviceObject);
      if (STATUS_SUCCESS != status) {
          DbgDump(DBG_ERR, ("StopIo ERROR: 0x%x\n", status));
          TEST_TRAP();
      }

      //
      // free the Read Irp
      //
      if (pDevExt->UsbReadIrp) {

         ASSERT( (IRP_STATE_COMPLETE == pDevExt->UsbReadState)
           || (IRP_STATE_CANCELLED== pDevExt->UsbReadState) );

         ExFreePool(pDevExt->UsbReadIrp);
         pDevExt->UsbReadIrp = NULL;
      }

      //
      // free the INT Irp
      //
      if (pDevExt->IntIrp) {

         ASSERT( (IRP_STATE_COMPLETE == pDevExt->IntState)
            || (IRP_STATE_CANCELLED== pDevExt->IntState) );

         ExFreePool(pDevExt->IntIrp);
         pDevExt->IntIrp = NULL;
      }

      //
      // free the INT Urb
      //
      if (pDevExt->IntUrb) {
         ExFreeToNPagedLookasideList( &pDevExt->BulkTransferUrbPool, pDevExt->IntUrb );
         pDevExt->IntUrb = NULL;

      }

   }

   DbgDump(DBG_PNP, ("<StopDevice(0x%x)\n", status));

   return status;
}


NTSTATUS
CleanUpPacketList(
   IN PDEVICE_OBJECT DeviceObject,
   IN PLIST_ENTRY PListHead,
   IN PKEVENT PEvent
   )
/* ++

Routine Description:

   Walks the pending packet list and
   cancels the packet's timer and Irp

Arguments:

   DeviceObject
   PListHead   - pointer to head of packet List

Return Value:

      NTSTATUS

-- */
{
   PDEVICE_EXTENSION pDevExt = DeviceObject->DeviceExtension;
   PUSB_PACKET       pPacket;
   KIRQL             irql;
   PLIST_ENTRY       pleHead, pleCurrent, pleNext;
   NTSTATUS          status = STATUS_SUCCESS;

   DbgDump(DBG_PNP|DBG_IRP, (">CleanUpPacketLists (%x)\n", DeviceObject));

   // acquire lock
   KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

   if ( !PListHead || !PEvent) {
      DbgDump(DBG_ERR, ("CleanUpPacketLists: !(Head|Event)\n"));
      TEST_TRAP();
      KeReleaseSpinLock( &pDevExt->ControlLock, irql );
      return STATUS_INVALID_PARAMETER;
   }

   // walk the list...
   for ( pleHead    = PListHead,          // get 1st ListEntry
         pleCurrent = pleHead->Flink,
         pleNext    = pleCurrent->Flink;

         pleCurrent != pleHead,           // done when we loop back to head
         !pleHead,                        // or hit a trashed list
         !pleCurrent,
         !pleNext;

         pleCurrent = pleNext,            // get the next in the list
         pleNext    = pleCurrent->Flink
        )
   {
      // did the list get trashed?
      ASSERT( pleHead );
      ASSERT( pleCurrent );
      ASSERT( pleNext );

      // extract packet pointer
      pPacket = CONTAINING_RECORD( pleCurrent,
                                   USB_PACKET,
                                   ListEntry );

      if ( pPacket &&
           pPacket->DeviceExtension &&
           pPacket->Irp ) {

        // cancel packet's timer
        KeCancelTimer( &pPacket->TimerObj);

        if ( !IoCancelIrp( pPacket->Irp ) ) {
           //
           // This means USB has the Irp in a non-canceable state.
           // We need to wait for either the pending read event, or the cancel event.
           //
           DbgDump(DBG_IRP, ("CleanUpPacketLists: Irp (%p) was not cancelled\n", pPacket->Irp));
        }

        //
        // we need to wait for the Irp to complete from USB
        //
        DbgDump(DBG_IRP, ("Waiting for Irp (%p) to complete...\n", pPacket->Irp ));

        KeReleaseSpinLock( &pDevExt->ControlLock, irql );

        PAGED_CODE();
        KeWaitForSingleObject( PEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

        DbgDump(DBG_IRP, ("...Irp (%p) signalled completion.\n", pPacket->Irp ));

      } else {
         // it was completed already
         DbgDump(DBG_WRN, ("CleanUpPacketLists: No Packet\n" ));

         if ( pPacket &&
              (!pPacket->ListEntry.Flink || !pPacket->ListEntry.Blink)) {

               DbgDump(DBG_ERR, ("CleanUpPacketLists: corrupt List!!\n" ));
               TEST_TRAP();
               break;
         }

      }

      //
      // The Irp should percolate back to our R/W completion
      // routine, which puts the packet back in packet pool.
      //
   }

#if DBG
   if ( !pleHead || !pleCurrent || !pleNext) {
      DbgDump(DBG_ERR, ("CleanUpPacketLists: corrupt List!!\n" ));
      TEST_TRAP();
   }
#endif

   KeReleaseSpinLock( &pDevExt->ControlLock, irql );

   DbgDump(DBG_PNP|DBG_IRP, ("<CleanUpPacketLists (0x%x)\n", STATUS_SUCCESS));

   return status;
}


NTSTATUS
RemoveDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

   This routine handles IRP_MN_REMOVE_DEVICE.

   See:  Setup, Plug & Play, Power Management: Preliminary Windows 2000 DDK
         Section 3.3.3.1 Removing a Device in a Function Driver

Arguments:

   DeviceObject
   Irp

Return Value:

    NTSTATUS

--*/
{
   PDEVICE_EXTENSION pDevExt = DeviceObject->DeviceExtension;
   NTSTATUS          status = STATUS_SUCCESS;

   DbgDump(DBG_PNP|DBG_TRACE, (">RemoveDevice (%x)\n", DeviceObject));
   PAGED_CODE();

   //
   // stop the device
   //
   status = StopDevice( DeviceObject, Irp );

   InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateRemoved);

   //
   // Pass the Irp down the stack now that we've done our work.
   // REMOVE_DEVICE must be handled first by the driver at the top of the device stack (this device)
   // and then by each next-lower driver (USBD) in the stack. A driver is not required to wait for underlying drivers to
   // finish their remove operations before continuing with its remove activities.
   //
   IoCopyCurrentIrpStackLocationToNext(Irp);
   status = IoCallDriver( pDevExt->NextDevice, Irp );

   //
   // wait for any pending I/O
   //
   ReleaseRemoveLockAndWait(&pDevExt->RemoveLock, Irp);

   //
   // cleanup any resources...
   //
   UsbFreeReadBuffer( DeviceObject );

   // free up notification buffer
   if(pDevExt->IntBuff) {
      ExFreePool(pDevExt->IntBuff);
      pDevExt->IntBuff = NULL;
   }

   //
   // delete LookasideLists
   //
   ExDeleteNPagedLookasideList( &pDevExt->PacketPool );
   ExDeleteNPagedLookasideList( &pDevExt->BulkTransferUrbPool );
   ExDeleteNPagedLookasideList( &pDevExt->PipeRequestUrbPool );
   ExDeleteNPagedLookasideList( &pDevExt->VendorRequestUrbPool );
   ExDeleteNPagedLookasideList( &pDevExt->WorkItemPool );

   if ( !g_isWin9x && g_ExposeComPort ) {
      // cleanup "COMx:" namespace
      UndoSerialPortNaming(pDevExt);
   }

   //
   // Dump PERF data
   //
#if PERFORMANCE
   if (DebugLevel & DBG_PERF )
   {
      DumpPerfCounters();

      DbgPrint("USB IN wMaxPacketSize: %d\n",    pDevExt->ReadPipe.MaxPacketSize);
      DbgPrint("USB OUT wMaxPacketSize: %d\n\n", pDevExt->WritePipe.MaxPacketSize );
      if ( pDevExt->IntPipe.hPipe) {
         DbgPrint("USB INT wMaxPacketSize: %d\n", pDevExt->IntPipe.MaxPacketSize);
         DbgPrint("USB INT Timeout: %d msec\n\n", -(pDevExt->IntReadTimeOut.QuadPart) / 10000 );
      }

      DbgPrint("TTL User Write Bytes   : %d\n",   pDevExt->TtlWriteBytes );
      DbgPrint("TTL User Write Requests: %d\n\n", pDevExt->TtlWriteRequests );

      DbgPrint("TTL User Read Bytes: %d\n",   pDevExt->TtlReadBytes );
      DbgPrint("TTL User Read Requests: %d\n\n", pDevExt->TtlReadRequests );

      DbgPrint("TTL USB Read Bytes: %d\n", pDevExt->TtlUSBReadBytes );
      DbgPrint("TTL USB Read Requests: %d\n\n", pDevExt->TtlUSBReadRequests );

      DbgPrint("USB Read Buffer Size: %d\n", pDevExt->UsbReadBuffSize );
      // Note: this signals the error condition: USB overran the *UsbReadBuffer* pending down the stack.
      DbgPrint("USB Read Buffer Overruns: %d\n\n", pDevExt->TtlUSBReadBuffOverruns );

#if USE_RING_BUFF
      DbgPrint("Internal RingBuffer Size: %d\n", pDevExt->RingBuff.Size );
      DbgPrint("Internal RingBuffer Overruns: %d\n\n", pDevExt->TtlRingBuffOverruns);
#endif
   }
#endif

   DbgDump(DBG_PNP|DBG_TRACE, ("<RemoveDevice (0x%x)\n", status));

   return status;
}



NTSTATUS
Pnp(
    IN PDEVICE_OBJECT PDevObj,
    IN PIRP PIrp
    )
{
   NTSTATUS status = STATUS_SUCCESS;
   PIO_STACK_LOCATION pIrpSp;
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

   PVOID   IoBuffer;
   ULONG   InputBufferLength;
   UCHAR   MinorFunction;
   BOOLEAN PassDown = TRUE;

   DbgDump(DBG_PNP|DBG_TRACE, (">Pnp)\n"));
   PAGED_CODE();

   status = AcquireRemoveLock(&pDevExt->RemoveLock, PIrp);
   if ( !NT_SUCCESS(status) ) {
        DbgDump(DBG_ERR, ("Pnp:(0x%x)\n", status));
        PIrp->IoStatus.Status = status;
        IoCompleteRequest(PIrp, IO_NO_INCREMENT);
        return status;
   }

   pIrpSp = IoGetCurrentIrpStackLocation(PIrp);
   MinorFunction     = pIrpSp->MinorFunction;
   IoBuffer          = PIrp->AssociatedIrp.SystemBuffer;
   InputBufferLength = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

   DbgDump(DBG_PNP, ("%s\n", PnPMinorFunctionString(MinorFunction)));

   switch (MinorFunction) {

        case IRP_MN_START_DEVICE:
          //
          // We cannot send the device any Non-PnP IRPs until
          // START_DEVICE has been propogated down the device stack
          //
          ASSERT( (PnPStateAttached == pDevExt->PnPState) ||
                  (PnPStateStopped == pDevExt->PnPState) );

          status = StartDevice(PDevObj, PIrp);
          PassDown = FALSE;
          break;

        case IRP_MN_STOP_DEVICE:

          status = StopDevice(PDevObj, PIrp);

          InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateStopped);
          break;

        case IRP_MN_SURPRISE_REMOVAL:
         //
         // * Win 2000 only *
         //
         status = StopDevice(PDevObj, PIrp);

         InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateSupriseRemove);
         break;

        case IRP_MN_REMOVE_DEVICE:
          //
          // sent when the device has been removed and probably physically detached
          // from the computer. As with STOP_DEVICE, the driver cannot
          // assume it has received any previous query and may have to
          // explicitly cancel any pending I/O IRPs it has staged.
          //
          status = RemoveDevice(PDevObj, PIrp);

           //
           // detach device from stack &
           //
           IoDetachDevice(pDevExt->NextDevice);

           //
           // delete our FDO and symbolic link
           //
           DeleteDevObjAndSymLink(PDevObj);

           //
           // A function driver does not specify an IoCompletion routine for a remove IRP,
           // nor does it complete the IRP. Remove IRPs are completed by the parent bus driver.
           // The device object & extension are now gone... don't touch it.
           //
           PassDown = FALSE;
           break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
          InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateRemovePending);
          break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
          InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateStarted);
          break;

        case IRP_MN_QUERY_STOP_DEVICE:
          InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateStopPending);
          break;

        case IRP_MN_CANCEL_STOP_DEVICE:
            InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateStarted);
          break;

        case IRP_MN_QUERY_CAPABILITIES: {
             KEVENT Event;

             KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

             IoCopyCurrentIrpStackLocationToNext(PIrp);

             IoSetCompletionRoutine( PIrp, SyncCompletion, &Event, TRUE, TRUE, TRUE);

             status = IoCallDriver(pDevExt->NextDevice, PIrp);
             if (status == STATUS_PENDING) {
                KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL);
             }

             status = PIrp->IoStatus.Status;
             if ( STATUS_SUCCESS == status ) {
               //
               // add in our capabilities
               //
               PDEVICE_CAPABILITIES pDevCaps = NULL;

               pDevCaps = pIrpSp->Parameters.DeviceCapabilities.Capabilities;

               //
               // touch Device PnP capabilities here...
               //
               pDevCaps->LockSupported = 0;
               pDevCaps->Removable = 1;
               pDevCaps->DockDevice = 0;
               pDevCaps->SilentInstall = 1;
               pDevCaps->SurpriseRemovalOK = 1;

               //
               // touch Device Power capabilities here...
               //
            }
            PassDown = FALSE;
          }
          break;


         case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {
            if (g_isWin9x) {
               status = PIrp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
               PassDown = FALSE;
            }
         }
         break;


        case IRP_MN_QUERY_PNP_DEVICE_STATE: {
            //
            // If the device took too many device errors then UsbResetOrAbortPipeWorkItem
            // disabled the device and called IoInvalidateDeviceState.
            // We only handle this Irp if we were disabled or marked as removed
            //
            KIRQL irql;
#if PnP_AS
            BOOLEAN bDisableInterface = FALSE;
#endif

            KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

            if (InterlockedCompareExchange(&pDevExt->DeviceRemoved, TRUE, TRUE)) {
                //
                // Do not set the PNP_DEVICE_REMOVED bit, else DevMan will mark the driver as banged out
                // until the next reboot; but stop taking requests.
                //
                DbgDump(DBG_WRN, ("PnP State: PNP_DEVICE_REMOVED\n"));

                InterlockedExchange(&pDevExt->AcceptingRequests, FALSE);
#if PnP_AS
                bDisableInterface = TRUE;
#endif

            } else if ( !CanAcceptIoRequests(PDevObj, FALSE, FALSE) ) {

                DbgDump(DBG_WRN, ("PnP State: PNP_DEVICE_FAILED\n"));

                PIrp->IoStatus.Information |= PNP_DEVICE_FAILED;

                status = PIrp->IoStatus.Status = STATUS_SUCCESS;
#if PnP_AS
                bDisableInterface = TRUE;
#endif
            }

            KeReleaseSpinLock(&pDevExt->ControlLock, irql);

#if PnP_AS
            // This is a great place to disable the interface, but unfortunately ActiveSync 3.1 will not reopen the device afterwards...
            // It misses about every other PnP this way. By *not* disableing the interface here then AS's only indication that anything is wrong is
            // by noticing that it's Read/Write/Serial requests get rejected, and AS will eventually timeout after some time dT ...
            // sometimes more than 5 seconds on Read/Writes. However, it does not sense Timeouts on Serial IOCTLS so will keep
            // sending us Serial requests, which will cause the bugcheck 0xCE in Set DTR. Disabeling the interface has the desired effect of
            // disallowing apps from sending us *ANY* requests.
            // This is an AS bug - there is pending email with kentce about this.
            if (bDisableInterface && pDevExt->DeviceClassSymbolicName.Buffer) {
                //
                // set the interface state to inactive to let ActiveSync know to release the handle. Must be done @ PASSIVE_LEVEL
                //
                status = IoSetDeviceInterfaceState(&pDevExt->DeviceClassSymbolicName, FALSE );
                if (NT_SUCCESS(status)) {
                    DbgDump(DBG_WRN, ("IoSetDeviceInterfaceState.1: OFF\n"));
                }
            }
#endif // PnP_AS
        }
        break;

        default:
          break;
   }

   if (IRP_MN_REMOVE_DEVICE != MinorFunction) {

      ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

   }

   if (PassDown) {

      IoCopyCurrentIrpStackLocationToNext(PIrp);

      status = IoCallDriver(pDevExt->NextDevice, PIrp);

   } else if (IRP_MN_REMOVE_DEVICE != MinorFunction) {

      IoCompleteRequest(PIrp, IO_NO_INCREMENT);

   }

   DbgDump(DBG_PNP|DBG_TRACE, ("<Pnp (0x%x)\n", status));

   return status;
}



NTSTATUS
SyncCompletion(
    IN PDEVICE_OBJECT PDevObj,
    IN PIRP PIrp,
    IN PKEVENT PSyncEvent
    )
/*++

Routine Description:

    This function is used to signal an event.
    It is used as a default completion routine.

Arguments:

    PDevObj - Pointer to Device Object
    PIrp - Pointer to IRP that is being completed
    PSyncEvent - Pointer to event that we should set

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
   UNREFERENCED_PARAMETER( PDevObj );
   UNREFERENCED_PARAMETER( PIrp );

   KeSetEvent( PSyncEvent, IO_NO_INCREMENT, FALSE );

   return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    DbgDump(DBG_PNP, (">PnpPower (%p, %p)\n", DeviceObject, Irp));

    //
    // If the device has been removed, the driver should not pass
    // the IRP down to the next lower driver.
    //
    if ( PnPStateRemoved == pDevExt->PnPState ) {

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status =  STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT );

        return STATUS_DELETE_PENDING;
    }

    //
    // passthrough
    //
    PoStartNextPowerIrp( Irp );
    IoSkipCurrentIrpStackLocation( Irp );

    DbgDump( DBG_PNP, ("<PnpPower\n") );

    return PoCallDriver( pDevExt->NextDevice, Irp );
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\debug.h ===
// Copyright (c) 1999-2000 Microsoft Corporation
#ifndef _DEBUG_H_
#define _DEBUG_H_


extern ULONG DebugLevel;


//
// Debugging Macros
//
#define DBG_OFF          ((ULONG)0x00000000)
#define DBG_ERR          ((ULONG)0x00000001)
#define DBG_WRN          ((ULONG)0x00000002)
#define DBG_INIT         ((ULONG)0x00000004)
#define DBG_PNP          ((ULONG)0x00000008)
#define DBG_READ         ((ULONG)0x00000010)
#define DBG_WRITE        ((ULONG)0x00000020)
#define DBG_DUMP_READS   ((ULONG)0x00000040)
#define DBG_DUMP_WRITES  ((ULONG)0x00000080)
#define DBG_READ_LENGTH  ((ULONG)0x00000100)
#define DBG_WRITE_LENGTH ((ULONG)0x00000200)
#define DBG_USB          ((ULONG)0x00000400)
#define DBG_SERIAL       ((ULONG)0x00000800)
#define DBG_TIME         ((ULONG)0x00001000)
#define DBG_EVENTS       ((ULONG)0x00002000)
#define DBG_CANCEL       ((ULONG)0x00004000)
#define DBG_IRP          ((ULONG)0x00008000)
#define DBG_INT          ((ULONG)0x00010000)
#define DBG_DUMP_INT     ((ULONG)0x00020000)
#define DBG_WORK_ITEMS   ((ULONG)0x00040000)
// ...
#define DBG_LOCKS        ((ULONG)0x00100000)
#define DBG_TRACE        ((ULONG)0x00200000)
// ...
#define DBG_PERF         ((ULONG)0x80000000)
// ...
#define DBG_ALL          ((ULONG)0xFFFFFFFF)


#if DBG

#ifndef DRV_NAME
#define DRV_NAME "WCEUSBSH"
#endif

#define DbgDump(_LEVEL, _STRING) \
{                                \
   ULONG level = _LEVEL;         \
   if ( DebugLevel & level ) {   \
         DbgPrint("%s(%d): ", DRV_NAME, KeGetCurrentIrql() ); \
         DbgPrint _STRING; \
   }  \
}

//
// these should be removed in the code if you can 'g' past these successfully
//
#define TEST_TRAP()  \
{ \
   DbgPrint( "%s: Code Coverage Trap: %s %d\nEnter 'g' to continue.\n", DRV_NAME, __FILE__, __LINE__); \
   DbgBreakPoint(); \
}

#else // !DBG

#define DbgDump(LEVEL,STRING)
#define TEST_TRAP() 

#endif // DBG


#endif //  _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\int.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

   int.c

Abstract:

   Interrupt Pipe handler
   Based on read.c

Author:

    Jeff Midkiff (jeffmi)     08-20-99

--*/

#include "wceusbsh.h"

VOID
RestartInterruptWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   );

NTSTATUS
UsbInterruptComplete(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PVOID Context
   );


//
// called with control lock held
//
#define START_ANOTHER_INTERRUPT( _PDevExt, _AcquireLock ) \
   ( (IRP_STATE_COMPLETE == _PDevExt->IntState) && \
     CanAcceptIoRequests(_PDevExt->DeviceObject, _AcquireLock, TRUE) \
   )


//
// This function allocates a single Irp & Urb to be continously
// submitted to USBD for INT pipe notifications.
// It is called from StartDevice.
// The Irp & Urb are finally freed in StopDevice.
//
NTSTATUS
AllocUsbInterrupt(
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_SUCCESS;
   PIRP     pIrp;
   PURB     pUrb;
   PAGED_CODE();

   DbgDump(DBG_INT, (">AllocUsbInterrupt(%p)\n", PDevExt->DeviceObject));

   ASSERT( PDevExt );

   if ( !PDevExt->IntPipe.hPipe ) {

      status = STATUS_UNSUCCESSFUL;
      DbgDump(DBG_ERR, ("AllocUsbInterrupt: 0x%x\n", status ));

   } else {

      ASSERT( NULL == PDevExt->IntIrp );

      pIrp = IoAllocateIrp( (CCHAR)(PDevExt->NextDevice->StackSize + 1), FALSE);

      if (pIrp) {

         //
         // fixup irp so we can pass to ourself,
         // and to USBD
         //
         FIXUP_RAW_IRP( pIrp, PDevExt->DeviceObject );

         //
         // alloc the int pipe's Urb
         //
         pUrb = ExAllocateFromNPagedLookasideList( &PDevExt->BulkTransferUrbPool );

         if (pUrb) {

            // save these to be freed when not needed
            SetPVoidLocked( &PDevExt->IntIrp,
                            pIrp,
                            &PDevExt->ControlLock);

            SetPVoidLocked( &PDevExt->IntUrb,
                            pUrb,
                            &PDevExt->ControlLock);

            DbgDump(DBG_INT, ("IntIrp: %p\t IntUrb: %p\n", PDevExt->IntIrp, PDevExt->IntUrb));

            InterlockedExchange(&PDevExt->IntState, IRP_STATE_COMPLETE);

            KeInitializeEvent( &PDevExt->IntCancelEvent,
                               SynchronizationEvent,
                               FALSE);

         } else {
            //
            // this is a fatal err since we can't post int requests to USBD
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            DbgDump(DBG_ERR, ("AllocUsbInterrupt: 0x%x\n", status ));
            TEST_TRAP();

         }

      } else {
         //
         // this is a fatal err since we can't post int requests to USBD
         //
         status = STATUS_INSUFFICIENT_RESOURCES;
         DbgDump(DBG_ERR, ("AllocUsbInterrupt: 0x%x\n", status ));
         TEST_TRAP();
      }
   }

   DbgDump(DBG_INT, ("<AllocUsbInterrupt 0x%x\n", status ));

   return status;
}


//
// This routine takes the device's current IntIrp and submits it to USBD.
// When the Irp is completed by USBD our completion routine fires.
//
// Return: successful return value is STATUS_SUCCESS, or
//         STATUS_PENDING - which means the I/O is pending in the USB stack.
//
NTSTATUS
UsbInterruptRead(
   IN PDEVICE_EXTENSION PDevExt
   )
{
   PIO_STACK_LOCATION pNextStack;
   NTSTATUS status = STATUS_SUCCESS;
   KIRQL irql;

   DbgDump(DBG_INT, (">UsbInterruptRead(%p)\n", PDevExt->DeviceObject));


   do {
      //
      // check our USB INT state
      //
      KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

      if ( !PDevExt->IntPipe.hPipe || !PDevExt->IntIrp ||
           !PDevExt->IntUrb   || !PDevExt->IntBuff ) {
         status = STATUS_UNSUCCESSFUL;
         DbgDump(DBG_ERR, ("UsbInterruptRead: 0x%x\n", status ));
         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
         break;
      }

      if ( !CanAcceptIoRequests(PDevExt->DeviceObject, FALSE, TRUE) ) {
         status = STATUS_DELETE_PENDING;
         DbgDump(DBG_ERR, ("UsbInterruptRead: 0x%x\n", status ));
         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
         break;
      }

#if DBG
      if (IRP_STATE_CANCELLED == PDevExt->IntState)
         TEST_TRAP();
#endif

      //
      // we post our INT irp to USB if it has been completed (not cancelled),
      // and the device is accepting requests
      //
      if ( START_ANOTHER_INTERRUPT( PDevExt, FALSE ) ) {

          status = AcquireRemoveLock(&PDevExt->RemoveLock, PDevExt->IntIrp);
          if ( !NT_SUCCESS(status) ) {
             DbgDump(DBG_ERR, ("UsbInterruptRead: 0x%x\n", status ));
             KeReleaseSpinLock(&PDevExt->ControlLock, irql);
             break;
         }

         ASSERT( IRP_STATE_COMPLETE == PDevExt->IntState);

         InterlockedExchange(&PDevExt->IntState, IRP_STATE_PENDING);

         KeClearEvent( &PDevExt->PendingIntEvent );
         KeClearEvent( &PDevExt->IntCancelEvent );

         RecycleIrp( PDevExt->DeviceObject, PDevExt->IntIrp );

         UsbBuildTransferUrb( PDevExt->IntUrb,
                              PDevExt->IntBuff,
                              PDevExt->IntPipe.MaxPacketSize,
                              PDevExt->IntPipe.hPipe,
                              TRUE );

         //
         // set Irp up for a submit Urb IOCTL
         //
         IoCopyCurrentIrpStackLocationToNext(PDevExt->IntIrp);

         pNextStack = IoGetNextIrpStackLocation(PDevExt->IntIrp);
         pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
         pNextStack->Parameters.Others.Argument1 = PDevExt->IntUrb;
         pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

         //
         // completion routine will take care of updating buffer
         //
         IoSetCompletionRoutine( PDevExt->IntIrp,
                                 UsbInterruptComplete,
                                 NULL, //PDevExt,          // Context
                                 TRUE, TRUE, TRUE);

         InterlockedIncrement(&PDevExt->PendingIntCount);

         KeReleaseSpinLock( &PDevExt->ControlLock, irql );

         status = IoCallDriver(PDevExt->NextDevice, PDevExt->IntIrp );

         if ( (STATUS_SUCCESS != status) &&  (STATUS_PENDING != status)) {
            //
            // We can end up here after our completion routine runs
            // for an error condition i.e., when we have an
            // invalid parameter, or when user pulls the plug, etc.
            //
            DbgDump(DBG_ERR, ("UsbInterruptRead: 0x%x\n", status));
         }

      } else {
         //
         // we did not post an INT, but this is not an error condition
         //
         status = STATUS_SUCCESS;
         DbgDump(DBG_INT, ("!UsbInterruptRead RE: 0x%x\n", PDevExt->IntState ));

         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
      }


   } while (0);

   DbgDump(DBG_INT, ("<UsbInterruptRead 0x%x\n", status ));

   return status;
}


/*

This completion routine fires when USBD completes our IntIrp
Note: we allocated the Irp, and recycle it.
Always return STATUS_MORE_PROCESSING_REQUIRED to retain the Irp.
This routine runs at DPC_LEVEL.

Interrupt Endpoint:
This endpoint will be used to indicate the availability of IN data,
as well as to reflect the state of the device serial control lines :

D15..D3     Reserved
D2      DSR state  (1=Active, 0=Inactive)
D1      CTS state  (1=Active, 0=Inactive)
D0      Data Available  - (1=Host should read IN endpoint, 0=No data currently available)

*/
NTSTATUS
UsbInterruptComplete(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP Irp,
   IN PVOID Context)
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   ULONG             count;
   KIRQL             irql;
   PIRP              pCurrentMaskIrp = NULL;

   NTSTATUS    irpStatus;
   USBD_STATUS urbStatus;

   USHORT   usNewMSR;
   USHORT   usOldMSR;
   USHORT   usDeltaMSR;
   NTSTATUS workStatus;

   BOOLEAN bStartRead = FALSE;

   UNREFERENCED_PARAMETER( Irp );
   UNREFERENCED_PARAMETER( Context );

   ASSERT( pDevExt->IntIrp == Irp );
   ASSERT( pDevExt->IntBuff );

   DbgDump(DBG_INT, (">UsbInterruptComplete(%p)\n", PDevObj));

   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   //
   // Our INT state should be either pending or cancelled at this point.
   // If it pending then USB is completing the Irp normally.
   // If it is cancelled then our Cancel routine set it,
   // in which case USB can complete the irp normally or as cancelled
   // depending on where it was in processing. If the state is cancelled
   // then do NOT set to complete, else the Irp will
   // go back down to USB and you are hosed.
   //
   ASSERT( (IRP_STATE_PENDING == pDevExt->IntState)
           || (IRP_STATE_CANCELLED== pDevExt->IntState) );

   if (IRP_STATE_PENDING == pDevExt->IntState) {
      InterlockedExchange(&pDevExt->IntState, IRP_STATE_COMPLETE);
   }

   //
   // signal everyone if this is the last IRP
   //
   if ( 0 == InterlockedDecrement(&pDevExt->PendingIntCount) ) {

      // DbgDump(DBG_INT, ("PendingIntCount: 0\n"));

      // when we drop back to passive level they will get signalled
      KeSetEvent(&pDevExt->PendingIntEvent, IO_SERIAL_INCREMENT, FALSE);
   }

   //
   // get the completion info
   //
   count = pDevExt->IntUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;

   irpStatus = pDevExt->IntIrp->IoStatus.Status;
   DbgDump(DBG_INT, ("Irp->IoStatus.Status  0x%x\n", irpStatus));

   urbStatus = pDevExt->IntUrb->UrbHeader.Status;
   DbgDump(DBG_INT, ("Urb->UrbHeader.Status 0x%x\n", urbStatus ));

   switch (irpStatus) {

      case STATUS_SUCCESS: {

         ASSERT( USBD_STATUS_SUCCESS == urbStatus );

         //
         // clear pipe error count
         //
         InterlockedExchange( &pDevExt->IntDeviceErrors, 0);

#if DBG
         if (DebugLevel & DBG_DUMP_INT) {
            ULONG i;
            DbgDump(DBG_INT, ("IntBuff[%d]: ", count ));
            for (i=0; i < count; i++) {
               KdPrint( ("%02x ", pDevExt->IntBuff[i] ) );
            }
            KdPrint(("\n"));
         }
#endif

        //
        // Get Data Ready
        //
        // D0 - Data Available (1=Host should read IN endpoint, 0=No data currently available)
        //
        if ( pDevExt->IntBuff[0] & USB_COMM_DATA_READY_MASK ) {

           DbgDump(DBG_INT, ("Data Ready\n"));
           bStartRead = TRUE;

           // Note: we may be prematurely setting this bit since we have not
           // confirmed data reception, but need to get the user's read started.
           // Perhaps only set if not using the ring-buffer, since buffered reads are not bound to app's reads.
           pDevExt->SerialPort.HistoryMask |= SERIAL_EV_RXCHAR;
        }

        //
        // Get Modem Status Register
        //
        // D1       CTS state  (1=Active, 0=Inactive)
        // D2       DSR state  (1=Active, 0=Inactive)
        //
        usOldMSR = pDevExt->SerialPort.ModemStatus;

        usNewMSR = pDevExt->IntBuff[0] & USB_COMM_MODEM_STATUS_MASK;

        DbgDump(DBG_INT, ("USB_COMM State: 0x%x\n", usNewMSR));

        if (usNewMSR & USB_COMM_CTS) {
           pDevExt->SerialPort.ModemStatus |= SERIAL_MSR_CTS;
        } else {
           pDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_CTS;
        }

        if (usNewMSR & USB_COMM_DSR) {
           pDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DSR | SERIAL_MSR_DCD;
        } else {
           pDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DSR & ~SERIAL_MSR_DCD;
        }

        // see what has changed in the status register
        usDeltaMSR = usOldMSR ^ pDevExt->SerialPort.ModemStatus;

        if (/*(pDevExt->SerialPort.RS232Lines & SERIAL_RTS_STATE) && */
            (usDeltaMSR & SERIAL_MSR_CTS)) {

           pDevExt->SerialPort.HistoryMask |= SERIAL_EV_CTS;
           pDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DCTS;
        }

        if (/*(pDevExt->SerialPort.RS232Lines & SERIAL_DTR_STATE) && */
            (usDeltaMSR & SERIAL_MSR_DSR)) {

           pDevExt->SerialPort.HistoryMask |= SERIAL_EV_DSR | SERIAL_EV_RLSD;
           pDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DDSR | SERIAL_MSR_DDCD;
        }

        DbgDump(DBG_INT, ("SerialPort.MSR: 0x%x\n", pDevExt->SerialPort.ModemStatus));

        KeReleaseSpinLock(&pDevExt->ControlLock, irql);

        //
        // signal serial events @ DISPATCH_LEVEL before starting our UsbRead,
        // since we run at higher IRQL than apps.
        //
        ProcessSerialWaits( pDevExt );

        if ( bStartRead )  {
           //
           // Get the data.
           // We do set a timeout on 1st read, in case the INT was illegit.
           // Note: we start this read @ DISPATCH_LEVEL.
           //
           UsbRead( pDevExt,
                    TRUE );

        }

        //
        // Queue a passive work item to sync execution of the INT pipe and the IN pipe
        // and then start the next INT packet.
        //
        workStatus = QueueWorkItem( PDevObj,
                                    RestartInterruptWorkItem,
                                    NULL,
                                    0 );

      }
      break;


      case STATUS_CANCELLED:  {
         DbgDump(DBG_INT|DBG_IRP, ("Int: STATUS_CANCELLED\n"));

         // signal anyone who cancelled this or is waiting for it to stop
         //
         KeSetEvent(&pDevExt->IntCancelEvent, IO_SERIAL_INCREMENT, FALSE);

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      }
      break;


      case STATUS_DEVICE_DATA_ERROR: {
         //
         // generic device error set by USBD.
         //
         DbgDump(DBG_ERR, ("IntPipe STATUS_DEVICE_DATA_ERROR: 0x%x\n", urbStatus ));

         //
         // bump pipe error count
         //
         InterlockedIncrement( &pDevExt->IntDeviceErrors);

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);

         //
         // is the endpoint is stalled?
         //
         if ( USBD_HALTED(pDevExt->IntUrb->UrbHeader.Status) ) {
               //
               // queue a reset request,
               // which also starts another INT
               //
               workStatus = QueueWorkItem( PDevObj,
                                           UsbResetOrAbortPipeWorkItem,
                                           (PVOID)((LONG_PTR)urbStatus),
                                           WORK_ITEM_RESET_INT_PIPE );

         } else {
            //
            // queue a passive work item to start the next INT packet.
            //
            workStatus = QueueWorkItem( PDevObj,
                                        RestartInterruptWorkItem,
                                        NULL,
                                        0 );
         }
      }
      break;

      default:
         DbgDump(DBG_WRN|DBG_INT, ("Unhandled INT Pipe status: 0x%x 0x%x\n", irpStatus, urbStatus ));
         KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      break;
   }

   ReleaseRemoveLock(&pDevExt->RemoveLock, pDevExt->IntIrp);

   DbgDump(DBG_INT, ("<UsbInterruptComplete\n"));

   return STATUS_MORE_PROCESSING_REQUIRED;
}


//
// This routine requests USB to cancel our INT Irp.
// It must be called at passive level.
// Note: it is the responsibility of the caller to
// reset the IntState to IRP_STATE_COMPLETE and restart USB Ints
// when this routine completes. Else, no more Interrupts will get posted.
//
NTSTATUS
CancelUsbInterruptIrp(
   IN PDEVICE_OBJECT PDevObj
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   NTSTATUS wait_status;
   KIRQL irql;

   DbgDump(DBG_INT|DBG_IRP, (">CancelUsbInterruptIrp\n"));

   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   if ( pDevExt->IntPipe.hPipe && pDevExt->IntIrp ) {

      switch (pDevExt->IntState) {

         //case IRP_STATE_START:
         case IRP_STATE_PENDING:
         {
            //
            // the Irp is pending somewhere down the USB stack...
            //
            PVOID Objects[2] = { &pDevExt->PendingIntEvent,
                                 &pDevExt->IntCancelEvent };

            //
            // signal we need to cancel the Irp
            //
            pDevExt->IntState = IRP_STATE_CANCELLED;

            KeReleaseSpinLock(&pDevExt->ControlLock, irql);

            if ( !IoCancelIrp( pDevExt->IntIrp ) ) {
               //
               // This means USB has the IntIrp in a non-canceable state.
               // We still need to wait for either the pending INT event, or the cancel event.
               //
               DbgDump(DBG_INT|DBG_IRP, ("Irp (%p) was not cancelled\n", pDevExt->IntIrp ));
               // TEST_TRAP();
            }

            DbgDump(DBG_INT|DBG_IRP, ("Waiting for pending IntIrp (%p) to cancel...\n", pDevExt->IntIrp ));

            PAGED_CODE();
            wait_status = KeWaitForMultipleObjects(
                              2,
                              Objects,
                              WaitAny,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL,
                              NULL );

            DbgDump(DBG_INT|DBG_IRP, ("...IntIrp (%p) signalled by: %d\n", pDevExt->IntIrp, wait_status ));

            //
            // At this point we have the Irp back from USB
            //
         }
         break;

         case IRP_STATE_COMPLETE:
         case IRP_STATE_CANCELLED:
            pDevExt->IntState = IRP_STATE_CANCELLED;
            KeReleaseSpinLock(&pDevExt->ControlLock, irql);
            break;

         default:
            DbgDump(DBG_ERR, ("CancelUsbInterruptIrp - Invalid IntState: 0x%x\n", pDevExt->IntState ));
            KeReleaseSpinLock(&pDevExt->ControlLock, irql);
            break;
      }

      if ( (IRP_STATE_CANCELLED != pDevExt->IntState) ||
           (0 != pDevExt->PendingIntCount) ) {

           DbgDump(DBG_ERR, ("CancelUsbInterruptIrp error: IntState: 0x%x \tPendingIntCount: 0x%x\n", pDevExt->IntState, pDevExt->PendingIntCount ));
           TEST_TRAP();

      }

   } else {
      status = STATUS_UNSUCCESSFUL;
      DbgDump(DBG_ERR, ("No INT Irp\n" ));
      KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      // TEST_TRAP();
   }

   DbgDump(DBG_INT|DBG_IRP, ("<CancelUsbInterruptIrp\n"));
   return status;
}


//
// Work item queued from interrupt completion
// to sync execution of the INT pipe and the IN pipe
// and then start another USB INT read if there is not one already in progress
//
VOID
RestartInterruptWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   )
{
   PDEVICE_OBJECT    pDevObj = PWorkItem->DeviceObject;
   PDEVICE_EXTENSION pDevExt = pDevObj->DeviceExtension;
   NTSTATUS status = STATUS_DELETE_PENDING;
   NTSTATUS wait_status;
   KIRQL irql;


   DbgDump(DBG_INT|DBG_WORK_ITEMS, (">RestartInterruptWorkItem(%p)\n", pDevObj ));

   KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

   //
   // Is the READ Irp is pending somewhere in the USB stack?
   //
   if ( IRP_STATE_PENDING == pDevExt->UsbReadState ) {
      //
      // Then we need to sync with the Usb Read Completion routine.
      //
      #define WAIT_REASONS 2
      PVOID Objects[WAIT_REASONS] = { &pDevExt->UsbReadCancelEvent,
                                      &pDevExt->PendingDataInEvent };

      KeReleaseSpinLock(&pDevExt->ControlLock, irql);

      DbgDump(DBG_INT, ("INT pipe waiting for pending UsbReadIrp (%p) to finish...\n", pDevExt->UsbReadIrp ));

      PAGED_CODE();
      wait_status = KeWaitForMultipleObjects( WAIT_REASONS,
                                              Objects,
                                              WaitAny,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL,
                                              NULL );

      DbgDump(DBG_INT, ("...UsbReadIrp (%p) signalled by: %d\n", pDevExt->UsbReadIrp, wait_status ));

      //
      // At this point the read packet is back on our list
      // and we have the UsbReadIrp back from USB
      //

   } else {
      KeReleaseSpinLock(&pDevExt->ControlLock, irql);
   }

   // start another INT read
   if ( START_ANOTHER_INTERRUPT(pDevExt, TRUE) ) {
      status = UsbInterruptRead( pDevExt );
   }

   DequeueWorkItem( pDevObj, PWorkItem );

   DbgDump(DBG_INT|DBG_WORK_ITEMS, ("<RestartInterruptWorkItem 0x%x\n", status ));

   PAGED_CODE(); // we must exit at passive level

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\perf.h ===
// Copyright (c) 1999-2000 Microsoft Corporation
///======================================================================
//
// Perf.h
//
// Fill in this header file with definitions for the performance
// counters you want to use.
//
///======================================================================

#ifndef _PERF_H_
#define _PERF_H_

//**********************************************************************
//
// Modify this section for your counters
//

#define DRV_NAME "WCEUSBSH"

//
// Define PERFORMANCE to "1" turn on the cycle performance counters.
// I currently set it in the debug build (or explicitely in SOURCES for free build) since
// the free build only sees a slight gain IFF *all* debug tracing (except DBG_ERR)
// is turned off.
//
#if DBG
#if !defined(MSFT_NT_BUILD)
#define PERFORMANCE 1
#endif
#endif

//
// This is the array of counter index definitions.
// Note that when a new entry is added here that the name array
// in perf.c must be updated as well. The convention is that
// the index name should match the function name identically, with
// the PERF_ prefix.
//
enum {
   //
   // Write path
   //
   PERF_Write,
   PERF_WriteComplete,
   PERF_WriteTimeout,

   //
   // Read path
   //
   PERF_StartUsbReadWorkItem,
   PERF_UsbRead,
   PERF_UsbReadCompletion,
   PERF_CheckForQueuedUserReads,
   PERF_GetUserData,
   PERF_PutUserData,
   PERF_CancelUsbReadIrp,
   PERF_Read,
   PERF_StartOrQueueIrp,
   PERF_StartUserRead,
   PERF_GetNextUserIrp,
   PERF_CancelCurrentRead,
   PERF_CancelQueuedIrp,
   PERF_ReadTimeout,
   PERF_IntervalReadTimeout,
   PERF_CancelUsbReadWorkItem,

   //
   // USB Path
   //
   PERF_UsbReadWritePacket,

   //
   // Serial path
   //
   PERF_ProcessSerialWaits,

   //
   // Utils
   //
   PERF_TryToCompleteCurrentIrp,
   PERF_RundownIrpRefs,
   PERF_RecycleIrp,
   PERF_ReuseIrp,
   PERF_CalculateTimeout,

   //
   // leave this entry alone
   //
   NUM_PERF_COUNTERS
} PERF_INDICED;

//
// End of user-modified portion
//
//**********************************************************************

typedef struct {
   KSPIN_LOCK      Lock;
   LONG            Count;
   LARGE_INTEGER   TotalCycles;
} PERF_COUNTER, *PPERF_COUNTER;


#if PERFORMANCE

extern PERF_COUNTER PerfCounter[];

//
// Definition for raw bytes that generate RDTSC instruction
//
#define RDTSC(_VAR)                \
   _asm {                          \
       _asm push eax               \
       _asm push edx               \
       _asm _emit 0Fh              \
       _asm _emit 31h              \
       _asm mov _VAR.LowPart, eax  \
       _asm mov _VAR.HighPart, edx \
       _asm pop edx                \
       _asm pop eax                \
   }

//
// Definitions for performance counters that execute
// at DISPATCH_LEVEL (e.g. in DPCs) and lower IRQLs.
//
// NOTE: we read the cycle counter at the outside of the
// macros since we compensate for the overhead of the macros themselves.
//
#define PERF_ENTRY(_INDEX)                  \
      LARGE_INTEGER _INDEX##perfStart;         \
      LARGE_INTEGER _INDEX##perfEnd;           \
      RDTSC(_INDEX##perfStart);                \
      InterlockedIncrement( &PerfCounter[_INDEX].Count )


#define PERF_EXIT(_INDEX)                   \
      RDTSC(_INDEX##perfEnd);                  \
      _INDEX##perfEnd.QuadPart -= _INDEX##perfStart.QuadPart;          \
      ExInterlockedAddLargeInteger( &PerfCounter[_INDEX].TotalCycles,  \
            _INDEX##perfEnd,                   \
            &PerfCounter[_INDEX].Lock )


//
// Definitions for performance counters that execute
// in ISRs, and hence need no locking
//
#define PERF_ISR_ENTRY(_INDEX)  PERF_ENTRY(_INDEX)

#define PERF_ISR_EXIT(_INDEX)               \
   _INDEX##perfEnd.QuadPart -= _INDEX##perfStart.QuadPart;               \
   PerfCounter[_INDEX].TotalCycles.QuadPart += _INDEX##perfEnd.QuadPart; \
   RDTSC(_INDEX##perfEnd)

#else // PERFORMANCE

#define PERF_ENTRY(_INDEX)

#define PERF_EXIT(_INDEX)

#endif PERFORMANCE


//
// Externs for perf.c
//
VOID InitPerfCounters();
VOID DumpPerfCounters();

#endif _PERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\read.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

   read.c

Abstract:

   This driver implements a state machine which polls for USB read data.
   It pends a single private read irp to USBD as soon as it starts up (StartDevice)
   if there is no interrupt endpoint.

   We have only 1 USB read buffer of some configured size.
   When the USB read irp completes then we copy the data into any pending user read buffer,
   and resubmit the Usb UsbReadIrp to USBD, *IF OUR BUFFER* is emptied. This implements
   simple flow ctrl. There is an optional ring-buffer implementation, which will not bind USB reads
   to application reads.

   Timeouts are set from the app via serial ioctls.

   An alternative to this muck is to create a driver thread to do the polling
   for USB read data. This has it's own caveats & requires the thread to be scheduled,
   so take time to investigate beforehand.

Author:

    Jeff Midkiff (jeffmi)     07-16-99

--*/


#if defined (USE_RING_BUFF)
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#else
#include <stdlib.h>
#endif

#include "wceusbsh.h"


//
// called with control held
//
#if defined (USE_RING_BUFF)
#define START_ANOTHER_USBREAD( _PDevExt ) \
   ( (IRP_STATE_COMPLETE == _PDevExt->UsbReadState) && \
     CanAcceptIoRequests(_PDevExt->DeviceObject, FALSE, TRUE) \
   )
#else
#define START_ANOTHER_USBREAD( _PDevExt ) \
   ( (IRP_STATE_COMPLETE == _PDevExt->UsbReadState) && \
     (0 == _PDevExt->UsbReadBuffChars) && \
     CanAcceptIoRequests(_PDevExt->DeviceObject, FALSE, TRUE) \
   )
#endif


NTSTATUS
UsbReadCompletion(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PVOID Context
   );

__inline
ULONG
GetUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN PCHAR PDestBuff,
   IN ULONG RequestedLen,
   IN OUT PULONG PBytesCopied
   );

__inline
VOID
PutUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN ULONG Count
   );

__inline
VOID
CheckForQueuedUserReads(
   IN PDEVICE_EXTENSION PDevExt,
   IN KIRQL Irql
   );

VOID
CancelQueuedIrp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

VOID
CancelUsbReadWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   );

VOID
StartUsbReadWorkItem(
    IN PWCE_WORK_ITEM PWorkItem
   );

NTSTATUS
StartUserRead(
   IN PDEVICE_EXTENSION PDevExt
   );

VOID
UsbReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   );

VOID
CancelCurrentRead(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

NTSTATUS
StartOrQueueIrp(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp,
   IN PLIST_ENTRY PIrpQueue,
   IN PIRP *PPCurrentIrp,
   IN PSTART_ROUTINE StartRoutine
   );

VOID
GetNextUserIrp(
   IN PIRP *PpCurrentOpIrp,
   IN PLIST_ENTRY PQueueToProcess,
   OUT PIRP *PpNextIrp,
   IN BOOLEAN CompleteCurrent,
   IN PDEVICE_EXTENSION PDevExt
   );


///////////////////////////////////////////////////////////////////
//
// USB read section
//
//

//
// This function allocates a single Irp & Urb to be continously submitted
// to USBD for buffered reads.
// It is called from StartDevice.
// The Irp & Urb are finally freed in StopDevice.
//
NTSTATUS
AllocUsbRead(
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_SUCCESS;
   PIRP     pIrp;

   DbgDump(DBG_READ, (">AllocUsbRead(%p)\n", PDevExt->DeviceObject));

   ASSERT( PDevExt );
   ASSERT( NULL == PDevExt->UsbReadIrp );

   pIrp = IoAllocateIrp( (CCHAR)(PDevExt->NextDevice->StackSize + 1), FALSE);

   if ( pIrp ) {

      DbgDump(DBG_READ, ("UsbReadIrp: %p\n", pIrp ));

      //
      // fixup irp so we can pass to ourself,
      // and to USBD
      //
      FIXUP_RAW_IRP( pIrp, PDevExt->DeviceObject );

      //
      // setup read state
      //
      KeInitializeEvent( &PDevExt->UsbReadCancelEvent,
                         SynchronizationEvent,
                         FALSE);

      PDevExt->UsbReadIrp = pIrp;

      ASSERT( PDevExt->UsbReadBuff );
      PDevExt->UsbReadBuffChars = 0;
      PDevExt->UsbReadBuffIndex = 0;

      ASSERT( 0 == PDevExt->PendingReadCount );

      InterlockedExchange(&PDevExt->UsbReadState, IRP_STATE_COMPLETE);

   } else {
      //
      // this is a fatal err since we can't post reads to USBD
      //
      TEST_TRAP();
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("AllocUsbRead: 0x%x\n", status ));
   }

   DbgDump(DBG_READ, ("<AllocUsbRead 0x%x\n", status ));

   return status;
}


//
// Work item queued from read completion or read timeout.
// Starts another USB read if there is not one already in progress
//
VOID
StartUsbReadWorkItem(
    IN PWCE_WORK_ITEM PWorkItem
   )
{
   PDEVICE_OBJECT    pDevObj = PWorkItem->DeviceObject;
   PDEVICE_EXTENSION pDevExt = pDevObj->DeviceExtension;
   NTSTATUS status = STATUS_DELETE_PENDING;

   PERF_ENTRY( PERF_StartUsbReadWorkItem );

   DbgDump(DBG_READ|DBG_WORK_ITEMS, (">StartUsbReadWorkItem(%p)\n", pDevObj ));

   if ( InterlockedCompareExchange(&pDevExt->AcceptingRequests, TRUE, TRUE) ) {
      status = UsbRead( pDevExt, FALSE );
   }

   DequeueWorkItem( pDevObj, PWorkItem );

   DbgDump(DBG_READ|DBG_WORK_ITEMS, ("<StartUsbReadWorkItem 0x%x\n", status ));

   PAGED_CODE(); // we must exit at passive level

   PERF_EXIT( PERF_StartUsbReadWorkItem );

   return;
}


//
// This routine takes the device's current USB UsbReadIrp and submits it to USBD.
// When the Irp is completed by USBD our completion routine fires.
//
// An optional Timeout value sets a timer on the USB Read Irp,
// so USBD won't queue the read Irp indefinetly.
// If there is a device error then USB returns the Irp.
//
// Return: successful return value is STATUS_SUCCESS, or
//         STATUS_PENDING - which means the I/O is pending in the USB stack.
//
NTSTATUS
UsbRead(
   IN PDEVICE_EXTENSION PDevExt,
   IN BOOLEAN UseTimeout
   )
{
   NTSTATUS status;
   KIRQL    irql;
   LARGE_INTEGER noTimeout = {0,0};

   PERF_ENTRY( PERF_UsbRead );

   DbgDump(DBG_READ, (">UsbRead(%p, %d)\n", PDevExt->DeviceObject, UseTimeout));

   do {
      //
      // check our USB read state
      //
      KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

      if ( !PDevExt->UsbReadIrp ) {
         status = STATUS_UNSUCCESSFUL;
         DbgDump(DBG_ERR, ("UsbRead NO READ IRP\n"));
         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
         PERF_EXIT( PERF_UsbRead );
         break;
      }

      if ( !CanAcceptIoRequests(PDevExt->DeviceObject, FALSE, TRUE)) {
         status = STATUS_DELETE_PENDING;
         DbgDump(DBG_ERR, ("UsbRead: 0x%x\n", status ));
         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
         PERF_EXIT( PERF_UsbRead );
         break;
      }

      //
      // we post our read irp to USB if it has been completed (not cancelled),
      // and our read bufer is driained (if not using a ring-buffer)
      // and the device is accepting requests
      //
      if ( START_ANOTHER_USBREAD( PDevExt ) ) {

         status = AcquireRemoveLock(&PDevExt->RemoveLock, PDevExt->UsbReadIrp);
         if ( !NT_SUCCESS(status) ) {
             DbgDump(DBG_ERR, ("UsbRead: 0x%x\n", status ));
             KeReleaseSpinLock(&PDevExt->ControlLock, irql);
             PERF_EXIT( PERF_UsbRead );
             break;
         }

         ASSERT( IRP_STATE_COMPLETE == PDevExt->UsbReadState);

         InterlockedExchange(&PDevExt->UsbReadState, IRP_STATE_PENDING);

         KeClearEvent( &PDevExt->PendingDataInEvent );
         KeClearEvent( &PDevExt->UsbReadCancelEvent );

         RecycleIrp( PDevExt->DeviceObject, PDevExt->UsbReadIrp );

         //
         // bump ttl request count
         //
         PDevExt->TtlUSBReadRequests++;

         KeReleaseSpinLock(&PDevExt->ControlLock, irql);

#if DBG
         if (UseTimeout) {
            DbgDump(DBG_INT, ("INT Read Timeout due in %d msec\n", (PDevExt->IntReadTimeOut.QuadPart/10000) ));
            KeQuerySystemTime(&PDevExt->LastIntReadTime);
         }
#endif

         status = UsbReadWritePacket( PDevExt,
                                      PDevExt->UsbReadIrp,
                                      UsbReadCompletion, // Irp completion routine
                                      UseTimeout ? PDevExt->IntReadTimeOut : noTimeout,
                                      UseTimeout ? UsbReadTimeout : NULL,    // Timeout routine
                                      TRUE );            // Read

         if ( (STATUS_SUCCESS != status) && (STATUS_PENDING != status) ) {
            //
            // We can end up here after our completion routine runs
            // for an error condition i.e., when we have an
            // invalid parameter, or when user pulls the plug, etc.
            //
            DbgDump(DBG_ERR, ("UsbReadWritePacket: 0x%x\n", status));
         }

      } else {
         //
         // we did not post a Read, but this is not an error condition
         //
         status = STATUS_SUCCESS;
         DbgDump(DBG_READ, ("!UsbRead RE(2): (0x%x,0x%x)\n", PDevExt->UsbReadState, PDevExt->UsbReadBuffChars ));

         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
      }

   } while (0);

   DbgDump(DBG_READ, ("<UsbRead 0x%x\n", status ));

   PERF_EXIT( PERF_UsbRead );

   return status;
}


//
// This completion routine fires when our USB read completes our UsbReadIrp
// Note: we allocated the Irp, and recycle it.
// Always return STATUS_MORE_PROCESSING_REQUIRED to retain the Irp.
// This routine runs at DPC_LEVEL.
//
NTSTATUS
UsbReadCompletion(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP Irp,
   IN PUSB_PACKET PPacket // Context
   )
{
   PDEVICE_EXTENSION pDevExt = PPacket->DeviceExtension;
   PDEVICE_OBJECT    pDevObj = pDevExt->DeviceObject;
   PURB              pUrb;
   ULONG             count;
   KIRQL             irql;
   NTSTATUS          irpStatus;
   NTSTATUS          workStatus;
   USBD_STATUS       urbStatus;

   PERF_ENTRY( PERF_UsbReadCompletion );

   UNREFERENCED_PARAMETER( PDevObj );

   DbgDump(DBG_READ, (">UsbReadCompletion (%p)\n", Irp));

   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   //
   // cancel the Packet Timer
   //
   if ( PPacket->Timeout.QuadPart != 0 ) {

      if (KeCancelTimer( &PPacket->TimerObj ) ) {
         //
         // the packet's timer was successfully removed from the system
         //
         DbgDump(DBG_READ|DBG_INT, ("Read PacketTimer: Canceled\n"));
      } else {
         //
         // the timer
         // a) already completed, in which case the Irp is being cancelled, or
         // b) it's spinning on the control lock, so tell it we took the Irp.
         //
         PPacket->Status = STATUS_ALERTED;
         DbgDump(DBG_READ|DBG_INT, ("Read PacketTimer: Alerted\n"));
      }
   }

   //
   // get everything we need out of the packet
   // and put it back on the list
   //

   // ensure the Irp is the same one as in our DevExt
   ASSERT( pDevExt->UsbReadIrp == Irp );

   // ensure the Packet's Irp is the same one as in our DevExt
   ASSERT( PPacket->Irp == Irp );

   pUrb = pDevExt->UsbReadUrb;

   // ensure the Packet's Urb is the same one as in our DevExt
   ASSERT( pUrb == &PPacket->Urb );

   count = pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;

   RemoveEntryList( &PPacket->ListEntry );

   //
   // Our read state should be either pending or cancelled at this point.
   // If it pending then USB is completing the Irp normally.
   // If it is cancelled then our CancelUsbReadIrp set it,
   // in which case USB can complete the irp normally or as cancelled
   // depending on where it was in processing. If the read state is cancelled
   // then do NOT set to complete, else the read Irp will
   // go back down to USB and you are hosed.
   //
   ASSERT( (IRP_STATE_PENDING == pDevExt->UsbReadState)
           || (IRP_STATE_CANCELLED== pDevExt->UsbReadState) );

   if (IRP_STATE_PENDING == pDevExt->UsbReadState) {
      InterlockedExchange(&pDevExt->UsbReadState, IRP_STATE_COMPLETE);
   }

   //
   // Put the pacet back in packet pool
   //
   ExFreeToNPagedLookasideList( &pDevExt->PacketPool,  // Lookaside,
                                PPacket                // Entry
                                );

   //
   // signal everyone if this is the last IRP
   //
   if ( 0 == InterlockedDecrement(&pDevExt->PendingReadCount) ) {

      DbgDump(DBG_READ, ("PendingReadCount(1) = 0\n"));

      // when we drop back to passive level they will get signalled
      KeSetEvent(&pDevExt->PendingDataInEvent, IO_SERIAL_INCREMENT, FALSE);

   }

   irpStatus = Irp->IoStatus.Status;
   DbgDump(DBG_READ, ("Irp->IoStatus.Status  0x%x\n", irpStatus));

   urbStatus = pUrb->UrbHeader.Status;
   DbgDump(DBG_READ, ("pUrb->UrbHeader.Status 0x%x\n", urbStatus ));

   switch (irpStatus) {

      case STATUS_SUCCESS: {
         //
         // save the read transfer info
         //
         ASSERT( USBD_STATUS_SUCCESS == urbStatus );

         DbgDump(DBG_READ_LENGTH, ("USB Read indication: %d\n", count));

         //
         // store read data
         //
         PutUserData( pDevExt, count );

         //
         // clear pipe error count
         //
         InterlockedExchange( &pDevExt->ReadDeviceErrors, 0);

         //
         // bump ttl byte counter
         //
         pDevExt->TtlUSBReadBytes += count;

         //
         // We have some USB read data in our local buffer,
         // let's see if we can satisfy any queued user read requests.
         // This f() releases the control lock.
         //
         CheckForQueuedUserReads(pDevExt, irql);

         //
         // kick off another USB read
         //
         UsbRead( pDevExt,
                  (BOOLEAN)(pDevExt->IntPipe.hPipe ? TRUE : FALSE) );

      }
      break;


      case STATUS_CANCELLED:  {

         DbgDump(DBG_WRN|DBG_READ|DBG_IRP, ("Read: STATUS_CANCELLED\n"));

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);

         //
         // If it was cancelled, it may have timed out.
         // We can tell by looking at the packet attached to it.
         //
         if ( STATUS_TIMEOUT == PPacket->Status ) {
            //
            // no read data available from USBD
            //
            DbgDump(DBG_WRN|DBG_READ|DBG_IRP, ("Read: STATUS_TIMEOUT\n"));
            ASSERT( USBD_STATUS_CANCELED == urbStatus);
            //
            // We need to kick off another USB read when we are out of reads,
            // or have an error condition.
            //
            if ( !pDevExt->IntPipe.hPipe ) {

               workStatus = QueueWorkItem( pDevObj,
                                           StartUsbReadWorkItem,
                                           NULL,
                                           0 );

            } else {
               workStatus = STATUS_UNSUCCESSFUL;
            }
         }
         //
         // signal anyone who cancelled this or is waiting for it to stop
         //
         KeSetEvent(&pDevExt->UsbReadCancelEvent, IO_SERIAL_INCREMENT, FALSE);
      }
      break;


      case STATUS_DEVICE_DATA_ERROR: {
         //
         // generic device error set by USBD.
         //
         DbgDump(DBG_ERR, ("ReadPipe STATUS_DEVICE_DATA_ERROR: 0x%x\n", urbStatus ));

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);

         //
         // bump pipe error count
         //
         InterlockedIncrement( &pDevExt->ReadDeviceErrors);

         //
         // is the endpoint is stalled?
         //
         if ( USBD_HALTED(pUrb->UrbHeader.Status) ) {

               if ( USBD_STATUS_BUFFER_OVERRUN == pUrb->UrbHeader.Status) {
                  pDevExt->TtlUSBReadBuffOverruns++;
               }

               //
               // queue a reset request,
               // which also starts another read
               //
               workStatus = QueueWorkItem( pDevObj,
                                           UsbResetOrAbortPipeWorkItem,
                                           (PVOID)((LONG_PTR)urbStatus),
                                           WORK_ITEM_RESET_READ_PIPE );

         } else {
            //
            // kick start another USB read
            //
            workStatus = QueueWorkItem( PDevObj,
                                        StartUsbReadWorkItem,
                                        NULL,
                                        0 );

         }
      }
      break;


      case STATUS_INVALID_PARAMETER:   {
         //
         // This means that our (TransferBufferSize > PipeInfo->MaxTransferSize)
         // we need to either break up requests or reject the Irp from the start.
         //
         DbgDump(DBG_WRN, ("STATUS_INVALID_PARAMETER\n"));

         ASSERT(USBD_STATUS_INVALID_PARAMETER == urbStatus);

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);

         TEST_TRAP();
      }
      break;

      default: {
         DbgDump(DBG_ERR, ("READ: Unhandled Irp status: 0x%x\n", irpStatus));
         KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      }
      break;
   }

   ReleaseRemoveLock(&pDevExt->RemoveLock, pDevExt->UsbReadIrp);

   DbgDump(DBG_READ, ("<UsbReadCompletion\n"));

   PERF_EXIT( PERF_UsbReadCompletion );

   return STATUS_MORE_PROCESSING_REQUIRED;
}


//
// This routine is called from the UsbReadCompletion routine
// when our USB UsbReadIrp has completed successfully.
// See if we have any queued user read Irps that we can satisfy.
// It is called with the control lock held (as an optimization)
// and must release the lock upon return.
//
__inline
VOID
CheckForQueuedUserReads(
   IN PDEVICE_EXTENSION PDevExt,
   IN KIRQL Irql
   )
{
   PERF_ENTRY( PERF_CheckForQueuedUserReads );

   DbgDump(DBG_READ, (">CheckForQueuedUserReads(%p)\n", PDevExt->DeviceObject));

   //
   // is there a user read pending?
   //
   if ( (PDevExt->UserReadIrp != NULL) &&
        (IRP_REFERENCE_COUNT(PDevExt->UserReadIrp) & IRP_REF_RX_BUFFER)) {
      //
      // copy our USB read data into user's irp buffer
      //
#if DBG
      ULONG charsRead =
#endif
      GetUserData( PDevExt,
                  ((PUCHAR)(PDevExt->UserReadIrp->AssociatedIrp.SystemBuffer))
                     + (IoGetCurrentIrpStackLocation(PDevExt->UserReadIrp))->Parameters.Read.Length
                     - PDevExt->NumberNeededForRead,
                  PDevExt->NumberNeededForRead,
                  (PULONG)&PDevExt->UserReadIrp->IoStatus.Information );

      if ( !PDevExt->UserReadIrp ) {
         //
         // it's (no longer) possible to have completed the read Irp
         // in the above GetUserData cycle.
         //
         DbgDump(DBG_READ, ("UsbReadIrp already completed(2)\n"));
         TEST_TRAP();

      } else if (PDevExt->NumberNeededForRead == 0) {
         //
         // Mark the user's read Irp as completed,
         // and try to get and service the next user read irp
         //
         ASSERT( PDevExt->UserReadIrp );

         PDevExt->UserReadIrp->IoStatus.Status = STATUS_SUCCESS;

         // signals the interval timer this read is complete
         PDevExt->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

#if DBG
         if ( DebugLevel & DBG_READ_LENGTH) {

               ULONG count;

               if (PDevExt->UserReadIrp->IoStatus.Status == STATUS_SUCCESS) {
                  count = (ULONG)PDevExt->UserReadIrp->IoStatus.Information;
               } else {
                  count = 0;

               }

               KdPrint(("RD2: RL(%d) C(%d) I(%p)\n",
                        IoGetCurrentIrpStackLocation(PDevExt->UserReadIrp)->Parameters.Read.Length,
                        count,
                        PDevExt->UserReadIrp));
         }
#endif

         TryToCompleteCurrentIrp( PDevExt,
                                  STATUS_SUCCESS,
                                  &PDevExt->UserReadIrp,
                                  &PDevExt->UserReadQueue,
                                  &PDevExt->ReadRequestIntervalTimer,
                                  &PDevExt->ReadRequestTotalTimer,
                                  StartUserRead,
                                  GetNextUserIrp,
                                  IRP_REF_RX_BUFFER,
                                  TRUE,
                                  Irql );

      } else {
         //
         // we could get here if we did not staisfy the user's read
         // but have drained our read buffer. This requires another
         // USB read post.
         //
         ASSERT( PDevExt->UserReadIrp );
         ASSERT( PDevExt->NumberNeededForRead );
         DbgDump(DBG_READ|DBG_READ_LENGTH, ("Pending Irp (%p) has %d bytes to satisfy\n",
                           PDevExt->UserReadIrp, PDevExt->NumberNeededForRead));

         KeReleaseSpinLock( &PDevExt->ControlLock, Irql);
         // TEST_TRAP();
      }

   } else {
      //
      // Q: should we:
      // 1.) copy the data into a local ring-buffer and post another read to USBD, - or -
      // 2.) leave the data in the FIFO & let the device stall/NAK so that:
      //    a) we dont lose any data if the user is not posting reads,
      //    b) lets the other end know to stop sending data via NAKs
      //
      // ...Currently choose #2. If we were to add a ring-buffer then here is where you should do the
      // local copy.
      //
      // Note: we could get here before an app even opens this device
      // if the there is data coming in on the other side of the FIFO.
      //
      DbgDump(DBG_READ|DBG_READ_LENGTH, ("No pending user Reads\n"));
      KeReleaseSpinLock( &PDevExt->ControlLock, Irql);
      //TEST_TRAP();
   }

   //
   // process serial Rx wait masks
   //
   ProcessSerialWaits(PDevExt);

   DbgDump(DBG_READ, ("<CheckForQueuedUserReads\n"));

   PERF_EXIT( PERF_CheckForQueuedUserReads );

   return;
}


#if !defined (USE_RING_BUFF)
//
// We have no ring-buffer.
// Simply copy data from our USB read buffer into user's buffer.
// Called with the control lock held.
//
// Returns the number of bytes copied.
//

__inline
ULONG
GetUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN PCHAR PDestBuff,
   IN ULONG RequestedLen,
   IN OUT PULONG PBytesCopied
   )
{
   ULONG count;

   PERF_ENTRY( PERF_GetUserData );

   DbgDump(DBG_READ, (">GetUserData (%p)\n", PDevExt->DeviceObject ));

   count = min(PDevExt->UsbReadBuffChars, RequestedLen);

   if (count) {

      memcpy( PDestBuff, &PDevExt->UsbReadBuff[PDevExt->UsbReadBuffIndex], count);

      PDevExt->UsbReadBuffIndex += count;
      PDevExt->UsbReadBuffChars -= count;

      PDevExt->NumberNeededForRead -= count;
      *PBytesCopied += count;
      PDevExt->ReadByIsr += count;
   }

#if DBG
   // temp hack to debug iPAQ 'CLIENT' indications
   if ((DebugLevel & DBG_DUMP_READS) && (count <= 6))
   {
         ULONG i;

         KdPrint(("RD1(%d): ", count));
         for (i = 0; i < count; i++) {
            KdPrint(("%02x ", PDestBuff[i] & 0xFF));
         }
         KdPrint(("\n"));
   }
#endif

   DbgDump(DBG_READ, ("<GetUserData 0x%x\n", count ));

   PERF_EXIT( PERF_GetUserData );

   return count;
}


/*
 We have no ring buffer.
 Simply update the USB read buffer's count & index
 and process serial chars.

 Called with the ControlLock held.
*/
__inline
VOID
PutUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN ULONG Count
   )
{
    PERF_ENTRY( PERF_PutUserData );

    ASSERT( PDevExt );

    DbgDump(DBG_READ, (">PutUserData %d\n", Count ));

    PDevExt->UsbReadBuffChars = Count;
    PDevExt->UsbReadBuffIndex = 0;

    ASSERT_SERIAL_PORT(PDevExt->SerialPort);

    PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RXCHAR;
    // We have no concept of 80% full. If we blindly set it
    // then serial apps may go into flow handlers.
    // | SERIAL_EV_RX80FULL;

    //
    // Scan for RXFLAG char if needed
    //
    if (PDevExt->SerialPort.WaitMask & SERIAL_EV_RXFLAG) {
        ULONG i;
        for (i = 0; i < Count; i++) {
            if ( *((PUCHAR)&PDevExt->UsbReadBuff[PDevExt->UsbReadBuffIndex] + i)
                == PDevExt->SerialPort.SpecialChars.EventChar) {

               PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RXFLAG;

               DbgDump(DBG_READ|DBG_EVENTS, ("Found SpecialChar: %x\n", PDevExt->SerialPort.SpecialChars.EventChar ));
               break;
            }
        }
    }

    DbgDump(DBG_READ, ("<PutUserData\n"));

    PERF_EXIT( PERF_PutUserData );

    return;
}


#else

/*
 Ring-buffer version
 Copy the ring-buffer data into the user's buffer while checking for wrap around.
 Also must check if we exhaust the read buffer.

 Called with the ControlLock held.
*/
__inline
ULONG
GetUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN PCHAR PDestBuff,
   IN ULONG RequestedLen,
   IN OUT PULONG PBytesCopied
   )
{
   ULONG i, count;

   PERF_ENTRY( PERF_GetUserData );

   DbgDump(DBG_READ, (">GetUserData (%p)\n", PDevExt->DeviceObject ));

   count = min(PDevExt->RingBuff.CharsInBuff, RequestedLen);

   if (count) {

      for ( i = 0; i< count; i++) {

         // copy the ring buffer data into user's buffer
         PDestBuff[i] = *PDevExt->RingBuff.pHead;

         // bump head checking for wrap
         PDevExt->RingBuff.pHead = PDevExt->RingBuff.pBase + ((ULONG)(PDevExt->RingBuff.pHead + 1) % RINGBUFF_SIZE);
      }

      PDevExt->RingBuff.CharsInBuff -= count;

      PDevExt->NumberNeededForRead -= count;
      *PBytesCopied += count;
      PDevExt->ReadByIsr += count;
   }

#if DBG
   if (DebugLevel & DBG_DUMP_READS)
   {
         ULONG i;

         KdPrint(("RD1(%d): ", count));

         for (i = 0; i < count; i++) {
            KdPrint(("%02x ", PDestBuff[i] & 0xFF));
         }

         KdPrint(("\n"));
   }
#endif

   DbgDump(DBG_READ, ("<GetUserData 0x%x\n", count ));

   PERF_EXIT( PERF_GetUserData );

   return count;
}


/*
 Ring-buffer version
 Copy the USB Read buffer into the ring-buffer while checking for wrap around.

 The ring buffer is assummed to be at least the same size as the USB read buffer.
 This is a simple ring where writes occur at the tail, which can eventually overwrite the start of
 the user read buffer location at the head, if user is not consuming the data. If we overwrite the
 head then we must reset the head to be where we started the current write.

 Note: the USB read buffer is a simple char array, with it's current index = 0.
 Note: SerialPort ownership assummed.

 Called with the ControlLock held.

 Q: Should write an error log if an app has an open handle and we overrun the buffer?

*/
__inline
VOID
PutUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN ULONG Count
   )
{
   ULONG i;
   PUCHAR pPrevTail;

   PERF_ENTRY( PERF_PutUserData );

   ASSERT( PDevExt );
   ASSERT( PDevExt->RingBuff.pBase );
   ASSERT( PDevExt->RingBuff.pHead );
   ASSERT( PDevExt->RingBuff.pTail );
   ASSERT( PDevExt->RingBuff.Size >= PDevExt->UsbReadBuffSize );
   ASSERT_SERIAL_PORT(PDevExt->SerialPort);

   DbgDump(DBG_READ, (">PutUserData %d\n", Count ));

   pPrevTail = PDevExt->RingBuff.pTail;

   for ( i = 0; i < Count; i++) {

      // copy the USB data
      *PDevExt->RingBuff.pTail = PDevExt->UsbReadBuff[i];

      // check EV_RXFLAG while we are here
      if ( (PDevExt->SerialPort.WaitMask & SERIAL_EV_RXFLAG) &&
           (*PDevExt->RingBuff.pTail == PDevExt->SerialPort.SpecialChars.EventChar)) {

         PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RXFLAG;

         DbgDump(DBG_READ|DBG_SERIAL, ("Found SpecialChar: %x\n", PDevExt->SerialPort.SpecialChars.EventChar ));
      }

      // bump tail checking for wrap
      PDevExt->RingBuff.pTail = PDevExt->RingBuff.pBase + ((ULONG)(PDevExt->RingBuff.pTail + 1) % PDevExt->RingBuff.Size);
   }

   //
   // bump count
   //
   if ( (PDevExt->RingBuff.CharsInBuff + Count) <=  PDevExt->RingBuff.Size ) {

      PDevExt->RingBuff.CharsInBuff += Count;

   } else {
      //
      // Overrun condition. We could check for this first to save the above copy process,
      // but it's the unusual case. We could also optimize the above copy a bit, but still need
      // to check for EV_RXFLAG.
      //
      PDevExt->RingBuff.CharsInBuff = Count;
      PDevExt->RingBuff.pHead = pPrevTail;
#if PERFORMANCE
      PDevExt->TtlRingBuffOverruns.QuadPart ++;
#endif
   }

   PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RXCHAR;

   //
   // Check for 80% full.
   // We currently signal this at 50% since we run at a raised IRQL and serial apps are slow.
   //
   if ( PDevExt->RingBuff.CharsInBuff > RINGBUFF_HIGHWATER_MARK ) {
      DbgDump(DBG_READ|DBG_READ_LENGTH|DBG_SERIAL|DBG_WRN, ("SERIAL_EV_RX80FULL\n"));
      PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RX80FULL;
   }

   DbgDump(DBG_READ, ("<PutUserData\n"));

   PERF_EXIT( PERF_PutUserData );

   return;
}

#endif // USE_RING_BUFF


//
// This routine requests USB to cancel our USB Read Irp.
//
// Note: it is the responsibility of the caller to
//    reset the read state to IRP_STATE_COMPLETE and restart USB reads
//    when this routine completes. Else, no more reads will get posted.
// Note: when the USB Read Irp is cancelled the pending USB read packet
//    is cancelled via the USB Read completion routine.
// Note: must be called at PASSIVE_LEVEL.
//
NTSTATUS
CancelUsbReadIrp(
   IN PDEVICE_OBJECT PDevObj
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   NTSTATUS wait_status;
   KIRQL irql;

   PERF_ENTRY( PERF_CancelUsbReadIrp );

   DbgDump(DBG_READ|DBG_IRP, (">CancelUsbReadIrp\n"));

   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   if ( pDevExt->UsbReadIrp ) {

      switch (pDevExt->UsbReadState) {

         //case IRP_STATE_START:
         case IRP_STATE_PENDING:
         {
            //
            // the Irp is pending somewhere down the USB stack...
            //
            PVOID Objects[2] = { &pDevExt->PendingDataInEvent,
                                 &pDevExt->UsbReadCancelEvent };

            //
            // signal we need to cancel the Irp
            //
            pDevExt->UsbReadState = IRP_STATE_CANCELLED;

            KeReleaseSpinLock(&pDevExt->ControlLock, irql);

            if ( !IoCancelIrp( pDevExt->UsbReadIrp ) ) {
               //
               // This means USB has the UsbReadIrp in a non-canceable state.
               // We still need to wait for either the pending read event, or the cancel event.
               //
               DbgDump(DBG_READ|DBG_IRP, ("Irp (%p) was not cancelled\n", pDevExt->UsbReadIrp ));
               // TEST_TRAP();
            }

            DbgDump(DBG_READ|DBG_IRP, ("Waiting for pending UsbReadIrp (%p) to cancel...\n", pDevExt->UsbReadIrp ));

            PAGED_CODE();
            wait_status = KeWaitForMultipleObjects(
                              2,
                              Objects,
                              WaitAny,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL,
                              NULL );

            DbgDump(DBG_READ|DBG_IRP, ("...UsbReadIrp (%p) signalled by: %d\n", pDevExt->UsbReadIrp, wait_status ));

            //
            // At this point the read packet is back on our list
            // and we have the Irp back from USB
            //

         }
         break;

         case IRP_STATE_COMPLETE:
            pDevExt->UsbReadState = IRP_STATE_CANCELLED;
            KeReleaseSpinLock(&pDevExt->ControlLock, irql);
            break;

         default:
            DbgDump(DBG_ERR, ("CancelUsbReadIrp - Invalid UsbReadState: 0x%x\n", pDevExt->UsbReadState ));
            TEST_TRAP();
            KeReleaseSpinLock(&pDevExt->ControlLock, irql);
            break;
      }

      if ( (IRP_STATE_CANCELLED != pDevExt->UsbReadState) ||
           (0 != pDevExt->PendingReadCount) ) {

           DbgDump(DBG_ERR, ("CancelUsbReadIrp error: UsbReadState: 0x%x \tPendingReadCount: 0x%x\n", pDevExt->UsbReadState, pDevExt->PendingReadCount ));
           //TEST_TRAP();

      }

   } else {
      status = STATUS_UNSUCCESSFUL;
      DbgDump(DBG_ERR, ("No Read Irp\n" ));
      KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      // TEST_TRAP();
   }

   DbgDump(DBG_READ|DBG_IRP, ("<CancelUsbReadIrp\n"));

   PERF_EXIT( PERF_CancelUsbReadIrp );

   return status;
}


//
// Work item queued from USB read timeout
// to Cancel the USB read irp pending in the USB stack
//
VOID
CancelUsbReadWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   )
{
   PDEVICE_OBJECT    pDevObj = PWorkItem->DeviceObject;
   PDEVICE_EXTENSION pDevExt = pDevObj->DeviceExtension;
   NTSTATUS status = STATUS_DELETE_PENDING;
   KIRQL irql;

   PERF_ENTRY( PERF_CancelUsbReadWorkItem );

   DbgDump(DBG_INT|DBG_READ|DBG_WORK_ITEMS, (">CancelUsbReadWorkItem(%p)\n", pDevObj ));

   KeAcquireSpinLock( &pDevExt->ControlLock, &irql);

   if (IRP_STATE_PENDING == pDevExt->UsbReadState) {

      KeReleaseSpinLock( &pDevExt->ControlLock, irql);

      status = CancelUsbReadIrp( pDevObj );

      InterlockedExchange(&pDevExt->UsbReadState, IRP_STATE_COMPLETE);

   } else {
      KeReleaseSpinLock( &pDevExt->ControlLock, irql);
   }

   DequeueWorkItem( pDevObj, PWorkItem );

   DbgDump(DBG_INT|DBG_READ|DBG_WORK_ITEMS, ("<CancelUsbReadWorkItem 0x%x\n", status ));

   PAGED_CODE(); // we must exit at passive level

   PERF_EXIT( PERF_CancelUsbReadWorkItem );

   return;
}



//
// USB read timeout set on a read packet in UsbRead.
// Runs at DISPATCH_LEVEL.
//
VOID
UsbReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   )
{
   PUSB_PACKET       pPacket = (PUSB_PACKET)DeferredContext;
   PDEVICE_EXTENSION pDevExt = pPacket->DeviceExtension;
   PDEVICE_OBJECT    pDevObj = pDevExt->DeviceObject;
   NTSTATUS status; // = STATUS_TIMEOUT;
   KIRQL irql;
#if DBG
   LARGE_INTEGER currentTime;
#endif

   UNREFERENCED_PARAMETER( PDpc );
   UNREFERENCED_PARAMETER( SystemContext1 );
   UNREFERENCED_PARAMETER( SystemContext2 );

   DbgDump(DBG_INT|DBG_READ, (">UsbReadTimeout\n"));

   if (pPacket && pDevExt && pDevObj) {
      //
      // sync with completion routine putting packet back on list
      //
      KeAcquireSpinLock( &pDevExt->ControlLock, &irql);

      if ( !pPacket || !pPacket->Irp ||
           (STATUS_ALERTED == pPacket->Status) ) {

         status = STATUS_ALERTED;

         DbgDump(DBG_INT|DBG_READ, ("STATUS_ALERTED\n" ));

         KeReleaseSpinLock( &pDevExt->ControlLock, irql );

       } else {
         //
         // queue a passive work item to cancel the USB read irp
         //
         KeReleaseSpinLock( &pDevExt->ControlLock, irql );

#if DBG
         KeQuerySystemTime(&currentTime);
         DbgDump(DBG_INT, ("INT Read Timeout occured in < %I64d msec\n", ((currentTime.QuadPart - pDevExt->LastIntReadTime.QuadPart)/(LONGLONG)10000) ));
#endif

         status = QueueWorkItem( pDevObj,
                                 CancelUsbReadWorkItem,
                                 NULL,
                                 0);
      }

   } else {

      status = STATUS_INVALID_PARAMETER;
      DbgDump(DBG_ERR, ("UsbReadTimeout: 0x%x\n", status ));
      TEST_TRAP();

   }

   DbgDump(DBG_INT|DBG_READ, ("<UsbReadTimeout (0x%x)\n", status ));

   return;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// User read section
//

NTSTATUS
Read(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp)
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status =  STATUS_SUCCESS;
   PIO_STACK_LOCATION pIrpSp;

   PERF_ENTRY( PERF_Read );

   DbgDump(DBG_READ|DBG_TRACE, (">Read (%p, %p)\n", PDevObj, PIrp ));

   if ( !CanAcceptIoRequests( pDevExt->DeviceObject, TRUE, TRUE) ) {

      status = PIrp->IoStatus.Status = STATUS_DELETE_PENDING;

      IoCompleteRequest (PIrp, IO_SERIAL_INCREMENT );

      DbgDump(DBG_ERR, ("Read: 0x%x\n", status ));

      PERF_EXIT( PERF_Read );

      return status;
   }

   //
   // set return values to something known
   //
   PIrp->IoStatus.Information = 0;

   pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   if (pIrpSp->Parameters.Read.Length != 0) {

      status = AcquireRemoveLock(&pDevExt->RemoveLock, PIrp);
      if ( !NT_SUCCESS(status) ) {
         DbgDump(DBG_ERR, ("Read:(0x%x)\n", status));
         PIrp->IoStatus.Status = status;
         IoCompleteRequest(PIrp, IO_NO_INCREMENT);
         return status;
      }

      DbgDump(DBG_READ_LENGTH, ("User Read (%p) length: %d\n", PIrp, pIrpSp->Parameters.Read.Length ));

      status = StartOrQueueIrp( pDevExt,
                                PIrp,
                                &pDevExt->UserReadQueue,
                                &pDevExt->UserReadIrp,
                                StartUserRead);

   } else {

      PIrp->IoStatus.Status = status = STATUS_SUCCESS;
      PIrp->IoStatus.Information = 0;

      IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);
   }

   DbgDump(DBG_READ|DBG_TRACE, ("<Read 0x%x\n", status));

   PERF_EXIT( PERF_Read );

   return status;
}



NTSTATUS
StartOrQueueIrp(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp,
   IN PLIST_ENTRY PQueue,
   IN PIRP *PPCurrentIrp,
   IN PSTART_ROUTINE Starter)
/*++

Routine Description:

    This function is used to either start processing an I/O request or to
    queue it on the appropriate queue if a request is already pending or
    requests may not be started.

Arguments:

    PDevExt       - A pointer to the DeviceExtension.
    PIrp          - A pointer to the IRP that is being started or queued.
    PQueue        - A pointer to the queue to place the IRP on if necessary.
    PPCurrentIrp  - A pointer to the pointer to the currently active I/O IRP.
    Starter       - Function to call if we decide to start this IRP.

Return Value:

    NTSTATUS

--*/
{
   KIRQL    irql;
   NTSTATUS status;

   PERF_ENTRY( PERF_StartOrQueueIrp );

   DbgDump(DBG_READ|DBG_TRACE, (">StartOrQueueIrp (%p, %p)\n", PDevExt->DeviceObject, PIrp ));

   //
   // Make sure the device is accepting request
   //
   if ( !CanAcceptIoRequests( PDevExt->DeviceObject, TRUE, TRUE) ) {

      status = PIrp->IoStatus.Status = STATUS_DELETE_PENDING;

      ReleaseRemoveLock(&PDevExt->RemoveLock, PIrp);

      IoCompleteRequest (PIrp, IO_SERIAL_INCREMENT );

      DbgDump(DBG_ERR, ("StartOrQueueIrp 0x%x\n", status ));

      PERF_EXIT( PERF_StartOrQueueIrp );

      return status;
   }

   KeAcquireSpinLock( &PDevExt->ControlLock, &irql );

   //
   // if nothing is pending then start this new irp
   //
   if (IsListEmpty(PQueue) && (NULL == *PPCurrentIrp)) {

      *PPCurrentIrp = PIrp;

      KeReleaseSpinLock( &PDevExt->ControlLock, irql );

      status = Starter(PDevExt);

      DbgDump(DBG_READ, ("<StartOrQueueIrp 0x%x\n", status ));

      PERF_EXIT( PERF_StartOrQueueIrp );

      return status;
   }

   //
   // We're queueing the irp, so we need a cancel routine -- make sure
   // the irp hasn't already been cancelled.
   //
   if (PIrp->Cancel) {
      //
      // The IRP was apparently cancelled.  Complete it.
      //
      KeReleaseSpinLock( &PDevExt->ControlLock, irql );

      PIrp->IoStatus.Status = STATUS_CANCELLED;

      ReleaseRemoveLock(&PDevExt->RemoveLock, PIrp);

      IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

      DbgDump(DBG_READ|DBG_TRACE, ("<StartOrQueueIrp 0x%x\n", STATUS_CANCELLED ));

      PERF_EXIT( PERF_StartOrQueueIrp );

      return STATUS_CANCELLED;
   }

   //
   // Mark as pending, attach our cancel routine, put on our wait list
   //
   PIrp->IoStatus.Status = STATUS_PENDING;

   IoMarkIrpPending(PIrp);

   InsertTailList(PQueue, &PIrp->Tail.Overlay.ListEntry);

   ASSERT ( !PIrp->CancelRoutine );

   IoSetCancelRoutine(PIrp, CancelQueuedIrp);

   KeReleaseSpinLock( &PDevExt->ControlLock, irql );

   DbgDump(DBG_READ, ("<StartOrQueueIrp 0x%x\n", STATUS_PENDING ));

   PERF_EXIT( PERF_StartOrQueueIrp );

   return STATUS_PENDING;
}



NTSTATUS
StartUserRead(
   IN PDEVICE_EXTENSION PDevExt
   )
/*++

Routine Description:

   This routine processes the active user read request by initializing any timers,
   doing the initial submission to the read state machine, etc.

Arguments:

    PDevExt - Pointer to the device extension for the device to start a read on

Return Value:

    NTSTATUS

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   BOOLEAN bSetStatus = FALSE;
   KIRQL irql;
   PIRP newIrp = NULL;
   ULONG readLen;
   ULONG multiplierVal = 0;
   ULONG constantVal = 0;
   ULONG ulNumberNeededForRead = 0;
   BOOLEAN useTotalTimer = FALSE;
   BOOLEAN returnWithWhatsPresent = FALSE;
   BOOLEAN os2ssreturn = FALSE;
   BOOLEAN crunchDownToOne = FALSE;
   BOOLEAN useIntervalTimer = FALSE;
   SERIAL_TIMEOUTS timeoutsForIrp;
   LARGE_INTEGER totalTime = {0,0};
   BOOLEAN bControlLockReleased = FALSE;

   PERF_ENTRY( PERF_StartUserRead );

   do {

      if ( !PDevExt || !PDevExt->DeviceObject ) {
         DbgDump(DBG_ERR, ("StartUserRead: NO Extension\n"));
         status = STATUS_UNSUCCESSFUL;
         TEST_TRAP();
         break;
      }

      DbgDump(DBG_READ, (">StartUserRead (%p, %p)\n", PDevExt->DeviceObject, PDevExt->UserReadIrp ));

      //
      // get user's read request parameters
      //
      bControlLockReleased = FALSE;
      KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

      // ensure we have a user Irp to play with
      if ( !PDevExt->UserReadIrp ) {
         DbgDump(DBG_ERR, ("StartUserRead: NO UserReadIrp!!\n"));
         KeReleaseSpinLock( &PDevExt->ControlLock, irql);
         status = STATUS_UNSUCCESSFUL;
         TEST_TRAP();
         break;
      }

      // ensure the timers were removed from an earilier read
      if ( KeCancelTimer(&PDevExt->ReadRequestTotalTimer) ||
           KeCancelTimer(&PDevExt->ReadRequestIntervalTimer) )
      {
         DbgDump(DBG_ERR, ("StartUserRead: Timer not cancelled !!\n"));
         TEST_TRAP();
      }

      //
      // Always initialize the timer objects so that the
      // completion code can tell when it attempts to
      // cancel the timers whether the timers had ever
      // been Set.
      //
      KeInitializeTimer(&PDevExt->ReadRequestTotalTimer);
      KeInitializeTimer(&PDevExt->ReadRequestIntervalTimer);

      IRP_SET_REFERENCE(PDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

      readLen = IoGetCurrentIrpStackLocation(PDevExt->UserReadIrp)->Parameters.Read.Length;

      PDevExt->NumberNeededForRead = readLen;
      PDevExt->ReadByIsr = 0;
      DbgDump(DBG_READ|DBG_TIME, ("NumberNeededForRead: %d\n", PDevExt->NumberNeededForRead ));
      DbgDump(DBG_READ|DBG_TIME, ("ReadByIsr: %d\n", PDevExt->ReadByIsr ));

      ASSERT_SERIAL_PORT( PDevExt->SerialPort );

      timeoutsForIrp = PDevExt->SerialPort.Timeouts;
      PDevExt->CountOnLastRead = 0;

      //
      // determine which timeouts we need to calculate for the read
      //
      if (timeoutsForIrp.ReadIntervalTimeout
          && (timeoutsForIrp.ReadIntervalTimeout != MAXULONG)) {

         useIntervalTimer = TRUE;

      }

      if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG) {
         //
         // We need to do special return quickly stuff here.
         //

         //
         // 1) If both constant and multiplier are
         //    0 then we return immediately with whatever
         //    we've got, even if it was zero.
         //
         if (!timeoutsForIrp.ReadTotalTimeoutConstant
             && !timeoutsForIrp.ReadTotalTimeoutMultiplier) {
            returnWithWhatsPresent = TRUE;
         }

         //
         // 2) If constant and multiplier are not MAXULONG
         //    then return immediately if any characters
         //    are present, but if nothing is there, then
         //    use the timeouts as specified.
         //
         else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                    && (timeoutsForIrp.ReadTotalTimeoutMultiplier
                        != MAXULONG)) {
            useTotalTimer = TRUE;
            os2ssreturn = TRUE;
            multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
            constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
         }

         //
         // 3) If multiplier is MAXULONG then do as in
         //    "2" but return when the first character
         //    arrives.
         //
         else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                    && (timeoutsForIrp.ReadTotalTimeoutMultiplier
                        == MAXULONG)) {
            useTotalTimer = TRUE;
            os2ssreturn = TRUE;
            crunchDownToOne = TRUE;
            multiplierVal = 0;
            constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
         }

      } else {
         //
         // If both the multiplier and the constant are
         // zero then don't do any total timeout processing.
         //
         if (timeoutsForIrp.ReadTotalTimeoutMultiplier
             || timeoutsForIrp.ReadTotalTimeoutConstant) {
            //
            // We have some timer values to calculate
            //
            useTotalTimer = TRUE;
            multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
            constantVal   = timeoutsForIrp.ReadTotalTimeoutConstant;
         }
      }

      if (useTotalTimer) {
         ulNumberNeededForRead = PDevExt->NumberNeededForRead;
      }

      // bump total request count
      PDevExt->TtlReadRequests++;

      //
      // see if we have any read data already available
      //
#if defined (USE_RING_BUFF)
      if (PDevExt->RingBuff.CharsInBuff) {
#else
      if (PDevExt->UsbReadBuffChars) {
#endif

#if DBG
         ULONG charsRead =
#endif
         GetUserData( PDevExt,
                     ((PUCHAR)(PDevExt->UserReadIrp->AssociatedIrp.SystemBuffer))
                        + readLen - PDevExt->NumberNeededForRead,
                     PDevExt->NumberNeededForRead,
                     (PULONG)&PDevExt->UserReadIrp->IoStatus.Information );

      } else {

         DbgDump(DBG_READ|DBG_READ_LENGTH, ("No immediate Read data\n"));

      }

      //
      // Try to kick start another USB read.
      //
      if ( START_ANOTHER_USBREAD(PDevExt) ) {

         KeReleaseSpinLock(&PDevExt->ControlLock, irql);

         UsbRead( PDevExt,
                  (BOOLEAN)(PDevExt->IntPipe.hPipe ? TRUE : FALSE) );

         bControlLockReleased = FALSE;
         KeAcquireSpinLock(&PDevExt->ControlLock, &irql);
      }

      if ( !PDevExt->UserReadIrp ) {
         //
         // it's possible that we completed the read Irp already
         // in the above cycle
         //
         DbgDump(DBG_READ, ("UsbReadIrp already completed(1)\n"));

      } else if (returnWithWhatsPresent || (PDevExt->NumberNeededForRead == 0)
          || (os2ssreturn && PDevExt->UsbReadIrp->IoStatus.Information)) {
         //
         // See if this read is complete
         //
         ASSERT( PDevExt->UserReadIrp );
#if DBG
         if ( DebugLevel & DBG_READ_LENGTH)
         {
            ULONG count;

            if (PDevExt->UserReadIrp->IoStatus.Status == STATUS_SUCCESS) {
               count = (ULONG)PDevExt->UserReadIrp->IoStatus.Information;
            } else {
               count = 0;
            }

            KdPrint(("RD3: RL(%d) C(%d) I(%p)\n",
                        IoGetCurrentIrpStackLocation(PDevExt->UserReadIrp)->Parameters.Read.Length,
                        count,
                        PDevExt->UserReadIrp));
         }
#endif
         //
         // Update the amount of chars left in the ring buffer
         //
         PDevExt->UserReadIrp->IoStatus.Status = STATUS_SUCCESS;

         if (!bSetStatus) {
            status = STATUS_SUCCESS;
            bSetStatus = TRUE;
         }

      } else {
         //
         // The irp has the chance to timeout
         //
         IRP_INIT_REFERENCE(PDevExt->UserReadIrp);

         //
         // Check to see if it needs to be cancelled
         //
         if (PDevExt->UserReadIrp->Cancel) {

            PDevExt->UserReadIrp->IoStatus.Status = STATUS_CANCELLED;
            PDevExt->UserReadIrp->IoStatus.Information = 0;

            if (!bSetStatus) {
               bSetStatus = TRUE;
               status = STATUS_CANCELLED;
            }

         } else {
            //
            // If we are supposed to crunch the read down to
            // one character, then update the read length
            // in the irp and truncate the number needed for
            // read down to one.  Note that if we are doing
            // this crunching, then the information must be
            // zero (or we would have completed above) and
            // the number needed for the read must still be
            /// equal to the read length.
            //
            if (crunchDownToOne) {
               PDevExt->NumberNeededForRead = 1;
               IoGetCurrentIrpStackLocation(PDevExt->UserReadIrp)->Parameters.Read.Length = 1;
            }

            IRP_SET_REFERENCE(PDevExt->UserReadIrp, IRP_REF_RX_BUFFER);
            IRP_SET_REFERENCE(PDevExt->UserReadIrp, IRP_REF_CANCEL);

            if (useTotalTimer) {

               CalculateTimeout( &totalTime,
                                 ulNumberNeededForRead,
                                 multiplierVal,
                                 constantVal );

               IRP_SET_REFERENCE(PDevExt->UserReadIrp, IRP_REF_TOTAL_TIMER);

               DbgDump(DBG_READ|DBG_TIME, ("TotalReadTimeout for Irp %p due in %d msec\n", PDevExt->UserReadIrp, (totalTime.QuadPart/10000) ));

               KeSetTimer(&PDevExt->ReadRequestTotalTimer,
                           totalTime,
                          &PDevExt->TotalReadTimeoutDpc);
            }

            if (useIntervalTimer) {

               // relative time. Note we could lose the high order bit here
               PDevExt->IntervalTime.QuadPart = MILLISEC_TO_100NANOSEC( (signed)timeoutsForIrp.ReadIntervalTimeout );

               IRP_SET_REFERENCE(PDevExt->UserReadIrp, IRP_REF_INTERVAL_TIMER);

               KeQuerySystemTime(&PDevExt->LastReadTime);

               DbgDump(DBG_READ|DBG_TIME, ("ReadIntervalTimeout for Irp %p due in %d msec\n", PDevExt->UserReadIrp, (PDevExt->IntervalTime.QuadPart/10000) ));

               KeSetTimer(&PDevExt->ReadRequestIntervalTimer,
                          PDevExt->IntervalTime,
                          &PDevExt->IntervalReadTimeoutDpc);
            }

            //
            // Mark IRP as cancellable
            //
            ASSERT( PDevExt->UserReadIrp );
            IoSetCancelRoutine( PDevExt->UserReadIrp,
                                CancelCurrentRead );

            ASSERT( PDevExt->UserReadIrp );
            IoMarkIrpPending( PDevExt->UserReadIrp );

            bControlLockReleased = TRUE;
            KeReleaseSpinLock(&PDevExt->ControlLock, irql);

            if (!bSetStatus) {
               //
               // At this point the USB Read irp pending as the PDevExt->UsbReadIrp.
               // Either a read timer will fire to complete or cancel the Read,
               // or we hang indefinetly.
               //
               status = STATUS_PENDING;
            }
         }

         DbgDump(DBG_READ, ("<StartUserRead (1) 0x%x\n", status ));

         PERF_EXIT( PERF_StartUserRead );

         return status;
      }

      //
      // kick start the next queued user Read Irp
      //
      bControlLockReleased = TRUE;
      KeReleaseSpinLock(&PDevExt->ControlLock, irql);

      GetNextUserIrp( &PDevExt->UserReadIrp,
                      &PDevExt->UserReadQueue,
                      &newIrp,
                      TRUE,
                      PDevExt);

   } while (newIrp != NULL);

   DbgDump(DBG_READ, ("<StartUserRead (2) 0x%x\n", status ));

   PERF_EXIT( PERF_StartUserRead );

   return status;
}



VOID
GetNextUserIrp(
   IN PIRP *PpCurrentOpIrp,
   IN PLIST_ENTRY PQueueToProcess,
   OUT PIRP *PpNextIrp,
   IN BOOLEAN CompleteCurrent,
   IN PDEVICE_EXTENSION PDevExt
   )
/*++

Routine Description:

    This function gets the next IRP off a queue, marks it as current,
    and possibly completes the current IRP.

Arguments:

    PpCurrentOpIrp    - A pointer to the pointer to the current IRP.
    PQueueToProcess  - A pointer to the queue to get the next IRP from.
    PpNextIrp         - A pointer to the pointer to the next IRP to process.
    CompleteCurrent  - TRUE if we should complete the IRP that is current at
                       the time we are called.
    PDevExt          - A pointer to the device extension.

Return Value:

    NTSTATUS

--*/
{
   KIRQL irql;
   PIRP pOldIrp;

   PERF_ENTRY( PERF_GetNextUserIrp );

   if ( !PpCurrentOpIrp || !PQueueToProcess || !PpNextIrp || !PDevExt ) {
      DbgDump(DBG_ERR, ("GetNextUserIrp: missing parameter\n" ));
      PERF_EXIT( PERF_GetNextUserIrp );
      TEST_TRAP();
      return;
   }

   DbgDump(DBG_IRP|DBG_READ, (">GetNextUserIrp (%p)\n", PDevExt->DeviceObject ));

   KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

   pOldIrp = *PpCurrentOpIrp;

   //
   // Check to see if there is a new irp to start up
   //
   if ( !IsListEmpty(PQueueToProcess) ) {
      PLIST_ENTRY pHeadOfList;

      pHeadOfList = RemoveHeadList(PQueueToProcess);

      *PpCurrentOpIrp = CONTAINING_RECORD(pHeadOfList, IRP,
                                         Tail.Overlay.ListEntry);

      IoSetCancelRoutine(*PpCurrentOpIrp, NULL);

   } else {
      *PpCurrentOpIrp = NULL;
   }

   *PpNextIrp = *PpCurrentOpIrp;

   //
   // Complete the current one if so requested
   //
   if ( pOldIrp && CompleteCurrent ) {

      ASSERT(NULL == pOldIrp->CancelRoutine);

      DbgDump(DBG_IRP|DBG_READ|DBG_READ_LENGTH|DBG_TRACE, ("IoCompleteRequest(1, %p) Status: 0x%x Btyes: %d\n",
                                                pOldIrp, pOldIrp->IoStatus.Status,  pOldIrp->IoStatus.Information ));

      //
      // bump ttl byte counter
      //
      PDevExt->TtlReadBytes += (ULONG)pOldIrp->IoStatus.Information;

      ReleaseRemoveLock(&PDevExt->RemoveLock, pOldIrp);

      KeReleaseSpinLock(&PDevExt->ControlLock, irql);

      IoCompleteRequest(pOldIrp, IO_NO_INCREMENT );

   } else {
      KeReleaseSpinLock(&PDevExt->ControlLock, irql);
   }

   DbgDump(DBG_IRP|DBG_READ, ("Next Irp: %p\n", *PpNextIrp ));

   DbgDump(DBG_IRP|DBG_READ|DBG_TRACE, ("<GetNextUserIrp\n" ));

   PERF_EXIT( PERF_GetNextUserIrp );

   return;
}



VOID
CancelCurrentRead(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   )
/*++

Routine Description:

    This routine is used to cancel the User's current read Irp.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/
{

   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   KIRQL irql;

   PERF_ENTRY( PERF_CancelCurrentRead );

   DbgDump(DBG_READ|DBG_IRP, (">CancelCurrentRead (%p)\n", PDevObj ));

   //
   // we manage our own Irp queue, so release this ASAP
   //
   IoReleaseCancelSpinLock( PIrp->CancelIrql );

    //
    // We set this to indicate to the interval timer
    // that the read has encountered a cancel.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

    pDevExt->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;

    if ( pDevExt->UserReadIrp ) {

       // grab the read irp
       IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

       TryToCompleteCurrentIrp( pDevExt,
                                STATUS_CANCELLED,
                                &pDevExt->UserReadIrp,
                                &pDevExt->UserReadQueue,
                                &pDevExt->ReadRequestIntervalTimer,
                                &pDevExt->ReadRequestTotalTimer,
                                StartUserRead,
                                GetNextUserIrp,
                                IRP_REF_CANCEL,
                                TRUE,
                                irql );

   } else {
      //
      // it is already gone
      //
      DbgDump( DBG_ERR, ("UserReadIrp already gone!\n" ));
      KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      TEST_TRAP();

   }

   DbgDump(DBG_READ|DBG_IRP, ("<CancelCurrentRead\n" ));

   PERF_EXIT( PERF_CancelCurrentRead );

   return;
}



VOID
CancelQueuedIrp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   )
/*++

Routine Description:

    This function is used as a cancel routine for queued irps.
    Basically for us this means the user's Read IRPs.

Arguments:

    PDevObj - A pointer to the serial device object.

    PIrp    - A pointer to the IRP that is being cancelled

Return Value:

    VOID

--*/
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);
   KIRQL irql;

   PERF_ENTRY( PERF_CancelQueuedIrp );

   DbgDump(DBG_READ|DBG_IRP|DBG_TRACE, (">CancelQueuedIrp (%p)\n", PDevObj ));

   //
   // we manage our own Irp queue, so release this ASAP
   //
   IoReleaseCancelSpinLock(PIrp->CancelIrql);

   //
   // The irp was cancelled -- remove it from the queue
   //
   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   PIrp->IoStatus.Status = STATUS_CANCELLED;
   PIrp->IoStatus.Information = 0;

   RemoveEntryList(&PIrp->Tail.Overlay.ListEntry);

   ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

   KeReleaseSpinLock(&pDevExt->ControlLock, irql);

   IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

   DbgDump(DBG_READ|DBG_IRP|DBG_TRACE, ("<CancelQueuedIrp\n" ));

   PERF_EXIT( PERF_CancelQueuedIrp );

   return;
}



VOID
ReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   )
/*++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    PDpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{
   PDEVICE_EXTENSION pDevExt = DeferredContext;
   KIRQL oldIrql;

   PERF_ENTRY( PERF_ReadTimeout );

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(SystemContext1);
   UNREFERENCED_PARAMETER(SystemContext2);

   DbgDump(DBG_TIME, (">ReadTimeout (%p)\n", pDevExt->DeviceObject ));

  KeAcquireSpinLock(&pDevExt->ControlLock, &oldIrql);

   if ( !CanAcceptIoRequests(pDevExt->DeviceObject, FALSE, TRUE) ) {

      TEST_TRAP();

      IRP_CLEAR_REFERENCE( pDevExt->UserReadIrp, IRP_REF_TOTAL_TIMER);

      // manually set the cancel routine
      IoSetCancelRoutine( pDevExt->UserReadIrp,
                          CancelCurrentRead );

      KeReleaseSpinLock(&pDevExt->ControlLock, oldIrql);

      IoCancelIrp(pDevExt->UserReadIrp);

      PERF_EXIT( PERF_ReadTimeout );

      return;
   }

    //
    // We set this to indicate to the interval timer
    // that the read has completed due to total timeout.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

   pDevExt->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

   // grab the read irp
   IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

   DbgDump(DBG_TIME|DBG_READ_LENGTH, ("TotalReadTimeout for (%p)\n", pDevExt->UserReadIrp ));

   TryToCompleteCurrentIrp( pDevExt,
                          STATUS_TIMEOUT,
                          &pDevExt->UserReadIrp,
                          &pDevExt->UserReadQueue,
                          &pDevExt->ReadRequestIntervalTimer,
                          &pDevExt->ReadRequestTotalTimer,
                          StartUserRead,
                          GetNextUserIrp,
                          IRP_REF_TOTAL_TIMER,
                          TRUE,
                          oldIrql );

   DbgDump(DBG_TIME, ("<ReadTimeout\n"));

   PERF_EXIT( PERF_ReadTimeout );

   return;
}



VOID
IntervalReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   )
/*++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    PDpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

   PDEVICE_EXTENSION pDevExt = DeferredContext;
   KIRQL irql;

   PERF_ENTRY( PERF_IntervalReadTimeout );

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(SystemContext1);
   UNREFERENCED_PARAMETER(SystemContext2);

   DbgDump(DBG_TIME, (">IntervalReadTimeout (%p)\n", pDevExt->DeviceObject ));

   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   if ( !pDevExt->UserReadIrp ||
        (IRP_REFERENCE_COUNT(pDevExt->UserReadIrp) & IRP_REF_INTERVAL_TIMER) == 0 ) {
      //
      // we already completed the read irp so just exit
      //
      DbgDump(DBG_TIME|DBG_IRP, ("Already completed User's Read Irp\n"));

      KeReleaseSpinLock(&pDevExt->ControlLock, irql);

      PERF_EXIT( PERF_IntervalReadTimeout );

      return;
   }

   if ( !CanAcceptIoRequests(pDevExt->DeviceObject, FALSE, TRUE) ) {

      IRP_CLEAR_REFERENCE( pDevExt->UserReadIrp, IRP_REF_INTERVAL_TIMER);

      // manually set the cancel routine
      IoSetCancelRoutine( pDevExt->UserReadIrp,
                          CancelCurrentRead );

      KeReleaseSpinLock(&pDevExt->ControlLock, irql);

      IoCancelIrp(pDevExt->UserReadIrp);

      PERF_EXIT( PERF_IntervalReadTimeout );

      return;
   }

   if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) {
      //
      // This value is only set by the total
      // timer to indicate that it has fired.
      // If so, then we should simply try to complete.
      //
      DbgDump(DBG_TIME, ("SERIAL_COMPLETE_READ_TOTAL\n"));

      // grab the read irp
      IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

      pDevExt->CountOnLastRead = 0;

      TryToCompleteCurrentIrp( pDevExt,
                               STATUS_TIMEOUT,
                               &pDevExt->UserReadIrp,
                               &pDevExt->UserReadQueue,
                               &pDevExt->ReadRequestIntervalTimer,
                               &pDevExt->ReadRequestTotalTimer,
                               StartUserRead,
                               GetNextUserIrp,
                               IRP_REF_INTERVAL_TIMER,
                               TRUE,
                               irql );

   } else if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) {
      //
      // This value is only set by the regular completion routine.
      // If so, then we should simply try to complete.
      //
      DbgDump(DBG_TIME|DBG_READ_LENGTH, ("SERIAL_COMPLETE_READ_COMPLETE\n"));

      // grab the read irp
      IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

      pDevExt->CountOnLastRead = 0;

      TryToCompleteCurrentIrp( pDevExt,
                               STATUS_SUCCESS,
                               &pDevExt->UserReadIrp,
                               &pDevExt->UserReadQueue,
                               &pDevExt->ReadRequestIntervalTimer,
                               &pDevExt->ReadRequestTotalTimer,
                               StartUserRead,
                               GetNextUserIrp,
                               IRP_REF_INTERVAL_TIMER,
                               TRUE,
                               irql );

   } else if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) {
      //
      // This value is only set by the cancel
      // read routine.
      //
      // If so, then we should simply try to complete.
      //
      DbgDump(DBG_TIME, ("SERIAL_COMPLETE_READ_CANCEL\n"));

      // grab the read irp
      IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

      pDevExt->CountOnLastRead = 0;

      TryToCompleteCurrentIrp( pDevExt,
                               STATUS_CANCELLED,
                               &pDevExt->UserReadIrp,
                               &pDevExt->UserReadQueue,
                               &pDevExt->ReadRequestIntervalTimer,
                               &pDevExt->ReadRequestTotalTimer,
                               StartUserRead,
                               GetNextUserIrp,
                               IRP_REF_INTERVAL_TIMER,
                               TRUE,
                               irql );

   } else if (pDevExt->CountOnLastRead || pDevExt->ReadByIsr) {
      //
      // Something has happened since we last came here.  We
      // check to see if the ISR has read in any more characters.
      // If it did then we should update the isr's read count
      // and resubmit the timer.
      //
      if (pDevExt->ReadByIsr) {

         DbgDump(DBG_TIME, ("ReadByIsr %d\n", pDevExt->ReadByIsr));

         pDevExt->CountOnLastRead = pDevExt->ReadByIsr;

         pDevExt->ReadByIsr = 0;

         //
         // Save off the "last" time something was read.
         // As we come back to this routine we will compare
         // the current time to the "last" time.  If the
         // difference is ever larger then the interval
         // requested by the user, then time out the request.
         //
         KeQuerySystemTime(&pDevExt->LastReadTime);

         DbgDump(DBG_TIME, ("ReadIntervalTimeout for Irp %p due in %d msec\n", pDevExt->UsbReadIrp, pDevExt->IntervalTime.QuadPart/10000 ));

         KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                    pDevExt->IntervalTime,
                    &pDevExt->IntervalReadTimeoutDpc);

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);

      } else {
         //
         // Take the difference between the current time
         // and the last time we had characters and
         // see if it is greater then the interval time.
         // if it is, then time out the request.  Otherwise
         // restart the timer.
         //

         //
         // No characters read in the interval time.  Kill
         // this read.
         //
         LARGE_INTEGER currentTime;

         KeQuerySystemTime(&currentTime);

         if ((currentTime.QuadPart - pDevExt->LastReadTime.QuadPart) >=
            -(pDevExt->IntervalTime.QuadPart) ) { // absolute time

            DbgDump(DBG_TIME, ("TIMEOUT - CountOnLastRead=%d ReadByIsr=%d\n", pDevExt->CountOnLastRead, pDevExt->ReadByIsr));
#if DBG
            if (pDevExt->ReadByIsr > pDevExt->NumberNeededForRead ) {
               // did we we forgot to clear ReadByIsr
               TEST_TRAP();
            }
#endif
            // grab the read irp
            IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

            pDevExt->CountOnLastRead = pDevExt->ReadByIsr = 0;

            // return any chars read up to this point
            TryToCompleteCurrentIrp( pDevExt,
                                     STATUS_TIMEOUT,
                                     &pDevExt->UserReadIrp,
                                     &pDevExt->UserReadQueue,
                                     &pDevExt->ReadRequestIntervalTimer,
                                     &pDevExt->ReadRequestTotalTimer,
                                     StartUserRead,
                                     GetNextUserIrp,
                                     IRP_REF_INTERVAL_TIMER,
                                     TRUE,
                                     irql );

         } else {

            DbgDump(DBG_TIME, ("ReadIntervalTimeout for Irp %p due in %d msec\n", pDevExt->UsbReadIrp, pDevExt->IntervalTime.QuadPart/10000 ));

            KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                       pDevExt->IntervalTime,
                       &pDevExt->IntervalReadTimeoutDpc);

            KeReleaseSpinLock(&pDevExt->ControlLock, irql);

         }
      }

   } else {
      //
      // Timer doesn't really start until the first character.
      // So we should simply resubmit ourselves.
      //
      DbgDump(DBG_TIME, ("ReadIntervalTimeout for Irp %p due in %d msec\n", pDevExt->UsbReadIrp, pDevExt->IntervalTime.QuadPart/10000 ));

      KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                 pDevExt->IntervalTime,
                 &pDevExt->IntervalReadTimeoutDpc);

      KeReleaseSpinLock(&pDevExt->ControlLock, irql);

   }

   DbgDump(DBG_TIME, ("<IntervalReadTimeout\n"));

   PERF_EXIT( PERF_IntervalReadTimeout );

   return;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\remlock.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    remlock.h

Abstract:

    Common RemoveLock

Authors:

    Jeff Midkiff

Environment:

    kernel mode only

Notes:
    
    Simple binary compatible RemoveLock definitions for Win9x & Win2k
    made to mimic the new Win2k ONLY IoXxxRemoveLock functions.
    See the Win2k DDK for descriptions.

Revision History:

--*/

#include <ntverp.h>
#include <wdm.h>

#if !defined (_REMLOCK_)
#define _REMLOCK_


#if (DBG && WIN2K_LOCKS)

#include "debug.h"

typedef IO_REMOVE_LOCK  REMOVE_LOCK;
typedef PIO_REMOVE_LOCK PREMOVE_LOCK;

__inline VOID InitializeRemoveLock(IN PREMOVE_LOCK Lock) {
    IoInitializeRemoveLock(Lock, 'HECW', 1, 100);
    DbgDump(DBG_LOCKS, ("InitializeRemoveLock: %p, %d\n", Lock, Lock->Common.IoCount));
}

__inline NTSTATUS AcquireRemoveLock(PIO_REMOVE_LOCK Lock, PVOID   Tag)  {
    NTSTATUS status = IoAcquireRemoveLock(Lock, Tag);
    DbgDump(DBG_LOCKS, ("AcquireRemoveLock: %d, %p\n", Lock->Common.IoCount, Tag));
    return status;
}

__inline VOID ReleaseRemoveLock(PIO_REMOVE_LOCK Lock, PVOID   Tag)  {
    IoReleaseRemoveLock(Lock, Tag);
    DbgDump(DBG_LOCKS, ("ReleaseRemoveLock: %d, %p\n", Lock->Common.IoCount, Tag));
}

__inline VOID ReleaseRemoveLockAndWait(PIO_REMOVE_LOCK Lock, PVOID   Tag)  {
    DbgDump(DBG_LOCKS, ("ReleaseRemoveLockAndWait: %d, %p\n", Lock->Common.IoCount, Tag));
    IoReleaseRemoveLockAndWait(Lock, Tag);
}

#else

typedef struct _REMOVE_LOCK {
    
    BOOLEAN     Removed;
    BOOLEAN     Reserved[3];
    LONG        IoCount;
    KEVENT      RemoveEvent;

} REMOVE_LOCK, *PREMOVE_LOCK;

VOID
InitializeRemoveLock(
    IN PREMOVE_LOCK Lock
    );


NTSTATUS
AcquireRemoveLock(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    );


VOID
ReleaseRemoveLock(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    );

    
VOID
ReleaseRemoveLockAndWait(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    );

#endif

#endif // _REMLOCK_

//EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\utils.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

        UTILS.C

Abstract:

        Utility functions 

Environment:

        kernel mode only

Revision History:

        07-15-99  : created

Author:

        Jeff Midkiff (jeffmi)

Notes:

-- */

#include <wdm.h>
#include <stdio.h>
#include <stdlib.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddser.h>

#include "wceusbsh.h"

__inline
VOID
ReuseIrp (
    PIRP Irp,
    NTSTATUS Status
    );

__inline
VOID
RundownIrpRefs(
   IN PIRP *PpCurrentOpIrp, 
   IN PKTIMER IntervalTimer OPTIONAL,
   IN PKTIMER TotalTimer OPTIONAL,
   IN PDEVICE_EXTENSION PDevExt
   );



VOID
TryToCompleteCurrentIrp(
    IN PDEVICE_EXTENSION PDevExt,
    IN NTSTATUS ReturnStatus,
    IN PIRP *PpCurrentIrp,
    IN PLIST_ENTRY PIrpQueue OPTIONAL,
    IN PKTIMER PIntervalTimer OPTIONAL,
    IN PKTIMER PTotalTimer OPTIONAL,
    IN PSTART_ROUTINE PStartNextIrpRoutine OPTIONAL,
    IN PGET_NEXT_ROUTINE PGetNextIrpRoutine OPTIONAL,
    IN LONG ReferenceType,
    IN BOOLEAN CompleteRequest,
    IN KIRQL IrqlForRelease
    )
/*++

Routine Description:

    This routine attempts to rundown all of the reasons there are
    references on the current Irp.  If everything can be killed
    then it will complete this Irp, and then try to start another.

    Similiar to StartIo.

   NOTE: This routine assumes that it is called with the control lock held.

Arguments:

    Extension - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the control lock held.
                     This is the irql that was current when it was acquired.

    ReturnStatus - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{
   PERF_ENTRY( PERF_TryToCompleteCurrentIrp );

   if ( !PDevExt || !PpCurrentIrp || !(*PpCurrentIrp) ) {
      DbgDump(DBG_ERR, ("TryToCompleteCurrentIrp: INVALID PARAMETER\n"));
      KeReleaseSpinLock(&PDevExt->ControlLock, IrqlForRelease);
      PERF_EXIT( PERF_TryToCompleteCurrentIrp );
      TEST_TRAP();
      return;
   }
   
   DbgDump(DBG_IRP|DBG_TRACE, (">TryToCompleteCurrentIrp(%p, 0x%x)\n", *PpCurrentIrp, ReturnStatus));

    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //
    IRP_CLEAR_REFERENCE(*PpCurrentIrp, ReferenceType);
    
    //
    // Try to run down all other references (i.e., Timers) to this irp.
    //
    RundownIrpRefs(PpCurrentIrp, PIntervalTimer, PTotalTimer, PDevExt);

    //
    // See if the ref count is zero after trying to kill everybody else.
    //
    if (!IRP_REFERENCE_COUNT(*PpCurrentIrp)) {
        //
        // The ref count was zero so we should complete this request.
        //
        PIRP pNewIrp;

        DbgDump( DBG_IRP, ("!IRP_REFERENCE_COUNT\n"));

         // set Irp's return status
        (*PpCurrentIrp)->IoStatus.Status = ReturnStatus;

        if (ReturnStatus == STATUS_CANCELLED) {

            (*PpCurrentIrp)->IoStatus.Information = 0;

        }

        if (PGetNextIrpRoutine) {
            //
            // Get the next Irp off the specified Irp queue
            //
            KeReleaseSpinLock(&PDevExt->ControlLock, IrqlForRelease);
            DbgDump( DBG_IRP, ("<< Current IRQL(1)\n"));
           
            DbgDump( DBG_IRP, ("Calling GetNextUserIrp\n"));
            (*PGetNextIrpRoutine)(PpCurrentIrp, PIrpQueue, &pNewIrp, CompleteRequest, PDevExt);

            if (pNewIrp) {
               //
               // There was an Irp in the queue
               //
               DbgDump( DBG_IRP, ("Calling StartNextIrpRoutine\n"));

                //
                // kick-start the next Irp
                //
                PStartNextIrpRoutine(PDevExt);
            }

        } else {
            
            PIRP pOldIrp = *PpCurrentIrp;
            
            //
            // There was no GetNextIrpRoutine.  
            // We will simply complete the Irp.  
            //
            DbgDump( DBG_IRP, ("No GetNextIrpRoutine\n"));
            
            *PpCurrentIrp = NULL;
            
            KeReleaseSpinLock(&PDevExt->ControlLock, IrqlForRelease);
            DbgDump( DBG_IRP, ("<< Current IRQL(2)\n"));
            
            if (CompleteRequest) {
               //
               // complete the Irp
               //
               DbgDump(DBG_IRP|DBG_READ|DBG_READ_LENGTH|DBG_TRACE, ("IoCompleteRequest(2, %p) Status: 0x%x Btyes: %d\n", pOldIrp, pOldIrp->IoStatus.Status,  pOldIrp->IoStatus.Information ));
             
               ReleaseRemoveLock(&PDevExt->RemoveLock, pOldIrp);

               IoCompleteRequest( pOldIrp, IO_NO_INCREMENT );
            }
        }

    } else {
        //
        // Irp still has outstanding references
        //
        DbgDump(DBG_WRN|DBG_IRP|DBG_TRACE, ("Current IRP %p still has reference of %x\n", *PpCurrentIrp,
                  ((UINT_PTR)((IoGetCurrentIrpStackLocation((*PpCurrentIrp))->
                               Parameters.Others.Argument4)))));

        KeReleaseSpinLock(&PDevExt->ControlLock, IrqlForRelease);
        DbgDump( DBG_IRP, ("<< Current IRQL(3)\n"));
    
   }

   DbgDump( DBG_IRP|DBG_TRACE, ("<TryToCompleteCurrentIrp\n"));

   PERF_EXIT( PERF_TryToCompleteCurrentIrp );
   
   return;
}



VOID
RundownIrpRefs(
   IN PIRP *PpCurrentIrp, 
   IN PKTIMER IntervalTimer OPTIONAL,
   IN PKTIMER TotalTimer OPTIONAL,
   IN PDEVICE_EXTENSION PDevExt
   )
/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write Irp.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the control lock held.

Arguments:

    PpCurrentIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

    PDevExt - Pointer to device extension

Return Value:

    None.

--*/
{
   PERF_ENTRY( PERF_RundownIrpRefs );

   if ( !PDevExt || !PpCurrentIrp || !(*PpCurrentIrp) ) {
      DbgDump(DBG_ERR, ("RundownIrpRefs: INVALID PARAMETER\n"));
      PERF_EXIT( PERF_RundownIrpRefs );
      TEST_TRAP();
      return;
   }

   DbgDump(DBG_IRP, (">RundownIrpRefs(%p)\n", *PpCurrentIrp));
   
    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //
    if ((*PpCurrentIrp)->CancelRoutine) {

        IRP_CLEAR_REFERENCE(*PpCurrentIrp, IRP_REF_CANCEL);

        IoSetCancelRoutine(*PpCurrentIrp, NULL);

    }

    if (IntervalTimer) {
        //
        // Try to cancel the operation's interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //
        if (KeCancelTimer(IntervalTimer)) {
            IRP_CLEAR_REFERENCE(*PpCurrentIrp, IRP_REF_INTERVAL_TIMER);
        } else {
            // short circuit the read irp from the interval timer
            DbgDump(DBG_IRP|DBG_TIME, ("clearing IRP_REF_INTERVAL_TIMER on (%p)\n", *PpCurrentIrp ));
            IRP_CLEAR_REFERENCE(*PpCurrentIrp, IRP_REF_INTERVAL_TIMER);
        }
    }

    if (TotalTimer) {
        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //        
        // If we have an escape char event pending, we can't overstuff,
        // so subtract one from the length
        //

        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //
        if (KeCancelTimer(TotalTimer)) {
            IRP_CLEAR_REFERENCE(*PpCurrentIrp, IRP_REF_TOTAL_TIMER);
        }
    }

   DbgDump(DBG_IRP, ("<RundownIrpRefs\n"));

   PERF_EXIT( PERF_RundownIrpRefs );

   return;
}


//
// Recycle the passed in Irp for reuse.
// May be called holding a SpinLock to protect your Irp.
//
VOID
RecycleIrp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP  PIrp
   )
{
   NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;

   PERF_ENTRY( PERF_RecycleIrp );

   DbgDump(DBG_IRP, (">RecycleIrp(%p)\n", PIrp));

   if ( PDevObj && PIrp ) {
      //
      // recycle the Irp
      //
      IoSetCancelRoutine( PIrp, NULL );  

      ReuseIrp( PIrp, STATUS_SUCCESS ); 

      FIXUP_RAW_IRP( PIrp, PDevObj );

   } else {
      DbgDump(DBG_ERR, ("RecycleIrp: INVALID PARAMETER !!\n"));
      TEST_TRAP();
   }

   DbgDump(DBG_IRP, ("<RecycleIrp\n" ));

   PERF_EXIT( PERF_RecycleIrp );

   return;
}


__inline
VOID
ReuseIrp(
   PIRP Irp,
   NTSTATUS Status
   )
/*--

Routine Description:

    This routine is used by drivers to initialize an already allocated IRP for reuse.
    It does what IoInitializeIrp does but it saves the allocation flags so that we know
    how to free the Irp and take care of quote requirements. Call ReuseIrp
    instead of calling IoInitializeIrp to reinitialize an IRP.

Arguments:

    Irp - Pointer to Irp to be reused

    Status - Status to preinitialize the Iostatus field.

--*/
{
    USHORT  PacketSize;
    CCHAR   StackSize;
    UCHAR   AllocationFlags;

    PERF_ENTRY( PERF_ReuseIrp );

    // Did anyone forget to pull their cancel routine?
    ASSERT(Irp->CancelRoutine == NULL) ;

    // We probably don't want thread enqueue'd IRPs to be used
    // ping-pong style as they cannot be dequeue unless they
    // complete entirely. Not really an issue for worker threads,
    // but definitely for operations on application threads.
#if DBG
   if (!g_isWin9x) {
      ASSERT(IsListEmpty(&Irp->ThreadListEntry));
   }
#endif

   AllocationFlags = Irp->AllocationFlags;
   StackSize = Irp->StackCount;
   PacketSize =  IoSizeOfIrp(StackSize);
   IoInitializeIrp(Irp, PacketSize, StackSize);
   Irp->AllocationFlags = AllocationFlags;
   Irp->IoStatus.Status = Status;

   PERF_EXIT( PERF_ReuseIrp );

   return;
}


NTSTATUS
ManuallyCancelIrp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDRIVER_CANCEL pCancelRoutine;
   NTSTATUS status = STATUS_SUCCESS;
   KIRQL irql, cancelIrql;
   BOOLEAN bReleased = FALSE;

   DbgDump(DBG_IRP, (">ManuallyCancelIrp (%p)\n", PIrp ));

   KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

   if ( PIrp ) {
            
        pCancelRoutine = PIrp->CancelRoutine;
        PIrp->Cancel = TRUE;

        //
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.
        //
        if (pCancelRoutine) {

            PIrp->CancelRoutine = NULL;
            PIrp->CancelIrql = irql;

            //
            // This irp is in a cancelable state.  We simply
            // mark it as canceled and manually call the cancel routine.
            //
            bReleased = TRUE;
            KeReleaseSpinLock( &pDevExt->ControlLock, irql );

            IoAcquireCancelSpinLock(&cancelIrql);

            ASSERT(irql == cancelIrql);

            DbgDump(DBG_IRP, ("Invoking Cancel Routine (%p)\n", pCancelRoutine ));

            pCancelRoutine(PDevObj, PIrp);

            //
            // pCancelRoutine releases the cancel lock
            //

         } else {

            DbgDump(DBG_WRN, ("No CancelRoutine on %p\n", PIrp ));

         }

   } else {

      // the Irp could have completed already since we relesed the 
      // spinlock before calling, so call it a success.
      DbgDump(DBG_WRN, ("ManuallyCancelIrp: No Irp!\n"));

   }

   if (!bReleased) {
      KeReleaseSpinLock( &pDevExt->ControlLock, irql );
   }


   DbgDump(DBG_IRP, (">ManuallyCancelIrp 0x%x\n", status ));
   
   return status;
}



//
// Calculates a Serial Timeout in millisec
//
VOID
CalculateTimeout(
   IN OUT PLARGE_INTEGER PTimeOut,
   IN ULONG Length,
   IN ULONG Multiplier,
   IN ULONG Constant
   )
{
   PERF_ENTRY( PERF_CalculateTimeout );
   
   if (PTimeOut) {

      PTimeOut->QuadPart = (LONGLONG)0;

      if (Multiplier) {

         PTimeOut->QuadPart = UInt32x32To64( Length, Multiplier);
      }

      if (Constant) {
         
         PTimeOut->QuadPart += (LONGLONG)Constant;

      }

      //
      // put into (relative) 100-nano second units
      //
      PTimeOut->QuadPart = MILLISEC_TO_100NANOSEC( PTimeOut->QuadPart );
   
   } else {
      TEST_TRAP();
   }

   PERF_EXIT( PERF_CalculateTimeout );
   
   return;
}


// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\usbutils.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

        USBUTILS.C

Abstract:

        USB configuration utility functions.

        These functions are called in the context of PNP_START_DEVICE.
        In order to mark them pageable we don't use a spinlock, 
        which is OK because of the context.

        We do not use look-aside lists to manage pool allocs here since they are one-shot.
        If the allocs fail then the load will fail.

Environment:

        kernel mode only

Revision History:

        07-14-99 : created

Authors:

        Jeff Midkiff (jeffmi)

-- */

#include <wdm.h>
#include <stdio.h>
#include <stdlib.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddser.h>

#include "wceusbsh.h"


NTSTATUS
UsbSelectInterface(
    IN PDEVICE_OBJECT PDevObj,
    IN PUSB_CONFIGURATION_DESCRIPTOR PConfigDesc,
    IN UCHAR AlternateSetting
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWCE1, UsbGetDeviceDescriptor)
#pragma alloc_text(PAGEWCE1, UsbSelectInterface)
#pragma alloc_text(PAGEWCE1, UsbConfigureDevice)
#endif

/*

Sample dump for the Anchor EZ-Link (AN2720) cable:

WCEUSBSH(0): DeviceDescriptor: fbfa8fe8
WCEUSBSH(0): Length 12
WCEUSBSH(0): 
WCEUSBSH(0): Device Descriptor
WCEUSBSH(0): ------------------------
WCEUSBSH(0): bLength         12
WCEUSBSH(0): bDescriptorType 1
WCEUSBSH(0): bcdUSB          100
WCEUSBSH(0): bDeviceClass    ff
WCEUSBSH(0): bDeviceSubClass ff
WCEUSBSH(0): bDeviceProtocol ff
WCEUSBSH(0): bMaxPacketSize0 8
WCEUSBSH(0): idVendor        547
WCEUSBSH(0): idProduct       2720
WCEUSBSH(0): bcdDevice       0
WCEUSBSH(0): iManufacturer   0
WCEUSBSH(0): iProduct        0
WCEUSBSH(0): iSerialNumber   0
WCEUSBSH(0): bNumConfigs     1
WCEUSBSH(0): ------------------------
WCEUSBSH(0): 
WCEUSBSH(0): Configuration Descriptor
WCEUSBSH(0): ----------------
WCEUSBSH(0): bLength             9
WCEUSBSH(0): bDescriptorType     2
WCEUSBSH(0): wTotalLength        d0
WCEUSBSH(0): bNumInterfaces      1
WCEUSBSH(0): bConfigurationValue 1
WCEUSBSH(0): iConfiguration      0
WCEUSBSH(0): bmAttributes        a0
WCEUSBSH(0): MaxPower            32
WCEUSBSH(0): ----------------
WCEUSBSH(0): 
WCEUSBSH(0): Interface Descriptor(0)
WCEUSBSH(0): ------------------------
WCEUSBSH(0): bLength             9
WCEUSBSH(0): bDescriptorType     4
WCEUSBSH(0): bInterfaceNumber    0
WCEUSBSH(0): bAlternateSetting   0
WCEUSBSH(0): bNumEndpoints       2
WCEUSBSH(0): bInterfaceClass     ff
WCEUSBSH(0): bInterfaceSubClass  ff
WCEUSBSH(0): bInterfaceProtocol  ff
WCEUSBSH(0): iInterface          0
WCEUSBSH(0): ------------------------
WCEUSBSH(0): 
WCEUSBSH(0): Interface Definition
WCEUSBSH(0): ------------------------
WCEUSBSH(0): Number of pipes   2
WCEUSBSH(0): Length            38
WCEUSBSH(0): Alt Setting       0
WCEUSBSH(0): Interface Number  0
WCEUSBSH(0): Class             ff
WCEUSBSH(0): Subclass          ff
WCEUSBSH(0): Protocol          ff
WCEUSBSH(0): ------------------------
WCEUSBSH(0): 'COMM' Device Found at Index:0 InterfaceNumber:0 AlternateSetting: 0
WCEUSBSH(0): 
WCEUSBSH(0): Pipe Information (0)
WCEUSBSH(0): ----------------
WCEUSBSH(0): Pipe Type        2
WCEUSBSH(0): Endpoint Addr    82
WCEUSBSH(0): MaxPacketSize    40
WCEUSBSH(0): Interval         0
WCEUSBSH(0): Handle           fbfcef90
WCEUSBSH(0): MaxTransSize     1ffff
WCEUSBSH(0): ----------------
WCEUSBSH(0): 
WCEUSBSH(0): Pipe Information (1)
WCEUSBSH(0): ----------------
WCEUSBSH(0): Pipe Type        2
WCEUSBSH(0): Endpoint Addr    2
WCEUSBSH(0): MaxPacketSize    40
WCEUSBSH(0): Interval         0
WCEUSBSH(0): Handle           fbfcefac
WCEUSBSH(0): MaxTransSize     1ffff
WCEUSBSH(0): ----------------
WCEUSBSH(0): IntPipe: 0 DataOutPipe: fbfcefac DataInPipe: fbfcef90 

*/



NTSTATUS
UsbGetDeviceDescriptor(
    IN PDEVICE_OBJECT PDevObj
    )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status;
   ULONG descSize;
   ULONG urbCDRSize;
   PURB pUrb;

   DbgDump(DBG_USB, (">UsbGetDeviceDescriptor\n"));
   PAGED_CODE();

   urbCDRSize = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);

   pUrb = ExAllocatePool(NonPagedPool, urbCDRSize);

   if (pUrb != NULL) {

      descSize = sizeof(USB_DEVICE_DESCRIPTOR);

      RtlZeroMemory(&pDevExt->DeviceDescriptor, sizeof(USB_DEVICE_DESCRIPTOR));

      UsbBuildGetDescriptorRequest(pUrb,
                                   (USHORT)urbCDRSize,
                                    USB_DEVICE_DESCRIPTOR_TYPE, 
                                    0, 
                                    0,
                                    &pDevExt->DeviceDescriptor,
                                    NULL, 
                                    descSize, 
                                    NULL );

         status = UsbSubmitSyncUrb( PDevObj, pUrb, TRUE, DEFAULT_CTRL_TIMEOUT );
       
         if (STATUS_SUCCESS == status) {
#if DBG        
            if (DebugLevel & DBG_USB) {
               DbgDump(DBG_USB, ("Device Descriptor\n"));
               DbgDump(DBG_USB, ("------------------------\n"));
               DbgDump(DBG_USB, ("bLength         0x%x\n", pDevExt->DeviceDescriptor.bLength));
               DbgDump(DBG_USB, ("bDescriptorType 0x%x\n", pDevExt->DeviceDescriptor.bDescriptorType));
               DbgDump(DBG_USB, ("bcdUSB          0x%x\n", pDevExt->DeviceDescriptor.bcdUSB));
               DbgDump(DBG_USB, ("bDeviceClass    0x%x\n", pDevExt->DeviceDescriptor.bDeviceClass));
               DbgDump(DBG_USB, ("bDeviceSubClass 0x%x\n", pDevExt->DeviceDescriptor.bDeviceSubClass));
               DbgDump(DBG_USB, ("bDeviceProtocol 0x%x\n", pDevExt->DeviceDescriptor.bDeviceProtocol));
               DbgDump(DBG_USB, ("bMaxPacketSize0 0x%x\n", pDevExt->DeviceDescriptor.bMaxPacketSize0));
               DbgDump(DBG_USB, ("idVendor        0x%x\n", pDevExt->DeviceDescriptor.idVendor));
               DbgDump(DBG_USB, ("idProduct       0x%x\n", pDevExt->DeviceDescriptor.idProduct));
               DbgDump(DBG_USB, ("bcdDevice       0x%x\n", pDevExt->DeviceDescriptor.bcdDevice));
               DbgDump(DBG_USB, ("iManufacturer   0x%x\n", pDevExt->DeviceDescriptor.iManufacturer));
               DbgDump(DBG_USB, ("iProduct        0x%x\n", pDevExt->DeviceDescriptor.iProduct));
               DbgDump(DBG_USB, ("iSerialNumber   0x%x\n", pDevExt->DeviceDescriptor.iSerialNumber));
               DbgDump(DBG_USB, ("bNumConfigs     0x%x\n", pDevExt->DeviceDescriptor.bNumConfigurations));
               DbgDump(DBG_USB, ("------------------------\n"));
            }
#endif
         } else {
            DbgDump(DBG_ERR, ("UsbSubmitSyncUrb error: 0x%x\n", status));
            RtlZeroMemory(&pDevExt->DeviceDescriptor, sizeof(USB_DEVICE_DESCRIPTOR));
         }

         ExFreePool(pUrb);

   } else {
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("UsbGetDeviceDescriptor 0x%x\n", status));
   }

   if (STATUS_INSUFFICIENT_RESOURCES == status) {

      LogError( NULL,
                PDevObj, 
                0, 0, 0, 
                ERR_GET_DEVICE_DESCRIPTOR,
                status, 
                SERIAL_INSUFFICIENT_RESOURCES,
                pDevExt->DeviceName.Length + sizeof(WCHAR),
                pDevExt->DeviceName.Buffer,
                0, NULL );
   
   } else if (STATUS_SUCCESS != status ) {
      // handles all other failures
      LogError( NULL,
                PDevObj, 
                0, 0, 0, 
                ERR_GET_DEVICE_DESCRIPTOR,
                status, 
                SERIAL_HARDWARE_FAILURE,
                pDevExt->DeviceName.Length + sizeof(WCHAR),
                pDevExt->DeviceName.Buffer,
                0,
                NULL 
                );
   }
   
   DbgDump(DBG_USB, ("<UsbGetDeviceDescriptor 0x%x\n", status));
   
   return status;
}


//
// BUGBUG: currently assumes 1 interface
//

NTSTATUS
UsbSelectInterface(
    IN PDEVICE_OBJECT PDevObj,
    IN PUSB_CONFIGURATION_DESCRIPTOR PConfigDesc,
    IN UCHAR AlternateSetting
    )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   PURB pUrb = NULL;

   ULONG pipe;
   ULONG index = 0;
   UCHAR interfaceNumber = 0;
   PUSBD_INTERFACE_INFORMATION pInterfaceInfo = NULL;
   BOOLEAN foundCommDevice = FALSE;

   USBD_INTERFACE_LIST_ENTRY interfaceList[2] = {0, 0};

   DbgDump(DBG_USB, (">UsbSelectInterface %d\n", AlternateSetting));
   PAGED_CODE();

   if ( !PDevObj || !PConfigDesc ) {
      status = STATUS_INVALID_PARAMETER;
      DbgDump(DBG_ERR, ("UsbSelectInterface 0x%x\n", status));
      goto SelectInterfaceError;
   }
     
   interfaceList[0].InterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                              PConfigDesc,
                                              PConfigDesc,
                                              -1,
                                              AlternateSetting,
                                              -1,
                                              -1,
                                              -1 );

   if (interfaceList[0].InterfaceDescriptor) {

      // interfaceList[1].InterfaceDescriptor = NULL;

      DbgDump(DBG_USB, ("\n"));
      DbgDump(DBG_USB, ("Interface Descriptor(%d)\n", interfaceNumber ));
      DbgDump(DBG_USB, ("------------------------\n"));
      DbgDump(DBG_USB, ("bLength             0x%x\n", interfaceList[0].InterfaceDescriptor->bLength ));
      DbgDump(DBG_USB, ("bDescriptorType     0x%x\n", interfaceList[0].InterfaceDescriptor->bDescriptorType));
      DbgDump(DBG_USB, ("bInterfaceNumber    0x%x\n", interfaceList[0].InterfaceDescriptor->bInterfaceNumber ));
      DbgDump(DBG_USB, ("bAlternateSetting   0x%x\n", interfaceList[0].InterfaceDescriptor->bAlternateSetting ));
      DbgDump(DBG_USB, ("bNumEndpoints       0x%x\n", interfaceList[0].InterfaceDescriptor->bNumEndpoints ));
      DbgDump(DBG_USB, ("bInterfaceClass     0x%x\n", interfaceList[0].InterfaceDescriptor->bInterfaceClass ));
      DbgDump(DBG_USB, ("bInterfaceSubClass  0x%x\n", interfaceList[0].InterfaceDescriptor->bInterfaceSubClass ));
      DbgDump(DBG_USB, ("bInterfaceProtocol  0x%x\n", interfaceList[0].InterfaceDescriptor->bInterfaceProtocol ));
      DbgDump(DBG_USB, ("iInterface          0x%x\n", interfaceList[0].InterfaceDescriptor->iInterface ));
      DbgDump(DBG_USB, ("------------------------\n"));

     pUrb = USBD_CreateConfigurationRequestEx( PConfigDesc, 
                                               &interfaceList[0]);
        
     if ( pUrb ) {
         //
         // perform any pipe initialization here
         //
         PUSBD_INTERFACE_INFORMATION pInitInterfaceInfo = &pUrb->UrbSelectConfiguration.Interface;

         for ( index = 0; 
               index < interfaceList[0].InterfaceDescriptor->bNumEndpoints;
               index++) {

            pInitInterfaceInfo->Pipes[index].MaximumTransferSize = pDevExt->MaximumTransferSize;
            pInitInterfaceInfo->Pipes[index].PipeFlags = 0; 
         
         }

         status = UsbSubmitSyncUrb(PDevObj, pUrb, TRUE, DEFAULT_CTRL_TIMEOUT );

         if (STATUS_SUCCESS == status) {

            pDevExt->ConfigurationHandle = pUrb->UrbSelectConfiguration.ConfigurationHandle;

            pInterfaceInfo = &pUrb->UrbSelectConfiguration.Interface;

            DbgDump(DBG_USB, ("Interface Definition\n" ));
            DbgDump(DBG_USB, ("------------------------\n"));
            DbgDump(DBG_USB, ("Number of pipes   0x%x\n", pInterfaceInfo->NumberOfPipes));
            DbgDump(DBG_USB, ("Length            0x%x\n", pInterfaceInfo->Length));
            DbgDump(DBG_USB, ("Alt Setting       0x%x\n", pInterfaceInfo->AlternateSetting));
            DbgDump(DBG_USB, ("Interface Number  0x%x\n", pInterfaceInfo->InterfaceNumber));
            DbgDump(DBG_USB, ("Class             0x%x\n", pInterfaceInfo->Class));
            DbgDump(DBG_USB, ("Subclass          0x%x\n", pInterfaceInfo->SubClass));
            DbgDump(DBG_USB, ("Protocol          0x%x\n", pInterfaceInfo->Protocol));
            DbgDump(DBG_USB, ("------------------------\n"));

            if ( (pInterfaceInfo->Class == USB_NULL_MODEM_CLASS) && 
                 (pInterfaceInfo->AlternateSetting == AlternateSetting) && 
                 (pInterfaceInfo->NumberOfPipes)) {

                  foundCommDevice = TRUE;

                  pDevExt->UsbInterfaceNumber = pInterfaceInfo->InterfaceNumber;

            } else {
               status = STATUS_NO_SUCH_DEVICE;
               DbgDump(DBG_ERR, ("UsbSelectInterface 0x%x\n", status));
               goto SelectInterfaceError;
            }

         } else {
            DbgDump(DBG_ERR, ("UsbSubmitSyncUrb 0x%x\n", status));
            goto SelectInterfaceError;
         }
       
      } else {
         status = STATUS_INSUFFICIENT_RESOURCES;
         DbgDump(DBG_ERR, ("USBD_CreateConfigurationRequestEx 0x%x\n", status));
         goto SelectInterfaceError;
      }

      DbgDump(DBG_USB, ("\n"));
      DbgDump(DBG_USB, ("Function Device Found at Index:0x%x InterfaceNumber:0x%x AlternateSetting: 0x%x\n", 
                      interfaceNumber, pDevExt->UsbInterfaceNumber, AlternateSetting));

      //
      // We found the interface we want, now discover the pipes
      // The standard interface is defined to contain 1 bulk read, 1 bulk write, and an optional INT pipe
      // BUGBUG: if there are more endpoints then they will overwrite the previous with this code.
      //
      ASSERT( pInterfaceInfo );
      for ( pipe = 0; pipe < pInterfaceInfo->NumberOfPipes; pipe++) {

         PUSBD_PIPE_INFORMATION pPipeInfo;

         pPipeInfo = &pInterfaceInfo->Pipes[pipe];

         DbgDump(DBG_USB, ("\n"));
         DbgDump(DBG_USB, ("Pipe Information (%d)\n", pipe));
         DbgDump(DBG_USB, ("----------------\n"));
         DbgDump(DBG_USB, ("Pipe Type        0x%x\n", pPipeInfo->PipeType));
         DbgDump(DBG_USB, ("Endpoint Addr    0x%x\n", pPipeInfo->EndpointAddress));
         DbgDump(DBG_USB, ("MaxPacketSize    0x%x\n", pPipeInfo->MaximumPacketSize));
         DbgDump(DBG_USB, ("Interval         0x%x\n", pPipeInfo->Interval));
         DbgDump(DBG_USB, ("Handle           0x%x\n", pPipeInfo->PipeHandle));
         DbgDump(DBG_USB, ("MaxTransSize     0x%x\n", pPipeInfo->MaximumTransferSize));
         DbgDump(DBG_USB, ("----------------\n"));

         //
         // save pipe info in our device extension
         //
         if ( USB_ENDPOINT_DIRECTION_IN( pPipeInfo->EndpointAddress ) ) {
            //
            // Bulk Data In pipe
            //
            if ( USB_ENDPOINT_TYPE_BULK == pPipeInfo->PipeType) {
               //
               // Bulk IN pipe
               //
               pDevExt->ReadPipe.wIndex = pPipeInfo->EndpointAddress;
               pDevExt->ReadPipe.hPipe  = pPipeInfo->PipeHandle;
               pDevExt->ReadPipe.MaxPacketSize = pPipeInfo->MaximumPacketSize;

            } else if ( USB_ENDPOINT_TYPE_INTERRUPT == pPipeInfo->PipeType ) {
               //
               // INT Pipe - alloc a notify buffer for 1 packet
               //
               PVOID pOldBuff = NULL;
               PVOID pNewBuff = NULL;

               pDevExt->IntPipe.MaxPacketSize = pPipeInfo->MaximumPacketSize;
            
               if ( pDevExt->IntPipe.MaxPacketSize ) {

                  pNewBuff = ExAllocatePool( NonPagedPool, pDevExt->IntPipe.MaxPacketSize );

                  if ( !pNewBuff ) {
                     status = STATUS_INSUFFICIENT_RESOURCES;
                     DbgDump(DBG_ERR, ("ExAllocatePool: 0x%x\n", status));
                     goto SelectInterfaceError;
                  }

               } else {
                  DbgDump(DBG_ERR, ("No INT MaximumPacketSize\n"));
                  status = STATUS_NO_SUCH_DEVICE;
                  goto SelectInterfaceError;
               }

               if (pDevExt->IntBuff) {
                  pOldBuff = pDevExt->IntBuff;
                  ExFreePool(pOldBuff);
               }

               pDevExt->IntBuff = pNewBuff;
               pDevExt->IntPipe.hPipe  = pPipeInfo->PipeHandle;
               pDevExt->IntPipe.wIndex = pPipeInfo->EndpointAddress;

               pDevExt->IntReadTimeOut.QuadPart = MILLISEC_TO_100NANOSEC( g_lIntTimout );

            } else {
               DbgDump(DBG_ERR, ("Invalid IN PipeType"));
               status = STATUS_NO_SUCH_DEVICE;
               goto SelectInterfaceError;
            }

         } else if ( USB_ENDPOINT_DIRECTION_OUT( pPipeInfo->EndpointAddress ) ) {
            //
            // OUT EPs
            //
            if ( USB_ENDPOINT_TYPE_BULK == pPipeInfo->PipeType ) {
               //
               // Bulk OUT Pipe
               //
               pDevExt->WritePipe.hPipe  = pPipeInfo->PipeHandle;
               pDevExt->WritePipe.wIndex = pPipeInfo->EndpointAddress;
               pDevExt->WritePipe.MaxPacketSize = pPipeInfo->MaximumPacketSize;

            } else {
               DbgDump(DBG_ERR, ("Invalid OUT PipeType"));
               status = STATUS_NO_SUCH_DEVICE;
               goto SelectInterfaceError;
            }

         } else {
               DbgDump(DBG_ERR, ("Invalid EndpointAddress"));
               status = STATUS_NO_SUCH_DEVICE;
               goto SelectInterfaceError;
         }
      }

      DbgDump(DBG_USB, ("\n"));
      DbgDump(DBG_USB, ("INT Pipe: %p\t OUT Pipe: %p\t IN Pipe: %p\n",
                         pDevExt->IntPipe.hPipe, pDevExt->WritePipe.hPipe, pDevExt->ReadPipe.hPipe ));

   } else {
      DbgDump(DBG_ERR, ("USBD_ParseConfigurationDescriptorEx: No match not found\n"));
      status = STATUS_NO_SUCH_DEVICE;
      goto SelectInterfaceError;
   }

   //
   // did we find all of our pipes?
   //
SelectInterfaceError:

   if ( !foundCommDevice || !pDevExt->ReadPipe.hPipe || !pDevExt->WritePipe.hPipe || (STATUS_SUCCESS != status) ) {
      
        LogError( NULL,
                PDevObj, 
                0, 0, 0, 
                ERR_SELECT_INTERFACE,
                status,
                (status == STATUS_INSUFFICIENT_RESOURCES) ? SERIAL_INSUFFICIENT_RESOURCES : SERIAL_HARDWARE_FAILURE,
                pDevExt->DeviceName.Length + sizeof(WCHAR),
                pDevExt->DeviceName.Buffer,
                0, NULL );

   }

   if ( pUrb ) {
      ExFreePool(pUrb);
   }

   DbgDump(DBG_USB, ("<UsbSelectInterface 0x%x\n", status));

   return status;
}



NTSTATUS
UsbConfigureDevice(
    IN PDEVICE_OBJECT PDevObj
    )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PUSB_CONFIGURATION_DESCRIPTOR pConDesc = NULL;
   NTSTATUS status = STATUS_UNSUCCESSFUL;
   PURB  pUrb = NULL;
   ULONG size;
   ULONG urbCDRSize;
   ULONG numConfigs;
   UCHAR config;

   DbgDump(DBG_USB, (">UsbConfigureDevice\n"));
   PAGED_CODE();

   urbCDRSize = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);

   // configure the device
   pUrb = ExAllocatePool(NonPagedPool, urbCDRSize);
   if (pUrb == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("UsbConfigureDevice ERROR: 0x%x\n", status));
      goto ConfigureDeviceError;
   }

   //
   // there may be problems with the 82930 chip, so make this buffer bigger
   // to prevent choking
   //
   size = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 256;

   //
   // get the number of configurations
   //
   numConfigs = pDevExt->DeviceDescriptor.bNumConfigurations;

   //
   // walk all of the configurations looking for a CDC device
   //
   for (config = 0; config < numConfigs; config++) {

      //
      // we will probably only do this once, maybe twice
      //
      while (TRUE) {

         pConDesc = ExAllocatePool(NonPagedPool, size);

         if (pConDesc == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            DbgDump(DBG_ERR, ("ExAllocatePool: 0x%x\n", status));
            goto ConfigureDeviceError;
         }

         //
         // Get descriptor information from the host controller driver (HCD).
         // All interface, endpoint, class-specific, and vendor-specific descriptors 
         // for the configuration also are retrieved
         //
         UsbBuildGetDescriptorRequest( pUrb, 
                                       (USHORT)urbCDRSize,
                                       USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                       config,  // Index
                                       0,       // LanguageId
                                       pConDesc,// TransferBuffer 
                                       NULL,    // TransferBufferMdl
                                       size,    // TransferBufferLength
                                       NULL);   // Link

         status = UsbSubmitSyncUrb( PDevObj, pUrb, TRUE, DEFAULT_CTRL_TIMEOUT );

         if (status != STATUS_SUCCESS) {
            DbgDump(DBG_ERR, ("UsbSubmitSyncUrb: 0x%x\n", status));
            goto ConfigureDeviceError;
         }

         //
         // see if we got enough data, we may get an error in URB because of
         // buffer overrun
         //
         if ((pUrb->UrbControlDescriptorRequest.TransferBufferLength > 0)
              && (pConDesc->wTotalLength > size)) {

            //
            // size of data exceeds current buffer size, so allocate correct
            // size
            //
            size = pConDesc->wTotalLength;

            ExFreePool(pConDesc);
            pConDesc = NULL;

         } else {
            break;
         }
      }

#if DBG
      DbgDump(DBG_USB, ("\n"));
      DbgDump(DBG_USB, ("Configuration Descriptor\n" ));
      DbgDump(DBG_USB, ("----------------\n"));
      DbgDump(DBG_USB, ("bLength             0x%x\n", pConDesc->bLength ));
      DbgDump(DBG_USB, ("bDescriptorType     0x%x\n", pConDesc->bDescriptorType ));
      DbgDump(DBG_USB, ("wTotalLength        0x%x\n", pConDesc->wTotalLength ));
      DbgDump(DBG_USB, ("bNumInterfaces      0x%x\n", pConDesc->bNumInterfaces ));
      DbgDump(DBG_USB, ("bConfigurationValue 0x%x\n", pConDesc->bConfigurationValue ));
      DbgDump(DBG_USB, ("iConfiguration      0x%x\n", pConDesc->iConfiguration ));
      DbgDump(DBG_USB, ("bmAttributes        0x%x\n", pConDesc->bmAttributes ));
      DbgDump(DBG_USB, ("MaxPower            0x%x\n", pConDesc->MaxPower ));
      DbgDump(DBG_USB, ("----------------\n"));
      DbgDump(DBG_USB, ("\n"));
#endif
      
      status = UsbSelectInterface(PDevObj, pConDesc, (UCHAR)g_ulAlternateSetting);

      ExFreePool(pConDesc);
      pConDesc = NULL;

      //
      // found a config we like
      //
      if (status == STATUS_SUCCESS)
         break;

   } // config

ConfigureDeviceError:

   if (pUrb != NULL) {
      ExFreePool(pUrb);
   }

   if (pConDesc != NULL) {
      ExFreePool(pConDesc);
   }

   if (STATUS_INSUFFICIENT_RESOURCES == status) {

      LogError( NULL,
                PDevObj, 
                0, 0, 0, 
                ERR_CONFIG_DEVICE,
                status, 
                SERIAL_INSUFFICIENT_RESOURCES,
                pDevExt->DeviceName.Length + sizeof(WCHAR),
                pDevExt->DeviceName.Buffer,
                0, NULL );
   
   } else if (STATUS_SUCCESS != status ) {
      // handles all other failures
      LogError( NULL,
                PDevObj, 
                0, 0, 0, 
                ERR_CONFIG_DEVICE,
                status, 
                SERIAL_HARDWARE_FAILURE,
                pDevExt->DeviceName.Length + sizeof(WCHAR),
                pDevExt->DeviceName.Buffer,
                0, NULL );
   }

   DbgDump(DBG_USB, ("<UsbConfigureDevice (0x%x)\n", status));
   
   return status;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\remlock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    remlock.c

Abstract:

    Common RemoveLock

Authors:

    Jeff Midkiff

Environment:

    kernel mode only

Notes:
    
    Simple binary compatible RemoveLock definitions for Win9x & Win2k
    made to mimic the Win2k ONLY IoXxxRemoveLock functions.
    See the Win2k DDK for descriptions.

Revision History:

--*/

#include "remlock.h" 
#include "debug.h"

#if !(DBG && WIN2K_LOCKS)

#pragma alloc_text(PAGEWCE1, InitializeRemoveLock)
#pragma alloc_text(PAGEWCE1, ReleaseRemoveLockAndWait)

VOID
InitializeRemoveLock(
    IN  PREMOVE_LOCK Lock
    )
{
    PAGED_CODE();

    if (Lock) {
        Lock->Removed = FALSE;
        Lock->IoCount = 1;
        KeInitializeEvent( &Lock->RemoveEvent,
                           SynchronizationEvent,
                           FALSE );
        DbgDump(DBG_LOCKS, ("InitializeRemoveLock: %p, %d\n", Lock, Lock->IoCount));
    } else {
        DbgDump(DBG_ERR, ("InitializeRemoveLock: Invalid Parameter\n"));
        TEST_TRAP();
    }
}


NTSTATUS
AcquireRemoveLock(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    )
{
    LONG        ioCount;
    NTSTATUS    status;

    UNREFERENCED_PARAMETER(Tag);

#if DBG
    if (!Lock) {
        status = STATUS_INVALID_PARAMETER;
        DbgDump(DBG_ERR, ("AcquireRemoveLock error: 0x%x\n", status ));
        TEST_TRAP();
    }
#endif

    //
    // Grab the remove lock
    //
    ioCount = InterlockedIncrement( &Lock->IoCount );

    ASSERTMSG("AcquireRemoveLock - lock negative : \n", (ioCount > 0));

    if ( !Lock->Removed ) {

        status = STATUS_SUCCESS;

    } else {

        if (0 == InterlockedDecrement( &Lock->IoCount ) ) {
            KeSetEvent( &Lock->RemoveEvent, 0, FALSE);
        }
        status = STATUS_DELETE_PENDING;
        TEST_TRAP();
    }

    DbgDump(DBG_LOCKS, ("AcquireRemoveLock: %d, %p\n", Lock->IoCount, Tag));

    return status;
}


VOID
ReleaseRemoveLock(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    )
{
    LONG    ioCount;

    UNREFERENCED_PARAMETER(Tag);

#if DBG
    if (!Lock) {
        DbgDump(DBG_ERR, ("ReleaseRemoveLock: Invalid Parameter\n"));
        TEST_TRAP();
    }
#endif

    ioCount = InterlockedDecrement( &Lock->IoCount );

    ASSERT(0 <= ioCount);

    if (0 == ioCount) {

        ASSERT(Lock->Removed);

        TEST_TRAP();

        //
        // The device needs to be removed.  Signal the remove event
        // that it's safe to go ahead.
        //
        KeSetEvent(&Lock->RemoveEvent, IO_NO_INCREMENT, FALSE);

    }

    DbgDump(DBG_LOCKS, ("ReleaseRemoveLock: %d, %p\n", Lock->IoCount, Tag));

    return;
}


VOID
ReleaseRemoveLockAndWait(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    )
{
    LONG    ioCount;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(Tag);

#if DBG
    if (!Lock) {
        DbgDump(DBG_ERR, ("ReleaseRemoveLockAndWait: Invalid Parameter\n"));
        TEST_TRAP();
    }
#endif

    DbgDump(DBG_LOCKS, ("ReleaseRemoveLockAndWait: %d, %p\n", Lock->IoCount, Tag));

    Lock->Removed = TRUE;

    ioCount = InterlockedDecrement( &Lock->IoCount );
    ASSERT (0 < ioCount);

    if (0 < InterlockedDecrement( &Lock->IoCount ) ) {
    
        DbgDump(DBG_LOCKS, ("ReleaseRemoveLockAndWait: waiting for %d IoCount...\n", Lock->IoCount));
        
        // BUGBUG: may want a timeout here inside a loop
        KeWaitForSingleObject( &Lock->RemoveEvent, 
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        DbgDump(DBG_LOCKS, ("....ReleaseRemoveLockAndWait: done!\n"));
    }

    return;
}

#endif // !(DBG && WIN2K_LOCKS)

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\usbio.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

        USBIO.C

Abstract:

        USB I/O functions

Environment:

        kernel mode only


Revision History:

        07-14-99 : created

Authors:

       Jeff Midkiff  (jeffmi)

-- */

#include <wdm.h>
#include <stdio.h>
#include <stdlib.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddser.h>

#include "wceusbsh.h"


NTSTATUS
UsbSubmitSyncUrbCompletion(
    IN PDEVICE_OBJECT PDevObj,
    IN PIRP PIrp,
    IN PKEVENT PSyncEvent
    )
/*++

Routine Description:


Arguments:

    PDevObj - Pointer to Device Object
    PIrp - Pointer to IRP that is being completed
    PSyncEvent - Pointer to event that we should set

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
   UNREFERENCED_PARAMETER( PDevObj );
   UNREFERENCED_PARAMETER( PIrp );

   DbgDump(DBG_USB, (">UsbSubmitSyncUrbCompletion (%p)\n", PIrp) );

   ASSERT( PSyncEvent );
   KeSetEvent( PSyncEvent, IO_NO_INCREMENT, FALSE );

   DbgDump(DBG_USB, ("<UsbSubmitSyncUrbCompletion 0x%x\n", PIrp->IoStatus.Status ) );

   // our driver owns and releases the irp
   return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
UsbSubmitSyncUrb(
   IN PDEVICE_OBJECT    PDevObj,
   IN PURB              PUrb,
   IN BOOLEAN           Configuration,
   IN LONG              TimeOut
   )
/*++

Routine Description:

    This routine issues a synchronous URB request to the USBD.

Arguments:

    PDevObj - Ptr to our FDO

    PUrb - URB to pass

    Configuration - special case to allow USB config transactions onto the bus.
        We need to do this because a) if the device was removed then we can stall the controller
        which results in a reset kicking anything off the bus and re-enumerating the bus.
        b) to trap any cases of suprise removal from numerous paths

    TimeOut - timeout in milliseconds

Note: runs at PASSIVE_LEVEL.

Return Value:

    NTSTATUS - propogates status from USBD

--*/
{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    IO_STATUS_BLOCK ioStatus = {0, 0};
    PIO_STACK_LOCATION pNextIrpSp;
    KEVENT event;
    NTSTATUS status, wait_status;
    PIRP pIrp;

    PAGED_CODE();

    DbgDump(DBG_USB|DBG_TRACE, (">UsbSubmitSyncUrb\n") );

    if ( !PUrb || !pDevExt->NextDevice ) {
        status = STATUS_INVALID_PARAMETER;
        DbgDump(DBG_ERR, ("UsbSubmitSyncUrb.1: 0x%x\n", status));
        TEST_TRAP();
        return status;
    }

    if ( !Configuration && !CanAcceptIoRequests(PDevObj, TRUE, TRUE) ) {
        status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("UsbSubmitSyncUrb.2: 0x%x\n", status));
        return status;
    }

    // we need to grab the lock here to keep it's IoCount correct
    status = AcquireRemoveLock(&pDevExt->RemoveLock, PUrb);
    if ( !NT_SUCCESS(status) ) {
        DbgDump(DBG_ERR, ("UsbSubmitSyncUrb.3: 0x%x\n", status));
        return status;
    }

    DbgDump(DBG_USB, (">UsbSubmitSyncUrb (%p, %p)\n", PDevObj, PUrb) );

    pIrp = IoAllocateIrp( (CCHAR)(pDevExt->NextDevice->StackSize + 1), FALSE);

    if ( pIrp ) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        RecycleIrp( PDevObj, pIrp);

        IoSetCompletionRoutine(pIrp,
                               UsbSubmitSyncUrbCompletion,
                               &event,  // Context
                               TRUE, TRUE, TRUE );

        pNextIrpSp = IoGetNextIrpStackLocation(pIrp);
        ASSERT(pNextIrpSp);
        pNextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        pNextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
        pNextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
        pNextIrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;

        pNextIrpSp->Parameters.Others.Argument1 = PUrb;

        status = IoCallDriver( pDevExt->NextDevice, pIrp );

        if (STATUS_PENDING == status ) {
            //
            // Set a default timeout in case the hardware is flakey, so USB will not hang us.
            // We may want these timeouts user configurable via registry.
            //
            LARGE_INTEGER timeOut;

            ASSERT(TimeOut >= 0);
            timeOut.QuadPart = MILLISEC_TO_100NANOSEC( (TimeOut == 0 ? DEFAULT_PENDING_TIMEOUT : TimeOut) );

            wait_status = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, &timeOut );

            if (STATUS_TIMEOUT == wait_status) {
                //
                // The wait timed out, try to cancel the Irp.
                // N.B: if you freed the Irp in the completion routine
                // then you have a race condition between the completion routine freeing the Irp
                // and the timer firing where we need to set the cancel bit.
                //
                DbgDump(DBG_USB|DBG_WRN, ("UsbSubmitSyncUrb: STATUS_TIMEOUT\n"));

                if ( !IoCancelIrp(pIrp) ) {
                    //
                    // This means USB has the Irp in a non-canceable state.
                    //
                    DbgDump(DBG_ERR, ("!IoCancelIrp(%p)\n", pIrp));
                    TEST_TRAP();
                }

                //
                // Wait for our completion routine, to see if the Irp completed normally or actually cancelled.
                // An alternative could be alloc an event & status block, stored in the Irp
                // strung along a list, which would also get freed in the completion routine...
                // which creates other problems not worth the effort for an exit condition.
                //
                wait_status = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL );
            }
        }

        //
        // The completion routine signalled the event and completed,
        // and our the timer has expired. Now we can safely free the Irp.
        //
        status = pIrp->IoStatus.Status;

#if DBG
        if (STATUS_SUCCESS != status) {
            DbgDump(DBG_ERR, ("UsbSubmitSyncUrb IrpStatus: 0x%x UrbStatus: 0x%x\n", status, PUrb->UrbHeader.Status) );
        }
#endif

        IoFreeIrp( pIrp );

    } else {
        DbgDump(DBG_ERR, ("IoAllocateIrp failed!\n") );
        status = STATUS_INSUFFICIENT_RESOURCES;
        TEST_TRAP();
    }

    ReleaseRemoveLock(&pDevExt->RemoveLock, PUrb);

    DbgDump(DBG_USB|DBG_TRACE, ("<UsbSubmitSyncUrb (0x%x)\n", status) );

    return status;
}


NTSTATUS
UsbClassVendorCommand(
   IN PDEVICE_OBJECT PDevObj,
   IN UCHAR  Request,
   IN USHORT Value,
   IN USHORT Index,
   IN PVOID  Buffer,
   IN OUT PULONG BufferLen,
   IN BOOLEAN Read,
   IN ULONG   Class
   )
/*++

Routine Description:

   Issue class or vendor specific command

Arguments:

   PDevObj      - pointer to a your object
   Request      - request field of class/vendor specific command
   Value        - value field of class/vendor specific command
   Index        - index field of class/vendor specific command
   Buffer       - pointer to data buffer
   BufferLen    - data buffer length
   Read         - data direction flag
   Class        - True if Class Command, else vendor command

Return Value:
    NTSTATUS

--*/
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status;
   PURB     pUrb;
   ULONG    ulSize;
   ULONG    ulLength;

   PAGED_CODE();

   DbgDump(DBG_USB, (">UsbClassVendorCommand\n" ));

   ulLength = BufferLen ? *BufferLen : 0;

   ulSize = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

   pUrb = ExAllocateFromNPagedLookasideList( &pDevExt->VendorRequestUrbPool );

   if (pUrb) {

      UsbBuildVendorRequest( pUrb,
                             Class == WCEUSB_CLASS_COMMAND ? URB_FUNCTION_CLASS_INTERFACE : URB_FUNCTION_VENDOR_DEVICE,
                             (USHORT)ulSize,
                             Read ? USBD_TRANSFER_DIRECTION_IN : USBD_TRANSFER_DIRECTION_OUT,
                             0,
                             Request,
                             Value,
                             Index,
                             Buffer,
                             NULL,
                             ulLength,
                             NULL);

      status = UsbSubmitSyncUrb(PDevObj, pUrb, FALSE, DEFAULT_CTRL_TIMEOUT);

      if (BufferLen)
         *BufferLen = pUrb->UrbControlVendorClassRequest.TransferBufferLength;

      ExFreeToNPagedLookasideList( &pDevExt->VendorRequestUrbPool, pUrb );

   } else {
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("ExAllocatePool error: 0x%x\n", status));
      TEST_TRAP();
   }

   DbgDump(DBG_USB, ("<UsbClassVendorCommand (0x%x)\n", status));

   return status;
}



/////////////////////////////////////////////////////////////////////////
//
//    Usb Read / Write Utils
//

NTSTATUS
UsbReadWritePacket(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp,
   IN PIO_COMPLETION_ROUTINE CompletionRoutine,
   IN LARGE_INTEGER TimeOut,
   IN PKDEFERRED_ROUTINE TimeoutRoutine,
   IN BOOLEAN Read
   )
/*++

Routine Description:

    This function allocates and passes a Bulk Transfer URB Request
    down to USBD to perform a Read/Write. Note that the Packet
    MUST freed (put back on the packet list) in the
    CompletionRoutine.

Arguments:

    PDevExt - Pointer to device extension

    PIrp    - Read/Write IRP

    CompletionRoutine - completion routine to set in the Irp

    TimeOut - Timeout value for packet. If no timeout is
      specified the we use a default timeout.

    Read - TRUE for Read, else Write

Return Value:

    NTSTATUS

Notes:

   This is not currently documented in the DDK, so here 's what
   happens:

   We pass the Irp to USBD. USBD parameter checks the Irp.
   If any parameters are invalid then USBD returns an NT status code
   and Urb status code, then the Irp goes to our completion routine.
   If there are no errors then USBD passes Irp to HCD. HCD queues the
   Irp to it's StartIo & and returns STATUS_PENDING.  When HCD finishes
   the (DMA) transfer it completes the Irp, setting the Irp & Urb status
   fields. USBD's completion routine gets the Irp, translates any HCD
   error codes, completes it, which percolates it back up to our
   completion routine.

   Note: HCD uses DMA & therefore MDLs. Since this client driver
   currently uses METHOD_BUFFERED, then USBD allocates an MDL for
   HCD. So you have the I/O manager double bufffering the data
   and USBD mapping MDLs. What the hell, we have to buffer user reads
   too... uggh. Note that if you change to method direct then
   the read path gets nastier.

   Note: when the user submits a write buffer > MaxTransferSize
   then we reject the buffer.

--*/
{
   PIO_STACK_LOCATION pIrpSp;
   PUSB_PACKET   pPacket;
   NTSTATUS status;
   KIRQL irql; //, cancelIrql;
   PURB  pUrb;
   PVOID pvBuffer;
   ULONG ulLength;
   USBD_PIPE_HANDLE hPipe;

   PERF_ENTRY( PERF_UsbReadWritePacket );

   DbgDump(DBG_USB, (">UsbReadWritePacket (%p, %p, %d, %d)\n", PDevExt->DeviceObject, PIrp, TimeOut.QuadPart/10000, Read));


   if ( !PDevExt || !PIrp || !CompletionRoutine ) {

      status = PIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
      DbgDump(DBG_ERR, ("<UsbReadWritePacket 0x%x\n", status));
      KeAcquireSpinLock( &PDevExt->ControlLock, &irql );

      TryToCompleteCurrentIrp(
               PDevExt,
               status,
               &PIrp,
                NULL,               // Queue
                NULL,               // IntervalTimer
                NULL,               // PTotalTimer
                NULL,               // Starter
                NULL,               // PGetNextIrp
                IRP_REF_RX_BUFFER,  // RefType
                (BOOLEAN)(!Read),
                irql  ); // Complete

      PERF_EXIT( PERF_UsbReadWritePacket );
      TEST_TRAP();
      return status;
   }

   IRP_SET_REFERENCE(PIrp, IRP_REF_RX_BUFFER);

   pIrpSp = IoGetCurrentIrpStackLocation(PIrp);
   ASSERT( pIrpSp );

   //
   // Allocate & Build a USB Bulk Transfer Request (Packet)
   //
   pPacket = ExAllocateFromNPagedLookasideList( &PDevExt->PacketPool );

   if ( !pPacket ) {

      status = PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("<UsbReadWritePacket 0x%x\n", status));
      KeAcquireSpinLock( &PDevExt->ControlLock, &irql );

      TryToCompleteCurrentIrp(
               PDevExt,
               status,
               &PIrp,
                NULL,               // Queue
                NULL,               // IntervalTimer
                NULL,               // PTotalTimer
                NULL,               // Starter
                NULL,               // PGetNextIrp
                IRP_REF_RX_BUFFER,  // RefType
                (BOOLEAN)(!Read),
                irql );

      PERF_EXIT( PERF_UsbReadWritePacket );
      TEST_TRAP();
      return status;
   }

   //
   // init the Packet
   //
   RtlZeroMemory( pPacket, sizeof(USB_PACKET) );

   pPacket->DeviceExtension = PDevExt;

   pPacket->Irp = PIrp;

   pUrb = &pPacket->Urb;
   ASSERT( pUrb );

   KeAcquireSpinLock( &PDevExt->ControlLock, &irql );


   if (Read) {
      //
      // store the Urb for buffered reads
      //
      PDevExt->UsbReadUrb = pUrb;
   }

   //
   // Build the URB.
   // Note: HCD breaks up our buffer into Transport Descriptors (TD)
   // of PipeInfo->MaxPacketSize.
   // Q: does USBD/HCD look at the PipeInfo->MaxTransferSize to see
   // if he can Rx/Tx?
   // A: Yes. HCD will return urbStatus = USBD_STATUS_INVALID_PARAMETER
   // and status = STATUS_INVALID_PARAMETER of too large.
   //
   ASSERT( Read ? (PDevExt->UsbReadBuffSize <= PDevExt->MaximumTransferSize ) :
                  (pIrpSp->Parameters.Write.Length <= PDevExt->MaximumTransferSize ) );

   //
   // Note: Reads are done into our local USB read buffer,
   // and then copied into the user's buffer on completion.
   // Writes are done directly from user's buffer.
   // We allow NULL writes to indicate end of a USB transaction.
   //
   pvBuffer = Read ? PDevExt->UsbReadBuff :
                     PIrp->AssociatedIrp.SystemBuffer;

   ulLength = Read ? PDevExt->UsbReadBuffSize :
                     pIrpSp->Parameters.Write.Length;

   hPipe = Read ? PDevExt->ReadPipe.hPipe :
                 PDevExt->WritePipe.hPipe;

   ASSERT( hPipe );

   UsbBuildTransferUrb(
            pUrb,       // Urb
            pvBuffer,   // Buffer
            ulLength,   // Length
            hPipe,       // PipeHandle
            Read        // ReadRequest
            );

   //
   // put the packet on a pending list
   //
   InsertTailList( Read ? &PDevExt->PendingReadPackets : // ListHead,
                          &PDevExt->PendingWritePackets,
                   &pPacket->ListEntry );                // ListEntry

   //
   // Increment the pending packet counter
   //
   InterlockedIncrement( Read ? &PDevExt->PendingReadCount:
                                &PDevExt->PendingWriteCount );

   //
   // Setup Irp for submit Urb IOCTL
   //
   IoCopyCurrentIrpStackLocationToNext(PIrp);

   pIrpSp = IoGetNextIrpStackLocation(PIrp);

   pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

   pIrpSp->Parameters.Others.Argument1 = pUrb;

   pIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

   IoSetCompletionRoutine( PIrp,
                           CompletionRoutine,
                           pPacket,          // Context
                           TRUE, TRUE, TRUE);
   //
   // Initialize and Arm the Packet's Timer.
   // If the Timer fires then the packet's Timeout routine runs.
   //
   KeInitializeTimer( &pPacket->TimerObj );

   if ( 0 != TimeOut.QuadPart ) {

      pPacket->Timeout = TimeOut;

      ASSERT( TimeoutRoutine );

      pPacket->TimerDPCRoutine = TimeoutRoutine;

      KeInitializeDpc( &pPacket->TimerDPCObj,      // DPC Object
                       pPacket->TimerDPCRoutine,   // DPC Routine
                       pPacket );                  // Context

      DbgDump(DBG_USB, ("Timer for Irp %p due in %d msec\n", pPacket->Irp, pPacket->Timeout.QuadPart/10000 ));

      KeSetTimer( &pPacket->TimerObj,      // TimerObj
                  pPacket->Timeout,        // DueTime
                  &pPacket->TimerDPCObj    // DPC Obj
                  );

   }

   //
   // pass the Irp to USBD
   //
   DbgDump(DBG_IRP, ("UsbReadWritePacket IoCallDriver with %p\n", PIrp));

   KeReleaseSpinLock( &PDevExt->ControlLock, irql );

   status = IoCallDriver( PDevExt->NextDevice, PIrp );

   if ( (STATUS_SUCCESS != status) && (STATUS_PENDING != status) ) {
      //
      // We end up here after our completion routine runs
      // for an error condition i.e., when we have and
      // invalid parameter, or when user pulls the plug, etc.
      //
      DbgDump(DBG_ERR, ("UsbReadWritePacket error: 0x%x\n", status));
   }

   DbgDump(DBG_USB , ("<UsbReadWritePacket 0x%x\n", status));

   PERF_EXIT( PERF_UsbReadWritePacket );

   return status;
}



//
// This routine sets up a PUrb for a _URB_BULK_OR_INTERRUPT_TRANSFER.
// It assumes it's called holding a SpinLock.
//
VOID
UsbBuildTransferUrb(
    PURB PUrb,
    PUCHAR PBuffer,
    ULONG Length,
    IN USBD_PIPE_HANDLE PipeHandle,
    IN BOOLEAN Read
    )
{
   ULONG size;

   ASSERT( PUrb );
   ASSERT( PipeHandle );

   size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

   RtlZeroMemory(PUrb, size);

   PUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)size;

   PUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;

   PUrb->UrbBulkOrInterruptTransfer.Hdr.Status = USBD_STATUS_SUCCESS;

   PUrb->UrbBulkOrInterruptTransfer.PipeHandle = PipeHandle;

   //
   // we are using a tranfsfer buffer instead of an MDL
   //
   PUrb->UrbBulkOrInterruptTransfer.TransferBuffer = PBuffer;

   PUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = Length;

   PUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;

   //
   // Set transfer flags
   //
   PUrb->UrbBulkOrInterruptTransfer.TransferFlags |= Read ? USBD_TRANSFER_DIRECTION_IN : USBD_TRANSFER_DIRECTION_OUT;

   //
   // Short transfer is not treated as an error.
   // If USBD_TRANSFER_DIRECTION_IN is set,
   // directs the HCD not to return an error if a packet is received from the device
   // shorter than the maximum packet size for the endpoint.
   // Otherwise, a short request is returns an error condition.
   //
   PUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;

   //
   // no linkage for now
   //
   PUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

   return;
}


/////////////////////////////////////////////////////////////////////////
//
//    Usb Reset Utils
//
VOID
UsbResetOrAbortPipeWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   )
{
    PDEVICE_OBJECT    pDevObj = PWorkItem->DeviceObject;
    PDEVICE_EXTENSION pDevExt = pDevObj->DeviceExtension;

    UCHAR    retries = 0;
    ULONG    ulUniqueErrorValue = 0;
    NTSTATUS status = STATUS_DELETE_PENDING;

    DbgDump(DBG_WORK_ITEMS, (">UsbResetOrAbortPipeWorkItem (0x%x)\n", pDevObj));

    //
    // The work item was queued at IRQL > PASSIVE some time ago from an I/O completion routine.
    // If we are unsuccessful after max retries then stop taking I/O requests & assume the device is broken
    //
    if ( CanAcceptIoRequests(pDevObj, TRUE, TRUE) )
    {
        switch (PWorkItem->Flags)
        {
            case WORK_ITEM_RESET_READ_PIPE:
            {
                DbgDump(DBG_WORK_ITEMS, ("WORK_ITEM_RESET_READ_PIPE\n"));

                if ( pDevExt->ReadDeviceErrors < g_ulMaxPipeErrors)
                {
                   //
                   // reset read Pipe, which could fail.
                   // E.g. flakey h/w, suprise remove, timeout, ...
                   //
                   status = UsbResetOrAbortPipe( pDevObj, &pDevExt->ReadPipe, RESET );

                   switch (status)
                   {
                       case STATUS_SUCCESS:
                       {
                          //
                          // kick start another read
                          //
                          status = UsbRead( pDevExt,
                                           (BOOLEAN)(pDevExt->IntPipe.hPipe ? TRUE : FALSE) );

                          if ( (STATUS_SUCCESS == status) || (STATUS_PENDING == status) ) {
                             //
                             // the device recovered OK
                             //
                             status = STATUS_SUCCESS;

                          } else {
                             DbgDump(DBG_ERR, ("UsbRead error: 0x%x\n", status));
                          }

                       } break;

                       case STATUS_UNSUCCESSFUL:
                       // a previous reset/abort request failed, so this request was rejected
                       break;

                       case STATUS_DELETE_PENDING:
                       // the device is going away
                       break;

                       case STATUS_PENDING:
                       // there is a reset/abort request already pending
                       break;

                       default:
                       {
                          //
                          // if we can not reset the endpoint the device is hosed or removed
                          //
                          DbgDump(DBG_ERR, ("UsbResetOrAbortPipeWorkItem.1 error: 0x%x\n", status ));
                          retries = 1;
                          ulUniqueErrorValue = ERR_NO_READ_PIPE_RESET;
                       } break;

                    } // status

                } else {
                    status = (NTSTATUS)PtrToLong(PWorkItem->Context); // Urb status is stored here
                    retries = (UCHAR)pDevExt->ReadDeviceErrors;
                    ulUniqueErrorValue = ERR_MAX_READ_PIPE_DEVICE_ERRORS;
                }

                if ( USBD_STATUS_BUFFER_OVERRUN == (USBD_STATUS)PtrToLong(PWorkItem->Context)) {
                    LogError( NULL,
                             pDevObj,
                             0, 0,
                             (UCHAR)pDevExt->ReadDeviceErrors,
                             ERR_USB_READ_BUFF_OVERRUN,
                             (USBD_STATUS)PtrToLong(PWorkItem->Context),
                             SERIAL_USB_READ_BUFF_OVERRUN,
                             pDevExt->DeviceName.Length + sizeof(WCHAR),
                             pDevExt->DeviceName.Buffer,
                             0, NULL );
                }
            } // WORK_ITEM_RESET_READ_PIPE
            break;


            case WORK_ITEM_RESET_WRITE_PIPE:
            {
                DbgDump(DBG_WORK_ITEMS, ("WORK_ITEM_RESET_WRITE_PIPE\n"));

                if (pDevExt->WriteDeviceErrors < g_ulMaxPipeErrors)
                {
                   //
                   // reset write Pipe, which could fail.
                   // E.g. flakey h/w, suprise remove, timeout, ...
                   //
                   status = UsbResetOrAbortPipe( pDevObj, &pDevExt->WritePipe, RESET );

                   switch (status)
                   {
                       case STATUS_SUCCESS:
                       // the device recovered OK
                       break;

                       case STATUS_UNSUCCESSFUL:
                       // a previous reset/abort request failed, so this request was rejected
                       break;

                       case STATUS_DELETE_PENDING:
                       // the device is going away
                       break;

                       case STATUS_PENDING:
                       // there is a reset/abort request already pending
                       break;

                       default: {
                          //
                          // if we can not reset the endpoint the device is hosed or removed
                          //
                          DbgDump(DBG_ERR, ("UsbResetOrAbortPipeWorkItem.2 error: 0x%x\n", status ));
                          retries = 1;
                          ulUniqueErrorValue = ERR_NO_WRITE_PIPE_RESET;
                       } break;

                    } // status

                } else {
                    status = (NTSTATUS)PtrToLong(PWorkItem->Context);
                    retries = (UCHAR)pDevExt->WriteDeviceErrors;
                    ulUniqueErrorValue = ERR_MAX_WRITE_PIPE_DEVICE_ERRORS;
                }

            } // WORK_ITEM_RESET_WRITE_PIPE
            break;


            case WORK_ITEM_RESET_INT_PIPE:
            {
                DbgDump(DBG_WORK_ITEMS, ("WORK_ITEM_RESET_INT_PIPE\n"));

                if ( pDevExt->IntDeviceErrors < g_ulMaxPipeErrors)
                {
                   //
                   // reset INT Pipe, which could fail.
                   // E.g. flakey h/w, suprise remove, timeout, ...
                   //
                   status = UsbResetOrAbortPipe( pDevObj, &pDevExt->IntPipe, RESET );

                   switch (status)
                   {
                       case STATUS_SUCCESS:
                       {
                          //
                          // kick start another INT read
                          //
                          status = UsbInterruptRead( pDevExt );

                          if ((STATUS_SUCCESS == status) || (STATUS_PENDING == status) ) {
                             //
                             // the device recovered OK
                             //
                             status = STATUS_SUCCESS;

                          } else {
                             DbgDump(DBG_ERR, ("UsbInterruptRead error: 0x%x\n", status));
                          }

                       } break;

                       case STATUS_UNSUCCESSFUL:
                       // a previous reset/abort request failed, so this request was rejected
                       break;

                       case STATUS_DELETE_PENDING:
                       // the device is going away
                       break;

                       case STATUS_PENDING:
                       // there is a reset/abort request already pending
                       break;

                       default:
                       {
                          //
                          // if we can not reset the endpoint the device is either hosed or removed
                          //
                          DbgDump(DBG_ERR, ("UsbResetOrAbortPipeWorkItem.3 error: 0x%x\n", status ));
                          retries = 1;
                          ulUniqueErrorValue = ERR_NO_INT_PIPE_RESET;
                       } break;

                   } // switch

                 } else {
                    status = (NTSTATUS)PtrToLong(PWorkItem->Context);
                    retries = (UCHAR)pDevExt->IntDeviceErrors;
                    ulUniqueErrorValue = ERR_MAX_INT_PIPE_DEVICE_ERRORS;
                 }

            } // WORK_ITEM_RESET_INT_PIPE
            break;

            case WORK_ITEM_ABORT_READ_PIPE:
            case WORK_ITEM_ABORT_WRITE_PIPE:
            case WORK_ITEM_ABORT_INT_PIPE:
            default:
            // status = STATUS_NOT_IMPLEMENTED; - let it fall through and see what happens
            DbgDump(DBG_ERR, ("ResetWorkItemFlags: 0x%x 0x%x\n", PWorkItem->Flags, status ));
            ASSERT(0);
            break;

        } // PWorkItem->Flags

    } else {
        status = STATUS_DELETE_PENDING;
    }

    //
    // is the device is hosed?
    //
    if ( (STATUS_SUCCESS != status) && (STATUS_DELETE_PENDING != status) && (0 != retries)) {

        // only log known errors, not suprise remove.
        if (1 == retries ) {

            // mark as PNP_DEVICE_REMOVED
            InterlockedExchange(&pDevExt->DeviceRemoved, TRUE);

            DbgDump(DBG_WRN, ("DEVICE REMOVED\n"));

        } else {

            // mark as PNP_DEVICE_FAILED
            InterlockedExchange(&pDevExt->AcceptingRequests, FALSE);

            DbgDump(DBG_ERR, ("*** UNRECOVERABLE DEVICE ERROR: (0x%x, %d)  No longer Accepting Requests ***\n", status, retries ));

            LogError( NULL,
                    pDevObj,
                    0, 0,
                    retries,
                    ulUniqueErrorValue,
                    status,
                    SERIAL_HARDWARE_FAILURE,
                    pDevExt->DeviceName.Length + sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL );
        }

        IoInvalidateDeviceState( pDevExt->PDO );

    }

    DequeueWorkItem( pDevObj, PWorkItem );

    DbgDump(DBG_WORK_ITEMS, ("<UsbResetOrAbortPipeWorkItem 0x%x\n", status));
}



//
// NT's USB stack likes only 1 reset pending at any time.
// Also, if any reset fails then do NOT send anymore, else you'll get the controller
// or HUB in a funky state, where it will try to reset the port... which kicks off all
// the other devices on the hub.
//
NTSTATUS
UsbResetOrAbortPipe(
   IN PDEVICE_OBJECT PDevObj,
   IN PUSB_PIPE      PPipe,
   IN BOOLEAN        Reset
   )
{
    PDEVICE_EXTENSION pDevExt;
    NTSTATUS status;
    KIRQL irql;
    PURB pUrb;

    ASSERT( PDevObj );

    DbgDump(DBG_USB, (">UsbResetOrAbortPipe (%p)\n", PDevObj) );

    PAGED_CODE();

    if (!PDevObj || !PPipe || !PPipe->hPipe ) {
        DbgDump(DBG_ERR, ("UsbResetOrAbortPipe: STATUS_INVALID_PARAMETER\n") );
        TEST_TRAP();
        return STATUS_INVALID_PARAMETER;
    }

    pDevExt = PDevObj->DeviceExtension;

    KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

    if ( PPipe->ResetOrAbortFailed ) {
        status = STATUS_UNSUCCESSFUL;
        DbgDump(DBG_ERR, ("UsbResetOrAbortPipe.1: 0x%x\n", status) );
        KeReleaseSpinLock(&pDevExt->ControlLock, irql);
        return status;
    }

    if (!CanAcceptIoRequests(PDevObj, FALSE, TRUE) ||
        !NT_SUCCESS(AcquireRemoveLock(&pDevExt->RemoveLock, UlongToPtr(Reset ? URB_FUNCTION_RESET_PIPE : URB_FUNCTION_ABORT_PIPE))))
    {
        status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("UsbResetOrAbortPipe.2: 0x%x\n", status) );
        KeReleaseSpinLock(&pDevExt->ControlLock, irql);
        return status;
    }

    KeReleaseSpinLock(&pDevExt->ControlLock, irql);

    //
    // USBVERIFIER ASSERT: Reset sent on a pipe with a reset already pending
    // The USB stack likes only 1 pending Reset or Abort request per pipe a time.
    //
    if ( 1 == InterlockedIncrement(&PPipe->ResetOrAbortPending) ) {

        pUrb = ExAllocateFromNPagedLookasideList( &pDevExt->PipeRequestUrbPool );

        if ( pUrb != NULL ) {
            //
            // pass the Reset -or- Abort request to USBD
            //
            pUrb->UrbHeader.Length = (USHORT)sizeof(struct _URB_PIPE_REQUEST);

            pUrb->UrbHeader.Function = Reset ? URB_FUNCTION_RESET_PIPE : URB_FUNCTION_ABORT_PIPE;

            pUrb->UrbPipeRequest.PipeHandle = PPipe->hPipe;

            status = UsbSubmitSyncUrb(PDevObj, pUrb, FALSE, DEFAULT_BULK_TIMEOUT);

            if (status != STATUS_SUCCESS) {
                DbgDump(DBG_ERR , ("*** UsbResetOrAbortPipe ERROR: 0x%x ***\n", status));
                InterlockedIncrement(&PPipe->ResetOrAbortFailed);
            }

            ExFreeToNPagedLookasideList(&pDevExt->PipeRequestUrbPool, pUrb);

        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            DbgDump(DBG_ERR , ("ExAllocateFromNPagedLookasideList failed (0x%x)!\n", status));
        }

        InterlockedDecrement(&PPipe->ResetOrAbortPending);

        ASSERT(PPipe->ResetOrAbortPending == 0);

    } else {
        //
        // If there is a reset/abort request pending then we are done.
        // Return STATUS_PENDING here so the work item won't start another transfer,
        // but will dequeue the item. The real item will follow-up with the correct status.
        //
        DbgDump(DBG_WRN, ("UsbResetOrAbortPipe: STATUS_PENDING\n"));
        TEST_TRAP();
        status = STATUS_PENDING;
    }

    ReleaseRemoveLock(&pDevExt->RemoveLock, UlongToPtr(Reset ? URB_FUNCTION_RESET_PIPE : URB_FUNCTION_ABORT_PIPE));

    DbgDump(DBG_USB, ("<UsbResetOrAbortPipe(0x%x)\n", status) );

    return status;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\serioctl.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

        SERIOCTL.C

Abstract:

        Routines to handle IOCTL_SERIAL_Xxx

Environment:

        kernel mode only

Revision History:

        07-14-99  Jeff Midkiff   (jeffmi)

-- */

#include "wceusbsh.h"

VOID
SerialCompletePendingWaitMasks(
   IN PDEVICE_EXTENSION PDevExt
   );

VOID
SerialCancelWaitMask(
   IN PDEVICE_OBJECT PDevObj, 
   IN PIRP PIrp
   );

//
// Debug spew
//
#if DBG

//
// gets the function code fom an ioctl code, which uses method buffered.
// assumes the device type is serial port
//
#define SERIAL_FNCT_CODE( _ctl_code_ ) ( (_ctl_code_ & 0xFF) >> 2)

//
// debug dumps. no spin lock usage to better simulate free build's run time.
// if these trap in the debugger you know why.
//
#define DBG_DUMP_BAUD_RATE( _PDevExt ) \
{  \
      DbgDump(DBG_SERIAL, ("SerialPort.CurrentBaud: %d\n", _PDevExt->SerialPort.CurrentBaud.BaudRate));  \
}

#define DBG_DUMP_LINE_CONTROL( _PDevExt ) \
{  \
      DbgDump(DBG_SERIAL, ("SerialPort.LineControl.StopBits : 0x%x\n", _PDevExt->SerialPort.LineControl.StopBits ));   \
      DbgDump(DBG_SERIAL, ("SerialPort.LineControl.Parity : 0x%x\n", _PDevExt->SerialPort.LineControl.Parity )); \
      DbgDump(DBG_SERIAL, ("SerialPort.LineControl.WordLength : 0x%x\n", _PDevExt->SerialPort.LineControl.WordLength ));  \
}

#define DBG_DUMP_SERIAL_HANDFLOW( _PDevExt )  \
{  \
      DbgDump(DBG_SERIAL, ("SerialPort.HandFlow.ControlHandShake: 0x%x\n", PDevExt->SerialPort.HandFlow.ControlHandShake));  \
      DbgDump(DBG_SERIAL, ("SerialPort.HandFlow.FlowReplace: 0x%x\n", PDevExt->SerialPort.HandFlow.FlowReplace));  \
      DbgDump(DBG_SERIAL, ("SerialPort.HandFlow.XonLimit: 0x%x\n", PDevExt->SerialPort.HandFlow.XonLimit));  \
      DbgDump(DBG_SERIAL, ("SerialPort.HandFlow.XoffLimit: 0x%x\n", PDevExt->SerialPort.HandFlow.XoffLimit));  \
}

#define DBG_DUMP_SERIAL_TIMEOUTS( _PDevExt ) \
{  \
      DbgDump(DBG_SERIAL|DBG_TIME, ("SerialPort.Timeouts.ReadIntervalTimeout: %d\n", _PDevExt->SerialPort.Timeouts.ReadIntervalTimeout ));         \
      DbgDump(DBG_SERIAL|DBG_TIME, ("SerialPort.Timeouts.ReadTotalTimeoutMultiplier: %d\n", _PDevExt->SerialPort.Timeouts.ReadTotalTimeoutMultiplier )); \
      DbgDump(DBG_SERIAL|DBG_TIME, ("SerialPort.Timeouts.ReadTotalTimeoutConstant: %d\n", _PDevExt->SerialPort.Timeouts.ReadTotalTimeoutConstant ));  \
      DbgDump(DBG_SERIAL|DBG_TIME, ("SerialPort.Timeouts.WriteTotalTimeoutMultiplier: %d\n", _PDevExt->SerialPort.Timeouts.WriteTotalTimeoutMultiplier ));  \
      DbgDump(DBG_SERIAL|DBG_TIME, ("SerialPort.Timeouts.WriteTotalTimeoutConstant: %d\n", _PDevExt->SerialPort.Timeouts.WriteTotalTimeoutConstant ));   \
}

#define DBG_DUMP_SERIAL_CHARS( _PDevExt)     \
{  \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.EofChar:   0x%x\n", _PDevExt->SerialPort.SpecialChars.EofChar )); \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.ErrorChar: 0x%x\n", _PDevExt->SerialPort.SpecialChars.ErrorChar )); \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.BreakChar: 0x%x\n", _PDevExt->SerialPort.SpecialChars.BreakChar )); \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.EventChar: 0x%x\n", _PDevExt->SerialPort.SpecialChars.EventChar )); \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.XonChar:   0x%x\n", _PDevExt->SerialPort.SpecialChars.XonChar )); \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.XoffChar:  0x%x\n", _PDevExt->SerialPort.SpecialChars.XoffChar )); \
}

#else
#define DBG_DUMP_BAUD_RATE( _PDevExt )
#define DBG_DUMP_LINE_CONTROL( _PDevExt )
#define DBG_DUMP_SERIAL_HANDFLOW( _PDevExt )
#define DBG_DUMP_SERIAL_TIMEOUTS( _PDevExt )
#define DBG_DUMP_SERIAL_CHARS( _PDevExt)
#endif

__inline
NTSTATUS
IoctlSetSerialValue(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp, 
   ULONG Size, 
   IN OUT PVOID PDest
   )
{
   PIO_STACK_LOCATION pIrpSp;
   NTSTATUS status = STATUS_DELETE_PENDING;
   ULONG information = Size;
   KIRQL oldIrql;

   KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < Size) {

     information = 0;
     status = STATUS_BUFFER_TOO_SMALL;
     DbgDump(DBG_ERR, ("IoctlSetSerialValue: (0x%x)\n", status));

    } else {

     memcpy( PDest, PIrp->AssociatedIrp.SystemBuffer, Size);
     status = STATUS_SUCCESS;

    }

   KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
   
   PIrp->IoStatus.Information = information;
   PIrp->IoStatus.Status = status;
   
   return status;
}

__inline
NTSTATUS
IoctlGetSerialValue(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp, 
   ULONG Size, 
   IN PVOID PSrc
   )
{
   PIO_STACK_LOCATION pIrpSp;
   NTSTATUS status = STATUS_DELETE_PENDING;
   ULONG information = Size;
   KIRQL oldIrql;

   KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);
   
    pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < Size) {

         information = 0;
         status = STATUS_BUFFER_TOO_SMALL;
         DbgDump(DBG_ERR, ("IoctlGetSerialValue: (0x%x)\n", status));

    } else {

     memcpy( PIrp->AssociatedIrp.SystemBuffer, PSrc, Size );
     status = STATUS_SUCCESS;

    }

   KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);

   PIrp->IoStatus.Information = information;
   PIrp->IoStatus.Status = status;
   return status;
}


__inline
NTSTATUS
SetBaudRate(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">SetBaudRate(%p)\n", PIrp));

   status = IoctlSetSerialValue(PDevExt,
                                PIrp, 
                                sizeof( PDevExt->SerialPort.CurrentBaud ),
                                &PDevExt->SerialPort.CurrentBaud );

   DBG_DUMP_BAUD_RATE(PDevExt);
   
   DbgDump(DBG_SERIAL, ("<SetBaudRate %x\n", status));

   return status;
}


__inline
NTSTATUS
GetBaudRate(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetBaudRate(%p)\n", PIrp));
   
   status = IoctlGetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof( PDevExt->SerialPort.CurrentBaud ),
                        &PDevExt->SerialPort.CurrentBaud);

   DBG_DUMP_BAUD_RATE(PDevExt);

   DbgDump(DBG_SERIAL, ("<GetBaudRate %x\n", status));

   return status;
}



__inline
NTSTATUS
SetLineControl(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;
   
   DbgDump(DBG_SERIAL, (">SetLineControl(%p)\n", PIrp));
   
   status = IoctlSetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.LineControl),
                        &PDevExt->SerialPort.LineControl);

   DBG_DUMP_LINE_CONTROL(  PDevExt );

   DbgDump(DBG_SERIAL, ("<SetLineControl %x\n",
                                     status));

   return status;
}



__inline
NTSTATUS
GetLineControl(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status= STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetLineControl(%p)\n", PIrp));

   status = IoctlGetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.LineControl),
                        &PDevExt->SerialPort.LineControl );

   DBG_DUMP_LINE_CONTROL(  PDevExt );

   DbgDump(DBG_SERIAL, ("<GetLineControl %x\n",
                                     status));

   return status;
}



__inline
NTSTATUS
SetTimeouts(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL|DBG_TIME,(">SetTimeouts(%p)\n", PIrp));

   status = IoctlSetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.Timeouts),
                        &PDevExt->SerialPort.Timeouts);

   DBG_DUMP_SERIAL_TIMEOUTS( PDevExt );

   DbgDump(DBG_SERIAL|DBG_TIME,("<SetTimeouts %x\n", status));

   return status;
}



__inline
NTSTATUS
GetTimeouts(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL|DBG_TIME, (">GetTimeouts(%p)\n", PIrp));

   status = IoctlGetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.Timeouts),
                        &PDevExt->SerialPort.Timeouts);

   DBG_DUMP_SERIAL_TIMEOUTS( PDevExt );

   DbgDump(DBG_SERIAL|DBG_TIME, ("<GetTimeouts %x\n", status));

   return status;
}



__inline
NTSTATUS
SetSpecialChars( 
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">SetSpecialChars(%p)\n", PIrp));

   status = IoctlSetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.SpecialChars),
                        &PDevExt->SerialPort.SpecialChars);

   DBG_DUMP_SERIAL_CHARS( PDevExt);

   DbgDump(DBG_SERIAL, ("<SetSpecialChars %x\n", status));

   return status;
}



__inline
NTSTATUS
GetSpecialChars(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetSpecialChars(%p)\n", PIrp));

   status = IoctlGetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.SpecialChars),
                        &PDevExt->SerialPort.SpecialChars);

   DBG_DUMP_SERIAL_CHARS( PDevExt);

   DbgDump(DBG_SERIAL, ("<GetSpecialChars %x\n", status));

   return status;
}



__inline
NTSTATUS
SetClearDTR(
    IN PDEVICE_EXTENSION PDevExt,
    IN PIRP Irp,
    IN BOOLEAN Set
    )
{
    NTSTATUS status = STATUS_DELETE_PENDING;
    KIRQL irql;
    USHORT usState = 0; // DRT/RTS state to send to USB device
    USHORT usOldMSR = 0;
    USHORT usDeltaMSR = 0;
    ULONG  ulOldHistoryMask = 0;
    ULONG  ulOldRS232Lines = 0;

    DbgDump(DBG_SERIAL, (">SetClearDTR (%x, %x)\n", PDevExt->DeviceObject, Set));

    KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    //
    // we queue the user's Irp because this operation may take some time,
    // and we only want to hit the USB with one of these requests at a time.
    //
    if ( NULL != PDevExt->SerialPort.ControlIrp ) {
        DbgDump(DBG_WRN, ("SetClearDTR: STATUS_DEVICE_BUSY\n"));
        status = STATUS_DEVICE_BUSY;
        KeReleaseSpinLock(&PDevExt->ControlLock, irql);   
        return status;
    }

    if ( !CanAcceptIoRequests(PDevExt->DeviceObject, FALSE, TRUE) || 
         !NT_SUCCESS(AcquireRemoveLock(&PDevExt->RemoveLock, Irp)) ) 
    {
        status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("SetClearDTR: 0x%x\n", status));
        KeReleaseSpinLock( &PDevExt->ControlLock, irql);
        return status;
    }

    //
    // Queue the Irp.
    //
    ASSERT( NULL == PDevExt->SerialPort.ControlIrp );
    PDevExt->SerialPort.ControlIrp = Irp;

    usOldMSR         = PDevExt->SerialPort.ModemStatus;
    ulOldRS232Lines  = PDevExt->SerialPort.RS232Lines;
    ulOldHistoryMask = PDevExt->SerialPort.HistoryMask;

    if (PDevExt->SerialPort.RS232Lines & SERIAL_RTS_STATE) {
        usState |= USB_COMM_RTS;
    }

    if (Set) {

        PDevExt->SerialPort.RS232Lines |= SERIAL_DTR_STATE;

        //
        // If there is an INT pipe then MSR could get modified
        //
        PDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DSR | SERIAL_MSR_DCD;

        usState |= USB_COMM_DTR;

    } else {

        PDevExt->SerialPort.RS232Lines &= ~SERIAL_DTR_STATE;

        //
        // If there is an INT pipe then MSR could get modified
        //
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DSR & ~SERIAL_MSR_DCD;
    }

    // see what has changed in the MSR
    usDeltaMSR = usOldMSR ^ PDevExt->SerialPort.ModemStatus;

    if (usDeltaMSR & (SERIAL_MSR_DSR|SERIAL_MSR_DCD)) {
        // set delta MSR bits
        PDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DDSR | SERIAL_MSR_DDCD;
    }

    DbgDump(DBG_SERIAL, ("SerialPort.RS232Lines : 0x%x\n", PDevExt->SerialPort.RS232Lines ));
    DbgDump(DBG_SERIAL, ("SerialPort.ModemStatus: 0x%x\n", PDevExt->SerialPort.ModemStatus ));
    DbgDump(DBG_SERIAL, ("SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask ));

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    //
    // set DTR/RTS on the USB device
    //
    status = UsbClassVendorCommand( PDevExt->DeviceObject,
                                    USB_COMM_SET_CONTROL_LINE_STATE,
                                    usState,
                                    PDevExt->UsbInterfaceNumber, 
                                    NULL,
                                    NULL, 
                                    FALSE, 
                                    WCEUSB_CLASS_COMMAND );

    DbgDump(DBG_SERIAL|DBG_READ_LENGTH, ("USB_COMM_SET_CONTROL_LINE_STATE(1, State: 0x%x, Status: 0x%x)\n", usState, status ));

_EzLink:
    if ( STATUS_SUCCESS == status ) {

        KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

        // signal history massk 
        if ( usDeltaMSR &  (SERIAL_MSR_DSR|SERIAL_MSR_DCD) ) {
            PDevExt->SerialPort.HistoryMask |= SERIAL_EV_DSR | SERIAL_EV_RLSD;
        }

        PDevExt->EP0DeviceErrors = 0;

        DbgDump(DBG_SERIAL, ("SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask ));

        KeReleaseSpinLock(&PDevExt->ControlLock, irql);
   
    } else {
        // Ez-link
        if ((PDevExt->DeviceDescriptor.idVendor  != 0x0547) && 
           ((PDevExt->DeviceDescriptor.idProduct != 0x2710) || (PDevExt->DeviceDescriptor.idProduct != 0x2720)))
        {
            // WINCE BUG 19544: 
            // AS 3.1 does not handle STATUS_TIMEOUT, so will not see a problem. 
            // A side effect is that it could sit spinning the green light trying to connect forever. 
            // However, this is a different case from BUG 19544, which is a disconnect problem.
            // If we return failure then it will keep pounding us with Set DTR Irps.
            // This would be OK if AS would recognize that we disabled the interface, but it won't - see above.
            // You only see this bug when you have a flakey device (iPAQ, hung Jornada, etc.) that times out or 
            // fails to properly handle the command. To prevent the bugcheck 0xCE the choices as of today are:
            //    a) let it spin and never connect for these bad devices (iPAQ). Fix your firmware.
            //    b) fix AcvtiveSync
            // I prefer both - pending email with COMPAQ (HTC) and ActiveSync. When AS gets their changes in then we need to 
            // investigate again.
            status = STATUS_TIMEOUT;

           KeAcquireSpinLock( &PDevExt->ControlLock, &irql);

           if ( ++PDevExt->EP0DeviceErrors < MAX_EP0_DEVICE_ERRORS) {
       
               DbgDump(DBG_ERR, ("USB_COMM_SET_CONTROL_LINE_STATE error: 0x%x\n", status ));
               //
               // The command failed. Reset the old states, propogate status, and disable the device interface. 
               // This should stop AS 3.1 from pounding us with Set DTR Irps.
               // However, AS does not participate in PnP well if we disable the interface
               // (see the note in IRP_MN_QUERY_PNP_DEVICE_STATE). Disabeling the 
               // interface has the desired effect of notifying apps to stop sending us requests and Close the handle.
               //
               PDevExt->SerialPort.ModemStatus = usOldMSR;
               PDevExt->SerialPort.HistoryMask = ulOldHistoryMask;
               PDevExt->SerialPort.RS232Lines  = ulOldRS232Lines;

               KeReleaseSpinLock( &PDevExt->ControlLock, irql);

            } else {
        
                 DbgDump(DBG_ERR, ("*** UNRECOVERABLE DEVICE ERROR.2: (0x%x, %d)  No longer Accepting Requests ***\n", status, PDevExt->EP0DeviceErrors ));

                 // mark as PNP_DEVICE_FAILED
                 InterlockedExchange(&PDevExt->AcceptingRequests, FALSE);

                 KeReleaseSpinLock( &PDevExt->ControlLock, irql);

                 IoInvalidateDeviceState( PDevExt->PDO );

                 LogError( NULL,
                           PDevExt->DeviceObject,
                           0, 0, 
                           (UCHAR)PDevExt->EP0DeviceErrors, 
                           ERR_NO_DTR,
                           status,
                           SERIAL_HARDWARE_FAILURE,
                           PDevExt->DeviceName.Length + sizeof(WCHAR),
                           PDevExt->DeviceName.Buffer,
                           0,
                           NULL );
            }

        } else {
            DbgDump(DBG_WRN, ("Ez-Link\n" ));
            status = STATUS_SUCCESS;
            goto _EzLink;
        }
    }

    //
    // finally, release any pending serial events
    //
    ProcessSerialWaits(PDevExt);

    //
    // DeQueue the user's Irp. It gets completed in the SerialIoctl dispatch
    //
    KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    ReleaseRemoveLock(&PDevExt->RemoveLock, Irp);

    ASSERT( NULL != PDevExt->SerialPort.ControlIrp );

    PDevExt->SerialPort.ControlIrp = NULL;

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    DbgDump(DBG_SERIAL, ("<SetClearDTR %x\n", status ));

    return status;
}



__inline
NTSTATUS
SetClearRTS(
    IN PDEVICE_EXTENSION PDevExt,
    IN PIRP Irp,
    IN BOOLEAN Set
    )
{
    NTSTATUS status = STATUS_DELETE_PENDING;
    KIRQL irql;
    USHORT usState = 0; // DRT/RTS state to send to USB device
    USHORT usOldMSR = 0;
    USHORT usDeltaMSR = 0;
    ULONG  ulOldRS232Lines = 0;
    ULONG  ulOldHistoryMask = 0;

    DbgDump(DBG_SERIAL, (">SetClearRTS (%x, %x)\n", PDevExt->DeviceObject, Set));

    KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    //
    // we queue the user's Irp because this operation may take some time,
    // and we only want to hit the USB with one of these requests at a time.
    //
    if ( NULL != PDevExt->SerialPort.ControlIrp ) {
        status = STATUS_DEVICE_BUSY;
        DbgDump(DBG_WRN, ("SetClearRTS.1: 0x%x\n", status));
        KeReleaseSpinLock(&PDevExt->ControlLock, irql);   
        return status;
    }

    if ( !CanAcceptIoRequests(PDevExt->DeviceObject, FALSE, TRUE) ||
         !NT_SUCCESS(AcquireRemoveLock(&PDevExt->RemoveLock, Irp)) )
    {
        status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("SetClearRTS.2: 0x%x\n", status));
        KeReleaseSpinLock(&PDevExt->ControlLock, irql);
        return status;
    }

    //
    // Queue the Irp.
    //
    ASSERT( NULL == PDevExt->SerialPort.ControlIrp );
    PDevExt->SerialPort.ControlIrp = Irp;

    usOldMSR = PDevExt->SerialPort.ModemStatus;
    ulOldRS232Lines = PDevExt->SerialPort.RS232Lines;
    ulOldHistoryMask = PDevExt->SerialPort.HistoryMask;

    if (PDevExt->SerialPort.RS232Lines & SERIAL_DTR_STATE) {
        usState |= USB_COMM_DTR;
    }

    if (Set) {

        PDevExt->SerialPort.RS232Lines |= SERIAL_RTS_STATE;

        //
        // If there is an INT pipe then MSR could get modified
        //
        PDevExt->SerialPort.ModemStatus |= SERIAL_MSR_CTS;

        usState |= USB_COMM_RTS;

    } else {

        PDevExt->SerialPort.RS232Lines &= ~SERIAL_RTS_STATE;

        //
        // If there is an INT pipe then MSR could get modified
        //
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_CTS;
    }

    // see what has changed in the MSR
    usDeltaMSR = usOldMSR ^ PDevExt->SerialPort.ModemStatus;

    if (usDeltaMSR & SERIAL_MSR_CTS) {
        // set delta MSR bits
        PDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DCTS;
    }

    DbgDump(DBG_SERIAL, ("SerialPort.RS232Lines : 0x%x\n", PDevExt->SerialPort.RS232Lines ));
    DbgDump(DBG_SERIAL, ("SerialPort.ModemStatus: 0x%x\n", PDevExt->SerialPort.ModemStatus));
    DbgDump(DBG_SERIAL, ("SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask ));

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    //
    // set DTR/RTS on the USB device
    //
    status = UsbClassVendorCommand( PDevExt->DeviceObject,
                                    USB_COMM_SET_CONTROL_LINE_STATE, 
                                    usState,
                                    PDevExt->UsbInterfaceNumber, 
                                    NULL,
                                    NULL, 
                                    FALSE, 
                                    WCEUSB_CLASS_COMMAND );

    DbgDump(DBG_SERIAL|DBG_READ_LENGTH, ("USB_COMM_SET_CONTROL_LINE_STATE(2, State: 0x%x, Status: 0x%x)\n", usState, status ));

_EzLink:
    if ( STATUS_SUCCESS == status ) {

        KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    // signal history mask
    if ( usDeltaMSR & SERIAL_MSR_CTS ) {
        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_CTS;
    }

    PDevExt->EP0DeviceErrors = 0;

    DbgDump(DBG_SERIAL, ("SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask ));

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    } else {
        // Ez-link
        if ((PDevExt->DeviceDescriptor.idVendor  != 0x0547) && 
           ((PDevExt->DeviceDescriptor.idProduct != 0x2710) || (PDevExt->DeviceDescriptor.idProduct != 0x2720)))
        {
            // AS 3.1 does not handle STATUS_TIMEOUT, so will not see a problem. 
            // A side effect is that it could sit spinning the green light trying to connect forever. 
            // However, this is a different case from BUG 19544, which is a disconnect problem.
            // If we return failure then it will keep pounding us with Set DTR Irps.
            // This would be OK if AS would recognize that we disabled the interface, but it won't - see above.
            // You only see this bug when you have a flakey device (iPAQ, hung Jornada, etc.) that times out or 
            // fails to properly handle the command. To prevent the bugcheck 0xCE the choices as of today are:
            //    a) let it spin and never connect for these bad devices (iPAQ). Fix your firmware.
            //    b) fix AcvtiveSync
            // I prefer both - pending email with COMPAQ (HTC) and ActiveSync. When AS gets their changes in then we need to 
            // investigate again.
           status = STATUS_TIMEOUT;

           KeAcquireSpinLock( &PDevExt->ControlLock, &irql);

           TEST_TRAP();

           if ( ++PDevExt->EP0DeviceErrors < MAX_EP0_DEVICE_ERRORS) {

               DbgDump(DBG_ERR, ("USB_COMM_SET_CONTROL_LINE_STATE error: %x\n", status ));
               //
               // The command failed. Reset the old states, propogate status, and disable the device interface. 
               // This should stop AS 3.1 from pounding us with Set DTR Irps.
               // However, AS does not participate in PnP well if we disable the interface
               // (see the note in IRP_MN_QUERY_PNP_DEVICE_STATE). Disabeling the 
               // interface has the desired effect of notifying apps to stop sending us requests and Close the handle.
               //
               PDevExt->SerialPort.ModemStatus = usOldMSR;
               PDevExt->SerialPort.RS232Lines  = ulOldRS232Lines;
               PDevExt->SerialPort.HistoryMask = ulOldHistoryMask;

               KeReleaseSpinLock( &PDevExt->ControlLock, irql);
    
            } else {
        
                 DbgDump(DBG_ERR, ("*** UNRECOVERABLE DEVICE ERROR.3: (0x%x, %d)  No longer Accepting Requests ***\n", status, PDevExt->EP0DeviceErrors ));

                 // mark as PNP_DEVICE_FAILED
                 InterlockedExchange(&PDevExt->AcceptingRequests, FALSE);

                 KeReleaseSpinLock( &PDevExt->ControlLock, irql);

                 IoInvalidateDeviceState( PDevExt->PDO );

                 LogError( NULL,
                           PDevExt->DeviceObject,
                           0, 0, 
                           (UCHAR)PDevExt->EP0DeviceErrors, 
                           ERR_NO_RTS,
                           status,
                           SERIAL_HARDWARE_FAILURE,
                           PDevExt->DeviceName.Length + sizeof(WCHAR),
                           PDevExt->DeviceName.Buffer,
                           0,
                           NULL );

            }

        } else {
            DbgDump(DBG_WRN, ("Ez-Link\n" ));
            status = STATUS_SUCCESS;
            goto _EzLink;
        }
    }

    //
    // finally, release any pending serial events
    //
    ProcessSerialWaits(PDevExt);

    //
    // DeQueue the user's Irp. It gets completed in the SerialIoctl dispatch
    //
    KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    ReleaseRemoveLock(&PDevExt->RemoveLock, Irp);

    ASSERT( NULL != PDevExt->SerialPort.ControlIrp );

    PDevExt->SerialPort.ControlIrp = NULL;

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    DbgDump(DBG_SERIAL, ("<SetClearRTS %x\n", status ));

    return status;
}



__inline
NTSTATUS
GetDtrRts(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetDtrRts (%p)\n", Irp));

   status = IoctlGetSerialValue( PDevExt, 
                           Irp, 
                           sizeof(PDevExt->SerialPort.RS232Lines),
                           &PDevExt->SerialPort.RS232Lines);

   DbgDump(DBG_SERIAL, ("SerialPort.RS232Lines: 0x%x\n", PDevExt->SerialPort.RS232Lines ));

   DbgDump(DBG_SERIAL, ("<GetDtrRts %x\n", status));

   return status;
}



__inline
NTSTATUS
SerialResetDevice(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP Irp,
   IN BOOLEAN ClearDTR
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;
   BOOLEAN bRelease = TRUE;
   KIRQL oldIrql;
   
   DbgDump(DBG_SERIAL, (">SerialResetDevice (%x, %d)\n", PDevExt->DeviceObject, ClearDTR ));

   KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

  ASSERT_SERIAL_PORT( PDevExt->SerialPort );

  PDevExt->SerialPort.SupportedBauds = SERIAL_BAUD_075 | SERIAL_BAUD_110 | SERIAL_BAUD_150
                          | SERIAL_BAUD_300 | SERIAL_BAUD_600 | SERIAL_BAUD_1200 
                          | SERIAL_BAUD_1800 | SERIAL_BAUD_2400 | SERIAL_BAUD_4800 | SERIAL_BAUD_7200
                          | SERIAL_BAUD_9600 | SERIAL_BAUD_14400 | SERIAL_BAUD_19200 | SERIAL_BAUD_38400 | SERIAL_BAUD_56K
                          | SERIAL_BAUD_128K | SERIAL_BAUD_57600  | SERIAL_BAUD_115200 | SERIAL_BAUD_USER;

  PDevExt->SerialPort.CurrentBaud.BaudRate = 115200;

  PDevExt->SerialPort.LineControl.StopBits = STOP_BIT_1;
  PDevExt->SerialPort.LineControl.Parity = NO_PARITY;
  PDevExt->SerialPort.LineControl.WordLength = SERIAL_DATABITS_8;

  PDevExt->SerialPort.HandFlow.ControlHandShake = 0;
  PDevExt->SerialPort.HandFlow.FlowReplace = 0;
  PDevExt->SerialPort.HandFlow.XonLimit = 0;
  PDevExt->SerialPort.HandFlow.XoffLimit = 0;

  RtlZeroMemory( &PDevExt->SerialPort.Timeouts, sizeof(SERIAL_TIMEOUTS) );
  RtlZeroMemory( &PDevExt->SerialPort.SpecialChars, sizeof(SERIAL_CHARS) );

  PDevExt->SerialPort.RS232Lines = 0;
  PDevExt->SerialPort.HistoryMask = 0;
  PDevExt->SerialPort.WaitMask = 0;
  PDevExt->SerialPort.ModemStatus = 0;

  DbgDump(DBG_SERIAL, ("SerialPort.RS232Lines : 0x%x\n",  PDevExt->SerialPort.RS232Lines ));
  DbgDump(DBG_SERIAL, ("SerialPort.ModemStatus: 0x%x\n", PDevExt->SerialPort.ModemStatus));
  DbgDump(DBG_SERIAL, ("SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask));

  if ( PDevExt->SerialPort.CurrentWaitMaskIrp ) {
     KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
     bRelease = FALSE;
     SerialCompletePendingWaitMasks(PDevExt);
  }

  //
  // drop the RTS/DTR lines on the USB device
  //
  if (bRelease) {
     KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
     bRelease = FALSE;
  }

  status = ClearDTR ? SetClearDTR(PDevExt, Irp, FALSE) : STATUS_SUCCESS;

  if (bRelease) {
      KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
  }

  DBG_DUMP_BAUD_RATE(PDevExt);
  DBG_DUMP_LINE_CONTROL(PDevExt);
  DBG_DUMP_SERIAL_HANDFLOW(PDevExt);
  DBG_DUMP_SERIAL_TIMEOUTS(PDevExt);
  DBG_DUMP_SERIAL_CHARS(PDevExt);

  DbgDump(DBG_SERIAL, ("<SerialResetDevice %x\n", status));

  return status;
}



__inline
NTSTATUS
SetBreak( 
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt,
   USHORT Time
   )
{
   UNREFERENCED_PARAMETER(PIrp);
   UNREFERENCED_PARAMETER(PDevExt);
   UNREFERENCED_PARAMETER(Time);

   DbgDump(DBG_SERIAL, (">SetBreak(%p)\n",  PIrp));
   DbgDump(DBG_SERIAL, ("<SetBreak %x\n", STATUS_NOT_SUPPORTED));
   
   return STATUS_NOT_SUPPORTED;
}



__inline
NTSTATUS
SetQueueSize(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
/* ++

   IOCTL_SERIAL_SET_QUEUE_SIZE
   Operation
   Resizes the driver's internal typeahead and input buffers.
   The driver can allocate buffers larger than the requested sizes
   and can refuse to allocate buffers larger than its capacity.

   Input
   Parameters.DeviceIoControl.InputBufferLength 
   indicates the size in bytes (must be >= sizeof(SERIAL_QUEUE_SIZE)) 
   of the buffer at Irp->AssociatedIrp.SystemBuffer, containing the 
   InSize and OutSize specifications.

   Output
   None

   I/O Status Block
   The Information field is set to zero. 
   The Status field is set to STATUS_SUCCESS or 
   possibly to STATUS_BUFFER_TOO_SMALL or 
   STATUS_INSUFFICIENT_RESOURCES if the driver 
   cannot satisfy the request by allocating more memory.

-- */
{
   NTSTATUS status = STATUS_DELETE_PENDING;
   
   UNREFERENCED_PARAMETER(PIrp);
   UNREFERENCED_PARAMETER(PDevExt);

   DbgDump(DBG_SERIAL, (">SetQueueSize (%p)\n",  PIrp));

   // we pretend to set this, but don't really care
   status = IoctlSetSerialValue(PDevExt, 
                                PIrp, 
                                sizeof(PDevExt->SerialPort.FakeQueueSize ),
                                &PDevExt->SerialPort.FakeQueueSize );

   DbgDump( DBG_SERIAL, ("SerialPort.FakeQueueSize.InSize = 0x%x\n", PDevExt->SerialPort.FakeQueueSize.InSize ));
   DbgDump( DBG_SERIAL, ("SerialPort.FakeQueueSize.OutSize = 0x%x\n", PDevExt->SerialPort.FakeQueueSize.OutSize));

   DbgDump(DBG_SERIAL, ("DataOutMaxPacketSize = %d\n", PDevExt->WritePipe.MaxPacketSize));
   DbgDump(DBG_SERIAL, ("UsbReadBuffSize = %d\n", PDevExt->UsbReadBuffSize ));

#if USE_RING_BUFF      
   DbgDump(DBG_SERIAL, ("Internal RingBuffer Size: %d\n", PDevExt->RingBuff.Size ));
#endif   
         
   DbgDump(DBG_SERIAL, ("<SetQueueSize %x\n", status));

   return status;
}



__inline
NTSTATUS
GetWaitMask(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetWaitMask (%p)\n",  PIrp));

   status = IoctlGetSerialValue(PDevExt, 
                                PIrp, 
                                sizeof(PDevExt->SerialPort.WaitMask),
                                &PDevExt->SerialPort.WaitMask);

   DbgDump(DBG_SERIAL, ("Current SerialPort.WaitMask = 0x%x\n", PDevExt->SerialPort.WaitMask));

   DbgDump(DBG_SERIAL, ("<GetWaitMask %x\n", status));

   return status;
}



__inline
NTSTATUS
SetWaitMask(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
/* ++

   IOCTL_SERIAL_SET_WAIT_MASK
   Operation
   Causes the driver to track the specified events, or, 
   if the specified value is zero, to complete pending waits.

   Input
   Parameters.DeviceIoControl.InputBufferLength 
   indicates the size in bytes (must be >= sizeof(ULONG)) of
   the bitmask at Irp->AssociatedIrp.SystemBuffer.

   Output
   None

   I/O Status Block
   The Information field is set to zero. 
   The Status field is set to STATUS_SUCCESS or 
   possibly to STATUS_PENDING, STATUS_CANCELLED, 
   STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_PARAMETER.

-- */
{
  PULONG pWaitMask = (PULONG)PIrp->AssociatedIrp.SystemBuffer;
  NTSTATUS status = STATUS_DELETE_PENDING;
  KIRQL oldIrql;
  PIO_STACK_LOCATION pIrpSp;

  DbgDump(DBG_SERIAL, (">SetWaitMask (%p)\n",  PIrp));

  KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);
   
  PIrp->IoStatus.Information = 0;

  pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

  if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {

     status = STATUS_BUFFER_TOO_SMALL;
     DbgDump(DBG_ERR, ("SetWaitMask: (0x%x)\n", status));
     KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
  
  } else {
  
     // make sure it's a valid request
     if (*pWaitMask & ~(SERIAL_EV_RXCHAR   |
                        SERIAL_EV_RXFLAG   |
                        SERIAL_EV_TXEMPTY  |
                        SERIAL_EV_CTS      |
                        SERIAL_EV_DSR      |
                        SERIAL_EV_RLSD     |
                        SERIAL_EV_BREAK    |
                        SERIAL_EV_ERR      |
                        SERIAL_EV_RING     |
                        SERIAL_EV_PERR     |
                        SERIAL_EV_RX80FULL |
                        SERIAL_EV_EVENT1   |
                        SERIAL_EV_EVENT2) ) {

        status = STATUS_INVALID_PARAMETER;
        DbgDump(DBG_ERR, ("Invalid WaitMask: (0x%x)\n", *pWaitMask));
        KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
  
     } else {

        KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
     
        // force completion of any pending waits
        SerialCompletePendingWaitMasks( PDevExt );

        KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

        PDevExt->SerialPort.HistoryMask = 0; // clear the history mask

        PDevExt->SerialPort.WaitMask = *pWaitMask;

        //
        // for NT RAS
        // A value of '0' means clear any pending waits, which should have read 
        // and cleared the MSR delta bits. The delta bits are the low nibble.
        //
        if (PDevExt->SerialPort.WaitMask == 0) {
           // clear delta bits
           PDevExt->SerialPort.ModemStatus &= 0xF0;
        }
                         
        DbgDump(DBG_SERIAL, ("New SerialPort.WaitMask = 0x%x\n", PDevExt->SerialPort.WaitMask));
        DbgDump(DBG_SERIAL, ("SerialPort.RS232Lines   = 0x%x\n", PDevExt->SerialPort.RS232Lines ));
        DbgDump(DBG_SERIAL, ("SerialPort.ModemStatus  = 0x%x\n", PDevExt->SerialPort.ModemStatus));
        
        KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
        
        status = STATUS_SUCCESS;
     }
  }
   
  DbgDump(DBG_SERIAL, ("<SetWaitMask %x\n", status));

  return status;
}


VOID
ProcessSerialWaits(
   IN PDEVICE_EXTENSION PDevExt
   )
{
   KIRQL irql;
   PULONG pWaitMask;
   PIRP pMaskIrp;
   BOOLEAN bReleaseNeeded = TRUE;

   PERF_ENTRY( PERF_ProcessSerialWaits );

   ASSERT(PDevExt);

   DbgDump(DBG_SERIAL|DBG_TRACE, (">ProcessSerialWaits\n"));

   KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

   if ( PDevExt->SerialPort.CurrentWaitMaskIrp ) {
   
      ASSERT_SERIAL_PORT( PDevExt->SerialPort );

      if ( PDevExt->SerialPort.WaitMask & PDevExt->SerialPort.HistoryMask) {

         DbgDump(DBG_SERIAL, ("Releasing SerialPort.CurrentWaitMaskIrp(%p) with Mask: 0x%x\n", 
                              PDevExt->SerialPort.CurrentWaitMaskIrp, PDevExt->SerialPort.HistoryMask));

         pWaitMask = (PULONG)PDevExt->SerialPort.CurrentWaitMaskIrp->AssociatedIrp.SystemBuffer;
         *pWaitMask = PDevExt->SerialPort.HistoryMask;

         PDevExt->SerialPort.HistoryMask = 0;
      
         pMaskIrp = PDevExt->SerialPort.CurrentWaitMaskIrp;

         pMaskIrp->IoStatus.Information = sizeof(ULONG);
      
         pMaskIrp->IoStatus.Status = STATUS_SUCCESS;
      
         PDevExt->SerialPort.CurrentWaitMaskIrp = NULL;
      
         IoSetCancelRoutine(pMaskIrp, NULL);

         bReleaseNeeded = FALSE;

         ReleaseRemoveLock(&PDevExt->RemoveLock, pMaskIrp);

         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
         
         IoCompleteRequest(pMaskIrp, IO_NO_INCREMENT );
      
      } else {

         DbgDump(DBG_SERIAL, ("No Serial Events\n" ));
      
      }

   } else {

      DbgDump(DBG_SERIAL, ("No CurrentWaitMaskIrp\n"));
      
   }

   if (bReleaseNeeded) {
      KeReleaseSpinLock(&PDevExt->ControlLock, irql);
   }
   
   DbgDump(DBG_SERIAL|DBG_TRACE, ("<ProcessSerialWaits\n"));
   
   PERF_EXIT( PERF_ProcessSerialWaits );

   return;
}



__inline
NTSTATUS
WaitOnMask(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
/* ++

   IOCTL_SERIAL_WAIT_ON_MASK
   Operation
   Returns information about which events have occurred 
   among those that the caller was waiting on.

   Input
   Parameters.DeviceIoControl.OutputBufferLength indicates the
   size in bytes (must be >= sizeof(ULONG)) of the buffer.

   Output
   The driver returns a bitmask with bits set for events that 
   occurred (or with a value of zero if the preceding 
   set-waitmask request specified zero) to the buffer at 
   Irp->AssociatedIrp.SystemBuffer.

   I/O Status Block
   The Information field is set to sizeof(ULONG) when the 
   Status field is set to STATUS_SUCCESS. Otherwise, 
   the Information field is set to zero, and the Status field 
   can be set to STATUS_PENDING or 
   STATUS_INVALID_PARAMETER if a wait is already pending.

-- */
{
  PULONG pWaitMask = (PULONG)PIrp->AssociatedIrp.SystemBuffer;
  PIO_STACK_LOCATION pIrpSp;
  NTSTATUS status = STATUS_DELETE_PENDING;
  KIRQL oldIrql;

  DbgDump(DBG_SERIAL|DBG_TRACE, (">WaitOnMask (%p)\n",  PIrp));

  KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

  if ( !CanAcceptIoRequests(PDevExt->DeviceObject, FALSE, TRUE) ) {
      status = STATUS_DELETE_PENDING;
      DbgDump(DBG_ERR, ("WaitOnMask: 0x%x\n", status) );
      KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
      return status;
  }

  status = STATUS_SUCCESS;

  PIrp->IoStatus.Information = 0;

  pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

  if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
     
     KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
     status = STATUS_BUFFER_TOO_SMALL;
     DbgDump(DBG_ERR, ("WaitOnMask: (0x%x)\n", status));

  } else {
     //
     // Fake NULL modem...
     //
     if ((PDevExt->SerialPort.WaitMask & SERIAL_EV_CTS) && (PDevExt->SerialPort.ModemStatus & SERIAL_MSR_DCTS) ) {

        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_CTS;
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DCTS;

     }

     if ((PDevExt->SerialPort.WaitMask & SERIAL_EV_DSR) && (PDevExt->SerialPort.ModemStatus & SERIAL_MSR_DDSR) ) {

        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_DSR;
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DDSR;
        
        // make RAS happy
        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RLSD;
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DDCD;

     }

     if ((PDevExt->SerialPort.WaitMask & SERIAL_EV_RLSD) && (PDevExt->SerialPort.ModemStatus & SERIAL_MSR_DDCD) ) {

        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RLSD;
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DDCD;

     }

     if ((PDevExt->SerialPort.WaitMask & SERIAL_EV_RING) && (PDevExt->SerialPort.ModemStatus & SERIAL_MSR_DRI) ) {

        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RING;
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DRI;

     }

     DbgDump(DBG_SERIAL, ("WaitOnMask::SerialPort.ModemStatus: 0x%x\n", PDevExt->SerialPort.ModemStatus ));
     DbgDump(DBG_SERIAL, ("WaitOnMask::SerialPort.WaitMask   : 0x%x\n", PDevExt->SerialPort.WaitMask ));
     DbgDump(DBG_SERIAL, ("WaitOnMask::SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask ));

     //
     // If we already have an event to report, then just go ahead and return it.
     //
     if ( PDevExt->SerialPort.HistoryMask ) {

        *pWaitMask = PDevExt->SerialPort.HistoryMask;
     
        PDevExt->SerialPort.HistoryMask = 0;

        KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);

        PIrp->IoStatus.Information = sizeof(PDevExt->SerialPort.HistoryMask);

        // the Irp gets completed by the calling routine
        DbgDump(DBG_SERIAL | DBG_EVENTS, ("Returning WatiMask: 0x%08x\n", *pWaitMask));

     } else {
        //
        // we don't have any events yet, 
        // so queue the input Irp (PIrp)
        //

        //
        // just in case something comes in (Rx/Tx), 
        // we'll use a while loop to complete any 
        // pending wait mask Irps.
        //
        while (PDevExt->SerialPort.CurrentWaitMaskIrp) {
           PIRP pOldIrp;

           pOldIrp = PDevExt->SerialPort.CurrentWaitMaskIrp;
           PDevExt->SerialPort.CurrentWaitMaskIrp = NULL;

           pOldIrp->IoStatus.Status = STATUS_SUCCESS;

           IoSetCancelRoutine(pOldIrp, NULL);

           *pWaitMask = 0;

           DbgDump(DBG_SERIAL|DBG_EVENTS|DBG_TRACE, ("Completing maskirp(4) %p\n", pOldIrp));

           //
           // Release locks, complete request, then reacquire locks
           //
           ReleaseRemoveLock(&PDevExt->RemoveLock, pOldIrp);

           KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);

           IoCompleteRequest(pOldIrp, IO_SERIAL_INCREMENT);

           KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);
        }

        //
        // Check to see if the input Irp needs to be cancelled
        //
        if (PIrp->Cancel) {

           PIrp->IoStatus.Information = 0;

           status = PIrp->IoStatus.Status = STATUS_CANCELLED;
           //
           // the caller completes the Irp
           //
        } else {
              //
              // queue the input Irp as the SerialPort.CurrentWaitMaskIrp
              //
              DbgDump(DBG_SERIAL | DBG_EVENTS, ("Queuing Irp: %p for WatiMask: 0x%08x\n", PIrp, PDevExt->SerialPort.WaitMask ));

              IoSetCancelRoutine( PIrp, SerialCancelWaitMask );

              IoMarkIrpPending(PIrp);
        
              status = PIrp->IoStatus.Status = STATUS_PENDING;

              ASSERT( NULL == PDevExt->SerialPort.CurrentWaitMaskIrp); // don't want to drop Irps on the floor
              PDevExt->SerialPort.CurrentWaitMaskIrp = PIrp;

              //
              // now the Irp is on our queue, 
              // so the caller should NOT try to complete it.
              //
        }

        KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
     }  // !SerialPort.HistoryMask

  }  // pIrpSp->Parameters

   DbgDump(DBG_SERIAL, ("<WaitOnMask %x\n", status));

   return status;
}



VOID
SerialCompletePendingWaitMasks(
   IN PDEVICE_EXTENSION PDevExt
   )
/*++

Routine Description:

    This function is used to complete the pending SerialPort.WaitMask Irp
    due to IOCTL_SERIAL_SET_WAIT_MASK

Arguments:

Return Value:

    VOID

--*/
{
  KIRQL oldIrql;
  PIRP pCurrentMaskIrp = NULL;

  ASSERT(PDevExt);
  DbgDump(DBG_SERIAL|DBG_TRACE, (">SerialCompletePendingWaitMasks\n"));
   
  KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

  ASSERT_SERIAL_PORT( PDevExt->SerialPort );

  pCurrentMaskIrp = PDevExt->SerialPort.CurrentWaitMaskIrp;

  if (pCurrentMaskIrp) {

     pCurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;
  
     pCurrentMaskIrp->IoStatus.Information = sizeof(PDevExt->SerialPort.HistoryMask);

     DbgDump(DBG_SERIAL, ("SerialCompletePendingWaitMasks: %p with 0x%x\n", PDevExt->SerialPort.CurrentWaitMaskIrp, PDevExt->SerialPort.HistoryMask));
     
     *((PULONG)pCurrentMaskIrp->AssociatedIrp.SystemBuffer) = PDevExt->SerialPort.HistoryMask;
  
     PDevExt->SerialPort.HistoryMask = 0;
  
     PDevExt->SerialPort.CurrentWaitMaskIrp = NULL;

     IoSetCancelRoutine(pCurrentMaskIrp, NULL);

   }

   KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);

   // complete the queued SerialPort.WaitMask IRP if needed
   if (pCurrentMaskIrp) {
      
      ReleaseRemoveLock(&PDevExt->RemoveLock, pCurrentMaskIrp);
      
      IoCompleteRequest(pCurrentMaskIrp, IO_SERIAL_INCREMENT);
   }

   DbgDump(DBG_SERIAL|DBG_TRACE, ("<SerialCompletePendingWaitMasks\n"));

   return;
}


VOID
SerialCancelWaitMask(
   IN PDEVICE_OBJECT PDevObj, 
   IN PIRP PIrp
   )
/*++

Routine Description:

    This function is used as a cancel routine for Irps queued due 
    to IOCTL_SERIAL_WAIT_ON_MASK

Arguments:

    PDevObj - Pointer to Device Object
    PIrp    - Pointer to IRP that is being canceled; must be the same as
              the current mask IRP.

Return Value:

    VOID

--*/
{
  PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
  KIRQL oldIrql;

  DbgDump(DBG_SERIAL|DBG_IRP|DBG_CANCEL|DBG_TRACE, (">SerialCancelWaitMask (%p)\n", PIrp));

  //
  // release ASAP since we queue our own Irps
  //
  IoReleaseCancelSpinLock(PIrp->CancelIrql);

  KeAcquireSpinLock(&pDevExt->ControlLock, &oldIrql);  

  ASSERT_SERIAL_PORT( pDevExt->SerialPort );

  ASSERT(pDevExt->SerialPort.CurrentWaitMaskIrp == PIrp);

  PIrp->IoStatus.Status = STATUS_CANCELLED;
  PIrp->IoStatus.Information = 0;

  pDevExt->SerialPort.CurrentWaitMaskIrp = NULL;

  ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

  KeReleaseSpinLock(&pDevExt->ControlLock, oldIrql);

  IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

  DbgDump(DBG_SERIAL|DBG_IRP|DBG_CANCEL|DBG_TRACE, ("<SerialCancelWaitMask\n"));

  return;
}


__inline
NTSTATUS
GetCommStatus(
   IN PIRP PIrp,
   IN PDEVICE_EXTENSION PDevExt
   )
/* ++

   IOCTL_SERIAL_GET_COMMSTATUS
   Operation
   Returns general status information, including how many 
   Errors and HoldReasons have occurred, how much data 
   is in the driver's buffers as indicated by the AmountInInQueue 
   and AmountInOutQueue values, and whether EofReceived and 
   WaitForImmediate are set.

   Input
   Parameters.DeviceIoControl.OutputBufferLength 
   indicates the size in bytes of the buffer, which must be 
   >= sizeof(SERIAL_STATUS).

   Output
   The driver returns information to the buffer at 
   Irp->AssociatedIrp.SystemBuffer.

   I/O Status Block
   The Information field is set to sizeof(SERIAL_STATUS) 
   when the Status field is set to STATUS_SUCCESS. Otherwise, 
   the Information field is set to zero and the Status field is set to 
   STATUS_BUFFER_TOO_SMALL.

-- */
{
    PSERIAL_STATUS pSerialStatus = (PSERIAL_STATUS)PIrp->AssociatedIrp.SystemBuffer;
    NTSTATUS status = STATUS_DELETE_PENDING;
    KIRQL oldIrql;
    PIO_STACK_LOCATION  pIrpSp;

    DbgDump(DBG_SERIAL, (">GetCommStatus (%p)\n", PIrp));

    KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);
   
    pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_STATUS)) {

        status = STATUS_BUFFER_TOO_SMALL;
        PIrp->IoStatus.Information = 0;
        DbgDump(DBG_ERR, ("GetCommStatus: (0x%x)\n", status));

    } else {

        status = STATUS_SUCCESS;
        PIrp->IoStatus.Information = sizeof(SERIAL_STATUS);

        RtlZeroMemory(pSerialStatus, sizeof(SERIAL_STATUS));

        pSerialStatus->Errors = 0;
        pSerialStatus->EofReceived = FALSE;

        pSerialStatus->WaitForImmediate = 0;
        pSerialStatus->HoldReasons = 0;

#if defined (USE_RING_BUFF)
        pSerialStatus->AmountInInQueue = PDevExt->RingBuff.CharsInBuff;
#else
        pSerialStatus->AmountInInQueue = PDevExt->UsbReadBuffChars;
#endif
        pSerialStatus->AmountInOutQueue= PDevExt->SerialPort.CharsInWriteBuf;

        DbgDump(DBG_SERIAL, ("AmountInInQueue: %x\n", pSerialStatus->AmountInInQueue ));
        DbgDump(DBG_SERIAL, ("AmountInOutQueue: %x\n", pSerialStatus->AmountInOutQueue));
    }

    KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
   
    DbgDump(DBG_SERIAL, ("<GetCommStatus %x\n", status));

    return status;
}


__inline
NTSTATUS
GetModemStatus(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetModemStatus (%p)\n", PIrp));

   // get current MSR
   status = IoctlGetSerialValue(PDevExt,
                                PIrp, 
                                sizeof( PDevExt->SerialPort.ModemStatus ),
                                &PDevExt->SerialPort.ModemStatus );

   DbgDump(DBG_SERIAL, ("<GetModemStatus %x\n", status));

   return status;
}



__inline
NTSTATUS
ImmediateChar(
   IN PIRP Irp, 
   IN PDEVICE_OBJECT DeviceObject
   )
{
   PUCHAR   Char = (PUCHAR) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS status = STATUS_SUCCESS;
   PIO_STACK_LOCATION IrpStack;

   DbgDump(DBG_SERIAL, (">ImmediateChar (%p)\n", Irp));

   TEST_TRAP();

   Irp->IoStatus.Information = 0;
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR)) {

      status = STATUS_BUFFER_TOO_SMALL;
      DbgDump(DBG_ERR, ("ImmediateChar: (0x%x)\n", status));

   } else {
      //
      // Fabricate a write irp & send it to our write path.
      // We do this because the R/W path depends on receiving an Irp of type
      // IRP_MJ_WRITE or IRP_MJ_READ. It would be easier to 
      // simply say "not supported", but legacy apps depend on this.
      //
      PIRP pIrp;
      KEVENT event;
      IO_STATUS_BLOCK ioStatusBlock = {0, 0};
      LARGE_INTEGER startingOffset  = {0, 0};

      PAGED_CODE();

      KeInitializeEvent(
         &event,
         NotificationEvent,
         FALSE
         );

      pIrp = IoBuildSynchronousFsdRequest(
                 IRP_MJ_WRITE,   // MajorFunction,
                 DeviceObject,   // DeviceObject,
                 &Char,          // Buffer,
                 sizeof(Char),   // Length ,
                 &startingOffset,// StartingOffset,
                 &event,         // Event,
                 &ioStatusBlock  // OUT PIO_STATUS_BLOCK  IoStatusBlock
                 );

      if ( !pIrp ) {

         status = Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
         DbgDump(DBG_ERR, ("IoBuildSynchronousFsdRequest: STATUS_INSUFFICIENT_RESOURCES\n", status));

      } else {

         status = IoCallDriver( DeviceObject, 
                                pIrp );

         if ( STATUS_PENDING == status ) {
            KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL );
         }

         //
         // Propogate Write status.
         // Note: the system released the Irp we just created & sent
         // when the Write completes.... so don't touch it.
         //
         status = ioStatusBlock.Status ;
      }

   }

   DbgDump(DBG_SERIAL, ("<ImmediateChar, %x\n", status));

   return status;
}


NTSTATUS
SerialPurgeRxClear(
   IN PDEVICE_OBJECT PDevObj,
   IN BOOLEAN CancelRead
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   KIRQL irql;

   DbgDump( DBG_SERIAL, (">SerialPurgeRxClear:%d\n", CancelRead));

   //
   // Cancel the USB INT & Read Irps, which effectvely NAKs all packets from the client
   // device untill we resubmit it.
   //
   if ( CancelRead ) 
   {
        if (pDevExt->IntIrp) 
        {
            status = CancelUsbInterruptIrp( PDevObj );
        }
        status = CancelUsbReadIrp( PDevObj );
   }

   if (STATUS_SUCCESS == status) {
      //
      // Now, purge the Rx buffer.
      //
      KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

#if DBG
   if ( DebugLevel & (DBG_DUMP_READS|DBG_READ_LENGTH)) 
   {
      ULONG i;
#if defined (USE_RING_BUFF)
      KdPrint( ("PurgeRxBuff[%d]: ", pDevExt->RingBuff.CharsInBuff ));
      for (i = 0; i < pDevExt->RingBuff.CharsInBuff; i++) {
         KdPrint(("%02x ", *pDevExt->RingBuff.pHead++ & 0xFF));
      }
#else
      KdPrint( ("PurgeRxBuff[%d]: ", pDevExt->UsbReadBuffChars ));
      for (i = 0; i < pDevExt->UsbReadBuffChars; i++) {
         KdPrint(("%02x ", pDevExt->UsbReadBuff[i] & 0xFF));
      }
#endif // USE_RING_BUFF
      KdPrint(("\n"));
   }
#endif // DBG

#if defined (USE_RING_BUFF)
      pDevExt->RingBuff.CharsInBuff = 0;
      pDevExt->RingBuff.pHead =
      pDevExt->RingBuff.pTail = 
      pDevExt->RingBuff.pBase;
#else    // USE_RING_BUFF
      pDevExt->UsbReadBuffChars = 0;
      pDevExt->UsbReadBuffIndex   = 0;
#endif

      if ( CancelRead ) {
         //
         // reset read states
         //
         InterlockedExchange(&pDevExt->UsbReadState, IRP_STATE_COMPLETE);
         InterlockedExchange(&pDevExt->IntState,     IRP_STATE_COMPLETE);
      }

      KeReleaseSpinLock(&pDevExt->ControlLock, irql);
   }
   
   DbgDump(DBG_SERIAL, ("<SerialPurgeRxClear:0x%x\n", status ));

   return status;
}



__inline
NTSTATUS
Purge(
   IN PDEVICE_OBJECT PDevObj, 
   IN PIRP Irp
   )
/* ++

   IOCTL_SERIAL_PURGE
   Operation
   Purges the specified operation(s) or queues: one or more of 
   the current and all pending writes, the current and all pending 
   reads, the transmit buffer if one exists, and the receive buffer 
   if one exists.

   Input
   Parameters.DeviceIoControl.InputBufferLength indicates the 
   size in bytes of the buffer at Irp->AssociatedIrp.SystemBuffer,
   which contains a bitmask of type ULONG, indicating what to purge.

   Output
   None

   I/O Status Block
   The Information field is set to zero, and the Status field is set 
   to STATUS_SUCCESS or possibly to STATUS_PENDING, 
   STATUS_CANCELLED, or STATUS_INVALID_PARAMETER

-- */
{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    PIO_STACK_LOCATION pIrpStack;
    NTSTATUS status = STATUS_DELETE_PENDING;
    ULONG    ulMask = 0;
    KIRQL  irql;
    PIRP NulllIrp = NULL;

    DbgDump(DBG_SERIAL|DBG_IRP, (">Purge (%p)\n", Irp));

    KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

    Irp->IoStatus.Information = 0;
    pIrpStack = IoGetCurrentIrpStackLocation(Irp);

    if (!Irp->AssociatedIrp.SystemBuffer ||
        pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        DbgDump(DBG_ERR, ("Purge: (0x%x)\n", status));

    } else {

         ulMask = *((PULONG) Irp->AssociatedIrp.SystemBuffer);

         // make sure purge request is valid
         if ( (!ulMask) || (ulMask & ( ~( SERIAL_PURGE_TXABORT  |
                                          SERIAL_PURGE_RXABORT |
                                          SERIAL_PURGE_TXCLEAR  |
                                          SERIAL_PURGE_RXCLEAR)))) {

            status = STATUS_INVALID_PARAMETER;
            DbgDump(DBG_ERR, ("Purge: (0x%x)\n", status));

         } else {

            DbgDump(DBG_SERIAL, ("Purge Mask: 0x%x\n", ulMask ));

            status = STATUS_SUCCESS;

            if ( ulMask & SERIAL_PURGE_RXCLEAR) {
               //
               // SERIAL_PURGE_RXCLEAR - Implies the receive buffer if exists.
               //
               DbgDump(DBG_SERIAL|DBG_IRP, ("SERIAL_PURGE_RXCLEAR\n"));
               KeReleaseSpinLock(&pDevExt->ControlLock, irql);
       
               status = SerialPurgeRxClear(PDevObj, TRUE);

               if ( NT_SUCCESS(status) ) {
                   if ( !pDevExt->IntPipe.hPipe ) {
                      DbgDump(DBG_SERIAL, ("kick starting another USB Read\n" ));
                      status = UsbRead( pDevExt, FALSE );
                   } else {
                      DbgDump(DBG_SERIAL, ("kick starting another USB INT Read\n" ));
                      status = UsbInterruptRead( pDevExt );
                   }
               }

               if ( NT_SUCCESS(status) ) { 
                   // should be STATUS_PENDING
                   status = STATUS_SUCCESS;
               }
      
               KeAcquireSpinLock(&pDevExt->ControlLock, &irql);
            }

            if (ulMask & SERIAL_PURGE_RXABORT) {
               //
               // SERIAL_PURGE_RXABORT - Implies the current and all pending reads.
               //
               DbgDump(DBG_SERIAL|DBG_IRP, ("SERIAL_PURGE_RXABORT\n"));

               KeReleaseSpinLock(&pDevExt->ControlLock, irql);

               // cancel all outstanding USB read requests
               //status = CleanUpPacketList( PDevObj, &pDevExt->PendingReadPackets);
       
               // cancel all outstanding user reads
               KillAllPendingUserReads( PDevObj,
                                        &pDevExt->UserReadQueue,
                                        &pDevExt->UserReadIrp ); //&NulllIrp );
       
               KeAcquireSpinLock(&pDevExt->ControlLock, &irql);
            }

            if (ulMask & SERIAL_PURGE_TXCLEAR) {
               //
               // SERIAL_PURGE_TXCLEAR - Implies the transmit buffer if exists
               //
               DbgDump(DBG_SERIAL|DBG_IRP, ("SERIAL_PURGE_TXCLEAR\n"));
    
               pDevExt->SerialPort.CharsInWriteBuf = 0;

            }

            if (ulMask & SERIAL_PURGE_TXABORT) {
               //
               // SERIAL_PURGE_TXABORT - Implies the current and all pending writes.
               //
               DbgDump(DBG_SERIAL|DBG_IRP, ("SERIAL_PURGE_TXABORT\n"));

               KeReleaseSpinLock(&pDevExt->ControlLock, irql);
       
               //
               // We don't queue write Irps, rather write packets.
               // So, cancel all outstanding write requests 
               //
               status = CleanUpPacketList( PDevObj, 
                                           &pDevExt->PendingWritePackets,
                                           &pDevExt->PendingDataOutEvent
                                           );
       
               KeAcquireSpinLock(&pDevExt->ControlLock, &irql);
            }

         }
    }

   KeReleaseSpinLock(&pDevExt->ControlLock, irql);

   DbgDump(DBG_SERIAL|DBG_IRP, ("<Purge %x\n", status));

   return status;
}



__inline
NTSTATUS
GetHandflow(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING; 

   DbgDump(DBG_SERIAL, (">GetHandFlow (%p)\n", Irp));

   status = IoctlGetSerialValue(PDevExt,
                                Irp, 
                                sizeof( PDevExt->SerialPort.HandFlow ),
                                &PDevExt->SerialPort.HandFlow);

   DBG_DUMP_SERIAL_HANDFLOW( PDevExt );
   
   DbgDump(DBG_SERIAL, ("<GetHandFlow %x\n", status));

   return status;
}



__inline
NTSTATUS
SetHandflow(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status= STATUS_DELETE_PENDING;
   
   DbgDump(DBG_SERIAL, (">SetHandFlow(%p)\n", PIrp));

   status = IoctlSetSerialValue( PDevExt, 
                           PIrp, 
                           sizeof( PDevExt->SerialPort.HandFlow ),
                           &PDevExt->SerialPort.HandFlow);

   DBG_DUMP_SERIAL_HANDFLOW( PDevExt );
      
   DbgDump(DBG_SERIAL, ("<SetHandFlow %x\n", status));

   return status;
}



NTSTATUS
GetProperties(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS           status = STATUS_DELETE_PENDING;
   PSERIAL_COMMPROP   Properties;
   PIO_STACK_LOCATION IrpStack;
   KIRQL oldIrql;

   DbgDump(DBG_SERIAL, (">GetProperties (%p)\n", Irp));
   
    KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_COMMPROP)) {
 
        status = STATUS_BUFFER_TOO_SMALL;
        DbgDump(DBG_ERR, ("GetProperties: (0x%x)\n", status));

    } else {

        Properties = (PSERIAL_COMMPROP)Irp->AssociatedIrp.SystemBuffer;
  
        RtlZeroMemory(Properties, sizeof(SERIAL_COMMPROP));

        Properties->PacketLength   = sizeof(SERIAL_COMMPROP);
        Properties->PacketVersion  = 2;

        Properties->ServiceMask    = SERIAL_SP_SERIALCOMM;

        // internal limits
        Properties->MaxTxQueue = DEFAULT_PIPE_MAX_TRANSFER_SIZE; 
        #if defined (USE_RING_BUFF)
        Properties->MaxRxQueue = PDevExt->RingBuff.Size;
        #else
        Properties->MaxRxQueue = PDevExt->UsbReadBuffSize;
        #endif

        Properties->MaxBaud        = SERIAL_BAUD_USER; // SERIAL_BAUD_115200;
        Properties->SettableBaud  = PDevExt->SerialPort.SupportedBauds;

        Properties->ProvSubType  = SERIAL_SP_UNSPECIFIED; // SERIAL_SP_RS232;

        Properties->ProvCapabilities = SERIAL_PCF_DTRDSR | SERIAL_PCF_RTSCTS
                                  | SERIAL_PCF_CD | SERIAL_PCF_XONXOFF
                                  | SERIAL_PCF_TOTALTIMEOUTS | SERIAL_PCF_INTTIMEOUTS
                                  | SERIAL_PCF_SPECIALCHARS;

        Properties->SettableParams = SERIAL_SP_BAUD | SERIAL_SP_CARRIER_DETECT;

        Properties->SettableData  = SERIAL_DATABITS_8;

        Properties->SettableStopParity  = SERIAL_STOPBITS_10 | SERIAL_STOPBITS_20 
                                     | SERIAL_PARITY_NONE | SERIAL_PARITY_ODD  
                                     | SERIAL_PARITY_EVEN | SERIAL_PARITY_MARK
                                     | SERIAL_PARITY_SPACE;

#if defined (USE_RING_BUFF)
        Properties->CurrentRxQueue = PDevExt->RingBuff.Size;
#else
        Properties->CurrentRxQueue = PDevExt->UsbReadBuffSize;
        Properties->CurrentTxQueue = PDevExt->ReadPipe.MaxPacketSize;
#endif

        status = STATUS_SUCCESS;
    }

    KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);

    if (STATUS_SUCCESS == status)  {
        Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
    } else {
        Irp->IoStatus.Information = 0;
    }

    DbgDump(DBG_SERIAL, ("<GetProperties %x\n", status));

    return status;
}



__inline
NTSTATUS
LsrmstInsert(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   UNREFERENCED_PARAMETER(  Irp );
   UNREFERENCED_PARAMETER( PDevExt );

   DbgDump(DBG_SERIAL, (">LsrmstInsert (%p)\n", Irp));
   DbgDump(DBG_SERIAL, ("<LsrmstInsert (%x)\n", STATUS_NOT_SUPPORTED));

   return STATUS_NOT_SUPPORTED;
}



__inline
NTSTATUS
ConfigSize(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   PULONG               ConfigSize = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS             status = STATUS_SUCCESS;
   PIO_STACK_LOCATION   IrpStack;

   UNREFERENCED_PARAMETER( PDevExt );

   DbgDump(DBG_SERIAL, (">ConfigSize (%p)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {

      status = STATUS_BUFFER_TOO_SMALL;
      DbgDump(DBG_ERR, ("ConfigSize: (0x%x)\n", status));
   
   } else {
      *ConfigSize = 0;

      Irp->IoStatus.Information = sizeof(ULONG);
   }

   DbgDump(DBG_SERIAL, ("<ConfigSize %x\n", status));

   return status;
}



__inline
NTSTATUS
GetStats(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
    PSERIALPERF_STATS pStats = NULL;
    PIO_STACK_LOCATION pIrpSp;
    NTSTATUS status = STATUS_DELETE_PENDING;
    ULONG information = 0;
    KIRQL irql;

    DbgDump(DBG_SERIAL, (">GetStats %p\n", PIrp));

    KeAcquireSpinLock(&PDevExt->ControlLock, &irql );
      
    pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIALPERF_STATS) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        DbgDump(DBG_ERR, ("GetStats: (0x%x)\n", status));

    } else {
        information = sizeof(SERIALPERF_STATS);
        status = STATUS_SUCCESS;

        pStats = (PSERIALPERF_STATS)PIrp->AssociatedIrp.SystemBuffer;                  
        RtlZeroMemory(pStats , sizeof(SERIALPERF_STATS));

        pStats->ReceivedCount     = PDevExt->TtlUSBReadBytes;
        pStats->TransmittedCount = PDevExt->TtlWriteBytes;
        pStats->FrameErrorCount  = PDevExt->ReadDeviceErrors + PDevExt->WriteDeviceErrors + PDevExt->IntDeviceErrors; // ??
        pStats->SerialOverrunErrorCount = PDevExt->TtlUSBReadBuffOverruns;
#if defined (USE_RING_BUFF)
        pStats->BufferOverrunErrorCount = PDevExt->TtlRingBuffOverruns;
#else
        pStats->BufferOverrunErrorCount = 0;
#endif         
        pStats->ParityErrorCount = 0;

        DbgDump(DBG_SERIAL, ("ReceivedCount:    %d\n", pStats->ReceivedCount )); \
        DbgDump(DBG_SERIAL, ("TransmittedCount: %d\n", pStats->TransmittedCount )); \
        DbgDump(DBG_SERIAL, ("FrameErrorCount:  %d\n", pStats->FrameErrorCount ));  \
        DbgDump(DBG_SERIAL, ("SerialOverrunErrorCount: %d\n", pStats->SerialOverrunErrorCount ));  \
        DbgDump(DBG_SERIAL, ("BufferOverrunErrorCount: %d\n", pStats->BufferOverrunErrorCount ));  \
        DbgDump(DBG_SERIAL, ("ParityErrorCount: %d\n", pStats->ParityErrorCount )); \
   }

   KeReleaseSpinLock(&PDevExt->ControlLock, irql);

   PIrp->IoStatus.Information = information;
   PIrp->IoStatus.Status = status;     

   DbgDump(DBG_SERIAL, ("<GetStats %x\n", status));

   return status;
}



NTSTATUS
ClearStats(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
    NTSTATUS status = STATUS_DELETE_PENDING;
    KIRQL irql;

    DbgDump(DBG_SERIAL, (">ClearStats (%p)\n", Irp));

    KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    PDevExt->TtlWriteRequests = 0;
    PDevExt->TtlWriteBytes = 0;
    PDevExt->TtlReadRequests = 0;
    PDevExt->TtlReadBytes = 0;
    PDevExt->TtlUSBReadRequests = 0;
    PDevExt->TtlUSBReadBytes = 0;
    PDevExt->TtlUSBReadBuffOverruns = 0;
#if defined (USE_RING_BUFF)
    PDevExt->TtlRingBuffOverruns = 0;
#endif
    status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    DbgDump(DBG_SERIAL, ("<ClearStats %x\n", status));

    return status;
}



/*++

Note:  Unhandled IOCTL_SERIAL_: 0x2b002c : function code 11 is IOCTL_MODEM_CHECK_FOR_MODEM,
which if unhandled tells the system to load modem.sys over this serial port driver. 
This is setup by RAS & unimodem.

--*/
NTSTATUS
SerialIoctl(
   PDEVICE_OBJECT PDevObj, 
   PIRP PIrp
   )
{
   PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);
   ULONG ioctl = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
   NTSTATUS status = STATUS_NOT_SUPPORTED;
   BOOLEAN bSignalNeeded = FALSE;
   KIRQL irql;
   LONG lSanity = 0;

   DbgDump(DBG_SERIAL|DBG_TRACE, (">SerialIoctl(%p)\n", PIrp));

    do {
        KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

        //
        // Make sure the device is accepting request
        //
        if ( !CanAcceptIoRequests( PDevObj, FALSE, TRUE) || 
             !NT_SUCCESS(AcquireRemoveLock(&pDevExt->RemoveLock, PIrp)) ) 
        {
            status = STATUS_DELETE_PENDING;
            DbgDump(DBG_WRN, ("SerialIoctl: 0x%x, 0x%x\n", ioctl, status));
            PIrp->IoStatus.Status = status;
            KeReleaseSpinLock(&pDevExt->ControlLock, irql);
            IoCompleteRequest(PIrp, IO_NO_INCREMENT);
            return status;
        }

        ASSERT_SERIAL_PORT( pDevExt->SerialPort );

        KeReleaseSpinLock(&pDevExt->ControlLock, irql);

        switch (ioctl) 
        {
             case IOCTL_SERIAL_SET_BAUD_RATE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_BAUD_RATE\n"));
                status = SetBaudRate(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_BAUD_RATE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_BAUD_RATE\n"));
                status = GetBaudRate(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_LINE_CONTROL:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_LINE_CONTROL\n"));
                status = SetLineControl(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_LINE_CONTROL:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_LINE_CONTROL\n"));
                status = GetLineControl(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_TIMEOUTS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_TIMEOUTS\n"));
                status = SetTimeouts(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_TIMEOUTS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_TIMEOUTS\n"));
                status = GetTimeouts(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_CHARS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_CHARS\n"));
                status = SetSpecialChars(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_CHARS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_CHARS\n"));
                status = GetSpecialChars(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_DTR:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_DTR\n"));
                status = SetClearDTR(pDevExt, PIrp, TRUE);
                break;

             case IOCTL_SERIAL_CLR_DTR:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_CLR_DTR\n"));
                status = SetClearDTR(pDevExt, PIrp, FALSE);
                break;

             case IOCTL_SERIAL_SET_RTS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_RTS\n"));
                status = SetClearRTS(pDevExt, PIrp, TRUE);
                break;

             case IOCTL_SERIAL_CLR_RTS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_CLR_RTS\n"));
                status = SetClearRTS(pDevExt, PIrp, FALSE);
                break;

             case IOCTL_SERIAL_GET_DTRRTS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_DTRRTS\n"));
                status = GetDtrRts(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_BREAK_ON:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_BREAK_ON\n"));
                status = SetBreak(PIrp, pDevExt, 0xFFFF);
                break;

             case IOCTL_SERIAL_SET_BREAK_OFF:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_BREAK_OFF\n"));
                status = SetBreak(PIrp, pDevExt, 0);
                break;

             case IOCTL_SERIAL_SET_QUEUE_SIZE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_QUEUE_SIZE\n"));
                status = SetQueueSize(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_WAIT_MASK:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_WAIT_MASK\n"));
                status = GetWaitMask(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_WAIT_MASK:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_WAIT_MASK\n"));
                status = SetWaitMask(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_WAIT_ON_MASK:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_WAIT_ON_MASK\n"));
                status = WaitOnMask(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_MODEMSTATUS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_MODEMSTATUS\n"));
                status = GetModemStatus(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_COMMSTATUS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_COMMSTATUS\n"));
                status = GetCommStatus(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_IMMEDIATE_CHAR:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_IMMEDIATE_CHAR\n"));
                status = ImmediateChar(PIrp, PDevObj);
                break;

             case IOCTL_SERIAL_PURGE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_PURGE\n"));
                status = Purge(PDevObj, PIrp);
                break;

             case IOCTL_SERIAL_GET_HANDFLOW:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_HANDFLOW\n"));
                status = GetHandflow(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_HANDFLOW:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_HANDFLOW\n"));
                status = SetHandflow(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_RESET_DEVICE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_RESET_DEVICE\n"));
                status = SerialResetDevice(pDevExt, PIrp, TRUE);
                break;

             case IOCTL_SERIAL_LSRMST_INSERT:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_LSRMST_INSERT\n"));
                status = LsrmstInsert(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_CONFIG_SIZE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_CONFIG_SIZE\n"));
                status = ConfigSize(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_STATS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_STATS\n"));
                status = GetStats(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_CLEAR_STATS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_CLEAR_STATS\n"));
                status = ClearStats(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_PROPERTIES:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_PROPERTIES\n"));
                status = GetProperties(PIrp, pDevExt);
                break;

             default:
                DbgDump(DBG_WRN, ("Unhandled IOCTL_SERIAL_: 0x%x : function code %d\n",
                                               ioctl, SERIAL_FNCT_CODE(ioctl) ) );
                status = STATUS_NOT_SUPPORTED;
                break;
        }

   } while (0);

   //
   // Don't complete any pending Irps
   //
   if ( STATUS_PENDING != status) {
      
      PIrp->IoStatus.Status = status;

      ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

      IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

   }

#ifdef DELAY_RXBUFF
   //
   // Special Case: the device was just opened.
   // To emulate a serial port RX buffer we need to kick start a USB read.
   // We don't want to do this in the IRP_MJ_CREATE code since AS does 
   // IOCTL_SERIAL_SET_WAIT_MASK then *two* IOCTL_SERIAL_SET_DTR requests. If we start the USB read
   // too soon then the CE device can get confused with a Read then SetDTR requests.
   // So, if we were just opened, and we have seen *one* successful IOCTL_SERIAL_SET_DTR then start our USB read.
   // Two good DTRs works better, but we'll let one slip for a timeout or something to recover, e.g. iPAQ on NEC E13+.
   // This may cause problems with other apps, but our target is ActiveSync. We could add a magic registry flag is required.
   // This means that outside of the initial get/set descriptors/configuration the USB is quiet until
   // an app opens the device for I/O... which is a good thing. 
   // However, this implementation causes the initial connect to a bit too slow for slow devices (e.g., HP Jornada, Cassiopeia).
   //
   if ( pDevExt->StartUsbRead && (IOCTL_SERIAL_SET_DTR == ioctl) && (STATUS_SUCCESS == status)) 
   {
        if ( 0 == InterlockedDecrement(&pDevExt->StartUsbRead)) 
        {
            if ( !pDevExt->IntPipe.hPipe ) {
                DbgDump(DBG_SERIAL, ("SerialIoctl: kick starting another USB Read\n" ));
                status = UsbRead( pDevExt, FALSE );
            } else {
                DbgDump(DBG_SERIAL, ("SerialIoctl: kick starting another USB INT Read\n" ));
                status = UsbInterruptRead( pDevExt );
            }

            if ( NT_SUCCESS(status) ) {
                // should be STATUS_PENDING
                status = STATUS_SUCCESS;
            } else {
                InterlockedIncrement(&pDevExt->StartUsbRead);
            }
        }
   }
#endif

   DbgDump(DBG_SERIAL|DBG_TRACE, ("<SerialIoctl: %p, 0x%x\n", PIrp, status));   

   return status;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\wceusbsh.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    wceusbsh.c

Abstract:

    Main entrypoint for Windows CE USB Serial Host driver, for
        ... Windows CE USB sync devices:
            SL11, Socket CF cards, HP Jornada, COMPAQ iPAQ, Casio Cassiopeia, etc.
        ... cables using the Anchor AN27x0 chipset (i.e. EZ-Link)
        ... ad-hoc USB NULL Modem Class

Environment:

    kernel mode only

Author:

    Jeff Midkiff (jeffmi)

Revision History:

    07-15-99    :   rev 1.00    ActiveSync 3.1  initial release
    04-20-00    :   rev 1.01    Cedar 3.0 Platform Builder
    09-20-00    :   rev 1.02    finally have some hardware

Notes:

    o) WCE Devices currently do not handle remote wake, nor can we put the device in power-off state when not used, etc.
    o) Pageable Code sections are marked as follows:
           PAGEWCE0 - useable only during init/deinit
           PAGEWCE1 - useable during normal runtime

-- */

#include "wceusbsh.h"

//
// This is currently missing from wdm.h,
// but IoUnregisterShutdownNotification is there
//
#if !defined( IoRegisterShutdownNotification )
NTKERNELAPI
NTSTATUS
IoRegisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );
#endif

NTSTATUS
Create(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

NTSTATUS
Close(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

NTSTATUS
Cleanup(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

VOID
Unload(
   IN PDRIVER_OBJECT DriverObject
   );

NTSTATUS
SetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
QueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Flush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Shutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
KillAllPendingUserIrps(
   PDEVICE_OBJECT PDevObj
   );

NTSTATUS 
SystemControl(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

//
// GLOBALS
//
BOOLEAN g_isWin9x   = FALSE;
BOOLEAN g_ExposeComPort = FALSE;

LONG  g_NumDevices;
LONG  g_lIntTimout = DEFAULT_INT_PIPE_TIMEOUT;
ULONG g_ulAlternateSetting = 0;
ULONG g_ulMaxPipeErrors = DEFAULT_MAX_PIPE_DEVICE_ERRORS;

ULONG DebugLevel;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGEWCE0, AddDevice)

#pragma alloc_text(PAGEWCE1, Unload)
#pragma alloc_text(PAGEWCE1, Flush)
#pragma alloc_text(PAGEWCE1, QueryInformationFile)
#pragma alloc_text(PAGEWCE1, SetInformationFile)
#pragma alloc_text(PAGEWCE1, Shutdown)
#pragma alloc_text(PAGEWCE1, UsbFreeReadBuffer)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT PDrvObj,
    IN PUNICODE_STRING PRegistryPath
    )
{
#ifdef DBG
   CHAR VersionHerald[] = "Windows CE USB Serial Host, Version %s built on %s\n";
   CHAR VersionNumber[] = "1.02";
   CHAR VersionTimestamp[] = __DATE__ " " __TIME__;
#endif

   PAGED_CODE();
   KdPrint((VersionHerald, VersionNumber, VersionTimestamp));

   //
   // determine OS
   //
   g_isWin9x = IsWin9x();
   KdPrint(("This is Win %s\n", g_isWin9x ? "9x" : "NT" ));

   PDrvObj->MajorFunction[IRP_MJ_CREATE]  = Create;
   PDrvObj->MajorFunction[IRP_MJ_CLOSE]   = Close;
   PDrvObj->MajorFunction[IRP_MJ_CLEANUP] = Cleanup;

   PDrvObj->MajorFunction[IRP_MJ_READ]   = Read;
   PDrvObj->MajorFunction[IRP_MJ_WRITE]  = Write;
   PDrvObj->MajorFunction[IRP_MJ_DEVICE_CONTROL]    = SerialIoctl;

   PDrvObj->MajorFunction[IRP_MJ_FLUSH_BUFFERS]     = Flush;
   PDrvObj->MajorFunction[IRP_MJ_QUERY_INFORMATION] = QueryInformationFile;
   PDrvObj->MajorFunction[IRP_MJ_SET_INFORMATION]   = SetInformationFile;

   PDrvObj->DriverExtension->AddDevice  = AddDevice;
   PDrvObj->MajorFunction[IRP_MJ_PNP]   = Pnp;
   PDrvObj->MajorFunction[IRP_MJ_POWER] = Power;
   PDrvObj->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SystemControl;

   PDrvObj->MajorFunction[IRP_MJ_SHUTDOWN] = Shutdown;

   PDrvObj->DriverUnload = Unload;

   //
   // initialize Globals
   //
   g_NumDevices = 0;

   QueryRegistryParameters( PRegistryPath );

   DbgDump(DBG_INIT, ("Create @ %p\n", Create));
   DbgDump(DBG_INIT, ("Close @ %p\n", Close));
   DbgDump(DBG_INIT, ("Cleanup @ %p\n", Cleanup));
   DbgDump(DBG_INIT, ("Read @ %p\n", Read));
   DbgDump(DBG_INIT, ("Write @ %p\n", Write));
   DbgDump(DBG_INIT, ("SerialIoctl @ %p\n", SerialIoctl));
   DbgDump(DBG_INIT, ("Flush @ %p\n", Flush));
   DbgDump(DBG_INIT, ("QueryInformationFile @ %p\n", QueryInformationFile));
   DbgDump(DBG_INIT, ("SetInformationFile @ %p\n", SetInformationFile));
   DbgDump(DBG_INIT, ("AddDevice @ %p\n", AddDevice));
   DbgDump(DBG_INIT, ("Pnp @ %p\n", Pnp));
   DbgDump(DBG_INIT, ("Power @ %p\n", Power));
   DbgDump(DBG_INIT, ("Shutdown @ %p\n", Shutdown));
   DbgDump(DBG_INIT, ("Unload @ %p\n", Unload));

   return STATUS_SUCCESS;
}



NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT PDrvObj,
    IN PDEVICE_OBJECT PPDO
    )
/*++

Routine Description:

    Add our driver to the USB device stack.
    This also creates our base device name and symbolic link.

Arguments:

    PDrvObj - Pointer to our driver object
    PPDO    - Pointer to the PDO for the stack to which we should add ourselves

Return Value:

    NTSTATUS

--*/

{
   NTSTATUS status;
   PDEVICE_OBJECT pDevObj = NULL;
   PDEVICE_EXTENSION pDevExt = NULL;
   LONG  comPortNumber=0;
   BOOLEAN bListsInitilized = FALSE;
   ULONG UniqueErrorValue = 0;

   DbgDump(DBG_INIT, (">AddDevice\n"));
   PAGED_CODE();

   //
   // Create the FDO
   //
   if (PPDO == NULL) {
      DbgDump(DBG_ERR, ("No PDO\n"));
      return STATUS_NO_MORE_ENTRIES;
   }

   //
   // create a named device object
   // and unprotected symbolic link.
   //
   status = CreateDevObjAndSymLink(
                  PDrvObj,
                  PPDO,
                  &pDevObj,
                  DRV_NAME );

   if ( (status != STATUS_SUCCESS) || !pDevObj ) {
      DbgDump(DBG_ERR, ("CreateDevObjAndSymLink error: 0x%x\n", status));
      UniqueErrorValue = ERR_NO_DEVICE_OBJ;
      goto AddDeviceFailed;
   }

   DbgDump( DBG_INIT, ("DevObj: %p\n", pDevObj));

   // init our device extension
   //
   pDevExt = pDevObj->DeviceExtension;

   pDevExt->DeviceObject = pDevObj;

   pDevExt->PDO = PPDO;

   // init our states
   //
   InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateInitialized);
#ifdef POWER
   pDevExt->DevicePowerState= PowerDeviceD0;
#endif

   // set FDO flags
   //
   ASSERT( !(pDevObj->Flags & DO_POWER_PAGABLE) );
   pDevObj->Flags |= (PPDO->Flags & DO_POWER_PAGABLE);

   pDevObj->Flags |= DO_BUFFERED_IO;
   pDevObj->Flags &= ~ DO_DEVICE_INITIALIZING;

   //
   // Create or initialize any other non-hardware resources here.
   // These items get cleaned up in IRP_MN_REMOVE_DEVICE....
   //

   // Initialize locks
   //
   KeInitializeSpinLock(&pDevExt->ControlLock);

   InitializeRemoveLock( &pDevExt->RemoveLock );

   //
   // Initialize USB Read Buffer, This value has an effect on performance.
   // In addition to testing the endpoint's MaximumPacketSize (64 byte max),
   // I tested 512, 1024, 2048, & 4096 across the EZ-Link, SL11, & CF.
   // 1024, 2048, and 4096 all gave similiar results which were much faster than 64 bytes
   // or even 512.
   //
   // EZ-Link Note: the pserial perf tests can sometimes go into timeout/retry/abort
   // situatiuon in the 2nd phase of a test. This is because it closes and then re-opens (so therefore purges) the driver's read  buffer.
   // The driver's USB read buffer is purged of a full 960 byte device FIFO, already consumed by the driver.
   // This is viewable in the debugger using DBG_READ_LENGTH. This does not happen with ActiveSync.
   //
   pDevExt->UsbReadBuffSize = USB_READBUFF_SIZE;
   pDevExt->UsbReadBuff = ExAllocatePool( NonPagedPool, pDevExt->UsbReadBuffSize );
   if ( !pDevExt->UsbReadBuff ) {

      status = STATUS_INSUFFICIENT_RESOURCES;
      UniqueErrorValue = ERR_NO_USBREAD_BUFF;

      goto AddDeviceFailed;
   }

   pDevExt->MaximumTransferSize = DEFAULT_PIPE_MAX_TRANSFER_SIZE;

#if defined (USE_RING_BUFF)
   // setup Ring Buffer
   pDevExt->RingBuff.Size  = RINGBUFF_SIZE;
   pDevExt->RingBuff.pHead =
   pDevExt->RingBuff.pTail =
   pDevExt->RingBuff.pBase = ExAllocatePool( NonPagedPool, pDevExt->RingBuff.Size );
   if ( !pDevExt->RingBuff.pBase ) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      UniqueErrorValue = ERR_NO_RING_BUFF;
      goto AddDeviceFailed;
   }
#endif

   // Initialize events
   //
   KeInitializeEvent( &pDevExt->PendingDataInEvent,    NotificationEvent /*SynchronizationEvent*/, FALSE);
   KeInitializeEvent( &pDevExt->PendingDataOutEvent,   NotificationEvent /*SynchronizationEvent*/, FALSE);
   KeInitializeEvent( &pDevExt->PendingIntEvent,       NotificationEvent /*SynchronizationEvent*/, FALSE);
   KeInitializeEvent( &pDevExt->PendingWorkItemsEvent, NotificationEvent /*SynchronizationEvent*/, FALSE);

   //
   // initialize nonpaged pools...
   //
   ExInitializeNPagedLookasideList(
         &pDevExt->PacketPool,   // Lookaside,
         NULL,                   // Allocate  OPTIONAL,
         NULL,                   // Free  OPTIONAL,
         0,                      // Flags,
         sizeof(USB_PACKET),   // Size,
         WCEUSB_POOL_TAG,        // Tag,
         0 );                    // Depth
   DbgDump(DBG_INIT, ("PacketPool: %p\n", &pDevExt->PacketPool));


   ExInitializeNPagedLookasideList(
         &pDevExt->BulkTransferUrbPool,
         NULL, NULL, 0,
         sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
         WCEUSB_POOL_TAG,
         0 );
   DbgDump(DBG_INIT, ("BulkTransferUrbPool: %p\n", &pDevExt->BulkTransferUrbPool));


   ExInitializeNPagedLookasideList(
         &pDevExt->PipeRequestUrbPool,
         NULL, NULL, 0,
         sizeof(struct _URB_PIPE_REQUEST),
         WCEUSB_POOL_TAG,
         0 );
   DbgDump(DBG_INIT, ("PipeRequestUrbPool: %p\n", &pDevExt->PipeRequestUrbPool));


   ExInitializeNPagedLookasideList(
         &pDevExt->VendorRequestUrbPool,
         NULL, NULL, 0,
         sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
         WCEUSB_POOL_TAG,
         0 );
   DbgDump(DBG_INIT, ("VendorRequestUrbPool: %p\n", &pDevExt->VendorRequestUrbPool));


   ExInitializeNPagedLookasideList(
         &pDevExt->WorkItemPool,
         NULL, NULL, 0,
         sizeof(WCE_WORK_ITEM),
         WCEUSB_POOL_TAG,
         0 );
   DbgDump(DBG_INIT, ("WorkItemPool: %p\n", &pDevExt->WorkItemPool));


   bListsInitilized = TRUE;


   //
   // initialize pending I/O lists
   //
   InitializeListHead( &pDevExt->PendingReadPackets );
   pDevExt->PendingReadCount = 0;

   InitializeListHead( &pDevExt->PendingWritePackets );
   pDevExt->PendingWriteCount = 0;

   InitializeListHead(&pDevExt->UserReadQueue);

   InitializeListHead( &pDevExt->PendingWorkItems );
   pDevExt->PendingWorkItemsCount = 0;


   //
   // Win 2000 ONLY : setup external SerialPort (COMx) interface
   // iff the user setup the magic reg key under
   // HKLM\SYSTEM\ControlSet\Services\wceusbsh\Parameters\ExposeComPort:REG_DWORD:1
   // This is NOT required for ActiveSync, only testing and is disabled by default.
   //
   // The Win9x CommXxx API *requires* going through VCOMM. Thus, we must
   // be installed as a virtual modem, and use ccport.sys and wdmmdmld.vxd ... NFW.
   //
   if ( !g_isWin9x && g_ExposeComPort ) {
      //
      // N.B. we don't want to use the static port name from the registry because the device
      // can come & go quickly (power up/down, etc.) and run into name collisions.
      //comPortNumber = GetComPort(pDevObj, pDevExt->SerialPort.Com.Instance-1);
      comPortNumber = GetFreeComPortNumber( );
      if (-1 == comPortNumber) {
         status = STATUS_DEVICE_DATA_ERROR;
         UniqueErrorValue = ERR_COMM_SYMLINK;
         goto AddDeviceFailed;
      }

      status = DoSerialPortNaming( pDevExt, comPortNumber );
      if (status != STATUS_SUCCESS) {
         UniqueErrorValue = ERR_COMM_SYMLINK;
         DbgDump(DBG_ERR, ("DoSerialPortNaming error: 0x%x\n", status));
         goto AddDeviceFailed;
      }

      status = IoRegisterShutdownNotification( pDevExt->DeviceObject );
      if (status != STATUS_SUCCESS) {
         UniqueErrorValue = ERR_COMM_SYMLINK;
         DbgDump(DBG_ERR, ("IoRegisterShutdownNotification error: 0x%x\n", status));
         TEST_TRAP();
         goto AddDeviceFailed;
      }

   } else {
        DbgDump(DBG_INIT, ("!GetFreeComPortNumber(%d, %d)\n", g_isWin9x, g_ExposeComPort));
   }

   //
   // attach to device stack
   //
   pDevExt->NextDevice = IoAttachDeviceToDeviceStack(pDevObj, PPDO);
   if ( !pDevExt->NextDevice ) {

      status = STATUS_NO_SUCH_DEVICE;
      DbgDump(DBG_ERR, ("IoAttachDeviceToDeviceStack error: 0x%x\n", status));

   } else {

      // set state after we attach to the stack
      InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateAttached);

   }

#if PERFORMANCE
   InitPerfCounters();
#endif


AddDeviceFailed:

   if (status != STATUS_SUCCESS) {

      if (pDevObj != NULL) {
         UsbFreeReadBuffer( pDevObj );
         if (pDevExt) {
            if (pDevExt->NextDevice) {
                DbgDump(DBG_INIT, ("Detach from PDO\n"));
                IoDetachDevice(pDevExt->NextDevice);
            }
            if ( bListsInitilized) {
               //
               // delete LookasideLists
               //
               DbgDump(DBG_INIT, ("Deleting LookasideLists\n"));
               ExDeleteNPagedLookasideList( &pDevExt->PacketPool );
               ExDeleteNPagedLookasideList( &pDevExt->BulkTransferUrbPool );
               ExDeleteNPagedLookasideList( &pDevExt->PipeRequestUrbPool );
               ExDeleteNPagedLookasideList( &pDevExt->VendorRequestUrbPool );
               ExDeleteNPagedLookasideList( &pDevExt->WorkItemPool );
            }
            UndoSerialPortNaming(pDevExt);
         }
         ReleaseSlot( PtrToLong(NULL) );
         DeleteDevObjAndSymLink(pDevObj);
      }
   }

   if (STATUS_INSUFFICIENT_RESOURCES == status) {

      DbgDump(DBG_ERR, ("AddDevice ERROR: 0x%x, %d\n", status, UniqueErrorValue));
      LogError( PDrvObj,
                NULL,
                0, 0, 0,
                UniqueErrorValue,
                status,
                SERIAL_INSUFFICIENT_RESOURCES,
                (pDevExt && pDevExt->DeviceName.Buffer) ? pDevExt->DeviceName.Length + sizeof(WCHAR) : 0,
                (pDevExt && pDevExt->DeviceName.Buffer) ? pDevExt->DeviceName.Buffer : NULL,
                0, NULL );

   } else if (STATUS_SUCCESS != status ) {
      // handles all other failures
      LogError( PDrvObj,
                NULL,
                0, 0, 0,
                UniqueErrorValue,
                status,
                SERIAL_INIT_FAILED,
                (pDevExt && pDevExt->DeviceName.Buffer) ? pDevExt->DeviceName.Length + sizeof(WCHAR) : 0,
                (pDevExt && pDevExt->DeviceName.Buffer) ? pDevExt->DeviceName.Buffer : NULL,
                0, NULL );
   }

   DbgDump(DBG_INIT, ("<AddDevice 0x%x\n", status));

   return status;
}



NTSTATUS
Create(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   )
{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    NTSTATUS status;

    DbgDump(DBG_INIT|DBG_TRACE, (">Create (%p)\n", PDevObj));

    if (!CanAcceptIoRequests(PDevObj, TRUE, FALSE) ||
        !NT_SUCCESS(AcquireRemoveLock(&pDevExt->RemoveLock, IRP_MJ_CREATE)))
    {
        status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("Create: 0x%x\n", status));
        PIrp->IoStatus.Status = status;
        IoCompleteRequest(PIrp, IO_NO_INCREMENT);
        return status;
    }

    ASSERT_SERIAL_PORT(pDevExt->SerialPort);

    //
    // Serial devices do not allow multiple concurrent opens
    //
    if ( InterlockedIncrement( &pDevExt->SerialPort.Com.OpenCnt ) != 1 ) {
        InterlockedDecrement( &pDevExt->SerialPort.Com.OpenCnt );
        status = STATUS_ACCESS_DENIED;
        DbgDump(DBG_ERR, ("OpenComPort ERROR: 0x%x\n", status));
        goto CreateDone;
    }

    InterlockedExchange(&pDevExt->DeviceOpened, TRUE);

    // Take out an additional reference on ourself.
    // We are seeing a possible premature unload with open handles in ActiveSync.
    // We dereference it in IRP_MJ_CLEANUP instead or IRP_MJ_CLOSE in case the app crashes
    // where we wouldn't otherwise get it.
    ObReferenceObject( PDevObj );

    //
    // reset the virtual serial port interface,
    // but don't send anything on the bus yet
    //
    status = SerialResetDevice(pDevExt, PIrp, FALSE);

    if (STATUS_SUCCESS == status) {
        //
        // CederRapier BUGBUG 13310: clean the read buffer when the app does CreateFile.
        //
        status = SerialPurgeRxClear(PDevObj, TRUE );

        if ( NT_SUCCESS(status) ) {

#if !defined(DELAY_RXBUFF)
            // this will subit the read a bit earlier, making the connection faster
            if ( !pDevExt->IntPipe.hPipe ) {
                DbgDump(DBG_INIT, ("Create: kick starting another USB Read\n" ));
                status = UsbRead( pDevExt, FALSE );
            } else {
                DbgDump(DBG_INIT, ("Create: kick starting another USB INT Read\n" ));
                status = UsbInterruptRead( pDevExt );
            }

            if ( NT_SUCCESS(status) ) {
                // should be STATUS_PENDING
                status = STATUS_SUCCESS;
            }
#else
            // signal to start the RX buffer in SerIoctl
            InterlockedExchange(&pDevExt->StartUsbRead, 1);
#endif

        } else {
            DbgDump(DBG_ERR, ("SerialPurgeRxClear ERROR: %x\n", status));
            TEST_TRAP();
        }
    }

    if (STATUS_SUCCESS != status) {
        //
        // Let the user know that the device can not be opened.
        //
        DbgDump(DBG_ERR, ("*** UNRECOVERABLE CreateFile ERROR:0x%x, No longer Accepting Requests ***\n", status));

        InterlockedExchange(&pDevExt->AcceptingRequests, FALSE);

        InterlockedExchange(&pDevExt->DeviceOpened, FALSE);

        IoInvalidateDeviceState( pDevExt->PDO );

        LogError( NULL, PDevObj,
                  0, IRP_MJ_CREATE,
                  1, // retries
                  ERR_NO_CREATE_FILE,
                  status,
                  SERIAL_HARDWARE_FAILURE,
                  pDevExt->DeviceName.Length + sizeof(WCHAR),
                  pDevExt->DeviceName.Buffer,
                  0,
                  NULL );
    }

CreateDone:
   // we release this reference on Close.
   if (STATUS_SUCCESS != status) {
        ReleaseRemoveLock(&pDevExt->RemoveLock, IRP_MJ_CREATE);
   }

   PIrp->IoStatus.Status = status;
   PIrp->IoStatus.Information = 0;
   IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

   DbgDump(DBG_INIT|DBG_TRACE, ("<Create 0x%x\n", status));

   return status;
}


NTSTATUS
Close(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   )
{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG openCount;

    DbgDump(DBG_INIT|DBG_TRACE, (">Close (%p)\n", PDevObj));
    PAGED_CODE();

    ASSERT_SERIAL_PORT(pDevExt->SerialPort);

    //
    // stop any pending I/O
    //
    InterlockedExchange(&pDevExt->DeviceOpened, FALSE);

    status = StopIo(PDevObj);

    if (STATUS_SUCCESS == status) {

        if ( pDevExt->SerialPort.Com.OpenCnt ) {

            openCount = InterlockedDecrement( &pDevExt->SerialPort.Com.OpenCnt );

            if ( openCount != 0) {
               status = STATUS_UNSUCCESSFUL;
               DbgDump(DBG_WRN, ("Close ERROR: 0x%x RE: %d\n", status, openCount));
               TEST_TRAP();
            }
#ifdef DELAY_RXBUFF
            // signal our RX buffer
            InterlockedExchange(&pDevExt->StartUsbRead, 0);
#endif
        }

    } else {
        DbgDump(DBG_ERR, ("StopIo ERROR: 0x%x\n", status));
        TEST_TRAP();
    }

    PIrp->IoStatus.Status = status;
    PIrp->IoStatus.Information = 0;

    IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

    if (STATUS_SUCCESS == status) {
        // Release the lock acquired in IRP_MJ_CREATE.
        // Warning: if the app misses our PnP signal then could we hang on this reference?
        ReleaseRemoveLock(&pDevExt->RemoveLock, IRP_MJ_CREATE);
   }

   DbgDump(DBG_INIT|DBG_TRACE, ("<Close 0x%x\n", status));

   return status;
}


NTSTATUS
Cleanup(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP Irp
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;

   DbgDump(DBG_INIT, (">Cleanup\n"));

   //
   // stop any pending I/O
   //
   InterlockedExchange(&pDevExt->DeviceOpened, FALSE);

   status = StopIo(PDevObj);
   if (STATUS_SUCCESS != status) {
       DbgDump(DBG_ERR, ("StopIo ERROR: 0x%x\n", status));
       TEST_TRAP();
   }

#ifdef DELAY_RXBUFF
   // signal our RX buffer
   InterlockedExchange(&pDevExt->StartUsbRead, 0);
#endif

   // Dereference the additional reference taken on IRP_MJ_CREATE.
   ObDereferenceObject( PDevObj );

   Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information = 0;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   DbgDump(DBG_INIT, ("<Cleanup 0x%x\n", status));
   return status;
}



VOID
KillAllPendingUserReads(
   IN PDEVICE_OBJECT PDevObj,
   IN PLIST_ENTRY PQueueToClean,
   IN PIRP *PpCurrentOpIrp
   )

/*++

Routine Description:

    cancel all queued user reads.

Arguments:

    PDevObj - A pointer to the serial device object.

    PQueueToClean - A pointer to the queue which we're going to clean out.

    PpCurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    KIRQL irql;
    NTSTATUS status;

    DbgDump( DBG_IRP, (">KillAllPendingUserReads\n"));


    KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

    //
    // Clean the list from back to front.
    //
    while (!IsListEmpty(PQueueToClean)) {

        PIRP pCurrentLastIrp = CONTAINING_RECORD( PQueueToClean->Blink,
                                                  IRP,
                                                  Tail.Overlay.ListEntry);

        RemoveEntryList(PQueueToClean->Blink);

        KeReleaseSpinLock( &pDevExt->ControlLock, irql );

        status = ManuallyCancelIrp( PDevObj, pCurrentLastIrp);

        ASSERT(STATUS_SUCCESS == status );

        KeAcquireSpinLock( &pDevExt->ControlLock, &irql );
    }

    //
    // The queue is clean.  Now go after the current if
    // it's there.
    //
    if (*PpCurrentOpIrp) {

        KeReleaseSpinLock( &pDevExt->ControlLock, irql );

        status = ManuallyCancelIrp( PDevObj, *PpCurrentOpIrp );

        ASSERT(STATUS_SUCCESS == status );

    } else {

        DbgDump(DBG_IRP, ("No current Irp\n"));
        KeReleaseSpinLock( &pDevExt->ControlLock, irql );

    }

   DbgDump( DBG_IRP, ("<KillAllPendingUserReads\n"));

   return;
}


VOID
Unload(
   IN PDRIVER_OBJECT DriverObject
   )
/*++

Routine Description:

   Undo everything setup in DriverEntry

Arguments:

    DriverObject

Return Value:

    VOID

--*/
{
   UNREFERENCED_PARAMETER( DriverObject );

   DbgDump(DBG_INIT, (">Unload\n"));
   PAGED_CODE();

   // release global resources here

   DbgDump(DBG_INIT, ("<Unload\n"));
}



NTSTATUS
Flush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );

    DbgDump( DBG_INIT|DBG_READ_LENGTH|DBG_WRITE_LENGTH, ("Flush\n"));
    PAGED_CODE();

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0L;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}



NTSTATUS
QueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    UNREFERENCED_PARAMETER(DeviceObject);

    DbgDump( DBG_INIT|DBG_READ_LENGTH, (">QueryInformationFile\n"));
    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    if (IrpSp->Parameters.QueryFile.FileInformationClass == FileStandardInformation) {

        PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;

        Buf->AllocationSize.QuadPart = 0;
        Buf->EndOfFile = Buf->AllocationSize;
        Buf->NumberOfLinks = 0;
        Buf->DeletePending = FALSE;
        Buf->Directory = FALSE;
        Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);

    } else if (IrpSp->Parameters.QueryFile.FileInformationClass == FilePositionInformation) {

        ((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->CurrentByteOffset.QuadPart = 0;
        Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);

    } else {
        Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
    }

   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   DbgDump( DBG_INIT|DBG_READ_LENGTH, ("<QueryInformationFile\n"));

    return Status;
}



NTSTATUS
SetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    DbgDump( DBG_INIT|DBG_READ_LENGTH, (">SetInformationFile\n"));

    Irp->IoStatus.Information = 0L;

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation) {
//        || (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileAllocationInformation)) { // FileAllocationInformationnot defined in wdm.h

        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_INVALID_PARAMETER;

    }

   Irp->IoStatus.Status = Status;

   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   DbgDump( DBG_INIT|DBG_READ_LENGTH, ("<SetInformationFile\n"));

    return Status;
}



NTSTATUS
Shutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    DbgDump(DBG_INIT, (">Shutdown\n"));
    PAGED_CODE();

    //
    // Special Case - If an app has an open handle to the device,
    // and the system is being shut down in a controlled manner,
    // and we have not been removed via PnP, then remove the COMx name
    // from the Registry's COM Name Arbitrator DataBase for the next boot cycle.
    // Win NT only; Win9x does not export COMx names.
    //
    // N.B: we have to do this in a Shutdown handler, and NOT in the PNP_POWER handler
    // because the Registry entry is NOT saved in the Power down code path.
    //
    if ( !g_isWin9x && g_ExposeComPort &&
         pDevExt->SerialPort.Com.PortNumber &&
         (PnPStateStarted  == pDevExt->PnPState) ) {
            //
            // remove our entry from ComDB
            //
            ReleaseCOMPort( pDevExt->SerialPort.Com.PortNumber );
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0L;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DbgDump(DBG_INIT, ("<Shutdown\n"));

    return status;
}


VOID
UsbFreeReadBuffer(
   IN PDEVICE_OBJECT PDevObj
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

   DbgDump(DBG_USB, (">UsbFreeReadBuffer %p\n", PDevObj));
   PAGED_CODE();

   if ( pDevExt->UsbReadBuff != NULL ) {
      ExFreePool(pDevExt->UsbReadBuff);
      pDevExt->UsbReadBuff = NULL;
   }

#if defined (USE_RING_BUFF)
   if ( pDevExt->RingBuff.pBase != NULL ) {
      ExFreePool(pDevExt->RingBuff.pBase);
      pDevExt->RingBuff.pBase =
      pDevExt->RingBuff.pHead =
      pDevExt->RingBuff.pTail = NULL;
   }
#endif // USE_RING_BUFF

   DbgDump(DBG_USB, ("<UsbFreeReadBuffer\n"));
   return;
}


NTSTATUS 
SystemControl(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
{
    PDEVICE_EXTENSION   pDevExt;

    PAGED_CODE();

    DbgDump(DBG_INIT, ("SystemControl\n"));

    pDevExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(pDevExt->NextDevice, Irp);
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\inc\hackflag.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    hackflag.h

Abstract:

    USB 'hack flags' are defined to work around specific 
    device problems.

    These flags are placed in the registry under 
    HKLM\CCS\Services\USB\DeviceHackFlags\VIDnnnn&PIDnnnn&REVnnnn
    or
    HKLM\CCS\Services\USB\DeviceHackFlags\VIDnnnn&PIDnnnn

    as a DWORD key HackFlags

Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __HACKFLAG_H__
#define   __HACKFLAG_H__



#define USB_HACKFLAG_IGNORE_PF_XXX         0x00000001


#endif    //__HACKFLAG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\hccoin\hccoin.h ===
#ifndef _HCCOIN_H
#define _HCCOIN_H


DWORD
HCCOIN_DoWin2kInstall(
    HDEVINFO  DeviceInfoSet,
    PSP_DEVINFO_DATA  DeviceInfoData
    );

DWORD 
HCCOIN_CheckControllers(
    DWORD Haction,
    DWORD NextHaction
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\write.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

   write.c

Abstract:

   Write functions

Environment:

   kernel mode only

Revision History:

   07-14-99 : created

Authors:

   Jeff Midkiff (jeffmi)

-- */

#include <wdm.h>
#include <stdio.h>
#include <stdlib.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddser.h>

#include "wceusbsh.h"

NTSTATUS
WriteComplete(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp,
   IN PUSB_PACKET PPacket
   );

VOID
WriteTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   );

#if DBG
VOID
DbgDumpReadWriteData(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp,
   IN BOOLEAN Read
   );
#else
#define DbgDumpReadWriteData( _devobj, _irp, _read )
#endif



NTSTATUS
Write(
   IN PDEVICE_OBJECT PDevObj,
   PIRP PIrp
   )
/*++

Routine Description:

   Process the IRPs sent to this device for writing.
   IRP_MJ_WRITE

Arguments:

    PDevObj - Pointer to the device object for the device written to
    PIrp       - Pointer to the write IRP.

Return Value:

    NTSTATUS

Notes:

   The AN2720 is a low-quality FIFO device and will NAK all packets when it's
   FIFO gets full. We can't get real device status, like serial port registers.
   If we submit a USBDI 'GetEndpointStatus', then all we get back is a stall bit.
   PROBLEM: what to do when it's FIFO get's full, i.e., how to handle flow control?
   If the peer/client on the other side of the FIFO is not reading packets out of the FIFO,
   then AN2720 NAKS every packet thereafter, until the FIFO gets drained (or, at least 1 packet
   removed).

   Here's what we currently do: on every _USB_PACKET we submit, set a timeout.
   When the timer expires we check if our R/W completion routine has already cancelled that
   packet's timer. If our completion did cancel the timer, then we are done.
   If not, then we timed out on this packet. We do not reset the endpoint on a timeout
   since the FIFO's contents will be lost. We simply complete the Irp to
   user with STATUS_TIMEOUT. User should then go into whatever retry logic they require.

--*/
{
   PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   KIRQL irql;
   LARGE_INTEGER timeOut = {0,0};
   ULONG ulTransferLength;
   NTSTATUS status = STATUS_UNSUCCESSFUL;
   BOOLEAN bCompleteIrp = FALSE;

   PERF_ENTRY( PERF_Write );

   DbgDump(DBG_WRITE|DBG_TRACE, (">Write(%p, %p, %x)\n", PDevObj, PIrp, Read));

   PIrp->IoStatus.Information = 0L;

    //
    // Make sure the device is accepting request
    //
    if ( !CanAcceptIoRequests( PDevObj, TRUE, TRUE) ||
         !NT_SUCCESS(AcquireRemoveLock(&pDevExt->RemoveLock, PIrp)) )
    {
        status = PIrp->IoStatus.Status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("Write ERROR: 0x%x\n", status));
        PIrp->IoStatus.Status = status;
        IoCompleteRequest(PIrp, IO_NO_INCREMENT);
        return status;
   }

   //
   // Check write length.
   // Allow zero length writes for apps to send a NULL packet
   // to signal end of transaction.
   //
   ulTransferLength = pIrpSp->Parameters.Write.Length;

   if ( ulTransferLength > pDevExt->MaximumTransferSize ) {

      DbgDump(DBG_ERR, ("Write Buffer too large: %d\n", ulTransferLength ));

      status = PIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

      bCompleteIrp = TRUE;

      goto WriteExit;
   }

   DbgDump(DBG_WRITE_LENGTH, ("User Write request length: %d\n", ulTransferLength ));

   //
   // calculate Serial TimeOut values
   //
    ASSERT_SERIAL_PORT(pDevExt->SerialPort);

    CalculateTimeout( &timeOut,
                    pIrpSp->Parameters.Write.Length,
                    pDevExt->SerialPort.Timeouts.WriteTotalTimeoutMultiplier,
                    pDevExt->SerialPort.Timeouts.WriteTotalTimeoutConstant );

    DbgDump(DBG_TIME, ("CalculateWriteTimeOut = %d msec\n", timeOut.QuadPart ));

    status = STATUS_SUCCESS;

   //
   // check if this Irp should be cancelled.
   // Note that we don't queue write Irps.
   //
   IoAcquireCancelSpinLock(&irql);

   if (PIrp->Cancel) {

      TEST_TRAP();
      IoReleaseCancelSpinLock(irql);
      status = PIrp->IoStatus.Status = STATUS_CANCELLED;
      // since we don't set a completion routine we complete it here
      bCompleteIrp = TRUE;

   } else {
      //
      // prepare to submit the IRP to the USB stack.
      //
      IoSetCancelRoutine(PIrp, NULL);
      IoReleaseCancelSpinLock(irql);

      KeAcquireSpinLock( &pDevExt->ControlLock, &irql);

      IRP_INIT_REFERENCE(PIrp);

      // set current number of chars in the Tx buffer
      InterlockedExchange( &pDevExt->SerialPort.CharsInWriteBuf, ulTransferLength );

      KeClearEvent( &pDevExt->PendingDataOutEvent );

      //
      // bump ttl request count
      //
      pDevExt->TtlWriteRequests++;

      KeReleaseSpinLock( &pDevExt->ControlLock, irql);

      status = UsbReadWritePacket( pDevExt,
                                   PIrp,
                                   WriteComplete,
                                   timeOut,
                                   WriteTimeout,
                                   FALSE );

   }

WriteExit:

   if (bCompleteIrp)
   {
       ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

       IoCompleteRequest (PIrp, IO_SERIAL_INCREMENT );
   }

   DbgDump(DBG_WRITE|DBG_TRACE, ("<Write 0x%x\n", status));

   PERF_EXIT( PERF_Write );

   return status;
}



NTSTATUS
WriteComplete(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp,
   IN PUSB_PACKET PPacket
   )
/*++

Routine Description:

    This is the completion routine for Write requests.
    It assumes you have the serial port context.

Arguments:

    PDevObj - Pointer to device object
    PIrp    - Irp we are completing
    PPacket - USB Packet which will be freed

Return Value:

    NTSTATUS -- propogate Irp's status.

Notes:

   This routine runs at DPC_LEVEL.

--*/
{
   PDEVICE_EXTENSION pDevExt = PPacket->DeviceExtension;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   PURB pUrb = &PPacket->Urb;
   NTSTATUS irpStatus, workStatus;
   USBD_STATUS urbStatus;
   KIRQL irql;
   LONG curCount;

   PERF_ENTRY( PERF_WriteComplete );

   UNREFERENCED_PARAMETER( PDevObj );

   DbgDump(DBG_WRITE, (">WriteComplete(%p, %p, %p)\n", PDevObj, PIrp, PPacket));

   // Note: we don't hold the control lock so this could
   // disappear on us.
   ASSERT_SERIAL_PORT(pDevExt->SerialPort);

   //
   // First off, cancel the Packet Timer
   //
   if ( PPacket->Timeout.QuadPart != 0 ) {

      if (KeCancelTimer( &PPacket->TimerObj ) ) {
         //
         // the packet's timer was successfully removed from the system
         //
      } else {
         //
         // the timer could be spinning on the control lock,
         // so tell it we took the Irp.
         //
         PPacket->Status = STATUS_ALERTED;
      }

   }

   //
   // Now we can process the Irp.
   // If the lower driver returned PENDING,
   // then mark our stack location as pending.
   //
   if ( PIrp->PendingReturned ) {
      DbgDump(DBG_WRITE, ("Resetting Irp STATUS_PENDING\n"));
      IoMarkIrpPending(PIrp);
   }

   //
   // This is the R/W operation's return status.
   // irpStatus is the Irp's completion status
   // ubrStatus is a more USBD specific Urb operation completion status
   //
   irpStatus = PIrp->IoStatus.Status;
   DbgDump(DBG_WRITE, ("Irp->IoStatus.Status  0x%x\n", irpStatus));

   urbStatus = pUrb->UrbHeader.Status;
   DbgDump(DBG_WRITE, ("Urb->UrbHeader.Status 0x%x\n", urbStatus  ));

   // get the Irp type Read or Write
   ASSERT( IRP_MJ_WRITE == pIrpStack->MajorFunction );

   switch (irpStatus) {

      case STATUS_SUCCESS: {
//         ASSERT( USBD_STATUS_SUCCESS == urbStatus );

         //
         // indicate the number of Tx bytes transferred, as indicated in the Urb
         //
         PIrp->IoStatus.Information = pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;

         //
         // indicate that our Tx buffer is empty, although the data may
         // actually still reside on the AN2720 chip.
         // There is no way for us to know.
         //
         InterlockedExchange( &pDevExt->SerialPort.CharsInWriteBuf, 0 );

         //
         // clear pipe error count
         //
         InterlockedExchange( &pDevExt->WriteDeviceErrors, 0);

         //
         // incr ttl byte counter
         //
         pDevExt->TtlWriteBytes += (ULONG)PIrp->IoStatus.Information;

         DbgDump( DBG_WRITE_LENGTH , ("USB Write indication: %d\n",  PIrp->IoStatus.Information) );

         DbgDumpReadWriteData( PDevObj, PIrp, FALSE);
      }
      break;

      case STATUS_CANCELLED:  {

            DbgDump(DBG_WRN|DBG_WRITE|DBG_IRP, ("Write: STATUS_CANCELLED\n"));
            //
            // If it was cancelled, it may have timed out.
            // We can tell by looking at the packet attached to it.
            //
            if ( STATUS_TIMEOUT == PPacket->Status ) {
                //
               // more than likely the FIFO was stalled (i.e., the other side did not
               // read fom the endpoint). Inform user we timed out the R/W request
               //
               ASSERT( USBD_STATUS_CANCELED == urbStatus);
               irpStatus = PIrp->IoStatus.Status = STATUS_TIMEOUT;
               DbgDump(DBG_WRN|DBG_WRITE|DBG_IRP, ("Write: STATUS_TIMEOUT\n"));
            }
      }
      break;

      case STATUS_DEVICE_DATA_ERROR:   {
         //
         // generic device error set by USBD.
         //
         DbgDump(DBG_ERR, ("WritePipe STATUS_DEVICE_DATA_ERROR: 0x%x\n", urbStatus));

         //
         // bump pipe error count
         //
         InterlockedIncrement( &pDevExt->WriteDeviceErrors);

         //
         // is the endpoint is stalled?
         //
         if ( USBD_HALTED(pUrb->UrbHeader.Status) ) {
               //
               // queue a reset request
               //
               workStatus = QueueWorkItem( pDevExt->DeviceObject,
                                           UsbResetOrAbortPipeWorkItem,
                                           (PVOID)((LONG_PTR)urbStatus),
                                           WORK_ITEM_RESET_WRITE_PIPE
                                           );
         }

      }
      break;

      case STATUS_INVALID_PARAMETER:
            //
            // This means that our (TransferBufferSize > PipeInfo->MaxTransferSize)
            // we need to either break up requests or reject the Irp from the start.
            //
            DbgDump(DBG_WRN, ("STATUS_INVALID_PARAMETER\n"));
            ASSERT(USBD_STATUS_INVALID_PARAMETER == urbStatus);

            //
            // pass the Irp through for completion
            //
      break;

      default:
         DbgDump(DBG_WRN, ("WRITE: Unhandled Irp status: 0x%x\n", irpStatus));
      break;
   }

   //
   // Remove the packet from the pending List
   //
   KeAcquireSpinLock( &pDevExt->ControlLock,  &irql );

   RemoveEntryList( &PPacket->ListEntry );

   curCount = InterlockedDecrement( &pDevExt->PendingWriteCount );

   //
   // Put the packet back in packet pool.
   //
   PPacket->Irp = NULL;

   ExFreeToNPagedLookasideList( &pDevExt->PacketPool,  // Lookaside,
                                PPacket                // Entry
                                );

   ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

   //
   // Complete the IRP
   //
   TryToCompleteCurrentIrp(
            pDevExt,
            irpStatus,  // ReturnStatus
            &PIrp,      // Irp
            NULL,       // Queue
            NULL,       // IntervalTimer
            NULL,       // TotalTimer
            NULL,       // StartNextIrpRoutine
            NULL,       // GetNextIrpRoutine
            IRP_REF_RX_BUFFER, // ReferenceType
            FALSE,       // CompleteRequest
            irql );

   //
   // Perform any post I/O processing.
   //
   ASSERT(curCount >= 0);

   if ( 0 == curCount ) {
      //
      // do Tx post processing here...
      //
      KeAcquireSpinLock( &pDevExt->ControlLock , &irql);
      pDevExt->SerialPort.HistoryMask |= SERIAL_EV_TXEMPTY;
      KeReleaseSpinLock( &pDevExt->ControlLock, irql);

      ProcessSerialWaits( pDevExt );

      KeSetEvent( &pDevExt->PendingDataOutEvent, IO_SERIAL_INCREMENT, FALSE);
   }

   DbgDump(DBG_WRITE, ("<WriteComplete 0x%x\n", irpStatus));

   PERF_EXIT( PERF_WriteComplete );

   return irpStatus;
}



VOID
WriteTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   )
/*++

Routine Description:

    This is the Write Timeout DPC routine that is called when a
    Timer expires on a packet submitted to USBD.
    Runs at DPC_LEVEL.

Arguments:

    PDpc             - Unused
    DeferredContext  - pointer to the Packet
    SystemContext1   - Unused
    SystemContext2   - Unused

Return Value:
    VOID

--*/
{
   PUSB_PACKET       pPacket = (PUSB_PACKET)DeferredContext;
   PDEVICE_EXTENSION pDevExt = pPacket->DeviceExtension;
   PDEVICE_OBJECT    pDevObj = pDevExt->DeviceObject;

   NTSTATUS status = STATUS_TIMEOUT;
   KIRQL irql;

   PERF_ENTRY( PERF_WriteTimeout );

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(SystemContext1);
   UNREFERENCED_PARAMETER(SystemContext2);

   DbgDump(DBG_WRITE|DBG_TIME, (">WriteTimeout\n"));

   if (pPacket && pDevExt && pDevObj) {
      //
      // sync with completion routine putting packet back on list
      //
      KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

      if ( !pPacket || !pPacket->Irp ||
           (STATUS_ALERTED == pPacket->Status) ) {

         status = STATUS_ALERTED;

         KeReleaseSpinLock( &pDevExt->ControlLock, irql );

         DbgDump(DBG_WRITE, ("WriteTimeout: Irp completed\n" ));
         PERF_EXIT( PERF_WriteTimeout );
         return;

      } else {
         //
         // mark the packet as timed out, so we can propogate this to user
         // from completion routine
         //
         pPacket->Status = STATUS_TIMEOUT;

         KeReleaseSpinLock( &pDevExt->ControlLock, irql );

         //
         // Cancel the Irp.
         //
         if ( !IoCancelIrp(pPacket->Irp) ) {
            //
            // The Irp is not in a cancelable state.
            //
            DbgDump(DBG_WRITE|DBG_TIME, ("Warning: couldn't cancel Irp: %p,\n", pPacket->Irp));
         }

      }

   } else {
      status = STATUS_INVALID_PARAMETER;
      DbgDump(DBG_ERR, ("WriteTimeout: 0x%x\n", status ));
      TEST_TRAP();
   }

   DbgDump(DBG_WRITE|DBG_TIME, ("<WriteTimeout 0x%x\n", status));

   PERF_EXIT( PERF_WriteTimeout );

   return;
}


#if DBG
VOID
DbgDumpReadWriteData(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp,
   IN BOOLEAN Read
   )
{
   PIO_STACK_LOCATION pIrpSp;

   ASSERT(PDevObj);
   ASSERT(PIrp);

   pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   if ( (Read && (DebugLevel & DBG_DUMP_READS)) ||
        (!Read && (DebugLevel & DBG_DUMP_WRITES)) ) {

      ULONG i;
      ULONG count=0;
      NTSTATUS status;

      status = PIrp->IoStatus.Status;

      if (STATUS_SUCCESS ==  status) {
         count = (ULONG)PIrp->IoStatus.Information;
      }

      KdPrint( ("WCEUSBSH: %s: for DevObj(%p) Irp(0x%x) Length(0x%x) status(0x%x)\n",
                     Read ? "ReadData" : "WriteData", PDevObj, PIrp, count, status ));

      for (i = 0; i < count; i++) {
         KdPrint(("%02x ", *(((PUCHAR)PIrp->AssociatedIrp.SystemBuffer) + i) & 0xFF));
      }

      KdPrint(("\n"));
   }

   return;
}
#endif

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\inc\usbpriv.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbpriv.h

Abstract:

Environment:

    Kernel & user mode

Revision History:

    10-30-01 : created

--*/

#ifndef   __USB_PRIV_H__
#define   __USB_PRIV_H__

// {022252A1-ED5D-4e3f-976F-B2D9DB3D2BD3}
DEFINE_GUID(GUID_USBPRIV_ROOTPORT_STATUS, 
0x22252a1, 0xed5d, 0x4e3f, 0x97, 0x6f, 0xb2, 0xd9, 0xdb, 0x3d, 0x2b, 0xd3);


typedef struct _USBPRIV_ROOTPORT_STATUS
{
    RH_PORT_STATUS PortStatus;
    USHORT         PortNumber;
}
USBPRIV_ROOTPORT_STATUS, *PUSBPRIV_ROOTPORT_STATUS;

#endif /* __USB_PRIV_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\wceusbsh\wceusbsh.h ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    wceusbsh.h

Abstract:

    Main entrypoint for Windows CE USB Serial Host driver, for
        ... Windows CE USB sync devices:
            SL11, Socket CF cards, HP Jornada, COMPAQ iPAQ, Casio Cassiopeia, etc.
        ... cables using the Anchor AN27x0 chipset (i.e. EZ-Link)
        ... ad-hoc USB NULL Modem Class

Environment:

    kernel mode only

Author:

    Jeff Midkiff (jeffmi)

Revision History:

    07-15-99    :   rev 1.00    ActiveSync 3.1  initial release
    04-20-00    :   rev 1.01    Cedar 3.0 Platform Builder
    09-20-00    :   rev 1.02    finally have some hardware

Notes:

    o) WCE Devices currently do not handle remote wake, nor can we put the device in power-off state when not used, etc.
    o) Pageable Code sections are marked as follows:
           PAGEWCE0 - useable only during init/deinit
           PAGEWCE1 - useable during normal runtime

-- */

#if !defined(_WCEUSBSH_H_)
#define _WCEUSBSH_H_

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddser.h>

#define DRV_NAME "WCEUSBSH"

#include "errlog.h"
#include "perf.h"
#include "debug.h"

//
// Instantiate the GUID
//
#if !defined(FAR)
#define FAR
#endif

#include <initguid.h>
/* 25dbce51-6c8f-4a72-8a6d-b54c2b4fc835 */
DEFINE_GUID( GUID_WCE_SERIAL_USB, 0x25dbce51, 0x6c8f, 0x4a72, 0x8a, 0x6d, 0xb5, 0x4c, 0x2b, 0x4f, 0xc8, 0x35);

#define WCEUSB_POOL_TAG 'HECW'

//
// Max times we let a pipe take STATUS_DEVICE_DATA_ERROR
// before we shoot it in the head. This is registry configurable.
// Make the default large enough for (somewhat) working hardware to recover.
// I choose 100 because I know the error queuing code has handled queue depths of this size,
// and COMPAQ/INTEL has known USB function chipset bugs and requested a huge recovery window.
//
#define DEFAULT_MAX_PIPE_DEVICE_ERRORS 100

//
// The max times we take a class/vendor specific command error on EP0.
// This number can NOT change since
// a) commands on EP0 should never fail unless the device is bad
// b) ActiveSync retries commands (e.g. SET_DTR) this many times,
//    so we need a way to inform the user that device is hosed.
//
#define MAX_EP0_DEVICE_ERRORS 2

extern ULONG   g_ulMaxPipeErrors;

#include "remlock.h"

// TRUE  - OS = Win98
// FALSE - OS = WinNT
extern BOOLEAN g_isWin9x;

// do we expose a COMx: port. The default is NO,
// since this is only for debug purposes
extern BOOLEAN g_ExposeComPort;


#ifdef POOL_TAGGING
#undef  ExAllocatePool
#undef  ExAllocatePoolWithQuota
#define ExAllocatePool(a,b)             ExAllocatePoolWithTag(a, b, WCEUSB_POOL_TAG)
#define ExAllocatePoolWithQuota(a,b)    ExAllocatePoolWithQuotaTag(a, b, WCEUSBSH_POOL_TAG)
#endif

extern LONG  g_NumDevices;

//typedef struct _DEVICE_EXTENSION *PDEVICE_EXTENSION;

//
// Emulation of the bit mask on the MODEM STATUS REGISTER.
//
#define SERIAL_MSR_DCTS     0x0001
#define SERIAL_MSR_DDSR     0x0002
#define SERIAL_MSR_DRI      0x0004
#define SERIAL_MSR_DDCD     0x0008
#define SERIAL_MSR_CTS      0x0010
#define SERIAL_MSR_DSR      0x0020
#define SERIAL_MSR_RI       0x0040
#define SERIAL_MSR_DCD      0x0080

//
// Maximum char length for dos device name
//
#define DOS_NAME_MAX 80

//
// Maximum length for symbolic link
//
#define SYMBOLIC_NAME_LENGTH  128

//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
//
//#define DEFAULT_DIRECTORY  L"DosDevices"

//
// PNP_STATE_Xxx flags
//
typedef enum _PNP_STATE {
    PnPStateInitialized,
    PnPStateAttached,
    PnPStateStarted,
    PnPStateRemovePending,
    PnPStateSupriseRemove,
    PnPStateStopPending,
    PnPStateStopped,
    PnPStateRemoved,
    PnPStateMax = PnPStateRemoved,
} PNP_STATE, *PPNP_STATE;


#define MILLISEC_TO_100NANOSEC(x)  ((ULONGLONG) ((-(x)) * 10000))

// default timeouts for pending items, in msec
#define DEFAULT_CTRL_TIMEOUT    500
#define DEFAULT_BULK_TIMEOUT    1000
#define DEFAULT_PENDING_TIMEOUT DEFAULT_BULK_TIMEOUT

#define WORK_ITEM_COMPLETE (0xFFFFFFFF)

//
// Work Item
//
typedef struct _WCE_WORK_ITEM {
   //
   // owning list this packet belongs on
   //
   LIST_ENTRY  ListEntry;

   //
   // owning Device for this work item
   //
   PDEVICE_OBJECT DeviceObject;

   //
   // Context
   //
   PVOID Context;

   //
   // Flags
   //
   ULONG Flags;

   //
   // The work item
   //
   WORK_QUEUE_ITEM Item;

} WCE_WORK_ITEM, *PWCE_WORK_ITEM;


//
// Where in the DeviceMap section of the registry serial port entries
// should appear
//
#define SERIAL_DEVICE_MAP  L"SERIALCOMM"

//
// COMM Port Context
//
typedef struct _COMPORT_INFO {
    //
    // Com Port number
    // read/written to from registry
    //
    ULONG PortNumber;

    //
    // (ones-based) instance number of device driver
    //
    ULONG Instance;

    //
    // number of successful Create calls on device
    //
    ULONG OpenCnt;

    //
    // True if a serial port symbolic link has been
    // created and should be removed upon deletion.
    //
    BOOLEAN SerialSymbolicLink;

    //
    // Symbolic link name -- e.g., \\DosDevices\COMx
    //
    UNICODE_STRING SerialPortName;

    //
    // written to SERIALCOMM -- e.g., COMx
    //
    UNICODE_STRING SerialCOMMname;

} COM_INFO, *PCOMPORT_INFO;


#define WCE_SERIAL_PORT_TYPE GUID_WCE_SERIAL_USB.Data2

#if DBG
#define ASSERT_SERIAL_PORT( _SP ) \
{ \
   ASSERT( WCE_SERIAL_PORT_TYPE == _SP.Type); \
}
#else
#define ASSERT_SERIAL_PORT( _SP )
#endif


//
// Serial Port Interface
//
typedef struct _SERIAL_PORT_INTERFACE {

    USHORT Type;

    //
    // exposed COMx information
    //
    COM_INFO Com;

    //
    // "named" (via SERIAL_BAUD_Xxx bitmask)
    // baud rates for this device
    //
    ULONG SupportedBauds;

    //
    // current baud rate
    //
    SERIAL_BAUD_RATE  CurrentBaud;

    //
    // line control reg: StopBits, Parity, Wordlen
    //
    SERIAL_LINE_CONTROL  LineControl;

    //
    // Handshake and control Flow control settings
    //
    SERIAL_HANDFLOW   HandFlow;

    //
    // RS-232 Serial Interface Lines
    //
    ULONG RS232Lines;

    //
    // Emulation of Modem Status Register (MSR)
    //
    USHORT ModemStatus;

    //
    // pending set/clear DTR/RTS command, etc. in progress
    //
    PIRP  ControlIrp;

    //
    // timeout controls for device
    //
    SERIAL_TIMEOUTS   Timeouts;

    //
    // Special Chars: EOF, ERR, BREAK, EVENT, XON, XOFF
    //
    SERIAL_CHARS   SpecialChars;

    //
    // Wait Mask
    //
    ULONG WaitMask;           // Flag to determine if the occurence of SERIAL_EV_ should be noticed
    ULONG HistoryMask;        // history of SERIAL_EV_
    PIRP  CurrentWaitMaskIrp; // current wait mask Irp

    //
    // Fake Rx/Tx buffer size.
    //
    SERIAL_QUEUE_SIZE FakeQueueSize;

    //
    // Current number of Tx characters buffered.
    //
    ULONG CharsInWriteBuf;

} SERIAL_PORT_INTERFACE, *PSERIAL_PORT_INTERFACE;


//
// Unique error log values
//
#define ERR_COMM_SYMLINK                  1
#define ERR_SERIALCOMM                    2
#define ERR_GET_DEVICE_DESCRIPTOR         3
#define ERR_SELECT_INTERFACE              4
#define ERR_CONFIG_DEVICE                 5
#define ERR_RESET_WORKER                  6
#define ERR_MAX_READ_PIPE_DEVICE_ERRORS   7
#define ERR_MAX_WRITE_PIPE_DEVICE_ERRORS  8
#define ERR_MAX_INT_PIPE_DEVICE_ERRORS    9
#define ERR_USB_READ_BUFF_OVERRUN         10
#define ERR_NO_USBREAD_BUFF               11
#define ERR_NO_RING_BUFF                  12
#define ERR_NO_DEVICE_OBJ                 13
#define ERR_NO_READ_PIPE_RESET            14
#define ERR_NO_WRITE_PIPE_RESET           15
#define ERR_NO_INT_PIPE_RESET             16
#define ERR_NO_CREATE_FILE                17
#define ERR_NO_DTR                        18
#define ERR_NO_RTS                        19



//
// NULL Modem USB Class
//
#define USB_NULL_MODEM_CLASS 0xFF


#define DEFAULT_ALTERNATE_SETTING 0

extern ULONG g_ulAlternateSetting;


//
// On a 300MHz MP machine it takes ~73 msec to
// cancel a pending USB Read Irp from the USB stack.
// On a P90 is takes ~14 ms (no SpinLock contention).
// With a default timeout of 1000 msec you have a hard time connecting via
// ActiveSync to CEPC using INT endpoints, and NT RAS ping times out a lot,
// both due to app's timing.
// However, you can easily connect with 100, 250, 500, 2000, etc. msec.
// Note: with 100 msec reads take longer than normal since we timeout at almost 10x/sec
//
#define DEFAULT_INT_PIPE_TIMEOUT 1280

extern LONG g_lIntTimout;


//
// USB COMM constants
//
#define WCEUSB_VENDOR_COMMAND 0
#define WCEUSB_CLASS_COMMAND  1

// Abstract Control Model defines
#define USB_COMM_SET_CONTROL_LINE_STATE   0x0022

// Control Line State - sent to device on default control pipe
#define USB_COMM_DTR    0x0001
#define USB_COMM_RTS    0x0002

// Serial State Notification masks
#define USB_COMM_DATA_READY_MASK   0X0001
#define USB_COMM_MODEM_STATUS_MASK 0X0006

// Serial State Notification bits - read from device on int pipe
#define USB_COMM_CTS 0x0002
#define USB_COMM_DSR 0x0004


//
// state machine defines for Irps that can pend in the USB stack
//
#define IRP_STATE_INVALID          0x0000
#define IRP_STATE_START            0x0001
#define IRP_STATE_PENDING          0x0002
#define IRP_STATE_COMPLETE         0x0004
#define IRP_STATE_CANCELLED        0x0008


//
// The following macros are used to initialize, set
// and clear references in IRPs that are used by
// this driver.  The reference is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//
#define IRP_REF_RX_BUFFER        (0x00000001)
#define IRP_REF_CANCEL           (0x00000002)
#define IRP_REF_TOTAL_TIMER      (0x00000004)
#define IRP_REF_INTERVAL_TIMER   (0x00000008)

#define IRP_INIT_REFERENCE(Irp) { \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define IRP_SET_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PUINT_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       *_arg4 |= _refType; \
   } while (0)

#define IRP_CLEAR_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PUINT_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       *_arg4 &= ~_refType; \
   } while (0)

#define IRP_REFERENCE_COUNT(Irp) \
    ((UINT_PTR)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))


//
// Priority increment for app's thread when completing
// USB Serial I/O (IoCompleteRequest). Used mainly for pumpimg up
// serial events & read completions.
//
//#define IO_WCEUSBS_INCREMENT     6


//
// These values are used by the routines that can be used
// to complete a read (other than interval timeout) to indicate
// to the interval timeout that it should complete.
//
#define SERIAL_COMPLETE_READ_CANCEL     ((LONG)-1)
#define SERIAL_COMPLETE_READ_TOTAL      ((LONG)-2)
#define SERIAL_COMPLETE_READ_COMPLETE   ((LONG)-3)

//
// flags for work items
//
#define WORK_ITEM_RESET_READ_PIPE   (0x00000001)
#define WORK_ITEM_RESET_WRITE_PIPE  (0x00000002)
#define WORK_ITEM_RESET_INT_PIPE    (0x00000004)
#define WORK_ITEM_ABORT_READ_PIPE   (0x00000010)
#define WORK_ITEM_ABORT_WRITE_PIPE  (0x00000020)
#define WORK_ITEM_ABORT_INT_PIPE    (0x00000040)


typedef struct _DEVICE_EXTENSION *PDEVICE_EXTENSION;

//
// Common Read/Write USB Packet
//
typedef struct _USB_PACKET {
   //
   // owning list this packet belongs on (Read, Write, PacketPool)
   //
   LIST_ENTRY  ListEntry;

   //
   // owning Device for this read/write
   //
   PDEVICE_EXTENSION DeviceExtension;

   //
   // Irp this packet belongs with.
   //
   PIRP Irp;

   //
   // Read/Write Timeout Value
   //
   LARGE_INTEGER Timeout;

   //
   // Read/Write Timer Object
   //
   KTIMER TimerObj;

   //
   // Read/Write TimerDPC Object
   //
   KDPC TimerDPCObj;

   //
   // Read/Write DPC Routine
   //
   PKDEFERRED_ROUTINE TimerDPCRoutine;

   //
   // Status
   //
   NTSTATUS Status;

   //
   // Urb for this write  N.B.: size is variable, so leave last
   // may not need it becase the Irp has a pointer to the Urb
   //
   URB Urb;

} USB_PACKET, *PUSB_PACKET;


//
// Note: the SL11 is now pushing faster transfer rates,
// and we were getting USBD_STATUS_BUFFER_OVERRUN with a 1024 USB Read Buffer.
//
// Note: ActiveSync can burst up to 6 IP packets at 1500 bytes each, so we have a Read Buffer
// to accomodate it (9000 bytes). Since all allocs are paged based and any space remaining inside that page is lost,
// then just round up to the next page size i.e., 3 (4k) pages.
// Note: we have hardcoded the page size here for x86 in case this driver ever makes it
// onto another platform (e.g. Alpha).
//
#if !defined (USE_RING_BUFF)
#define USB_READBUFF_SIZE     (4096 * 3)
#else
#define USB_READBUFF_SIZE     (4096)
#define RINGBUFF_SIZE                       (USB_READBUFF_SIZE * 3)
#define RINGBUFF_HIGHWATER_MARK  (RINGBUFF_SIZE/2)
//
// Ring Buffer to cache USB Reads.
//      Reads occur at the head.
//      Writes occur at the tail.
//      Both Head & Tail move in the same direction.
//
typedef struct _RING_BUFF {
    ULONG   Size;  // in bytes
    ULONG   CharsInBuff;
    PUCHAR  pBase;
    PUCHAR  pHead;
    PUCHAR  pTail;
} RING_BUFF, *PRING_BUFF;
#endif // USE_RING_BUFF

//
// PipeInfo->MaximumTransferSize
//
#define DEFAULT_PIPE_MAX_TRANSFER_SIZE      USB_READBUFF_SIZE


typedef struct _USB_PIPE {

    USBD_PIPE_HANDLE  hPipe;

    ULONG             MaxPacketSize;

    UCHAR             wIndex;

    LONG              ResetOrAbortPending;
    LONG              ResetOrAbortFailed;

} USB_PIPE, *PUSB_PIPE;


typedef struct _DEVICE_EXTENSION {

      ///////////////////////////////////////////////////////////
      //
      // WDM Interface
      //

      //
      // Device Extension's global SpinLock.
      // No major need for multiple locks since all paths basically need to sync to the same data.
      //
      KSPIN_LOCK  ControlLock;

      REMOVE_LOCK RemoveLock;

      //
      // Back pointer to our DeviceObject
      //
      PDEVICE_OBJECT DeviceObject;

      //
      // Device just below us in the device stack
      //
      PDEVICE_OBJECT NextDevice;

      //
      // Our Physical Device Object
      //
      PDEVICE_OBJECT PDO;

      //
      // Our Device PnP State
      //
      PNP_STATE PnPState;

      //
      // is the device removed
      //
      ULONG DeviceRemoved;

      //
      // is the device stopped
      //
      ULONG AcceptingRequests;

      //
      // open/close state
      //
      ULONG DeviceOpened;

#ifdef DELAY_RXBUFF
      //
      // used to emulate RX buffer
      //
      ULONG StartUsbRead;
#endif

#ifdef POWER
      // The CE devices do not yet handle power, let the bus driver manage

      //
      // SystemWake from devcaps
      //
      SYSTEM_POWER_STATE SystemWake;

      //
      // DeviceWake from devcaps
      //
      DEVICE_POWER_STATE DevicePowerState;
#endif

      //
      // User visible name \\DosDevices\WCEUSBSHx, where x = 001, 002, ...
      // Open as CreateFile("\\\\.\\WCEUSBSH001", ... )
      //
      CHAR DosDeviceName[DOS_NAME_MAX];

      //
      // (kernel) Device Name -- e.g., \\Devices\WCEUSBSHx
      //
      UNICODE_STRING DeviceName;

      //
      // True if a symbolic link has been
      // created to the kernel namspace and should be removed upon deletion.
      //
      BOOLEAN SymbolicLink;

      //
      // String where we keep the symbolic link that is returned to us when we
      // register our device (IoRegisterDeviceInterface) with the Plug and Play manager.
      // The string looks like \\??\\USB#Vid_0547&Pid_2720#Inst_0#{GUID}
      //
      UNICODE_STRING DeviceClassSymbolicName;

      //
      // Pointer to our Serial Port Interface
      //
      SERIAL_PORT_INTERFACE SerialPort;

      ///////////////////////////////////////////////////////////
      //
      // USB Interface ...
      //

      //
      // USB Device descriptor for this device
      //
      USB_DEVICE_DESCRIPTOR DeviceDescriptor;

      //
      // USBD configuration
      //
      USBD_CONFIGURATION_HANDLE  ConfigurationHandle;

      //
      // index of USB interface we are using
      //
      UCHAR UsbInterfaceNumber;

      //
      // USBD Pipe Handles
      //
      USB_PIPE ReadPipe;

      USB_PIPE WritePipe;

      //
      // FIFO size in bytes
      // written to PipeInfo->MaximumTransferSize
      //
      ULONG MaximumTransferSize;

      //
      // USB Packet (_USB_PACKET) Pool
      //
      NPAGED_LOOKASIDE_LIST PacketPool;

      //
      // Pending USB Packet Lists
      // We queue packets, not Irps. We allocate a packet from PacketPool,
      // then put it on it's R or W pending queue (list). When the I/O completes
      // then remove the packet from it's pending list & place back in
      // PacketPool. The list is processed FIFO, so the most recent packet is at the tail.
      // If a Timer fires then we remove the packet from the pending R/W
      // list, cancel the Irp, and put packet back in PacketPool.
      // The list is protected by grabbing the extension's global spinlock.
      //
      LIST_ENTRY  PendingReadPackets; // ListHead
      ULONG       PendingReadCount;

      LIST_ENTRY  PendingWritePackets; // ListHead
      LONG        PendingWriteCount;

      //
      // N-Paged LookAside Lists
      //
      NPAGED_LOOKASIDE_LIST BulkTransferUrbPool;
      NPAGED_LOOKASIDE_LIST PipeRequestUrbPool;
      NPAGED_LOOKASIDE_LIST VendorRequestUrbPool;

      //
      // These events are signalled for waiters (e.g. AbortPipes) when a packet list is empty
      //
      KEVENT PendingDataOutEvent;       // PendingWritePackets drained

      ULONG  PendingDataOutCount;

      //
      // Work Item context
      //
      NPAGED_LOOKASIDE_LIST WorkItemPool;
      LIST_ENTRY            PendingWorkItems;      // ListHead
      // remove lock
      LONG                  PendingWorkItemsCount;
      KEVENT                PendingWorkItemsEvent;


      ///////////////////////////////////////////////////
      //
      // support for buffered reads & polling the USBD stack
      //
      PIRP    UsbReadIrp;        // Irp for read requests to USBD
      PURB    UsbReadUrb;        // Urb for read requests to USBD

      //
      // USB Read state machine
      //
      ULONG   UsbReadState;

      //
      // Used to signal canceled USB read Irp.
      // Note that this could get signalled before the
      // PendingDataIn event.
      //
      KEVENT  UsbReadCancelEvent;

      //
      // This is the USB read buffer which gets sent down the USB stack,
      // not a ring-buffer for user.
      //
      PUCHAR UsbReadBuff;        // buffer for read requests
      ULONG UsbReadBuffSize;
      ULONG  UsbReadBuffIndex;   // current zero based index into read buffer
      ULONG  UsbReadBuffChars;   // current number of characters buffered

      KEVENT PendingDataInEvent; // signals PendingReadCount hit zero

#if defined (USE_RING_BUFF)
      //
      // Ring Buffer
      //
      RING_BUFF RingBuff;
#endif

      //
      // Current Read Irp which is pending from User
      //
      PIRP UserReadIrp;

      //
      // Read queue for pending user Read requests
      //
      LIST_ENTRY UserReadQueue;

      //
      // This value holds the number of characters desired for a
      // particular read.  It is initially set by read length in the (UserReadIrp)
      // IRP.  It is decremented each time more characters are placed
      // into the "users" buffer by the code that reads characters
      // out of the USB read buffer into the users buffer.  If the
      // read buffer is exhausted by the read, and the reads buffer
      // is given to the isr to fill, this value is becomes meaningless.
      //
      ULONG NumberNeededForRead;

      //
      // Timer for timeout on total read request
      //
      KTIMER ReadRequestTotalTimer;

      //
      // Timer for timeout on the interval
      //
      KTIMER ReadRequestIntervalTimer;

      //
      // Relative time set by the read code which holds the time value
      // used for read interval timing.  We keep it in the extension
      // so that the interval timer dpc routine determine if the
      // interval time has passed for the IO.
      //
      LARGE_INTEGER IntervalTime;

      //
      // This holds the system time when we last time we had
      // checked that we had actually read characters.  Used
      // for interval timing.
      //
      LARGE_INTEGER LastReadTime;

      //
      // This dpc is fired off if the timer for the total timeout
      // for the read expires.  It will execute a dpc routine that
      // will cause the current read to complete.
      //
      KDPC TotalReadTimeoutDpc;

      //
      // This dpc is fired off if the timer for the interval timeout
      // expires.  If no more characters have been read then the
      // dpc routine will cause the read to complete.  However, if
      // more characters have been read then the dpc routine will
      // resubmit the timer.
      //
      KDPC IntervalReadTimeoutDpc;

      //
      // This holds a count of the number of characters read
      // the last time the interval timer dpc fired.  It
      // is a long (rather than a ulong) since the other read
      // completion routines use negative values to indicate
      // to the interval timer that it should complete the read
      // if the interval timer DPC was lurking in some DPC queue when
      // some other way to complete occurs.
      //
      LONG CountOnLastRead;

      //
      // This is a count of the number of characters read by the
      // isr routine.  It is *ONLY* written at isr level.  We can
      // read it at dispatch level.
      //
      ULONG ReadByIsr;


      ///////////////////////////////////////////////////
      //
      // support for interrupt endpoints
      //
      USB_PIPE  IntPipe;
      ULONG     IntState;           // state machine for starting reads from completion routine
      PIRP      IntIrp;             // Irp for Int reads
      PURB      IntUrb;             // Urb for Int Irp

      // remove lock
      ULONG     PendingIntCount;
      KEVENT    PendingIntEvent;

      KEVENT    IntCancelEvent;
      PUCHAR    IntBuff;            // buffer for notifications

      // Value in 100 nanosec units to timeout USB reads
      // Used in conjunction with the INT endpoint
      LARGE_INTEGER IntReadTimeOut;
#if DBG
      LARGE_INTEGER LastIntReadTime;
#endif

      //
      // device error counters
      //
      ULONG  ReadDeviceErrors;
      ULONG  WriteDeviceErrors;
      ULONG  IntDeviceErrors;
      ULONG  EP0DeviceErrors;

      //
      // perf counters ~ SERIALPERF_STATS.
      //
      ULONG TtlWriteRequests;
      ULONG TtlWriteBytes;     // TTL bytes written for user

      ULONG TtlReadRequests;
      ULONG TtlReadBytes;        // TTL bytes read for user

      ULONG TtlUSBReadRequests;
      ULONG TtlUSBReadBytes;   // TTL bytes indicatid up from USB
      ULONG TtlUSBReadBuffOverruns;   // TTL USB read buffer overruns

#if defined (USE_RING_BUFF)
      ULONG TtlRingBuffOverruns; // TTL ring buffer overruns
#endif

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;



#define FIXUP_RAW_IRP( _pirp, _deviceObject ) \
{  \
   PIO_STACK_LOCATION _irpSp; \
   ASSERT( _pirp ); \
   ASSERT( _deviceObject ); \
   _pirp->CurrentLocation--; \
   _irpSp = IoGetNextIrpStackLocation( _pirp ); \
   ASSERT( _irpSp  );   \
   _pirp->Tail.Overlay.CurrentStackLocation = _irpSp; \
   _irpSp->MajorFunction = IRP_MJ_READ; \
   _irpSp->DeviceObject = _deviceObject; \
   _irpSp->Parameters.Others.Argument1 = 0; \
   _irpSp->Parameters.Others.Argument2 = 0; \
   _irpSp->Parameters.Others.Argument3 = 0; \
   _irpSp->Parameters.Others.Argument4 = 0; \
}


/***************************************************
    P R O T O S
***************************************************/

//
// common.c
//
NTSTATUS
QueryRegistryParameters(
   IN PUNICODE_STRING RegistryPath
    );

VOID
ReleaseSlot(
   IN LONG Slot
   );

NTSTATUS
AcquireSlot(
   OUT PULONG PSlot
   );

NTSTATUS
CreateDevObjAndSymLink(
    IN PDRIVER_OBJECT PDrvObj,
    IN PDEVICE_OBJECT PPDO,
    IN PDEVICE_OBJECT *PpDevObj,
    IN PCHAR PDevName
    );

NTSTATUS
DeleteDevObjAndSymLink(
   IN PDEVICE_OBJECT DeviceObject
   );

VOID
SetPVoidLocked(
   IN OUT PVOID *PDest,
   IN OUT PVOID Src,
   IN PKSPIN_LOCK PSpinLock
   );

typedef
VOID
(*PWCE_WORKER_THREAD_ROUTINE)(
    IN PWCE_WORK_ITEM Context
    );

NTSTATUS
QueueWorkItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PWCE_WORKER_THREAD_ROUTINE WorkerRoutine,
   IN PVOID Context,
   IN ULONG Flags
   );

VOID
DequeueWorkItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PWCE_WORK_ITEM PWorkItem
   );

NTSTATUS
WaitForPendingItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PKEVENT PPendingEvent,
   IN PULONG  PPendingCount
   );

BOOLEAN
CanAcceptIoRequests(
   IN PDEVICE_OBJECT DeviceObject,
   IN BOOLEAN        AcquireLock,
   IN BOOLEAN        CheckOpened
   );

BOOLEAN
IsWin9x(
   VOID
   );

VOID
LogError(
   IN PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT DeviceObject OPTIONAL,
   IN ULONG SequenceNumber,
   IN UCHAR MajorFunctionCode,
   IN UCHAR RetryCount,
   IN ULONG UniqueErrorValue,
   IN NTSTATUS FinalStatus,
   IN NTSTATUS SpecificIOStatus,
   IN ULONG LengthOfInsert1,
   IN PWCHAR Insert1,
   IN ULONG LengthOfInsert2,
   IN PWCHAR Insert2
   );

#if DBG
PCHAR
PnPMinorFunctionString (
   UCHAR MinorFunction
   );
#endif

//
// comport.c
//
LONG
GetFreeComPortNumber(
   VOID
   );

VOID
ReleaseCOMPort(
   LONG comPortNumber
   );

NTSTATUS
DoSerialPortNaming(
   IN PDEVICE_EXTENSION PDevExt,
   IN LONG  ComPortNumber
   );

VOID
UndoSerialPortNaming(
   IN PDEVICE_EXTENSION PDevExt
   );

//
// int.c
//
NTSTATUS
AllocUsbInterrupt(
   IN PDEVICE_EXTENSION DeviceExtension
   );

NTSTATUS
UsbInterruptRead(
   IN PDEVICE_EXTENSION DeviceExtension
   );

NTSTATUS
CancelUsbInterruptIrp(
   IN PDEVICE_OBJECT PDevObj
   );

//
// pnp.c
//
NTSTATUS
Pnp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

NTSTATUS
Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
StopIo(
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
CleanUpPacketList(
   IN PDEVICE_OBJECT DeviceObject,
   IN PLIST_ENTRY PListHead,
   IN PKEVENT PEvent
   );

//
// read.c
//
NTSTATUS
AllocUsbRead(
   IN PDEVICE_EXTENSION PDevExt
   );

NTSTATUS
UsbRead(
   IN PDEVICE_EXTENSION PDevExt,
   IN BOOLEAN UseTimeout
   );

NTSTATUS
CancelUsbReadIrp(
   IN PDEVICE_OBJECT PDevObj
   );


NTSTATUS
Read(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

VOID
ReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   );

VOID
IntervalReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   );

//
// serioctl.c
//
NTSTATUS
SerialIoctl(
   PDEVICE_OBJECT PDevObj,
   PIRP PIrp
   );

NTSTATUS
SerialResetDevice(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP Irp,
   IN BOOLEAN ClearDTR
   );

VOID
ProcessSerialWaits(
   IN PDEVICE_EXTENSION PDevExt
   );

NTSTATUS
SerialPurgeRxClear(
   IN PDEVICE_OBJECT PDevObj,
   IN BOOLEAN CancelRead
   );

//
// usbio.c
//
NTSTATUS
UsbSubmitSyncUrb(
    IN PDEVICE_OBJECT   PDevObj,
    IN PURB             PUrb,
    IN BOOLEAN          Configuration,
    IN LONG             TimeOut
    );

NTSTATUS
UsbClassVendorCommand(
   IN PDEVICE_OBJECT PDevObj,
   IN UCHAR  Request,
   IN USHORT Value,
   IN USHORT Index,
   IN PVOID  Buffer,
   IN OUT PULONG BufferLen,
   IN BOOLEAN Read,
   IN ULONG   Class
   );

NTSTATUS
UsbReadWritePacket(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp,
   IN PIO_COMPLETION_ROUTINE  CompletionRoutine,
   IN LARGE_INTEGER Timeout,
   IN PKDEFERRED_ROUTINE TimeoutRoutine,
   IN BOOLEAN Read
   );

VOID
UsbBuildTransferUrb(
   PURB Urb,
   PUCHAR Buffer,
   ULONG Length,
   IN USBD_PIPE_HANDLE PipeHandle,
   IN BOOLEAN Read
   );


#define RESET TRUE
#define ABORT FALSE

NTSTATUS
UsbResetOrAbortPipe(
   IN PDEVICE_OBJECT PDevObj,
   IN PUSB_PIPE PPipe,
   IN BOOLEAN Reset
   );

VOID
UsbResetOrAbortPipeWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   );

//
// usbutils.c
//
NTSTATUS
UsbGetDeviceDescriptor(
   IN PDEVICE_OBJECT PDevObj
   );

NTSTATUS
UsbConfigureDevice(
   IN PDEVICE_OBJECT PDevObj
   );

//
// utils.c
//
typedef
NTSTATUS
(*PSTART_ROUTINE)(              // StartRoutine
   IN PDEVICE_EXTENSION
   );

typedef
VOID
(*PGET_NEXT_ROUTINE) (          // GetNextIrpRoutine
      IN PIRP *CurrentOpIrp,
      IN PLIST_ENTRY QueueToProcess,
      OUT PIRP *NewIrp,
      IN BOOLEAN CompleteCurrent,
      PDEVICE_EXTENSION Extension
      );

VOID
TryToCompleteCurrentIrp(
   IN PDEVICE_EXTENSION PDevExt,
   IN NTSTATUS StatusToUse,
   IN PIRP *PpCurrentOpIrp,
   IN PLIST_ENTRY PQueue OPTIONAL,
   IN PKTIMER PIntervalTimer OPTIONAL,
   IN PKTIMER PTotalTimer OPTIONAL,
   IN PSTART_ROUTINE Starter OPTIONAL,
   IN PGET_NEXT_ROUTINE PGetNextIrp OPTIONAL,
   IN LONG RefType,
   IN BOOLEAN Complete,
   IN KIRQL IrqlForRelease
   );

VOID
RecycleIrp(
   IN PDEVICE_OBJECT PDevOjb,
   IN PIRP  PIrp
   );

NTSTATUS
ManuallyCancelIrp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

VOID
CalculateTimeout(
   IN OUT PLARGE_INTEGER PTimeOut,
   IN ULONG Length,
   IN ULONG Multiplier,
   IN ULONG Constant
   );

//
// wceusbsh.c
//
NTSTATUS
DriverEntry(
   IN PDRIVER_OBJECT PDrvObj,
   IN PUNICODE_STRING PRegistryPath
   );

NTSTATUS
AddDevice(
   IN PDRIVER_OBJECT PDrvObj,
   IN PDEVICE_OBJECT PPDO
   );

VOID
KillAllPendingUserReads(
   IN PDEVICE_OBJECT PDevObj,
   IN PLIST_ENTRY PQueueToClean,
   IN PIRP *PpCurrentOpIrp
   );

VOID
UsbFreeReadBuffer(
   IN PDEVICE_OBJECT PDevObj
   );

//
// write.c
//
NTSTATUS
Write(
   IN PDEVICE_OBJECT PDevObj,
   PIRP PIrp
   );

#endif // _WCEUSBSH_H_

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\hccoin\hccoin.c ===
//#define UNICODE

#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <basetyps.h>
#include <regstr.h>
#include <devioctl.h>
#include <initguid.h>
#include <usb.h>
#include <usbuser.h>
#include <setupapi.h>
#include <cfgmgr32.h>

#include <assert.h>
#include "hccoin.h"

#define PSTR    LPSTR

BOOL Win2k = FALSE;

#if DBG

#define TEST_TRAP() DebugBreak()

ULONG
_cdecl
KdPrintX(
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function.

Arguments:

Return Value:


--*/
{
    va_list list;
    int i;
    int arg[6];
    TCHAR tmp[256];

#ifdef UNICODE
    OutputDebugString(L"HCCOIN.DLL:");
#else 
    OutputDebugString("HCCOIN.DLL:");
#endif    
    va_start(list, Format);
    for (i=0; i<6; i++) {
        arg[i] = va_arg(list, int);

        wsprintf((PSTR)&tmp[0], Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);
    }

    OutputDebugString((PSTR)tmp);

    return 0;
}


#define KdPrint(_x_) KdPrintX _x_

#else 

#define KdPrint(_x_)
#define TEST_TRAP() 

#endif


DWORD
HCCOIN_Win2k (
    DI_FUNCTION InstallFunction,
    HDEVINFO  DeviceInfoSet,
    PSP_DEVINFO_DATA  DeviceInfoData,
    PCOINSTALLER_CONTEXT_DATA  Context
    )
{
    DWORD status = NO_ERROR;

    KdPrint(("HCCOIN_Win2k 0x%x\n", InstallFunction));
    KdPrint(("Context %08.8x, DeviceInfoData %08.8x\n", 
        Context, DeviceInfoData));

    switch(InstallFunction) {
    
    case DIF_DESTROYPRIVATEDATA:
        KdPrint(("DIF_DESTROYPRIVATEDATA\n"));
        break;

    case DIF_PROPERTYCHANGE:
        break;
        
    case DIF_INSTALLDEVICE:
        if (Context->PostProcessing) {
            KdPrint(("DIF_INSTALLDEVICE, post\n"));
            status = HCCOIN_DoWin2kInstall(DeviceInfoSet, DeviceInfoData);
        } else {
            status = ERROR_DI_POSTPROCESSING_REQUIRED;
        }
        break;
    }
    
    return status;
    
}

/*

    HACTION STATES
    (0) companion can enumerate
    (1) companion should wait on 2.0 controller, 2.0 is enabled
    (2) companion is disabled, needs reenable 2.0 is disabled
    (3) companion is disabled, needs reenable 2.0 is enabled
    (4) companion is disabled, needs reenable 2.0 is removed
*/

#define USB2_DISABLE  1
#define USB2_ENABLE   2
#define USB2_REMOVE   3
#define USB2_INSTALL  4

// Global state of install process
ULONG MyContext = 0;

DWORD
HCCOIN_WinXp (
    DI_FUNCTION InstallFunction,
    HDEVINFO  DeviceInfoSet,
    PSP_DEVINFO_DATA  DeviceInfoData,
    PCOINSTALLER_CONTEXT_DATA  Context
    )

{
    DWORD status = NO_ERROR;
    ULONG pd;
    
    KdPrint(("HCCOIN_WinXp 0x%x\n", InstallFunction));
    KdPrint(("Context %08.8x, DeviceInfoData %08.8x private %08.8x\n", 
        Context, DeviceInfoData, Context->PrivateData));

    //pd = (ULONG) Context->PrivateData; 
    pd = MyContext;
    KdPrint(("pd %08.8x\n", pd)); 

    switch(InstallFunction) {
    
    case DIF_DESTROYPRIVATEDATA:
        KdPrint(("DIF_DESTROYPRIVATEDATA\n"));
        switch (pd) {
        case USB2_DISABLE:
        
            KdPrint((">DISABLE 2>0\n"));
            // disabling 2.0 hc find current state 2, 
            // cc need reenable and set to state 0 (ok to enum)
            // 2->0
            status = HCCOIN_CheckControllers(2, 0);
            break;
            
        case USB2_ENABLE:
            KdPrint((">ENABLE 3>1\n"));
            // enabling 2.0 hc find state 3 
            // cc need reenable and set to state 1 (wait to enum)
            // 3->1
            status = HCCOIN_CheckControllers(3, 1);
            break;
            
        case USB2_REMOVE:
            // removing 2.0 hc find state 4 
            // cc need reenumerate and set to state 0 (ok to enum)
            // 3->1
            KdPrint((">REMOVE 4>0\n"));
            status = HCCOIN_CheckControllers(4, 0);
            break;
        }
        break;

    case DIF_PROPERTYCHANGE:
        {
        SP_PROPCHANGE_PARAMS propChange;

        // get the private data
        propChange.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        propChange.ClassInstallHeader.InstallFunction = InstallFunction;
        
        SetupDiGetClassInstallParams(DeviceInfoSet,
                                     DeviceInfoData, 
                                     &propChange.ClassInstallHeader,                                     
                                     sizeof(propChange),
                                     NULL);
                                     
        switch (propChange.StateChange) {
        case DICS_ENABLE:
            pd = USB2_ENABLE;
            break;
        case DICS_DISABLE:
            pd = USB2_DISABLE;
            break;
        default:
            pd = 0;
        }
        //Context->PrivateData = (PVOID) pd;
        MyContext = pd;
        
        KdPrint(("DIF_PROPERTYCHANGE %x\n", pd));
        if (pd == USB2_ENABLE) {
            KdPrint((">ENABLE\n"));
            if (Context->PostProcessing) {
                KdPrint(("DIF_PROPERTYCHANGE, post 0>3\n"));
                // enabling 2.0 hc. find state 0 and disable
                // set to state 3 need reenable
                // 0->3
                status = HCCOIN_CheckControllers(0, 3);
           } else {
                status = ERROR_DI_POSTPROCESSING_REQUIRED;
           }
        }
        }
        break;
        
    case DIF_INSTALLDEVICE:
        // two options here, force a reboot or attempt to locate all 
        // companion controllers and cycle them
        KdPrint(("DIF_INSTALLDEVICE\n"));
        // set all controllers to 'wait mode'
        MyContext = USB2_INSTALL;
        status = HCCOIN_CheckControllers(0, 1);
        break;
        
    case DIF_REMOVE:
        if (Context->PostProcessing) {
            KdPrint(("DIF_REMOVE, post\n"));
            MyContext = USB2_REMOVE;
            status = HCCOIN_CheckControllers(2, 4);
        } else {
            status = ERROR_DI_POSTPROCESSING_REQUIRED;
        }
        break;        
    }
    
    return status;
}


DWORD
HCCOIN_CopyFile(
    PSTR SrcPath,
    PSTR DestPath,
    PSTR FileName
    )
{
    TCHAR src[MAX_PATH];
    TCHAR dest[MAX_PATH];
    
    KdPrint(("SrcPath <%s>\n", SrcPath));    
    KdPrint(("DstPath <%s>\n", DestPath));    
    KdPrint(("File <%s>\n", FileName));  

    wsprintf(src,"%s\\%s", SrcPath, FileName);
    wsprintf(dest,"%s\\%s", DestPath, FileName);
    
    CopyFile(src, dest, FALSE);

    return NO_ERROR;
}


// global string buffers
TCHAR Usb2Path[MAX_PATH];
TCHAR Usb2Inf[MAX_PATH];
TCHAR SourcePath[MAX_PATH];
TCHAR Usb2Section[MAX_PATH];

DWORD
HCCOIN_DoWin2kInstall(
    HDEVINFO  DeviceInfoSet,
    PSP_DEVINFO_DATA  DeviceInfoData
    )
{
    DWORD status = NO_ERROR;
    SP_DRVINFO_DATA driverInfoData;
    SP_DRVINFO_DETAIL_DATA driverInfoDetailData;
    TCHAR tmp[MAX_PATH+1];
    TCHAR fileName[MAX_PATH];
    HINF infHandle;
    INFCONTEXT infContext;
    BOOL findFirst, found;
    UINT len;
    
    // Destination
    // get our strings, localize?
    
    len = GetWindowsDirectory(tmp, MAX_PATH+1);
    // make sure there is enogh room to tack on our directory
    if (len && len < MAX_PATH-6) {
        wsprintf((PSTR)Usb2Path, "%s\\USB2", tmp);
        wsprintf((PSTR)Usb2Inf, "USB2.INF");
        KdPrint(("Usb2Path <%s>\n", Usb2Path));
    } else {
       status = ERROR_INVALID_NAME;
       return status;
    }
    
    wsprintf((PSTR)Usb2Section, "USB2COINSTALLER");

    // create our USB2 directory
    if (!CreateDirectory((PSTR)Usb2Path, NULL)) {
        status = GetLastError();

        if (status != ERROR_ALREADY_EXISTS) {
            KdPrint(("CreateDirectory status %d\n", status));
            return status;
        }            
    }

    // Source
    // get setup info from PnP
    driverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver(DeviceInfoSet,
                                  DeviceInfoData,
                                  &driverInfoData)) {

        status = GetLastError();
        KdPrint(("SetupDiGetSelectedDriver status %d\n", status));
                                          
        return status;
    }
    
    driverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &driverInfoData,
                                    &driverInfoDetailData,    
                                    sizeof(driverInfoDetailData),
                                    NULL)) {
        status = GetLastError();
        KdPrint(("SetupDiGetDriverInfoDetail status %d\n", status));
        
        if (status == ERROR_INSUFFICIENT_BUFFER) { 
            // don't need extended info
            status = NO_ERROR;
        } else {
            return status;
        }            
    }   
    KdPrint(("driverInfoData %08.8x driverInfoDetailData %08.8x\n", 
        &driverInfoData, &driverInfoDetailData));

    assert(sizeof(driverInfoDetailData.InfFileName) == sizeof(SourcePath));
    memcpy(SourcePath, 
           driverInfoDetailData.InfFileName, 
           sizeof(driverInfoDetailData.InfFileName));        

    // strip the file name
    // note that this won't work with DBCS so either compile as 
    // UNICODE or convert the source string to unicode and back
    // again
    {
        PTCHAR pStart, pEnd;

        pEnd = pStart = &SourcePath[0];
#ifdef UNICODE        
        pEnd = pStart + wstrlen(SourcePath);
#else 
        pEnd = pStart + strlen(SourcePath);
#endif
        
        while (*pEnd != '\\' && pEnd != pStart) {
            pEnd--;
        }
        if (*pEnd == '\\') {
            *pEnd = UNICODE_NULL;
        }
    }

    KdPrint(("SourcePath <%s>\n", SourcePath));
    // copy files to our directory
    status = HCCOIN_CopyFile(SourcePath, Usb2Path, Usb2Inf);
    if (status != NO_ERROR) {
        return status;
    }

    // now open the source inf 
    infHandle = SetupOpenInfFile(driverInfoDetailData.InfFileName,     
                                 NULL,
                                 INF_STYLE_WIN4,
                                 NULL);
                                 
    if (INVALID_HANDLE_VALUE == infHandle) {
        status = ERROR_INVALID_NAME;
        return status;
    }

    findFirst = TRUE;
    // read the inf for files to copy
    do {
        if (findFirst) {
            found = SetupFindFirstLine(infHandle,
                               Usb2Section,
                               NULL,
                               &infContext);
            findFirst = FALSE;                               
        } else {
            found = SetupFindNextLine(&infContext,
                                      &infContext);
        }
        
        if (found) {
  
            if (SetupGetLineText(&infContext,
                                 infHandle,
                                 Usb2Section,  //Section
                                 NULL,         //Key
                                 fileName,     //ReturnBuffer
                                 sizeof(fileName),  //ReturnBufferLength
                                 NULL)) {
                             
                status = HCCOIN_CopyFile(SourcePath, Usb2Path, fileName);
                if (status != NO_ERROR) {
                    SetupCloseInfFile(infHandle);
                    return status;
                }                             
            }                             
        }
    } while (found);       
                           
#if 0
    // bugbug, hardcode other files for now
    status = HCCOIN_CopyFile(SourcePath, Usb2Path, "usbhub20.sys");
    if (status != NO_ERROR) {
        return status;
    }
    status = HCCOIN_CopyFile(SourcePath, Usb2Path, "usbport.sys");
    if (status != NO_ERROR) {
        return status;
    }
    status = HCCOIN_CopyFile(SourcePath, Usb2Path, "usbehci.sys");
    if (status != NO_ERROR) {
        return status;
    }
#endif    

    SetupCloseInfFile(infHandle);
    
    wsprintf((PSTR)tmp, "%s\\%s", Usb2Path, Usb2Inf);
     
    // tell setup about our inf 
    if (!SetupCopyOEMInf(tmp,  //SourceInfFileName
                    Usb2Path,      //OEMSourceMediaLocation
                    SPOST_PATH,    //OEMSourceMediaType
                    0,             //CopyStyle
                    NULL,          //DestinationInfFileName
                    0,             //DestinationInfFileNameSize
                    NULL,          //RequiredSize
                    NULL)) {       //DestinationInfFileNameComponent

        status = GetLastError();
        KdPrint(("SetupCopyOEMInf status %d\n", status));
    }                    

    return status;
    
}


DEVINST 
HCCOIN_FindUSBController(
    DWORD Haction,
    DWORD NextHaction
    )
/*++
    do a depth first search of the device tree looking for any 
    usb controllers that need attention
--*/    
{
    DEVINST     devInst;
    DEVINST     devInstNext;
    CONFIGRET   cr;
    BOOL        walkDone = FALSE;
    ULONG       len = 0;
    ULONG       status = 0, problemNumber = 0;
    HKEY        devKey;
    DWORD       haction = 0;
    TCHAR       buf[MAX_PATH];
           
    //
    // Get Root DevNode
    //
    cr = CM_Locate_DevNode(&devInst, NULL, 0);

    if (cr != CR_SUCCESS) {
        return 0;
    }

    //
    // Do a depth first search for the DevNode 
    //
    while (!walkDone) {
        //
        // check for our key
        //
                                              
        if (cr == CR_SUCCESS) {

            //KdPrint(("devInst %08.8x - ", devInst));

            len = sizeof(buf);
            if (CM_Get_DevNode_Registry_Property(devInst,
                                                 CM_DRP_DRIVER,
                                                 NULL,
                                                 buf,
                                                 &len,
                                                 0) == CR_SUCCESS) {
                //KdPrint(("<%s>\n",buf));
            } else {
                //KdPrint(("<no driver>\n"));
            }

            if (CM_Open_DevNode_Key(devInst,
                                    KEY_ALL_ACCESS,
                                    CM_REGISTRY_HARDWARE,
                                    RegDisposition_OpenExisting,
                                    &devKey,
                                    0) == CR_SUCCESS) {
                len = sizeof(DWORD);
                if (RegQueryValueEx(devKey,
                                    "haction",
                                    NULL,
                                    NULL,
                                    (LPBYTE) &haction,
                                    &len) == ERROR_SUCCESS) {

                    KdPrint(("Found Key %d\n", haction));

                    if (haction == Haction) {
                        LONG err;
                    
                        len = sizeof(DWORD);         
                        haction = NextHaction;
                        // reset the key
                        err = RegSetValueEx(devKey,
                                    "haction",
                                    0,
                                    REG_DWORD,
                                    (LPBYTE) &haction,
                                    len);
            
                        RegCloseKey(devKey);
                        //KdPrint(("Reset Key %x\n", err));
                        
                        return devInst;
                    }                            
                }

                RegCloseKey(devKey);
            }
        
        }

        //
        // This DevNode didn't match, go down a level to the first child.
        //
        cr = CM_Get_Child(&devInstNext,
                          devInst,
                          0);

        if (cr == CR_SUCCESS) {
            devInst = devInstNext;
            continue;
        }

        //
        // Can't go down any further, go across to the next sibling.  If
        // there are no more siblings, go back up until there is a sibling.
        // If we can't go up any further, we're back at the root and we're
        // done.
        //
        for (;;) {
            cr = CM_Get_Sibling(&devInstNext,
                                devInst,
                                0);

            if (cr == CR_SUCCESS) {
                devInst = devInstNext;
                break;
            }

            cr = CM_Get_Parent(&devInstNext,
                               devInst,
                               0);

            if (cr == CR_SUCCESS) {
                devInst = devInstNext;
            } else {
                walkDone = TRUE;
                break;
            }
        }
    }

    return 0;
}


DWORD 
HCCOIN_CheckControllers(
    DWORD Haction,
    DWORD NextHaction
    )
/*++
--*/
{
    DEVINST devInst;
    ULONG err;
    
    do {
        if (devInst = HCCOIN_FindUSBController(Haction, NextHaction)) {
            KdPrint((">Take Haction %08.8x\n", devInst));  

            switch(Haction) {
            // 0->3
            // 0->1
            case 0:
                if (NextHaction != 1) {
                    err = CM_Disable_DevNode(devInst, CM_DISABLE_UI_NOT_OK | 
                                                      CM_DISABLE_ABSOLUTE);
                    KdPrint(("<Take Haction %d->%d - disable %x\n", 
                        Haction,
                        NextHaction,
                        err));  
                }                        
                break;

            // 3->1
            // 2->0
            // 2->4
            case 3:
            case 2:
                if (NextHaction == 4) {
                    //err = CM_Disable_DevNode(devInst, CM_DISABLE_UI_NOT_OK | 
                    //                                  CM_DISABLE_ABSOLUTE);
                } else {
                    err = CM_Enable_DevNode(devInst, 0);
                }
                KdPrint(("<Take Haction %d->%d - enable %x\n", 
                    Haction,
                    NextHaction,
                    err));  
                break;
            case 4:
                //err = CM_Enable_DevNode(devInst, 0);
                err = CM_Setup_DevNode(devInst, CM_SETUP_DEVNODE_READY);
                KdPrint(("<Take Haction %d->%d - enumerate %x\n", 
                    Haction,
                    NextHaction,
                    err));  
                break;
            }                
        }
    }  while (devInst);      

    return NO_ERROR;
}


DWORD
HCCOIN_Entry (
    DI_FUNCTION InstallFunction,
    HDEVINFO  DeviceInfoSet,
    PSP_DEVINFO_DATA  DeviceInfoData,
    PCOINSTALLER_CONTEXT_DATA  Context
    )
{
    OSVERSIONINFO osVersion;

    osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osVersion); 
    
    if ( osVersion.dwMajorVersion == 5 && osVersion.dwMinorVersion == 0 ) {
        Win2k = TRUE;            
    }
    
    if (Win2k) {

        KdPrint(("Microsoft Windows 2000 "));
        
        return HCCOIN_Win2k(InstallFunction,
                            DeviceInfoSet,
                            DeviceInfoData,
                            Context);
    } else {
        KdPrint(("Microsoft Windows XP or later "));
        
        return HCCOIN_WinXp(InstallFunction,
                            DeviceInfoSet,
                            DeviceInfoData,
                            Context);
    }                            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\inc\usbhcdi.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usb_hcdi.h

Abstract:

Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __USB_HCDI_H__
#define   __USB_HCDI_H__

/*
    Power management rules for USB host controllers transitioning from 
    USB suspend to USB working.  This is what we expect for 
    S3->S0
    S1->S0

    1. The controller must not reset the USB bus or cause a disconnect or power 
       loss on any of the root USB ports.
    2. The system BIOS must not enable any type of legacy USB BIOS or otherwise 
       enable the host controller to a run state.
    3. If a PCI reset occurs in addition to rule 1 the BIOS must restore all 
       host registers to their state prior to entering low power.  Root ports 
       should NOT indicate connect or enable status changes.
    4. The controller hardware must be in a functional state -- capable of 
       driving resume and entering the run state without requiring a global
       hardware reset that otherwise would result in a USB bus reset driven on 
       the root ports.
    
*/

#define USB_BAD_PTR     ((PVOID) (-1))

/* status code returned by core functions */

typedef enum _USB_MINIPORT_STATUS {

    USBMP_STATUS_SUCCESS = 0,
    USBMP_STATUS_BUSY,
    USBMP_STATUS_NO_RESOURCES,
    USBMP_STATUS_NO_BANDWIDTH,
    USBMP_STATUS_INIT_FAILURE,
    USBMP_STATUS_FAILURE,
    USBMP_STATUS_NOT_SUPPORTED,
    USBMP_STATUS_HARDWARE_FAILURE,
    USBMP_STATUS_NTERRCODE_NOT_MAPPFED,
    
} USB_MINIPORT_STATUS;


/* define a test guids for the miniport pass-thru interface */
/* {53D3650A-A4E7-4b0f-BC1D-B76DEB40FA1E}*/
DEFINE_GUID(MINIPORT_PASSTHRU_TEST_GUID, 
0x53d3650a, 0xa4e7, 0x4b0f, 0xbc, 0x1d, 0xb7, 0x6d, 0xeb, 0x40, 0xfa, 0x1e);

/* {386289AA-02EC-486e-925E-838931877F4B}*/
DEFINE_GUID(MINIPORT_PASSTHRU_TEST_BADGUID, 
0x386289aa, 0x2ec, 0x486e, 0x92, 0x5e, 0x83, 0x89, 0x31, 0x87, 0x7f, 0x4b);
// {386289AA-02EC-486e-925E-838931877F4B}

#define TEST_FLAG(var, flag)    (((var) & (flag)) ? TRUE : FALSE)
#define CLEAR_FLAG(var, flag)   ((var) &= ~(flag))
#define SET_FLAG(var, flag)     ((var) |= (flag))

/* 
    Definition for the 32 bit physical address 
    that controller hardware understands.

    If a miniport HW structure only supports 32 bit
    physical addresses then this type is used to 
    indicate it.
    
*/   
typedef ULONG HW_32BIT_PHYSICAL_ADDRESS; 
typedef HW_32BIT_PHYSICAL_ADDRESS *PHW_32BIT_PHYSICAL_ADDRESS;

typedef PHYSICAL_ADDRESS HW_64BIT_PHYSICAL_ADDRESS; 


typedef struct _MP_HW_PHYSICAL_ADDRESS {
    union {
        HW_32BIT_PHYSICAL_ADDRESS Hw32;
        HW_64BIT_PHYSICAL_ADDRESS Hw64;
    };
} MP_HW_PHYSICAL_ADDRESS, *PMP_HW_PHYSICAL_ADDRESS;

C_ASSERT((sizeof(MP_HW_PHYSICAL_ADDRESS) == 8));

/* 
   This structure is used for pointers embedded in 
   HW structures by the miniport.  They is always sized 
   for 64 bit to limit 32/64 bit porting problems.
*/

typedef struct _MP_HW_POINTER {
        PVOID Pointer;
#ifndef _WIN64      
        ULONG PadTo8;
#endif        
} MP_HW_POINTER, *PMP_HW_POINTER;

C_ASSERT((sizeof(MP_HW_POINTER) == 8));

typedef struct _MP_HW_LIST_ENTRY {
   LIST_ENTRY List; 
#ifndef _WIN64        
   ULONG PadTo16[2];
#endif     
} MP_HW_LIST_ENTRY, *PMP_HW_LIST_ENTRY;

C_ASSERT((sizeof(MP_HW_LIST_ENTRY) == 16));


#define PENDPOINT_DATA PVOID
#define PDEVICE_DATA PVOID
#define PTRANSFER_CONTEXT PVOID

/* 
    we redifine the USBDI HCD AREA for the miniport model
*/
struct _USBPORT_DATA {
    PVOID HcdTransferContext;
    PVOID UrbSig;
    PVOID Reserved7[6];
};

#ifdef _WIN64
#define URB_SIG ((PVOID) 0xDEADF00DDEADF00D)
#else
#define URB_SIG ((PVOID) 0xDEADF00D)
#endif

//C_ASSERT(sizeof(struct _URB_HCD_AREA) ==  sizeof(struct _USBPORT_DATA))

#define IN_TRANSFER(tp)       (((tp)->TransferFlags & \
                                USBD_TRANSFER_DIRECTION_IN) ? TRUE : FALSE)

#define SHORT_TRANSFER_OK(tp) (((tp)->TransferFlags & \
                                 USBD_SHORT_TRANSFER_OK) ? TRUE : FALSE)
                                
/*
Common transfer request parameter definition, all transfer
requests passed to the miniport will be mapped to this
format.  The miniport will/can use this structure to
reference fields that are common to all transfers
as well as fields specific to isochronous and
control transfers.
*/

#define MPTX_SPLIT_TRANSFER             0x00000001

typedef struct _TRANSFER_PARAMETERS {

    /* identical to URB field */
    ULONG TransferFlags;
    /* identical to URB field */
    ULONG TransferBufferLength;
    /* uniquely identifies a transfer set */ 
    ULONG SequenceNumber;
    /* miniport special handling requirements */
    ULONG MiniportFlags;
    /* USB frame this transfer completed in */
    ULONG FrameCompleted;
    /* setup packet for control transfers */
    UCHAR SetupPacket[8];  

} TRANSFER_PARAMETERS, *PTRANSFER_PARAMETERS;

typedef struct _MINIPORT_ISO_PACKET {
    /*
      length of this packet
    */
    ULONG Length;
    /*
       bytes transferred this packet
     */
    ULONG LengthTransferred;
    /*
       virtual frame to transmit this packet
    */
    ULONG FrameNumber;
    ULONG MicroFrameNumber;
    /*
       completion code for this packet
     */
    USBD_STATUS UsbdStatus;
    
    ULONG BufferPointerCount;
    
    /* support up to 2 sg entries per packet */
    /* max packet size for a USB 1.1 frame is ~1024 bytes*/
    
    ULONG BufferPointer0Length;
    MP_HW_PHYSICAL_ADDRESS BufferPointer0;

    ULONG BufferPointer1Length;
    MP_HW_PHYSICAL_ADDRESS BufferPointer1;

} MINIPORT_ISO_PACKET, *PMINIPORT_ISO_PACKET;


typedef struct _MINIPORT_ISO_TRANSFER {

    ULONG Sig;
    ULONG PacketCount;
    PUCHAR SystemAddress;
    MINIPORT_ISO_PACKET Packets[1];
    
} MINIPORT_ISO_TRANSFER, *PMINIPORT_ISO_TRANSFER;


/* 
    These structures are used to pass IoMapped transfer
    buffers to the miniport
*/    

//
// Page size and shift value used by the OHCI, EHCI and UHCI
// controller  usb controllers use a defined 
//
// this must always be 4k -- it is defined by the controller HW
#define USB_PAGE_SIZE       0x00001000

#define USB_PAGE_SHIFT      12L


typedef struct _TRANSFER_SG_ENTRY32 {
    MP_HW_PHYSICAL_ADDRESS LogicalAddress;
    PUCHAR SystemAddress;
    ULONG Length;
    ULONG StartOffset;
} TRANSFER_SG_ENTRY32, *PTRANSFER_SG_ENTRY32;

#define USBMP_SGFLAG_SINGLE_PHYSICAL_PAGE   0x00000001

typedef struct _TRANSFER_SG_LIST { 
    ULONG SgFlags;
    PUCHAR MdlVirtualAddress;
    PUCHAR MdlSystemAddress;
    ULONG SgCount;
    TRANSFER_SG_ENTRY32 SgEntry[1];  
} TRANSFER_SG_LIST, *PTRANSFER_SG_LIST;


/************************************************************** 
 **************************************************************
USBPORT Interface Services    

    NOTES:
        - these functions are callable at raised IRQL

        
***************************************************************    
***************************************************************/

#define USBPRTFN __stdcall

/* 
VOID
USBPORTSVC_InvalidateEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

*/

typedef VOID
    (USBPRTFN *PPORTFN_INVALIDATE_ENDPOINT) (
        PDEVICE_DATA,
        PENDPOINT_DATA
    );

/*
PUCHAR
USBPORTSVC_MapHwPhysicalToVirtual(
    HW_32BIT_PHYSICAL_ADDRESS HwPhysicalAddress,
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData    
    )

    maps a physical address from the miniport to 
    a virtual address
*/

typedef PUCHAR
    (USBPRTFN *PPORTFN_PHYS_TO_VIRTUAL) (
        HW_32BIT_PHYSICAL_ADDRESS,
        PDEVICE_DATA,
        PENDPOINT_DATA   
    );

/* 
VOID
USBPORTSVC_CompleteTransfer(
    PDEVICE_DATA DeviceData
    PDEVICE_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    USBD_STATUS UsbdStatus,
    ULONG BytesTransferred
    );

    Called by miniport to complete an async transfer request
*/

typedef VOID
    (USBPRTFN *PPORTFN_COMPLETE_TRANSFER) (
        PDEVICE_DATA,
        PENDPOINT_DATA,
        PTRANSFER_PARAMETERS,
        USBD_STATUS,
        ULONG
    );

/* 
VOID
USBPORTSVC_CompleteIsoTransfer(
    PDEVICE_DATA DeviceData
    PDEVICE_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    );

    Called by miniport to complete an iso transfer request
*/

typedef VOID
    (USBPRTFN *PPORTFN_COMPLETE_ISO_TRANSFER) (
        PDEVICE_DATA,
        PENDPOINT_DATA,
        PTRANSFER_PARAMETERS,
        PMINIPORT_ISO_TRANSFER
    );
    

/* ROOT HUB functions */


/* 
VOID
USBPORTSVC_InvalidateRootHub(
    PDEVICE_DATA DeviceData
    );

    Called by the miniport to indicate the root hub
    needs attention
    
*/

typedef VOID
    (USBPRTFN *PPORTFN_INVALIDATE_ROOTHUB) (
        PDEVICE_DATA
    );


/* Debug functions */

/* 
VOID
USBPORTSVC_DbgPrint(
    PDEVICE_DATA DeviceData,
    ULONG Level,
    PCH Format,
    PVOID Arg0,
    PVOID Arg1,
    PVOID Arg2,
    PVOID Arg3,
    PVOID Arg4,
    PVOID Arg5
    );

    Called by miniport to print a message to the debugger
    the message is printed if the var USBPORT_DEBUG_TRACE_LEVEL 
    is >= level.
*/

typedef VOID
    (USBPRTFN *PPORTFN_DBGPRINT) (
        PDEVICE_DATA,
        ULONG,
        PCH,
        int, 
        int,
        int,
        int,
        int,
        int
    );

/* 
VOID
USBPORTSVC_TestDebugBreak(
    PDEVICE_DATA DeviceData
    );

   Triggers a break in the debugger in the registry key
   debugbreakOn is set.  These breakpoins are useful for
   debugging hardware/client software problems
 
*/

typedef VOID
    (USBPRTFN *PPORTFN_TEST_DEBUG_BREAK) (
        PDEVICE_DATA
    );

/* 
VOID
USBPORTSVC_AssertFailure(
    PDEVICE_DATA DeviceData
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

 
*/

typedef VOID
    (USBPRTFN *PPORTFN_ASSERT_FAILURE) (
        PDEVICE_DATA,
        PVOID,
        PVOID,
        ULONG,
        PCHAR
    );

/* 
VOID
USBPORTSVC_LogEntry(
    PDEVICE_DATA DeviceData,
    
    );

 
*/

/* Miniport LOG MASKS */
#define G 0x10000001    /* always log */

typedef VOID
    (USBPRTFN *PPORTFN_LOGENTRY) (
        PDEVICE_DATA,
        ULONG,
        ULONG, 
        ULONG_PTR, 
        ULONG_PTR, 
        ULONG_PTR
    );    

/* other functions */

/*
USB_MINIPORT_STATUS 
USBPORTSVC_ReadWriteConfigSpace(
    PDEVICE_DATA DeviceData,
    BOOLEAN Read,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )
    
    reads a registry key value from the branch associated 
    with the PDO for the host controller.

    this API reads from either the software or hardware 
    branch

    this function cannot be called at raised IRQL
*/

typedef USB_MINIPORT_STATUS
    (USBPRTFN *PPORTFN_READWRITE_CONFIG_SPACE) (
        PDEVICE_DATA,
        BOOLEAN,
        PVOID,
        ULONG,
        ULONG
    );

/*
VOID 
USBPORTSVC_Wait(
    PDEVICE_DATA DeviceData,
    ULONG MillisecondsToWait
    )

    Execute a syncronous wait for a specified number of 
    milliseconds        
*/

typedef VOID
    (USBPRTFN *PPORTFN_WAIT) (
        PDEVICE_DATA,
        ULONG
    );

/*
VOID 
USBPORTSVC_BugCheck(
    PDEVICE_DATA DeviceData
    )

*/

typedef VOID
    (USBPRTFN *PPORTFN_BUGCHECK) (
        PDEVICE_DATA
    );
    

/*
VOID 
USBPORTSVC_NotifyDoubleBuffer(
    PDEVICE_DATA DeviceData
    PTRANSFER_PARAMETERS TransferParameters,
    PVOID SystemAddress,
    ULONG Length
    )

*/

typedef VOID
    (USBPRTFN *PPORTFN_NOTIFY_DOUBLE_BUFFER) (
        PDEVICE_DATA, 
        PTRANSFER_PARAMETERS,
        PVOID,
        ULONG
    );


/*
USB_MINIPORT_STATUS 
USBPORTSVC_GetMiniportRegistryKeyValue(
    PDEVICE_DATA DeviceData,
    BOOLEAN SoftwareBranch,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    )
    
    reads a registry key value from the branch associated 
    with the PDO for the host controller.

    this API reads from either the software or hardware 
    branch

    this function cannot be called at raised IRQL
*/

typedef USB_MINIPORT_STATUS
    (USBPRTFN *PPORTFN_GET_MINIPORT_REGESTRY_KEY_VALUE) (
        PDEVICE_DATA,
        BOOLEAN,
        PWCHAR,
        ULONG,
        PVOID,
        ULONG
    );


/*
VOID 
USBPORTSVC_RequestAsyncCallback(
    PDEVICE_DATA DeviceData,
    ULONG MilliSecondInterval,    
    PVOID Context,
    ULONG ContextLength,
    PMPFN_MINIPORT_CALLBACK Callback    
    )

    request an async callback when the millisecond interval
    has elapsed.

    The context field is copied ant the miniport is called back
    with the copy so it is safe for the miniport to use a stack 
    variable as context.
*/

/*++
    CallBack Definition for async notifiaction service
--*/

typedef VOID
    (__stdcall *PMINIPORT_CALLBACK) (
        PDEVICE_DATA,
        PVOID
    );         

typedef VOID
    (USBPRTFN *PPORTFN_REQUEST_ASYNC_CALLBACK) (
        PDEVICE_DATA,
        ULONG,
        PVOID,
        ULONG,
        PMINIPORT_CALLBACK    
    );

/*
VOID 
USBPORTSVC_InvalidateController(
    PDEVICE_DATA DeviceData,
    USB_CONTROLLER_STATE ControllerState
    )

*/

typedef enum _USB_CONTROLLER_STATE {

    UsbMpControllerPowerFault,
    UsbMpControllerNeedsHwReset,
    UsbMpControllerRemoved,
    UsbMpSimulateInterrupt
    
} USB_CONTROLLER_STATE;


typedef VOID
    (__stdcall *PPORTFN_INVALIDATE_CONTROLLER) (
        PDEVICE_DATA,
        USB_CONTROLLER_STATE
    );  

/************************************************************** 
 **************************************************************
USB MINIPORT interface functions

    prototypes for functions called by the USB port driver
    (usbport)
***************************************************************    
***************************************************************/

#define USBMPFN __stdcall

/***************************************************************
CORE Functions

    The following core functions are serialized as a group they 
    are assocaited with processing data transfers on the bus

 
   MINIPORT_SubmitTransfer
   MINIPORT_SubmitIsoTransfer
   MINIPORT_AbortTransfer
   MINIPORT_OpenEndpoint
   MINIPORT_RebalanceEndpoint
   MINIPORT_QueryEndpointRequirements
   MINIPORT_CloseEndpoint
   MINIPORT_SetEndpointState
   MINIPORT_GetEndpointState
   MINIPORT_PokeEndpoint
   MINIPORT_PollEndpoint
   MINIPORT_Get32bitFrameNumber
   MINIPORT_InterruptNextSOF
   MINIPORT_PollController
   
    
****************************************************************/

/*++
    MINIPORT_SubmitTransfer
    
    program a USB transfer, iso, bulk, interrupt or control to the hardware.  
    if no resources are avaiable then return USBMP_STATUS_BUSY.

    if the transfer is successfully queued to the HW then return 
        USBMP_STATUS_SUCCESS
    

    NOTES:
        -At the time this routine is called the transfer buffer has been 
         mapped (ie no need to call IoMapTransfer).

    URB_FUNCTION_CONTROL_TRANSFER                
    URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER      

    IRQL = DISPATCH_LEVEL

USB_MINIPORT_STATUS
MINIPORT_SubmitTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );
--*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_SUBMIT_TRANSFER) (
        PDEVICE_DATA, 
        PENDPOINT_DATA,
        PTRANSFER_PARAMETERS,
        PTRANSFER_CONTEXT,
        PTRANSFER_SG_LIST
    );

/*++
    MINIPORT_SubmitTransfer
    
    program a USB transfer, iso, bulk, interrupt or control to the hardware.  
    if no resources are avaiable then return USBMP_STATUS_BUSY.

    if the transfer is successfully queued to the HW then return 
        USBMP_STATUS_SUCCESS
    

    NOTES:
        -At the time this routine is called the transfer buffer has been 
         mapped (ie no need to call IoMapTransfer).

    IRQL = DISPATCH_LEVEL

USB_MINIPORT_STATUS
MINIPORT_SubmitIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    );
--*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_SUBMIT_ISO_TRANSFER) (
        PDEVICE_DATA, 
        PENDPOINT_DATA,
        PTRANSFER_PARAMETERS,
        PTRANSFER_CONTEXT,
        PMINIPORT_ISO_TRANSFER
    );
    

/*++
    MINIPORT_AbortTransfer

    abort a specfic transfer that has been started, this will only be 
    called if the endpoint is in the ENDPOINT_PAUSED state.

    this call is NOT failable and the HW must have no reference to 
    the transfer on return.

    The miniport does not indicate completion.

    IRQL = DISPATCH_LEVEL

VOID
MINIPORT_AbortTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext,
    PULONG BytesTransferred
    );    
--*/

typedef VOID
    (USBMPFN *PMPFN_ABORT_TRANSFER) (
        PDEVICE_DATA, 
        PENDPOINT_DATA,
        PTRANSFER_CONTEXT,
        PULONG 
    );

/*++
    MINIPORT_OpenEndpoint

    open an endpoint.
    
    PENDPOINT_DATA is the minport private endpoint
    context
    
    PENDPOINT_PARAMETERS describes the endpoint to open 
    for the miniport -- this information is READ_ONLY

    on return the endpoint should be in the PAUSE state

    IRQL = DISPATCH_LEVEL

USB_MINIPORT_STATUS
MINIPORT_OpenEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );    
--*/

typedef enum _ENDPOINT_TRANSFER_TYPE {
    Isochronous = 0,
    Control,
    Bulk,
    Interrupt
} ENDPOINT_TRANSFER_TYPE;


typedef enum _ENDPOINT_TRANSFER_DIRECTION {
    In = 0,
    Out
} ENDPOINT_TRANSFER_DIRECTION;

typedef enum _DEVICE_SPEED {
    LowSpeed = 0,
    FullSpeed,
    HighSpeed
} DEVICE_SPEED;


/* these values are input by the port driver */

/*
    Bandwidth Mamagement:

    All bandwidth allocation is managed by the port driver.  The 
    bandwidth consumed by an endpoint is passed to the miniport 
    but this is purely informational.

    Load balancing for interrupt endpoints is handled by passing
    the miniport the appropriate schedule offset for an interrupt
    endpoint.

    interrupt endpoints may occupy different locations in the 
    schedule dpeneding on the period. The consume bandwidth only
    for locations they occupy.  This is the 'ScheduleOffset'.

    USBPORT will choose an appropriate schedule offset and pass this
    to the miniport for the open.

    period      offsets
       1          0
       2          0,1
       4          0,..3
       8          0,..7
       16         0,..15
       32         0,..31
        
*/

typedef struct _ENDPOINT_PARAMETERS {
    USHORT DeviceAddress;
    USHORT EndpointAddress;
    USHORT MaxPacketSize;
    // adjusted interrupt period
    // will be one of : 128, 64, 32, 16, 8, 4, 2, 1
    UCHAR Period;
    UCHAR MaxPeriod;
    // bandwidth required in bits/ms 
    // ie the reserved bw that this endpont will
    // consume
    DEVICE_SPEED DeviceSpeed;
    ULONG Bandwidth;
    ULONG ScheduleOffset;
    ENDPOINT_TRANSFER_TYPE TransferType;
    ENDPOINT_TRANSFER_DIRECTION TransferDirection;
    PUCHAR CommonBufferVa;
    HW_32BIT_PHYSICAL_ADDRESS CommonBufferPhys; 
    ULONG CommonBufferBytes;
    // endpoint parm flags
    ULONG EndpointFlags;
    ULONG MaxTransferSize;
    // usb 2.0 parameters
    // device address of the hub (TT) for this ep
    USHORT TtDeviceAddress;
    // port number (really TT number) of the TT for 
    // this device
    USHORT TtPortNumber;

    UCHAR InterruptScheduleMask;
    UCHAR SplitCompletionMask;
    UCHAR TransactionsPerMicroframe;
    UCHAR Pad;
    USHORT MuxPacketSize;
    ULONG Ordinal;
    
} ENDPOINT_PARAMETERS, *PENDPOINT_PARAMETERS;

/* these are returned by the miniport */
typedef struct _ENDPOINT_REQUIREMENTS {
    /* size of the common buffer the
      miniport will need to service 
      this endpoint */
    ULONG MinCommonBufferBytes; 

    /* 
       the largest single transfer this endpoint
       can handle. If a client driver passes 
       down a larger transfer usbport will break
       it in to multiple requests.

       MinCommonBufferBytes/sizeof(TD) should be 
       enough TDs to statify at least one request
       of MaximumTransferSize.

       Ideally it should be able to handle two -- this 
       will ensure that the bus does not go idle.
       
    */
       
    ULONG MaximumTransferSize;
    
} ENDPOINT_REQUIREMENTS, *PENDPOINT_REQUIREMENTS;


// **
// EP_PARM_FLAG_
// Enpoint Parameter flags, describe required endpoint
// behaviors including possible optimaizations

//#define EP_PARM_FLAG_         0x00000002    

//
// EP_PARM_FLAG_NOHALT - the endpoint should not halt on the 
//      host side as a result of a bus error
//
#define EP_PARM_FLAG_NOHALT           0x00000004  

// optimization flags
#define EP_PARM_ISO_BUFFERING         0x00000008

// 


typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_OPEN_ENDPOINT) (
        PDEVICE_DATA, 
        PENDPOINT_PARAMETERS,
         PENDPOINT_DATA 
    );

/*++
    MINIPORT_PokeEndpoint

    poke an endpoint.
    use to change the address of an endpoint without 
    removing it from the schedule.

    **This API is used exclusively to change the endpoint 
    address.
    
    PENDPOINT_DATA is the minport private endpoint
    context
    
    PENDPOINT_PARAMETERS describes the endpoint to open 
    for the miniport -- this information is READ_ONLY

    IRQL = DISPATCH_LEVEL

USB_MINIPORT_STATUS
MINIPORT_PokeEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );    
--*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_POKE_ENDPOINT) (
        PDEVICE_DATA, 
        PENDPOINT_PARAMETERS,
        PENDPOINT_DATA 
    );    


/*++
    MINIPORT_RebalanceEndpoint

    PENDPOINT_DATA is the minport private endpoint
    context
    
    PENDPOINT_PARAMETERS describes the endpoint to open 
    for the miniport -- this information is READ_ONLY

    IRQL = DISPATCH_LEVEL

VOID
MINIPORT_RebalanceEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );    
--*/

typedef VOID
    (USBMPFN *PMPFN_REBALANCE_ENDPOINT) (
        PDEVICE_DATA, 
        PENDPOINT_PARAMETERS,
        PENDPOINT_DATA 
    );      

/*++
    MINIPORT_QueryEndpointRequirements

    PENDPOINT_DATA is the minport private endpoint
    context
    
    IRQL = DISPATCH_LEVEL
    
VOID
MINIPORT_QueryEndpointRequirements(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_REQUIREMENTS EndpointRequirements
    );   


Notes on Maximum Transfer Sizes:

Control:
    The miniport can assume that no Control transfer buffer passed to 
    it will be larger than EndpointParameters.MAXTRANSFERSIZE.  The miniport 
    should request enough locked memory (common buffer) to support at least 
    one control transfer.

    TBD - The miniport may optionally request that the controller transfer 
    be limmited to a smaller value by setting 
    EndpointRequirements.MAXTRANSFERSIZE.  In this case the miniport must 
    support fragmented control tranfsers.  
    
    EndpointParameters.MAXTRANSFERSIZE can never be larger than 64k by spec.

Interrupt:
    The miniport can indicate the max transfer size for each interrupt
    transfer it can handle in EndpointRequirements.MAXTRANSFERSIZE.
    
    Assume that no transfer buffer will be larger than the this size.
    EndpointParameters.MAXTRANSFERSIZE is the default value. The miniport
    should allocate resources to handle at least two transfers of this size.

Bulk:
    The miniport can indicate the max transfer size for each bulk transfer 
    it can handle in EndpointRequirements.MAXTRANSFERSIZE.  No transfer will 
    be passed in larger than this value. The miniport must request enough 
    resources to program at least two transfers of this size into the hardware. 
    MAXTRANSFERSIZE must be at least 4k.
    
    EndpointParameters.MAXTRANSFERSIZE is the default value.

Basic Iso:
    Miniport may specify an EndpointRequirements.MAXTRANSFERSIZE size 
    but it must also be able to always handle at least two transfers of 
    MAX_ISO_PACKETS_PER_TRANSFER.
        

--*/

/*
    Historical Note:

    The orignal USBD driver shipped in Win98 thru Win2k limits iso requests
    to 255 packets so we are safe to set this limit at 256.

    This is 256ms for full speed and 32 ms for High speed on the hardware 
    per request which is plenty.
    
*/

#define MAX_ISO_PACKETS_PER_TRANSFER    256

typedef VOID
    (USBMPFN *PMPFN_QENDPOINT_REQUIREMENTS) (
        PDEVICE_DATA, 
        PENDPOINT_PARAMETERS,
         PENDPOINT_REQUIREMENTS
    );

/*++
    MINIPORT_PollEndpoint

    Poll the endpoint for done transfers or other changes

    PENDPOINT_DATA is the minport private endpoint
    context
    
    IRQL = DISPATCH_LEVEL
    
VOID
MINIPORT_PollEndpoint(
    PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );       
--*/

typedef VOID
    (USBMPFN *PMPFN_POLL_ENDPOINT) (
        PDEVICE_DATA, 
        PENDPOINT_DATA
    );    

/*
    MINIPORT_CloseEndpoint

    close an endpoint, PENDPOINT_DATA is the minport private endpoint
    context

    free any resources allocated for the endpoint other than BW
    
    IRQL = DISPATCH_LEVEL

VOID
MINIPORT_CloseEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );    
*/

typedef VOID
    (USBMPFN *PMPFN_CLOSE_ENDPOINT) (
        PDEVICE_DATA, 
        PENDPOINT_DATA
    );

/*
    MINIPORT_SetEndpointState

    Set an endpoint to one of our defined transfer states, the endpoint 
    need not be in the state when the miniport returns.
    
    There is an assumption here that the enpoint will reach the 
    desired state on the next SOF, the port will keep track of 
    this and assume that the state transition has occurred after 
    one ms frame has passed.

    These are software state, changes can only be intiated by a 
    request thru the MINIPORT_SetEndpointState function. endpoints
    cannot transition on their own.

    ENDPOINT_IDLE
        The endpoint has no active transfer, set this endpoint to a 
        state that generates minimal activity on the contoller (ie 
        remove it from the schedule,set skip bit etc)

    ENDPOINT_PAUSE 
        temporarily stop any bus activity associated with the endpoint,
        this is a prelude to receiving an abortTransfer.

    ENDPOINT_ACTIVE 
        enable processing of the enpoint -- ie it is in the schedule and
        ready for action

    ENDPOINT_REMOVE 
        the endpoint has been removed from the HW schedule


    IRQL = DISPATCH_LEVEL

VOID
MINIPORT_SetEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    MP_ENDPOINT_STATE
    );    

MP_ENDPOINT_STATE
MINIPORT_GetEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );     
*/
typedef enum _MP_ENDPOINT_STATE {
    ENDPOINT_TRANSITION = 0,
    ENDPOINT_IDLE,
    ENDPOINT_PAUSE, 
    ENDPOINT_ACTIVE, 
    ENDPOINT_REMOVE,
    ENDPOINT_CLOSED
} MP_ENDPOINT_STATE;    

typedef VOID
    (USBMPFN *PMPFN_SET_ENDPOINT_STATE) (
        PDEVICE_DATA, 
        PENDPOINT_DATA,
        MP_ENDPOINT_STATE
    );
    
typedef MP_ENDPOINT_STATE
    (USBMPFN *PMPFN_GET_ENDPOINT_STATE) (
        PDEVICE_DATA, 
        PENDPOINT_DATA
    );

/*++
    MINIPORT_SetEndpointDataToggle

    resets the data toggle for an endpoint
    
    IRQL = DISPATCH_LEVEL
    
VOID
MINIPORT_SetEndpointDataToggle(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndointData,
    ULONG Toggle
    );       
--*/

typedef VOID
    (USBMPFN *PMPFN_SET_ENDPOINT_DATA_TOGGLE) (
        PDEVICE_DATA,
        PENDPOINT_DATA,
        ULONG            
    );          

/*++
    MINIPORT_GetEndpointStatus
    
    returns the status of an endpoint ie HALTED 
    the status of the endpoint is controlled by the HW.
        
    IRQL = DISPATCH_LEVEL
    
MP_ENDPOINT_STATUS
MINIPORT_GetEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndointData
    );       

VOID
MINIPORT_SetEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndointData,
    MP_ENDPOINT_STATUS EpStatus
    );       
    
--*/

typedef enum _MP_ENDPOINT_STATUS {
    ENDPOINT_STATUS_RUN = 0,
    ENDPOINT_STATUS_HALT
} MP_ENDPOINT_STATUS;    


typedef MP_ENDPOINT_STATUS
    (USBMPFN *PMPFN_GET_ENDPOINT_STATUS) (
        PDEVICE_DATA,
        PENDPOINT_DATA
    );          
    
typedef VOID
    (USBMPFN *PMPFN_SET_ENDPOINT_STATUS) (
        PDEVICE_DATA,
        PENDPOINT_DATA,
        MP_ENDPOINT_STATUS
    );          

/*++
    MINIPORT_Get32BitFrameNumber

    returns the 32 bit frame number maintained by the HCD

    IRQL = DISPATCH_LEVEL
    
ULONG
MINIPORT_Get32BitFrameNumber(
    PDEVICE_DATA DeviceData
    );       
--*/

typedef ULONG
    (USBMPFN *PMPFN_GET_32BIT_FRAME_NUMBER) (
        PDEVICE_DATA 
    );        

/*++
    MINIPORT_InterruptNextSOF

    requests an interrupt at the next SOF interval

    IRQL = DISPATCH_LEVEL
    
VOID
MINIPORT_InterruptNextSOF(
    PDEVICE_DATA DeviceData
    );       
--*/

typedef VOID
    (USBMPFN *PMPFN_INTERRUPT_NEXT_SOF) (
        PDEVICE_DATA 
    );        
    
/*
    MINIPORT_PollController    

    Optional Poll routine for miniport this function will
    be called at the MiniportPollInterval specficeid in 
    the registration packet.
    
    Specifying a vlue of zero disables polling of the 
    controller.

    IRQL = ANY

VOID
MINIPORT_PollController (
    PDEVICE_DATA DeviceData
    );
*/

typedef VOID
    (USBMPFN *PMPFN_POLL_CONTROLLER) (
        PDEVICE_DATA 
    );  
    
/***************************************************************
PNP/POWER Functions

    The following core pnp functions are serialized as a group
    
****************************************************************/

/*
    MINIPORT_CheckController    

    Entry point called by usbport periodically to check the hardware 
    state, this function is not serialized. Typically this is used to 
    detect surprise removal of the hardware. 

    IRQL = ANY

VOID
MINIPORT_CheckController(
    PDEVICE_DATA DeviceData
    );
*/

typedef VOID
    (USBMPFN *PMPFN_CHECK_CONTROLLER) (
        PDEVICE_DATA 
    );  

/*
    MINIPORT_StartController   

    Initialize Hardware, allocate memory etc.

    on return (STATUS_SUCCESS) the device is considered started and 
    powered and must handle ALL CORE functions.

    the miniport should disable any BIOS if present

    the last thing the driver should do before returning is enable 
    interrupt generation by the controller

    HcParameters are filled in by the miniport
    
    IRQL = PASSIVE_LEVEL


USB_MINIPORT_STATUS
MINIPORT_StartController(
    PDEVICE_DATA DeviceData,
    PHC_RESOURCES HcResources
    );
*/    

typedef struct _HC_RESOURCES {

/* values for Flags field */
#define HCR_IO_REGS     0x0000001     
#define HCR_IRQ         0x0000002
#define HCR_MEM_REGS    0x0000004

    ULONG Flags;
    USB_CONTROLLER_FLAVOR ControllerFlavor;
    
    /* interrupt */
    ULONG InterruptVector;
    KIRQL InterruptLevel;
    KAFFINITY Affinity;
    BOOLEAN ShareIRQ;
    KINTERRUPT_MODE InterruptMode;
    PKINTERRUPT InterruptObject;  

    /* io ports */
    /* memory mapped */
    PVOID DeviceRegisters; 
    ULONG DeviceRegistersLength;

    PUCHAR CommonBufferVa;
    HW_32BIT_PHYSICAL_ADDRESS CommonBufferPhys; 

    /* BIOS detected
        filled in by miniport
    */
    BOOLEAN DetectedLegacyBIOS;
    BOOLEAN Restart;
    
} HC_RESOURCES, *PHC_RESOURCES;


typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_START_CONTROLLER) (
        PDEVICE_DATA, 
        PHC_RESOURCES
    );
    

/*
    MINIPORT_StopController   

    disconnect interrupt, free memory etc.

    on return (non Failable) the device is considered stopped and 
    powered down and will no longer receicve calls to CORE functions.

    NOTES: 
        - The miniport will only receive a stop request if it was 
          successfuly started.
        - Miniport should disable all interrupts from the hardware.          
        - if Hardware Present is FALSE the miniport should not access 
          memory registers or ioports.
          
    
    IRQL = PASSIVE_LEVEL


VOID
MINIPORT StopController(
    PDEVICE_DATA DeviceData,
    BOOLEAN HardwarePresent
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_STOP_CONTROLLER) (
        PDEVICE_DATA, 
        BOOLEAN 
    );


/*
    MINIPORT_ResetController   

    Reset the host controller hardware

    This function is serialized with the ISR and DPC and holds
    the core function lock in order to provide a safe environment 
    or the miniport to reset the host hardware.
    

VOID
MINIPORT ResetController(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_RESET_CONTROLLER) (
        PDEVICE_DATA 
    );


/*
    MINIPORT_SuspendController   

    IRQL = PASSIVE_LEVEL


VOID
MINIPORT SuspendController(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_SUSPEND_CONTROLLER) (
        PDEVICE_DATA 
    );

/*
    MINIPORT_ResumeController   

    Attempts to resume HC HW from the suspend state.  The miniport
    may fail this in the event the controller has been hosed by the
    BIOS.  In that even the port driver may attempt to power cycle.

    IRQL = PASSIVE_LEVEL


VOID
MINIPORT ResumeController(
    PDEVICE_DATA DeviceData
    );
*/    

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_RESUME_CONTROLLER) (
        PDEVICE_DATA 
    );    

/*
    MINIPORT_FlushInterrupts   

    Flush Interrupts on the USB the controller HW
    
    IRQL = PASSIVE_LEVEL


VOID
MINIPORT FlushInterrupts(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_FLUSH_INTERRUPTS) (
        PDEVICE_DATA 
    );   

/*
    MINIPORT_TakePortControl   

    Pre start controller initialization
    
    IRQL = PASSIVE_LEVEL


VOID
MINIPORT_TakePortControl(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_TAKE_PORT_CONTROL) (
        PDEVICE_DATA 
    );            

/*
    MINIPORT_EnableInterrupts   

    Enable Interrupts by the USB the controller HW
    
    IRQL = PASSIVE_LEVEL


VOID
MINIPORT EnableInterrupts(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_ENABLE_INTERRUPTS) (
        PDEVICE_DATA 
    );    

/*
    MINIPORT_DisableInterrupts   

    Disable Interrupts by the USB the controller HW

    On return from this function the controller is expected to 
    not generate ANY interrupts. 
    Also the controller should ack all interrupts since on return
    from this routine the ISR & ISRDPC will no longer be called.

    
    IRQL = This function is synchronized with the ISR


VOID
MINIPORT DisableInterrupts(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_DISABLE_INTERRUPTS) (
        PDEVICE_DATA 
    );        


/***************************************************************
ROOT HUB Functions

MINIPORT_RH_GetRootHubData
MINIPORT_RH_DisableIrq
MINIPORT_RH_EnableIrq

MINIPORT_RH_GetStatus
MINIPORT_RH_GetPortStatus 
MINIPORT_RH_GetHubStatus 

Port Functions, all use PMPFN_RH_PORT_FUNCTION
MINIPORT_RH_SetFeaturePortReset
MINIPORT_RH_SetFeaturePortSuspend
MINIPORT_RH_SetFeaturePortPower
MINIPORT_RH_SetFeaturePortEnable

MINIPORT_RH_ClearFeaturePortEnable
MINIPORT_RH_ClearFeaturePortSuspend
MINIPORT_RH_ClearFeaturePortPower

MINIPORT_RH_ClearFeaturePortConnectChange
MINIPORT_RH_ClearFeaturePortResetChange
MINIPORT_RH_ClearFeaturePortEnableChange
MINIPORT_RH_ClearFeaturePortSuspendChange
MINIPORT_RH_ClearFeaturePortOvercurrentChange

****************************************************************/

/* 
    root hub port status data as defined in the Hub Class 
    section of the CORE (USB 1.1) spec.
*/

typedef struct _RH_PORT_STATUS {

    union {
        struct {
        
            /* Status bits 0.. 15 */
            
            ULONG Connected:1;
            ULONG Enabled:1;
            ULONG Suspended:1;
            ULONG OverCurrent:1;
            ULONG Reset:1;        
            ULONG Reserved0:3;
            ULONG PowerOn:1;
            ULONG LowSpeed:1;
            ULONG HighSpeed:1;
            ULONG Reserved1:4;
            /* borrowed from reserved bits to indicate 
                port disposition */
            ULONG OwnedByCC:1; 
        
            /* Change bits 16..31 */
        
            ULONG ConnectChange:1;
            ULONG EnableChange:1;
            ULONG SuspendChange:1;
            ULONG OverCurrentChange:1;
            ULONG ResetChange:1;
            ULONG Reserved2:11;
            
        };
        ULONG ul;
   }; 
} RH_PORT_STATUS, *PRH_PORT_STATUS;

C_ASSERT(sizeof(RH_PORT_STATUS) == sizeof(ULONG));

typedef struct _RH_HUB_STATUS {

    /* Status bits 0.. 15 */
    union {
        struct {   
            ULONG LocalPowerLost:1;
            ULONG OverCurrent:1;
            ULONG Reserved:14;
        
            /* Change bits 16..31 */
        
            ULONG LocalPowerChange:1;
            ULONG OverCurrentChange:1;
            ULONG Reserved2:14;
        };
        ULONG ul;
    };    
} RH_HUB_STATUS, *PRH_HUB_STATUS;

C_ASSERT(sizeof(RH_HUB_STATUS) == sizeof(ULONG));

/*
   Hub Charateristics as defined 
   in 11.11.2 of the USB core spec.
*/   
/* PowerSwitchType */
#define USBPORT_RH_POWER_SWITCH_GANG    0    
#define USBPORT_RH_POWER_SWITCH_PORT    1

typedef union _RH_HUB_CHARATERISTICS {

    USHORT us;
    struct {
        /* 
            00 = Gang switched
            01 = port power switched

            1x = 1.0 hubs with no power 
                 switching
        */
        USHORT PowerSwitchType:2;       /* 0-1      */
        USHORT CompoundDevice:1;        /* 2        */
        USHORT OverCurrentProtection:2; /* 3-4      */
        USHORT Reserved:11;             /* 5-15     */
    }; 

} RH_HUB_CHARATERISTICS, *PRH_HUB_CHARATERISTICS;

C_ASSERT(sizeof(RH_HUB_CHARATERISTICS) == sizeof(USHORT));


typedef struct _ROOTHUB_DATA {

    ULONG NumberOfPorts;         // number of ports on this hub
    RH_HUB_CHARATERISTICS HubCharacteristics;  
    USHORT pad;
    ULONG PowerOnToPowerGood;    // port power on till power good in 2ms
    ULONG HubControlCurrent;     // max current in mA

} ROOTHUB_DATA, *PROOTHUB_DATA;



/*
    MINIPORT_RH_GetRootHubData   

    get information about the root hub, port 
    driver uses this information to emulate 
    the root hub for the miniport
    
    IRQL = PASSIVE_LEVEL


VOID
MINIPORT_RH_GetRootHubData(
    PDEVICE_DATA DeviceData,
     PROOTHUB_DATA HubData
    );
*/

typedef VOID
    (USBMPFN *PMPFN_RH_GET_ROOTHUB_DATA) (
        PDEVICE_DATA, 
        PROOTHUB_DATA
    );
    

/*
    MINIPORT_RH_GetStatus   

    Used to support the GET_STATUS command sent to the root hub device.

    may return with the following bits set in Status
    
        USB_GETSTATUS_SELF_POWERED                0x01
        USB_GETSTATUS_REMOTE_WAKEUP_ENABLED       0x02

    are we self powered?
    are we a remote wakeup source?
    
    see section 9.4.5 USB 1.1 spec
    
    
    IRQL = PASSIVE_LEVEL


USB_MINIPORT_STATUS
MINIPORT_RH_GetStatus(
    PDEVICE_DATA DeviceData
     PUSHORT Status
    );
*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_RH_GET_STATUS) (
        PDEVICE_DATA, 
         PUSHORT
    );

/*
    MINIPORT_RH_DisableIrq  (OPTIONAL)

    If the comntroller is capable of generating interrupts
    on root hub status changes then it must provide this 
    service to disable/enable the feature.

    IRQL = DPC_LEVEL


VOID
MINIPORT_RH_DisableIrq(
    PDEVICE_DATA DeviceData
    );
*/

typedef VOID
    (USBMPFN *PMPFN_RH_DISABLE_IRQ) (
        PDEVICE_DATA 
    );
    
/*
    MINIPORT_RH_EnableIrq   (OPTIONAL)

    IRQL = DPC_LEVEL


VOID
MINIPORT_RH_EnableIrq(
    PDEVICE_DATA DeviceData
    );
*/

typedef VOID
    (USBMPFN *PMPFN_RH_ENABLE_IRQ) (
        PDEVICE_DATA 
    );
    
/*
    MINIPORT_RH_GetPortStatus   

    Used to support the GET_STATUS hub class command sent 
    to the root hub interface for a port.

    PortNumber = 1,2, etc

    see section 11.16.2.5 of USB 1.1 spec

    IRQL = PASSIVE_LEVEL


USB_MINIPORT_STATUS
MINIPORT_RH_GetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
     PRH_PORT_STATUS PortStatus
    );
*/


typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_RH_GET_PORT_STATUS) (
        PDEVICE_DATA, 
        USHORT,
        PRH_PORT_STATUS
    );


/*
    MINIPORT_RH_GetHubStatus   

    Used to support the GET_STATUS hub class command sent 
    to the root hub interface for a hub.

    IRQL = PASSIVE_LEVEL


USB_MINIPORT_STATUS
MINIPORT_RH_GetHubStatus(
    PDEVICE_DATA DeviceData,
     PRH_HUB_STATUS HubStatus
    );
*/


typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_RH_GET_HUB_STATUS) (
        PDEVICE_DATA, 
        PRH_HUB_STATUS
    );


/*
    MINIPORT_RH_PORT_FUNCTION   

    format for root hub services that act on ports.

    PortNumber = 1,2, etc
     
    IRQL = PASSIVE_LEVEL


USB_MINIPORT_STATUS
MINIPORT_RH_PORT_FUNCTION(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

    The following services use the MINIPORT_RH_PORT_FUNCTION
    format
    
    MINIPORT_RH_SetFeaturePortReset   

    MINIPORT_RH_SetFeaturePortPower   

    MINIPORT_RH_SetFeaturePortEnable  

    MINIPORT_RH_SetFeaturePortSuspend  
    
    MINIPORT_RH_ClearFeaturePortEnable   

    MINIPORT_RH_ClearFeaturePortPower   
    
    MINIPORT_RH_ClearFeaturePortEnableChange   

    MINIPORT_RH_ClearFeaturePortConnectChange   

    MINIPORT_RH_ClearFeaturePortResetChange   

*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_RH_PORT_FUNCTION) (
        PDEVICE_DATA, 
        USHORT
    );

/***************************************************************
 INTERRUPT Functions
 
these functions are not serialized
****************************************************************/

/*
    MINIPORT_InterruptService    

    IRQL = ANY

BOOLEAN
MINIPORT_InterruptService (
    PDEVICE_DATA DeviceData
    );
*/

typedef BOOLEAN
    (USBMPFN *PMPFN_INTERRUPT_SERVICE) (
        PDEVICE_DATA
    );


/*
    MINIPORT_InterruptDpc    

    Called by port in response to an interrupt generated by the HW.

    This function is not serialize with other core functions since 
    which allow it to call services in USBPORT that result in 
    immediate calls to core functions.

    The port driver passes a flag to indicate if interrupts need 
    to be re-enabled on completion of this routine.  This is to handle
    the rare case where interrupts have been disabled just after the
    ISR has queued a DPC.

    IRQL = DISPATCH_LEVEL

VOID
MINIPORT_InterruptDpc (
    PDEVICE_DATA DeviceData
    BOOLEAN EnableInterrupts
    );
*/

typedef VOID
    (USBMPFN *PMPFN_INTERRUPT_DPC) (
        PDEVICE_DATA, 
        BOOLEAN 
    );


/***************************************************************
 DEBUG/TEST Functions
 
****************************************************************/

/*
    MINIPORT_SendOnePacket    

    IRQL = ANY

    used to support the single-step debug application.  This api is
    OPTIONAL

    

VOID
MINIPORT_SendOnePacket (
    PDEVICE_DATA DeviceData,
    PPACKET_PARAMETERS PacketParameters,
    PUCHAR PacketData,
    PULONG PacketLength,
    PUCHAR WorkspaceVirtualAddress,
    HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    ULONG WorkspaceLength,
    PUSBD_STATUS UsbdStatus
    );

*/

typedef enum _SS_PACKET_TYPE {
    ss_Setup = 0,
    ss_In, 
    ss_Out,
    ss_Iso_In,
    ss_Iso_Out
} SS_PACKET_TYPE;    


typedef enum _SS_PACKET_SPEED {
    ss_Low = 0,
    ss_Full, 
    ss_High
} SS_PACKET_SPEED;    


typedef enum _SS_PACKET_DATA_TOGGLE {
    ss_Toggle0 = 0,
    ss_Toggle1
} SS_PACKET_DATA_TOGGLE;    


typedef struct _MP_PACKET_PARAMETERS {
    UCHAR DeviceAddress;
    UCHAR EndpointAddress;
    USHORT MaximumPacketSize;
    USHORT ErrorCount;
    USHORT Pad;
    SS_PACKET_TYPE Type;
    SS_PACKET_SPEED Speed;
    SS_PACKET_DATA_TOGGLE Toggle;
    /* 2.0 hubs */
    USHORT HubDeviceAddress;
    USHORT PortTTNumber;
} MP_PACKET_PARAMETERS, *PMP_PACKET_PARAMETERS;

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_SEND_ONE_PACKET) (
        PDEVICE_DATA, 
        PMP_PACKET_PARAMETERS,
        PUCHAR, 
        PULONG,
        PUCHAR,
        HW_32BIT_PHYSICAL_ADDRESS,
        ULONG,
        USBD_STATUS *
    );


/***************************************************************
 API Functions
    These are called at IRQL passive_level
****************************************************************/

/*
    MINIPORT_PassThru    

    IRQL = PASSIVE_LEVEL

    

USB_MINIPORT_STATUS
MINIPORT_PassThru (
    PDEVICE_DATA DeviceData,
    GUID *FunctionGuid,
    ULONG ParameterLength,
    PVOID Parameters
    );
*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_PASS_THRU) (
        PDEVICE_DATA, 
        GUID *, 
        ULONG,
        PVOID 
    );
    
/***************************************************************
 ***************************************************************
 REGISTRATION PACKET
 ***************************************************************
****************************************************************/

/* HCI Hardware Types */

typedef enum _USB_HCI_TYPE {

    USB_UNKNOWN_HCI = 0,
    USB_OHCI,   
    USB_UHCI,   
    USB_EHCI
    
} USB_HCI_TYPE;


/* Miniport Option Flags */

/* resources required by miniport */ 
#define USB_MINIPORT_OPT_NEED_IRQ             0x00000001
#define USB_MINIPORT_OPT_NEED_IOPORT          0x00000002
#define USB_MINIPORT_OPT_NEED_MEMORY          0x00000004
/* USB version */
#define USB_MINIPORT_OPT_USB11                0x00000008
#define USB_MINIPORT_OPT_USB20                0x00000010
/* support selective suspend */
#define USB_MINIPORT_OPT_NO_SS                0x00000020
/* disables synchronization of the ISRDPC and the 
   MP_DisableInterrupts function. usbed by UHCI 
   to clear/ set PIRQD in config space. */
#define USB_MINIPORT_OPT_NO_IRQ_SYNC          0x00000040
/* indicates controller poll routine should be called 
    this will always be at least ounce evert 500ms
*/    
#define USB_MINIPORT_OPT_POLL_CONTROLLER      0x00000080
/* for bridge drivers with no hw resources */
#define USB_MINIPORT_OPT_NO_PNP_RESOURCES     0x00000100
/* poll whe HW suspended */
#define USB_MINIPORT_OPT_POLL_IN_SUSPEND      0x00000200

#define USB_MINIPORT_HCI_VERSION USB_MINIPORT_HCI_VERSION_1
#define USB_MINIPORT_HCI_VERSION_1            100
#define USB_MINIPORT_HCI_VERSION_2            200

/*
    Bus Bandwidth defined by spec
*/
#define USB_11_BUS_BANDWIDTH                12000
#define USB_20_BUS_BANDWIDTH                400000

#define USB_HCI_MN                          0x10000001

/* version shipped with XP 2600 this must remaon unchanged */

typedef struct _USBPORT_REGISTRATION_PACKET_V1 {

    /* begin version (1) interface definition */

    /* Host Controller HCI Type */
    USB_HCI_TYPE HciType;    
    
    /* registration parameters */
    ULONG OptionFlags;

    /* 
       Total bus bandwidth avaibale in MBits
     */
    ULONG BusBandwidth;

    LONG Reserved;

    ULONG DeviceDataSize;
    ULONG EndpointDataSize;
    ULONG TransferContextSize;

    /* 7 char ASCII NULL terminated name */
    UCHAR Name[8]; 

    /*
        Amount of global common buffer needed
        this memory is passed to the miniport on 
        a start and freed on a stop 
    */
    ULONG CommonBufferBytes;

    /* miniport Functions */
    PMPFN_OPEN_ENDPOINT                   MINIPORT_OpenEndpoint;
    PMPFN_POKE_ENDPOINT                   MINIPORT_PokeEndpoint;
    PMPFN_QENDPOINT_REQUIREMENTS          MINIPORT_QueryEndpointRequirements;
    PMPFN_CLOSE_ENDPOINT                  MINIPORT_CloseEndpoint;
    PMPFN_START_CONTROLLER                MINIPORT_StartController;
    PMPFN_STOP_CONTROLLER                 MINIPORT_StopController;
    PMPFN_SUSPEND_CONTROLLER              MINIPORT_SuspendController;  
    PMPFN_RESUME_CONTROLLER               MINIPORT_ResumeController;
    PMPFN_INTERRUPT_SERVICE               MINIPORT_InterruptService;
    PMPFN_INTERRUPT_DPC                   MINIPORT_InterruptDpc;
    PMPFN_SUBMIT_TRANSFER                 MINIPORT_SubmitTransfer;
    PMPFN_SUBMIT_ISO_TRANSFER             MINIPORT_SubmitIsoTransfer;
    PMPFN_ABORT_TRANSFER                  MINIPORT_AbortTransfer;
    PMPFN_GET_ENDPOINT_STATE              MINIPORT_GetEndpointState;
    PMPFN_SET_ENDPOINT_STATE              MINIPORT_SetEndpointState;  
    PMPFN_POLL_ENDPOINT                   MINIPORT_PollEndpoint; 
    PMPFN_CHECK_CONTROLLER                MINIPORT_CheckController;
    PMPFN_GET_32BIT_FRAME_NUMBER          MINIPORT_Get32BitFrameNumber;
    PMPFN_INTERRUPT_NEXT_SOF              MINIPORT_InterruptNextSOF;
    PMPFN_ENABLE_INTERRUPTS               MINIPORT_EnableInterrupts;
    PMPFN_DISABLE_INTERRUPTS              MINIPORT_DisableInterrupts;
    PMPFN_POLL_CONTROLLER                 MINIPORT_PollController;
    PMPFN_SET_ENDPOINT_DATA_TOGGLE        MINIPORT_SetEndpointDataToggle; 
    PMPFN_GET_ENDPOINT_STATUS             MINIPORT_GetEndpointStatus;
    PMPFN_SET_ENDPOINT_STATUS             MINIPORT_SetEndpointStatus;  
    PMPFN_RESET_CONTROLLER                MINIPORT_ResetController;  
   
    /* root hub functions */
    PMPFN_RH_GET_ROOTHUB_DATA             MINIPORT_RH_GetRootHubData;
    PMPFN_RH_GET_STATUS                   MINIPORT_RH_GetStatus;
    PMPFN_RH_GET_PORT_STATUS              MINIPORT_RH_GetPortStatus;  
    PMPFN_RH_GET_HUB_STATUS               MINIPORT_RH_GetHubStatus;  
    /* root hub port functions */                                
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortReset;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortPower;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortEnable;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortSuspend;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortEnable;    
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortPower;   
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortSuspend; 
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortEnableChange;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortConnectChange;        
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortResetChange;                                                        
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortSuspendChange;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortOvercurrentChange;
    
    /* optional root hub functions */
    PMPFN_RH_DISABLE_IRQ                  MINIPORT_RH_DisableIrq;
    PMPFN_RH_ENABLE_IRQ                   MINIPORT_RH_EnableIrq;

    /* OPTIONAL DEBUG SERVICES
    
        Miniport should return USBMP_STATUS_NOT_SUPPORTED for the 
        services not supported.
     */
    PMPFN_SEND_ONE_PACKET                 MINIPORT_StartSendOnePacket;
    PMPFN_SEND_ONE_PACKET                 MINIPORT_EndSendOnePacket;

    /* PASS-THRU API function
        
    */
    PMPFN_PASS_THRU                        MINIPORT_PassThru;
    

    /* interface Services */
    PPORTFN_DBGPRINT                            USBPORTSVC_DbgPrint;
    PPORTFN_TEST_DEBUG_BREAK                    USBPORTSVC_TestDebugBreak;
    PPORTFN_ASSERT_FAILURE                      USBPORTSVC_AssertFailure;
    PPORTFN_GET_MINIPORT_REGESTRY_KEY_VALUE     USBPORTSVC_GetMiniportRegistryKeyValue;
    PPORTFN_INVALIDATE_ROOTHUB                  USBPORTSVC_InvalidateRootHub;
    PPORTFN_INVALIDATE_ENDPOINT                 USBPORTSVC_InvalidateEndpoint;
    PPORTFN_COMPLETE_TRANSFER                   USBPORTSVC_CompleteTransfer;
    PPORTFN_COMPLETE_ISO_TRANSFER               USBPORTSVC_CompleteIsoTransfer;
    PPORTFN_LOGENTRY                            USBPORTSVC_LogEntry;
    PPORTFN_PHYS_TO_VIRTUAL                     USBPORTSVC_MapHwPhysicalToVirtual;
    PPORTFN_REQUEST_ASYNC_CALLBACK              USBPORTSVC_RequestAsyncCallback;
    PPORTFN_READWRITE_CONFIG_SPACE              USBPORTSVC_ReadWriteConfigSpace;
    PPORTFN_WAIT                                USBPORTSVC_Wait;
    PPORTFN_INVALIDATE_CONTROLLER               USBPORTSVC_InvalidateController;
    PPORTFN_BUGCHECK                            USBPORTSVC_BugCheck;
    PPORTFN_NOTIFY_DOUBLE_BUFFER                USBPORTSVC_NotifyDoubleBuffer;

    PMPFN_REBALANCE_ENDPOINT                    MINIPORT_RebalanceEndpoint;  
    PMPFN_FLUSH_INTERRUPTS                      MINIPORT_FlushInterrupts;

} USBPORT_REGISTRATION_PACKET_V1, *PUSBPORT_REGISTRATION_PACKET_V1;

/*
    Miniport version 2 (current) api packet
*/
typedef struct _USBPORT_REGISTRATION_PACKET {

    /* begin version (1) interface definition */

    /* Host Controller HCI Type */
    USB_HCI_TYPE HciType;    
    
    /* registration parameters */
    ULONG OptionFlags;

    /* 
       Total bus bandwidth avaibale in MBits
     */
    ULONG BusBandwidth;

    LONG Reserved;

    ULONG DeviceDataSize;
    ULONG EndpointDataSize;
    ULONG TransferContextSize;

    /* 7 char ASCII NULL terminated name */
    UCHAR Name[8]; 

    /*
        Amount of global common buffer needed
        this memory is passed to the miniport on 
        a start and freed on a stop 
    */
    ULONG CommonBufferBytes;

    /* miniport Functions */
    PMPFN_OPEN_ENDPOINT                   MINIPORT_OpenEndpoint;
    PMPFN_POKE_ENDPOINT                   MINIPORT_PokeEndpoint;
    PMPFN_QENDPOINT_REQUIREMENTS          MINIPORT_QueryEndpointRequirements;
    PMPFN_CLOSE_ENDPOINT                  MINIPORT_CloseEndpoint;
    PMPFN_START_CONTROLLER                MINIPORT_StartController;
    PMPFN_STOP_CONTROLLER                 MINIPORT_StopController;
    PMPFN_SUSPEND_CONTROLLER              MINIPORT_SuspendController;  
    PMPFN_RESUME_CONTROLLER               MINIPORT_ResumeController;
    PMPFN_INTERRUPT_SERVICE               MINIPORT_InterruptService;
    PMPFN_INTERRUPT_DPC                   MINIPORT_InterruptDpc;
    PMPFN_SUBMIT_TRANSFER                 MINIPORT_SubmitTransfer;
    PMPFN_SUBMIT_ISO_TRANSFER             MINIPORT_SubmitIsoTransfer;
    PMPFN_ABORT_TRANSFER                  MINIPORT_AbortTransfer;
    PMPFN_GET_ENDPOINT_STATE              MINIPORT_GetEndpointState;
    PMPFN_SET_ENDPOINT_STATE              MINIPORT_SetEndpointState;  
    PMPFN_POLL_ENDPOINT                   MINIPORT_PollEndpoint; 
    PMPFN_CHECK_CONTROLLER                MINIPORT_CheckController;
    PMPFN_GET_32BIT_FRAME_NUMBER          MINIPORT_Get32BitFrameNumber;
    PMPFN_INTERRUPT_NEXT_SOF              MINIPORT_InterruptNextSOF;
    PMPFN_ENABLE_INTERRUPTS               MINIPORT_EnableInterrupts;
    PMPFN_DISABLE_INTERRUPTS              MINIPORT_DisableInterrupts;
    PMPFN_POLL_CONTROLLER                 MINIPORT_PollController;
    PMPFN_SET_ENDPOINT_DATA_TOGGLE        MINIPORT_SetEndpointDataToggle; 
    PMPFN_GET_ENDPOINT_STATUS             MINIPORT_GetEndpointStatus;
    PMPFN_SET_ENDPOINT_STATUS             MINIPORT_SetEndpointStatus;  
    PMPFN_RESET_CONTROLLER                MINIPORT_ResetController;  
   
    /* root hub functions */
    PMPFN_RH_GET_ROOTHUB_DATA             MINIPORT_RH_GetRootHubData;
    PMPFN_RH_GET_STATUS                   MINIPORT_RH_GetStatus;
    PMPFN_RH_GET_PORT_STATUS              MINIPORT_RH_GetPortStatus;  
    PMPFN_RH_GET_HUB_STATUS               MINIPORT_RH_GetHubStatus;  
    /* root hub port functions */                                
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortReset;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortPower;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortEnable;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortSuspend;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortEnable;    
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortPower;   
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortSuspend; 
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortEnableChange;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortConnectChange;        
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortResetChange;                                                        
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortSuspendChange;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortOvercurrentChange;
    
    /* optional root hub functions */
    PMPFN_RH_DISABLE_IRQ                  MINIPORT_RH_DisableIrq;
    PMPFN_RH_ENABLE_IRQ                   MINIPORT_RH_EnableIrq;

    /* OPTIONAL DEBUG SERVICES
    
        Miniport should return USBMP_STATUS_NOT_SUPPORTED for the 
        services not supported.
     */
    PMPFN_SEND_ONE_PACKET                 MINIPORT_StartSendOnePacket;
    PMPFN_SEND_ONE_PACKET                 MINIPORT_EndSendOnePacket;

    /* PASS-THRU API function
        
    */
    PMPFN_PASS_THRU                        MINIPORT_PassThru;
    

    /* interface Services */
    PPORTFN_DBGPRINT                            USBPORTSVC_DbgPrint;
    PPORTFN_TEST_DEBUG_BREAK                    USBPORTSVC_TestDebugBreak;
    PPORTFN_ASSERT_FAILURE                      USBPORTSVC_AssertFailure;
    PPORTFN_GET_MINIPORT_REGESTRY_KEY_VALUE     USBPORTSVC_GetMiniportRegistryKeyValue;
    PPORTFN_INVALIDATE_ROOTHUB                  USBPORTSVC_InvalidateRootHub;
    PPORTFN_INVALIDATE_ENDPOINT                 USBPORTSVC_InvalidateEndpoint;
    PPORTFN_COMPLETE_TRANSFER                   USBPORTSVC_CompleteTransfer;
    PPORTFN_COMPLETE_ISO_TRANSFER               USBPORTSVC_CompleteIsoTransfer;
    PPORTFN_LOGENTRY                            USBPORTSVC_LogEntry;
    PPORTFN_PHYS_TO_VIRTUAL                     USBPORTSVC_MapHwPhysicalToVirtual;
    PPORTFN_REQUEST_ASYNC_CALLBACK              USBPORTSVC_RequestAsyncCallback;
    PPORTFN_READWRITE_CONFIG_SPACE              USBPORTSVC_ReadWriteConfigSpace;
    PPORTFN_WAIT                                USBPORTSVC_Wait;
    PPORTFN_INVALIDATE_CONTROLLER               USBPORTSVC_InvalidateController;
    PPORTFN_BUGCHECK                            USBPORTSVC_BugCheck;
    PPORTFN_NOTIFY_DOUBLE_BUFFER                USBPORTSVC_NotifyDoubleBuffer;

    PMPFN_REBALANCE_ENDPOINT                    MINIPORT_RebalanceEndpoint;  
    PMPFN_FLUSH_INTERRUPTS                      MINIPORT_FlushInterrupts;

    /* end version (1) definition */       

    /* begin version (2) definition */
    PMPFN_RH_PORT_FUNCTION                      MINIPORT_Chirp_RH_Port;
    PMPFN_TAKE_PORT_CONTROL                     MINIPORT_TakePortControl;
    PVOID pad2;
    PVOID pad3;
    
    /* end version (2) definition */

} USBPORT_REGISTRATION_PACKET, *PUSBPORT_REGISTRATION_PACKET;

/************************************************************** 
**************************************************************
 USBPORT DLL Services    
***************************************************************    
***************************************************************/

#ifndef USBPORT

DECLSPEC_IMPORT
NTSTATUS
USBPORT_RegisterUSBPortDriver(
    PDRIVER_OBJECT DriverObject,
    ULONG MiniportHciVersion,
    PUSBPORT_REGISTRATION_PACKET RegistrationPacket
    );

DECLSPEC_IMPORT
ULONG
USBPORT_GetHciMn(
    );

#endif    

/* miniport must define these */

#undef PDEVICE_DATA
#undef PTRANSFER_CONTEXT
#undef PENDPOINT_DATA 

#endif /* __USB_HCDI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\list.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    list.c

Abstract:

    WinDbg Extension Api
    implements !list

Author:

    jdunn

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usbhcdkd.h"

// _list DH
VOID
DumpDeviceHandleList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_USBD_DEVICE_HANDLE";

    PrintfMemLoc("*LIST -- DeviceHandleList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc) {
        USHORT vid, pid;

        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs, 
            "ListEntry");

        dprintf ("[%d] DeviceHandle: ", i);
        PrintfMemLoc("", memLoc, " ");
        i++;

        dprintf("VID %04.4x PID %04.4x\n",
        UsbReadFieldUshort(memLoc, cs, "DeviceDescriptor.idVendor"),
        UsbReadFieldUshort(memLoc, cs, "DeviceDescriptor.idProduct"));                
#if 0
        PrintfMemLoc("\tDriverObject: ", 
            UsbReadFieldPtr(mpMemLoc, cs, "DriverObject"), 
            "\n");
        PrintfMemLoc("\tMiniportUnload: ", 
            UsbReadFieldPtr(mpMemLoc, cs, "MiniportUnload"), 
            "\n");
#endif
        flink = UsbReadFieldPtr(memLoc, cs, "ListEntry.Flink");

                                        
    }

}

#define LT_ENDPOINT_ACTIVE_LIST     0
#define LT_MAP_TRANSFER_LIST        1
#define LT_DONE_TRANSFER_LIST       2
#define LT_ENDPOINT_CANCEL_LIST     3
#define LT_ENDPOINT_PENDING_LIST    4 

// AL, MT, DT 
VOID
DumpTransferList(
    ULONG ListType,
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink, blink, memLoc;
    UCHAR cs[] = "_HCD_TRANSFER_CONTEXT";
    ULONG i=0;
    
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    switch(ListType) {
    case LT_ENDPOINT_ACTIVE_LIST:
        dprintf ("*LIST -- EndpointActiveList\n");
        break;
    case LT_MAP_TRANSFER_LIST:
        dprintf ("*LIST -- MapTransferList\n");
        break;
    case LT_DONE_TRANSFER_LIST:
        dprintf ("*LIST -- DoneTransferList\n");
        break;
    case LT_ENDPOINT_CANCEL_LIST:
        dprintf ("*LIST -- EndpointCancelList\n");
        break;
    case LT_ENDPOINT_PENDING_LIST:        
        dprintf ("*LIST -- EndpointPendingList\n");
        break;
    }

    while (flink != HeadMemLoc) {
        ULONG f;
        
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs, 
            "TransferLink");

        dprintf ("[%d] Transfer (_tfer): ", i);
                    
        PrintfMemLoc(" ", memLoc, " ");             
        PrintfMemLoc(" Urb (_urb): ", 
            UsbReadFieldPtr(memLoc, cs, "Urb"),
            "");             

        f = UsbReadFieldUlong(memLoc, cs, "Flags");            

        if (f & USBPORT_TXFLAG_IN_MINIPORT) {
            dprintf ("  USBPORT_TXFLAG_IN_MINIPORT\n");
        }            

        dprintf ("\n");
        i++;

        flink = UsbReadFieldPtr(memLoc, 
            cs, "TransferLink.Flink");

    }
    
}


// CL
VOID
DumpClosedEnpointList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_HCD_ENDPOINT";
    ENDPOINT_TRANSFER_TYPE tt;
    ENDPOINT_TRANSFER_DIRECTION dir;
    USHORT ea, da;

    PrintfMemLoc("*LIST -- EpClosedList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs, 
            "ClosedLink");

        dprintf ("[%d] Endpoint: ", i);
        PrintfMemLoc("", memLoc, "\n");
        
        da = UsbReadFieldUshort(memLoc, cs, "Parameters.DeviceAddress");
        ea = UsbReadFieldUshort(memLoc, cs, "Parameters.EndpointAddress");
        tt = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferType");
        dir = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferDirection");
        
        dprintf ("\tDevice Address: 0x%02.2x, ep 0x%02.2x ", 
                    da,
                    ea);
        EpType(tt);
        dprintf (" ");
        if (tt != Control) {
            EpDir(dir); 
        }            
        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "ClosedLink.Flink");
    }
    
}


// AT
VOID
DumpAttendEndpointList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_HCD_ENDPOINT";
    ENDPOINT_TRANSFER_TYPE tt;
    ENDPOINT_TRANSFER_DIRECTION dir;
    USHORT ea, da;

    PrintfMemLoc("*LIST -- AttendEndpointList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs, 
            "AttendLink");

        dprintf ("[%d] Endpoint: ", i);
        PrintfMemLoc("", memLoc, "\n");
        
        da = UsbReadFieldUshort(memLoc, cs, "Parameters.DeviceAddress");
        ea = UsbReadFieldUshort(memLoc, cs, "Parameters.EndpointAddress");
        tt = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferType");
        dir = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferDirection");
        
        dprintf ("\tDevice Address: 0x%02.2x, ep 0x%02.2x ", 
                    da,
                    ea);
        EpType(tt);
        dprintf (" ");
        if (tt != Control) {
            EpDir(dir); 
        }            
        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "AttendLink.Flink");
    }
    
}



// GL
VOID
DumpGlobalEnpointList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_HCD_ENDPOINT";
    ENDPOINT_TRANSFER_TYPE tt;
    ENDPOINT_TRANSFER_DIRECTION dir;
    USHORT ea, da;

    PrintfMemLoc("*LIST -- GlobalEndpointList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs, 
            "GlobalLink");

        dprintf ("[%d] Endpoint (_endp): ", i);
        PrintfMemLoc("", memLoc, "\n");
        
        da = UsbReadFieldUshort(memLoc, cs, "Parameters.DeviceAddress");
        ea = UsbReadFieldUshort(memLoc, cs, "Parameters.EndpointAddress");
        tt = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferType");
        dir = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferDirection");
        
        dprintf ("\tDevice Address: 0x%02.2x, ep 0x%02.2x ", 
                    da,
                    ea);
        EpType(tt);
        dprintf (" ");
        if (tt != Control) {
            EpDir(dir); 
        }            
        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "GlobalLink.Flink");
    }
    
}


// SC
VOID
DumpStateEnpointList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_HCD_ENDPOINT";
    ENDPOINT_TRANSFER_TYPE tt;
    ENDPOINT_TRANSFER_DIRECTION dir;
    ULONG f;

    PrintfMemLoc("*LIST -- EpStateChangeList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs, 
            "StateLink");

        dprintf ("[%d] Endpoint (_endp): ", i);
        PrintfMemLoc("", memLoc, " ");
        
        f = UsbReadFieldUlong(memLoc, cs, "StateChangeFrame");
        dprintf ("- frame (0x%x) \n", f);
        
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "StateLink.Flink");
    }
    
}


// PH
VOID
DumpPipeHandleList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "USBD_PIPE_HANDLE_I";

    PrintfMemLoc("*LIST -- PipeHandleList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc && i<100) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs, 
            "ListEntry");

        dprintf ("[%d] PipeHandle (_piph): ", i);
        PrintfMemLoc("", memLoc, "\n");
        
        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "ListEntry.Flink");
    }
    
#if 0
    LIST_ENTRY headListEntry;
    ULONG pipeMemLoc, result, i=0;
    USBD_PIPE_HANDLE_I pipeHandle;
    ULONG memLocListEntry;
    
    dprintf ("*LIST -- PipeHandleList\n");
    if (ReadMemory (HeadMemLoc, &headListEntry, sizeof (LIST_ENTRY), &result)) {

        memLocListEntry = (ULONG) headListEntry.Flink;

        while (memLocListEntry != HeadMemLoc) {
            // extact this device handle
            pipeMemLoc = memLocListEntry;
            pipeMemLoc = pipeMemLoc-
                 FIELD_OFFSET(USBD_PIPE_HANDLE_I, ListEntry);

            if (ReadMemory (pipeMemLoc, &pipeHandle, sizeof (pipeHandle), &result)) {
                dprintf ("[%d] PipeHandle: %08.8x endpoint: %08.8x\n", i, 
                    pipeMemLoc, pipeHandle.Endpoint);
                // display the address and type
                i++;
                memLocListEntry = (ULONG) pipeHandle.ListEntry.Flink;
            } else {
                dprintf ("Could not read Pipehandle\n");
                break;
            }
        }
    
    } else {
        dprintf ("Could not read list head\n");
    }
#endif    
}


// TT
VOID
DumpTtList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_TRANSACTION_TRANSLATOR";

    PrintfMemLoc("*LIST -- TtList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc && i<100) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs, 
            "TtLink");

        dprintf ("[%d] TT (_tt): ", i);
        PrintfMemLoc("", memLoc, "\n");
        
        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "TtLink.Flink");
    }
}


// AI
VOID
DumpAbortIrpList(
    MEMLOC HeadMemLoc
    )
{

    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    MEMLOC irpMemLoc;
    ULONG i = 0;

    PrintfMemLoc("*LIST -- AbortIrpList ", HeadMemLoc, "\n");
#if 0
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    memLoc = flink;

    while (memLoc != HeadMemLoc) {
    
        // extract this entry
                
        irpMemLoc = memLoc;
        GetFieldValue(memLoc, "_LIST_ENTRY", "Flink", memLoc);
        irpMemLoc = irpMemLoc-
             UsbFieldOffset("_IRP", 
                    "Tail.Overlay.ListEntry");

        dprintf ("[%d] Irp: ", i);                    
        PrintfMemLoc("", irpMemLoc, "\n");
        i++;
    }
#endif    
}



PCHAR
ListEmpty(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    if (flink == HeadMemLoc) {
        return "empty\n";
    } else {
        return "\n";
    }
}


DECLARE_API( _list )

/*++

Routine Description:

   dumps a usbport list

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    UCHAR parm[32];

    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("list: ", addr, " ");
    sscanf(s, ",%s", &parm);
    dprintf("%s\n", parm);

    if (_strcmpi(parm, "DH") == 0) {
        DumpDeviceHandleList(addr);
    }        

    if (_strcmpi(parm, "GL") == 0) {
        DumpGlobalEnpointList(addr);
    }        

    if (_strcmpi(parm, "AL") == 0) {
        DumpTransferList(LT_ENDPOINT_ACTIVE_LIST, addr);
    } 

     if (_strcmpi(parm, "AI") == 0) {
        DumpAbortIrpList(addr);
    } 

    if (_strcmpi(parm, "XL") == 0) {
        DumpClosedEnpointList(addr);
    }  

    if (_strcmpi(parm, "AT") == 0) {
        DumpAttendEndpointList(addr);
    }

    if (_strcmpi(parm, "SC") == 0) {
        DumpStateEnpointList(addr);
    }  

    if (_strcmpi(parm, "PH") == 0) {
        DumpPipeHandleList(addr);
    }  

    if (_strcmpi(parm, "TT") == 0) {
        DumpTtList(addr);
    }  

    if (_strcmpi(parm, "DT") == 0) {
        DumpTransferList(LT_DONE_TRANSFER_LIST, addr);
    } 

    if (_strcmpi(parm, "MT") == 0) {
        DumpTransferList(LT_MAP_TRANSFER_LIST, addr);
    } 

    
#if 0
    if (_strcmpi(parm, "XL") == 0) {
        DumpClosedEnpointList(memLoc, level);
    }  

    if (_strcmpi(parm, "SC") == 0) {
        DumpStateEnpointList(memLoc, level);
    }  

    if (_strcmpi(parm, "PH") == 0) {
        DumpPipeHandleList(memLoc, level);
    }  

    if (_strcmpi(parm, "AT") == 0) {
        DumpAttendEndpointList(memLoc, level);
    } 

    // endpoint transfer lists
    if (_strcmpi(parm, "AL") == 0) {
        DumpTransferList(LT_ENDPOINT_ACTIVE_LIST, memLoc, level);
    } 

    if (_strcmpi(parm, "CL") == 0) {
        DumpTransferList(LT_ENDPOINT_CANCEL_LIST, memLoc, level);
    } 

    if (_strcmpi(parm, "PL") == 0) {
        DumpTransferList(LT_ENDPOINT_PENDING_LIST, memLoc, level);
    } 


    // global transfer lists
    if (_strcmpi(parm, "MT") == 0) {
        DumpTransferList(LT_MAP_TRANSFER_LIST, memLoc, level);
    } 

    if (_strcmpi(parm, "DT") == 0) {
        DumpTransferList(LT_DONE_TRANSFER_LIST, memLoc, level);
    } 

    if (_strcmpi(parm, "AI") == 0) {
        DumpAbortIrpList(memLoc, level);
    }        
#endif

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\ext.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ext.c

Abstract:

    WinDbg Extension Api
    implements !_ext
               !_help 
               !_pow

Author:

    jdunn

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usbhcdkd.h"


PUCHAR 
S_State(
    SYSTEM_POWER_STATE S
    )
{
    switch (S) {
    case PowerSystemUnspecified:
        return "SystemUnspecified(S?)";
    case PowerSystemWorking:
        return "SystemWorking    (S0)";
    case PowerSystemSleeping1:
        return "SystemSleeping1  (S1)";
    case PowerSystemSleeping2:
        return "SystemSleeping2  (S2)";
    case PowerSystemSleeping3:
        return "SystemSleeping3  (S3)";
    case PowerSystemHibernate:
        return "SystemHibernate      ";
    case PowerSystemShutdown:
        return "SystemShutdown       ";
    case PowerSystemMaximum:
        return "SystemMaximum        ";
    }        

    return "???";
}


PUCHAR 
PwrAttributes(
    HC_POWER_ATTRIBUTES A
    )
{
    switch (A) {
    case HcPower_N_Wakeup_N:
        return "HcPower_N_Wakeup_N";
    case HcPower_Y_Wakeup_Y:
        return "HcPower_Y_Wakeup_Y";
    case HcPower_Y_Wakeup_N:
        return "HcPower_Y_Wakeup_N";
    case HcPower_N_Wakeup_Y:
        return "HcPower_N_Wakeup_Y";
    }
    return "???";
}


PUCHAR 
D_State(
    DEVICE_POWER_STATE D
    )
{
    switch (D) {
    case PowerDeviceUnspecified:
        return "D?";
    case PowerDeviceD0:
        return "D0";
    case PowerDeviceD1:
        return "D1";
    case PowerDeviceD2:
        return "D2";
    case PowerDeviceD3:
        return "D3";
    case PowerDeviceMaximum:
        return "DX";
    }        

    return "??";
}


VOID
DumpPortFdoDevExt(
    MEMLOC ExtMemLoc
    )
{
    ULONG i, f;
    UCHAR cs[] = "usbport!_FDO_EXTENSION";
    ULONG bandwidthTable[USBPORT_MAX_INTEP_POLLING_INTERVAL];
    MEMLOC l;
    
    FLAG_TABLE fdoFlags[] = {
    "USBPORT_FDOFLAG_IRQ_CONNECTED", USBPORT_FDOFLAG_IRQ_CONNECTED,
    "USBPORT_FDOFLAG_ENABLE_SYSTEM_WAKE", USBPORT_FDOFLAG_ENABLE_SYSTEM_WAKE,
    "USBPORT_FDOFLAG_POLL_CONTROLLER", USBPORT_FDOFLAG_POLL_CONTROLLER,
    "USBPORT_FDOFLAG_KILL_THREAD", USBPORT_FDOFLAG_KILL_THREAD,

    "USBPORT_FDOFLAG_NEED_SET_POWER_D0", USBPORT_FDOFLAG_NEED_SET_POWER_D0,
    "USBPORT_FDOFLAG_DM_TIMER_ENABLED", USBPORT_FDOFLAG_DM_TIMER_ENABLED,
    "USBPORT_FDOFLAG_SKIP_TIMER_WORK", USBPORT_FDOFLAG_SKIP_TIMER_WORK,
    "USBPORT_FDOFLAG_OFF", USBPORT_FDOFLAG_OFF,
    
    "USBPORT_FDOFLAG_SUSPENDED", USBPORT_FDOFLAG_SUSPENDED,
    "USBPORT_FDOFLAG_IRQ_EN", USBPORT_FDOFLAG_IRQ_EN,
    "USBPORT_FDOFLAG_RH_CAN_SUSPEND", USBPORT_FDOFLAG_RH_CAN_SUSPEND,
    "USBPORT_FDOFLAG_RESUME_SIGNALLING", USBPORT_FDOFLAG_RESUME_SIGNALLING,
    
    "USBPORT_FDOFLAG_HCPENDING_WAKE_IRP", USBPORT_FDOFLAG_HCPENDING_WAKE_IRP,
    "USBPORT_FDOFLAG_DM_TIMER_INIT",  USBPORT_FDOFLAG_DM_TIMER_INIT,
    "USBPORT_FDOFLAG_THREAD_INIT", USBPORT_FDOFLAG_THREAD_INIT

    };     
                    
    FLAG_TABLE mpStateFlags[] = {
        "MP_STATE_STARTED", MP_STATE_STARTED,
        "MP_STATE_SUSPENDED", MP_STATE_SUSPENDED
         };
        
    
    dprintf ("\n");
    PrintfMemLoc("**USBPORT FDO_EXTENSION ", ExtMemLoc, "\n");

    PrintfMemLoc("WorkerThreadHandle: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "WorkerThreadHandle"), 
            "\n");  
            
    PrintfMemLoc("WorkerPkThread: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "WorkerPkThread"), 
            "\n");  

    PrintfMemLoc("HcPendingWakeIrp: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "HcPendingWakeIrp"), 
            "\n");            
   
    PrintfMemLoc("PhysicalDeviceObject: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "PhysicalDeviceObject"), 
            "\n");
            
    PrintfMemLoc("TopOfStackDeviceObject: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "TopOfStackDeviceObject"), 
            "\n");

    PrintfMemLoc("RootHubPdo: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "RootHubPdo"), 
            "\n");

    dprintf ("DM_TimerInterval: %d\n", 
                UsbReadFieldUlong(ExtMemLoc, cs, "DM_TimerInterval")
            );                
    dprintf ("DeviceNameIdx: %d\n", 
                UsbReadFieldUlong(ExtMemLoc, cs, "DeviceNameIdx")
            );
    dprintf ("TotalBusBandwidth: %d\n", 
                UsbReadFieldUlong(ExtMemLoc, cs, "TotalBusBandwidth")
            );                

    dprintf ("Bandwidth Table[]\n");


    {
    ULONG64 addr;
    ULONG cb;

    addr = ExtMemLoc + UsbFieldOffset(cs, 
            "BandwidthTable[0]");
            
    ReadMemory(addr,
               &bandwidthTable,
               (ULONG)sizeof(bandwidthTable),
               &cb);
    }               

    for (i=0; i< USBPORT_MAX_INTEP_POLLING_INTERVAL/4; i++) {
        dprintf ("[%02.2d] - %8d [%02.2d] - %8d [%02.2d] - %8d [%02.2d] - %8d\n",  
            i*4, bandwidthTable[i*4],
            i*4+1, bandwidthTable[i*4+1],
            i*4+2, bandwidthTable[i*4+2],
            i*4+3, bandwidthTable[i*4+3]);
    }

    dprintf ("AllocedInterruptBW 1,2,4,8,16,32 ms\n");
    for (i=0; i<6; i++) {
        UCHAR s[80];
        sprintf(s, "AllocedInterruptBW[%d]", i);
        dprintf ("bits/sec %d \n",  
            UsbReadFieldUlong(ExtMemLoc, cs, s)
            );
    }            
        
    dprintf ("AllocedIsoBW %d \n", 
        UsbReadFieldUlong(ExtMemLoc, cs, "AllocedIsoBW")
        );        

    // stats

    dprintf ("StatBulkBytes %d \n", 
        UsbReadFieldUlong(ExtMemLoc, cs, "StatBulkBytes")
        );        

    dprintf ("StatIsoBytes %d \n", 
        UsbReadFieldUlong(ExtMemLoc, cs, "StatIsoBytes")
        );        

    dprintf ("StatInterruptBytes %d \n", 
        UsbReadFieldUlong(ExtMemLoc, cs, "StatInterruptBytes")
        );        

    dprintf ("StatControlDataBytes %d \n", 
        UsbReadFieldUlong(ExtMemLoc, cs, "StatControlDataBytes")
        );
        
    PrintfMemLoc("***Miniport Extension: ", 
            ExtMemLoc + UsbFieldOffset(cs, "MiniportExtension"), 
            "\n");            

    f = UsbReadFieldUlong(ExtMemLoc, cs, "FdoFlags"),
    dprintf ("FdoFlags %08.8x\n", f);
    UsbDumpFlags(f, fdoFlags, 
        sizeof(fdoFlags)/sizeof(FLAG_TABLE));

    f = UsbReadFieldUlong(ExtMemLoc, cs, "MpStateFlags"),
    dprintf ("MpStateFlags %08.8x\n", f);
    UsbDumpFlags(f, mpStateFlags, 
        sizeof(mpStateFlags)/sizeof(FLAG_TABLE));

    dprintf ("DmaBusy %d\n", 
        UsbReadFieldUlong(ExtMemLoc, cs, "DmaBusy")
        );
    dprintf ("WorkerDpc %d\n", 
        UsbReadFieldUlong(ExtMemLoc, cs, "WorkerDpc")
        );        
        
    dprintf ("PciVendorId: %04.4x PciDeviceId: %04.4x Rev %02.2x\n", 
        UsbReadFieldUshort(ExtMemLoc, cs, "PciVendorId"),
        UsbReadFieldUshort(ExtMemLoc, cs, "PciDeviceId"),
        UsbReadFieldUshort(ExtMemLoc, cs, "PciRevisionId")
        );

    f = UsbReadFieldUlong(ExtMemLoc, cs, "HcFlavor"),
    dprintf ("ControllerFlavor: %d ", f);
    
    switch(f) {
    case USB_HcGeneric: 
        dprintf ("USB_HcGeneric\n");
        break;
    case OHCI_Generic: 
        dprintf ("OHCI_Generic\n");
        break;
    case OHCI_Hydra: 
        dprintf ("OHCI_Hydra\n");
        break;
    case OHCI_NEC: 
        dprintf ("OHCI_NEC\n");
        break;
    case UHCI_Generic: 
        dprintf ("UHCI_Generic\n");
        break;        
    case UHCI_Piix4: 
        dprintf ("UHCI_Piix4\n");
        break;                   
    case EHCI_Generic: 
        dprintf ("EHCI_Generic\n");
        break;          
    default:        
        dprintf ("???\n");        
    }

    dprintf ("-Driver Lists-\n");
    //GETMEMLOC(x, MemLoc, DEVICE_EXTENSION, Fdo.DeviceHandleList);

    l = ExtMemLoc + UsbFieldOffset(cs, "DeviceHandleList");
    PrintfMemLoc("(DH) DeviceHandleList: ", 
            l, 
            ListEmpty(l));            

    l = ExtMemLoc + UsbFieldOffset(cs, "MapTransferList");
    PrintfMemLoc("(MT) MapTransferList: ", 
            l, 
            ListEmpty(l));               

    l = ExtMemLoc + UsbFieldOffset(cs, "DoneTransferList");
    PrintfMemLoc("(DT) DoneTransferList: ", 
            l, 
            ListEmpty(l));  

    l = ExtMemLoc + UsbFieldOffset(cs, "EpStateChangeList");
    PrintfMemLoc("(SC) EpStateChangeList: ", 
            l, 
            ListEmpty(l));              

    l = ExtMemLoc + UsbFieldOffset(cs, "GlobalEndpointList");
    PrintfMemLoc("(GL) GlobalEndpointList: ", 
            l, 
            ListEmpty(l));           

    l = ExtMemLoc + UsbFieldOffset(cs, "AttendEndpointList");
    PrintfMemLoc("(AT) AttendEndpointList: ", 
            l, 
            ListEmpty(l));    

    l = ExtMemLoc + UsbFieldOffset(cs, "EpClosedList");
    PrintfMemLoc("(XL) EpClosedList: ", 
            l, 
            ListEmpty(l));              
}


VOID
DumpPortPdoDevExt(
    MEMLOC ExtMemLoc
    )
{
    UCHAR cs[] = "usbport!_PDO_EXTENSION";
    
    dprintf ("\n");
    PrintfMemLoc("**USBPORT PDO_EXTENSION ", ExtMemLoc, "\n");

    
    PrintfMemLoc("RootHubInterruptEndpoint: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "RootHubInterruptEndpoint"), 
            "\n");

    dprintf ("ConfigurationValue: %d\n", 
                UsbReadFieldUchar(ExtMemLoc, cs, "Flags"));
        
    PrintfMemLoc("DeviceDescriptor: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "DeviceDescriptor"), 
            "\n");
    
    PrintfMemLoc("ConfigurationDescriptor: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "ConfigurationDescriptor"), 
            "\n");
    
    PrintfMemLoc("HubDescriptor: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "HubDescriptor"), 
            "\n");
            
    PrintfMemLoc("PendingWaitWakeIrp: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "PendingWaitWakeIrp"), 
            "\n");         
            
    PrintfMemLoc("PendingIdleNotificationIrp: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "PendingIdleNotificationIrp"), 
            "\n");             

    PrintfMemLoc("Descriptors: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "Descriptors"), 
            "\n");     
            
}


VOID
DumpPowerCaps(
    MEMLOC MemLoc
    )
{
    SYSTEM_POWER_STATE s;
    DEVICE_CAPABILITIES devCaps;
    ULONG cb;

    PrintfMemLoc(">Power Capabilities @ ", 
                  MemLoc,
                 "\n");
                  
    ReadMemory(MemLoc,
               &devCaps,
               sizeof(devCaps),
               &cb);
    

    dprintf ("\tSystemWake = %s\n", 
        S_State(devCaps.SystemWake));

    dprintf ("\tDeviceWake = %s\n", 
        D_State(devCaps.DeviceWake));

    dprintf ("\t<System Power State Map>\n"); 
    for (s=PowerSystemUnspecified; s< PowerSystemMaximum; s++) {
        dprintf ("\t%s =  %s\n", 
            S_State(s), D_State(devCaps.DeviceState[s]));
    }
}


VOID
DumpFdoPower(
    MEMLOC MemLoc
    )
{
    MEMLOC ExtMemLoc;
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG pa, st, d, i;
    UCHAR s[64];
    UCHAR csFdo[] = "usbport!_FDO_EXTENSION";

    PrintfMemLoc("*POWER SUMMARY fdo ", 
                  MemLoc,
                 "\n");

    // dump the hc power caps
    dprintf ("HC Power Capabilities\n");
    DumpPowerCaps(MemLoc + UsbFieldOffset(cs, "DeviceCapabilities"));  

    ExtMemLoc = MemLoc + UsbFieldOffset(cs, "Fdo");
    // dump power attributes
    dprintf ("HC Power Attributes\n");
    for (i=0; i< USBPORT_MAPPED_SLEEP_STATES; i++) {

        sprintf(s, "HcPowerStateTbl.PowerState[0].SystemState", i);
        st = UsbReadFieldUlong(ExtMemLoc, csFdo, s);
        sprintf(s, "HcPowerStateTbl.PowerState[0].DeviceState", i);
        d = UsbReadFieldUlong(ExtMemLoc, csFdo, s);
        sprintf(s, "HcPowerStateTbl.PowerState[0].Attributes", i);
        pa = UsbReadFieldUlong(ExtMemLoc, csFdo, s); 
        
        dprintf("[%d] %s - %s  %s\n", 
            i,
            S_State(st),
            D_State(d),
            PwrAttributes(pa));
        ExtMemLoc+=sizeof(HC_POWER_STATE);            
    }

    
}


VOID
DumpFdoSpin(
    MEMLOC MemLoc
    )
{
    MEMLOC ExtMemLoc;
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG pa, st, d, i;
    UCHAR s[64];
    UCHAR csFdo[] = "usbport!_FDO_EXTENSION";

    PrintfMemLoc("*SPINLOCK SUMMARY fdo ", 
                  MemLoc,
                 "\n");

    ExtMemLoc = MemLoc + UsbFieldOffset(cs, "Fdo");

    PrintfMemLoc("CoreFunctionSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "CoreFunctionSpin"),
                 "\n");
    PrintfMemLoc("MapTransferSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "MapTransferSpin"),
                 "\n");
    PrintfMemLoc("DoneTransferSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "DoneTransferSpin"),
                 "\n");
    PrintfMemLoc("EndpointListSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "EndpointListSpin"),
                 "\n");
    PrintfMemLoc("EpStateChangeListSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "EpStateChangeListSpin"),
                 "\n");
    PrintfMemLoc("DevHandleListSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "DevHandleListSpin"),
                 "\n");                 
    PrintfMemLoc("EpClosedListSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "EpClosedListSpin"),
                 "\n");
    PrintfMemLoc("PendingTransferIrpSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "PendingTransferIrpSpin"),
                 "\n");
    PrintfMemLoc("ActiveTransferIrpSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "ActiveTransferIrpSpin"),
                 "\n");
    PrintfMemLoc("WorkerThreadSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "WorkerThreadSpin"),
                 "\n");               
    PrintfMemLoc("DM_TimerSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "DM_TimerSpin"),
                 "\n");                 
    PrintfMemLoc("WakeIrpSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "WakeIrpSpin"),
                 "\n");
    PrintfMemLoc("HcPendingWakeIrpSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "HcPendingWakeIrpSpin"),
                 "\n");
    PrintfMemLoc("IdleIrpSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "IdleIrpSpin"),
                 "\n");
    PrintfMemLoc("IsrDpcSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "IsrDpcSpin"),
                 "\n");                       
    PrintfMemLoc("StatCounterSpin - ", 
                  ExtMemLoc + UsbFieldOffset(csFdo, "StatCounterSpin"),
                 "\n");                   
}


VOID
DumpBandwidth(
    MEMLOC MemLoc
    )
{
    MEMLOC ExtMemLoc;
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG pa, st, d, i;
    UCHAR s[64];
    UCHAR csFdo[] = "usbport!_FDO_EXTENSION";
    ULONG bandwidthTable[USBPORT_MAX_INTEP_POLLING_INTERVAL];

    PrintfMemLoc("*BANDWIDTH SUMMARY fdo_ext ", 
                  MemLoc,
                 "\n");

    ExtMemLoc = MemLoc + UsbFieldOffset(cs, "Fdo");

    dprintf ("TotalBusBandwidth (bits/sec): %d\n", 
                UsbReadFieldUlong(ExtMemLoc, csFdo, "TotalBusBandwidth")
            );                


    // dump the 32 node bandwidth table
    
    {
    ULONG64 addr;
    ULONG cb;

    addr = ExtMemLoc + UsbFieldOffset(csFdo, 
            "BandwidthTable[0]");
            
    ReadMemory(addr,
               &bandwidthTable,
               (ULONG)sizeof(bandwidthTable),
               &cb);
    }               

    for (i=0; i< USBPORT_MAX_INTEP_POLLING_INTERVAL/4; i++) {
        dprintf ("[%02.2d] - %8d [%02.2d] - %8d [%02.2d] - %8d [%02.2d] - %8d\n",  
            i*4, bandwidthTable[i*4],
            i*4+1, bandwidthTable[i*4+1],
            i*4+2, bandwidthTable[i*4+2],
            i*4+3, bandwidthTable[i*4+3]);
    }

    dprintf ("AllocedInterruptBW, period 1,2,4,8,16,32 ms\n");
    for (i=0; i<6; i++) {
        UCHAR s[80];
        sprintf(s, "AllocedInterruptBW[%d]", i);
        dprintf ("bits/sec %d \n",  
            UsbReadFieldUlong(ExtMemLoc, csFdo, s)
            );
    }            
        
    dprintf ("AllocedIsoBW %d \n", 
        UsbReadFieldUlong(ExtMemLoc, csFdo, "AllocedIsoBW")
        );        

    {
    ULONG m, t;
    t =  UsbReadFieldUlong(ExtMemLoc, csFdo, "TotalBusBandwidth");       
    m =  UsbReadFieldUlong(ExtMemLoc, csFdo, "MaxAllocedBw");         
    dprintf ("MaxAllocedBw %d %% (%d)\n", m, (m*100/t));
    m =  UsbReadFieldUlong(ExtMemLoc, csFdo, "MinAllocedBw");         
    dprintf ("MinAllocedBw %d %% (%d)\n", m, (m*100/t));
    }        
        
}


#if 0
VOID
DumpCaps(
    PDEVICE_CAPABILITIES DevCaps
    )
{
    dprintf ("USBPORT PDO Extension\n");

    dprintf("DeviceCapabilities: \n");
    dprintf(">Size %d Version %d\n", devCaps.Size, devCaps.Version);    
    dprintf(">Address %08.8x UINumber %08.8x\n", devCaps.Address, devCaps.UINumber);  

    dprintf(">DeviceD1: "); 
    if (devCaps.DeviceD1) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">DeviceD2: ");
    if (devCaps.DeviceD2) {
    dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">LockSupported: ");
    if (devCaps.LockSupported) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">EjectSupported: ");
    if (devCaps.EjectSupported) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">Removable: ");
    if (devCaps.Removable) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">DockDevice: ");
    if (devCaps.DockDevice) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">UniqueID: ");
    if (devCaps.UniqueID) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">SilentInstall: ");
    if (devCaps.SilentInstall) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">RawDeviceOK: ");
    if (devCaps.RawDeviceOK) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">SurpriseRemovalOK: ");
    if (devCaps.SurpriseRemovalOK) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">WakeFromD0: ");
    if (devCaps.WakeFromD0) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">WakeFromD1: ");
    if (devCaps.WakeFromD1) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">WakeFromD2: ");
    if (devCaps.WakeFromD2) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">WakeFromD3: ");
    if (devCaps.WakeFromD3) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">HardwareDisabled: ");
    if (devCaps.HardwareDisabled) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">NonDynamic: ");
    if (devCaps.NonDynamic) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }
    dprintf(">WarmEjectSupported: ");
    if (devCaps.WarmEjectSupported) {
        dprintf(" yes\n");    
    } else {
        dprintf(" no\n");  
    }

    //BUGBUG
    //DEVICE_POWER_STATE DeviceState[PowerSystemMaximum];
    //SYSTEM_POWER_STATE SystemWake;
    //DEVICE_POWER_STATE DeviceWake;
    dprintf(">D1Latency: %d\n", devCaps.D1Latency);
    dprintf(">D2Latency: %d\n", devCaps.D2Latency);
    dprintf(">D3Latency: %d\n", devCaps.D3Latency);
}
#endif


VOID
DumpPortDevExt(
    MEMLOC ExtMemLoc
    )
{
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG sig, f;
    DEVICE_POWER_STATE dps;
  
    FLAG_TABLE flags[] = {
        "USBPORT_FLAG_SYM_LINK", USBPORT_FLAG_SYM_LINK
        };        
    FLAG_TABLE pnpFlags[] = {
        "USBPORT_PNP_STOPPED", USBPORT_PNP_STOPPED,
        "USBPORT_PNP_STARTED", USBPORT_PNP_STARTED,
        "USBPORT_PNP_REMOVED", USBPORT_PNP_REMOVED,
        "USBPORT_PNP_START_FAILED", USBPORT_PNP_START_FAILED
        };        

    PrintfMemLoc("*USBPORT DEVICE_EXTENSION ", ExtMemLoc, "\n");

    PrintfMemLoc("DummyUsbdExtension: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "DummyUsbdExtension"), 
            "\n");

    sig = UsbReadFieldUlong(ExtMemLoc, cs, "Sig");
    
    if (sig != USBPORT_DEVICE_EXT_SIG && 
        sig != ROOTHUB_DEVICE_EXT_SIG) {
        dprintf("Not a USBPORT Extension\n");
        return;        
    }   
    
    Sig(sig, "");      

    PrintfMemLoc("HcFdoDeviceObject: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "HcFdoDeviceObject"), 
            "\n");
            
    PrintfMemLoc("LogPtr: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "Log.LogPtr"), 
            "");            
    PrintfMemLoc("LogStart: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "Log.LogStart"), 
            ""); 
    PrintfMemLoc("LogEnd: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "Log.LogEnd"), 
            "\n");             

    PrintfMemLoc("PendingRequestCount: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "PendingRequestCount"), 
            "\n");

    PrintfMemLoc("TrackIrpList.Flink: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "TrackIrpList.Flink"), 
            "\n");
    PrintfMemLoc("TrackIrpList.Blink: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "TrackIrpList.Blink"), 
            "\n");            
            
    PrintfMemLoc("PendingTransferIrpTable: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "PendingTransferIrpTable"), 
            "\n");
    PrintfMemLoc("ActiveTransferIrpTable: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "ActiveTransferIrpTable"), 
            "\n");            

    f = UsbReadFieldUlong(ExtMemLoc, cs, "Flags");
    dprintf("Flags: %08.8x\n", f);
    UsbDumpFlags(f, flags, 
        sizeof(flags)/sizeof(FLAG_TABLE));

    f = UsbReadFieldUlong(ExtMemLoc, cs, "PnpStateFlags");
    dprintf("PnpStateFlags: %08.8x\n", f);
    UsbDumpFlags(f, pnpFlags, 
        sizeof(pnpFlags)/sizeof(FLAG_TABLE));

    dprintf("----------------\n");
    PrintfMemLoc("SystemPowerIrp: ", 
            UsbReadFieldPtr(ExtMemLoc, cs, "SystemPowerIrp"), 
            "\n");
    dprintf("CurrentDevicePowerState: ");

    dps = (DEVICE_POWER_STATE) UsbReadFieldUlong(ExtMemLoc, cs, 
                                "CurrentDevicePowerState");
    switch (dps) {
    case PowerDeviceUnspecified:
        dprintf("PowerDeviceUnspecified\n");
        break;
    case PowerDeviceD0:
        dprintf("PowerDeviceD0\n");
        break;
    case PowerDeviceD1:
        dprintf("PowerDeviceD1\n");
        break;
    case PowerDeviceD2:
        dprintf("PowerDeviceD2\n");
        break;
    case PowerDeviceD3:
        dprintf("PowerDeviceD3\n");
        break;
    default:
        dprintf("???\n");     
    }     

    dprintf ("Power Capabilities\n");
    DumpPowerCaps(ExtMemLoc + UsbFieldOffset(cs, "DeviceCapabilities"));  

    dprintf("----------------\n");            
    
//    dprintf("SymbolicLinkName:\n");
//    DumpUnicodeString(devExt.SymbolicLinkName); 
    if (sig == USBPORT_DEVICE_EXT_SIG) {
        ExtMemLoc = ExtMemLoc + UsbFieldOffset(cs, "Fdo");
        DumpPortFdoDevExt(ExtMemLoc);
    }
    
    if (sig == ROOTHUB_DEVICE_EXT_SIG) {
        ExtMemLoc = ExtMemLoc + UsbFieldOffset(cs, "Pdo");
        DumpPortPdoDevExt(ExtMemLoc);
    }    
    
}


VOID
DumpMiniportList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC mpMemLoc;
    ULONG i=0;
    UCHAR cs[] = "_USBPORT_MINIPORT_DRIVER";
    
    dprintf ("*USBPORT DRIVER LIST: ");
    PrintfMemLoc("", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    PrintfMemLoc("blink: ", blink, "\n");
    PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc && i < 5) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        mpMemLoc = flink - UsbFieldOffset("_USBPORT_MINIPORT_DRIVER", 
            "ListEntry");

        dprintf ("[%d] MiniportDriver: ", i);
        PrintfMemLoc("", mpMemLoc, "\n");
        i++;

        PrintfMemLoc("\tDriverObject: ", 
            UsbReadFieldPtr(mpMemLoc, cs, "DriverObject"), 
            "\n");
        PrintfMemLoc("\tMiniportUnload: ", 
            UsbReadFieldPtr(mpMemLoc, cs, "MiniportUnload"), 
            "\n");

        flink = UsbReadFieldPtr(mpMemLoc, cs, "ListEntry.Flink");

                                        
    }
}


VOID
DumpIrps(
    MEMLOC ExtMemLoc
    )
{
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    UCHAR is[] = "_USBPORT_IRP_TABLE";
    MEMLOC nxt, tbl;
    ULONG i;
    UCHAR s[64];
    
    PrintfMemLoc("*USBPORT DEVICE_EXTENSION ", ExtMemLoc, "\n");
    
    tbl = UsbReadFieldPtr(ExtMemLoc, cs, "PendingTransferIrpTable");
    
    PrintfMemLoc("Pending TABLE @", tbl, "\n");
    nxt = UsbReadFieldPtr(tbl, is, "NextTable"), 
    PrintfMemLoc("NextTable: ", nxt, "\n");
    for (i= 0; i<IRP_TABLE_LENGTH; i++) {
        MEMLOC irp;
        sprintf(s, "Irps[%d]", i);
        irp = UsbReadFieldPtr(tbl, is, s);
        if (irp != 0) {
            PrintfMemLoc("irp: ", 
                         irp,
                         "\n");
        }                         
    }

    tbl = UsbReadFieldPtr(ExtMemLoc, cs, "ActiveTransferIrpTable");
    
    PrintfMemLoc("Active TABLE @", tbl, "\n");
    nxt = UsbReadFieldPtr(tbl, is, "NextTable"), 
    PrintfMemLoc("NextTable: ", nxt, "\n");
    for (i= 0; i<IRP_TABLE_LENGTH; i++) {
        MEMLOC irp;
        sprintf(s, "Irps[%d]", i);
        irp = UsbReadFieldPtr(tbl, is, s);
        if (irp != 0) {
            PrintfMemLoc("irp: ", 
                         irp,
                         "\n");
        }                         
    }
}


DECLARE_API( _ext )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;

    CHECKSYM();

    addr = GetExpression( args );
    
    DumpPortDevExt (addr);

    return S_OK; 
}


DECLARE_API( _usbirps )

/*++

Routine Description:

   dumps the irps from our active and pending 
   tables

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;

    CHECKSYM();

    addr = GetExpression( args );
    
    DumpIrps (addr);

    return S_OK; 
}


DECLARE_API( _help )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{

    // usbport extensions
    dprintf("usbport extensions\n");
    dprintf("!_ext [addr] - addr = DEVICE_EXTENSION\n");
    dprintf("!_pow [addr_PDO addr_FDO] - addr = DEVICE_EXTENSION\n");
    
    dprintf("!_list [n], [type]\n");
    
    dprintf("!_devh [addr]\n");
    dprintf("!_log [addr], [count] - addr = DEVICE_EXTENSION\n");
    dprintf("                        count = entries to dump \n");
   
    dprintf("!_urb [addr]\n");
    dprintf("!_endp [addr]\n");
    dprintf("!_cmbf [addr]\n");
    dprintf("!_tfer [addr] - dumps HCD_TRANSFER_CONTEXT for usbport\n");
    dprintf("---\n");
    
    // usbohci miniport extensions
    dprintf("usbohci miniport extensions \n");
    dprintf("!_ohcidd [addr] - addr = DEVICE_DATA\n");
    dprintf("!_ohcitd [addr] - addr = HCD_TRANSFER_DESCRIPTOR\n");
    dprintf("!_ohcied [addr] - addr = HCD_ENDPOINT_DESCRIPTOR\n");
    dprintf("!_ohciep [addr] - addr = ENDPOINT_DATA\n");
    dprintf("!_ohcitfer [addr] - addr = TRANSFER_CONTEXT\n");
    dprintf("!_ohciregs [addr] - addr = OHCI Opertation Registers\n");
    dprintf("---\n");
     
    // usbehci miniport extensions
    dprintf("usbehci miniport extensions \n");
    dprintf("!_ehcidd [addr] - addr = DEVICE_DATA\n");
    dprintf("!_ehcitd [addr] - addr = HCD_TRANSFER_DESCRIPTOR\n");
    dprintf("!_ehciqh [addr] - addr = HCD_QUEUEHEAD_DESCRIPTOR\n");
    dprintf("!_ehciep [addr] - addr = ENDPOINT_DATA\n");
    dprintf("!_ehciregs [addr] - addr = EHCI Opertation Registers\n");
    dprintf("---\n");        
    
    dprintf("!_help - displays this screen\n");

    return S_OK; 
}


DECLARE_API( _pow )

/*++

Routine Description:

   dumps a summary of the power info

   pow fdo_ext

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;

    CHECKSYM();

    addr = GetExpression( args );
    
    DumpFdoPower (addr);

    return S_OK; 

}


DECLARE_API( _usbport )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - 
    
Return Value:

    None

--*/

{
    MEMLOC          addr;

//    memLoc = GetExpression(args);    
    
    // fetch the list head
    addr = GetExpression( "usbport!USBPORT_MiniportDriverList" );
    
    if (addr == 0) {
       dprintf("Error retrieving address of USBPORT_MiniportDriverList\n");
       return E_INVALIDARG;
    }
    
    DumpMiniportList(addr);
    
    return S_OK; 
}


DECLARE_API( _spin )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - 
    
Return Value:

    None

--*/

{
    MEMLOC          addr;

    CHECKSYM();

    addr = GetExpression( args );
    
    DumpFdoSpin (addr);

    return S_OK; 
}


DECLARE_API( _bw )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - 
    
Return Value:

    None

--*/

{
    MEMLOC          addr;

    CHECKSYM();

    addr = GetExpression( args );
    
    DumpBandwidth (addr);

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/
#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status;

// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

#define EXIT_API     ExtRelease

extern WINDBG_EXTENSION_APIS ExtensionApis;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\log.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    log.c

Abstract:

    WinDbg Extension Api
    implements !_log

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#include "usbhcdkd.h"

VOID    
DumpXferLog(
    MEMLOC LogMemLoc,
    MEMLOC StartMemLoc,
    MEMLOC EndMemLoc, 
    ULONG NumEntriesToDump
    )
{
    ULONG i;
    LOG_ENTRY logEntry1, logEntry2;
    ULONG cb;
    MEMLOC m1, m2, m3;
    ENDPOINT_TRANSFER_TYPE t;
    PUCHAR s;
    
    PrintfMemLoc("*TRANSFER LOGSTART: ", LogMemLoc, " ");
    dprintf("# %d \n", NumEntriesToDump);
    
    for (i=0; i< NumEntriesToDump; i++) {

        ReadMemory(LogMemLoc,
           &logEntry2,
           sizeof(logEntry2),
           &cb);
           
        LogMemLoc+=cb;            

        if (LogMemLoc > EndMemLoc) {
            LogMemLoc = StartMemLoc;
        }           

        ReadMemory(LogMemLoc,
           &logEntry1,
           sizeof(logEntry1),
           &cb);
           
        LogMemLoc+=cb;            

        if (LogMemLoc > EndMemLoc) {
            LogMemLoc = StartMemLoc;
        }        
#if 0
        t = (ENDPOINT_TRANSFER_TYPE) logEntry.TransferType;
        switch(logEntry.TransferType) {
        case Isochronous:
            s = "ISO";
            break;
        case Control:
            s = "CON";
            break;
        case Bulk:
            s = "BLK";
            break;
        case Interrupt:
            s = "INT";
            break;
        default:            
            s = "???";
        }   
#endif
        
        dprintf("[%3.3d] Endpoint(%08.8x) - URB:%08.8x IRP:%8.8x\n", 
                 i,
                 logEntry1.le_info1,
                 logEntry1.le_info2,
                 logEntry1.le_info3);
        dprintf("        \t\t\t Bytes [%6.6d]  NT_STATUS %08.8x USBD_STATUS %08.8x\n", 
                 logEntry2.le_info3,
                 logEntry2.le_info2,
                 logEntry2.le_info1);   

    }

}


VOID    
DumpLog(
    MEMLOC LogMemLoc,
    MEMLOC StartMemLoc,
    MEMLOC EndMemLoc, 
    ULONG NumEntriesToDump,
    ULONG MarkSig1,
    ULONG MarkSig2
    )
{
    ULONG i;
    SIG s;
    LOG_ENTRY64 logEntry64;
    LOG_ENTRY32 logEntry32;
    CHAR c;
    ULONG cb;
    MEMLOC m1, m2, m3;

    PrintfMemLoc("*LOG: ", LogMemLoc, " ");
    PrintfMemLoc("*LOGSTART: ", StartMemLoc, " ");
    PrintfMemLoc("*LOGEND: ", EndMemLoc, " ");
    dprintf("# %d \n", NumEntriesToDump);
#if 0    
    s.l = MarkSig1;
    dprintf("*(%c%c%c%c) ",  
        s.c[0],  s.c[1],  s.c[2], s.c[3]);
    s.l = MarkSig2;    
    dprintf("*(%c%c%c%c) ",  
        s.c[0],  s.c[1],  s.c[2], s.c[3]);
    dprintf("\n");    
#endif
    for (i=0; i< NumEntriesToDump; i++) {

        if (IsPtr64()) { 
            ReadMemory(LogMemLoc,
               &logEntry64,
               sizeof(logEntry64),
               &cb);
  
            s.l = logEntry64.le_sig;

            m1 = logEntry64.le_info1;                
            m2 = logEntry64.le_info2;  
            m3 = logEntry64.le_info3; 
            
        } else {
            ReadMemory(LogMemLoc,
               &logEntry32,
               sizeof(logEntry32),
               &cb);

            s.l = logEntry32.le_sig;

            m1 = logEntry32.le_info1;                
            m2 = logEntry32.le_info2;  
            m3 = logEntry32.le_info3;  
        }

        if (s.l == MarkSig1 || s.l == MarkSig2) {
            c = '*';
        } else {
            c = ' ';
        }

        dprintf("%c[%3.3d]", c, i); 
        PrintfMemLoc(" ", LogMemLoc, " ");
        
        dprintf("%c%c%c%c ", s.c[0],  s.c[1],  s.c[2], s.c[3]);
       
        PrintfMemLoc(" ", m1, " ");
        PrintfMemLoc(" ", m2, " ");
        PrintfMemLoc(" ", m3, "\n");
        
        LogMemLoc+=cb;            

        if (LogMemLoc > EndMemLoc) {
            LogMemLoc = StartMemLoc;
        }
    }

}


DECLARE_API( _eplog )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    UCHAR           buffer1[256];
    UCHAR           buffer2[256];
    UCHAR           buffer3[256];
    SIG s1, s2;
    ULONG len = 5;
    MEMLOC logPtr, logStart, logEnd;
    UCHAR cs[] = "_HCD_ENDPOINT";
   
    
    buffer1[0] = '\0';
    buffer2[0] = '\0';
    buffer3[0] = '\0';

    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("LOG@: ", addr, "\n");
    sscanf(s, ",%s %s %s", &buffer1, &buffer2, &buffer3);

    if ('\0' != buffer1[0]) {
        sscanf(buffer1, "%d", &len);
    }

    s1.l = 0;
    if ('\0' != buffer2[0]) {
//        sscanf(buffer2, "%d", &len);
        s1.c[0] = buffer2[0];
        s1.c[1] = buffer2[1];
        s1.c[2] = buffer2[2];
        s1.c[3] = buffer2[3];
    }

    s2.l = 0;
    if ('\0' != buffer3[0]) {
//        sscanf(buffer2, "%d", &len);
        s2.c[0] = buffer3[0];
        s2.c[1] = buffer3[1];
        s2.c[2] = buffer3[2];
        s2.c[3] = buffer3[3];
    }

    logPtr = UsbReadFieldPtr(addr, cs, "Log.LogPtr");
    logStart = UsbReadFieldPtr(addr, cs, "Log.LogStart");
    logEnd = UsbReadFieldPtr(addr, cs, "Log.LogEnd");

    DumpLog (logPtr,
             logStart,
             logEnd,
             len,
             s1.l,
             s2.l);

    return S_OK;             
}




DECLARE_API( _log )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    UCHAR           buffer1[256];
    UCHAR           buffer2[256];
    UCHAR           buffer3[256];
    SIG s1, s2;
    ULONG len = 5;
    MEMLOC logPtr, logStart, logEnd;
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG logIdx, m, i;
    
    buffer1[0] = '\0';
    buffer2[0] = '\0';
    buffer3[0] = '\0';

    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("LOG@: ", addr, "\n");
    sscanf(s, ",%s %s %s", &buffer1, &buffer2, &buffer3);

    if ('\0' != buffer1[0]) {
        sscanf(buffer1, "%d", &len);
    }

    s1.l = 0;
    if ('\0' != buffer2[0]) {
//        sscanf(buffer2, "%d", &len);
        s1.c[0] = buffer2[0];
        s1.c[1] = buffer2[1];
        s1.c[2] = buffer2[2];
        s1.c[3] = buffer2[3];
    }

    s2.l = 0;
    if ('\0' != buffer3[0]) {
//        sscanf(buffer2, "%d", &len);
        s2.c[0] = buffer3[0];
        s2.c[1] = buffer3[1];
        s2.c[2] = buffer3[2];
        s2.c[3] = buffer3[3];
    }

    logPtr = UsbReadFieldPtr(addr, cs, "Log.LogStart");
    logStart = UsbReadFieldPtr(addr, cs, "Log.LogStart");
    logEnd = UsbReadFieldPtr(addr, cs, "Log.LogEnd");
    logIdx = UsbReadFieldUlong(addr, cs, "Log.LogIdx");
    m = UsbReadFieldUlong(addr, cs, "Log.LogSizeMask");
    i = logIdx & m;
    
    dprintf(">LOG mask = %x idx = %x (%x)\n", m, logIdx, i );
    logPtr += (i*16);
    
    DumpLog (logPtr,
             logStart,
             logEnd,
             len,
             s1.l,
             s2.l);

    return S_OK;             
}


DECLARE_API( _xlog )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    ULONG len = 5;
    UCHAR buffer1[256];
    MEMLOC logPtr, logStart, logEnd;
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
   
    
    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("LOG@: ", addr, "\n");
    sscanf(s, ",%s ", &buffer1);

    if ('\0' != buffer1[0]) {
        sscanf(buffer1, "%d", &len);
    }

    logPtr = UsbReadFieldPtr(addr, cs, "TransferLog.LogStart");
    logStart = UsbReadFieldPtr(addr, cs, "TransferLog.LogStart");
    logEnd = UsbReadFieldPtr(addr, cs, "TransferLog.LogEnd");

    DumpXferLog (logPtr,
                 logStart,
                 logEnd,
                 len);

    return S_OK;             
}


DECLARE_API( _isolog )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    UCHAR           buffer1[256];
    UCHAR           buffer2[256];
    UCHAR           buffer3[256];
    SIG s1, s2;
    ULONG len = 5;
    MEMLOC logPtr, logStart, logEnd;
    UCHAR cs[] = "_HCD_ENDPOINT";
   
    
    buffer1[0] = '\0';
    buffer2[0] = '\0';
    buffer3[0] = '\0';

    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("LOG@: ", addr, "\n");
    sscanf(s, ",%s %s %s", &buffer1, &buffer2, &buffer3);

    if ('\0' != buffer1[0]) {
        sscanf(buffer1, "%d", &len);
    }

    s1.l = 0;
    if ('\0' != buffer2[0]) {
//        sscanf(buffer2, "%d", &len);
        s1.c[0] = buffer2[0];
        s1.c[1] = buffer2[1];
        s1.c[2] = buffer2[2];
        s1.c[3] = buffer2[3];
    }

    s2.l = 0;
    if ('\0' != buffer3[0]) {
//        sscanf(buffer2, "%d", &len);
        s2.c[0] = buffer3[0];
        s2.c[1] = buffer3[1];
        s2.c[2] = buffer3[2];
        s2.c[3] = buffer3[3];
    }

    logPtr = UsbReadFieldPtr(addr, cs, "IsoLog.LogPtr");
    logStart = UsbReadFieldPtr(addr, cs, "IsoLog.LogStart");
    logEnd = UsbReadFieldPtr(addr, cs, "IsoLog.LogEnd");

    DumpLog (logPtr,
             logStart,
             logEnd,
             len,
             s1.l,
             s2.l);

    return S_OK;             
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\kdext.c ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Stephane Plante (splante)
    jdunn, adapted to USB2

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

#ifdef USB_KD64
DBGKD_GET_VERSION64     KernelVersionPacket;
#else 
DBGKD_GET_VERSION32     KernelVersionPacket;
#endif

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    return;
}


VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ( (SavedMajorVersion != 0x0c) ||
         (SavedMinorVersion != VER_PRODUCTBUILD) ) {

        dprintf(
            "\r\n*** Extension DLL(%d Checked) does not match target "
            "system(%d %s)\r\n\r\n",
            VER_PRODUCTBUILD,
            SavedMinorVersion,
            (SavedMajorVersion==0x0f) ? "Free" : "Checked"
            );

    }
#else
    if ( (SavedMajorVersion != 0x0f) ||
         (SavedMinorVersion != VER_PRODUCTBUILD) ) {

        dprintf(
            "\r\n*** Extension DLL(%d Free) does not match target "
            "system(%d %s)\r\n\r\n",
            VER_PRODUCTBUILD,
            SavedMinorVersion,
            (SavedMajorVersion==0x0f) ? "Free" : "Checked"
            );

    }
#endif
}


BOOL
HaveDebuggerData(
    VOID
    )
{
    static int havedata = 0;

    if (havedata == 2) {
        return FALSE;
    }

    if (havedata == 0) {
        if (!Ioctl(
                IG_GET_KERNEL_VERSION,
                (PVOID)(&KernelVersionPacket),
                sizeof(KernelVersionPacket)
                )
            ) {
            havedata = 2;

        } else if (KernelVersionPacket.MajorVersion == 0) {

            havedata = 2;

        } else {

            havedata = 1;

        }

    }

    return (havedata == 1) &&
           ((KernelVersionPacket.Flags & DBGKD_VERS_FLAG_DATA) != 0);
}

#if 0
BOOL
GetUlong (
    IN  PCHAR   String,
    IN  PULONG  Value
    )
{
    BOOL    status;
    ULONG_PTR Location;
    ULONG   result;


    Location = GetExpression( String );
    if (!Location) {

        dprintf("unable to get %s\n",String);
        return FALSE;

    }

    status = ReadMemory(
        Location,
        Value,
        sizeof(ULONG),
        &result
        );
    if (status == FALSE || result != sizeof(ULONG)) {

        return FALSE;

    }
    return TRUE;
}


BOOL
GetUlongPtr (
    IN  PCHAR   String,
    IN  PULONG_PTR Address
    )
{
    BOOL    status;
    ULONG_PTR Location;
    ULONG   result;


    Location = GetExpression( String );
    if (!Location) {

        dprintf("unable to get %s\n",String);
        return FALSE;

    }

    status = ReadMemory(
        Location,
        Address,
        sizeof(ULONG_PTR),
        &result
        );
    if (status == FALSE || result != sizeof(ULONG)) {

        return FALSE;

    }
    return TRUE;
}
#endif //xxx

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf(
        "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
        DebuggerType,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
        );

   return S_OK;         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\extflags.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    extflags.h

Abstract:

    This header file (re)defines various flags used by extensions. These definitions
    are copied from different header files as stated.

--*/

#ifndef _EXTFLAGS_
#define _EXTFLAGS_


#if 0
///////////////////////////////////////////////////////////////////////////////
//
// apic.inc
//
///////////////////////////////////////////////////////////////////////////////

//
//  Default Physical addresses of the APICs in a PC+MP system
//

#define IO_BASE_ADDRESS 0xFEC00000  // Default address of
                                    // 1st IO Apic
#define LU_BASE_ADDRESS 0xFEE00000  // Default address
                                    // of Local Apic

#define IO_REGISTER_SELECT      0x00000000 //
#define IO_REGISTER_WINDOW      0x00000010 //

#define IO_ID_REGISTER          0x00000000
#define IO_VERS_REGISTER        0x00000001
#define IO_ARB_ID_REGISTER      0x00000002
#define IO_REDIR_00_LOW         0x00000010
#define IO_REDIR_00_HIGH        0x00000011

#define IO_MAX_REDIR_MASK       0x00FF0000
#define IO_VERSION_MASK         0x000000FF

#define LU_ID_REGISTER          0x00000020 //
#define LU_VERS_REGISTER        0x00000030 //
#define LU_TPR                  0x00000080 //
#define LU_APR                  0x00000090 //
#define LU_PPR                  0x000000A0 //
#define LU_EOI                  0x000000B0 //
#define LU_REMOTE_REGISTER      0x000000C0 //

#define LU_LOGICAL_DEST         0x000000D0 //
#define LU_LOGICAL_DEST_MASK    0xFF000000

#define LU_DEST_FORMAT          0x000000E0 //
#define LU_DEST_FORMAT_MASK     0xF0000000
#define LU_DEST_FORMAT_FLAT     0xFFFFFFFF
#define LU_DEST_FORMAT_CLUSTER  0x0FFFFFFF

#define LU_SPURIOUS_VECTOR      0x000000F0 //
#define LU_FAULT_VECTOR         0x00000370 //
#define LU_UNIT_ENABLED         0x00000100
#define LU_UNIT_DISABLED        0x00000000

#define LU_ISR_0                0x00000100 //
#define LU_TMR_0                0x00000180 //
#define LU_IRR_0                0x00000200 //
#define LU_ERROR_STATUS         0x00000280 //
#define LU_INT_CMD_LOW          0x00000300 //
#define LU_INT_CMD_HIGH         0x00000310 //
#define LU_TIMER_VECTOR         0x00000320 //
#define LU_PERF_VECTOR          0x00000340
#define LU_INT_VECTOR_0         0x00000350 //    TEMPORARY - do not use
#define LU_INT_VECTOR_1         0x00000360 //    TEMPORARY - do not use
#define LU_INITIAL_COUNT        0x00000380 //
#define LU_CURRENT_COUNT        0x00000390 //
#define LU_DIVIDER_CONFIG       0x000003E0 //

#define APIC_ID_MASK            0xFF000000
#define APIC_ID_SHIFT           24

#define INT_VECTOR_MASK         0x000000FF
#define RESERVED_HIGH_INT       0x000000F8
#define DELIVERY_MODE_MASK      0x00000700
#define DELIVER_FIXED           0x00000000
#define DELIVER_LOW_PRIORITY    0x00000100
#define DELIVER_SMI             0x00000200
#define DELIVER_REMOTE_READ     0x00000300
#define DELIVER_NMI             0x00000400
#define DELIVER_INIT            0x00000500
#define DELIVER_STARTUP         0x00000600
#define DELIVER_EXTINT          0x00000700
#define PHYSICAL_DESTINATION    0x00000000
#define LOGICAL_DESTINATION     0x00000800
#define DELIVERY_PENDING        0x00001000
#define ACTIVE_LOW              0x00002000
#define ACTIVE_HIGH             0x00000000
#define REMOTE_IRR              0x00004000
#define LEVEL_TRIGGERED         0x00008000
#define EDGE_TRIGGERED          0x00000000
#define INTERRUPT_MASKED        0x00010000
#define INTERRUPT_MOT_MASKED    0x00000000
#define PERIODIC_TIMER          0x00020000

#define ICR_LEVEL_ASSERTED      0x00004000
#define ICR_LEVEL_DEASSERTED    0x00000000
#define ICR_RR_STATUS_MASK      0x00030000
#define ICR_RR_INVALID          0x00000000
#define ICR_RR_IN_PROGRESS      0x00010000
#define ICR_RR_VALID            0x00020000
#define ICR_SHORTHAND_MASK      0x000C0000
#define ICR_USE_DEST_FIELD      0x00000000
#define ICR_SELF                0x00040000
#define ICR_ALL_INCL_SELF       0x00080000
#define ICR_ALL_EXCL_SELF       0x000C0000


//
//  Io Apic Entry definitions
//
//  Interrupt Types Possible in the PC+MP Table
//  valid for both local and Io Apics
//
#define INT_TYPE_INTR           0x0
#define INT_TYPE_NMI            0x1
#define INT_TYPE_SMI            0x2
#define INT_TYPE_EXTINT         0x3



///////////////////////////////////////////////////////////////////////////////
//
// arbiter.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Attributes for the ranges
//

#define ARBITER_RANGE_BOOT_ALLOCATED    0x01

#define ARBITER_RANGE_ALIAS             0x10
#define ARBITER_RANGE_POSITIVE_DECODE   0x20

#define INITIAL_ALLOCATION_STATE_SIZE   PageSize

#define ARBITER_INSTANCE_SIGNATURE      'sbrA'



///////////////////////////////////////////////////////////////////////////////
//
// busp.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Flags definitions of DEVICE_INFORMATION and BUS_EXTENSION
//

#define DF_DELETED          0x00000001
#define DF_REMOVED          0X00000002
#define DF_NOT_FUNCTIONING  0x00000004
#define DF_ENUMERATED       0x00000008
#define DF_ACTIVATED        0x00000010
#define DF_QUERY_STOPPED    0x00000020
#define DF_SURPRISE_REMOVED 0x00000040
#define DF_PROCESSING_RDP   0x00000080
#define DF_STOPPED          0x00000100
#define DF_RESTARTED_MOVED  0x00000200
#define DF_RESTARTED_NOMOVE 0x00000400
#define DF_REQ_TRIMMED      0x00000800
#define DF_READ_DATA_PORT   0x40000000
#define DF_BUS              0x80000000


///////////////////////////////////////////////////////////////////////////////
//
// cache.h
//
///////////////////////////////////////////////////////////////////////////////

//  Define two constants describing the view size (and alignment)
//  that the Cache Manager uses to map files.
//

#define VACB_MAPPING_GRANULARITY         (0x40000)
#define VACB_OFFSET_SHIFT                (18)


///////////////////////////////////////////////////////////////////////////////
//
// cc.h
//
///////////////////////////////////////////////////////////////////////////////

//
//  Define our node type codes.
//

#define CACHE_NTC_SHARED_CACHE_MAP       (0x2FF)
#define CACHE_NTC_PRIVATE_CACHE_MAP      (0x2FE)
#define CACHE_NTC_BCB                    (0x2FD)
#define CACHE_NTC_DEFERRED_WRITE         (0x2FC)
#define CACHE_NTC_MBCB                   (0x2FB)
#define CACHE_NTC_OBCB                   (0x2FA)
#define CACHE_NTC_MBCB_GRANDE            (0x2F9)

//  There is a bit of a trick as we make the jump to the multilevel structure in that
//  we need a real fixed reference count.
//

#define VACB_LEVEL_SHIFT                  (7)

//
//  This is how many bytes of pointers are at each level.  This is the size for both
//  the Vacb array and (optional) Bcb listheads.  It does not include the reference
//  block.
//

// #define VACB_LEVEL_BLOCK_SIZE             ((1 << VACB_LEVEL_SHIFT) * sizeof(PVOID))

//
//  This is the last index for a level.
//

#define VACB_LAST_INDEX_FOR_LEVEL         ((1 << VACB_LEVEL_SHIFT) - 1)

//
//  This is the size of file which can be handled in a single level.
//

#define VACB_SIZE_OF_FIRST_LEVEL         (1 << (VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT))

//
//  This is the maximum number of levels it takes to support 63-bits.  It is
//  used for routines that must remember a path.
//

#define VACB_NUMBER_OF_LEVELS            (((63 - VACB_OFFSET_SHIFT)/VACB_LEVEL_SHIFT) + 1)

//
//  First some constants
//

#define PREALLOCATED_VACBS               (4)


///////////////////////////////////////////////////////////////////////////////
//
// ex.h
//
///////////////////////////////////////////////////////////////////////////////

#define CALL_HASH_TABLE_SIZE 64

//
// If high order bit in Pool tag is set, then must use ExFreePoolWithTag to free
//

#define PROTECTED_POOL 0x80000000

#define POOL_BACKTRACEINDEX_PRESENT 0x8000

#define ResourceNeverExclusive       0x10
#define ResourceReleaseByOtherThread 0x20
#define ResourceOwnedExclusive       0x80

#define RESOURCE_HASH_TABLE_SIZE 64

//
// The following two definitions control the raising of exceptions on quota
// and allocation failures.
//

#define POOL_QUOTA_FAIL_INSTEAD_OF_RAISE 8
#define POOL_RAISE_IF_ALLOCATION_FAILURE 16               // ntifs



///////////////////////////////////////////////////////////////////////////////
//
// cmdata.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Define the HINT Length used
//
#define CM_SUBKEY_HINT_LENGTH   4
#define CM_MAX_CACHE_HINT_SIZE 14

//
// Bits used in the ExtFlags in KCB.
//

#define CM_KCB_NO_SUBKEY        0x0001      // This key has no subkeys
#define CM_KCB_SUBKEY_ONE       0x0002      // This key has only one subkey and the
                                            // first 4 char
                                            //
#define CM_KCB_SUBKEY_HINT          0x0004
#define CM_KCB_SYM_LINK_FOUND       0x0008
#define CM_KCB_KEY_NON_EXIST        0x0010
#define CM_KCB_NO_DELAY_CLOSE       0x0020
#define CM_KCB_INVALID_CACHED_INFO  0x0040  // info stored in SubKeyCount is not valid, so we shouldn't rely on it

#define CM_KCB_CACHE_MASK (CM_KCB_NO_SUBKEY | \
                           CM_KCB_KEY_NON_EXIST | \
                           CM_KCB_SUBKEY_ONE | \
                           CM_KCB_SUBKEY_HINT)




//
// CM_KEY_BODY
//
#define KEY_BODY_TYPE           0x6b793032      // "ky02"

//
// ----- CM_KEY_VALUE -----
//

#define CM_KEY_VALUE_SIGNATURE      0x6b76                      // "kv"

#define VALUE_COMP_NAME             0x0001                      // The name for this value is stored in a

//
// ----- CM_KEY_NODE -----
//

#define CM_KEY_NODE_SIGNATURE      0x6b6e           // "kn"
#define CM_LINK_NODE_SIGNATURE     0x6b6c          // "kl"

#define KEY_VOLATILE        0x0001      // This key (and all its children)
                                        // is volatile.

#define KEY_HIVE_EXIT       0x0002      // This key marks a bounary to another
                                        // hive (sort of a link).  The null
                                        // value entry contains the hive
                                        // and hive index of the root of the
                                        // child hive.

#define KEY_HIVE_ENTRY      0x0004      // This key is the root of a particular
                                        // hive.

#define KEY_NO_DELETE       0x0008      // This key cannot be deleted, period.

#define KEY_SYM_LINK        0x0010      // This key is really a symbolic link.
#define KEY_COMP_NAME       0x0020      // The name for this key is stored in a
                                        // compressed form.
#define KEY_PREDEF_HANDLE   0x0040      // There is no real key backing this,
                                        // return the predefined handle.
                                        // Predefined handles are stashed in
                                        // ValueList.Count.

///////////////////////////////////////////////////////////////////////////////
//
// hivedata.h
//
///////////////////////////////////////////////////////////////////////////////
#define HFILE_TYPE_PRIMARY      0   // Base hive file
#define HFILE_TYPE_LOG          1   // Log (security.log)
#define HFILE_TYPE_EXTERNAL     2   // Target of savekey, etc.
#define HFILE_TYPE_MAX          3

#define HHIVE_SIGNATURE 0xBEE0BEE0

#define HBIN_SIGNATURE          0x6e696268      // "hbin"

#define HHIVE_LINEAR_INDEX      16  // All computed linear indices < HHIVE_LINEAR_INDEX are valid
#define HHIVE_EXPONENTIAL_INDEX 23  // All computed exponential indices < HHIVE_EXPONENTIAL_INDEX
                                    // and >= HHIVE_LINEAR_INDEX are valid.
#define HHIVE_FREE_DISPLAY_SIZE 24

#define HHIVE_FREE_DISPLAY_SHIFT 3  // This must be log2 of HCELL_PAD!
#define HHIVE_FREE_DISPLAY_BIAS  7  // Add to first set bit left of cell size to get exponential index

///////////////////////////////////////////////////////////////////////////////
//
// hardware.h
//
///////////////////////////////////////////////////////////////////////////////

typedef enum {
   WaveInDevice = 0,
   WaveOutDevice,
   MidiOutDevice,
   MidiInDevice,
   LineInDevice,
   CDInternal,
   MixerDevice,
   AuxDevice,
   NumberOfDevices
   } SOUND_DEVICES;

///////////////////////////////////////////////////////////////////////////////
//
// hcdi.h
//
///////////////////////////////////////////////////////////////////////////////

//
// values for DeviceExtension Flags
//
#define USBDFLAG_PDO_REMOVED                0x00000001
#define USBDFLAG_HCD_SHUTDOWN               0x00000002
#define USBDFLAG_HCD_STARTED                0x00000004
#define USBDFLAG_HCD_D0_COMPLETE_PENDING    0x00000008
#define USBDFLAG_RH_DELAY_SET_D0            0x00000010


#define HC_ENABLED_FOR_WAKEUP           0x01
#define HC_WAKE_PENDING                 0x02


// device hack flags, these flags alter the stacks default behavior
// in order to support certain broken "legacy" devices

#define USBD_DEVHACK_SLOW_ENUMERATION   0x00000001
#define USBD_DEVHACK_DISABLE_SN         0x00000002

//
// This macro returns the true device object for the HCD give
// either the true device_object or a PDO owned by the HCD/BUS
// driver.
//

//
// HCD specific URB commands
//

#define URB_FUNCTION_HCD_OPEN_ENDPOINT                0x1000
#define URB_FUNCTION_HCD_CLOSE_ENDPOINT               0x1001
#define URB_FUNCTION_HCD_GET_ENDPOINT_STATE           0x1002
#define URB_FUNCTION_HCD_SET_ENDPOINT_STATE           0x1003
#define URB_FUNCTION_HCD_ABORT_ENDPOINT               0x1004

// this bit is set for all functions that must be handled by HCD
#define HCD_URB_FUNCTION                              0x1000
// this bit is set in the function code by USBD to indicate that
// this is an internal call originating from USBD
#define HCD_NO_USBD_CALL                              0x2000

//
// values for HcdEndpointState
//

//
// set if the current state of the endpoint in the HCD is 'stalled'
//
#define HCD_ENDPOINT_HALTED_BIT            0
#define HCD_ENDPOINT_HALTED                (1<<HCD_ENDPOINT_HALTED_BIT)

//
// set if the HCD has any transfers queued for the endpoint
//
#define HCD_ENDPOINT_TRANSFERS_QUEUED_BIT  1
#define HCD_ENDPOINT_TRANSFERS_QUEUED      (1<<HCD_ENDPOINT_TRANSFERS_QUEUED_BIT)


//
// set if the HCD should reset the data toggle on the host side
//
#define HCD_ENDPOINT_RESET_DATA_TOGGLE_BIT 2
#define HCD_ENDPOINT_RESET_DATA_TOGGLE     (1<<HCD_ENDPOINT_RESET_DATA_TOGGLE_BIT )


//
// HCD specific URBs
//

#define USBD_EP_FLAG_LOWSPEED                0x0001
#define USBD_EP_FLAG_NEVERHALT               0x0002
#define USBD_EP_FLAG_DOUBLE_BUFFER           0x0004
#define USBD_EP_FLAG_FAST_ISO                0x0008


///////////////////////////////////////////////////////////////////////////////
//
// hidclass\local.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Valid values for HIDCLASS_DEVICE_EXTENSION.state
//
enum deviceState {
    DEVICE_STATE_INITIALIZED,
    DEVICE_STATE_STARTING,
    DEVICE_STATE_START_SUCCESS,
    DEVICE_STATE_START_FAILURE,
    DEVICE_STATE_STOPPED,
    DEVICE_STATE_REMOVING,
    DEVICE_STATE_REMOVED,
    DEVICE_STATE_SUSPENDED
};

enum collectionState {
    COLLECTION_STATE_UNINITIALIZED,
    COLLECTION_STATE_INITIALIZED,
    COLLECTION_STATE_RUNNING,
    COLLECTION_STATE_STOPPED,
    COLLECTION_STATE_REMOVING
};

#define             HID_DEVICE_EXTENSION_SIG 'EddH'

///////////////////////////////////////////////////////////////////////////////
//
// hidparse.h
//
///////////////////////////////////////////////////////////////////////////////

#define HIDP_PREPARSED_DATA_SIGNATURE1 'PdiH'
#define HIDP_PREPARSED_DATA_SIGNATURE2 'RDK '



///////////////////////////////////////////////////////////////////////////////
//
// hivedata.h
//
///////////////////////////////////////////////////////////////////////////////



//
// ===== Basic Structures and Definitions =====
//
// These are same whether on disk or in memory.
//

//
// NOTE:    Volatile == storage goes away at reboot
//          Stable == Persistent == Not Volatile
//
typedef enum {
    Stable = 0,
    Volatile = 1
} HSTORAGE_TYPE;

#define HTYPE_COUNT 2

// --- HBASE_BLOCK --- on disk description of the hive
//

//
// NOTE:    HBASE_BLOCK must be >= the size of physical sector,
//          or integrity assumptions will be violated, and crash
//          recovery may not work.
//

#define HBASE_BLOCK_SIGNATURE   0x66676572  // "regf"

#define HSYS_MAJOR          1               // Must match to read at all
#define HSYS_MINOR          3               // Must be <= to write, always
                                            // set up to writer's version.

#define HBASE_FORMAT_MEMORY 1               // Direct memory load case

#define HBASE_NAME_ALLOC    64              // 32 unicode chars

// #define HLOG_HEADER_SIZE  (FIELD_OFFSET(HBASE_BLOCK, Reserved2))
#define HLOG_DV_SIGNATURE   0x54524944      // "DIRT"


#define HCELL_TYPE_MASK         0x80000000
#define HCELL_TYPE_SHIFT        31

#define HCELL_TABLE_MASK        0x7fe00000
#define HCELL_TABLE_SHIFT       21

#define HCELL_BLOCK_MASK        0x001ff000
#define HCELL_BLOCK_SHIFT       12

#define HCELL_OFFSET_MASK       0x00000fff

#define HBLOCK_SIZE             0x1000      // LOGICAL block size
                                            // This is the size of one of
                                            // the registry's logical/virtual
                                            // pages.  It has no particular
                                            // relationship to page size
                                            // of the machine.

#define HSECTOR_SIZE            0x200       // LOGICAL sector size
#define HSECTOR_COUNT           8           // LOGICAL sectors / LOGICAL Block

#define HTABLE_SLOTS        512         // 9 bits of address
#define HDIRECTORY_SLOTS    1024        // 10 bits of address


///////////////////////////////////////////////////////////////////////////////
//
// io.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d


//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the Device Object Extension Flags
//

#define DOE_UNLOAD_PENDING              0x00000001
#define DOE_DELETE_PENDING              0x00000002
#define DOE_REMOVE_PENDING              0x00000004
#define DOE_REMOVE_PROCESSED            0x00000008
#define DOE_START_PENDING               0x00000010

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400

#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000
#define IRP_RETRY_IO_COMPLETION         0x00004000



#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
//
// Define Volume Parameter Block (VPB) flags.
//

#define VPB_MOUNTED                     0x00000001
#define VPB_LOCKED                      0x00000002
#define VPB_PERSISTENT                  0x00000004
#define VPB_REMOVE_PENDING              0x00000008
#define VPB_RAW_MOUNT                   0x00000010



///////////////////////////////////////////////////////////////////////////////
//
// ke.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Define I/O request packet (IRP) alternate flags for allocation control.
//

#define IRP_QUOTA_CHARGED               0x01
#define IRP_ALLOCATED_MUST_SUCCEED      0x02
#define IRP_ALLOCATED_FIXED_SIZE        0x04
#define IRP_LOOKASIDE_ALLOCATION        0x08

//
// Public (external) constant definitions.
//

#define BASE_PRIORITY_THRESHOLD NORMAL_BASE_PRIORITY // fast path base threshold

// begin_ntddk begin_wdm
#define THREAD_WAIT_OBJECTS 3           // Builtin usable wait blocks
// end_ntddk end_wdm

#define EVENT_WAIT_BLOCK 2              // Builtin event pair wait block
#define SEMAPHORE_WAIT_BLOCK 2          // Builtin semaphore wait block
#define TIMER_WAIT_BLOCK 3              // Builtin timer wait block

#if (EVENT_WAIT_BLOCK != SEMAPHORE_WAIT_BLOCK)
#error "wait event and wait semaphore must use same wait block"
#endif

//
// Define timer table size.
//

#define TIMER_TABLE_SIZE 128


typedef enum _KOBJECTS {
    EventNotificationObject = 0,
    EventSynchronizationObject = 1,
    MutantObject = 2,
    ProcessObject = 3,
    QueueObject = 4,
    SemaphoreObject = 5,
    ThreadObject = 6,
    Spare1Object = 7,
    TimerNotificationObject = 8,
    TimerSynchronizationObject = 9,
    Spare2Object = 10,
    Spare3Object = 11,
    Spare4Object = 12,
    Spare5Object = 13,
    Spare6Object = 14,
    Spare7Object = 15,
    Spare8Object = 16,
    Spare9Object = 17,
    ApcObject,
    DpcObject,
    DeviceQueueObject,
    EventPairObject,
    InterruptObject,
    ProfileObject
    } KOBJECTS;


typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
    BufferEmpty,
    BufferInserted,
    BufferStarted,
    BufferFinished,
    BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE;



///////////////////////////////////////////////////////////////////////////////
//
// local.h
//
///////////////////////////////////////////////////////////////////////////////
typedef enum {

    //
    // Device Object Extension Types
    //

    PciPdoExtensionType = 'icP0',
    PciFdoExtensionType,

    //
    // Arbitration Types.  (These are also secondary extensions).
    //

    PciArb_Io,
    PciArb_Memory,
    PciArb_Interrupt,
    PciArb_BusNumber,

    //
    // Translation Types.  (These are also secondary extensions).
    //

    PciTrans_Interrupt,

    //
    // Other exposed interfaces.
    //

    PciInterface_BusHandler,
    PciInterface_IntRouteHandler,
    PciInterface_PciCb,
    PciInterface_LegacyDeviceDetection,
    PciInterface_PmeHandler,
    PciInterface_DevicePresent

} PCI_SIGNATURE;

///////////////////////////////////////////////////////////////////////////////
//
// lpc.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Valid values for Flags field
//

#define PORT_TYPE                           0x0000000F
#define SERVER_CONNECTION_PORT              0x00000001
#define UNCONNECTED_COMMUNICATION_PORT      0x00000002
#define SERVER_COMMUNICATION_PORT           0x00000003
#define CLIENT_COMMUNICATION_PORT           0x00000004
#define PORT_WAITABLE                       0x20000000
#define PORT_NAME_DELETED                   0x40000000
#define PORT_DYNAMIC_SECURITY               0x80000000
#define PORT_DELETED                        0x10000000


///////////////////////////////////////////////////////////////////////////////
//
// mi.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Page protections
//

#define MM_ZERO_ACCESS         0  // this value is not used.
#define MM_READONLY            1
#define MM_EXECUTE             2
#define MM_EXECUTE_READ        3
#define MM_READWRITE           4  // bit 2 is set if this is writable.
#define MM_WRITECOPY           5
#define MM_EXECUTE_READWRITE   6
#define MM_EXECUTE_WRITECOPY   7

#define MM_NOCACHE            0x8
#define MM_GUARD_PAGE         0x10
#define MM_DECOMMIT           0x10   //NO_ACCESS, Guard page
#define MM_NOACCESS           0x18   //NO_ACCESS, Guard_page, nocache.
#define MM_UNKNOWN_PROTECTION 0x100  //bigger than 5 bits!
#define MM_LARGE_PAGES        0x111

#define PROTECT_KSTACKS       1

#define MM_KSTACK_OUTSWAPPED  0x1F   //Debug marking for kernel stacks

#define MM_PROTECTION_WRITE_MASK     4
#define MM_PROTECTION_COPY_MASK      1
#define MM_PROTECTION_OPERATION_MASK 7 // mask off guard page and nocache.
#define MM_PROTECTION_EXECUTE_MASK   2

#define MM_SECURE_DELETE_CHECK 0x55


//
// Special pool constants
//
#define MI_SPECIAL_POOL_PAGABLE         0x8000
#define MI_SPECIAL_POOL_VERIFIER        0x4000
#define MI_SPECIAL_POOL_PTE_PAGABLE     0x0002
#define MI_SPECIAL_POOL_PTE_NONPAGABLE  0x0004

#define VI_VERIFYING_DIRECTLY   0x1
#define VI_VERIFYING_INVERSELY  0x2


#define MM_SYS_PTE_TABLES_MAX 5



///////////////////////////////////////////////////////////////////////////////
//
// mm.h
//
///////////////////////////////////////////////////////////////////////////////


typedef enum _MMLISTS {
    ZeroedPageList,
    FreePageList,
    StandbyPageList,  //this list and before make up available pages.
    ModifiedPageList,
    ModifiedNoWritePageList,
    BadPageList,
    ActiveAndValid,
    TransitionPage
} MMLISTS;

#define MM_FREE_WSLE_SHIFT 4

#define WSLE_NULL_INDEX ((ULONG64)0xFFFFFFFFFFFFFFFUI64)

//
//  GDT selectors - These defines are R0 selector numbers, which means
//                  they happen to match the byte offset relative to
//                  the base of the GDT.
//

#define KGDT_NULL       0
#define KGDT_R0_CODE    8
#define KGDT_R0_DATA    16
#define KGDT_R3_CODE    24
#define KGDT_R3_DATA    32
#define KGDT_TSS        40
#define KGDT_R0_PCR     48
#define KGDT_R3_TEB     56
#define KGDT_VDM_TILE   64
#define KGDT_LDT        72
#define KGDT_DF_TSS     80
#define KGDT_NMI_TSS    88

//
//  GDT selectors - These defines are R0 selector numbers, which means
//                  they happen to match the byte offset relative to
//                  the base of the GDT.
//

#define KGDT_NULL       0
#define KGDT_R3_CODE    24
#define KGDT_R3_DATA    32
#define KGDT_R3_TEB     56
#define KGDT_VDM_TILE   64


#define GRAN_BYTE   0
#define GRAN_PAGE   1

#endif

///////////////////////////////////////////////////////////////////////////////
//
// ob.h
//
///////////////////////////////////////////////////////////////////////////////
#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_CREATOR_INFO            0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40

#if 0

///////////////////////////////////////////////////////////////////////////////
//
// openhci.h
//
///////////////////////////////////////////////////////////////////////////////


//values for HcFlags
#define HC_FLAG_REMOTE_WAKEUP_CONNECTED     0x00000001
#define HC_FLAG_LEGACY_BIOS_DETECTED        0x00000002
#define HC_FLAG_SLOW_BULK_ENABLE            0x00000004
#define HC_FLAG_SHUTDOWN                    0x00000008  // not really used
#define HC_FLAG_MAP_SX_TO_D3                0x00000010
#define HC_FLAG_IDLE                        0x00000020
#define HC_FLAG_DISABLE_IDLE_CHECK          0x00000040
#define HC_FLAG_DEVICE_STARTED              0x00000080
#define HC_FLAG_LOST_POWER                  0x00000100
#define HC_FLAG_DISABLE_IDLE_MODE           0x00000200
#define HC_FLAG_USE_HYDRA_HACK              0x00000400
#define HC_FLAG_IN_DPC                      0x00000800
#define HC_FLAG_SUSPEND_NEXT_D3             0x00001000
#define HC_FLAG_LIST_FIX_ENABLE             0x00002000
#define HC_FLAG_HUNG_CHECK_ENABLE           0x00004000

#define PENDING_TD_LIST_SIZE                1000

#define HcCtrl_CBSR_MASK                     0x00000003L
#define HcCtrl_CBSR_1_to_1                   0x00000000L
#define HcCtrl_CBSR_2_to_1                   0x00000001L
#define HcCtrl_CBSR_3_to_1                   0x00000002L
#define HcCtrl_CBSR_4_to_1                   0x00000003L
#define HcCtrl_PeriodicListEnable            0x00000004L
#define HcCtrl_IsochronousEnable             0x00000008L
#define HcCtrl_ControlListEnable             0x00000010L
#define HcCtrl_BulkListEnable                0x00000020L
#define HcCtrl_ListEnableMask                0x00000038L

#define HcCtrl_HCFS_MASK                     0x000000C0L
#define HcCtrl_HCFS_USBReset                 0x00000000L
#define HcCtrl_HCFS_USBResume                0x00000040L
#define HcCtrl_HCFS_USBOperational           0x00000080L
#define HcCtrl_HCFS_USBSuspend               0x000000C0L

#define HcCtrl_InterruptRouting              0x00000100L
#define HcCtrl_RemoteWakeupConnected         0x00000200L
#define HcCtrl_RemoteWakeupEnable            0x00000400L

#define HcHCFS_USBReset                      0x00000000
#define HcHCFS_USBResume                     0x00000001
#define HcHCFS_USBOperational                0x00000002
#define HcHCFS_USBSuspend                    0x00000003

#define HcCmd_HostControllerReset            0x00000001
#define HcCmd_ControlListFilled              0x00000002
#define HcCmd_BulkListFilled                 0x00000004
#define HcCmd_OwnershipChangeRequest         0x00000008
#define HcCmd_SOC_Mask                       0x00030000
#define HcCmd_SOC_Offset                     16
#define HcCmd_SOC_Mask_LowBits               0x00000003

//
// Definitions for HC_ENDPOINT_CONTROL.Direction
//
#define HcEDDirection_Defer   0           // Defer direction to TD (Control Endpoints)
#define HcEDDirection_Out     1           // Direction from host to device
#define HcEDDirection_In      2           // Direction from device to host


//
// The different ED lists are as follows.
//
#define  ED_INTERRUPT_1ms        0
#define  ED_INTERRUPT_2ms        1
#define  ED_INTERRUPT_4ms        3
#define  ED_INTERRUPT_8ms        7
#define  ED_INTERRUPT_16ms       15
#define  ED_INTERRUPT_32ms       31
#define  ED_CONTROL              63
#define  ED_BULK                 64
#define  ED_ISOCHRONOUS          0     // same as 1ms interrupt queue
#define  NO_ED_LISTS             65
#define  ED_EOF                  0xff

//
// 7.1.4 HcInterrruptStatus Register
// 7.1.5 HcInterruptEnable  Register
// 7.1.6 HcInterruptDisable Register
//
#define HcInt_SchedulingOverrun              0x00000001L
#define HcInt_WritebackDoneHead              0x00000002L
#define HcInt_StartOfFrame                   0x00000004L
#define HcInt_ResumeDetected                 0x00000008L
#define HcInt_UnrecoverableError             0x00000010L
#define HcInt_FrameNumberOverflow            0x00000020L
#define HcInt_RootHubStatusChange            0x00000040L
#define HcInt_OwnershipChange                0x40000000L
#define HcInt_MasterInterruptEnable          0x80000000L

//
// 7.4.3 HcRhStatus Register
//
#define HcRhS_LocalPowerStatus                  0x00000001  // read only
#define HcRhS_OverCurrentIndicator              0x00000002  // read only
#define HcRhS_DeviceRemoteWakeupEnable          0x00008000  // read only
#define HcRhS_LocalPowerStatusChange            0x00010000  // read only
#define HcRhS_OverCurrentIndicatorChange        0x00020000  // read only

#define HcRhS_ClearGlobalPower                  0x00000001  // write only
#define HcRhS_SetRemoteWakeupEnable             0x00008000  // write only
#define HcRhS_SetGlobalPower                    0x00010000  // write only
#define HcRhS_ClearOverCurrentIndicatorChange   0x00020000  // write only
#define HcRhS_ClearRemoteWakeupEnable           0x80000000  // write only

//
// 7.4.4 HcRhPortStatus Register
//
#define HcRhPS_CurrentConnectStatus          0x00000001  // read only
#define HcRhPS_PortEnableStatus              0x00000002  // read only
#define HcRhPS_PortSuspendStatus             0x00000004  // read only
#define HcRhPS_PortOverCurrentIndicator      0x00000008  // read only
#define HcRhPS_PortResetStatus               0x00000010  // read only
#define HcRhPS_PortPowerStatus               0x00000100  // read only
#define HcRhPS_LowSpeedDeviceAttached        0x00000200  // read only
#define HcRhPS_ConnectStatusChange           0x00010000  // read only
#define HcRhPS_PortEnableStatusChange        0x00020000  // read only
#define HcRhPS_PortSuspendStatusChange       0x00040000  // read only
#define HcRhPS_OverCurrentIndicatorChange    0x00080000  // read only
#define HcRhPS_PortResetStatusChange         0x00100000  // read only

#define HcRhPS_ClearPortEnable               0x00000001  // write only
#define HcRhPS_SetPortEnable                 0x00000002  // write only
#define HcRhPS_SetPortSuspend                0x00000004  // write only
#define HcRhPS_ClearPortSuspend              0x00000008  // write only
#define HcRhPS_SetPortReset                  0x00000010  // write only
#define HcRhPS_SetPortPower                  0x00000100  // write only
#define HcRhPS_ClearPortPower                0x00000200  // write only
#define HcRhPS_ClearConnectStatusChange      0x00010000  // write only
#define HcRhPS_ClearPortEnableStatusChange   0x00020000  // write only
#define HcRhPS_ClearPortSuspendStatusChange  0x00040000  // write only
#define HcRhPS_ClearPortOverCurrentChange    0x00080000  // write only
#define HcRhPS_ClearPortResetStatusChange    0x00100000  // write only

#define HcRhPS_RESERVED     (~(HcRhPS_CurrentConnectStatus       | \
                               HcRhPS_PortEnableStatus           | \
                               HcRhPS_PortSuspendStatus          | \
                               HcRhPS_PortOverCurrentIndicator   | \
                               HcRhPS_PortResetStatus            | \
                               HcRhPS_PortPowerStatus            | \
                               HcRhPS_LowSpeedDeviceAttached     | \
                               HcRhPS_ConnectStatusChange        | \
                               HcRhPS_PortEnableStatusChange     | \
                               HcRhPS_PortSuspendStatusChange    | \
                               HcRhPS_OverCurrentIndicatorChange | \
                               HcRhPS_PortResetStatusChange        \
                            ))


//
// Definitions for HC_TRANSFER_CONTROL.Control
//
#define HcTDControl_STARTING_FRAME        0x0000FFFF  // mask for starting frame (Isochronous)
#define HcTDControl_ISOCHRONOUS           0x00010000  // 1 for Isoch TD, 0 for General TD
#define HcTDControl_SHORT_XFER_OK         0x00040000  // 0 if short transfers are errors
#define HcTDControl_DIR_MASK              0x00180000  // Transfer direction field
#define HcTDControl_DIR_SETUP             0x00000000  // direction is setup packet from host to device
#define HcTDControl_DIR_OUT               0x00080000  // direction is from host to device
#define HcTDControl_DIR_IN                0x00100000  // direction is from device to host
#define HcTDControl_INT_DELAY_MASK        0x00E00000  // Interrupt Delay field
#define HcTDControl_INT_DELAY_0_MS        0x00000000  // Interrupt at end of frame TD is completed
#define HcTDControl_INT_DELAY_1_MS        0x00200000  // Interrupt no later than end of 1st frame after TD is completed
#define HcTDControl_INT_DELAY_2_MS        0x00400000  // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDControl_INT_DELAY_3_MS        0x00600000  // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDControl_INT_DELAY_4_MS        0x00800000  // Interrupt no later than end of 4th frame after TD is completed
#define HcTDControl_INT_DELAY_5_MS        0x00A00000  // Interrupt no later than end of 5th frame after TD is completed
#define HcTDControl_INT_DELAY_6_MS        0x00C00000  // Interrupt no later than end of 6th frame after TD is completed

#ifdef NSC
#define HcTDControl_INT_DELAY_NO_INT      0x00C00000  // Almost infinity but not yet quite.
#elif DISABLE_INT_DELAY_NO_INT
#define   HcTDControl_INT_DELAY_NO_INT      0x00000000  // Interrupt at the completion of all packets.
#else
#define HcTDControl_INT_DELAY_NO_INT      0x00E00000  // Do not cause an interrupt for normal completion of this TD
#endif

#define HcTDControl_FRAME_COUNT_MASK      0x07000000  // mask for FrameCount field (Isochronous)
#define HcTDControl_FRAME_COUNT_SHIFT     24          // shift count for FrameCount (Isochronous)
#define HcTDControl_FRAME_COUNT_MAX       8           // Max number of for frame count per TD
#define HcTDControl_TOGGLE_MASK           0x03000000  // mask for Toggle control field
#define HcTDControl_TOGGLE_FROM_ED        0x00000000  // get data toggle from CARRY field of ED
#define HcTDControl_TOGGLE_DATA0          0x02000000  // use DATA0 for data PID
#define HcTDControl_TOGGLE_DATA1          0x03000000  // use DATA1 for data PID
#define HcTDControl_ERROR_COUNT           0x0C000000  // mask for Error Count field
#define HcTDControl_CONDITION_CODE_MASK   0xF0000000  // mask for ConditionCode field
#define HcTDControl_CONDITION_CODE_SHIFT  28          // shift count for ConditionCode

//
// Definitions for HC_TRANSFER_CONTROL.Direction
//
#define HcTDDirection_Setup               0           // setup packet from host to device
#define HcTDDirection_Out                 1           // direction from host to device
#define HcTDDirection_In                  2           // direction from device to host

//
// Definitions for Hc_TRANSFER_CONTROL.IntDelay
//
#define HcTDIntDelay_0ms                  0           // interrupt at end of frame TD is completed
#define HcTDIntDelay_1ms                  1           // Interrupt no later than end of 1st frame after TD is completed
#define HcTDIntDelay_2ms                  2           // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDIntDelay_3ms                  3           // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDIntDelay_4ms                  4           // Interrupt no later than end of 4th frame after TD is completed
#define HcTDIntDelay_5ms                  5           // Interrupt no later than end of 5th frame after TD is completed
#define HcTDIntDelay_6ms                  6           // Interrupt no later than end of 6th frame after TD is completed
#define HcTDIntDelay_NoInterrupt          7           // do not generate interrupt for normal completion of this TD

//
// Definitions for HC_TRANSFER_CONTROL.Toggle
//
#define HcTDToggle_FromEd                 0           // get toggle for Endpoint Descriptor toggle CARRY bit
#define HcTDToggle_Data0                  2           // use Data0 PID
#define HcTDToggle_Data1                  3           // use Data1 PID

//
// Definitions for HC_TRANSFER_CONTROL.ConditionCode and HC_OFFSET_PSW.ConditionCode
//
#define HcCC_NoError                      0x0UL
#define HcCC_CRC                          0x1UL
#define HcCC_BitStuffing                  0x2UL
#define HcCC_DataToggleMismatch           0x3UL
#define HcCC_Stall                        0x4UL
#define HcCC_DeviceNotResponding          0x5UL
#define HcCC_PIDCheckFailure              0x6UL
#define HcCC_UnexpectedPID                0x7UL
#define HcCC_DataOverrun                  0x8UL
#define HcCC_DataUnderrun                 0x9UL
      //                                  0xA         // reserved
      //                                  0xB         // reserved
#define HcCC_BufferOverrun                0xCUL
#define HcCC_BufferUnderrun               0xDUL
#define HcCC_NotAccessed                  0xEUL

///////////////////////////////////////////////////////////////////////////////
//
// pci.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Note - State.c depends on the order of these.
//
typedef enum {
    PciNotStarted = 0,
    PciStarted,
    PciDeleted,
    PciStopped,
    PciSurpriseRemoved,
    PciSynchronizedOperation,
    PciMaxObjectState
} PCI_OBJECT_STATE;

//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


///////////////////////////////////////////////////////////////////////////////
//
// pcmcia.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Flags indicating card/controller state
//
#define PCMCIA_DEVICE_STARTED                  0x00000001
#define PCMCIA_DEVICE_LOGICALLY_REMOVED        0x00000002
#define PCMCIA_DEVICE_PHYSICALLY_REMOVED       0x00000004
#define PCMCIA_DEVICE_MULTIFUNCTION            0x00000008
#define PCMCIA_DEVICE_WAKE_PENDING             0x00000010
#define PCMCIA_DEVICE_LEGACY_DETECTED          0x00000020
#define PCMCIA_DEVICE_DELETED                  0x00000040
#define PCMCIA_DEVICE_CARDBUS                  0x00000080
#define PCMCIA_FILTER_ADDED_MEMORY             0x00000100
#define PCMCIA_MEMORY_24BIT                    0x00000200
#define PCMCIA_CARDBUS_NOT_SUPPORTED           0x00000400
#define PCMCIA_USE_POLLED_CSC                  0x00000800
#define PCMCIA_ATTRIBUTE_MEMORY_MAPPED         0x00001000
#define PCMCIA_SOCKET_REGISTER_BASE_MAPPED     0x00002000
#define PCMCIA_INTMODE_COMPAQ                  0x00004000
#define PCMCIA_POWER_WORKER_POWERUP            0x00008000
#define PCMCIA_SOCKET_POWER_REQUESTED          0x00010000
#define PCMCIA_CONFIG_STATUS_DEFERRED          0x00020000
#define PCMCIA_POWER_STATUS_DEFERRED           0x00040000
#define PCMCIA_INT_ROUTE_INTERFACE             0x00080000
#define PCMCIA_FDO_CONTEXT_SAVED               0x00100000
#define PCMCIA_FDO_DEFAULT_IRQ_MASK            0x00200000


//
// Socket flags
//
#define SOCKET_CARD_IN_SOCKET          0x00000001
#define SOCKET_CARD_INITIALIZED        0x00000002
#define SOCKET_CARD_POWERED_UP         0x00000004
#define SOCKET_CARD_CONFIGURED         0x00000008
#define SOCKET_CARD_MULTIFUNCTION      0x00000010
#define SOCKET_CARD_CARDBUS            0x00000020
#define SOCKET_CARD_MEMORY             0x00000040
#define SOCKET_CHANGE_INTERRUPT        0x00000080
#define SOCKET_CUSTOM_INTERFACE        0x00000100
#define SOCKET_INSERTED_SOUND_PENDING  0x00000200
#define SOCKET_REMOVED_SOUND_PENDING   0x00000400
#define SOCKET_SUPPORT_MESSAGE_SENT    0x00000800
#define SOCKET_MEMORY_WINDOW_ENABLED   0x00001000
#define SOCKET_CARD_STATUS_CHANGE      0x00002000
#define SOCKET_POWER_STATUS_DEFERRED   0x00004000

//
// Worker states for socket power operations
//
#define SPW_Stopped                 0
#define SPW_Exit                    1
#define SPW_RequestPower            2
#define SPW_ReleasePower            3
#define SPW_SetPowerOn              4
#define SPW_SetPowerOff             5
#define SPW_InitPcCard              6
#define SPW_ParentPowerUp           7
#define SPW_ParentPowerUpComplete   8


//
// Controller classes returned in socket information structure.
//

typedef enum _PCMCIA_CONTROLLER_CLASS {
   PcmciaInvalidControllerClass = -1,
   PcmciaIntelCompatible,
   PcmciaCardBusCompatible,
   PcmciaElcController,
   PcmciaDatabook,
   PcmciaPciPcmciaBridge,
   PcmciaCirrusLogic,
   PcmciaTI,
   PcmciaTopic,
   PcmciaRicoh,
   PcmciaDatabookCB,
   PcmciaOpti,
   PcmciaTrid,
   PcmciaO2Micro,
   PcmciaNEC,
   PcmciaNEC_98
} PCMCIA_CONTROLLER_CLASS, *PPCMCIA_CONTROLLER_CLASS;
#define PcmciaInvalidControllerType 0xffffffff
#define PCMCIA_INVALID_CONFIGURATION    0x00000001
// Max length of device id
#define PCMCIA_MAXIMUM_DEVICE_ID_LENGTH   128


//
// states for PdoPowerWorker
//
#define PPW_Stopped           0
#define PPW_Exit              1
#define PPW_InitialState      2
#define PPW_PowerUp           3
#define PPW_PowerUpComplete   4
#define PPW_PowerDown         5
#define PPW_PowerDownComplete 6
#define PPW_SendIrpDown       7
#define PPW_16BitConfigure    8
#define PPW_Deconfigure       9
#define PPW_VerifyCard        10
#define PPW_CardBusRefresh    11
#define PPW_CardBusDelay      12
//
// phases for ConfigurationWorker
//
// Note that the ConfigurationPhase is simply incremented, these
// definitions are just for clarity.
//
#define CW_Stopped            0
#define CW_Phase1             1
#define CW_Phase2             2
#define CW_Phase3             3
#define CW_Exit               4


///////////////////////////////////////////////////////////////////////////////
//
// pcmp.inc
//
///////////////////////////////////////////////////////////////////////////////

//
//  IMCR (Interrupt Mode Control Register) access definitions
//
#define ImcrDisableApic         0x00
#define ImcrEnableApic          0x01
#define ImcrRegPortAddr         0x22
#if defined(NEC_98)
#define ImcrDataPortAddr        0x700
#else  // defined(NEC_98)
#define ImcrDataPortAddr        0x23
#endif // defined(NEC_98)
#define ImcrPort                0x70

// Physical location where the Extended BIOS Data Area segment adress is store
#define EBDA_SEGMENT_PTR    0x40e
#define BASE_MEM_PTR        0x413

//
//  The PC+MP configuration table Possible Entry Types
//
#define ENTRY_PROCESSOR     0
#define ENTRY_BUS           1
#define ENTRY_IOAPIC        2
#define ENTRY_INTI          3
#define ENTRY_LINTI         4

#define HEADER_SIZE     0x2c


// Number of default configurations for PC+MP version 1.1
#define NUM_DEFAULT_CONFIGS  7

//
// Bits used in the CpuFlags field of the Processor entry
//
#define CPU_DISABLED        0x0   // 1 Bit  - CPU Disabled
#define CPU_ENABLED         0x1   // 1 Bit  - CPU Enabled
#define BSP_CPU             0x2   // Bit #2 - CPU is BSP

//  APIC Versions used by PC+MP systems - this is used in the
//  Processor entries and the IoApic Entries
//
#define APIC_INTEGRATED     0x10  // 8 Bits-Apic Version Register
#define APIC_82489DX        0x0   // 8 Bits-Apic Version Register

//
//  Io Apic Entry definitions
//
//  Valid IoApicFlag values
//
#define IO_APIC_ENABLED         0x1
#define IO_APIC_DISABLED        0x0


//
// Default value for Io Apic ID.
//
#define IOUNIT_APIC_ID          0xE


//
//  PC+MP Signature used to verify the PC+MP table
//  as valid
//
//          "P"=50H,"C"=43H,"M"=4dH,"P"=50H
//
#define PCMP_SIGNATURE      0x504d4350

//
//  PC+MP Signature used to identify the floating pointer
//  structure (in extended BIOS data segment) that contains
//  a pointer to the PC+MP table.
//
//          "_"=5fH, "M"=4dH, "P"=50H, "_"=5fH
//
#define MP_PTR_SIGNATURE    0x5f504d5f


//
// Extension table definitions
//

#define EXTTYPE_BUS_ADDRESS_MAP           128
#define EXTTYPE_BUS_HIERARCHY             129
#define EXTTYPE_BUS_COMPATIBLE_MAP        130
#define EXTTYPE_PERSISTENT_STORE          131


#define MPS_ADDRESS_MAP_IO                  0
#define MPS_ADDRESS_MAP_MEMORY              1
#define MPS_ADDRESS_MAP_PREFETCH_MEMORY     2
#define MPS_ADDRESS_MAP_UNDEFINED           9

//
//  The System configuration table as used by a PC_MP system
//
//
// The offset is relative to the BIOS starting at f0000H
//
#define PTR_OFFSET          0x0000e6f5
#define BIOS_BASE           0x000f0000

#define PCMP_IMPLEMENTED    0x01    // In MpFeatureInfoByte1
#define PCMP_CONFIG_MASK    0x0e    // In MpFeatureInfoByte1
#define IMCR_MASK           0x80    // In MpFeatureInfoByte2
#define MULT_CLOCKS_MASK    0x40    // In MpFeatureInfoByte2


///////////////////////////////////////////////////////////////////////////////
//
// pnpiop.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Pool tags
//

#define IOP_DNOD_TAG    'donD'
#define IOP_DNDT_TAG    'tdnD'
#define IOP_DPWR_TAG    'rwPD'

//
// Dbg scope
//

#define DBG_SCOPE 1     // Enable SOME DBG stuff on ALL builds
//#define DBG_SCOPE DBG // Enable only on DBG build


//
// DNF_MAKEUP - this devnode's device is created and owned by PnP manager
//

#define DNF_MADEUP                                  0x00000001

//
// DNF_DUPLICATE - this devnode's device is a duplicate of another enumerate PDO
//

#define DNF_DUPLICATE                               0x00000002

//
// DNF_HAL_NODE - a flag to indicate which device node is the root node created by
// the hal
//

#define DNF_HAL_NODE                                0x00000004

//
// DNF_PROCESSED - indicates if the registry instance key of the device node
//                 was created.
//

#define DNF_PROCESSED                               0x00000008

//
// DNF_ENUMERATED - used to track enumeration in IopEnumerateDevice()
//

#define DNF_ENUMERATED                              0x00000010

//
// Singal that we need to send driver query id irps
//

#define DNF_NEED_QUERY_IDS                          0x00000020

//
// THis device has been added to its controlling driver
//

#define DNF_ADDED                                   0x00000040

//
// DNF_HAS_BOOT_CONFIG - the device has resource assigned by BIOS.  It is considered
//    pseudo-started and need to participate in rebalance.
//

#define DNF_HAS_BOOT_CONFIG                         0x00000080

//
// DNF_BOOT_CONFIG_RESERVED - Indicates the BOOT resources of the device are reserved.
//

#define DNF_BOOT_CONFIG_RESERVED                    0x00000100

//
// DNF_START_REQUEST_PENDING - Indicates the device is being started.
//

#define DNF_START_REQUEST_PENDING                   0x00000200

//
// DNF_NO_RESOURCE_REQUIRED - this devnode's device does not require resource.
//

#define DNF_NO_RESOURCE_REQUIRED                    0x00000400

//
// DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED - to distinguished the
//      DeviceNode->ResourceRequirements is a filtered list or not.
//

#define DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED     0x00000800

//
// Indicates the device's resources are bing assigned (but is not done yet.)
// So don't try assign resource to this device.
//

#define DNF_ASSIGNING_RESOURCES                     0x00001000

//
// DNF_RESOURCE_ASSIGNED - this devnode's resources are assigned by PnP
//

#define DNF_RESOURCE_ASSIGNED                       0x00002000

//
// DNF_RESOURCE_REPORTED - this devnode's resources are reported by PnP
//

#define DNF_RESOURCE_REPORTED                       0x00004000

//
// DNF_RESOURCE_REQUIREMENTS_CHANGED - Indicates the device's resource
//      requirements list has been changed.
//

#define DNF_RESOURCE_REQUIREMENTS_CHANGED           0x00008000

//
// DNF_NON_STOPPED_REBALANC - indicates the device can be restarted with new
//      resources without being stopped.
//

#define DNF_NON_STOPPED_REBALANCE                   0x00010000

//
// DNF_STOPPED - indicates this device is currently stopped for reconfiguration of
//               its resources.
//

#define DNF_STOPPED                                 0x00020000

//
// DNF_STARTED - indicates if the device was started, i.e., its StartDevice
//               irp is processed.
//

#define DNF_STARTED                                 0x00040000

//
// The device's controlling driver is a legacy driver
//

#define DNF_LEGACY_DRIVER                           0x00080000

//
// For the reported detected devices, they are considered started.  We still
// need a flag to indicate we need to enumerate the device.
//

#define DNF_NEED_ENUMERATION_ONLY                   0x00100000

//
// DNF_IO_INVALIDATE_DEVICE_RELATIONS_PENDING - indicate the
//      IoInvalidateDeviceRelations request is pending and therequest needs to
//      be queued after the Query_Device_relation irp is completed.
//

#define DNF_IO_INVALIDATE_DEVICE_RELATIONS_PENDING  0x00200000

//
// Indicates the device is being sent a query device relations irp. So no more
//      q-d-r irp at the same time.
//

#define DNF_BEING_ENUMERATED                        0x00400000

//
// DNF_ENUMERATION_REQUEST_QUEUED - indicate the IoInvalidateDeviceRelations
//      request is queued.  So, new IoInvalidateDeviceRelations can be ignored.
//

#define DNF_ENUMERATION_REQUEST_QUEUED              0x00800000

//
// DNF_ENUMERATION_REQUEST_PENDING - Indicates the QUERY_DEVICE_RELATIONS irp
//      returns pending.
//

#define DNF_ENUMERATION_REQUEST_PENDING             0x01000000

//
// This corresponds to the user-mode CM_PROB_WILL_BE_REMOVED problem value and
// the DN_WILL_BE_REMOVED status flag.
//

#define DNF_HAS_PROBLEM                             0x02000000

//
// DNF_HAS_PRIVATE_PROBLEM - indicates this device reported PNP_DEVICE_FAILED
//  to a IRP_MN_QUERY_PNP_DEVICE_STATE without also reporting
//  PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED.
//

#define DNF_HAS_PRIVATE_PROBLEM                     0x04000000

//
// DNF_REMOVE_PENDING_CLOSES is set after a IRP_MN_SURPRISE_REMOVE is sent
// to a device object.  It is an indicator that IRP_MN_REMOVE_DEVICE should
// be sent to the device object as soon as all of the file objects have gone
// away.
//

#define DNF_REMOVE_PENDING_CLOSES                   0x08000000

//
// DNF_DEVICE_GONE is set when a pdo is no longer returned in a query bus
// relations.  It will then be processed as a surprise remove if started.
// This flag is used to better detect when a device is resurrected, and when
// processing surprise remove, to determine if the devnode should be removed
// from the tree.
//

#define DNF_DEVICE_GONE                             0x10000000

//
// DNF_LEGACY_RESOURCE_DEVICENODE is set for device nodes created for legacy
// resource allocation.
//

#define DNF_LEGACY_RESOURCE_DEVICENODE              0x20000000

//
// DNF_NEEDS_REBALANCE is set for device nodes that trigger rebalance.
//

#define DNF_NEEDS_REBALANCE                         0x40000000

//
// DNF_LOCKED_FOR_EJECT is set on device nodes that are being ejected or are
// related to a device being ejected.
//

#define DNF_LOCKED_FOR_EJECT                        0x80000000

//
// This corresponds to the user-mode the DN_WILL_BE_REMOVED status flag.
//

#define DNUF_WILL_BE_REMOVED                        0x00000001

//
// This corresponds to the user-mode DN_NO_SHOW_IN_DM status flag.
//

#define DNUF_DONT_SHOW_IN_UI                        0x00000002

//
// This flag is set when user-mode lets us know that a reboot is required
// for this device.
//

#define DNUF_NEED_RESTART                           0x00000004

//
// This flag is set to let the user-mode know when a device can be disabled
// it is still possible for this to be TRUE, yet disable to fail, as it's
// a polled flag (see also PNP_DEVICE_NOT_DISABLEABLE)
//

#define DNUF_NOT_DISABLEABLE                        0x00000008

//
// Flags used during shutdown when the IO Verifier is trying to remove all
// PNP devices.
//
// DNUF_SHUTDOWN_QUERIED is set when we issue the QueryRemove to a devnode.
//
// DNUF_SHUTDOWN_SUBTREE_DONE is set once we've issued the QueryRemove to all
// a Devnodes descendants.
//
#define DNUF_SHUTDOWN_QUERIED                       0x00000010
#define DNUF_SHUTDOWN_SUBTREE_DONE                  0x00000020

//
// PNP Bugcheck Subcodes
//
#define PNP_ERR_DUPLICATE_PDO                   1
#define PNP_ERR_INVALID_PDO                     2
#define PNP_ERR_BOGUS_ID                        3
#define PNP_ERR_PDO_ENUMERATED_AFTER_DELETION   4
#define PNP_ERR_ACTIVE_PDO_FREED                5

#define PNP_ERR_DEVICE_MISSING_FROM_EJECT_LIST  6
#define PNP_ERR_UNEXPECTED_ADD_RELATION_ERR     7



//
// IOP_RESOURCE_REQUEST
//

#define QUERY_RESOURCE_LIST                0
#define QUERY_RESOURCE_REQUIREMENTS        1

#define REGISTRY_ALLOC_CONFIG              1
#define REGISTRY_FORCED_CONFIG             2
#define REGISTRY_BOOT_CONFIG               4
#define REGISTRY_OVERRIDE_CONFIGVECTOR     1
#define REGISTRY_BASIC_CONFIGVECTOR        2

///////////////////////////////////////////////////////////////////////////////
//
// pnpmgr.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Private device events
//
DEFINE_GUID( GUID_DEVICE_ARRIVAL,           0xcb3a4009L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_ENUMERATED,        0xcb3a400AL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_ENUMERATE_REQUEST, 0xcb3a400BL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_START_REQUEST,     0xcb3a400CL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_REMOVE_PENDING,    0xcb3a400DL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_QUERY_AND_REMOVE,  0xcb3a400EL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_EJECT,             0xcb3a400FL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_NOOP,              0xcb3a4010L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_SURPRISE_REMOVAL,  0xce5af000L, 0x80dd, 0x11d2, 0xa8, 0x8d, 0x00, 0xa0, 0xc9, 0x69, 0x6b, 0x4b);


//
// Standard interface device classes
//
DEFINE_GUID( GUID_CLASS_VOLUME,  0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x72);
DEFINE_GUID( GUID_CLASS_LPTPORT, 0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x74);
DEFINE_GUID( GUID_CLASS_NET,     0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x75);


///////////////////////////////////////////////////////////////////////////////
//
// po.h
//
///////////////////////////////////////////////////////////////////////////////


#define PO_ORDER_NOT_VIDEO          0x0001
#define PO_ORDER_ROOT_ENUM          0x0002
#define PO_ORDER_PAGABLE            0x0004
#define PO_ORDER_MAXIMUM            0x0007

// notify GDI before this order level
#define PO_ORDER_GDI_NOTIFICATION   (PO_ORDER_PAGABLE)


///////////////////////////////////////////////////////////////////////////////
//
// pop.h
//
///////////////////////////////////////////////////////////////////////////////

//
// constants
//
#define PO_IDLE_SCAN_INTERVAL  1       // scan interval in seconds

//
// Values for ios.Parameters.SystemContext
#define POP_NO_CONTEXT      0
#define POP_FLAG_CONTEXT    1                         // if true, it's flags
#define POP_DEVICE_REQUEST  (0x2 | POP_FLAG_CONTEXT)  // an irp sent by RequestPowerChange
#define POP_INRUSH_CONTEXT  (0x4 | POP_FLAG_CONTEXT)  // the active INRUSH irp
#define POP_COUNT_CONTEXT   0xff000000                // byte used for next counting
#define POP_COUNT_SHIFT     24


#define PO_ERROR            0x00000001
#define PO_WARN             0x00000002
#define PO_BATT             0x00000004
#define PO_PACT             0x00000008
#define PO_NOTIFY           0x00000010
#define PO_THERM            0x00000020
#define PO_THROTTLE         0x00000040
#define PO_HIBERNATE        0x00000080
#define PO_POCALL           0x00000200
#define PO_SYSDEV           0x00000400
#define PO_THERM_DETAIL     0x20000000
#define PO_SIDLE            0x40000000
#define PO_HIBER_MAP        0x80000000

#define POP_SIM_CAPABILITIES                0x00000001
#define POP_SIM_ALL_CAPABILITIES            0x00000002
#define POP_ALLOW_AC_THROTTLE               0x00000004
#define POP_IGNORE_S1                       0x00000008
#define POP_IGNORE_UNSUPPORTED_DRIVERS      0x00000010
#define POP_IGNORE_S3                       0x00000020
#define POP_IGNORE_S2                       0x00000040
#define POP_LOOP_ON_FAILED_DRIVERS          0x00000080
#define POP_CRC_MEMORY                      0x00000100
#define POP_IGNORE_CRC_FAILURES             0x00000200
#define POP_TEST_CRC_MEMORY                 0x00000400
#define POP_DEBUG_HIBER_FILE                0x00000800
#define POP_RESET_ON_HIBER                  0x00001000
#define POP_IGNORE_S4                       0x00002000
#define POP_USE_S4BIOS                      0x00004000
#define POP_IGNORE_HIBER_SYMBOL_UNLOAD      0x00008000
#define POP_ENABLE_HIBER_PERF               0x00010000

//
// Universal Power Data - stored in DeviceObject->DeviceObjectExtension->PowerFlags
//

#define POPF_SYSTEM_STATE       0xf         // 4 bits for S0 to S5
#define POPF_DEVICE_STATE       0xf0        // 4 bits to hold D0 to D3


#define POPF_SYSTEM_ACTIVE      0x100       // True if S irp active at this DO
#define POPF_SYSTEM_PENDING     0x200       // True if S irp pending (0x100 must be 1)
#define POPF_DEVICE_ACTIVE      0x400       // same as SYSTEM_ACTIVE but for DEVICE
#define POPF_DEVICE_PENDING     0x800       // same as SYSTEM_PENDING but for DEVICE


#define PO_PM_USER              0x01    // nice to inform user mode, but not needed
#define PO_PM_REISSUE           0x02    // sleep promotoed to shutdown
#define PO_PM_SETSTATE          0x04    // recomputed something to do with the viable state

#define PO_ACT_IDLE                 0
#define PO_ACT_NEW_REQUEST          1
#define PO_ACT_CALLOUT              2
#define PO_ACT_SET_SYSTEM_STATE     3


//
// Types for POP_ACTION_TRIGGER
//

typedef enum {
    PolicyDeviceSystemButton,
    PolicyDeviceThermalZone,
    PolicyDeviceBattery,
    PolicyInitiatePowerActionAPI,
    PolicySetPowerStateAPI,
    PolicyImmediateDozeS4,
    PolicySystemIdle
} POP_POLICY_DEVICE_TYPE;

#define PO_TRG_USER             0x01    // User action initiated
#define PO_TRG_SYSTEM           0x02    // System action initiated
#define PO_TRG_SYNC             0x20    // Trigger is synchronous
#define PO_TRG_SET              0x80    // Event enabled or disabled

// POP_THERMAL_ZONE.State
#define PO_TZ_NO_STATE      0
#define PO_TZ_READ_STATE    1
#define PO_TZ_SET_MODE      2
#define PO_TZ_SET_ACTIVE    3

// POP_THERMAL_ZONE.Flags
#define PO_TZ_THROTTLING    0x01
#define PO_TZ_CLEANUP       0x80

#define PO_TZ_THROTTLE_SCALE    10      // temp reported in 1/10ths kelin
#define PO_TZ_NO_THROTTLE   (100 * PO_TZ_THROTTLE_SCALE)

// PopCoolingMode
#define PO_TZ_ACTIVE        0
#define PO_TZ_PASSIVE       1
#define PO_TZ_INVALID_MODE  2

//
// Action timeouts
//

#define POP_ACTION_TIMEOUT              30
#define POP_ACTION_CANCEL_TIMEOUT       5


///////////////////////////////////////////////////////////////////////////////
//
// pool.h
//
///////////////////////////////////////////////////////////////////////////////


#define POOL_QUOTA_MASK 8

#define POOL_TYPE_MASK (3)

#define POOL_OVERHEAD ((LONG)GetTypeSize("POOL_HEADER"))


//
// Define pool tracking information.
//

#define POOL_BACKTRACEINDEX_PRESENT 0x8000

///////////////////////////////////////////////////////////////////////////////
//
// range.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Range list structures
//

#define RTLP_RANGE_LIST_ENTRY_MERGED         0x0001

///////////////////////////////////////////////////////////////////////////////
//
// srb.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Port driver error codes
//

#define SP_BUS_PARITY_ERROR         0x0001
#define SP_UNEXPECTED_DISCONNECT    0x0002
#define SP_INVALID_RESELECTION      0x0003
#define SP_BUS_TIME_OUT             0x0004
#define SP_PROTOCOL_ERROR           0x0005
#define SP_INTERNAL_ADAPTER_ERROR   0x0006
#define SP_REQUEST_TIMEOUT          0x0007
#define SP_IRQ_NOT_RESPONDING       0x0008
#define SP_BAD_FW_WARNING           0x0009
#define SP_BAD_FW_ERROR             0x000a
#define SP_LOST_WMI_MINIPORT_REQUEST 0x000b


//
// Return values for SCSI_HW_FIND_ADAPTER.
//

#define SP_RETURN_NOT_FOUND     0
#define SP_RETURN_FOUND         1
#define SP_RETURN_ERROR         2
#define SP_RETURN_BAD_CONFIG    3

//
// Notification Event Types
//

typedef enum _SCSI_NOTIFICATION_TYPE {
    RequestComplete,
    NextRequest,
    NextLuRequest,
    ResetDetected,
    CallDisableInterrupts,
    CallEnableInterrupts,
    RequestTimerCall,
    BusChangeDetected,     /* New */
    WMIEvent,
    WMIReregister
} SCSI_NOTIFICATION_TYPE, *PSCSI_NOTIFICATION_TYPE;

//
// SRB Functions
//

#define SRB_FUNCTION_EXECUTE_SCSI           0x00
#define SRB_FUNCTION_CLAIM_DEVICE           0x01
#define SRB_FUNCTION_IO_CONTROL             0x02
#define SRB_FUNCTION_RECEIVE_EVENT          0x03
#define SRB_FUNCTION_RELEASE_QUEUE          0x04
#define SRB_FUNCTION_ATTACH_DEVICE          0x05
#define SRB_FUNCTION_RELEASE_DEVICE         0x06
#define SRB_FUNCTION_SHUTDOWN               0x07
#define SRB_FUNCTION_FLUSH                  0x08
#define SRB_FUNCTION_ABORT_COMMAND          0x10
#define SRB_FUNCTION_RELEASE_RECOVERY       0x11
#define SRB_FUNCTION_RESET_BUS              0x12
#define SRB_FUNCTION_RESET_DEVICE           0x13
#define SRB_FUNCTION_TERMINATE_IO           0x14
#define SRB_FUNCTION_FLUSH_QUEUE            0x15
#define SRB_FUNCTION_REMOVE_DEVICE          0x16
#define SRB_FUNCTION_WMI                    0x17
#define SRB_FUNCTION_LOCK_QUEUE             0x18
#define SRB_FUNCTION_UNLOCK_QUEUE           0x19

//
// SRB Status Masks
//

#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

//
// SRB Flag Bits
//

#define SRB_FLAGS_QUEUE_ACTION_ENABLE       0x00000002
#define SRB_FLAGS_DISABLE_DISCONNECT        0x00000004
#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008
#define SRB_FLAGS_BYPASS_FROZEN_QUEUE       0x00000010
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000
#define SRB_FLAGS_UNSPECIFIED_DIRECTION      (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)
#define SRB_FLAGS_NO_QUEUE_FREEZE           0x00000100
#define SRB_FLAGS_ADAPTER_CACHE_ENABLE      0x00000200
#define SRB_FLAGS_IS_ACTIVE                 0x00010000
#define SRB_FLAGS_ALLOCATED_FROM_ZONE       0x00020000
#define SRB_FLAGS_SGLIST_FROM_POOL          0x00040000
#define SRB_FLAGS_BYPASS_LOCKED_QUEUE       0x00080000

#define SRB_FLAGS_NO_KEEP_AWAKE             0x00100000

#define SRB_FLAGS_PORT_DRIVER_RESERVED      0x0F000000
#define SRB_FLAGS_CLASS_DRIVER_RESERVED     0xF0000000

//
// Queue Action
//

#define SRB_SIMPLE_TAG_REQUEST              0x20
#define SRB_HEAD_OF_QUEUE_TAG_REQUEST       0x21
#define SRB_ORDERED_QUEUE_TAG_REQUEST       0x22

#define SRB_WMI_FLAGS_ADAPTER_REQUEST       0x01


///////////////////////////////////////////////////////////////////////////////
//
// trackirp.h
//
///////////////////////////////////////////////////////////////////////////////

#define DOE_DESIGNATED_FDO             0x80000000
#define DOE_BOTTOM_OF_FDO_STACK        0x40000000
#define DOE_RAW_FDO                    0x20000000
#define DOE_EXAMINED                   0x10000000
#define DOE_TRACKED                    0x08000000


#define ASSERTFLAG_TRACKIRPS           0x00000001
#define ASSERTFLAG_MONITOR_ALLOCS      0x00000002
#define ASSERTFLAG_POLICEIRPS          0x00000004
#define ASSERTFLAG_MONITORMAJORS       0x00000008
#define ASSERTFLAG_SURROGATE           0x00000010
#define ASSERTFLAG_SMASH_SRBS          0x00000020
#define ASSERTFLAG_CONSUME_ALWAYS      0x00000040
#define ASSERTFLAG_FORCEPENDING        0x00000080
#define ASSERTFLAG_COMPLETEATDPC       0x00000100
#define ASSERTFLAG_COMPLETEATPASSIVE   0x00000200
#define ASSERTFLAG_DEFERCOMPLETION     0x00000800
#define ASSERTFLAG_ROTATE_STATUS       0x00001000
//                                     ----------
#define ASSERTMASK_COMPLETESTYLE       0x00000F80
#define ASSERTFLAG_SEEDSTACK           0x00010000

//
// Disabling HACKHACKS_ENABLED will remove support for all hack code. The
// hack code allows the machine to fully boot in checked builds. Note that
// those hacks can be individually disabled by setting the IovpHackFlags
// variable at boot time.
//
#define HACKHACKS_ENABLED
#define HACKFLAG_FOR_MUP               0x00000001
#define HACKFLAG_FOR_SCSIPORT          0x00000002
#define HACKFLAG_FOR_ACPI              0x00000004
#define HACKFLAG_FOR_BOGUSIRPS         0x00000008


///////////////////////////////////////////////////////////////////////////////
//
// uhcd.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Interrupt Mask register bits
//
#define UHCD_INT_MASK_SHORT_BIT         3
#define UHCD_INT_MASK_SHORT             (1<<UHCD_INT_MASK_SHORT_BIT)

#define UHCD_INT_MASK_IOC_BIT           2
#define UHCD_INT_MASK_IOC               (1<<UHCD_INT_MASK_IOC_BIT)

#define UHCD_INT_MASK_RESUME_BIT        1
#define UHCD_INT_MASK_RESUME            (1<<UHCD_INT_MASK_RESUME_BIT)

#define UHCD_INT_MASK_TIMEOUT_BIT       0
#define UHCD_INT_MASK_TIMEOUT           (1<<UHCD_INT_MASK_TIMEOUT_BIT)


//
// Port Register Bits
//

#define UHCD_PORT_ENABLE_BIT            2
#define UHCD_PORT_ENABLE                (1<<UHCD_PORT_ENABLE_BIT)


//
// Command Register Bits
//

#define UHCD_CMD_RUN_BIT                0
#define UHCD_CMD_RUN                    (USHORT)(1<<UHCD_CMD_RUN_BIT)

#define UHCD_CMD_RESET_BIT              1
#define UHCD_CMD_RESET                  (USHORT)(1<<UHCD_CMD_RESET_BIT)

#define UHCD_CMD_GLOBAL_RESET_BIT       2
#define UHCD_CMD_GLOBAL_RESET           (USHORT)(1<<UHCD_CMD_GLOBAL_RESET_BIT)

#define UHCD_CMD_SUSPEND_BIT            3
#define UHCD_CMD_SUSPEND                (USHORT)(1<<UHCD_CMD_SUSPEND_BIT)

#define UHCD_CMD_FORCE_RESUME_BIT       4
#define UHCD_CMD_FORCE_RESUME           (USHORT)(1<<UHCD_CMD_FORCE_RESUME_BIT)

#define UHCD_CMD_SW_DEBUG_BIT           5
#define UHCD_CMD_SW_DEBUG               (USHORT)(1<<UHCD_CMD_SW_DEBUG_BIT)

#define UHCD_CMD_SW_CONFIGURED_BIT      6
#define UHCD_CMD_SW_CONFIGURED          (USHORT)(1<<UHCD_CMD_SW_CONFIGURED_BIT)

#define UHCD_CMD_MAXPKT_64_BIT          7
#define UHCD_CMD_MAXPKT_64              (USHORT)(1<<UHCD_CMD_MAXPKT_64_BIT)



//
// Status Register Bits
//

#define UHCD_STATUS_USBINT_BIT          0
#define UHCD_STATUS_USBINT              (1<<UHCD_STATUS_USBINT_BIT)

#define UHCD_STATUS_USBERR_BIT          1
#define UHCD_STATUS_USBERR              (1<<UHCD_STATUS_USBERR_BIT)

#define UHCD_STATUS_RESUME_BIT          2
#define UHCD_STATUS_RESUME              (1<<UHCD_STATUS_RESUME_BIT)

#define UHCD_STATUS_PCIERR_BIT          3
#define UHCD_STATUS_PCIERR              (1<<UHCD_STATUS_PCIERR_BIT)

#define UHCD_STATUS_HCERR_BIT           4
#define UHCD_STATUS_HCERR               (1<<UHCD_STATUS_HCERR_BIT)

#define UHCD_STATUS_HCHALT_BIT          5
#define UHCD_STATUS_HCHALT              (1<<UHCD_STATUS_HCHALT_BIT)

// number of bit times in a USB frame based on a 12MHZ SOF clock
#define UHCD_12MHZ_SOF              11936
//
// values for HcFlags
//

// Set to indicate port resources were assigned
#define HCFLAG_GOT_IO                   0x00000001
// Set at initialization to indicate that the base register
// address must be unmapped when the driver is unloaded.
#define HCFLAG_UNMAP_REGISTERS          0x00000002
// Set if we have a USB BIOS on this system
#define HCFLAG_USBBIOS                  0x00000004
// Current state of BW reclimation
#define HCFLAG_BWRECLIMATION_ENABLED    0x00000008
// This flag indicates if the driver needs to cleanup resources
// allocated in start_device.
#define HCFLAG_NEED_CLEANUP             0x00000010
// HC is idle
#define HCFLAG_IDLE                     0x00000020
// set when the rollover int is disabled
#define HCFLAG_ROLLOVER_IDLE            0x00000040
// set when the controller is stopped
#define HCFLAG_HCD_STOPPED              0x00000080
// turn off idle check
#define HCFLAG_DISABLE_IDLE             0x00000100
// work item queued
#define HCFLAG_WORK_ITEM_QUEUED         0x00000200
// hcd has shut down
#define HCFLAG_HCD_SHUTDOWN             0x00000400
// indicates we need to restore HC from hibernate
#define HCFLAG_LOST_POWER               0x00000800
// set when root hub turns off the HC
#define HCFLAG_RH_OFF                   0x00001000

#define HCFLAG_MAP_SX_TO_D3             0x00002000
// set if we will be suspending in this D3
#define HCFLAG_SUSPEND_NEXT_D3          0x00004000

///////////////////////////////////////////////////////////////////////////////
//
// usbdi.h
//
///////////////////////////////////////////////////////////////////////////////

//
//  URB request codes
//

#define URB_FUNCTION_SELECT_CONFIGURATION            0x0000
#define URB_FUNCTION_SELECT_INTERFACE                0x0001
#define URB_FUNCTION_ABORT_PIPE                      0x0002
#define URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL       0x0003
#define URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL    0x0004
#define URB_FUNCTION_GET_FRAME_LENGTH                0x0005
#define URB_FUNCTION_SET_FRAME_LENGTH                0x0006
#define URB_FUNCTION_GET_CURRENT_FRAME_NUMBER        0x0007
#define URB_FUNCTION_CONTROL_TRANSFER                0x0008
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER      0x0009
#define URB_FUNCTION_ISOCH_TRANSFER                  0x000A
#define URB_FUNCTION_RESET_PIPE                      0x001E

//
// These functions correspond
// to the standard commands on the default pipe
//
// direction is implied
//

#define URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE     0x000B
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT   0x0024
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE  0x0028

#define URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE       0x000C
#define URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT     0x0025
#define URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE    0x0029

#define URB_FUNCTION_SET_FEATURE_TO_DEVICE          0x000D
#define URB_FUNCTION_SET_FEATURE_TO_INTERFACE       0x000E
#define URB_FUNCTION_SET_FEATURE_TO_ENDPOINT        0x000F
#define URB_FUNCTION_SET_FEATURE_TO_OTHER           0x0023

#define URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE        0x0010
#define URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE     0x0011
#define URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT      0x0012
#define URB_FUNCTION_CLEAR_FEATURE_TO_OTHER         0x0022

#define URB_FUNCTION_GET_STATUS_FROM_DEVICE         0x0013
#define URB_FUNCTION_GET_STATUS_FROM_INTERFACE      0x0014
#define URB_FUNCTION_GET_STATUS_FROM_ENDPOINT       0x0015
#define URB_FUNCTION_GET_STATUS_FROM_OTHER          0x0021

// direction is specified in TransferFlags

#define URB_FUNCTION_RESERVED0                      0x0016

//
// These are for sending vendor and class commands
// on the default pipe
//
// direction is specified in TransferFlags
//

#define URB_FUNCTION_VENDOR_DEVICE                   0x0017
#define URB_FUNCTION_VENDOR_INTERFACE                0x0018
#define URB_FUNCTION_VENDOR_ENDPOINT                 0x0019
#define URB_FUNCTION_VENDOR_OTHER                    0x0020

#define URB_FUNCTION_CLASS_DEVICE                    0x001A
#define URB_FUNCTION_CLASS_INTERFACE                 0x001B
#define URB_FUNCTION_CLASS_ENDPOINT                  0x001C
#define URB_FUNCTION_CLASS_OTHER                     0x001F

//
// Reserved function codes
//
#define URB_FUNCTION_RESERVED                        0x001D

#define URB_FUNCTION_GET_CONFIGURATION               0x0026
#define URB_FUNCTION_GET_INTERFACE                   0x0027

#define URB_FUNCTION_LAST                            0x0029




///////////////////////////////////////////////////////////////////////////////
//
// usbhub.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Hub and Port status defined below also apply to StatusChnage bits
//
#define HUB_STATUS_LOCAL_POWER      0x01
#define HUB_STATUS_OVER_CURRENT     0x02

#define PORT_STATUS_CONNECT         0x001
#define PORT_STATUS_ENABLE          0x002
#define PORT_STATUS_SUSPEND         0x004
#define PORT_STATUS_OVER_CURRENT    0x008
#define PORT_STATUS_RESET           0x010
#define PORT_STATUS_POWER           0x100
#define PORT_STATUS_LOW_SPEED       0x200


#define HUBFLAG_NEED_CLEANUP        0x00000001
#define HUBFLAG_ENABLED_FOR_WAKEUP  0x00000002
#define HUBFLAG_DEVICE_STOPPING     0x00000004
#define HUBFLAG_HUB_FAILURE         0x00000008
#define HUBFLAG_SUPPORT_WAKEUP      0x00000010
#define HUBFLAG_HUB_STOPPED         0x00000020
#define HUBFLAG_HUB_BUSY            0x00000040
#define HUBFLAG_PENDING_WAKE_IRP    0x00000080
#define HUBFLAG_PENDING_PORT_RESET  0x00000100
#define HUBFLAG_HUB_HAS_LOST_BRAINS 0x00000200

#define USBH_MAX_ENUMERATION_ATTEMPTS   3

//
// Common fields for Pdo and Fdo extensions
//
#define EXTENSION_TYPE_PORT 0x54524f50      // "PORT"
#define EXTENSION_TYPE_HUB  0x20425548      // "HUB "
#define EXTENSION_TYPE_PARENT  0x50525400   // "PRT "
#define EXTENSION_TYPE_FUNCTION  0xfefefeff   // ""


//
// values for PortPdoFlags
//

#define PORTPDO_DEVICE_IS_HUB               0x00000001
#define PORTPDO_DEVICE_IS_PARENT            0x00000002
#define PORTPDO_DEVICE_ENUM_ERROR           0x00000004
#define PORTPDO_LOW_SPEED_DEVICE            0x00000008
#define PORTPDO_REMOTE_WAKEUP_SUPPORTED     0x00000010
#define PORTPDO_REMOTE_WAKEUP_ENABLED       0x00000020
#define PORTPDO_DELETED_PDO                 0x00000040
#define PORTPDO_DELETE_PENDING              0x00000080
#define PORTPDO_NEED_RESET                  0x00000100
#define PORTPDO_STARTED                     0x00000200
#define PORTPDO_WANT_POWER_FEATURE          0x00000400
#define PORTPDO_SYM_LINK                    0x00000800
#define PORTPDO_DEVICE_FAILED               0x00001000
#define PORTPDO_USB_SUSPEND                 0x00002000
#define PORTPDO_OVERCURRENT                 0x00004000
#define PORTPDO_DD_REMOVED                  0x00008000
#define PORTPDO_NOT_ENOUGH_POWER            0x00010000
#define PORTPDO_PDO_RETURNED                0x00020000
#define PORTPDO_NO_BANDWIDTH                0x00040000
#define PORTPDO_RESET_PENDING               0x00080000


///////////////////////////////////////////////////////////////////////////////
//
// wdm.h
//
///////////////////////////////////////////////////////////////////////////////


//
// POWER minor function codes
//
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03

// begin_ntminiport
//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)


///////////////////////////////////////////////////////////////////////////////
//
// wdmaud.h
//
///////////////////////////////////////////////////////////////////////////////

#define WDMAUD_CTL_CODE CTL_CODE

#define IOCTL_SOUND_BASE    FILE_DEVICE_SOUND
#define IOCTL_WDMAUD_BASE   0x0000
#define IOCTL_WAVE_BASE     0x0040
#define IOCTL_MIDI_BASE     0x0080
#define IOCTL_MIXER_BASE    0x00C0

#define IOCTL_WDMAUD_INIT                      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_ADD_DEVNODE               WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_REMOVE_DEVNODE            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_CAPABILITIES          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_NUM_DEVS              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_OPEN_PIN                  WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_CLOSE_PIN                 WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_VOLUME                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_SET_VOLUME                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0008, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_EXIT                      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0009, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_SET_PREFERRED_DEVICE      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x000a, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_WAVE_OUT_PAUSE            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_PLAY             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_RESET            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP        WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_GET_POS          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN        WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_WAVE_IN_STOP              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_RECORD            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0011, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_RESET             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0012, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_GET_POS           WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0013, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_READ_PIN          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0014, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIDI_OUT_RESET            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIDI_IN_STOP              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_RECORD            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0011, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_RESET             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0012, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_READ_PIN          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0013, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIXER_OPEN                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_CLOSE               WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETLINEINFO         WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETLINECONTROLS     WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)


///////////////////////////////////////////////////////////////////////////////
//
// wdguid.h
//
///////////////////////////////////////////////////////////////////////////////
//
// Device events that can be broadcasted to drivers and user-mode apps.
//
DEFINE_GUID( GUID_HWPROFILE_QUERY_CHANGE,          0xcb3a4001L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_HWPROFILE_CHANGE_CANCELLED,      0xcb3a4002L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_HWPROFILE_CHANGE_COMPLETE,       0xcb3a4003L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_DEVICE_INTERFACE_ARRIVAL,        0xcb3a4004L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_DEVICE_INTERFACE_REMOVAL,        0xcb3a4005L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_QUERY_REMOVE,      0xcb3a4006L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_REMOVE_CANCELLED,  0xcb3a4007L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_REMOVE_COMPLETE,   0xcb3a4008L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_PNP_CUSTOM_NOTIFICATION,         0xACA73F8EL, 0x8D23, 0x11D1, 0xAC, 0x7D, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );
DEFINE_GUID( GUID_PNP_POWER_NOTIFICATION,          0xC2CF0660L, 0xEB7A, 0x11D1, 0xBD, 0x7F, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );
#endif

#endif // _EXTFLAGS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\struc.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    struc.c

Abstract:

    WinDbg Extension Api
    implements !_devh   dumps USBD_DEVICE_HANDLE
               !_piph   dumps USBD_PIPE_HANDLE_I 
               !_endp   dumps HCD_ENDPOINT
               !_cmbf   dumps USBPORT_COMMON_BUFFER
               !_tfer   dumps HCD_TRANSFER_CONTEXT
               !_mdl    dumps MDL
               !_cfgh   dumps 

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usbhcdkd.h"


VOID    
DumpDeviceHandle(
    MEMLOC MemLoc
    )
{
    MEMLOC l, t;
    USB_DEVICE_DESCRIPTOR dd;
    ULONG f, cb;
    UCHAR cs[] = "_USBD_DEVICE_HANDLE";
    STRUC_ENTRY DevHandle[] = {
        "Sig", FT_SIG,
        "DeviceAddress", FT_USHORT,
        "Tt", FT_PTR,
        "PendingUrbs", FT_ULONG,
        "PortNumber", FT_USHORT,
        "HubDeviceHandle", FT_PTR,
        "ConfigurationHandle", FT_PTR,
        "DeviceSpeed", FT_DEVSPEED
    };
    FLAG_TABLE devFlags[] = {
        "USBPORT_DEVICEFLAG_ROOTHUB", USBPORT_DEVICEFLAG_ROOTHUB,
        "USBPORT_DEVICEFLAG_FREED_BY_HUB", USBPORT_DEVICEFLAG_FREED_BY_HUB
    }; 

    PrintfMemLoc("*USBD_DEVICE_HANDLE ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &DevHandle[0], sizeof(DevHandle)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "DeviceFlags");
    dprintf("DeviceFlags: %08.8x\n", f); 
    UsbDumpFlags(f, devFlags, 
        sizeof(devFlags)/sizeof(FLAG_TABLE));

    dprintf("-pipe list-\n");

    l = MemLoc + UsbFieldOffset(cs, "PipeHandleList");
    PrintfMemLoc("\t(PH) PipeHandleList: ", 
            l, 
            ListEmpty(l));    

    dprintf("-tt list-\n");
    l = MemLoc + UsbFieldOffset(cs, "TtList");
    PrintfMemLoc("\t(TT) TtList: ", 
            l, 
            ListEmpty(l));                

    t = MemLoc + UsbFieldOffset(cs, "DeviceDescriptor");
    PrintfMemLoc("DeviceDescriptor ", t, "\n");

    ReadMemory(t,
               &dd,
               sizeof(dd),
               &cb);

    DumpUSBDescriptor(&dd);
    
}


VOID    
DumpTt(
    MEMLOC MemLoc
    )
{
    ULONG f, i;
    UCHAR cs[] = "_TRANSACTION_TRANSLATOR";
    UCHAR s[64];
    STRUC_ENTRY tt[] = {
        "Sig", FT_SIG,
        "DeviceAddress", FT_USHORT,
        "PdoDeviceObject", FT_PTR,
    };

    PrintfMemLoc("*TRANSACTION_TRANSLATOR ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &tt[0], sizeof(tt)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "TotalBusBandwidth");
    dprintf("TotalBusBandwidth: %d\n", f); 
    
    for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
        sprintf(s, "BandwidthTable[%d]", i);
               
        dprintf("\tBandwidthTable[%d] - %d\n", i,
            UsbReadFieldUlong(MemLoc, cs, s)); 
    }        
    
}


VOID    
DumpIPipe(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_USBD_PIPE_HANDLE_I";
    ULONG f, cb;
    STRUC_ENTRY p[] = {
        "Sig", FT_SIG,
        "Endpoint", FT_PTR,
        "UsbdPipeFlags", FT_ULONG,
    };
    FLAG_TABLE pipeStateFlags[] = {
        "USBPORT_PIPE_STATE_CLOSED", USBPORT_PIPE_STATE_CLOSED,
         };   
    MEMLOC tmp;  
    USB_ENDPOINT_DESCRIPTOR ed;

    f = UsbReadFieldUlong(MemLoc, cs, "PipeStateFlags"); 
    dprintf("PipeStateFlags: %08.8x\n", f);
    UsbDumpFlags(f, pipeStateFlags, 
        sizeof(pipeStateFlags)/sizeof(FLAG_TABLE));
    UsbDumpStruc(MemLoc, cs, 
        &p[0], sizeof(p)/sizeof(STRUC_ENTRY));

    tmp = MemLoc + UsbFieldOffset(cs, "EndpointDescriptor");
    PrintfMemLoc("EndpointDescriptor ", tmp, "\n");

    ReadMemory(tmp,
               &ed,
               sizeof(ed),
               &cb);

    DumpUSBDescriptor(&ed);

}


VOID    
DumpIsoPacket(
    MEMLOC MemLoc,
    ULONG Idx
    )
{
    UCHAR cs[] = "_MINIPORT_ISO_PACKET";
    ULONG f, c, i;
    UCHAR s[32]; 
    STRUC_ENTRY t[] = {
        "Length", FT_ULONG,
        "LengthTransferred", FT_ULONG,
        "FrameNumber", FT_ULONG,
        "MicroFrameNumber", FT_ULONG,
        "UsbdStatus", FT_ULONG,
        "BufferPointerCount", FT_ULONG,
        "BufferPointer0Length", FT_ULONG,
        "BufferPointer0.Hw32", FT_ULONG,
        "BufferPointer1Length", FT_ULONG,
        "BufferPointer1.Hw32", FT_ULONG,         
    };

    sprintf(s, "*PACKET[%d] - ", Idx);
    PrintfMemLoc(s, MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));
}


VOID    
DumpIsoTransferContext(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_MINIPORT_ISO_TRANSFER";
    UCHAR s[64];
    ULONG f, c, i, p;
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "PacketCount", FT_ULONG,
        "SystemAddress", FT_PTR,
    };

    PrintfMemLoc("*MINIPORT_ISO_TRANSFER ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));
        
    p = UsbReadFieldUlong(MemLoc, cs, "PacketCount");
    for (i=0; i<p; i++) {
        MEMLOC t;
        
        sprintf(s, "Packets[%d]", i);
        t = MemLoc + UsbFieldOffset(cs, s);

        DumpIsoPacket(t, i);
    }
}


VOID    
DumpTransferContext(
    MEMLOC MemLoc
    )
{
    MEMLOC sgList;
    USBPORT_TRANSFER_DIRECTION d;
    UCHAR cs[] = "_HCD_TRANSFER_CONTEXT";
    ULONG f, c, i;
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "TotalLength", FT_ULONG,
        "MillisecTimeout", FT_ULONG,
        "MiniportBytesTransferred", FT_ULONG,
        "MiniportFrameCompleted", FT_ULONG,
        "TimeoutTime", FT_ULONG64,
        "Irp", FT_PTR,
        "Urb", FT_PTR,
        "Transfer", FT_PTR,
        "CompleteEvent", FT_PTR,
        "MapRegisterBase", FT_PTR,
        "NumberOfMapRegisters", FT_ULONG,
        "Endpoint", FT_PTR,
        "MiniportContext", FT_PTR,
        "IsoTransfer", FT_PTR,
    };
    FLAG_TABLE txFlags[] = {
        "USBPORT_TXFLAG_CANCELED", USBPORT_TXFLAG_CANCELED,
        "USBPORT_TXFLAG_MAPPED", USBPORT_TXFLAG_MAPPED,
        "USBPORT_TXFLAG_HIGHSPEED", USBPORT_TXFLAG_HIGHSPEED,
    
        "USBPORT_TXFLAG_IN_MINIPORT", USBPORT_TXFLAG_IN_MINIPORT,
        "USBPORT_TXFLAG_ABORTED", USBPORT_TXFLAG_ABORTED,
        "USBPORT_TXFLAG_ISO", USBPORT_TXFLAG_ISO,
        "USBPORT_TXFLAG_TIMEOUT", USBPORT_TXFLAG_TIMEOUT,

        "USBPORT_TXFLAG_TIMEOUT", USBPORT_TXFLAG_TIMEOUT,
        "USBPORT_TXFLAG_DEVICE_GONE", USBPORT_TXFLAG_DEVICE_GONE,
        "USBPORT_TXFLAG_SPLIT_CHILD", USBPORT_TXFLAG_SPLIT_CHILD,
        "USBPORT_TXFLAG_MPCOMPLETED", USBPORT_TXFLAG_MPCOMPLETED,
        "USBPORT_TXFLAG_SPLIT", USBPORT_TXFLAG_SPLIT
         }; 

    PrintfMemLoc("*TRANSFER ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "Flags");
    dprintf("Flags: 0x%08.8x\n", f);    
    UsbDumpFlags(f, txFlags, 
            sizeof(txFlags)/sizeof(FLAG_TABLE));

    d = UsbReadFieldUlong(MemLoc, cs, "Direction");   
    dprintf("Direction: ");
    switch (d) {
    case NotSet: 
        dprintf("NotSet\n");
        break;
    case ReadData:
        dprintf("ReadData\n");
        break;
    case WriteData:
        dprintf("WriteData\n");
        break;
    }

    {
    MEMLOC tmp;
    STRUC_ENTRY tp[] = {
        "TransferFlags", FT_ULONG,
        "TransferBufferLength", FT_ULONG,
        "SetupPacket[0]", FT_UCHAR,
        "SetupPacket[1]", FT_UCHAR,
        "SetupPacket[2]", FT_UCHAR,
        "SetupPacket[3]", FT_UCHAR,
        "SetupPacket[4]", FT_UCHAR,
        "SetupPacket[5]", FT_UCHAR,
        "SetupPacket[6]", FT_UCHAR,
        "SetupPacket[7]", FT_UCHAR,
        };
    tmp = MemLoc + UsbFieldOffset(cs, "Tp");
    dprintf("<TRANSFER_PARAMETERS>\n");
    UsbDumpStruc(tmp, "_TRANSFER_PARAMETERS", 
        &tp[0], sizeof(tp)/sizeof(STRUC_ENTRY));
 
    }       


    {
    STRUC_ENTRY sg[] = {
        "SgFlags", FT_ULONG,
        "MdlVirtualAddress", FT_PTR,
        "MdlSystemAddress", FT_PTR,
        "SgCount", FT_ULONG,
        };
    sgList = MemLoc + UsbFieldOffset(cs, "SgList");
    dprintf("<SG_LIST>\n");
    UsbDumpStruc(sgList, "_TRANSFER_SG_LIST", 
        &sg[0], sizeof(sg)/sizeof(STRUC_ENTRY));
 
    c = UsbReadFieldUlong(sgList, "_TRANSFER_SG_LIST", "SgCount");
    }
    dprintf("<SG_LIST(%d)>\n", c);
    for (i=0; i< c; i++) {
        UCHAR s[64];
        MEMLOC tmp;
        STRUC_ENTRY sg[] = {
            "StartOffset", FT_ULONG,
            "Length", FT_ULONG,
            "LogicalAddress", FT_PTR,
            "SystemAddress", FT_PTR
            };
        sprintf(s, "SgEntry[%d]", i);            
        tmp = sgList + UsbFieldOffset("_TRANSFER_SG_LIST", s);
        dprintf("<SG_ENTRY> [%d]\n", i);
        UsbDumpStruc(tmp, "TRANSFER_SG_ENTRY32", 
            &sg[0], sizeof(sg)/sizeof(STRUC_ENTRY));
    }    
#if 0
        // dump the sg list 
        dprintf("SGList.SgFlags: %08.8x\n", transfer->SgList.SgFlags);
        dprintf("SGList.MdlVirtualAddress: %08.8x\n", transfer->SgList.MdlVirtualAddress);
        dprintf("SGList.SgCount: %08.8x\n", transfer->SgList.SgCount);
        for (i=0; i< transfer->SgList.SgCount; i++) {
             dprintf("SGList.SgEntry[%d].StartOffset: %08.8x\n", 
                i, transfer->SgList.SgEntry[i].StartOffset);
             dprintf("SGList.SgEntry[%d].Length: %08.8x\n", 
                i, transfer->SgList.SgEntry[i].Length);            
             dprintf("SGList.SgEntry[%d].LogicalAddress: %08.8x\n", 
                i, transfer->SgList.SgEntry[i].LogicalAddress);             
        }

        if (transfer->Flags & USBPORT_TXFLAG_ISO) {
            DumpIsoTransferContext((ULONG) transfer->IsoTransfer);
        }
        
        free(transfer);

    }
#endif    
}


VOID    
EpStatus(
    MP_ENDPOINT_STATUS status
    )
{
    switch(status) {
    case ENDPOINT_STATUS_RUN:
        dprintf("\t ENDPOINT_STAUS_RUN\n");
        break;
    case ENDPOINT_STATUS_HALT:
        dprintf("\t ENDPOINT_STATUS_HALT\n");
        break;
    }
}


VOID    
EpState(
    MP_ENDPOINT_STATE state
    )
{
    switch(state) {
    case ENDPOINT_TRANSITION:
        dprintf("\t ENDPOINT_TRANSITION\n");
        break;
    case ENDPOINT_IDLE:
        dprintf("\t ENDPOINT_IDLE\n");
        break;
    case ENDPOINT_PAUSE: 
        dprintf("\t ENDPOINT_PAUSE\n");
        break;
    case ENDPOINT_ACTIVE: 
        dprintf("\t ENDPOINT_ACTIVE\n");
        break;
    case ENDPOINT_REMOVE: 
        dprintf("\t ENDPOINT_REMOVE\n");
        break;
    case ENDPOINT_CLOSED:
        dprintf("\t ENDPOINT_CLOSED\n");
        break;
    }
}


VOID    
EpType(
    ENDPOINT_TRANSFER_TYPE Typ
    )
{
    switch(Typ) {
    case Isochronous:
        dprintf("Isochronous");
        break;
    case Control:
        dprintf("Control");
        break;
    case Bulk: 
        dprintf("Bulk");
        break;
    case Interrupt: 
        dprintf("Interrupt");
        break;
    }
}


VOID    
EpDir(
    ENDPOINT_TRANSFER_DIRECTION Dir
    )
{
    switch(Dir) {
    case In:
        dprintf("In");
        break;
    case Out:
        dprintf("Out");
        break;
    }
}

VOID    
EpSpeed(
    DEVICE_SPEED Speed
    )
{
    switch(Speed) {
    case LowSpeed:
        dprintf("LowSpeed");
        break;
    case FullSpeed:
        dprintf("FullSpeed");
        break;
    case HighSpeed:
        dprintf("HighSpeed");
        break;        
    }
}


VOID    
DumpEndpointParameters(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_ENDPOINT_PARAMETERS";    

    PrintfMemLoc("-endpoint Parameters- ", MemLoc, "\n");

    dprintf("\tDeviceAddress: 0x%x\n", 
         UsbReadFieldUshort(MemLoc, cs, "DeviceAddress"));
    dprintf("\tEndpointAddress: 0x%x\n", 
         UsbReadFieldUshort(MemLoc, cs, "EndpointAddress"));
    dprintf("\tMaxPacketSize: 0x%08.8x\n", 
        UsbReadFieldUshort(MemLoc, cs, "MaxPacketSize"));
    dprintf("\tPeriod: 0x%0.2x\n", 
        UsbReadFieldUchar(MemLoc, cs, "Period"));
    dprintf("\tMaxPeriod: 0x%0.2x\n", 
        UsbReadFieldUchar(MemLoc, cs, "MaxPeriod"));        
    dprintf("\tBandwidth: 0x%08.8x %d Bits/Sec\n", 
        UsbReadFieldUlong(MemLoc, cs, "Bandwidth"),
        UsbReadFieldUlong(MemLoc, cs, "Bandwidth"));
    dprintf("\tSchedule Offset: %d\n",
        UsbReadFieldUlong(MemLoc, cs, "ScheduleOffset"));
    dprintf("\tType: ");
    EpType(UsbReadFieldUlong(MemLoc, cs, "TransferType"));
    dprintf("\n\tDirection: ");
    EpDir(UsbReadFieldUlong(MemLoc, cs, "TransferDirection"));
    dprintf("\n");
    
    PrintfMemLoc("\tCommonBufferVa: ",   
        UsbReadFieldPtr(MemLoc, cs, "CommonBufferVa"),
        "\n");
    
    dprintf("\tCommonBufferPhys (32 bit): %08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "CommonBufferPhys"));
    dprintf("\tCommonBufferBytes: %08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "CommonBufferBytes"));
    dprintf("\tEndpointFlags: 0x%08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "EndpointFlags"));
    dprintf("\tMaxTransferSize: %08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "MaxTransferSize"));
    dprintf("\tDeviceSpeed: %d - ", 
        UsbReadFieldUlong(MemLoc, cs, "DeviceSpeed"));
    EpSpeed(UsbReadFieldUlong(MemLoc, cs, "DeviceSpeed"));
    dprintf("\n");

    dprintf("\tTtDeviceAddress: 0x%x - ", 
        UsbReadFieldUlong(MemLoc, cs, "TtDeviceAddress"));
    dprintf("TtNumber: %d - \n", 
        UsbReadFieldUlong(MemLoc, cs, "TtNumber"));
    dprintf("\tInterruptScheduleMask: x%x - \n", 
        UsbReadFieldUchar(MemLoc, cs, "InterruptScheduleMask"));
    dprintf("\tSplitCompletionMask: x%x - \n", 
        UsbReadFieldUchar(MemLoc, cs, "SplitCompletionMask"));
    dprintf("\tTransactionsPerMicroframe: x%x - \n", 
        UsbReadFieldUchar(MemLoc, cs, "TransactionsPerMicroframe"));        
    dprintf("\tMuxPacketSize: x%x - \n", 
        UsbReadFieldUshort(MemLoc, cs, "MuxPacketSize"));            
    dprintf("\tOrdinal: x%x - \n", 
        UsbReadFieldUlong(MemLoc, cs, "Ordinal"));                
}


VOID    
DumpEndpoint(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_HCD_ENDPOINT";
    SIG s;
    FLAG_TABLE epFlags[] = {
        "EPFLAG_MAP_XFERS", EPFLAG_MAP_XFERS,
        "EPFLAG_ROOTHUB", EPFLAG_ROOTHUB,
        "EPFLAG_NUKED", EPFLAG_NUKED,
        "EPFLAG_VIRGIN", EPFLAG_VIRGIN,
        "EPFLAG_DEVICE_GONE", EPFLAG_DEVICE_GONE
         };     
    MP_ENDPOINT_STATUS epStatus;
    MP_ENDPOINT_STATE epState;
    ULONG f;
    MEMLOC l;
         
    PrintfMemLoc("*ENDPOINT ", MemLoc, "\n");

    s.l = UsbReadFieldUlong(MemLoc, cs, "Sig");
    Sig(s.l, "");
    if (s.l != SIG_ENDPOINT) {
        BadSig(s.l, SIG_ENDPOINT);
        return;
    }
    f = UsbReadFieldUlong(MemLoc, cs, "Flags");
    dprintf("Flags: %08.8x\n", f);    
    UsbDumpFlags(f, epFlags, 
        sizeof(epFlags)/sizeof(FLAG_TABLE));

    
    dprintf("Busy: %d\n", 
        UsbReadFieldUlong(MemLoc, cs, "Busy"));    

    PrintfMemLoc("FdoDeviceObject:", 
        UsbReadFieldPtr(MemLoc, cs, "DeviceDescriptor"),
        "\n");
        
    epStatus = UsbReadFieldUlong(MemLoc, cs, "CurrentStatus");
    dprintf("CurrentStatus: %08.8x\n", epStatus); 
    EpStatus(epStatus);     

    epState = UsbReadFieldUlong(MemLoc, cs, "CurrentState");
    dprintf("CurrentState: %08.8x\n", epState); 
    EpState(epState);  
        
    epState = UsbReadFieldUlong(MemLoc, cs, "NewState");
    dprintf("NewState: %08.8x\n", epState); 
    EpState(epState);  
        
    dprintf("StateChangeFrame: %08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "StateChangeFrame"));
    
    PrintfMemLoc("EpWorkerFunction:", 
        UsbReadFieldPtr(MemLoc, cs, "EpWorkerFunction"),
        "\n");
    PrintfMemLoc("CommonBuffer:", 
        UsbReadFieldPtr(MemLoc, cs, "CommonBuffer"),
        "\n");        
        
    PrintfMemLoc("Usb2LibEpContext:", 
        UsbReadFieldPtr(MemLoc, cs, "Usb2LibEpContext"),
        "\n");
             
    PrintfMemLoc("MiniportContext: ", 
            MemLoc + UsbFieldOffset(cs, "MiniportEndpointData"),
            "\n");
//    dprintf("HubDeviceAddress: 0x%08.8x\n", endpoint.HubDeviceAddress);
//    dprintf("PortTTNumber: 0x%08.8x\n", endpoint.PortTTNumber);

    DumpEndpointParameters(MemLoc + UsbFieldOffset(cs, "Parameters"));        

    dprintf("-lists-\n");

    l = MemLoc + UsbFieldOffset(cs, "ActiveList");
    PrintfMemLoc("\t(AL) ActiveList: ", 
            l, 
            ListEmpty(l));            
            
    l = MemLoc + UsbFieldOffset(cs, "PendingList");
    PrintfMemLoc("\t(PL) PendingList: ", 
            l, 
            ListEmpty(l));   
            
    l = MemLoc + UsbFieldOffset(cs, "CancelList");
    PrintfMemLoc("\t(CL) CancelList: ", 
            l, 
            ListEmpty(l));   
            
    l = MemLoc + UsbFieldOffset(cs, "AbortIrpList");
    PrintfMemLoc("\t(AI) AbortIrpList: ", 
            l, 
            ListEmpty(l));
            
//    LIST_ENTRY AbortIrpList;
#if 0
    // for linkage to global endpoint list
    dprintf("-linkage-\n");
    dprintf("\tGlobalLink.Flink: %08.8x\n", endpoint.GlobalLink.Flink);
    dprintf("\tGlobalLink.Blink: %08.8x\n", endpoint.GlobalLink.Blink);

    dprintf("\tAttendLink.Flink: %08.8x\n", endpoint.AttendLink.Flink);
    dprintf("\tAttendLink.Blink: %08.8x\n", endpoint.AttendLink.Blink);

    dprintf("\tStateLink.Flink: %08.8x\n", endpoint.StateLink.Flink);
    dprintf("\tStateLink.Blink: %08.8x\n", endpoint.StateLink.Blink);

    dprintf("\tClosedLink.Flink: %08.8x\n", endpoint.ClosedLink.Flink);
    dprintf("\tClosedLink.Blink: %08.8x\n", endpoint.ClosedLink.Blink);
#endif
}


VOID    
DumpCommonBuffer(
    ULONG MemLoc,
    ULONG Level
    )
{
    USBPORT_COMMON_BUFFER header;
    ULONG result;
 
    if (!ReadMemory (MemLoc, &header, sizeof (header), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    dprintf("*COMMON_BUFFER_HEADER %08.8x\n", MemLoc);
    Sig(header.Sig, "");
    if (header.Sig != SIG_CMNBUF) {
        BadSig(header.Sig, SIG_CMNBUF);
        return;
    }   
    dprintf("Flags: %08.8x\n", header.Flags);
    dprintf("TotalLength: %08.8x\n", header.TotalLength);
    dprintf("VirtualAddress: %08.8x\n", header.VirtualAddress);
    dprintf("BaseVa: %08.8x\n", header.BaseVa);
    dprintf("BasePhys: %08.8x\n", header.BasePhys);
    dprintf("MiniportLength: %08.8x\n", header.MiniportLength);
    dprintf("PadLength: %08.8x\n", header.PadLength);
    dprintf("MiniportVa: %08.8x\n", header.MiniportVa);
    dprintf("MiniportPhys: %08.8x\n", header.MiniportPhys);

}


VOID    
DumpMdl(
    ULONG MemLoc
    )
{
    PMDL mdl;
    MDL tmpMdl;
    PUCHAR buffer;
    ULONG result, count, i;
    PULONG pages;

    if (!ReadMemory (MemLoc, &tmpMdl, sizeof (tmpMdl), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    buffer = (PUCHAR) malloc(tmpMdl.Size);
    
    if (buffer != NULL) { 
    
        if (!ReadMemory (MemLoc, buffer, tmpMdl.Size, &result)) {
            BadMemLoc(MemLoc);
            free(buffer);
            return;
        }
        
        mdl = (PMDL) buffer;
        pages = (PULONG) (buffer+sizeof(MDL));

        dprintf("*MDL %08.8x\n", MemLoc);
        dprintf("Size: %d\n", mdl->Size);
        dprintf("Flags: %04.4x\n", mdl->MdlFlags);
        dprintf("MappedSystemVa: %08.8x\n", mdl->MappedSystemVa);
        dprintf("StartVa: %08.8x\n", mdl->StartVa);
        dprintf("ByteCount: %08.8x\n", mdl->ByteCount);
        dprintf("ByteOffset: %08.8x\n", mdl->ByteOffset);
        count = (mdl->Size - sizeof(MDL)) / sizeof(ULONG);
        dprintf("<Page Count> %d\n", count);
        
        for (i = 0; i < count; i++) {
            dprintf("Page[%d]: %08.8x\n", i, *pages);
            pages++;
        }

        free(buffer);
    }        
}


VOID    
DumpInterfaceHandle(
    MEMLOC MemLoc
    )
{   
    UCHAR cs[] = "_USBD_INTERFACE_HANDLE_I";
    ULONG f, cb;
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "HasAlternateSettings", FT_UCHAR,
    };
    UCHAR c, i;
    MEMLOC tmp;
    USB_INTERFACE_DESCRIPTOR id;
    

    dprintf("***\n");
    PrintfMemLoc("*INTERFACE_HANDLE ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    c = UsbReadFieldUchar(MemLoc, cs, 
        "InterfaceDescriptor.bNumEndpoints");

    tmp = MemLoc + UsbFieldOffset(cs, "InterfaceDescriptor");
    PrintfMemLoc("InterfaceDescriptor ", tmp, "\n");

    ReadMemory(tmp,
               &id,
               sizeof(id),
               &cb);

    DumpUSBDescriptor(&id);
    for (i=0; i<c; i++) {
        UCHAR s[32];
        dprintf("pipe[%02.2d] ", i);
        sprintf(s, "PipeHandle[%d]", i);
        PrintfMemLoc("_piph ", 
            MemLoc + UsbFieldOffset(cs, s), "\n");
    }
    dprintf("***\n");
}


VOID
DumpInterfaceHandleList(
    MEMLOC HeadMemLoc
    )
{

    MEMLOC flink, blink, memLoc;
    UCHAR cs[] = "_USBD_INTERFACE_HANDLE_I";
    ULONG i=0;
    
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    while (flink != HeadMemLoc) {
    
        memLoc = flink - UsbFieldOffset(cs, 
            "InterfaceLink");

        dprintf ("[%d] iHandle (_ihan): ", i);
                    
        PrintfMemLoc(" ", memLoc, "\n");             
                    
        i++;

        flink = UsbReadFieldPtr(memLoc, 
            cs, "InterfaceLink.Flink");
        DumpInterfaceHandle(memLoc);            

    }
}


VOID    
DumpUsbDescriptorMemLoc(
    ULONG MemLoc
    )
{
#if 0
    USB_COMMON_DESCRIPTOR cd;
    ULONG result;
    ULONG listMemLoc;
    PUCHAR tmp;
 
    if (!ReadMemory (MemLoc, &cd, sizeof (cd), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    dprintf("*USB DESCRIPTOR %08.8x length:%d type:%d Next->%08.8x\n", 
        MemLoc, cd.bLength, cd.bDescriptorType,
        MemLoc+cd.bLength);

    tmp = malloc(cd.bLength);
    if (tmp) {
    
        if (!ReadMemory (MemLoc, tmp, cd.bLength, &result)) {
            BadMemLoc(MemLoc);
            return;
        }            

        DumpUSBDescriptor(tmp);
        
        free (tmp);        
    }    
#endif    
}    

VOID
DumpCfgDescriptorMemLoc(
    ULONG MemLoc
    )
{
#if 0
    USB_CONFIGURATION_DESCRIPTOR cf;
    PUSB_COMMON_DESCRIPTOR cd;
    ULONG result;
    PUCHAR tmp, tmp2;
 
    if (!ReadMemory (MemLoc, &cf, sizeof(cf), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    dprintf("*USB CONFIG DESCRIPTOR %08.8x\n", 
        MemLoc);

    tmp = malloc(cf.wTotalLength);
    if (tmp) {
    
        if (!ReadMemory (MemLoc, tmp, cf.wTotalLength, &result)) {
            BadMemLoc(MemLoc);
            return;
        }            

        tmp2 = tmp;
        while (tmp2-tmp < cf.wTotalLength) {
            cd = (PUSB_COMMON_DESCRIPTOR) tmp2;
            DumpUSBDescriptor(tmp2);
            tmp2+=cd->bLength;
        }            
        
        free (tmp);        
    }    
#endif    
}    


VOID    
DumpConfigHandle(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_USBD_CONFIG_HANDLE";
    SIG s;
    MEMLOC cf, list;
    
    PrintfMemLoc("*USBD_CONFIG_HANDLE ", MemLoc, "\n");

    s.l = UsbReadFieldUlong(MemLoc, cs, "Sig");
    Sig(s.l, "");
    if (s.l != SIG_CONFIG_HANDLE) {
        BadSig(s.l, SIG_ENDPOINT);
        return;
    }

    cf = UsbReadFieldPtr(MemLoc, cs, "ConfigurationDescriptor");
    PrintfMemLoc("ConfigurationDescriptor ", cf, "\n");
 
    list = MemLoc + UsbFieldOffset(cs, 
            "InterfaceHandleList");

    DumpInterfaceHandleList(list);
}


DECLARE_API( _iso )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);

    DumpIsoTransferContext (addr);

    return S_OK; 
}



DECLARE_API( _tt )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);

    DumpTt (addr);

    return S_OK; 
}



DECLARE_API( _devh )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);

    DumpDeviceHandle (addr);

    return S_OK; 
}


DECLARE_API( _piph )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);

    DumpIPipe(addr);

    return S_OK; 
}


DECLARE_API( _endp )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpEndpoint(addr);

    return S_OK; 
}


DECLARE_API( _cmbf )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           level = 1;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%lx", &level);
    }

    DumpCommonBuffer (memLoc, level);

    return S_OK; 
}


DECLARE_API( _tfer )

/*++

Routine Description:

   dumps transfer Context for usbport
Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpTransferContext(addr);

    return S_OK; 
}


DECLARE_API( _mdl )

/*++

Routine Description:

   dumps an MDL
   
Arguments:

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           level = 1;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%lx", &level);
    }

    DumpMdl (memLoc);

    return S_OK; 
}


DECLARE_API( _cfgh )

/*++

Routine Description:

   dumps an MDL
   
Arguments:

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpConfigHandle(addr);

    return S_OK; 
}


DECLARE_API( _ifh )

/*++

Routine Description:

   dumps an MDL
   
Arguments:

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpInterfaceHandle(addr);

    return S_OK; 
}


DECLARE_API( _descusb )

/*++

Routine Description:

   dumps an MDL
   
Arguments:

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           level = 1;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%lx", &level);
    }

    DumpUsbDescriptorMemLoc(memLoc);

    return S_OK; 
}


DECLARE_API( _desccfg )

/*++

Routine Description:

   dumps an MDL
   
Arguments:

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           level = 1;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%lx", &level);
    }

    DumpCfgDescriptorMemLoc(memLoc);

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\usbohci.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbohci.c

Abstract:

    WinDbg Extension Api
    implements !_ohcitd
               !_ohcied
               !_ohciep
               !_ohcitfer

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usb.h"
#include "usbhcdi.h"
#include "..\miniport\usbohci\openhci.h"
#include "..\miniport\usbohci\usbohci.h"
#include "usbhcdkd.h"

VOID    
DumpOHCI_EpTransfers(
    ULONG HeadP_MemLoc,
    ULONG TailP_MemLoc
    );

VOID
HwConditionCode(
    ULONG cc
    ) 
{

    switch (cc) {
    case HcCC_NoError:       
        dprintf("HcCC_NoError");
        break;
    case HcCC_CRC:         
        dprintf("HcCC_CRC ");
        break;
    case HcCC_BitStuffing:             
        dprintf("HcCC_BitStuffing");
        break;
    case HcCC_DataToggleMismatch:            
        dprintf("HcCC_DataToggleMismatch");
        break;
    case HcCC_Stall:            
        dprintf("HcCC_Stall ");
        break;            
    case HcCC_DeviceNotResponding:            
        dprintf("HcCC_DeviceNotResponding");
        break;            
    case HcCC_PIDCheckFailure:           
        dprintf("HcCC_PIDCheckFailure");
        break;
    case HcCC_UnexpectedPID:            
        dprintf("HcCC_UnexpectedPID");
        break;
    case HcCC_DataOverrun:            
        dprintf("HcCC_DataOverrun");
        break;
    case HcCC_DataUnderrun:            
        dprintf("HcCC_DataUnderrun");
        break;
    case HcCC_BufferOverrun:            
        dprintf("HcCC_BufferOverrun ");
        break;
    case HcCC_BufferUnderrun:            
        dprintf("HcCC_BufferUnderrun");
        break;
    case HcCC_NotAccessed:                
        dprintf("HcCC_NotAccessed");
        break;
    default:                
        dprintf("???");
        break;        
    }
}


VOID    
DumpOHCI_Td(
    MEMLOC MemLoc
    )
{
    
    HCD_TRANSFER_DESCRIPTOR td;
    ULONG cb;
    ULONG i;

    // tds are a fixed size of 64/32 platforms so 
    // we can just read it in

    ReadMemory(MemLoc,
               &td,
               sizeof(td),
               &cb);

    PrintfMemLoc("*USBOHCI TD ", MemLoc, "\n");

    dprintf("HwTD");
    if (td.HwTD.Asy.Isochronous) {
        // dump as iso
        dprintf("\tIsochronous %x, \n", td.HwTD.Iso.Isochronous);
        dprintf("\tStartingFrame: %x\n", td.HwTD.Iso.StartingFrame);
        dprintf("\tFrameCount: %d (%d frames) \n", td.HwTD.Iso.FrameCount,
            td.HwTD.Iso.FrameCount+1);
        // dump the psw
    
        dprintf("\tPSW:\n"); 
        for (i=0; i< td.HwTD.Iso.FrameCount+2; i++) {
            // input
            dprintf("\t\tinput:[%d].Offset: x%x - %d\n", i, 
                td.HwTD.Packet[i].Offset,
                td.HwTD.Packet[i].Offset);
            dprintf("\t\tinput:[%d].Ones: x%x \n", i, td.HwTD.Packet[i].Ones);

            dprintf("\t\toutput:[%d].Size: %d\n", i, td.HwTD.Packet[i].Size);
            dprintf("\t\toutput:[%d].ConditionCode: %d\n", i, td.HwTD.Packet[i].ConditionCode);
        }
    } else {        
    
        // dump as async
        dprintf("\tIsochronous %x, \n", td.HwTD.Asy.Isochronous);
        dprintf("\tShortXferOk: %x\n", td.HwTD.Asy.ShortXferOk);
        dprintf("\tDirection: %x\n", td.HwTD.Asy.Direction);
        dprintf("\tToggle: %x", td.HwTD.Asy.Toggle);
        dprintf("\tIntDelay: %x", td.HwTD.Asy.IntDelay);
        dprintf("\tErrorCount: %x\n", td.HwTD.Asy.ErrorCount); 
        dprintf("\tConditionCode: x%x - ", td.HwTD.Asy.ConditionCode); 
        HwConditionCode(td.HwTD.Asy.ConditionCode);
        dprintf("\n");
        
        switch (td.HwTD.Asy.Toggle) {
        case HcTDToggle_FromEd:
            dprintf("HcTDToggle_FromEd\n");
            break;
        case HcTDToggle_Data0:
            dprintf("HcTDToggle_Data0\n");
            break;
        case HcTDToggle_Data1:
            dprintf("HcTDToggle_Data1\n");
            break;
        }            
    }        

    // these fields are common for iso & async
    
    dprintf("\tCBP: ! %x\n", td.HwTD.CBP);    
    dprintf("\tBE:  ! %x\n", td.HwTD.BE); 
    dprintf("\tNextTD: ! %x\n", td.HwTD.NextTD); 

    dprintf("PhysicalAddress: %08.8x\n", td.PhysicalAddress); 
    Sig(td.Sig, ""); 
    dprintf("Flags: 0x%08.8x\n", td.Flags);
    dprintf("EndpointData: %08.8x\n", td.EndpointData);
    dprintf("TransferContext: %08.8x\n", td.TransferContext);
    dprintf("TransferCount: 0x%08.8x\n", td.TransferCount);
    dprintf("FrameIndex: %d\n", td.FrameIndex);
    dprintf("NextHcdTD: %08.8x\n", td.NextHcdTD);
            

}


VOID    
DumpOHCI_Ed(
    ULONG MemLoc
    )
{
    
    HCD_ENDPOINT_DESCRIPTOR ed;
    ULONG result;

    if (!ReadMemory (MemLoc, &ed, sizeof(ed), &result)) {
        BadMemLoc(MemLoc);
        return;
    }
    
    dprintf("*USBOHCI ED %08.8x\n", MemLoc);
    dprintf("HwED");
    dprintf("\tFunctionAddress: 0x%x\n", ed.HwED.FunctionAddress);
    dprintf("\tEndpointNumber: %x\n", ed.HwED.EndpointNumber);
    dprintf("\tDirection: %x\n", ed.HwED.Direction);
    dprintf("\tLowSpeed: %x\n", ed.HwED.LowSpeed);
    dprintf("\tsKip: %x\n", ed.HwED.sKip);
    dprintf("\tIsochronous: %x\n", ed.HwED.Isochronous);
    dprintf("\tMaxPacket: 0x%x\n", ed.HwED.MaxPacket);
    
    dprintf("\tTailP: ! %x\n", ed.HwED.TailP);    
    dprintf("\tHeadP: ! %x", ed.HwED.HeadP);    
    if (ed.HwED.HeadP & HcEDHeadP_HALT) {
        dprintf(" (halted)");
    }   
    dprintf("\n");
    dprintf("\tNextED: %x\n", ed.HwED.NextED); 
    
    dprintf("PhysicalAddress: %08.8x\n", ed.PhysicalAddress); 
    Sig(ed.Sig, ""); 
    dprintf("EdFlags: 0x%08.8x\n", ed.EdFlags);
    dprintf("EndpointData: %08.8x\n", ed.EndpointData);
    dprintf("SwLink.List.Flink: %08.8x\n", ed.SwLink.List.Flink);
    dprintf("SwLink.List.Blink: %08.8x\n", ed.SwLink.List.Blink);

}


VOID    
DumpOHCI_EndpointData(
    MEMLOC MemLoc
    )
{
    
    UCHAR cs[] = "usbohci!_ENDPOINT_DATA";
 
    PrintfMemLoc("*USBOHCI ENDPOINT_DATA ", MemLoc, "\n");

    Sig(UsbReadFieldUlong(MemLoc, cs, "Sig"), "");
//    dprintf("MaxPendingTransfers: 0x%08.8x\n", epData.MaxPendingTransfers);
    dprintf("PendingTransfers: 0x%08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "PendingTransfers"));
    PrintfMemLoc("StaticEd: ", 
                 UsbReadFieldPtr(MemLoc, cs, "StaticEd"),
                 "\n");
    PrintfMemLoc("TdList: ", 
                 UsbReadFieldPtr(MemLoc, cs, "TdList"),
                 "\n");
    PrintfMemLoc("HcdEd: ", 
                 UsbReadFieldPtr(MemLoc, cs, "HcdEd"),
                 "\n");
                 
    dprintf("TdCount: 0x%08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "TdCount"));

    PrintfMemLoc("HcdTailP: ", 
                 UsbReadFieldPtr(MemLoc, cs, "HcdTailP"),
                 "\n");
    PrintfMemLoc("HcdHeadP: ", 
                 UsbReadFieldPtr(MemLoc, cs, "HcdHeadP"),
                 "\n");                 

//    DumpOHCI_Ed(epData.HcdEd);
    
//    DumpOHCI_EpTransfers((ULONG) epData.HcdHeadP, (ULONG) epData.HcdTailP);


}


VOID    
DumpOHCI_TransferContext(
    ULONG MemLoc
    )
{
    
    TRANSFER_CONTEXT tc;
    ULONG result;
    SIG s;
 
    if (!ReadMemory (MemLoc, &tc, sizeof(tc), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    dprintf("*USBOHCI TRANSFER_CONTEXT %08.8x\n", MemLoc);
    Sig(tc.Sig, "");
    dprintf("BytesTransferred: 0x%08.8x\n", tc.BytesTransferred);
    dprintf("TransferParameters: %x\n", 
        tc.TransferParameters);
    dprintf("PendingTds: %d\n", tc.PendingTds);
    dprintf("Flags: %08.8x\n", tc.TcFlags);
    dprintf("UsbdStatus: 0x%08.8x\n", tc.UsbdStatus);
    dprintf("NextXferTd: %08.8x\n", tc.NextXferTd);
    dprintf("StatusTd: %08.8x\n", tc.StatusTd);
    dprintf("EndpointData: %08.8x\n", tc.EndpointData);
}    


VOID    
DumpOHCI_EpTransfers(
    ULONG HeadP_MemLoc,
    ULONG TailP_MemLoc
    )
{
#if 0
    HCD_TRANSFER_DESCRIPTOR td;
    ULONG memLoc, result;
    
    // start at headp and walk to tail
    dprintf("\t TRANSFERS: HeadP\n");

    memLoc = HeadP_MemLoc;

    do {
        
        if (!ReadMemory (memLoc, &td, sizeof(td), &result)) {
           break;
        }   

        dprintf("\t> TD %8.8x(! %8.8x) - Transfer %8.8x Next-> ! %8.8x\n",
                memLoc, td.PhysicalAddress, td.TransferContext.Pointer,
                td.HwTD.NextTD);
       

        if (memLoc == TailP_MemLoc) {
            break;
        }
        
        memLoc = (ULONG) td.NextHcdTD.Pointer;
        
    } while (1);
#endif    
}


VOID    
DumpOHCI_DeviceData(
    MEMLOC MemLoc,
    BOOLEAN Verbose
    )
{
    UCHAR cs[] = "usbohci!_DEVICE_DATA";
    ULONG f, i;
    UCHAR fld[40], fld1[40], fld2[40], fld3[40], fld4[40];
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "HC", FT_PTR,
        "BIOS_Interval", FT_ULONG,
        "SofModifyValue", FT_ULONG,
        "FrameHighPart", FT_ULONG,
        "HcHCCA", FT_PTR,
        "HcHCCAPhys", FT_ULONG,
        "HydraLsHsHackEd", FT_PTR,
        "StaticEDs", FT_PTR,
        "StaticEDsPhys", FT_ULONG,
        "ControllerFlavor", FT_ULONG,
        
    };
    ULONG period[] =  {1, 2, 2, 4, 4, 4, 4, 8,
                      8, 8, 8, 8, 8, 8, 8,16,
                      16,16,16,16,16,16,16,16,
                      16,16,16,16,16,16,16,32,
                      32,32,32,32,32,32,32,32,
                      32,32,32,32,32,32,32,32,
                      32,32,32,32,32,32,32,32,
                      32,32,32,32,32,32,32,
                      0, 0};
//    FLAG_TABLE ddFlags[] = {
//        "EHCI_DD_FLAG_NOCHIRP", EHCI_DD_FLAG_NOCHIRP,
//        "EHCI_DD_FLAG_SOFT_ERROR_RETRY", EHCI_DD_FLAG_SOFT_ERROR_RETRY
//         };     

    PrintfMemLoc("*USBOHCI DEVICE DATA ", MemLoc, "\n");
    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    if (Verbose) {
        for (i= 0; i< NO_ED_LISTS; i++) {
            dprintf("\t[%02.2d] (%2.2dms): ", i, period[i]);
            sprintf(fld , "StaticEDList[%d]", i);
            sprintf(fld1, "StaticEDList[%d].HwED", i);
            sprintf(fld2, "StaticEDList[%d].HwEDPhys", i);
            PrintfMemLoc("StaticED @ ",
                MemLoc + UsbFieldOffset(cs, fld),
                " ");
            PrintfMemLoc("HwED ",
                UsbReadFieldPtr(MemLoc, cs, fld1),
                " ");

            dprintf("(!%08.8x)\n", 
                UsbReadFieldUlong(MemLoc, cs, fld2));
                
            sprintf(fld1, "StaticEDList[%d].NextIdx", i);            
            sprintf(fld2, "StaticEDList[%d].EdFlags", i);   
            sprintf(fld3, "StaticEDList[%d].HccaOffset", i);   
            sprintf(fld4, "StaticEDList[%d].PhysicalHead", i);   
            
            dprintf("\t\tNextIdx(%03.3d) EdFlags %08.8x Hcca Offset %d ", 
                UsbReadFieldUlong(MemLoc, cs, fld1), 
                UsbReadFieldUlong(MemLoc, cs, fld2),
                UsbReadFieldUlong(MemLoc, cs, fld3));
            PrintfMemLoc("PhysicalHead ",
                MemLoc + UsbFieldOffset(cs, fld4),
                "\n");

            sprintf(fld1, "StaticEDList[%d].TransferEdList.Flink", i);          
            PrintfMemLoc("\t\tTransferEdList.Flink ", 
                UsbReadFieldPtr(MemLoc, cs, fld1),
                "\n");
            sprintf(fld1, "StaticEDList[%d].TransferEdList.Blink", i);          
            PrintfMemLoc("\t\tTransferEdList.Blink ", 
                UsbReadFieldPtr(MemLoc, cs, fld1),
                "\n");
                            
        }   
    }
            
}

VOID    
DumpOHCI_Ints(
    ULONG i
    )
{
    if (i & HcInt_SchedulingOverrun) {
        dprintf("\t HcInt_SchedulingOverrun \n");
    }
    if (i & HcInt_WritebackDoneHead) {
        dprintf("\t HcInt_WritebackDoneHead \n");
    }
    if (i & HcInt_StartOfFrame) {
        dprintf("\t HcInt_StartOfFrame \n");
    }
    if (i & HcInt_ResumeDetected) {
        dprintf("\t HcInt_ResumeDetected \n");
    }
    if (i & HcInt_UnrecoverableError) {
        dprintf("\t HcInt_UnrecoverableError \n");
    }
    if (i & HcInt_RootHubStatusChange) {
        dprintf("\t HcInt_RootHubStatusChange \n");
    }
    if (i & HcInt_OwnershipChange) {
        dprintf("\t HcInt_OwnershipChange \n");
    }
    if (i & HcInt_MasterInterruptEnable) {
        dprintf("\t HcInt_MasterInterruptEnable \n");
    }
    if (i & HcInt_FrameNumberOverflow) {
        dprintf("\t HcInt_FrameNumberOverflow \n");
    }

     dprintf("\n");
}

VOID    
DumpOHCI_OpRegs(
    MEMLOC MemLoc
    )
{
    HC_OPERATIONAL_REGISTER hc;
    HC_CONTROL cmd;
    HC_COMMAND_STATUS sts;    
    ULONG l, i;
    ULONG cb;

    ReadMemory(MemLoc,
               &hc,
               sizeof(HC_OPERATIONAL_REGISTER),
               &cb);

    PrintfMemLoc("*(ohci)HC_OPERATIONAL_REGISTER ", MemLoc, "\n");

    cmd = hc.HcControl;
    dprintf("\tHC_CONTROL %08.8x\n" , cmd.ul);
    dprintf("\t.ControlBulkServiceRatio: %d\n", cmd.ControlBulkServiceRatio); 
    dprintf("\t.IsochronousEnable: %d\n", cmd.IsochronousEnable); 
    dprintf("\t.ControlListEnable: %d\n", cmd.ControlListEnable); 
    dprintf("\t.BulkListEnable: %d\n", cmd.BulkListEnable); 
    dprintf("\t.HostControllerFunctionalState: %d\n", cmd.HostControllerFunctionalState); 
    dprintf("Reset=0 Resume=1 Operational=2 Suspend=3\n");                     

    dprintf("\t.InterruptRouting: %d\n", cmd.InterruptRouting); 
    dprintf("\t.RemoteWakeupConnected: %d\n", cmd.RemoteWakeupConnected); 
    dprintf("\t.RemoteWakeupEnable: %d\n", cmd.RemoteWakeupEnable); 
    dprintf("\n");
    
    sts = hc.HcCommandStatus;
    dprintf("\tHC_COMMAND_STATUS %08.8x\n" , sts.ul);
    dprintf("\t.HostControllerReset: %d\n", sts.HostControllerReset); 
    dprintf("\t.ControlListFilled: %d\n", sts.ControlListFilled); 
    dprintf("\t.BulkListFilled: %d\n", sts.BulkListFilled); 
    dprintf("\t.OwnershipChangeRequest: %d\n", sts.OwnershipChangeRequest); 
    dprintf("\t.SchedulingOverrunCount: %d\n", sts.SchedulingOverrunCount); 
    dprintf("\n");

    dprintf("\tHcInterruptStatus: %08.8x\n" , hc.HcInterruptStatus);  
    DumpOHCI_Ints(hc.HcInterruptStatus);
    dprintf("\tHcInterruptEnable: %08.8x\n" , hc.HcInterruptEnable);  
    DumpOHCI_Ints(hc.HcInterruptEnable);
    dprintf("\tHcInterruptDisable: %08.8x\n" , hc.HcInterruptDisable);  
    DumpOHCI_Ints(hc.HcInterruptDisable);
    dprintf("\tHcHCCA: %08.8x\n" , hc.HcHCCA);  
    dprintf("\tHcPeriodCurrentED: %08.8x\n" , hc.HcPeriodCurrentED);  
    dprintf("\tHcControlHeadED: %08.8x\n" , hc.HcControlHeadED);  
    dprintf("\tHcControlCurrentED: %08.8x\n" , hc.HcControlCurrentED);  
    dprintf("\tHcBulkHeadED: %08.8x\n" , hc.HcBulkHeadED);  
    dprintf("\tHcBulkCurrentED: %08.8x\n" , hc.HcBulkCurrentED);  
    dprintf("\tHcDoneHead: %08.8x\n" , hc.HcDoneHead);  
    dprintf("\tHcFmInterval: %08.8x\n" , hc.HcFmInterval.ul);  
    dprintf("\tHcFmRemaining: %08.8x\n" , hc.HcFmRemaining.ul);  
    dprintf("\tHcFmNumber: %08.8x\n" , hc.HcFmNumber);  
    dprintf("\tHcPeriodicStart: %08.8x\n" , hc.HcPeriodicStart);  
    dprintf("\tHcLSThreshold: %08.8x\n" , hc.HcLSThreshold);  

    dprintf("\t-------\n");
    dprintf("\tCurrent Frame Index = %d\n", hc.HcFmNumber & 0x0000001f);
}


DECLARE_API( _ohcitd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpOHCI_Td (addr);

    return S_OK; 
}


DECLARE_API( _ohcied )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           len = 30;
    ULONG           result;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%d", &len);
    }

    DumpOHCI_Ed (memLoc);

    return S_OK; 
}


DECLARE_API( _ohciep )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpOHCI_EndpointData (addr);

    return S_OK; 
}


DECLARE_API( _ohcitfer )

/*++

Routine Description:

   dumps TRANSFER_CONTEXT
Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           len = 30;
    ULONG           result;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%d", &len);
    }

    DumpOHCI_TransferContext (memLoc);

    return S_OK; 
}


DECLARE_API( _ohciregs )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpOHCI_OpRegs(addr);

    return S_OK; 
}


DECLARE_API( _ohcidd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
    PCSTR s;
    UCHAR parm[32];

    GetExpressionEx( args, &addr, &s );
    
    sscanf(s, ",%s", &parm);
    dprintf("%s\n", parm);

    DumpOHCI_DeviceData(addr, parm[0] == 'v');

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\usbhcdkd.cpp ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

--*/

extern "C"
void
_disable (
    void
    );

extern "C"
void
_enable (
    void
    );

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

//
// globals
//
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG64                 STeip;
ULONG64                 STebp;
ULONG64                 STesp;

DBGKD_GET_VERSION64     KernelVersionPacket;
KDDEBUGGER_DATA64       KdDebuggerData;

ULONG64 EXPRLastDump = 0;

//
// Valid for the lifetime of the debug session.
//

ULONG   PageSize;
ULONG64 PaeEnabled;
ULONG   TargetMachine;
BOOL    Connected;

//
// this string is for supporting both the old and the new way of getting
// data from the kernel.  Maybe it will go away soon.
//
char ___SillyString[200];

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the page size and PAE enable flag
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK)
            {
                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                            DEBUG_DATA_PaeEnabled, &PaeEnabled,
                                            sizeof(PaeEnabled), NULL)) == S_OK)
                {
                    if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                                DEBUG_DATA_MmPageSize, &Page,
                                                sizeof(Page), NULL)) == S_OK)
                    {
                        PageSize = (ULONG)(ULONG_PTR)Page;
                    }
                }

                DebugDataSpaces->Release();
            }

            //
            // Get the architecture type.
            //

            if (PageSize)
            {
                if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                           (void **)&DebugControl)) == S_OK)
                {
                    if ((Hr = DebugControl->GetActualProcessorType(
                                                 &TargetMachine)) == S_OK)
                    {
                        Connected = TRUE;
                    }

                    DebugControl->Release();
                }
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        PageSize = 0;
        PaeEnabled = 0;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}

BOOL
HaveDebuggerData(
    VOID
    )
{
    static int havedata = 0;

    if (havedata == 0) {
        if (!Ioctl( IG_GET_KERNEL_VERSION, &KernelVersionPacket, sizeof(KernelVersionPacket))) {
            havedata = 2;
        } else if (KernelVersionPacket.MajorVersion == 0) {
            havedata = 2;
        } else {
            havedata = 1;
        }
    }

    return (havedata == 1) &&
           ((KernelVersionPacket.Flags & DBGKD_VERS_FLAG_DATA) != 0);
}

BOOL
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    )
{
    PDEBUG_SYSTEM_OBJECTS DebugSystem;
    ULONG64 hCurrentThread;

    if (Client) {
        if (Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                   (void **)&DebugSystem) != S_OK) {
            return 0;
        }

        DebugSystem->GetCurrentThreadHandle(&hCurrentThread);
        if (phCurrentThread) { 
            *phCurrentThread = (HANDLE) hCurrentThread;
        }
        if (pProcessor) {
            *pProcessor = (ULONG) hCurrentThread - 1;
        }

        DebugSystem->Release();
        return TRUE;
    }
    return FALSE;

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\usbhcdkd.h ===
#include "usb.h"
#include "usbhcdi.h"

// include all bus interfaces
#include "usbbusif.h"
#include "hubbusif.h"

// inclulde ioctl defs for port drivers
#include "usbkern.h"
#include "usbuser.h"

#include "..\..\USB2LIB\usb2lib.h"
#include "..\usbport\dbg.h"
#include "..\usbport\usbport.h"

//#define DEBUGIT

typedef union _SIG {
    UCHAR c[4];
    ULONG l;
} SIG, *PSIG;    

typedef struct _FLAG_TABLE {
    PUCHAR Name;
    ULONG Mask;
} FLAG_TABLE, *PFLAG_TABLE;

#define GETMEMLOC(base, typ, field) \
    ((base) + FIELD_OFFSET(typ, field))


typedef ULONG64 MEMLOC, *PMEMLOC; 

typedef struct _STRUC_ENTRY {
    PUCHAR FieldName;
    ULONG FieldType;
} STRUC_ENTRY, *PSTRUC_ENTRY;

#define FT_ULONG        1
#define FT_UCHAR        2
#define FT_USHORT       3
#define FT_PTR          4
#define FT_SIG          5
#define FT_DEVSPEED     6 
#define FT_ULONG64      7 

ULONG
CheckSym();


#define CHECKSYM()\
    {\
    ULONG n;\
    if ((n=CheckSym()) != S_OK) {\
        return n;\
    }\
    }



VOID
UsbDumpStruc(
    MEMLOC MemLoc,
    PUCHAR Cs,
    PSTRUC_ENTRY FieldList,
    ULONG NumEntries
    );

CPPMOD
ScanfMemLoc(
    PMEMLOC MemLoc,
    PCSTR args
    );

VOID
PrintfMemLoc(
     PUCHAR Str1,
     MEMLOC MemLoc,
     PUCHAR Str2
     );    

VOID
BadMemLoc(
    ULONG MemLoc
    );

VOID
BadSig(
    ULONG Sig,
    ULONG ExpectedSig
    );
    
VOID    
DumpIPipe(
    MEMLOC MEmLoc
    );

PCHAR
ListEmpty(
    MEMLOC HeadMemLoc
    );

VOID
DumpPowerCaps(
    MEMLOC MemLoc
    );

VOID 
UsbDumpFlags(
    ULONG Flags,
    PFLAG_TABLE FlagTable,
    ULONG NumEntries
    );

VOID
DumpUnicodeString(
    UNICODE_STRING uniString
    );

VOID    
DumpEndpointParameters(
    MEMLOC MemLoc
    );
    

VOID    
DumpUSBDescriptor(
    PVOID Descriptor
    );

VOID    
EpType(
    ENDPOINT_TRANSFER_TYPE Typ
    );    

VOID    
EpDir(
    ENDPOINT_TRANSFER_DIRECTION Dir
    );    

VOID
Sig(
    ULONG Sig,
    PUCHAR p
    );    

VOID    
DumpInterfaceInfo(
    MEMLOC MemLoc
    );

ULONG
UsbFieldOffset(
    IN LPSTR     Type,
    IN LPSTR     Field
    );    

MEMLOC
UsbReadFieldPtr(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );    

ULONG
UsbReadFieldUlong(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );        

UCHAR
UsbReadFieldUchar(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );

USHORT
UsbReadFieldUshort(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );    

VOID    
DumpEHCI_StaticQHs(
    MEMLOC MemLoc
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\usbehci.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbohci.c

Abstract:

    WinDbg Extension Api
    implements !_ehcitd
               !_ehciqh
               !_ehciep

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usb.h"
#include "usbhcdi.h"
#include "..\miniport\usbehci\ehci.h"
#include "..\miniport\usbehci\usbehci.h"
#include "usbhcdkd.h"

VOID    
DumpEHCI_qTD(
    PHW_QUEUE_ELEMENT_TD qTd
    )
{
    ULONG i;
    
    dprintf("\t qTD\n");
    dprintf("\t Next_qTD: %08.8x\n", qTd->Next_qTD);
    dprintf("\t AltNext_qTD: %08.8x\n", qTd->AltNext_qTD);
    dprintf("\t Token: 0x%08.8x\n", qTd->Token.ul);

    dprintf("\t\t PingState: 0x%x\n", qTd->Token.PingState);
    dprintf("\t\t SplitXstate: 0x%x\n", qTd->Token.SplitXstate);
    dprintf("\t\t MissedMicroFrame: 0x%x\n", qTd->Token.MissedMicroFrame);
    dprintf("\t\t XactErr: 0x%x\n", qTd->Token.XactErr);
    dprintf("\t\t BabbleDetected: 0x%x\n", qTd->Token.BabbleDetected);
    dprintf("\t\t DataBufferError: 0x%x\n", qTd->Token.DataBufferError);
    
    dprintf("\t\t Halted: 0x%x\n", qTd->Token.Halted);
    dprintf("\t\t Active: 0x%x\n", qTd->Token.Active);
    dprintf("\t\t Pid: 0x%x - ", qTd->Token.Pid);
    switch(qTd->Token.Pid) {
    case HcTOK_Out:           
        dprintf("HcTOK_Out\n");
        break;
    case HcTOK_In:           
        dprintf("HcTOK_In\n");
        break;        
    case HcTOK_Setup:           
        dprintf("HcTOK_Setup\n");
        break;        
    case HcTOK_Reserved:           
        dprintf("HcTOK_Reserved\n");
        break;        
    }        
    dprintf("\t\t ErrorCounter: 0x%x\n", qTd->Token.ErrorCounter);
    dprintf("\t\t C_Page: 0x%x\n", qTd->Token.C_Page);
    dprintf("\t\t InterruptOnComplete: 0x%x\n", qTd->Token.InterruptOnComplete);
    dprintf("\t\t BytesToTransfer: 0x%x\n", qTd->Token.BytesToTransfer);
    dprintf("\t\t DataToggle: 0x%x\n", qTd->Token.DataToggle);


    for (i=0; i<5; i++) {
        dprintf("\t BufferPage[%d]: 0x %05.5x-%03.3x  %08.8x\n", i, 
            qTd->BufferPage[i].BufferPointer, 
            qTd->BufferPage[i].CurrentOffset,
            qTd->BufferPage[i].ul);    
    }

}


VOID    
DumpEHCI_Td(
    ULONG MemLoc
    )
{
    
    HCD_TRANSFER_DESCRIPTOR td;
    ULONG result;
    ULONG i;

    if (!ReadMemory (MemLoc, &td, sizeof(td), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    if (td.Sig != SIG_HCD_TD) {
        dprintf("%08.8x is not a TD\n", MemLoc);
    } 
    dprintf("*USBEHCI TD %08.8x\n", MemLoc);
    Sig(td.Sig, "");
    DumpEHCI_qTD(&td.HwTD);    
    dprintf("Packet:"); 
    for (i=0; i<8; i++) {
        dprintf("%02.2x ", td.Packet[i]);
    }
    dprintf("\n"); 
    dprintf("PhysicalAddress: %08.8x\n",td.PhysicalAddress);          
    dprintf("EndpointData: %08.8x\n",td.EndpointData);  
    dprintf("TransferLength : %08.8x\n", td.TransferLength);
    dprintf("TransferContext: %08.8x\n",td.TransferContext);  
    dprintf("Flags: %08.8x\n",td.Flags);  
    if (td.Flags & TD_FLAG_BUSY) {
        dprintf("\tTD_FLAG_BUSY\n");
    }
    if (td.Flags & TD_FLAG_XFER) {
        dprintf("\tTD_FLAG_XFER\n");
    }
    if (td.Flags & TD_FLAG_DONE) {
        dprintf("\tTD_FLAG_DONE\n");
    }
    if (td.Flags & TD_FLAG_SKIP) {
        dprintf("\tTD_FLAG_SKIP\n");
    }
    if (td.Flags & TD_FLAG_DUMMY) {
        dprintf("\tTD_FLAG_DUMMY\n");
    }
    dprintf("NextHcdTD: %08.8x\n",td.NextHcdTD);  
    dprintf("AltNextHcdTD: %08.8x\n",td.AltNextHcdTD);  
}


VOID    
DumpEHCI_SiTd(
    ULONG MemLoc
    )
{
    
    HCD_SI_TRANSFER_DESCRIPTOR td;
    ULONG result;
    ULONG i;

    if (!ReadMemory (MemLoc, &td, sizeof(td), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    if (td.Sig != SIG_HCD_SITD) {
        dprintf("%08.8x is not a SiTD\n", MemLoc);
    } 
    dprintf("*USBEHCI SiTD %08.8x\n", MemLoc);
    Sig(td.Sig, "");
    dprintf("Packet: %08.8x\n",td.Packet); 
    dprintf("PhysicalAddress: %08.8x\n",td.PhysicalAddress);          

    dprintf("NextLink: %08.8x\n",td.HwTD.NextLink.HwAddress);  
    
    dprintf("Caps: %08.8x\n",td.HwTD.Caps.ul);  

    dprintf("Control: %08.8x\n",td.HwTD.Control.ul);  

    dprintf("State: %08.8x\n",td.HwTD.State.ul);  

    dprintf("BufferPointer0: %08.8x\n",td.HwTD.BufferPointer0.ul); 

    dprintf("BufferPointer1: %08.8x\n",td.HwTD.BufferPointer1.ul); 

    dprintf("BackPointer: %08.8x\n",td.HwTD.BackPointer.HwAddress); 
}


VOID    
DumpEHCI_iTd(
    MEMLOC MemLoc
    )
{
    HCD_HSISO_TRANSFER_DESCRIPTOR td;
    ULONG i, cb;
    ULONG flags;
    UCHAR s[64];
    UCHAR cs[] = "usbehci!_HCD_HSISO_TRANSFER_DESCRIPTOR";
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "PhysicalAddress", FT_ULONG,
        "HostFrame", FT_ULONG,
        "FirstPacket.Pointer", FT_PTR,
        "Transfer.Pointer", FT_PTR,
        "ReservedMBNull", FT_PTR,
    };
    
    ReadMemory(MemLoc,
               &td,
               sizeof(td),
               &cb);
               
    if (td.Sig != SIG_HCD_ITD) {
        dprintf("not a iTD\n");
    } 
    PrintfMemLoc("*USBEHCI iTD ", MemLoc, "\n");
    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    dprintf("\t NextLink %08.8x\n", td.HwTD.NextLink.HwAddress);    
    dprintf("\t (%08.8x)BufferPointer0 %08.8x\n", td.HwTD.BufferPointer0.ul,
        td.HwTD.BufferPointer0.BufferPointer); 
    dprintf("\t\t Dev x%x Ept x%x\n", td.HwTD.BufferPointer0.DeviceAddress,
        td.HwTD.BufferPointer0.EndpointNumber);        
        
    dprintf("\t (%08.8x)BufferPointer1 %08.8x\n", td.HwTD.BufferPointer1.ul,
        td.HwTD.BufferPointer1.BufferPointer); 
    dprintf("\t\t MaxPacketSize x%x\n", td.HwTD.BufferPointer1.MaxPacketSize);         
    
    dprintf("\t (%08.8x)BufferPointer2 %08.8x\n", td.HwTD.BufferPointer2.ul,
        td.HwTD.BufferPointer2.BufferPointer); 
    dprintf("\t\t Multi x%x\n", td.HwTD.BufferPointer2.Multi);          
    
    dprintf("\t (%08.8x)BufferPointer3 %08.8x\n", td.HwTD.BufferPointer3.ul,
        td.HwTD.BufferPointer3.BufferPointer); 
    dprintf("\t (%08.8x)BufferPointer4 %08.8x\n", td.HwTD.BufferPointer4.ul,
        td.HwTD.BufferPointer4.BufferPointer); 
    dprintf("\t (%08.8x)BufferPointer5 %08.8x\n", td.HwTD.BufferPointer5.ul,
        td.HwTD.BufferPointer5.BufferPointer); 
    dprintf("\t (%08.8x)BufferPointer6 %08.8x\n", td.HwTD.BufferPointer6.ul,
        td.HwTD.BufferPointer6.BufferPointer); 
    for (i=0; i<8; i++) {   
        dprintf("\t Transaction[%d](%08.8x)\n",
            i, td.HwTD.Transaction[i].ul);
        dprintf("\t Transaction[%d].Offset %08.8x\n", 
            i, td.HwTD.Transaction[i].Offset); 
        dprintf("\t Transaction[%d].PageSelect %d\n", 
            i, td.HwTD.Transaction[i].PageSelect);            
        dprintf("\t Transaction[%d].Length %08.8x\n", 
            i, td.HwTD.Transaction[i].Length);               
         dprintf("\t\t active %d ioc %d - xerr:%d babble:%d dataerr:%d\n", 
            td.HwTD.Transaction[i].Active,
            td.HwTD.Transaction[i].InterruptOnComplete,
            td.HwTD.Transaction[i].XactError,
            td.HwTD.Transaction[i].BabbleDetect,
            td.HwTD.Transaction[i].DataBufferError
            );            
    }
}


VOID    
DumpEHCI_Qh(
    MEMLOC MemLoc
    )
{
    
    HCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG cb;
    FLAG_TABLE qhFlags[] = {
        "EHCI_QH_FLAG_IN_SCHEDULE", EHCI_QH_FLAG_IN_SCHEDULE,
        "EHCI_QH_FLAG_QH_REMOVED", EHCI_QH_FLAG_QH_REMOVED,
        "EHCI_QH_FLAG_STATIC", EHCI_QH_FLAG_STATIC,
        "EHCI_QH_FLAG_HIGHSPEED", EHCI_QH_FLAG_HIGHSPEED,
         };     
    
    ReadMemory(MemLoc,
               &qh,
               sizeof(qh),
               &cb);


    if (qh.Sig != SIG_HCD_AQH &&
        qh.Sig != SIG_HCD_QH) {
    }        

    PrintfMemLoc("*USBEHCI QH ", MemLoc, "\n");
            
    dprintf("*USBEHCI QH %08.8x\n", MemLoc);
    Sig(qh.Sig, ""); 
    dprintf("PhysicalAddress %08.8x\n", qh.PhysicalAddress);
    dprintf("Flags: %08.8x\n", qh.QhFlags);
    UsbDumpFlags(qh.QhFlags, qhFlags, 
            sizeof(qhFlags)/sizeof(FLAG_TABLE));
    
    
    dprintf("EndpointData: %08.8x\n", qh.EndpointData);
    dprintf("NextQh: %08.8x\n", qh.NextQh);
    dprintf("PrevQh: %08.8x\n", qh.PrevQh);
    dprintf("PrevQh: %d\n", qh.Ordinal);


    dprintf("HwQH\n");
    
    dprintf("\t HwQH.HLink %08.8x\n", qh.HwQH.HLink.HwAddress);        
    
    dprintf("\t HwQH.EpChars %08.8x\n", qh.HwQH.EpChars.ul);
    dprintf("\t\t DeviceAddress: 0x%x\n", qh.HwQH.EpChars.DeviceAddress);
    dprintf("\t\t EndpointNumber: 0x%x\n", qh.HwQH.EpChars.EndpointNumber);
    dprintf("\t\t EndpointSpeed: 0x%x", qh.HwQH.EpChars.EndpointSpeed);

    switch(qh.HwQH.EpChars.EndpointSpeed) {
    case HcEPCHAR_FullSpeed:
        dprintf("HcEPCHAR_FullSpeed");   
        break;            
    case HcEPCHAR_HighSpeed:
        dprintf("HcEPCHAR_HighSpeed");   
        break;            
    case HcEPCHAR_LowSpeed:
        dprintf("HcEPCHAR_LowSpeed");   
        break;
    case HcEPCHAR_Reserved:
        dprintf("HcEPCHAR_Reserved");           
        break;
    }
    dprintf("\n");
    
    dprintf("\t\t DataToggleControl: 0x%x\n", qh.HwQH.EpChars.DataToggleControl);
    dprintf("\t\t HeadOfReclimationList: 0x%x\n", qh.HwQH.EpChars.HeadOfReclimationList);
    dprintf("\t\t MaximumPacketLength: 0x%x - %d\n", 
        qh.HwQH.EpChars.MaximumPacketLength, qh.HwQH.EpChars.MaximumPacketLength);
    dprintf("\t\t ControlEndpointFlag: %d\n", qh.HwQH.EpChars.ControlEndpointFlag);
    dprintf("\t\t NakReloadCount: %d\n", qh.HwQH.EpChars.NakReloadCount);

    dprintf("\t HwQH.EpCaps %08.8x\n", qh.HwQH.EpCaps.ul);
    dprintf("\t\t InterruptScheduleMask: 0x%x\n", qh.HwQH.EpCaps.InterruptScheduleMask);
    dprintf("\t\t SplitCompletionMask: 0x%x\n", qh.HwQH.EpCaps.SplitCompletionMask);
    dprintf("\t\t HubAddress: 0x%x\n", qh.HwQH.EpCaps.HubAddress);
    dprintf("\t\t PortNumber: 0x%x\n", qh.HwQH.EpCaps.PortNumber);
    dprintf("\t\t HighBWPipeMultiplier: 0x%x\n", qh.HwQH.EpCaps.HighBWPipeMultiplier);
    
    dprintf("\t HwQH.CurrentTD %08.8x\n", qh.HwQH.CurrentTD.HwAddress);
    dprintf("\t HwQH.Overlay\n");
    DumpEHCI_qTD((PHW_QUEUE_ELEMENT_TD)&qh.HwQH.Overlay);


}


VOID    
DumpEHCI_EndpointData(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "usbehci!_ENDPOINT_DATA";
    UCHAR ts[] = "usbehci!_HCD_TRANSFER_DESCRIPTOR";
    ULONG f, i=0;
    MEMLOC head, tail, m;
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "QueueHead", FT_PTR,
        "PendingTransfers", FT_ULONG,
        "MaxPendingTransfers", FT_ULONG,
        "HcdTailP", FT_PTR,
        "HcdHeadP", FT_PTR,
        "StaticQH", FT_PTR,
        "PeriodTableEntry", FT_PTR,
        "TdList", FT_PTR,
        "SiTdList", FT_PTR,
        "TdCount", FT_ULONG,
        "PrevEndpoint", FT_PTR,
        "NextEndpoint", FT_PTR,
        "DummyTd", FT_PTR,
        "LastFrame", FT_ULONG, 
        "TransferList.Flink", FT_PTR,
        "TransferList.Blink", FT_PTR,
        //"MaxErrorCount", FT_ULONG,
    };
    FLAG_TABLE epFlags[] = {
        "EHCI_EDFLAG_HALTED", EHCI_EDFLAG_HALTED,
        "EHCI_EDFLAG_NOHALT", EHCI_EDFLAG_NOHALT
         };     

    PrintfMemLoc("*USBEHCI ENDPOINT_DATA ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "Flags");
    dprintf("Flags: 0x%08.8x\n", f);    
    UsbDumpFlags(f, epFlags, 
            sizeof(epFlags)/sizeof(FLAG_TABLE));
    
    DumpEndpointParameters(MemLoc + UsbFieldOffset(cs, "Parameters"));

    // dump the transfers
    head = UsbReadFieldPtr(MemLoc, cs, "HcdHeadP");
    tail = UsbReadFieldPtr(MemLoc, cs, "HcdTailP");
    PrintfMemLoc("<HEAD> ", head, "\n");
    while (head != tail && i<10) {
        i++;
        dprintf("\t TD ");            
        PrintfMemLoc("", head, " ");    

        dprintf ("[%08.8x] ",
            UsbReadFieldUlong(head, ts, "PhysicalAddress"));
        
        m = UsbReadFieldPtr(head, ts, "TransferContext");            
        PrintfMemLoc("XFER ", m, "\n");    

        head = UsbReadFieldPtr(head, ts, "NextHcdTD");
    }
    PrintfMemLoc("<TAIL> ", tail, "\n");  

}


VOID    
DumpEHCI_DumpTfer(
    ULONG MemLoc
    )
{
    
    TRANSFER_CONTEXT tc;
    ULONG result;
    SIG s;
 
    if (!ReadMemory (MemLoc, &tc, sizeof(tc), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    if (tc.Sig != SIG_EHCI_TRANSFER) {
        dprintf("%08.8x is not TRANSFER_CONTEXT\n", MemLoc);
    } 
    
    Sig(tc.Sig, "");
    dprintf("PendingTds: 0x%08.8x\n", tc.PendingTds);
    dprintf("TransferParameters: 0x%08.8x\n", tc.TransferParameters);
    dprintf("UsbdStatus: 0x%08.8x\n", tc.UsbdStatus);
    dprintf("BytesTransferred: 0x%08.8x\n", tc.BytesTransferred);
    dprintf("XactErrCounter: %d\n", tc.XactErrCounter);
    dprintf("EndpointData: 0x%08.8x\n", tc.EndpointData);
}


VOID    
DumpEHCI_DeviceData(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "usbehci!_DEVICE_DATA";
    ULONG f;
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "OperationalRegisters", FT_PTR,
        "CapabilitiesRegisters", FT_PTR,
        "EnabledInterrupts", FT_ULONG,
        "AsyncQueueHead", FT_PTR,
        "ControllerFlavor", FT_ULONG,
        "FrameNumberHighPart", FT_ULONG,
        "PortResetChange", FT_ULONG,
        "PortSuspendChange", FT_ULONG,
        "PortConnectChange", FT_ULONG,
        "IrqStatus", FT_ULONG,
        "NumberOfPorts", FT_USHORT,
        "PortPowerControl", FT_USHORT,
        "HighSpeedDeviceAttached", FT_ULONG,
        "FrameListBaseAddress", FT_PTR,
        "FrameListBasePhys", FT_ULONG,
        "IsoEndpointListHead", FT_PTR
    };
    FLAG_TABLE ddFlags[] = {
        "EHCI_DD_FLAG_NOCHIRP", EHCI_DD_FLAG_NOCHIRP,
        "EHCI_DD_FLAG_SOFT_ERROR_RETRY", EHCI_DD_FLAG_SOFT_ERROR_RETRY
         };     

    PrintfMemLoc("*USBEHCI DEVICE DATA ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "Flags");
    dprintf("Flags: 0x%08.8x\n", f);    
    UsbDumpFlags(f, ddFlags, 
            sizeof(ddFlags)/sizeof(FLAG_TABLE));

    DumpEHCI_StaticQHs(MemLoc);
    
}


VOID    
DumpEHCI_StaticQHs(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "usbehci!_DEVICE_DATA";
    ULONG i;
    MEMLOC m;
    UCHAR s[64];
    UCHAR t[64];

    ULONG p[65] = {
      1, 2, 2, 4, 4, 4, 4, 8,
      8, 8, 8, 8, 8, 8, 8,16,
     16,16,16,16,16,16,16,16,
     16,16,16,16,16,16,16,32,
     32,32,32,32,32,32,32,32,
     32,32,32,32,32,32,32,32,
     32,32,32,32,32,32,32,32,
     32,32,32,32,32,32,32,0,0};

    for (i=0; i< 65; i++) {
        sprintf(s, "StaticQH[%d] (%d):", i, p[i]);    
        sprintf(t, "StaticInterruptQH[%d]", i);   
        m = UsbReadFieldPtr(MemLoc, cs, t);            
        PrintfMemLoc(s, m, "\n");
    }        
}


VOID    
DumpEHCI_OpRegs(
    MEMLOC MemLoc,
    ULONG NumPorts
    )
{
    
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;
    USBSTS sts;
    ULONG l, i;
    USBINTR irqE;
    ULONG cb;

    l = sizeof(HC_OPERATIONAL_REGISTER) + sizeof(PORTSC) * NumPorts;
    hcOp = malloc(l);

    if (!hcOp) {
        return;
    }

    ReadMemory(MemLoc,
               hcOp,
               l,
               &cb);

    PrintfMemLoc("*(ehci)HC_OPERATIONAL_REGISTER ", MemLoc, "\n");

    cmd = hcOp->UsbCommand;
    dprintf("\tUSBCMD %08.8x\n" , cmd.ul);
    dprintf("\t.HostControllerRun: %d\n", cmd.HostControllerRun); 
    dprintf("\t.HostControllerReset: %d\n", cmd.HostControllerReset); 
    dprintf("\t.FrameListSize: %d\n", cmd.FrameListSize); 
    dprintf("\t.PeriodicScheduleEnable: %d\n", cmd.PeriodicScheduleEnable); 
    dprintf("\t.AsyncScheduleEnable: %d\n", cmd.AsyncScheduleEnable); 
    dprintf("\t.IntOnAsyncAdvanceDoorbell: %d\n", cmd.IntOnAsyncAdvanceDoorbell); 
    dprintf("\t.HostControllerLightReset: %d\n", cmd.HostControllerLightReset); 
    dprintf("\t.InterruptThreshold: %d\n", cmd.InterruptThreshold); 
    dprintf("\n");
    
    sts = hcOp->UsbStatus;
    dprintf("\tUSBSTS %08.8x\n" , sts.ul);
    dprintf("\t.UsbInterrupt: %d\n", sts.UsbInterrupt); 
    dprintf("\t.UsbError: %d\n", sts.UsbError); 
    dprintf("\t.PortChangeDetect: %d\n", sts.PortChangeDetect); 
    dprintf("\t.FrameListRollover: %d\n", sts.FrameListRollover); 
    dprintf("\t.HostSystemError: %d\n", sts.HostSystemError); 
    dprintf("\t.IntOnAsyncAdvance: %d\n", sts.IntOnAsyncAdvance); 
    dprintf("\t----\n"); 
    dprintf("\t.HcHalted: %d\n", sts.HcHalted); 
    dprintf("\t.Reclimation: %d\n", sts.Reclimation); 
    dprintf("\t.PeriodicScheduleStatus: %d\n", sts.PeriodicScheduleStatus); 
    dprintf("\t.AsyncScheduleStatus: %d\n", sts.AsyncScheduleStatus); 
    dprintf("\n");

    irqE = hcOp->UsbInterruptEnable;
    dprintf("\tUSBINTR %08.8x\n" , irqE.ul);
    dprintf("\t.UsbInterrupt: %d\n", irqE.UsbInterrupt); 
    dprintf("\t.UsbError: %d\n", irqE.UsbError); 
    dprintf("\t.PortChangeDetect: %d\n", irqE.PortChangeDetect); 
    dprintf("\t.FrameListRollover: %d\n", irqE.FrameListRollover); 
    dprintf("\t.HostSystemError: %d\n", irqE.HostSystemError); 
    dprintf("\t.IntOnAsyncAdvance: %d\n", irqE.IntOnAsyncAdvance); 

    dprintf("\tPeriodicListBase %08.8x\n" , hcOp->PeriodicListBase);  
    dprintf("\tAsyncListAddr %08.8x\n" , hcOp->AsyncListAddr);  

    for (i=0; i<NumPorts; i++) {
        PORTSC p;

        p.ul = hcOp->PortRegister[i].ul;
        
        dprintf("\tPortSC[%d] %08.8x\n", i, p.ul);  
        dprintf("\t\tPortConnect x%x\n", p.PortConnect); 
        dprintf("\t\tPortConnectChange x%x\n", p.PortConnectChange);        
        dprintf("\t\tPortEnable x%x\n", p.PortEnable);     
        dprintf("\t\tPortEnableChange x%x\n", p.PortEnableChange);   
        dprintf("\t\tOvercurrentActive x%x\n", p.OvercurrentActive);   
        dprintf("\t\tOvercurrentChange x%x\n", p.OvercurrentChange);   
        dprintf("\t\tForcePortResume x%x\n", p.ForcePortResume);     
        dprintf("\t\tPortSuspend x%x\n", p.PortSuspend);   
        dprintf("\t\tPortReset x%x\n", p.PortReset);   
        dprintf("\t\tHighSpeedDevice x%x\n", p.HighSpeedDevice);   
        dprintf("\t\tLineStatus x%x\n", p.LineStatus);   
        dprintf("\t\tPortPower x%x\n", p.PortPower);     
        dprintf("\t\tPortOwnedByCC x%x\n", p.PortOwnedByCC);   
        dprintf("\t\tPortIndicator x%x\n", p.PortIndicator);   
        dprintf("\t\tPortTestControl x%x\n", p.PortTestControl);   
        dprintf("\t\tWakeOnConnect x%x\n", p.WakeOnConnect);   
        dprintf("\t\tWakeOnDisconnect x%x\n", p.WakeOnDisconnect);   
        dprintf("\t\tWakeOnOvercurrent x%x\n", p.WakeOnOvercurrent); 
    }
    free(hcOp);
  
}



DECLARE_API( _ehcidd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpEHCI_DeviceData(addr);

    return S_OK; 
}

DECLARE_API( _ehciitd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
   
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpEHCI_iTd (addr);

    return S_OK; 
}


DECLARE_API( _ehcitd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           len = 30;
    ULONG           result;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%d", &len);
    }

    DumpEHCI_Td (memLoc);

    return S_OK; 
}


DECLARE_API( _ehcisitd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           len = 30;
    ULONG           result;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%d", &len);
    }

    DumpEHCI_SiTd (memLoc);

    return S_OK; 
}


DECLARE_API( _ehciqh )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpEHCI_Qh(addr);

    return S_OK; 
}


DECLARE_API( _ehciep )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpEHCI_EndpointData (addr);

    return S_OK; 
}


DECLARE_API( _ehcitfer )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           len = 30;
    ULONG           result;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%d", &len);
    }

    DumpEHCI_DumpTfer(memLoc);

    return S_OK; 
}


DECLARE_API( _ehciregs )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    ULONG parm = 0;

    GetExpressionEx( args, &addr, &s );

    if (s[0] != '\0') { 
        sscanf(s, ",%d", &parm);
    }        

    DumpEHCI_OpRegs(addr, parm);

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\util.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    util.c

Abstract:

    WinDbg Extension Api

Author:

    Chris Robinson (crobins) Feburary 1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#include "usbhcdkd.h"


VOID    
DumpUSBDescriptor(
    PVOID Descriptor
    )
{
    PUSB_DEVICE_DESCRIPTOR dd = Descriptor;
    PUSB_COMMON_DESCRIPTOR cd = Descriptor;
    PUSB_INTERFACE_DESCRIPTOR id = Descriptor;
    PUSB_CONFIGURATION_DESCRIPTOR cf = Descriptor;
    PUSB_ENDPOINT_DESCRIPTOR ed = Descriptor;

    switch (cd->bDescriptorType) {
    case USB_CONFIGURATION_DESCRIPTOR_TYPE:
        dprintf("[CONFIGURATION DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", cf->bLength);
        dprintf("bDescriptorType 0x%x\n", cf->bDescriptorType);
        dprintf("wTotalLength 0x%x (%d)\n", cf->wTotalLength, cf->wTotalLength);
        dprintf("bNumInterfaces 0x%x\n", cf->bNumInterfaces);
        dprintf("bConfigurationValue 0x%x\n", cf->bConfigurationValue);
        dprintf("iConfiguration 0x%x\n", cf->iConfiguration);
        dprintf("bmAttributes 0x%x\n", cf->bmAttributes);
        dprintf("MaxPower 0x%x (%d)\n", cf->MaxPower, cf->MaxPower);
        break;
        
    case USB_INTERFACE_DESCRIPTOR_TYPE:
        dprintf("[INTERFACE DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", id->bLength);
        dprintf("bDescriptorType 0x%x\n", id->bDescriptorType);
        dprintf("bInterfaceNumber 0x%x\n", id->bInterfaceNumber);
        dprintf("bAlternateSetting 0x%x\n", id->bAlternateSetting);
        dprintf("bNumEndpoints 0x%x\n", id->bNumEndpoints);
        dprintf("bInterfaceClass 0x%x\n", id->bInterfaceClass);
        dprintf("bInterfaceSubClass 0x%x\n", id->bInterfaceSubClass);
        dprintf("bInterfaceProtocol 0x%x\n", id->bInterfaceProtocol);
        dprintf("iInterface 0x%x\n", id->iInterface);
        break;
                    
    case USB_DEVICE_DESCRIPTOR_TYPE:
        dprintf("[DEVICE DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", dd->bLength);
        dprintf("bDescriptorType 0x%x\n", dd->bDescriptorType);
        dprintf("bcdUSB 0x%x\n", dd->bcdUSB);
        dprintf("bDeviceClass 0x%x\n", dd->bDeviceClass);
        dprintf("bDeviceSubClass 0x%x\n", dd->bDeviceSubClass); 
        dprintf("bDeviceProtocol 0x%x\n", dd->bDeviceProtocol);
        dprintf("bMaxPacketSize0 0x%x\n", dd->bMaxPacketSize0);
        dprintf("idVendor 0x%x\n", dd->idVendor);
        dprintf("idProduct 0x%x\n", dd->idProduct);
        dprintf("bcdDevice 0x%x\n", dd->bcdDevice);
        dprintf("iManufacturer 0x%x\n", dd->iManufacturer);
        dprintf("iProduct 0x%x\n", dd->iProduct);
        dprintf("iSerialNumber 0x%x\n", dd->iSerialNumber);
        dprintf("bNumConfigurations 0x%x\n", dd->bNumConfigurations);
        break;
    case USB_ENDPOINT_DESCRIPTOR_TYPE:
        dprintf("[ENDPOINT DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", ed->bLength);
        dprintf("bDescriptorType 0x%x\n", ed->bDescriptorType);
        dprintf("bEndpointAddress 0x%x\n", ed->bEndpointAddress);
        dprintf("bmAttributes 0x%x\n", ed->bmAttributes);
        dprintf("wMaxPacketSize 0x%x\n", ed->wMaxPacketSize);
        dprintf("bInterval 0x%x\n", ed->bInterval);
        break;
        
    default:        
        dprintf("[DESCRIPTOR ???]\n");
    }   
    
}


VOID
DumpUnicodeString(
    UNICODE_STRING uniString
    )
{

       
    dprintf(">> Buffer: %08.8x, Length %d\n", 
        uniString.Buffer, uniString.Length);                    

}    


VOID
Sig(
    ULONG Sig,
    PUCHAR p
    )
{
    SIG s;
    
    dprintf(p);
    s.l = Sig;
    dprintf("Sig:%08.8x %c%c%c%c\n", Sig,
            s.c[0],  s.c[1],  s.c[2], s.c[3]); 

}      


CPPMOD
ScanfMemLoc(
    PMEMLOC MemLoc,
    PCSTR args
    )
{
//    UCHAR           buffer[256];
    ULONG tmp1 = 0, tmp2 = 0;

    //buffer[0] = '\0';

    if (IsPtr64()) {
        //sscanf(args, "%lx %lx", &MemLoc->p64, buffer);
    } else {
        sscanf(args, "%lx %lx", &tmp1, &tmp2);
        *MemLoc = (ULONG64) tmp1;             
        dprintf("tmp1 = %x tmp2 = %x\n", tmp1, tmp2);
    }
}          


VOID
PrintfMemLoc(
     PUCHAR Str1,
     MEMLOC MemLoc,
     PUCHAR Str2
     )
{
    if (IsPtr64()) {   
        ULONG tmp = (ULONG) MemLoc;
        ULONG tmp1 = (ULONG) (MemLoc>>32); 
#ifdef DEBUGIT          
        dprintf("%s%08.8x%08.8x (64)%s", Str1, tmp1, tmp, Str2); 
#else
        dprintf("%s%08.8x%08.8x %s", Str1, tmp1, tmp, Str2); 
#endif
    } else {
        ULONG tmp = (ULONG) MemLoc;
#ifdef DEBUGIT          
        dprintf("%s%08.8x (32)%s", Str1, tmp, Str2); 
#else   
        dprintf("%s%08.8x %s", Str1, tmp, Str2);
#endif        
    }
}


VOID
BadMemLoc(
    ULONG MemLoc
    )
{
    dprintf("could not read mem location %08.8x\n", MemLoc);
}     


VOID
BadSig(
    ULONG Sig,
    ULONG ExpectedSig
    )
{
    dprintf("Bad Structure Signature %08.8x\n", Sig);
}     


VOID 
UsbDumpFlags(
    ULONG Flags,
    PFLAG_TABLE FlagTable,
    ULONG NumEntries
    )
{
    ULONG i;
    PFLAG_TABLE ft = FlagTable;
    
    for (i=0; i< NumEntries; i++) {
        if (ft->Mask & Flags) {
            dprintf ("\t> %s\n", ft->Name);
        }
        ft++;
    }
}


ULONG
UsbFieldOffset(
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    ULONG offset;
    ULONG r;

    r = GetFieldOffset(Type, Field, &offset);
#ifdef DEBUGIT      
    dprintf("<UsbReadFieldPtr %x offset %x>", r, offset);
#endif     

    return offset;
}


MEMLOC
UsbReadFieldPtr(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    MEMLOC p;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, p);
#ifdef DEBUGIT      
    dprintf("<UsbReadFieldPtr %x>", r);
#endif    
    return p;
}


UCHAR
UsbReadFieldUchar(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    UCHAR ch;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, ch);
#ifdef DEBUGIT     
    dprintf("<UsbReadFieldUchar %x>", r);
#endif      
    return ch;
}


ULONG
UsbReadFieldUlong(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    ULONG l;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, l);
#ifdef DEBUGIT     
    dprintf("<UsbReadFieldUlong %x>", r);
#endif    
    return l;
}


USHORT
UsbReadFieldUshort(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    USHORT s;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, s);
#ifdef DEBUGIT    
    dprintf("<UsbReadFieldUshort %x>", r);
#endif    
    return s;
}

VOID
UsbDumpStruc(
    MEMLOC MemLoc,
    PUCHAR Cs,
    PSTRUC_ENTRY FieldList,
    ULONG NumEntries
    )
{
    ULONG i, l;
    UCHAR s[80];
    SIG sig;

    for (i=0; i< NumEntries; i++) {
        switch (FieldList->FieldType) {
        case FT_ULONG:
            dprintf("%s: 0x%08.8x\n",
                FieldList->FieldName,
                UsbReadFieldUlong(MemLoc, Cs, FieldList->FieldName));
            break;
        case FT_UCHAR:
            dprintf("%s: 0x%02.2x\n",
                FieldList->FieldName,
                UsbReadFieldUchar(MemLoc, Cs, FieldList->FieldName));
            break;
        case FT_USHORT:
            dprintf("%s: 0x%04.4x\n",
                FieldList->FieldName,
                UsbReadFieldUshort(MemLoc, Cs, FieldList->FieldName));
            break;
        case FT_PTR:
            sprintf(s, "%s: ", FieldList->FieldName);
            PrintfMemLoc(s, 
            UsbReadFieldPtr(MemLoc, Cs, FieldList->FieldName),
            "\n");
            break;
        case FT_SIG:
            sig.l = UsbReadFieldUlong(MemLoc, Cs, FieldList->FieldName);
            Sig(sig.l, "");
            break;
        case FT_DEVSPEED:
            l = UsbReadFieldUlong(MemLoc, Cs, FieldList->FieldName);
            dprintf("%s: ",
                FieldList->FieldName);
            switch (l) {
            case UsbLowSpeed:
                dprintf("UsbLowSpeed\n");
                break;
            case UsbFullSpeed:
                dprintf("UsbFullSpeed\n");
                break;
            case UsbHighSpeed:
                dprintf("UsbHighSpeed\n");
                break;            
            }
            break;
        }       
        FieldList++;
    }
    
}

ULONG
CheckSym() 
{
    MEMLOC m;
    
    //
    // Verify that we have the right symbols.
    //

    m = GetExpression ("usbport!USBPORT_MiniportDriverList");

    if (m == 0) {

        dprintf ("Incorrect symbols for USBPORT\n");
        return E_INVALIDARG;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\usbuhci.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbuhci.c

Abstract:

    WinDbg Extension Api
    implements 

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usb.h"
#include "usbhcdi.h"
#include "..\miniport\usbuhci\uhci.h"
#include "..\miniport\usbuhci\usbuhci.h"
#include "usbhcdkd.h"


VOID    
DumpUHCI_DeviceData(
    MEMLOC MemLoc,
    BOOLEAN Verbose
    )
{
    UCHAR cs[] = "usbuhci!_DEVICE_DATA";
    ULONG f, i;
    UCHAR fld[40], fld1[40], fld2[40], fld3[40], fld4[40];
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "Registers", FT_PTR,
        "EnabledInterrupts", FT_ULONG,
        "AsyncQueueHead", FT_PTR,
        "ControllerFlavor", FT_ULONG,
        "LastFrame", FT_ULONG,
        "FrameNumberHighPart", FT_ULONG,
        "PortResetChange", FT_ULONG,
        "PortSuspendChange", FT_ULONG,
        "PortConnectChange", FT_ULONG,
        "IrqStatus", FT_USHORT,
        "PortPowerControl", FT_USHORT,
        "FrameListVA", FT_PTR,
        "ControlQueueHead", FT_PTR,
        "BulkQueueHead", FT_PTR,
        "LastBulkQueueHead", FT_PTR
    
    };

    PrintfMemLoc("*USBUHCI DEVICE DATA ", MemLoc, "\n");
    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

}


VOID    
DumpUHCI_Qh(
    MEMLOC MemLoc
    )
{
    HW_QUEUE_HEAD hwqh;
    ULONG cb;
    UCHAR cs[] = "_HCD_QUEUEHEAD_DESCRIPTOR";
    STRUC_ENTRY qh[] = {
        "Sig", FT_SIG,
        "PhysicalAddress", FT_ULONG,
        "QhFlags", FT_ULONG,
        "NextQh", FT_PTR,
        "PrevQh", FT_PTR,
        "EndpointData", FT_PTR,
    };

    PrintfMemLoc("*USBUHCI QH ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
         &qh[0], sizeof(qh)/sizeof(STRUC_ENTRY));

    ReadMemory(MemLoc,
               &hwqh,
               sizeof(hwqh),
               &cb);

    dprintf("HwQH\n");
    
    // dump as 
    dprintf("\t HLink %08.8x ", hwqh.HLink.HwAddress);
    if (hwqh.HLink.Terminate) {
        dprintf("(T)");    
    } 
    if (hwqh.HLink.QHTDSelect) {
        dprintf("(QH)");    
    } 
    dprintf("\n"); 
    
    dprintf("\t\t Physical Address %08.8x \n", 
        hwqh.HLink.HwAddress & ~HW_LINK_FLAGS_MASK);

     // dump as 
    dprintf("\t VLink %08.8x ", hwqh.VLink.HwAddress);
    if (hwqh.VLink.Terminate) {
        dprintf("(T)");    
    } 
    if (hwqh.VLink.QHTDSelect) {
        dprintf("(QTD)");    
    } 
    dprintf("\n"); 
     
    dprintf("\t\t Physical Address %08.8x \n", 
        hwqh.VLink.HwAddress & ~HW_LINK_FLAGS_MASK);

}


VOID    
DumpUHCI_FrameList(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "usbuhci!_DEVICE_DATA";
    ULONG addr, cb, i;
    MEMLOC fl;
    
    fl = UsbReadFieldPtr(MemLoc, cs, "FrameListVA"), 
    PrintfMemLoc("*FRAME LIST @", fl, "\n");

    for (i = 0; i< 1024; i++) {
        ReadMemory(fl,
                   &addr,
                   sizeof(addr),
                   &cb);    
        dprintf("[%03.3x] - %08.8x  ", i, addr & ~HW_LINK_FLAGS_MASK);                         
        fl+=sizeof(ULONG);

        if ((i+1)%4 == 0) {
            dprintf("\n");
        }
    }                   

}


VOID    
DumpUHCI_Td(
    MEMLOC MemLoc
    )
{
    HW_QUEUE_ELEMENT_TD hwtd;
    ULONG cb;
    UCHAR cs[] = "_HCD_TRANSFER_DESCRIPTOR";
    STRUC_ENTRY td[] = {
        "Sig", FT_SIG,
        "PhysicalAddress", FT_ULONG,
        "Packet[0]", FT_UCHAR,
        "Packet[1]", FT_UCHAR,
        "Packet[2]", FT_UCHAR,
        "Packet[3]", FT_UCHAR,
        "Packet[4]", FT_UCHAR,
        "Packet[5]", FT_UCHAR,
        "Packet[6]", FT_UCHAR,
        "TransferContext", FT_PTR,
        "Flags", FT_ULONG,
        "TransferLength", FT_ULONG,
        "NextHcdTD", FT_PTR,
        "DoubleBufferIndex", FT_ULONG
    };

    PrintfMemLoc("*USBUHCI TD ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &td[0], sizeof(td)/sizeof(STRUC_ENTRY));

    // tds are a fixed size of 64/32 platforms so 
    // we can just read it in

    ReadMemory(MemLoc,
               &hwtd,
               sizeof(hwtd),
               &cb);

    dprintf("HwTD\n");

    // dump as async
    dprintf("\t LinkPointer %08.8x\n", hwtd.LinkPointer);
    dprintf("\t Control %08.8x\n", hwtd.Control);
    dprintf("\t\t Control.Reserved1 %d\n", hwtd.Control.Reserved1);
    dprintf("\t\t Control.ActualLength %d\n", hwtd.Control.ActualLength);
    dprintf("\t\t Control.BitstuffError %d\n", hwtd.Control.BitstuffError);
    dprintf("\t\t Control.Reserved2 %d\n", hwtd.Control.Reserved2);
    dprintf("\t\t Control.TimeoutCRC %d\n", hwtd.Control.TimeoutCRC);
    dprintf("\t\t Control.NAKReceived %d\n", hwtd.Control.NAKReceived);
    dprintf("\t\t Control.BabbleDetected %d\n", hwtd.Control.BabbleDetected);
    dprintf("\t\t Control.DataBufferError %d\n", hwtd.Control.DataBufferError);
    dprintf("\t\t Control.Stalled %d\n", hwtd.Control.Stalled);
    dprintf("\t\t Control.Active %d\n", hwtd.Control.Active);
    dprintf("\t\t Control.InterruptOnComplete %d\n", hwtd.Control.InterruptOnComplete);
    dprintf("\t\t Control.IsochronousSelect %d\n", hwtd.Control.IsochronousSelect);
    dprintf("\t\t Control.LowSpeedDevice %d\n", hwtd.Control.LowSpeedDevice);
    dprintf("\t\t Control.ErrorCount %d\n", hwtd.Control.ErrorCount);
    dprintf("\t\t Control.ShortPacketDetect %d\n", hwtd.Control.ShortPacketDetect);
    dprintf("\t\t Control.Reserved3 %d\n", hwtd.Control.Reserved3);
    dprintf("\t Token %08.8x\n", hwtd.Token);
    dprintf("\t\t Token.DeviceAddress %d\n", hwtd.Token.DeviceAddress);
    dprintf("\t\t Token.Endpoint %d\n", hwtd.Token.Endpoint);
    dprintf("\t\t Token.DataToggle %d\n", hwtd.Token.DataToggle);
    dprintf("\t\t Token.Reserved %d\n", hwtd.Token.Reserved);
    dprintf("\t\t Token.MaximumLength %d\n", hwtd.Token.MaximumLength);
    dprintf("\n");
}


DECLARE_API( _uhcifl )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpUHCI_FrameList (addr);

    return S_OK; 
}

    
DECLARE_API( _uhcitd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpUHCI_Td (addr);

    return S_OK; 
}


DECLARE_API( _uhciqh )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpUHCI_Qh (addr);

    return S_OK; 
}


DECLARE_API( _uhciports )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;

    return S_OK; 
}




DECLARE_API( _uhcidd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
    PCSTR s;
    UCHAR parm[32];

    GetExpressionEx( args, &addr, &s );
    
    sscanf(s, ",%s", &parm);
    dprintf("%s\n", parm);

    DumpUHCI_DeviceData(addr, parm[0] == 'v');

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\async.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   async.c

Abstract:

   miniport transfer code for control and bulk

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    1-1-00 : created, jdunn

--*/

#include "common.h"


//implements the following miniport functions:

//non paged
//EHCI_OpenControlEndpoint
//EHCI_InterruptTransfer
//EHCI_OpenControlEndpoint
//EHCI_InitializeTD
//EHCI_InitializeQH


VOID
EHCI_EnableAsyncList(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;

    hcOp = DeviceData->OperationalRegisters;

    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    cmd.AsyncScheduleEnable = 1;

    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);

    LOGENTRY(DeviceData, G, '_enA', cmd.ul, 0, 0);

}


VOID
EHCI_DisableAsyncList(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;

    hcOp = DeviceData->OperationalRegisters;

    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    cmd.AsyncScheduleEnable = 0;

    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);

    LOGENTRY(DeviceData, G, '_dsL', cmd.ul, 0, 0);

}


VOID
EHCI_LinkTransferToQueue(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR FirstTd
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    BOOLEAN syncWithHw;

    qh = EndpointData->QueueHead;

    // now link the transfers to the queue.
    // Two cases to handle:
    //
    // case 1: HeadP is pointing to dummy, no transfer
    // case 2: HeadP points to possibly active transfer

    LOGENTRY(DeviceData, G, '_L2Q', qh, EndpointData, EndpointData->HcdHeadP);

    syncWithHw = EHCI_HardwarePresent(DeviceData, FALSE);

    EHCI_ASSERT(DeviceData, EndpointData->HcdHeadP != NULL);
    if (EndpointData->HcdHeadP == EndpointData->DummyTd) {
        // The hardware will be accessing the dummy QH
        // link it in

        if (syncWithHw) {
            EHCI_LockQueueHead(DeviceData,
                               qh,
                               EndpointData->Parameters.TransferType);
        }

        qh->HwQH.CurrentTD.HwAddress = EndpointData->QhChkPhys;

        LOGENTRY(DeviceData, G, '_L21', qh, EndpointData, 0);

        qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress =
            FirstTd->HwTD.AltNext_qTD.HwAddress;
        qh->HwQH.Overlay.qTD.Next_qTD.HwAddress =
            FirstTd->PhysicalAddress;
        qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;
        qh->HwQH.Overlay.qTD.Token.Active = 0;
        qh->HwQH.Overlay.qTD.Token.Halted = 0;

        if (syncWithHw) {
            EHCI_UnlockQueueHead(DeviceData,
                                 qh);
        }

        EndpointData->HcdHeadP = FirstTd;
    } else {

        PHCD_TRANSFER_DESCRIPTOR td, lastTd;
        PTRANSFER_CONTEXT transfer, tmp;
        ULONG i;

        // new transfer already points to
        // dummyTd

        // walk the transfer list to the last td
        lastTd = td = EndpointData->HcdHeadP;
        ASSERT_TD(DeviceData, td);
        while (td != EndpointData->DummyTd) {
            lastTd = td;
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            LOGENTRY(DeviceData, G, '_nx2', qh, td, 0);
            ASSERT_TD(DeviceData, td);
        }
        // note last td should not be dummy, if dummy td were
        // head we would not be in this case
        EHCI_ASSERT(DeviceData, lastTd != EndpointData->DummyTd);
        ASSERT_TD(DeviceData, lastTd);
        LOGENTRY(DeviceData, G, '_lst', qh, lastTd, 0);

        transfer = TRANSFER_CONTEXT_PTR(lastTd->TransferContext);

        //EHCI_LockQueueHead(DeviceData,
        //                   qh,
        //                   EndpointData->Parameters.TransferType);

        // fixup the alt_next pointers in the TDs of the
        // last transfer
        for (i=0; i<EndpointData->TdCount; i++) {
            td = &EndpointData->TdList->Td[i];
            tmp = TRANSFER_CONTEXT_PTR(td->TransferContext);
            if (tmp == transfer) {
                SET_ALTNEXT_TD(DeviceData, td, FirstTd);
            }
        }

        // point the last TD at the first TD
        SET_NEXT_TD(DeviceData, lastTd, FirstTd);

        // now check the overlay, if the last TD is cuurent
        // then we need to update the overlay too
        if (qh->HwQH.CurrentTD.HwAddress == lastTd->PhysicalAddress) {
            qh->HwQH.Overlay.qTD.Next_qTD.HwAddress =
                FirstTd->PhysicalAddress;
            qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress =
                EHCI_TERMINATE_BIT;
        }

        //EHCI_UnlockQueueHead(DeviceData,
        //                     qh);

    }
}




PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_InitializeQH(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    )
/*++

Routine Description:

   Initialize an QH for inserting in to the
   schedule

   returns a ptr to the QH passed in

Arguments:


--*/
{

    RtlZeroMemory(Qh, sizeof(*Qh));

    // make double sure we have the prober alignment
    // on the TD structures
    EHCI_ASSERT(DeviceData, (HwPhysAddress & HW_LINK_FLAGS_MASK) == 0);
    Qh->PhysicalAddress = HwPhysAddress;
    ENDPOINT_DATA_PTR(Qh->EndpointData) = EndpointData;
    Qh->Sig = SIG_HCD_QH;

    // init the hw descriptor
    Qh->HwQH.EpChars.DeviceAddress = EndpointData->Parameters.DeviceAddress;
    Qh->HwQH.EpChars.EndpointNumber = EndpointData->Parameters.EndpointAddress;

    switch (EndpointData->Parameters.DeviceSpeed) {
    case LowSpeed:
        Qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_LowSpeed;
        LOGENTRY(DeviceData, G, '_iLS', EndpointData, 0, 0);
        break;
    case FullSpeed:
        Qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_FullSpeed;
        LOGENTRY(DeviceData, G, '_iFS', EndpointData, 0, 0);
        break;
    case HighSpeed:
        Qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_HighSpeed;
        LOGENTRY(DeviceData, G, '_iHS', EndpointData, 0, 0);
        break;
    default:
        USBPORT_BUGCHECK(DeviceData);
    }

    Qh->HwQH.EpChars.MaximumPacketLength =
        EndpointData->Parameters.MaxPacketSize;

    Qh->HwQH.EpCaps.HighBWPipeMultiplier = 1;
    if (EndpointData->Parameters.DeviceSpeed == HcEPCHAR_HighSpeed) {
        Qh->HwQH.EpCaps.HubAddress =  0;
        Qh->HwQH.EpCaps.PortNumber = 0;
    } else {
        Qh->HwQH.EpCaps.HubAddress =
            EndpointData->Parameters.TtDeviceAddress;
        Qh->HwQH.EpCaps.PortNumber =
            EndpointData->Parameters.TtPortNumber;
        if (EndpointData->Parameters.TransferType == Control) {
            Qh->HwQH.EpChars.ControlEndpointFlag = 1;
        }
        LOGENTRY(DeviceData, G, '_iTT',
            EndpointData->Parameters.TtPortNumber,
            EndpointData->Parameters.TtDeviceAddress,
            Qh->HwQH.EpChars.ControlEndpointFlag);
    }

    // init the overlay are such that we are in the 'advance queue'
    // state with the next queue Tds pointing to terminate links
    Qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
    Qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
    Qh->HwQH.Overlay.qTD.Token.Active = 0;
    Qh->HwQH.Overlay.qTD.Token.Halted = 0;

    return Qh;
}


PHCD_TRANSFER_DESCRIPTOR
EHCI_InitializeTD(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    )
/*++

Routine Description:

   Initialize an ED for insertin in to the
   schedule

   returns a ptr to the ED passed in

Arguments:


--*/
{
    RtlZeroMemory(Td, sizeof(*Td));

    // make double sure we have the prober alignment
    // on the TD structures
    EHCI_ASSERT(DeviceData, (HwPhysAddress & HW_LINK_FLAGS_MASK) == 0);
    Td->PhysicalAddress = HwPhysAddress;
    ENDPOINT_DATA_PTR(Td->EndpointData) = EndpointData;
    Td->Sig = SIG_HCD_TD;
    TRANSFER_CONTEXT_PTR(Td->TransferContext) = FREE_TD_CONTEXT;

    return Td;
}


USB_MINIPORT_STATUS
EHCI_ControlTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    )
/*++

Routine Description:

    Initialize a control transfer


    NOTES:

    HW pointers nextTD and AltNextTD are shadowed in
    NextHcdTD and AltNextHcdTD.



Arguments:


--*/
{
    PHCD_TRANSFER_DESCRIPTOR prevTd, td, setupTd, statusTd;
    ULONG lengthMapped, dataTDCount = 0;
    ULONG nextToggle;


    // we can do any control transfer with six TDs
    if (EndpointData->FreeTds < 6)  {
        return USBMP_STATUS_BUSY;
    }

    EndpointData->PendingTransfers++;

    nextToggle = HcTOK_Toggle1;

    // we have enough tds, program the transfer

    //
    // first prepare a TD for the setup packet
    //

    LOGENTRY(DeviceData, G, '_CTR', EndpointData, TransferParameters, 0);

    //
    // allocate setup stage
    //
    TransferContext->PendingTds++;
    setupTd = EHCI_ALLOC_TD(DeviceData, EndpointData);
    INITIALIZE_TD_FOR_TRANSFER(setupTd, TransferContext);

    //
    // Move setup data into TD (8 chars long)
    //
    RtlCopyMemory(&setupTd->Packet[0],
                  &TransferParameters->SetupPacket[0],
                  8);

    // this will set the offset and phys address bits at
    // the same time
    setupTd->HwTD.BufferPage[0].ul = (ULONG)(((PCHAR) &setupTd->Packet[0])
                               - ((PCHAR) &setupTd->HwTD)) + setupTd->PhysicalAddress;

    setupTd->HwTD.Token.BytesToTransfer = 8;
    setupTd->HwTD.Token.Pid = HcTOK_Setup;
    setupTd->HwTD.Token.DataToggle = HcTOK_Toggle0;
    setupTd->HwTD.Token.Active = 1;


    LOGENTRY(DeviceData,
             G, '_set',
             setupTd,
             *((PLONG) &TransferParameters->SetupPacket[0]),
             *((PLONG) &TransferParameters->SetupPacket[4]));

    // allocate the status phase TD now so we can
    // point the data TDs to it
    TransferContext->PendingTds++;
    statusTd = EHCI_ALLOC_TD(DeviceData, EndpointData);
    INITIALIZE_TD_FOR_TRANSFER(statusTd, TransferContext);

    // point setup to status
    SET_ALTNEXT_TD(DeviceData, setupTd, statusTd);

    //
    // now setup the data phase
    //

    td = prevTd = setupTd;
    lengthMapped = 0;
    while (lengthMapped < TransferParameters->TransferBufferLength) {

        //
        // fields for data TD
        //

        td = EHCI_ALLOC_TD(DeviceData, EndpointData);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
        dataTDCount++;
        TransferContext->PendingTds++;
        SET_NEXT_TD(DeviceData, prevTd, td);

        // use direction specified in transfer
        if (TEST_FLAG(TransferParameters->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
            td->HwTD.Token.Pid = HcTOK_In;
        } else {
            td->HwTD.Token.Pid = HcTOK_Out;
        }

        td->HwTD.Token.DataToggle = nextToggle;
        td->HwTD.Token.Active = 1;

        SET_ALTNEXT_TD(DeviceData, td, statusTd);

        LOGENTRY(DeviceData,
            G, '_dta', td, lengthMapped, TransferParameters->TransferBufferLength);

        lengthMapped =
            EHCI_MapAsyncTransferToTd(DeviceData,
                                      EndpointData->Parameters.MaxPacketSize,
                                      lengthMapped,
                                      &nextToggle,
                                      TransferContext,
                                      td,
                                      TransferSGList);

        // calculate next data toggle
        // if number of packets is odd the nextToggle is 0
        // otherwise it is 1




        prevTd = td;
    }

    // last td prepared points to status
    SET_NEXT_TD(DeviceData, td, statusTd);

    //
    // now do the status phase
    //

    LOGENTRY(DeviceData, G, '_sta', statusTd, 0, dataTDCount);

    // do the status phase

    // no buffer
    statusTd->HwTD.BufferPage[0].ul = 0;

    statusTd->HwTD.Token.BytesToTransfer = 0;
    statusTd->TransferLength = 0;
    // status stage is always toggle 1
    statusTd->HwTD.Token.DataToggle = HcTOK_Toggle1;
    statusTd->HwTD.Token.Active = 1;
    statusTd->HwTD.Token.InterruptOnComplete = 1;

    // status phase is opposite data dirrection
    if (TEST_FLAG(TransferParameters->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
        statusTd->HwTD.Token.Pid = HcTOK_Out;
    } else {
        statusTd->HwTD.Token.Pid = HcTOK_In;
    }

    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, td->PhysicalAddress, td);

    // td points to last TD in this transfer, point it at the dummy
    SET_NEXT_TD(DeviceData, statusTd, EndpointData->DummyTd);

    // set the active bit in the setup Phase TD, this will
    // activate the transfer

    PCI_TRIGGER(DeviceData->OperationalRegisters);

    // tell the hc we have control transfers available
    // do this vefore we link in because we will try
    // to sync with the hardware
    EHCI_EnableAsyncList(DeviceData);


    EHCI_LinkTransferToQueue(DeviceData,
                             EndpointData,
                             setupTd);

    ASSERT_DUMMY_TD(DeviceData, EndpointData->DummyTd);


    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_BulkTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferUrb,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
     )
{
    PHCD_TRANSFER_DESCRIPTOR firstTd, prevTd, td, tailTd;
    ULONG lengthMapped;
    ULONG need;

    // figure out how many TDs we will need
    need = TransferUrb->TransferBufferLength/(16*1024)+1;

    if (need > EndpointData->FreeTds) {
        LOGENTRY(DeviceData, G, '_BBS', EndpointData, TransferUrb, 0);
        return USBMP_STATUS_BUSY;
    }

    EndpointData->PendingTransfers++;

    // we have enough tds, program the transfer

    LOGENTRY(DeviceData, G, '_BIT', EndpointData, TransferUrb, 0);

    lengthMapped = 0;
    prevTd = NULL;
    while (lengthMapped < TransferUrb->TransferBufferLength) {

        TransferContext->PendingTds++;
        td = EHCI_ALLOC_TD(DeviceData, EndpointData);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

        if (TransferContext->PendingTds == 1) {
            firstTd = td;
        } else {
            SET_NEXT_TD(DeviceData, prevTd, td);
        }
        SET_ALTNEXT_TD(DeviceData, td, EndpointData->DummyTd);

        //
        // fields for data TD
        //
        td->HwTD.Token.InterruptOnComplete = 1;

        // use direction specified in transfer
        if (TEST_FLAG(TransferUrb->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
            td->HwTD.Token.Pid = HcTOK_In;
        } else {
            td->HwTD.Token.Pid = HcTOK_Out;
        }

        td->HwTD.Token.DataToggle = HcTOK_Toggle1;
        td->HwTD.Token.Active = 1;

        LOGENTRY(DeviceData,
            G, '_dta', td, lengthMapped, TransferUrb->TransferBufferLength);

        lengthMapped =
            EHCI_MapAsyncTransferToTd(DeviceData,
                                      EndpointData->Parameters.MaxPacketSize,
                                      lengthMapped,
                                      NULL,
                                      TransferContext,
                                      td,
                                      TransferSGList);

        prevTd = td;
    }

    // special case the zero length transfer
    if (TransferUrb->TransferBufferLength == 0) {

        TEST_TRAP();

        TransferContext->PendingTds++;
        td = EHCI_ALLOC_TD(DeviceData, EndpointData);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

        EHCI_ASSERT(DeviceData, TransferContext->PendingTds == 1);
        firstTd = td;
        SET_ALTNEXT_TD(DeviceData, td, EndpointData->DummyTd);

        td->HwTD.Token.InterruptOnComplete = 1;

        // use direction specified in transfer
        if (TEST_FLAG(TransferUrb->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
            td->HwTD.Token.Pid = HcTOK_In;
        } else {
            td->HwTD.Token.Pid = HcTOK_Out;
        }

        td->HwTD.Token.DataToggle = HcTOK_Toggle1;
        td->HwTD.Token.Active = 1;

        // point to a dummy buffer
        td->HwTD.BufferPage[0].ul =
            td->PhysicalAddress;

        td->HwTD.Token.BytesToTransfer =
            0;
        td->TransferLength = 0;
    }

    // td points to last TD in this transfer, point it at the dummy
    SET_NEXT_TD(DeviceData, td, EndpointData->DummyTd);

    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, td->PhysicalAddress, td);
    LOGENTRY(DeviceData, G,
        '_ftd',  0, 0, firstTd);

    // we now have a complete setup of TDs representing this transfer
    // (Next)    firstTd(1)->{td}(2)->{td}(3)->td(4)->dummyTd(tbit)
    // (AltNext) all point to dummyTd (tbit)
//TEST_TRAP();
    // tell the hc we have control transfers available
    EHCI_EnableAsyncList(DeviceData);

    EHCI_LinkTransferToQueue(DeviceData,
                             EndpointData,
                             firstTd);

    ASSERT_DUMMY_TD(DeviceData, EndpointData->DummyTd);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_OpenBulkOrControlEndpoint(
     PDEVICE_DATA DeviceData,
     BOOLEAN Control,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, qhPhys;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG i;
    ULONG tdCount, bytes;
    PHCD_TRANSFER_DESCRIPTOR dummyTd;

    LOGENTRY(DeviceData, G, '_opC', 0, 0, EndpointParameters);

    InitializeListHead(&EndpointData->DoneTdList);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    // how much did we get
    bytes = EndpointParameters->CommonBufferBytes;

    // 256 byte block used to check for overlay sync
    // problems
    EndpointData->QhChkPhys = phys;
    EndpointData->QhChk = buffer;
    RtlZeroMemory(buffer, 256);
    phys += 256;
    buffer += 256;
    bytes -= 256;

    // make the Ed
    qh = (PHCD_QUEUEHEAD_DESCRIPTOR) buffer;
    qhPhys = phys;
    // how much did we get

    phys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    buffer += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    bytes -= sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

    tdCount = bytes/sizeof(HCD_TRANSFER_DESCRIPTOR);
    EHCI_ASSERT(DeviceData, tdCount >= TDS_PER_CONTROL_ENDPOINT);

    if (EndpointParameters->TransferType == Control) {
        SET_FLAG(EndpointData->Flags, EHCI_EDFLAG_NOHALT);
    }

    EndpointData->TdList = (PHCD_TD_LIST) buffer;
    EndpointData->TdCount = tdCount;
    for (i=0; i<tdCount; i++) {
        EHCI_InitializeTD(DeviceData,
                          EndpointData,
                          &EndpointData->TdList->Td[i],
                          phys);

        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);
    }
    EndpointData->FreeTds = tdCount;

    EndpointData->QueueHead =
        EHCI_InitializeQH(DeviceData,
                          EndpointData,
                          qh,
                          qhPhys);

    if (Control) {
        // use data toggle in the TDs for control
        qh->HwQH.EpChars.DataToggleControl = HcEPCHAR_Toggle_From_qTD;
        EHCI_ASSERT(DeviceData, tdCount >= TDS_PER_CONTROL_ENDPOINT);
        EndpointData->HcdHeadP = NULL;

    } else {
        PHCD_TRANSFER_DESCRIPTOR dummyTd;

        qh->HwQH.EpChars.DataToggleControl = HcEPCHAR_Ignore_Toggle;
        EHCI_ASSERT(DeviceData, tdCount >= TDS_PER_BULK_ENDPOINT);
        //qh->HwQH.EpChars.NakReloadCount = 4;

    }

    // allocate a dummy TD for short tranfsers
    // the dummy TD is usd to mark the end of the cuurent transfer
    //
    dummyTd = EHCI_ALLOC_TD(DeviceData, EndpointData);
    dummyTd->HwTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
    TRANSFER_DESCRIPTOR_PTR(dummyTd->NextHcdTD) = NULL;
    dummyTd->HwTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
    TRANSFER_DESCRIPTOR_PTR(dummyTd->AltNextHcdTD) = NULL;
    dummyTd->HwTD.Token.Active = 0;
    SET_FLAG(dummyTd->Flags, TD_FLAG_DUMMY);
    EndpointData->DummyTd = dummyTd;
    EndpointData->HcdHeadP = dummyTd;

    // endpoint is not active, set up the overlay
    // so that the currentTD is the Dummy

    qh->HwQH.CurrentTD.HwAddress = dummyTd->PhysicalAddress;
    qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
    qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
    qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;
    qh->HwQH.Overlay.qTD.Token.Active = 0;

    // we now have an inactive QueueHead and a Dummy
    // tail TD

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_InsertQueueHeadInAsyncList(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh
    )
/*++

Routine Description:

   Insert an aync endpoint (queue head)
   into the HW list

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR asyncQh, nextQh;
    HW_LINK_POINTER newLink;

    asyncQh = DeviceData->AsyncQueueHead;

    LOGENTRY(DeviceData, G, '_Ain', 0, Qh, asyncQh);
    EHCI_ASSERT(DeviceData, !TEST_FLAG(Qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE));

    // ASYNC QUEUE looks like this:
    //
    //
    //            |- we insert here
    //|static QH|<->|xfer QH|<->|xfer QH|<->
    //     |                              |
    //     ---------------<->--------------

    // link new qh to the current 'head' ie
    // first transfer QH
    nextQh = QH_DESCRIPTOR_PTR(asyncQh->NextQh);

    Qh->HwQH.HLink.HwAddress =
        asyncQh->HwQH.HLink.HwAddress;
    QH_DESCRIPTOR_PTR(Qh->NextQh) = nextQh;
    QH_DESCRIPTOR_PTR(Qh->PrevQh) = asyncQh;

    QH_DESCRIPTOR_PTR(nextQh->PrevQh) = Qh;

    // put the new qh at the head of the queue

    newLink.HwAddress = Qh->PhysicalAddress;
    SET_QH(newLink.HwAddress);
    asyncQh->HwQH.HLink.HwAddress = newLink.HwAddress;
    QH_DESCRIPTOR_PTR(asyncQh->NextQh) = Qh;

    SET_FLAG(Qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE);

}


VOID
EHCI_RemoveQueueHeadFromAsyncList(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh
    )
/*++

Routine Description:

   Remove a aync endpoint (queue head)
   into the HW list

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR nextQh, prevQh, asyncQh;
    HW_LINK_POINTER newLink;
    HW_LINK_POINTER asyncHwQh;
    HW_32BIT_PHYSICAL_ADDRESS tmp;
    PHC_OPERATIONAL_REGISTER hcOp;

    hcOp = DeviceData->OperationalRegisters;

    LOGENTRY(DeviceData, G, '_Arm', Qh, 0, 0);
    // if already removed bail
    if (!TEST_FLAG(Qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE)) {
        return;
    }

    nextQh = QH_DESCRIPTOR_PTR(Qh->NextQh);
    prevQh = QH_DESCRIPTOR_PTR(Qh->PrevQh);;

    // ASYNC QUEUE looks like this:
    //
    //|static QH|->|xfer QH|->|xfer QH|->
    //     |                            |
    //     -------------<----------------

    asyncQh = DeviceData->AsyncQueueHead;
    asyncHwQh.HwAddress = asyncQh->PhysicalAddress;
    SET_QH(asyncHwQh.HwAddress);

    // unlink
    LOGENTRY(DeviceData, G, '_ulk', Qh, prevQh, nextQh);
    newLink.HwAddress = nextQh->PhysicalAddress;
    SET_QH(newLink.HwAddress);
    prevQh->HwQH.HLink.HwAddress =
        newLink.HwAddress;
    QH_DESCRIPTOR_PTR(prevQh->NextQh) = nextQh;
    QH_DESCRIPTOR_PTR(nextQh->PrevQh) = prevQh;

    // flush the HW cache after an unlink, the scheduke
    // should be enabled if we are removeing a QH
    EHCI_AsyncCacheFlush(DeviceData);

    // we need to update the async list base address reg in case this
    // qh is the current qh, if it is we will just replace it with
    // the static version
    tmp = READ_REGISTER_ULONG(&hcOp->AsyncListAddr);

    if (tmp == Qh->PhysicalAddress) {
        TEST_TRAP();
        WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr,
                             asyncHwQh.HwAddress);
    }

    CLEAR_FLAG(Qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE);
}


// figure out which sgentry a particular offset in to
// a client buffer falls
#define GET_SG_INDEX(sg, i, offset)\
    for((i)=0; (i) < (sg)->SgCount; (i)++) {\
        if ((offset) >= (sg)->SgEntry[(i)].StartOffset &&\
            (offset) < (sg)->SgEntry[(i)].StartOffset+\
                (sg)->SgEntry[(i)].Length) {\
            break;\
        }\
    }

#define GET_SG_OFFSET(sg, i, offset, sgoffset)\
    (sgoffset) = (offset) - (sg)->SgEntry[(i)].StartOffset


ULONG
EHCI_MapAsyncTransferToTd(
    PDEVICE_DATA DeviceData,
    ULONG MaxPacketSize,
    ULONG LengthMapped,
    PULONG NextToggle,
    PTRANSFER_CONTEXT TransferContext,
    PHCD_TRANSFER_DESCRIPTOR Td,
    PTRANSFER_SG_LIST SgList
    )
/*++

Routine Description:

    Maps a data buffer to TDs according to EHCI rules

    An EHCI TD can cover up to 20k with 5 page crossing.
    Note that 20k is the most data a single td can describe

    Each sg entry represents one 4k EHCI 'page'

x = pagebreak
c = current ptr
b = buffer start
e = buffer end


    {..sg[sgIdx]..}
b...|---
    x--c----
    [  ]
        \
         sgOffset
[      ]
        \
         LengthMapped


Worst case for 20k transfer has 5 page breaks and requires
but 6 bp entries

    {..sg0..}{..sg1..}{..sg2..}{..sg3..}{..sg4..}{..sg5..}
    |        |        |        |        |        |        |
    x--------x--------x--------x--------x--------x--------x
        b-------------------------------------------->e
    <..bp0..><..bp1..><..bp2..><..bp3..><..bp4..>



case 1: (<6 sg entries remain)
    (A)- transfer < 16k,  page breaks (if c=b sgOffset = 0)

    {..sg0..}{..sg1..}{..sg2..}{..sg3..}{..sg4..}
    |        |        |        |        |        |
    x--------x--------x--------x--------x--------x
        b------------------------------------>e
    <..bp0..><..bp1..><..bp2..><..bp3..><..bp4..>
        [.................iTD.................]

    (B)- last part of a transfer

             {..sgN..}{.sgN+1.}{.sgN+2.}{.sgN+3.}{.sgN+4.}
             |        |        |        |        |        |
             x--------x--------x--------x--------x--------x
       b.....|.c------------------------------------->e
             <..bp0..><..bp1..><..bp2..><..bp3..><..bp4..>
               [..................iTD.................]

case 2:  (>5 sg entries remain)
    (A)- transfer > 20k, first part of a large transfer

    {..sg0..}{..sg1..}{..sg2..}{..sg3..}{..sg4..}{..sg5..}
    |        |        |        |        |        |        |
    x--------x--------x--------x--------x--------x--------x
        b-------------------------------------------->e
    <..bp0..><..bp1..><..bp2..><..bp3..><..bp4..>
        [....................iTD................]

    (B)- continuation of a large transfer


Interesting DMA tests (USBTEST):

    length, offset - cases hit


Arguments:

Returns:

    LengthMapped

--*/
{
    ULONG sgIdx, sgOffset, bp, i;
    ULONG lengthThisTd;
    PTRANSFER_PARAMETERS tp;

    // A TD can have up to 5 page crossing.  This means we
    // can put 5 sg entries in to one TD.

    // point to first entry

    LOGENTRY(DeviceData, G, '_Mpr', TransferContext,
        0, LengthMapped);

    EHCI_ASSERT(DeviceData, SgList->SgCount != 0);

    tp = TransferContext->TransferParameters;

    GET_SG_INDEX(SgList, sgIdx, LengthMapped);
    LOGENTRY(DeviceData, G, '_Mpp', SgList, 0, sgIdx);
    EHCI_ASSERT(DeviceData, sgIdx < SgList->SgCount);

    if ((SgList->SgCount-sgIdx) < 6) {
        // first case, <6 entries left
        // ie <20k, we can fit this in
        // a single TD.

#if DBG
        if (sgIdx == 0) {
            // case 1A
            // USBT dma test length 4096, offset 0
            // will hit this case
            // TEST_TRAP();
            LOGENTRY(DeviceData, G, '_c1a', SgList, 0, sgIdx);
        } else {
            // case 1B
            // USBT dma test length 8192 offset 512
            // will hit this case
            LOGENTRY(DeviceData, G, '_c1b', SgList, 0, sgIdx);
            //TEST_TRAP();
        }
#endif
        lengthThisTd = tp->TransferBufferLength - LengthMapped;

        // compute offset into this TD
        GET_SG_OFFSET(SgList, sgIdx, LengthMapped, sgOffset);
        LOGENTRY(DeviceData, G, '_sgO', sgOffset, sgIdx, LengthMapped);

        // adjust for the amount of buffer consumed by the
        // previous TD

        // sets current offset and address at the same time
        Td->HwTD.BufferPage[0].ul =
            SgList->SgEntry[sgIdx].LogicalAddress.Hw32 + sgOffset;

        i = sgIdx+1;
        for (bp = 1; bp < 5 && i < SgList->SgCount; bp++,i++) {
            Td->HwTD.BufferPage[bp].ul =
                SgList->SgEntry[i].LogicalAddress.Hw32;
            EHCI_ASSERT(DeviceData, Td->HwTD.BufferPage[bp].CurrentOffset == 0);
        }

        LOGENTRY(DeviceData, G, '_sg1', Td->HwTD.BufferPage[0].ul, 0,
            0);

    } else {
        // second case, >=6 entries left
        // we will need more than one TD
        ULONG adjust, packetCount;
#if DBG
        if (sgIdx == 0) {
            // case 2A
            // USBT dma test length 8192 offset 512
            // will hit this case
            LOGENTRY(DeviceData, G, '_c2a', SgList, 0, sgIdx);
            //TEST_TRAP();
        } else {
            // case 2B
            // USBT dma test length 12288 offset 1
            // will hit this case
            LOGENTRY(DeviceData, G, '_c2b', SgList, 0, sgIdx);
            //TEST_TRAP();
        }
#endif
        // sg offset is the offset in to the current TD to start
        // using
        // ie it is the number of bytes already consumed by the
        // previous td
        GET_SG_OFFSET(SgList, sgIdx, LengthMapped, sgOffset);
        LOGENTRY(DeviceData, G, '_sgO', sgOffset, sgIdx, LengthMapped);
#if DBG
        if (sgIdx == 0) {
             EHCI_ASSERT(DeviceData, sgOffset == 0);
        }
#endif
        //
        // consume the next 4 sgEntries
        //

        // sets currentOffset at the same time
        Td->HwTD.BufferPage[0].ul =
            SgList->SgEntry[sgIdx].LogicalAddress.Hw32+sgOffset;
        lengthThisTd = EHCI_PAGE_SIZE - Td->HwTD.BufferPage[0].CurrentOffset;

        i = sgIdx+1;
        for (bp = 1; bp < 5; bp++,i++) {
            Td->HwTD.BufferPage[bp].ul =
                SgList->SgEntry[i].LogicalAddress.Hw32;
            EHCI_ASSERT(DeviceData, Td->HwTD.BufferPage[bp].CurrentOffset == 0);
            EHCI_ASSERT(DeviceData, i < SgList->SgCount);
            lengthThisTd += EHCI_PAGE_SIZE;
        }

        // round TD length down to the highest multiple
        // of max_packet size

        packetCount = lengthThisTd/MaxPacketSize;
        LOGENTRY(DeviceData, G, '_sg2', MaxPacketSize, packetCount, lengthThisTd);

        adjust = lengthThisTd - packetCount*MaxPacketSize;

        if (adjust) {
            lengthThisTd-=adjust;
            LOGENTRY(DeviceData, G, '_adj', adjust, lengthThisTd, 0);
        }

        if (NextToggle) {
        // calculate next data toggle if requested
        // two cases
        // case 1: prev NextToggle is 1
            // if number of packets is odd the nextToggle is 0
            // otherwise it is 1
        // case 2: prev NextToggle is 0
            // if number of packets is odd the nextToggle is 1
            // otherwise it is 0

        // so if packet count is even the value remains unchanged
        // otherwise we have to toggle it.
            if (packetCount % 2) {
                // packet count this TD is odd
                *NextToggle = (*NextToggle) ? 0 : 1;
            }
        }

        EHCI_ASSERT(DeviceData, lengthThisTd != 0);
        EHCI_ASSERT(DeviceData, lengthThisTd >= SgList->SgEntry[sgIdx].Length);

    }

    LengthMapped += lengthThisTd;
    Td->HwTD.Token.BytesToTransfer =
            lengthThisTd;
    Td->TransferLength = lengthThisTd;

    LOGENTRY(DeviceData, G, '_Mp1', LengthMapped, lengthThisTd, Td);

    return LengthMapped;
}


VOID
EHCI_SetAsyncEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHC_OPERATIONAL_REGISTER hcOp;
    ENDPOINT_TRANSFER_TYPE epType;

    qh = EndpointData->QueueHead;

    epType = EndpointData->Parameters.TransferType;

    switch(State) {
    case ENDPOINT_ACTIVE:
        if (epType == Interrupt) {
            // now insert the qh in the schedule
            EHCI_InsertQueueHeadInPeriodicList(DeviceData,
                                              EndpointData);

        } else {
            // put queue head in the schedule
            EHCI_InsertQueueHeadInAsyncList(DeviceData,
                                            EndpointData->QueueHead);
        }
        break;

    case ENDPOINT_PAUSE:
        // remove queue head from the schedule
        if (epType == Interrupt) {
            EHCI_RemoveQueueHeadFromPeriodicList(DeviceData,
                                                 EndpointData);
        } else {
            EHCI_RemoveQueueHeadFromAsyncList(DeviceData,
                                              EndpointData->QueueHead);
        }
        break;

    case ENDPOINT_REMOVE:
        qh->QhFlags |= EHCI_QH_FLAG_QH_REMOVED;

        if (epType == Interrupt) {
            EHCI_RemoveQueueHeadFromPeriodicList(DeviceData,
                                                 EndpointData);
        } else {
            EHCI_RemoveQueueHeadFromAsyncList(DeviceData,
                                              EndpointData->QueueHead);
        }

        // generate a cache flush after we remove so the the HW
        // does not have the QH cached
        EHCI_InterruptNextSOF(DeviceData);

        break;

    default:

        TEST_TRAP();
    }

    EndpointData->State = State;
}


MP_ENDPOINT_STATUS
EHCI_GetAsyncEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MP_ENDPOINT_STATUS status;

    status = ENDPOINT_STATUS_RUN;

    if (TEST_FLAG(EndpointData->Flags, EHCI_EDFLAG_HALTED)) {
        status = ENDPOINT_STATUS_HALT;
    }

    LOGENTRY(DeviceData, G, '_gps', EndpointData, status, 0);

    return status;
}


VOID
EHCI_SetAsyncEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATUS Status
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    qh = EndpointData->QueueHead;

    LOGENTRY(DeviceData, G, '_set', EndpointData, Status, 0);

    switch(Status) {
    case ENDPOINT_STATUS_RUN:
        CLEAR_FLAG(EndpointData->Flags, EHCI_EDFLAG_HALTED);

        qh->HwQH.Overlay.qTD.Token.Halted = 0;
        break;

    case ENDPOINT_STATUS_HALT:
        TEST_TRAP();
        break;
    }
}


VOID
EHCI_ProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
/*++

Routine Description:

    process a completed TD

Parameters

--*/
{
    PTRANSFER_CONTEXT transferContext;
    PENDPOINT_DATA endpointData;
    PTRANSFER_PARAMETERS tp;
    USBD_STATUS usbdStatus;
    ULONG byteCount;

    transferContext = TRANSFER_CONTEXT_PTR(Td->TransferContext);
    ASSERT_TRANSFER(DeviceData, transferContext);

    tp = transferContext->TransferParameters;
    transferContext->PendingTds--;
    endpointData = transferContext->EndpointData;

    if (TEST_FLAG(Td->Flags, TD_FLAG_SKIP)) {
        LOGENTRY(DeviceData, G, '_Ktd', transferContext,
                         0,
                         Td);

        goto free_it;
    }

    // completion status for this TD?
    // since the endpoint halts on error the  error
    // bits should have been written back to the TD
    // we use these bits to dermine the error
    if (Td->HwTD.Token.Halted == 1) {
        usbdStatus = EHCI_GetErrorFromTD(DeviceData,
                                         endpointData,
                                         Td);
    } else {
        usbdStatus = USBD_STATUS_SUCCESS;
    }

    LOGENTRY(DeviceData, G, '_Dtd', transferContext,
                         usbdStatus,
                         Td);

    byteCount = Td->TransferLength -
        Td->HwTD.Token.BytesToTransfer;

    LOGENTRY(DeviceData, G, '_tln', byteCount,
        Td->TransferLength, Td->HwTD.Token.BytesToTransfer);

    if (Td->HwTD.Token.Pid != HcTOK_Setup) {

        // data or status phase of a control transfer or a bulk/int
        // data transfer
        LOGENTRY(DeviceData, G, '_Idt', Td, transferContext, byteCount);

        transferContext->BytesTransferred += byteCount;

    }

    // note that we only set transferContext->UsbdStatus
    // if we find a TD with an error this will cause us to
    // record the last TD with an error as the error for
    // the transfer.
    if (USBD_STATUS_SUCCESS != usbdStatus) {

        // map the error to code in USBDI.H
        transferContext->UsbdStatus =
            usbdStatus;

        LOGENTRY(DeviceData, G, '_tER', transferContext->UsbdStatus, 0, 0);
    }

free_it:

    // mark the TD free
    EHCI_FREE_TD(DeviceData, endpointData, Td);

    if (transferContext->PendingTds == 0) {
        // all TDs for this transfer are done
        // clear the HAVE_TRANSFER flag to indicate
        // we can take another
        endpointData->PendingTransfers--;
//if (transferContext->BytesTransferred == 0 &&
//    endpointData->Parameters.TransferType == Bulk) {
//    TEST_TRAP();
//}
        LOGENTRY(DeviceData, G, '_cpt',
            transferContext->UsbdStatus,
            transferContext,
            transferContext->BytesTransferred);


        USBPORT_COMPLETE_TRANSFER(DeviceData,
                                  endpointData,
                                  tp,
                                  transferContext->UsbdStatus,
                                  transferContext->BytesTransferred);
    }
}


USBD_STATUS
EHCI_GetErrorFromTD(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
/*++

Routine Description:

    Maps the error bits in the TD to a USBD_STATUS code

Arguments:

Return Value:

--*/

{
    LOGENTRY(DeviceData, G, '_eTD', Td->HwTD.Token.ul, Td, 0);

    EHCI_ASSERT(DeviceData, Td->HwTD.Token.Halted == 1);
        //ULONG MissedMicroFrame:1; // 2
        //ULONG XactErr:1;          // 3
        //ULONG BabbleDetected:1;   // 4
        //ULONG DataBufferError:1;  // 5

    if (Td->HwTD.Token.XactErr) {
        LOGENTRY(DeviceData, G, '_mp1', 0, 0, 0);

        return USBD_STATUS_XACT_ERROR;
    }

    if (Td->HwTD.Token.BabbleDetected) {
        LOGENTRY(DeviceData, G, '_mp2', 0, 0, 0);

        return USBD_STATUS_BABBLE_DETECTED;
    }

    if (Td->HwTD.Token.DataBufferError) {
        LOGENTRY(DeviceData, G, '_mp3', 0, 0, 0);

        return USBD_STATUS_DATA_BUFFER_ERROR;
    }

    if (Td->HwTD.Token.MissedMicroFrame) {
        LOGENTRY(DeviceData, G, '_mp6', 0, 0, 0);
        return USBD_STATUS_XACT_ERROR;
    }

    // no bit set -- treat as a stall
    LOGENTRY(DeviceData, G, '_mp4', 0, 0, 0);
    return USBD_STATUS_STALL_PID;

}


VOID
EHCI_AbortAsyncTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_CONTEXT TransferContext
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'

    The goal here is to determine which TDs, if any,
    have completed and complete ant associated transfers

Arguments:

Return Value:

--*/
{

    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_32BIT_PHYSICAL_ADDRESS abortTdPhys;
    PTRANSFER_CONTEXT currentTransfer;
    ULONG byteCount;

    qh = EndpointData->QueueHead;

    // The endpoint should not be in the schedule

    LOGENTRY(DeviceData, G, '_abr', qh, TransferContext, EndpointData->HcdHeadP);
    EHCI_ASSERT(DeviceData, !TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE));

    // one less pending transfer
    EndpointData->PendingTransfers--;

    // our mission now is to remove all TDs associated with
    // this transfer

    // get the last known head, we update the head when we process
    // (AKA poll) the enopoint.
    // walk the list to the tail (dummy) TD

    // find the transfer we wish to cancel...

    // walk the list and find the first TD belonging
    // to this transfer

    // cases to handle
    // case 1 this is the first transfer in the list
    // case 2 this is a middle transfer in the list
    // case 3 this is the last transfer in the list
    // case 4 transfer is not in the list

    td = EndpointData->HcdHeadP;

    ASSERT_TD(DeviceData, td);

    if (TRANSFER_CONTEXT_PTR(td->TransferContext) == TransferContext) {

        // case 1
        byteCount = 0;

        while (td != EndpointData->DummyTd &&
               TRANSFER_CONTEXT_PTR(td->TransferContext) == TransferContext) {
            PHCD_TRANSFER_DESCRIPTOR tmp;

            // see if any data has been transferred
            byteCount += (td->TransferLength -
                td->HwTD.Token.BytesToTransfer);

            tmp = td;
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            EHCI_FREE_TD(DeviceData, EndpointData, tmp)
        }

        if (byteCount) {
            TransferContext->BytesTransferred += byteCount;
        }

        // td now points to the 'next transfer TD'

        // this puts us in the 'advance queue' state
        // ie overlay is !active && !halted, update the
        // overlay area as appropriate.
        //
        // NOTE: the hw is not accessing the qh at this time

        // do not zero the queue head because this will
        // trash the state of the data toggle
        //RtlZeroMemory(&qh->HwQH.Overlay.qTD,
        //              sizeof(qh->HwQH.Overlay.qTD));

        // point at the waste area to check for sync problems
        qh->HwQH.CurrentTD.HwAddress = EndpointData->QhChkPhys;

        qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress =
            td->HwTD.AltNext_qTD.HwAddress;
        qh->HwQH.Overlay.qTD.Next_qTD.HwAddress =
            td->PhysicalAddress;
        qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;
        qh->HwQH.Overlay.qTD.Token.Active = 0;
        qh->HwQH.Overlay.qTD.Token.Halted = 0;

        EndpointData->HcdHeadP = td;

    } else {

        PHCD_TRANSFER_DESCRIPTOR prevTd, nextTd;

        // determine the current transfer in the overlay
        EHCI_ASSERT(DeviceData, qh->HwQH.CurrentTD.HwAddress);

        currentTd = (PHCD_TRANSFER_DESCRIPTOR)
                USBPORT_PHYSICAL_TO_VIRTUAL(qh->HwQH.CurrentTD.HwAddress,
                                            DeviceData,
                                            EndpointData);
        currentTransfer =
                TRANSFER_CONTEXT_PTR(currentTd->TransferContext);

        LOGENTRY(DeviceData, G, '_Act', currentTransfer,
            currentTd, EndpointData->HcdHeadP);

        // case 2, 3

        // walk from the head to the first td of the transfer
        // we are interested in.

        prevTd = td = EndpointData->HcdHeadP;
        while (td != NULL) {
            PHCD_TRANSFER_DESCRIPTOR tmp;

            if (TRANSFER_CONTEXT_PTR(td->TransferContext) == TransferContext) {
                break;
            }

            prevTd = td;
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);

            LOGENTRY(DeviceData, G, '_nxt', prevTd, td, 0);

        }
        LOGENTRY(DeviceData, G, '_atd', 0, td, 0);

        abortTdPhys = td->PhysicalAddress;
        // now walk to the first td of the next transfer, free
        // TDs for this transfer as we go
        while (td != NULL &&
               TRANSFER_CONTEXT_PTR(td->TransferContext) == TransferContext) {
            PHCD_TRANSFER_DESCRIPTOR tmp;

            tmp = td;
            EHCI_FREE_TD(DeviceData, EndpointData, tmp)
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
        }

        nextTd = td;

        LOGENTRY(DeviceData, G, '_Apn', prevTd,
            nextTd, abortTdPhys);

        // now link prevTd to nextTd
        if (prevTd == NULL) {
            // case 4 transfer not in the list
            // should this happen?
            TEST_TRAP();
        }

        // next TD might be dummy
        EHCI_ASSERT(DeviceData, nextTd != NULL);
        EHCI_ASSERT(DeviceData, prevTd != NULL);

        SET_NEXT_TD(DeviceData, prevTd, nextTd);
        SET_ALTNEXT_TD(DeviceData, prevTd, nextTd);

        // fixup overlay area as needed,
        // if the aborted transfer was current we want to pick
        // up the next transfer

        if (currentTransfer == TransferContext) {
            LOGENTRY(DeviceData, G, '_At1', currentTransfer, 0, 0);
            // aborted transfer is current, prime the
            // overlay with the next transfer

            // catch HW sync problems
            qh->HwQH.CurrentTD.HwAddress = EndpointData->QhChkPhys;

            qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = nextTd->PhysicalAddress;
            qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
            qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;
            qh->HwQH.Overlay.qTD.Token.Active = 0;
            // preserve halted bit

        } else if (TRANSFER_CONTEXT_PTR(prevTd->TransferContext) ==
                   currentTransfer) {
            // previous transfer was current, make sure the overlay
            // area (current transfer) does not point to a deleted td
            LOGENTRY(DeviceData, G, '_At2', currentTransfer, 0, 0);

            // check overlay
            if (qh->HwQH.Overlay.qTD.Next_qTD.HwAddress == abortTdPhys) {
                qh->HwQH.Overlay.qTD.Next_qTD.HwAddress =
                    nextTd->PhysicalAddress;
            }

            if (qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress == abortTdPhys) {
                qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress =
                    nextTd->PhysicalAddress;
            }

            // correct all TDs for the current transfer
            td = EndpointData->HcdHeadP;
            while (td != NULL) {
                PHCD_TRANSFER_DESCRIPTOR tmp;

                if (TRANSFER_CONTEXT_PTR(td->TransferContext) == currentTransfer) {
                    td->HwTD.Next_qTD.HwAddress = nextTd->PhysicalAddress;
                    td->HwTD.AltNext_qTD.HwAddress = nextTd->PhysicalAddress;
                }

                td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            }
        }
    }
}


USB_MINIPORT_STATUS
EHCI_PokeAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    qh = EndpointData->QueueHead;
    EHCI_ASSERT(DeviceData, qh != NULL);

    EndpointData->Parameters = *EndpointParameters;

    qh->HwQH.EpChars.DeviceAddress =
        EndpointData->Parameters.DeviceAddress;

    qh->HwQH.EpChars.MaximumPacketLength =
        EndpointData->Parameters.MaxPacketSize;

    qh->HwQH.EpCaps.HubAddress =
        EndpointData->Parameters.TtDeviceAddress;

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_LockQueueHead(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh,
     ENDPOINT_TRANSFER_TYPE EpType
    )
/*++

Routine Description:

    Synchronously update the overlate area, this involves using the
    doorbell to wait for queue head to flush off the HC hardware

    the caller is responisble for resuming

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;
    PHCD_QUEUEHEAD_DESCRIPTOR nextQh, prevQh;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    ULONG mf, cmf;

    hcOp = DeviceData->OperationalRegisters;

    LOGENTRY(DeviceData, G, '_LKq', Qh, 0, 0);

    EHCI_ASSERT(DeviceData, !TEST_FLAG(Qh->QhFlags, EHCI_QH_FLAG_UPDATING));
    EHCI_ASSERT(DeviceData, DeviceData->LockQh == NULL);

    SET_FLAG(Qh->QhFlags, EHCI_QH_FLAG_UPDATING);

    nextQh = QH_DESCRIPTOR_PTR(Qh->NextQh);
    prevQh = QH_DESCRIPTOR_PTR(Qh->PrevQh);
    ASSERT(prevQh);

    DeviceData->LockPrevQh = prevQh;
    DeviceData->LockNextQh = nextQh;
    DeviceData->LockQh = Qh;

    if (nextQh) {
        phys = nextQh->PhysicalAddress;
        SET_QH(phys);
    } else {
        phys = 0;
        SET_T_BIT(phys);
    }

    // note that we only mess with the HW nextlinks and this
    // is temporary

    // unlink this queue head
    prevQh->HwQH.HLink.HwAddress = phys;
    mf = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

    if (EpType == Interrupt) {

        do {
            cmf = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);
        } while (cmf == mf);

    } else {
        EHCI_AsyncCacheFlush(DeviceData);
    }

    LOGENTRY(DeviceData, G, '_LKx', Qh, 0, 0);


}


VOID
EHCI_AsyncCacheFlush(
     PDEVICE_DATA DeviceData
     )
/*++

Routine Description:

    Synchronously flushes the async controlle cache by ringing
    the async doorbell and waiting

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;

    hcOp = DeviceData->OperationalRegisters;

    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    EHCI_ASSERT(DeviceData, cmd.AsyncScheduleEnable == 1);
    // if not enabled enable it, this would be a bug though
    cmd.AsyncScheduleEnable = 1;

    cmd.IntOnAsyncAdvanceDoorbell = 1;
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);

    // wait for it.
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    while (cmd.HostControllerRun &&
           cmd.IntOnAsyncAdvanceDoorbell &&
           cmd.ul != 0xFFFFFFFF) {
        KeStallExecutionProcessor(1);
        cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    }
}


VOID
EHCI_UnlockQueueHead(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh
     )
/*++

Routine Description:

    compliment to LockQueueHead, this function reactivates the qh after
    modifications are complete

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR nextQh, prevQh;
    HW_32BIT_PHYSICAL_ADDRESS phys;

    LOGENTRY(DeviceData, G, '_UKq', Qh, 0, 0);
    EHCI_ASSERT(DeviceData, TEST_FLAG(Qh->QhFlags, EHCI_QH_FLAG_UPDATING));
    EHCI_ASSERT(DeviceData, DeviceData->LockQh != NULL);
    EHCI_ASSERT(DeviceData, DeviceData->LockQh == Qh);

    CLEAR_FLAG(Qh->QhFlags, EHCI_QH_FLAG_UPDATING);
    DeviceData->LockQh = NULL;

    prevQh = DeviceData->LockPrevQh;

    phys = Qh->PhysicalAddress;
    SET_QH(phys);

    prevQh->HwQH.HLink.HwAddress =  phys;

    LOGENTRY(DeviceData, G, '_UKx', Qh, 0, phys);
}


VOID
EHCI_PollActiveAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     )
/*++

Routine Description:

    The queue head is in the running state we will just process
    the TDs that are completed up to 'current'  if dummy goes
    current then all TDs will be complete

Arguments:

Return Value:

--*/

{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_32BIT_PHYSICAL_ADDRESS tdPhys, curTdPhys;
    PTRANSFER_CONTEXT transfer;
    ULONG cf = 0;
    BOOLEAN syncWithHw;

#if DBG
    cf = EHCI_Get32BitFrameNumber(DeviceData);
#endif

    qh = EndpointData->QueueHead;
    curTdPhys =  qh->HwQH.CurrentTD.HwAddress & ~HW_LINK_FLAGS_MASK;

    LOGENTRY(DeviceData, G, '_pol', qh, cf, curTdPhys);

    EHCI_ASSERT(DeviceData, curTdPhys != 0);
    currentTd = (PHCD_TRANSFER_DESCRIPTOR)
                    USBPORT_PHYSICAL_TO_VIRTUAL(curTdPhys,
                                                DeviceData,
                                                EndpointData);

    // walk the soft list of TDs and complete all TDs
    // up to the currentTD

    // get the last known head
    LOGENTRY(DeviceData, G, '_hd1',
             EndpointData->HcdHeadP,
             0,
             currentTd);

    if (currentTd == EndpointData->QhChk) {
        // endpoint is transitioning to run a transfer or
        // is pointing at the waste area, do not poll at
        // this time
        LOGENTRY(DeviceData, G, '_pl!', 0, 0, currentTd);
        return;
    }

    // only do HW sync if QH is not in schedule
    syncWithHw = TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE) ?
                    TRUE : FALSE;
    // skip sync on hot remove
    if (EHCI_HardwarePresent(DeviceData, FALSE) == FALSE) {
        syncWithHw = FALSE;
    }

    ASSERT_TD(DeviceData, currentTd);
    td = EndpointData->HcdHeadP;

    if (td == currentTd &&
        td != EndpointData->DummyTd) {
        // currentTd is head verify that it is not complete
        if (td->HwTD.Token.Active == 0) {
            //currentTd = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            LOGENTRY(DeviceData, G, '_cAT', td, currentTd,
                qh->HwQH.CurrentTD.HwAddress & ~HW_LINK_FLAGS_MASK);
            //TEST_TRAP();
            EHCI_InterruptNextSOF(DeviceData);
        }
    }

    while (td != currentTd) {

        EHCI_ASSERT(DeviceData, !TEST_FLAG(td->Flags, TD_FLAG_DUMMY));
        // TDs between head and current should not be active

        transfer = TRANSFER_CONTEXT_PTR(td->TransferContext);
        LOGENTRY(DeviceData, G, '_dt1', td, 0, transfer);
        if (td->HwTD.Token.Active == 1) {
            // if the TD is active then it must have been
            // skipped due to a short xfer condition
            LOGENTRY(DeviceData, G, '_dtS', td, 0, 0);
            SET_FLAG(td->Flags, TD_FLAG_SKIP);
        }

        SET_FLAG(td->Flags, TD_FLAG_DONE);

        InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

        td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
    }

    // now check current TD if next td is the dummy and this td is
    // not active then we need to bump the current TD to dummy and
    // complete this TD. This will only occur if this is the last TD
    // queued
    // also check if this is a short transfer on the last transfer queued,
    // in this case the AltNextHcdTd will point to dummy and we will need
    // to advance passed the skipped TDs.


    if ((TRANSFER_DESCRIPTOR_PTR(currentTd->NextHcdTD) == EndpointData->DummyTd &&
         currentTd->HwTD.Token.Active == 0) ||
         // or a short packet
        (TRANSFER_DESCRIPTOR_PTR(currentTd->AltNextHcdTD) == EndpointData->DummyTd &&
         currentTd->HwTD.Token.Active == 0 &&
         currentTd->HwTD.Token.BytesToTransfer != 0) ) {

        LOGENTRY(DeviceData, G, '_bmp', currentTd, 0, 0);
        // synchronize with hardware in the event this td
        // has not been completely written back

        // since we are about to trash the overlay area there should
        // be no transfer current, we use the async doorbell to wait
        // for an the async TD to be completely flushed.
        //
        // In the event of a periodic transfer the HW may have prefetched
        // the periodic list so we need to wait for the microframe counter
        // to turn over.

        if (syncWithHw) {
            EHCI_LockQueueHead(DeviceData,
                               qh,
                               EndpointData->Parameters.TransferType);
        }

        qh->HwQH.CurrentTD.HwAddress = EndpointData->QhChkPhys;

        td = currentTd;
        SET_FLAG(td->Flags, TD_FLAG_DONE);

        InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

        if (td->HwTD.Token.BytesToTransfer != 0 &&
            TRANSFER_DESCRIPTOR_PTR(td->AltNextHcdTD) == EndpointData->DummyTd) {
            // start at first alt TD
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);

            // short xfer
            while (td != EndpointData->DummyTd) {
                SET_FLAG(td->Flags, TD_FLAG_SKIP);
                InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

                td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            }

        }


        qh->HwQH.CurrentTD.HwAddress = EndpointData->DummyTd->PhysicalAddress;
        qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
        qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
        qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;

        EndpointData->HcdHeadP = EndpointData->DummyTd;

        if (syncWithHw) {
            EHCI_UnlockQueueHead(DeviceData,
                               qh);
        }

        // check for sync problems
        EHCI_QHCHK(DeviceData, EndpointData);

    } else {

        EHCI_ASSERT(DeviceData, td != NULL);
        EndpointData->HcdHeadP = td;
    }
}


VOID
EHCI_PollHaltedAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_QUEUE_ELEMENT_TD overlay;
    HW_32BIT_PHYSICAL_ADDRESS tdPhys, curTdPhys;
    PTRANSFER_CONTEXT transfer, errTransfer;
    BOOLEAN syncWithHw;

    // we are halted probably due to an error and
    // currentTd should be the offending TD
    qh = EndpointData->QueueHead;
    curTdPhys =  qh->HwQH.CurrentTD.HwAddress & ~HW_LINK_FLAGS_MASK;

    LOGENTRY(DeviceData, G, '_plH', qh, 0, curTdPhys);
    EHCI_ASSERT(DeviceData, curTdPhys != 0);

    // only do HW sync if QH is not in schedule
    syncWithHw = TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE) ?
                    TRUE : FALSE;
    // skip sync on hot remove
    if (EHCI_HardwarePresent(DeviceData, FALSE) == FALSE) {
        syncWithHw = FALSE;
    }

    currentTd = (PHCD_TRANSFER_DESCRIPTOR)
                    USBPORT_PHYSICAL_TO_VIRTUAL(curTdPhys,
                                                DeviceData,
                                                EndpointData);

    if (currentTd == EndpointData->QhChk) {
        // endpoint is transitioning to run a transfer or
        // is pointing at the waste area, do not poll at
        // this time
        LOGENTRY(DeviceData, G, '_hl!', 0, 0, currentTd);
        return;
    }

    ASSERT_TD(DeviceData, currentTd);

    // we are halted probably due to an error and
    // currentTd should be the offending TD
    // we should not error on the dummy TD
    EHCI_ASSERT(DeviceData, EndpointData->DummyTd != currentTd);


    // walk the soft list of TDs and complete all TDs
    // up to the currentTD
    td = EndpointData->HcdHeadP;
    LOGENTRY(DeviceData, G, '_hed', 0, 0, td);

    while (td != currentTd) {

        EHCI_ASSERT(DeviceData, !TEST_FLAG(td->Flags, TD_FLAG_DUMMY));
        // TDs between head and current should not be active

        transfer = TRANSFER_CONTEXT_PTR(td->TransferContext);
        LOGENTRY(DeviceData, G, '_dt2', td, 0, transfer);
        if (td->HwTD.Token.Active == 1) {
            // if the TD is active then it must have been
            // skipped due to a short xfer condition
            LOGENTRY(DeviceData, G, '_d2S', td, 0, 0);
            SET_FLAG(td->Flags, TD_FLAG_SKIP);
        }

        SET_FLAG(td->Flags, TD_FLAG_DONE);

        InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

        td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
    }

    // adjust 'currentTd' to be the first TD of the NEXT
    // transfer
    td = currentTd;
    errTransfer = TRANSFER_CONTEXT_PTR(td->TransferContext);

    while (TRANSFER_CONTEXT_PTR(td->TransferContext) == errTransfer) {

        LOGENTRY(DeviceData, G, '_d3D', td, 0, 0);
        if (td->HwTD.Token.Active == 1) {
            // if the TD is active then it must have been
            // skipped due to a short xfer condition
            LOGENTRY(DeviceData, G, '_d3S', td, 0, 0);
            SET_FLAG(td->Flags, TD_FLAG_SKIP);
        }

        SET_FLAG(td->Flags, TD_FLAG_DONE);

        InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

        td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);

    }

    EHCI_ASSERT(DeviceData, td != NULL);
    // td is now first td of next transfer
    EndpointData->HcdHeadP = currentTd = td;

    // now fix up the queue head overlay area such that the
    // next transfer will run

    if (syncWithHw) {
    // sync with the HC hardware
        EHCI_LockQueueHead(DeviceData,
                           qh,
                           EndpointData->Parameters.TransferType);
    }

    qh->HwQH.CurrentTD.HwAddress = EndpointData->QhChkPhys;

    EHCI_ASSERT(DeviceData, qh->HwQH.Overlay.qTD.Token.Halted);

    // currentTD value should be irrelevent
    // we are !active, halted
    // overlay should be !active !halted when the queue head is reset
    // ie Advance Queue state
    qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = td->PhysicalAddress;
    qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
    qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;

    if (syncWithHw) {
    // queue head can now be aceesed by HW
        EHCI_UnlockQueueHead(DeviceData,
                             qh);
    }

    // if this is a control endpoint the we need to clear the
    // halt condition
    if (TEST_FLAG(EndpointData->Flags, EHCI_EDFLAG_NOHALT)) {
        LOGENTRY(DeviceData, G, '_clH', qh, 0, 0);

        CLEAR_FLAG(EndpointData->Flags, EHCI_EDFLAG_HALTED);

        qh->HwQH.Overlay.qTD.Token.Active = 0;
        qh->HwQH.Overlay.qTD.Token.Halted = 0;
        qh->HwQH.Overlay.qTD.Token.ErrorCounter = 0;
    }
}


VOID
EHCI_PollAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'

    This is where we poll bulk and interrupt endpoins.  BI endpoints
    use a 'dummy' TD to denote the end of the current transfer


Arguments:

Return Value:

--*/

{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_QUEUE_ELEMENT_TD overlay;
    BOOLEAN active, halted;
    PHCD_TRANSFER_DESCRIPTOR td;
    PLIST_ENTRY listEntry;
    ULONG cf = 0;

    EHCI_QHCHK(DeviceData, EndpointData);

#if DBG
    cf = EHCI_Get32BitFrameNumber(DeviceData);
#endif

    if (EndpointData->PendingTransfers == 0) {
        // if we have no transfers queued then there is
        // nothing to do
        LOGENTRY(DeviceData, G, '_poN', EndpointData, 0, cf);
        return;
    }


    //  get the queue head and a snapshot of the overlay
    qh = EndpointData->QueueHead;
    RtlCopyMemory(&overlay,
                  &qh->HwQH.Overlay.qTD,
                  sizeof(overlay));

    if (TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_QH_REMOVED)) {
        // don't check endpoint if qh has been removed
        LOGENTRY(DeviceData, G, '_qRM', EndpointData, 0, cf);
        return;
    }

    LOGENTRY(DeviceData, G, '_poo', EndpointData, 0, cf);

    //
    // Active AND Halted    -- should never happen
    // !Active AND !Halted  -- advance queue head
    // Active AND !Halted   -- executing transaction in overlay
    // !Active AND Halted   -- queue had is stopped due to an error

    halted = (BOOLEAN) overlay.Token.Halted;
    active = (BOOLEAN) overlay.Token.Active;

    if (!active && halted) {
        // queue is halted
        SET_FLAG(EndpointData->Flags, EHCI_EDFLAG_HALTED);
        EHCI_PollHaltedAsyncEndpoint(DeviceData, EndpointData);
    } else {
        // queue is active
        EHCI_PollActiveAsyncEndpoint(DeviceData, EndpointData);
    }

    // now flush all completed TDs in order of completion from
    // our 'done' List

    while (!IsListEmpty(&EndpointData->DoneTdList)) {

        listEntry = RemoveHeadList(&EndpointData->DoneTdList);


        td = (PHCD_TRANSFER_DESCRIPTOR) CONTAINING_RECORD(
                     listEntry,
                     struct _HCD_TRANSFER_DESCRIPTOR,
                     DoneLink);



        EHCI_ASSERT(DeviceData, (td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)));
        EHCI_ProcessDoneAsyncTd(DeviceData,
                                td);

    }

}


VOID
EHCI_AssertQhChk(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     )
{
    PULONG p;
    ULONG i;

    p = (PULONG) EndpointData->QhChk;

    for (i=0; i<256/sizeof(*p); i++) {
        EHCI_ASSERT(DeviceData, *p == 0);
        p++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\common.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    usbehci.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    1-1-00 : created

--*/

#ifndef   __COMMON_H__
#define   __COMMON_H__

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usb.h"
#include "usbhcdi.h"

#include "ehci.h"
#include "dbg.h"

#include "usbehci.h"

#endif // __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\dbg.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug only functions

Environment:

    kernel mode only

Notes:

Revision History:

    1-1-00 : created

--*/


#include "common.h"



// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
//EHCI_KdPrintX

#if DBG


ULONG
_cdecl
EHCI_KdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function. 

    calls the port driver print function

Arguments:

Return Value:


--*/    
{
    va_list list;
    int i;
    int arg[6];
    
    va_start(list, Format);
    for (i=0; i<6; i++) {
        arg[i] = va_arg(list, int);
    }            
    
    USBPORT_DBGPRINT(
        DeviceData, Level, Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\kdexts\urb.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    urb.c

Abstract:

    WinDbg Extension Api
    implements !_urb
               

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usbhcdkd.h"


PUCHAR    
UsbdFunctionName(
    USHORT Function
    )
{
    switch(Function) {
    case URB_FUNCTION_SELECT_CONFIGURATION:
        return "URB_FUNCTION_SELECT_CONFIGURATION";
    case URB_FUNCTION_SELECT_INTERFACE:
        return "URB_FUNCTION_SELECT_INTERFACE";
    case URB_FUNCTION_ABORT_PIPE:
        return "URB_FUNCTION_ABORT_PIPE";
    case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
        return "URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL";
    case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
        return "URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL";
    case URB_FUNCTION_GET_FRAME_LENGTH:
        return "URB_FUNCTION_GET_FRAME_LENGTH";
    case URB_FUNCTION_SET_FRAME_LENGTH:
        return "URB_FUNCTION_SET_FRAME_LENGTH";
    case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER  :
        return "URB_FUNCTION_GET_CURRENT_FRAME_NUMBER";
    case URB_FUNCTION_CONTROL_TRANSFER:
        return "URB_FUNCTION_CONTROL_TRANSFER";
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
        return "URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER";
    case URB_FUNCTION_ISOCH_TRANSFER:
        return "URB_FUNCTION_ISOCH_TRANSFER";
    case URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL:
        return "URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL";
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
        return "URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE";
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
        return "URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT";
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
        return "URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE";
    case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
        return "URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE";                                                               
    case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
        return "URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT";    
    case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
        return "URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE"; 
    case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
        return "URB_FUNCTION_SET_FEATURE_TO_DEVICE"; 
    case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
        return "URB_FUNCTION_SET_FEATURE_TO_INTERFACE"; 
    case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
        return "URB_FUNCTION_SET_FEATURE_TO_ENDPOINT"; 
    case URB_FUNCTION_SET_FEATURE_TO_OTHER:
        return "URB_FUNCTION_SET_FEATURE_TO_OTHER"; 
    case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
        return "URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE"; 
    case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
        return "URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE"; 
    case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
        return "URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT"; 
    case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
        return "URB_FUNCTION_CLEAR_FEATURE_TO_OTHER"; 
    case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
        return "URB_FUNCTION_GET_STATUS_FROM_DEVICE"; 
    case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
        return "URB_FUNCTION_GET_STATUS_FROM_INTERFACE"; 
    case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
        return "URB_FUNCTION_GET_STATUS_FROM_ENDPOINT"; 
    case URB_FUNCTION_GET_STATUS_FROM_OTHER:
        return "URB_FUNCTION_GET_STATUS_FROM_OTHER"; 
    case URB_FUNCTION_VENDOR_DEVICE:
        return "URB_FUNCTION_VENDOR_DEVICE"; 
    case URB_FUNCTION_VENDOR_INTERFACE:
        return "URB_FUNCTION_VENDOR_INTERFACE"; 
    case URB_FUNCTION_VENDOR_ENDPOINT:
        return "URB_FUNCTION_VENDOR_ENDPOINT"; 
    case URB_FUNCTION_VENDOR_OTHER:
        return "URB_FUNCTION_VENDOR_OTHER"; 
    case URB_FUNCTION_CLASS_DEVICE:
        return "URB_FUNCTION_CLASS_DEVICE"; 
    case URB_FUNCTION_CLASS_INTERFACE:
        return "URB_FUNCTION_CLASS_INTERFACE"; 
    case URB_FUNCTION_CLASS_ENDPOINT:
        return "URB_FUNCTION_CLASS_ENDPOINT"; 
    case URB_FUNCTION_CLASS_OTHER:
        return "URB_FUNCTION_CLASS_OTHER"; 
    case URB_FUNCTION_GET_CONFIGURATION:
        return "URB_FUNCTION_GET_CONFIGURATION"; 
    case URB_FUNCTION_GET_INTERFACE:
        return "URB_FUNCTION_GET_INTERFACE"; 
    }        

    return "???"; 
}


VOID    
DumpPipeRequest(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_URB_PIPE_REQUEST";
    STRUC_ENTRY ap[] = {
        "PipeHandle", FT_PTR,
        "Reserved", FT_ULONG,
    };

    UsbDumpStruc(MemLoc, cs, 
        &ap[0], sizeof(ap)/sizeof(STRUC_ENTRY));
}


VOID    
DumpControlTransfer(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_TRANSFER_URB";
    ULONG f;
    PUSB_DEFAULT_PIPE_SETUP_PACKET setup;
    USB_DEFAULT_PIPE_SETUP_PACKET tmp;
    PUCHAR s;
    PUCHAR Dir_String[2] = {"HOST_TO_DEVICE",
                            "DEVICE_TO_HOST"};
    PUCHAR Type_String[3] = {"STANDARD",
                             "CLASS",
                             "VENDOR"};                            

    PUCHAR Recipient_String[3] = {"DEVICE",
                                  "INTERFACE",
                                  "ENDPOINT"};                                    

#define MAX_BREQ  13   
    PUCHAR bReq_String[MAX_BREQ] = {                                  
                "USB_REQUEST_GET_STATUS",       // 0
                "USB_REQUEST_CLEAR_FEATURE",    // 1
                "",                             // 2
                "USB_REQUEST_SET_FEATURE",      // 3
                "",                             // 4
                "USB_REQUEST_SET_ADDRESS",      // 5
                "USB_REQUEST_GET_DESCRIPTOR",   // 6
                "USB_REQUEST_SET_DESCRIPTOR",   // 7
                "USB_REQUEST_GET_CONFIGURATION",// 8
                "USB_REQUEST_SET_CONFIGURATION",// 9
                "USB_REQUEST_GET_INTERFACE",    // 10
                "USB_REQUEST_SET_INTERFACE",    // 11
                "USB_REQUEST_SYNC_FRAME"        // 12
                };
    

    FLAG_TABLE xferFlags[] = {
        "USBD_TRANSFER_DIRECTION_IN", USBD_TRANSFER_DIRECTION_IN,
        "USBD_SHORT_TRANSFER_OK", USBD_SHORT_TRANSFER_OK,
        "USBD_START_ISO_TRANSFER_ASAP", USBD_START_ISO_TRANSFER_ASAP
         };
    STRUC_ENTRY t[] = {
        "UsbdPipeHandle", FT_PTR,
        "TransferBufferLength", FT_ULONG,
        "TransferBuffer", FT_PTR,
        "TransferBufferMDL", FT_PTR,
        "ResevedMBNull", FT_PTR,
        "pd.HcdTransferContext", FT_PTR,
    };        

    
    dprintf("*CONTROL TRANSFER\n");    

    f = UsbReadFieldUlong(MemLoc, cs, "TransferFlags"); 
    dprintf("TransferFlags: %08.8x\n", f);
    UsbDumpFlags(f, xferFlags, 
        sizeof(xferFlags)/sizeof(FLAG_TABLE));
    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));


    
    {
    ULONG64 addr;
    ULONG cb;

    addr = MemLoc + UsbFieldOffset(cs, 
            "u.SetupPacket");
            
    ReadMemory(addr,
               &tmp,
               sizeof(tmp),
               &cb);
    }   
    
    setup = (PUSB_DEFAULT_PIPE_SETUP_PACKET) &tmp;
    s = (PUCHAR) setup;
    
    dprintf(
        "<SetupPacket> %02.2x %02.2x %02.2x %02.2x %02.2x %02.2x %02.2x %02.2x\n",
        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
    dprintf("bmRequestType (%02.2x)\n", setup->bmRequestType.B);    
    dprintf("\tRecipient %d - %s\n", setup->bmRequestType.Recipient,
        Recipient_String[setup->bmRequestType.Recipient]);       
    dprintf("\tType %d - %s\n", setup->bmRequestType.Type,     
        Type_String[setup->bmRequestType.Type]);
    dprintf("\tDir %d - %s\n", setup->bmRequestType.Dir, 
        Dir_String[setup->bmRequestType.Dir]);     
    dprintf("\tReserved %d\n", setup->bmRequestType.Reserved);  
    dprintf("bRequest %d  ", setup->bRequest);  
    if (setup->bmRequestType.Type == 0 && setup->bRequest < MAX_BREQ) {
        dprintf("%s\n", bReq_String[setup->bRequest]);
    } else {
        dprintf("\n"); 
    }
    dprintf("wValue 0x%04.4x (LowByte %02.2x HiByte %02.2x)\n", setup->wValue.W, 
        setup->wValue.LowByte, setup->wValue.HiByte); 
    dprintf("wIndex 0x%04.4x\n", setup->wIndex); 
    dprintf("wLength 0x%04.4x\n", setup->wLength); 
    
}


VOID    
DumpAsyncTransfer(
    MEMLOC MemLoc
    )
{
    ULONG flags;
    UCHAR cs[] = "_TRANSFER_URB";
    STRUC_ENTRY t[] = {
        "UsbdPipeHandle", FT_PTR,
        "TransferBufferLength", FT_ULONG,
        "TransferBuffer", FT_PTR,
        "TransferBufferMDL", FT_PTR,
        "ReservedMBNull", FT_PTR,
        "pd.HcdTransferContext", FT_PTR
    };
    FLAG_TABLE xferFlags[] = {
        "USBD_TRANSFER_DIRECTION_IN", USBD_TRANSFER_DIRECTION_IN,
        "USBD_SHORT_TRANSFER_OK", USBD_SHORT_TRANSFER_OK,
        "USBD_START_ISO_TRANSFER_ASAP", USBD_START_ISO_TRANSFER_ASAP
         };

    dprintf("*ASYNC TRANSFER\n");    
    flags =  UsbReadFieldUlong(MemLoc, cs, "TransferFlags");
    dprintf("TransferFlags: %08.8x\n", flags);         
    UsbDumpFlags(flags, xferFlags, 
        sizeof(xferFlags)/sizeof(FLAG_TABLE));
       
    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));
            
}


VOID    
DumpIsochTransfer(
    MEMLOC MemLoc
    )
{
    ULONG flags;
    UCHAR s[64];
    UCHAR cs[] = "_TRANSFER_URB";
    STRUC_ENTRY t[] = {
        "UsbdPipeHandle", FT_PTR,
        "TransferBufferLength", FT_ULONG,
        "TransferBuffer", FT_PTR,
        "TransferBufferMDL", FT_PTR,
        "ReservedMBNull", FT_PTR,
        "pd.HcdTransferContext", FT_PTR,
        "u.Isoch.StartFrame", FT_ULONG,
        "u.Isoch.NumberOfPackets", FT_ULONG,
        "u.Isoch.ErrorCount", FT_ULONG
    };
    FLAG_TABLE xferFlags[] = {
        "USBD_TRANSFER_DIRECTION_IN", USBD_TRANSFER_DIRECTION_IN,
        "USBD_SHORT_TRANSFER_OK", USBD_SHORT_TRANSFER_OK,
        "USBD_START_ISO_TRANSFER_ASAP", USBD_START_ISO_TRANSFER_ASAP
         };
    ULONG p, i;         

    dprintf("*ISOCH TRANSFER\n");    
    flags =  UsbReadFieldUlong(MemLoc, cs, "TransferFlags");
    dprintf("TransferFlags: %08.8x\n", flags);         
    UsbDumpFlags(flags, xferFlags, 
        sizeof(xferFlags)/sizeof(FLAG_TABLE));
       
    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    // attempt to dump the packet struc
    p = UsbReadFieldUlong(MemLoc, cs, "u.Isoch.NumberOfPackets");
    for (i=0; i<p; i++) {
        USBD_ISO_PACKET_DESCRIPTOR pd;
        MEMLOC t;
        ULONG cb;
        
        sprintf(s, "u.Isoch.IsoPacket[%d]", i);
        t = MemLoc + UsbFieldOffset(cs, s);

        ReadMemory(t,
                   &pd,
                   sizeof(pd),
                   &cb);

        dprintf("Packet[%d]: Offset %08.8x Length %08.8x UsbdStatus %08.8x\n", i, 
            pd.Offset, pd.Length, pd.Status);                         
    }
        
}


VOID 
DumpPipeInfo(
    MEMLOC MemLoc
    )
{
    ULONG i;
    UCHAR cs[] = "_USBD_PIPE_INFORMATION";
    STRUC_ENTRY ps[] = {
        "MaximumPacketSize", FT_USHORT,
        "EndpointAddress", FT_UCHAR,
        "Interval", FT_UCHAR,
        "PipeType", FT_ULONG,
        "PipeHandle", FT_PTR,
        "MaximumTransferSize", FT_ULONG,
        "PipeFlags", FT_ULONG,
    };

    PrintfMemLoc("Pipe:  ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &ps[0], sizeof(ps)/sizeof(STRUC_ENTRY));
    
#if 0
    dprintf("\t\tPipeType: ");
    switch(PipeInfo->PipeType) {
    case UsbdPipeTypeControl:
        dprintf("UsbdPipeTypeControl\n");
        break;
    case UsbdPipeTypeIsochronous:
        dprintf("UsbdPipeTypeIsochronous\n");
        break;
    case UsbdPipeTypeBulk:
        dprintf("UsbdPipeTypeBulk\n");
        break;
    case UsbdPipeTypeInterrupt:     
        dprintf("UsbdPipeTypeInterrupt\n");
        break;
    }
#endif
}


VOID    
DumpInterfaceInfo(
    MEMLOC MemLoc
    )
{
    ULONG i, np;
    UCHAR cs[] = "_USBD_INTERFACE_INFORMATION";
    STRUC_ENTRY is[] = {
        "Length", FT_USHORT,
        "InterfaceNumber", FT_UCHAR,
        "AlternateSetting", FT_UCHAR,
        "Class", FT_UCHAR,
        "SubClass", FT_UCHAR,
        "Protocol", FT_UCHAR,
        "Reserved", FT_UCHAR,
        "InterfaceHandle", FT_PTR,
        "NumberOfPipes", FT_ULONG,
    };

    dprintf("Interface -----------------\n");

    UsbDumpStruc(MemLoc, cs, 
        &is[0], sizeof(is)/sizeof(STRUC_ENTRY));

    np = UsbReadFieldUlong(MemLoc, cs, "NumberOfPipes"); 

    for (i=0; i < np; i++) {           
        UCHAR s[80];
        MEMLOC p;
        
        dprintf("Pipe[%02.2d] -----------------\n", i);
        sprintf(s, "Pipes[%d]", i);
        
        p= MemLoc + UsbFieldOffset(cs, s);
        
        DumpPipeInfo(p);
    }      
}


VOID    
DumpSelectConfiguration(
    MEMLOC MemLoc,
    ULONG UrbLength
    )
{
    UCHAR cs[] = "_URB_SELECT_CONFIGURATION";
    UCHAR is[] = "_USBD_INTERFACE_INFORMATION";
    STRUC_ENTRY sc[] = {
        "ConfigurationHandle", FT_PTR,
        "ConfigurationDescriptor", FT_PTR,
    };
    MEMLOC start, end;
    ULONG i = 0;

    dprintf("*SELECT_CONFIG\n");    
    UsbDumpStruc(MemLoc, cs, 
        &sc[0], sizeof(sc)/sizeof(STRUC_ENTRY));
        
    start = MemLoc;
    end = start+UrbLength;

    start += UsbFieldOffset(cs, "Interface");
    
    while (start < end && i < 8) {
        ULONG length;
        
        length = UsbReadFieldUshort(start, is, "Length"); 

        DumpInterfaceInfo(start);
                
        start+=length;
        i++;
    }         
}


VOID    
DumpSelectInterface(
    MEMLOC MemLoc,
    ULONG UrbLength
    )
{
    UCHAR cs[] = "_URB_SELECT_INTERFACE";
    UCHAR is[] = "_USBD_INTERFACE_INFORMATION";
    STRUC_ENTRY sc[] = {
        "ConfigurationHandle", FT_PTR
    };
    MEMLOC start, end;
    ULONG i = 0;

    dprintf("*SELECT_INTERFACE\n");    
    UsbDumpStruc(MemLoc, cs, 
        &sc[0], sizeof(sc)/sizeof(STRUC_ENTRY));
        
    start = MemLoc;
    end = start+UrbLength;

    start += UsbFieldOffset(cs, "Interface");
    
    while (start < end && i < 8) {
        ULONG length;
        
        length = UsbReadFieldUshort(start, is, "Length"); 

        DumpInterfaceInfo(start);
                
        start+=length;
        i++;
    }         
}


VOID    
DumpUrb(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_URB_HEADER";
    ULONG f;
    USHORT func;
    STRUC_ENTRY urbHeader[] = {
        "Length", FT_USHORT,
        "Status", FT_ULONG,
        "UsbdDeviceHandle", FT_PTR,
    };
    FLAG_TABLE usbdFlags[] = {

        "USBPORT_REQUEST_IS_TRANSFER", USBPORT_REQUEST_IS_TRANSFER,
        "USBPORT_REQUEST_MDL_ALLOCATED", USBPORT_REQUEST_MDL_ALLOCATED,
        "USBPORT_REQUEST_USES_DEFAULT_PIPE", USBPORT_REQUEST_USES_DEFAULT_PIPE,
    
        "USBPORT_REQUEST_NO_DATA_PHASE", USBPORT_REQUEST_NO_DATA_PHASE,
        "USBPORT_RESET_DATA_TOGGLE", USBPORT_RESET_DATA_TOGGLE,
        "USBPORT_TRANSFER_ALLOCATED", USBPORT_TRANSFER_ALLOCATED
         }; 

    PrintfMemLoc("*URB @", MemLoc, "\n");

    func = UsbReadFieldUshort(MemLoc, cs, "Function");
    dprintf("Function: 0x%04.4x  (%s)\n", func, 
        UsbdFunctionName(func));
        
    UsbDumpStruc(MemLoc, cs, 
        &urbHeader[0], sizeof(urbHeader)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "UsbdFlags");        
    dprintf("UsbdFlags: 0x%08.8x\n", f);
    UsbDumpFlags(f, usbdFlags, 
            sizeof(usbdFlags)/sizeof(FLAG_TABLE));


    // dump the function specific stuff
    switch (func) {
    case URB_FUNCTION_CONTROL_TRANSFER:
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
    case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
    case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
    case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
    case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
    case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
    case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
    case URB_FUNCTION_SET_FEATURE_TO_OTHER:
    case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
    case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
    case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
    case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
    case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
    case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
    case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
    case URB_FUNCTION_GET_STATUS_FROM_OTHER:
    case URB_FUNCTION_VENDOR_DEVICE:
    case URB_FUNCTION_VENDOR_INTERFACE:
    case URB_FUNCTION_VENDOR_ENDPOINT:
    case URB_FUNCTION_VENDOR_OTHER:
    case URB_FUNCTION_CLASS_DEVICE:
    case URB_FUNCTION_CLASS_INTERFACE:
    case URB_FUNCTION_CLASS_ENDPOINT:
    case URB_FUNCTION_CLASS_OTHER:
    case URB_FUNCTION_GET_CONFIGURATION:
    case URB_FUNCTION_GET_INTERFACE:
        DumpControlTransfer(MemLoc);
        break;
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
        DumpAsyncTransfer(MemLoc); 
        break;
//    case URB_FUNCTION_SELECT_INTERFACE:
//        DumpSelectInterface((PURB) rawUrb);
//        break;
    case URB_FUNCTION_SELECT_INTERFACE:
        DumpSelectInterface(MemLoc, UsbReadFieldUshort(MemLoc, cs, "Length"));
        break;       
    case URB_FUNCTION_SELECT_CONFIGURATION:
        DumpSelectConfiguration(MemLoc, UsbReadFieldUshort(MemLoc, cs, "Length"));
        break;        
    case URB_FUNCTION_ISOCH_TRANSFER:
        DumpIsochTransfer(MemLoc); 
        break; 
    case URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL:
        DumpPipeRequest(MemLoc);
        break;
    case URB_FUNCTION_ABORT_PIPE:
        DumpPipeRequest(MemLoc);
        break;
    default:
        dprintf ("Don't know how to dump\n");        
    }

}


DECLARE_API( _urb )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);

    DumpUrb (addr);

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\dbg.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros
    
Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

// 
// Structure signatures
//

#define EHCI_TAG          'ehci'        //"EHCI"

// write to one of the reserved operational registers
// we use this to trigger the PCI analyzer
#define PCI_TRIGGER(hcOp)  WRITE_REGISTER_ULONG(&(hcOp)->PciTrigger, 0xABADBABE);


#if DBG

#define DEBUG_LOG

// Triggers a break in the debugger in the registry key
// debugbreakOn is set.  These breakpoins are useful for
// debugging hardware/client software problems
//
 
#define DEBUG_BREAK(dd)  RegistrationPacket.USBPORTSVC_TestDebugBreak;                           

//
// This Breakpoint means we either need to test the code path 
// somehow or the code is not implemented.  ie either case we
// should not have any of these when the driver is finished
//

#define TEST_TRAP()      {\
                            DbgPrint("<EHCI TEST_TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                         }                            
                         


#define ASSERT_TRANSFER(dd, t) EHCI_ASSERT((dd), (t)->Sig == SIG_EHCI_TRANSFER)

#define ASSERT_TD(dd, t) EHCI_ASSERT((dd), (t)->Sig == SIG_HCD_TD)
#define ASSERT_SITD(dd, t) EHCI_ASSERT((dd), (t)->Sig == SIG_HCD_SITD)
#define ASSERT_ITD(dd, t) EHCI_ASSERT((dd), (t)->Sig == SIG_HCD_ITD)

#define ASSERT_DUMMY_TD(dd, t) \
    EHCI_ASSERT((dd), (t)->NextHcdTD.Pointer == NULL);\
    EHCI_ASSERT((dd), (t)->AltNextHcdTD.Pointer == NULL);

ULONG
_cdecl
EHCI_KdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    );

#define   EHCI_KdPrint(_x_) EHCI_KdPrintX _x_

#define EHCI_ASSERT(dd, exp ) \
    if (!(exp)) {\
        RegistrationPacket.USBPORTSVC_AssertFailure( (dd), #exp, __FILE__, __LINE__, NULL );\
    }        

#define EHCI_QHCHK(dd, ed)  EHCI_AssertQhChk(dd, ed);

#else 

// debug macros for retail build

#define TEST_TRAP()
#define DEBUG_BREAK(dd)

#define ASSERT_TRANSFER(dd, t) 

#define ASSERT_DUMMY_TD(dd, t)
#define ASSERT_TD(dd, t) 
#define ASSERT_SITD(dd, t)
#define ASSERT_ITD(dd, t) 


#define EHCI_ASSERT(dd, exp )

#define   EHCI_KdPrint(_x_) 

#define EHCI_QHCHK(dd, ed)

#endif /* DBG */

// retail and debug

#ifdef DEBUG_LOG

#define LOGENTRY(dd, mask, sig, info1, info2, info3)  \
    RegistrationPacket.USBPORTSVC_LogEntry( (dd), (mask), (sig), \
        (ULONG_PTR)(info1), (ULONG_PTR)(info2), (ULONG_PTR)(info3) )

#else

#define LOGENTRY(dd, mask, sig, info1, info2, info3)

#endif


#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\ehci.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    ehci.h

Abstract:

   Definitions from Enhanced USB 2.0  
   controller specification

Environment:

    Kernel & user mode

Revision History:

    1-1-00 : created jdunn

--*/


#ifndef EHCI_H
#define EHCI_H

#include <PSHPACK4.H>
//
// Don't use <PSHPACK1.H> on shared memory data structures that should only
// be accessed using 4-byte load/store instructions (e.g use ld4 instructions
// instead of ld1 instructions on ia64 machines).
//

// maximum time to wait for reset to go low in microseconds
#define USBEHCI_MAX_RESET_TIME  500

#define EHCI_PAGE_SIZE      0x1000

//
// Host Controler Hardware Registers as accessed in memory
//

//
// HCLENGTHVERION - Capability Register Length / Interface Versoin Number
//

typedef union _HCLENGTHVERSION {
   ULONG                   ul;
   struct {                 
      ULONG                 HcCapLength:8;                      // 0-7
      ULONG                 Reserved:8;                         // 8-15
      ULONG                 HcVersion:16;                       // 16-31
   };
} HCLENGTHVERSION, *PHCLENGTHVERSION;

C_ASSERT((sizeof(HCLENGTHVERSION) == sizeof(ULONG)));

//
// HCSPARAMS - Structural Parameters
//

typedef union _HCSPARAMS {
   ULONG                   ul;
   struct {                 
      ULONG                 NumberOfPorts:4;                    // 0-3
      ULONG                 PortPowerControl:1;                 // 4
      ULONG                 Reserved1:3;                        // 5-7
      ULONG                 NumberOfPortsPerCompConroller:4;    // 8-11
      ULONG                 NumberOfCompControllers:4;          // 12-15
      ULONG                 PortLEDs:1;                         // 16
      ULONG                 Reserved2:15;                       // 17-31
   };
} HCSPARAMS, *PHCSPARMS;

C_ASSERT((sizeof(HCSPARAMS) == sizeof(ULONG)));

//
// HCCPARAMS - Capability Parameters
//

typedef union _HCCPARAMS {
   ULONG                   ul;
   struct {                 
      ULONG                 Bit64Addressing:1;      // 0
      ULONG                 ProgramableFrameList:1; // 1
      ULONG                 Reserved1:2;            // 2-3
      ULONG                 IsochronousThreshold:4; // 4-7
      ULONG                 Reserved2:24;           // 8-31
   };
} HCCPARAMS, *PHCCPARMS;

C_ASSERT((sizeof(HCCPARAMS) == sizeof(ULONG)));

//
// CAPABILITIES REGISTER
//

typedef struct _HC_CAPABILITIES_REGISTER {

   HCLENGTHVERSION          HcLengthVersion;
   HCSPARAMS                HcStructuralParameters;
   HCCPARAMS                HcCapabilityParameters;
   
} HC_CAPABILITIES_REGISTER, *PHC_CAPABILITIES_REGISTER;

C_ASSERT((sizeof(HC_CAPABILITIES_REGISTER) == (3 * sizeof(ULONG))));

//
// USBCMD - USB Command Register
//

//
// Definitions for HC_QTD_TOKEN.Pid
//

#define HcCmd_FrameListSizeIs1024         0    
#define HcCmd_FrameListSizeIs512          1    
#define HcCmd_FrameListSizeIs256          2    


typedef union _USBCMD {

    ULONG                   ul;
    struct {                
        ULONG               HostControllerRun:1;        // 0
        ULONG               HostControllerReset:1;      // 1
        ULONG               FrameListSize:2;            // 2-3
        ULONG               PeriodicScheduleEnable:1;   // 4
        ULONG               AsyncScheduleEnable:1;      // 5
        ULONG               IntOnAsyncAdvanceDoorbell:1;// 6
        ULONG               HostControllerLightReset:1; // 7
        ULONG               Reserved1:8;                // 8-15
        ULONG               InterruptThreshold:8;       // 16-23
        ULONG               Reserved2:8;                // 24-31
    };
    
} USBCMD, *PUSBCMD;

C_ASSERT((sizeof(USBCMD) == sizeof(ULONG)));

//
// USBSTS - USB Status Register
//

#define HcInterruptStatusMask                   0x0000003F     

#define HcInt_IntOnasyncAdvance                 0x00000020
#define HcInt_HostSystemError                   0x00000010
#define HcInt_FrameListRollover                 0x00000008
#define HcInt_PortChangeDetect                  0x00000004
#define HcInt_UsbError                          0x00000002
#define HcInt_UsbInterrupt                      0x00000001

typedef union _USBSTS {

    ULONG                   ul;
    struct {                
        // controller interrupt status bits
        ULONG               UsbInterrupt:1;                 // 0
        ULONG               UsbError:1;                     // 1
        ULONG               PortChangeDetect:1;             // 2
        ULONG               FrameListRollover:1;            // 3
        ULONG               HostSystemError:1;              // 4
        ULONG               IntOnAsyncAdvance:1;            // 5
        ULONG               ReservedStatus:6;               // 6-11
        
        // controller status
        ULONG               HcHalted:1;                     // 12
        ULONG               Reclimation:1;                  // 13
        ULONG               PeriodicScheduleStatus:1;       // 14
        ULONG               AsyncScheduleStatus:1;          // 15
        ULONG               Reserved:16;                    // 16-31
    };
    
} USBSTS, *PUSBSTS;

C_ASSERT((sizeof(USBSTS) == sizeof(ULONG)));


//
// USBINTR - USB Interrupt Enable Register
//

typedef union _USBINTR {

    ULONG                   ul;
    struct {                
        ULONG               UsbInterrupt:1;                 // 0
        ULONG               UsbError:1;                     // 1
        ULONG               PortChangeDetect:1;             // 2
        ULONG               FrameListRollover:1;            // 3
        ULONG               HostSystemError:1;              // 4
        ULONG               IntOnAsyncAdvance:1;            // 5
        //HostSystemError
        //HostControllerProcessError
        ULONG               Reserved:26;                   // 6-31
    };
    
} USBINTR, *PUSBINTR;

C_ASSERT((sizeof(USBINTR) == sizeof(ULONG)));

//
// FRNUM - Frame Number Register
//

typedef union _FRINDEX {

    ULONG                   ul;
    struct {                
        ULONG               FrameListCurrentIndex:14;
        ULONG               Reserved:18;
    };
    
} FRINDEX, *PFRINDEX;

C_ASSERT((sizeof(FRINDEX) == sizeof(ULONG)));

//
// CONFIGFLAG - 
//

typedef union _CONFIGFLAG {

    ULONG                   ul;
    struct {                
        ULONG               RoutePortsToEHCI:1;
        ULONG               Reserved:31;
    };
    
} CONFIGFLAG, *PCONFIGFLAG;

C_ASSERT((sizeof(CONFIGFLAG) == sizeof(ULONG)));


//
// PORTSC - Port Status and Control Register
//

typedef union _PORTSC {

    ULONG                   ul;
    struct {                
        ULONG               PortConnect:1;          // 0
        ULONG               PortConnectChange:1;    // 1
        ULONG               PortEnable:1;           // 2
        ULONG               PortEnableChange:1;     // 3   
        
        ULONG               OvercurrentActive:1;    // 4
        ULONG               OvercurrentChange:1;    // 5
        ULONG               ForcePortResume:1;      // 6
        ULONG               PortSuspend:1;          // 7
        
        ULONG               PortReset:1;            // 8
        ULONG               HighSpeedDevice:1;      // 9
        ULONG               LineStatus:2;           // 10-11   
        
        ULONG               PortPower:1;            // 12
        ULONG               PortOwnedByCC:1;        // 13
        ULONG               PortIndicator:2;        // 14-15
        
        ULONG               PortTestControl:4;      // 16-19  
        
        ULONG               WakeOnConnect:1;        // 20
        ULONG               WakeOnDisconnect:1;     // 21
        ULONG               WakeOnOvercurrent:1;    // 22
        ULONG               Reserved:9;             // 23-31
    };
    
} PORTSC, *PPORTSC;

C_ASSERT((sizeof(PORTSC) == sizeof(ULONG)));




// OPERATIONAL REGISTER

typedef struct _HC_OPERATIONAL_REGISTER {

    // 00h
    USBCMD                          UsbCommand;     
    USBSTS                          UsbStatus;     
    USBINTR                         UsbInterruptEnable;    
    FRINDEX                         UsbFrameIndex;

    // 10h
    HW_32BIT_PHYSICAL_ADDRESS       SegmentSelector;
    HW_32BIT_PHYSICAL_ADDRESS       PeriodicListBase;     
    HW_32BIT_PHYSICAL_ADDRESS       AsyncListAddr;
    //ULONG                           Reserved;
    ULONG                           PciTrigger;

    // 20h
    ULONG                           ReservedB0[4];

    // 30h
    ULONG                           ReservedB1[4];

    // 40h
    CONFIGFLAG                      ConfigFlag;
    PORTSC                          PortRegister[1];
   
} HC_OPERATIONAL_REGISTER, *PHC_OPERATIONAL_REGISTER;


//#define HcDTYPE_iTD                 0    // iterative TD
//#define HcDTYPE_QH                  1    // queue head
//#define HcDTYPE_siTD                2    // isochronousTD

// note that bits 0,1,2 are used for QH type
// bits 4, and 5 are used for the nak cnt in the 
// transfer overlay
#define HW_LINK_FLAGS_MASK          0x0000001f

typedef union _HW_LINK_POINTER {

   HW_32BIT_PHYSICAL_ADDRESS        HwAddress;         
// this screws up the 64-bit compiler    
#if 0   
   struct {
        ULONG Terminate:1;                   // 0
        ULONG DType:2;                       // 1-2
        ULONG ReservedMBZ:2;                 // 3-4
        ULONG PhysicalAddressBits:27;        // 5-31
   };
#endif   
   
} HW_LINK_POINTER, *PHW_LINK_POINTER;

#define EHCI_TERMINATE_BIT      0x00000001 // 00001
#define EHCI_DTYPE_QH           0x00000002 // 00010
#define EHCI_DTYPE_SITD         0x00000004 // 00100
#define EHCI_RsvdMBZ            0x00000018 // 11000
#define EHCI_DTYPE_Mask         0x0000001E // 11110

#define SET_T_BIT(addr) ((addr) |= EHCI_TERMINATE_BIT)
#define SET_SITD(addr) do {\
                        ((addr) &= ~EHCI_DTYPE_Mask);\
                        ((addr) |= EHCI_DTYPE_SITD);\
                       } while (0)

#define SET_QH(addr)  do {\
                        ((addr) &= ~EHCI_DTYPE_Mask);\
                        ((addr) |= EHCI_DTYPE_QH);\
                      } while (0)

C_ASSERT((sizeof(HW_LINK_POINTER) == sizeof(ULONG)));

//
// Isochronous Transfer Descriptor
//

typedef union _HC_ITD_BUFFER_POINTER0 {
    ULONG ul;
    struct {
        ULONG DeviceAddress:7;          // 0-6
        ULONG Reserved:1;               // 7
        ULONG EndpointNumber:4;         // 8-11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_ITD_BUFFER_POINTER0, *PHC_ITD_BUFFER_POINTER0;

C_ASSERT((sizeof(HC_ITD_BUFFER_POINTER0) == sizeof(ULONG)));


typedef union _HC_ITD_BUFFER_POINTER1 {
    ULONG ul;
    struct {
        ULONG MaxPacketSize:11;         // 0-10
        ULONG Direction:1;              // 11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_ITD_BUFFER_POINTER1, *PHC_ITD_BUFFER_POINTER1;

C_ASSERT((sizeof(HC_ITD_BUFFER_POINTER1) == sizeof(ULONG)));


typedef union _HC_ITD_BUFFER_POINTER2 {
    ULONG ul;
    struct {
        ULONG Multi:2;                  // 0-1
        ULONG Reserved:10;              // 2-11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_ITD_BUFFER_POINTER2, *PHC_ITD_BUFFER_POINTER2;

C_ASSERT((sizeof(HC_ITD_BUFFER_POINTER2) == sizeof(ULONG)));

typedef union _HC_ITD_BUFFER_POINTER {
    ULONG ul;
    struct {
        ULONG Reserved:12;              // 0-11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_ITD_BUFFER_POINTER, *PHC_ITD_BUFFER_POINTER;

C_ASSERT((sizeof(HC_ITD_BUFFER_POINTER) == sizeof(ULONG)));


typedef union _HC_ITD_TRANSACTION {
    ULONG ul;
    struct {
        ULONG Offset:12;                // 0-11
        ULONG PageSelect:3;             // 12-14
        ULONG InterruptOnComplete:1;    // 15
        ULONG Length:12;                // 16-27
        ULONG XactError:1;              // 28
        ULONG BabbleDetect:1;           // 29
        ULONG DataBufferError:1;        // 30
        ULONG Active:1;                 // 31
    };    
} HC_ITD_TRANSACTION, *PHC_ITD_TRANSACTION;

C_ASSERT((sizeof(HC_ITD_TRANSACTION) == sizeof(ULONG)));

typedef struct _HW_ISOCHRONOUS_TD {
    HW_LINK_POINTER         NextLink;
    HC_ITD_TRANSACTION      Transaction[8];
    HC_ITD_BUFFER_POINTER0  BufferPointer0;
    HC_ITD_BUFFER_POINTER1  BufferPointer1;
    HC_ITD_BUFFER_POINTER2  BufferPointer2;
    HC_ITD_BUFFER_POINTER   BufferPointer3;
    HC_ITD_BUFFER_POINTER   BufferPointer4;
    HC_ITD_BUFFER_POINTER   BufferPointer5;
    HC_ITD_BUFFER_POINTER   BufferPointer6;
    ULONG                   BufferPointer64[7];
    ULONG                   Pad[9];
} HW_ISOCHRONOUS_TD, *PHW_ISOCHRONOUS_TD;

C_ASSERT((sizeof(HW_ISOCHRONOUS_TD) == 128));

//
// Split Transaction Isochronous Transfer Descriptor
//

typedef union _HC_SITD_CAPS {
    ULONG   ul;
    struct {
        ULONG DeviceAddress:7;          // 0-6
        ULONG Reserved0:1;              // 7
        ULONG EndpointNumber:4;         // 8-11
        ULONG Reserved1:4;              // 12-15
        ULONG HubAddress:7;             // 16-22
        ULONG Reserved2:1;              // 23
        ULONG PortNumber:7;             // 24-30        
        ULONG Direction:1;              // 31
    };
} HC_SITD_CAPS, *PHC_SITD_CAPS;

C_ASSERT((sizeof(HC_SITD_CAPS) == sizeof(ULONG)));

typedef union _HC_SITD_CONTROL {
    ULONG   ul;
    struct {
        ULONG sMask:8;                  // 0-7  
        ULONG cMask:8;                  // 8-15        
        ULONG Reserved:16;              // 16-31
    };
} HC_SITD_CONTROL, *PHC_SITD_CONTROL;

C_ASSERT((sizeof(HC_SITD_CONTROL) == sizeof(ULONG)));

typedef union _HC_SITD_STATE {
    ULONG   ul;
    struct {
        ULONG Reserved0:1;              // 0
        ULONG SplitXState:1;            // 1
        ULONG MissedMicroframe:1;       // 2  
        ULONG XactErr:1;                // 3
        ULONG BabbleDetected:1;         // 4
        ULONG DataBufferError:1;        // 5
        ULONG ERR:1;                    // 6
        ULONG Active:1;                 // 7
        
        ULONG cProgMask:8;              // 8-15
        ULONG BytesToTransfer:10;       // 16-25
        ULONG Reserved1:4;              // 26-29
        ULONG PageSelect:1;             // 30        
        ULONG InterruptOnComplete:1;    // 31
    };
} HC_SITD_STATE, *PHC_SITD_STATE;

C_ASSERT((sizeof(HC_SITD_STATE) == sizeof(ULONG)));

// Tposition
#define TPOS_ALL        0
#define TPOS_BEGIN      1

typedef union _HC_SITD_BUFFER_POINTER1 {
    ULONG ul;
    struct {
        ULONG Tcount:3;                 // 0-2
        ULONG Tposition:2;              // 3-4
        ULONG Reseved:7;                // 5-11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_SITD_BUFFER_POINTER1, *PHC_SITD_BUFFER_POINTER1;

C_ASSERT((sizeof(HC_SITD_BUFFER_POINTER1) == sizeof(ULONG)));

typedef union _HC_SITD_BUFFER_POINTER0 {
    ULONG ul;
    struct {
        ULONG CurrentOffset:12;         // 0-11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_SITD_BUFFER_POINTER0, *PHC_SITD_BUFFER_POINTER0;

C_ASSERT((sizeof(HC_SITD_BUFFER_POINTER0) == sizeof(ULONG)));

typedef struct _HW_SPLIT_ISOCHRONOUS_TD {
    HW_LINK_POINTER         NextLink;
    HC_SITD_CAPS            Caps;
    HC_SITD_CONTROL         Control;
    HC_SITD_STATE           State;
    HC_SITD_BUFFER_POINTER0 BufferPointer0;
    HC_SITD_BUFFER_POINTER1 BufferPointer1;
    HW_LINK_POINTER         BackPointer;
    ULONG                   BufferPointer64_0;
    ULONG                   BufferPointer64_1;
    ULONG                   Pad[7];
} HW_SPLIT_ISOCHRONOUS_TD, *PHW_SPLIT_ISOCHRONOUS_TD;


C_ASSERT((sizeof(HW_SPLIT_ISOCHRONOUS_TD) == 64));

//
// Queue Element Transfer Descriptor
//

//
// Definitions for HC_QTD_TOKEN.Pid
//

#define HcTOK_Out           0    
#define HcTOK_In            1    
#define HcTOK_Setup         2    
#define HcTOK_Reserved      3     

#define HcTOK_PingDoOut     0
#define HcTOK_PingDoPing    1     

#define HcTOK_Toggle0       0
#define HcTOK_Toggle1       1   

typedef union _HC_BUFFER_POINTER {
    ULONG ul;
    struct {
        ULONG CurrentOffset:12;     // 0-11
        ULONG BufferPointer:20;     // 12-31
    };    
} HC_BUFFER_POINTER, *PHC_BUFFER_POINTER;

C_ASSERT((sizeof(HC_BUFFER_POINTER) == sizeof(ULONG)));


typedef union _HC_QTD_TOKEN {
    ULONG   ul;
    struct {
        // status bits
        ULONG PingState:1;        // 0
        ULONG SplitXstate:1;      // 1
        ULONG MissedMicroFrame:1; // 2
        ULONG XactErr:1;          // 3
        ULONG BabbleDetected:1;   // 4
        ULONG DataBufferError:1;  // 5
        ULONG Halted:1;           // 6
        ULONG Active:1;           // 7
        
        ULONG Pid:2;                    // 8-9
        ULONG ErrorCounter:2;           // 10-11
        ULONG C_Page:3;                 // 12-14
        ULONG InterruptOnComplete:1;    // 15
        
        ULONG BytesToTransfer:15;       // 16-30        
        ULONG DataToggle:1;             // 31
    };
} HC_QTD_TOKEN, *PHC_QTD_TOKEN;

C_ASSERT((sizeof(HC_QTD_TOKEN) == sizeof(ULONG)));


typedef struct _HW_QUEUE_ELEMENT_TD {
    HW_LINK_POINTER             Next_qTD;
    HW_LINK_POINTER             AltNext_qTD;
    HC_QTD_TOKEN                Token;  
    HC_BUFFER_POINTER           BufferPage[5]; 
    ULONG                       BufferPage64[5];
    ULONG                       Pad[3];
} HW_QUEUE_ELEMENT_TD, *PHW_QUEUE_ELEMENT_TD;

C_ASSERT((sizeof(HW_QUEUE_ELEMENT_TD) == 64));


typedef union HC_OVLAY_8 {
    ULONG   ul;
    struct {
        // status bits
        ULONG CprogMask:8;        // 0-7
        ULONG Buffer:24;
    };
} HC_OVLAY_8, *PHC_OVLAY_8;

C_ASSERT((sizeof(HC_OVLAY_8) == sizeof(ULONG)));

typedef union HC_OVLAY_9 {
    ULONG   ul;
    struct {
        // status bits
        ULONG fTag:5;        // 0-4
        ULONG Sbytes:7;      // 5-11
        ULONG Buffer:20;
    };
} HC_OVLAY_9, *PHC_OVLAY_9;

C_ASSERT((sizeof(HC_OVLAY_9) == sizeof(ULONG)));


typedef struct _HW_OVERLAY_AREA {
    HW_LINK_POINTER             Next_qTD;       // dw4
    HW_LINK_POINTER             AltNext_qTD;    // dw5
    HC_QTD_TOKEN                Token;          // dw6
    HC_BUFFER_POINTER           BufferPage0;    // dw7
    HC_OVLAY_8                  OverlayDw8;
    HC_OVLAY_9                  OverlayDw9;
    HC_BUFFER_POINTER           BufferPage3;
    HC_BUFFER_POINTER           BufferPage4;
    ULONG                       BufferPage64[5];
    ULONG                       Pad[3];
} HW_OVERLAY_AREA, *PHW_OVERLAY_AREA;

C_ASSERT((sizeof(HW_QUEUE_ELEMENT_TD) == 64));

//
// General Transfer Descriptor
//

typedef union _HW_TRANSFER_DESCRIPTOR {
    HW_QUEUE_ELEMENT_TD         qTD;
    HW_OVERLAY_AREA             Ov;
} HW_TRANSFER_DESCRIPTOR, *PHW_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HW_TRANSFER_DESCRIPTOR) == 64));


//
// Definitions for HC_ENDPOINT_CHARACTERSITICS.DataToggleControl
//
#define HcEPCHAR_Ignore_Toggle         0    // ignore DT bit from incomming QTD
#define HcEPCHAR_Toggle_From_qTD       1    // DT from incomming QTD

//
// Definitions for HC_ENDPOINT_CHARACTERSITICS.EndpointSpeed
//

#define HcEPCHAR_FullSpeed      0    // 12Mbs
#define HcEPCHAR_LowSpeed       1    // 1.5Mbs
#define HcEPCHAR_HighSpeed      2    // 480Mbs
#define HcEPCHAR_Reserved       3     


typedef union _HC_ENDPOINT_CHARACTERSITICS {
    ULONG   ul;
    struct {
        ULONG DeviceAddress:7;          // 0-6
        ULONG Reserved1:1;              // 7
        ULONG EndpointNumber:4;         // 8-11
        ULONG EndpointSpeed:2;          // 12-13
        ULONG DataToggleControl:1;      // 14
        ULONG HeadOfReclimationList:1;  // 15
        ULONG MaximumPacketLength:11;   // 16-26
        ULONG ControlEndpointFlag:1;    // 27
        ULONG NakReloadCount:4;         // 28-31
    } ;   
} HC_ENDPOINT_CHARACTERSITICS, *PHC_ENDPOINT_CHARACTERSITICS;

C_ASSERT((sizeof(HC_ENDPOINT_CHARACTERSITICS) == sizeof(ULONG)));


typedef union _HC_ENDPOINT_CAPABILITIES {
    ULONG   ul;
    struct {
        ULONG InterruptScheduleMask:8;  // 0-7
        ULONG SplitCompletionMask:8;    // 8-15
        ULONG HubAddress:7;             // 16-22
        ULONG PortNumber:7;             // 23-29
        ULONG HighBWPipeMultiplier:2;   // 30-31
    };
} HC_ENDPOINT_CAPABILITIES, *PHC_ENDPOINT_CAPABILITIES;

C_ASSERT((sizeof(HC_ENDPOINT_CAPABILITIES) == sizeof(ULONG)));

//
// Queue Head Descriptor
//

typedef struct _HW_QUEUEHEAD_DESCRIPTOR {

   HW_LINK_POINTER                  HLink;         // horizontal link ptr dw:0
   HC_ENDPOINT_CHARACTERSITICS      EpChars;       // dw:1
   HC_ENDPOINT_CAPABILITIES         EpCaps;        // dw:2
   HW_LINK_POINTER                  CurrentTD;     // dw:3
   HW_TRANSFER_DESCRIPTOR           Overlay;       // dw:4-11
   
} HW_QUEUEHEAD_DESCRIPTOR, *PHW_QUEUEHEAD_DESCRIPTOR;

C_ASSERT((sizeof(HW_QUEUEHEAD_DESCRIPTOR) == 80));

#include <POPPACK.H>

#endif /* EHCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\int.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    int.c

Abstract:

    interrupt service routine
    
Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-19-99 : created, jdunn

--*/



#include "common.h"


BOOLEAN
EHCI_InterruptService (
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    BOOLEAN usbInt;
    PHC_OPERATIONAL_REGISTER hcOp;
    ULONG enabledIrqs, frameNumber;
    USBSTS irqStatus;
    FRINDEX frameIndex;

    hcOp = DeviceData->OperationalRegisters;

    // assume it is not ours
    usbInt = FALSE;

    if (EHCI_HardwarePresent(DeviceData, FALSE) == FALSE) {
        return FALSE;
    }
    // get a mask of possible interrupts
    enabledIrqs = READ_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul);

    irqStatus.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
    // just look at the IRQ status bits
    irqStatus.ul &= HcInterruptStatusMask;
    // AND with the enabled IRQs
    irqStatus.ul &= enabledIrqs;

    // irqStatus now possibly contains bits set for any currently 
    // enabled interrupts

    if (irqStatus.ul != 0)  {
    
        DeviceData->IrqStatus = irqStatus.ul;

        WRITE_REGISTER_ULONG(&hcOp->UsbStatus.ul, 
                             irqStatus.ul);

#if DBG

        if (irqStatus.HostSystemError) {
            // something has gone terribly wrong
            EHCI_ASSERT(DeviceData, FALSE);
        }
#endif        

        // This code maintains the 32-bit 1 ms frame counter
        
        // bugbug this code does not handle varaible frame list
        // sizes
        frameIndex.ul = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

        frameNumber = (ULONG) frameIndex.FrameListCurrentIndex;
        // shut off the microframes 
        frameNumber >>= 3;
           
        // did the sign bit change ?
        if ((DeviceData->LastFrame ^ frameNumber) & 0x0400) {
            // Yes
            DeviceData->FrameNumberHighPart += 0x0800 -
                ((frameNumber ^ DeviceData->FrameNumberHighPart) & 0x0400);
        }

        // remember the last frame number
        DeviceData->LastFrame = frameNumber;

        // inications are that this came from the 
        // USB controller
        usbInt = TRUE;

        // disable all interrupts until the DPC for ISR runs
        //WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul, 
        //                     0);

    }        

    return usbInt;
}       


VOID
EHCI_InterruptDpc (
     PDEVICE_DATA DeviceData,
     BOOLEAN EnableInterrupts
    )
/*++

Routine Description:

    process an interrupt

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    USBSTS irqStatus, tmp;

    hcOp = DeviceData->OperationalRegisters;

    // ack all status bits asserted now
    //tmp.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
    tmp.ul = DeviceData->IrqStatus;
    DeviceData->IrqStatus = 0;
    
    LOGENTRY(DeviceData, G, '_idp', tmp.ul, 0, 0);

    //WRITE_REGISTER_ULONG(&hcOp->UsbStatus.ul, 
    //                     tmp.ul);

    // now process status bits aserted,
    // just look at the IRQ status bits
    irqStatus.ul = tmp.ul & HcInterruptStatusMask;        
    // AND with the enabled IRQs, these are the interrupts
    // we are interested in
    irqStatus.ul &= DeviceData->EnabledInterrupts.ul;
    

    if (irqStatus.UsbInterrupt || 
        irqStatus.UsbError ||
        irqStatus.IntOnAsyncAdvance) {
        LOGENTRY(DeviceData, G, '_iEP', irqStatus.ul, 0, 0);
    
        USBPORT_INVALIDATE_ENDPOINT(DeviceData, NULL);         
    }         

    if (irqStatus.PortChangeDetect) {
        USBPORT_INVALIDATE_ROOTHUB(DeviceData);
    }

    // since ehci does not provide a way to globally mask 
    // interrupts we must mask off all interrupts in our ISR.
    // When the ISR DPC completes we re-enable the set of 
    // currently enabled interrupts.

    if (EnableInterrupts) {
        LOGENTRY(DeviceData, G, '_iEE', 0, 0, 0);
    
        WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul, 
                             DeviceData->EnabledInterrupts.ul);
    }                             
}


VOID
USBMPFN
EHCI_DisableInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;

    hcOp = DeviceData->OperationalRegisters;

    // mask off all interrupts        
    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul, 
                         0);
}


VOID
USBMPFN
EHCI_FlushInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    USBSTS irqStatus;
    
    hcOp = DeviceData->OperationalRegisters;

    // flush any outstanding interrupts
    irqStatus.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
    WRITE_REGISTER_ULONG(&hcOp->UsbStatus.ul, 
                        irqStatus.ul);
    
}


VOID
USBMPFN
EHCI_EnableInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;

    hcOp = DeviceData->OperationalRegisters;

    // activate the controllers interrupt
    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul, 
                         DeviceData->EnabledInterrupts.ul);

}


VOID
EHCI_RH_DisableIrq(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    USBINTR enabledIrqs;

    hcOp = DeviceData->OperationalRegisters;

    // clear the port change interrupt
    enabledIrqs.ul = 
        READ_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul); 

    enabledIrqs.PortChangeDetect =     
        DeviceData->EnabledInterrupts.PortChangeDetect = 0;

    if (enabledIrqs.UsbInterrupt) {
        WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul, 
                             enabledIrqs.ul);
    }                             
}


VOID
EHCI_RH_EnableIrq(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    USBINTR enabledIrqs;
    
    hcOp = DeviceData->OperationalRegisters;

    // enable the port change interrupt
    enabledIrqs.ul = 
        READ_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul); 
        
    if (!NO_CHIRP(DeviceData)) {
        enabledIrqs.PortChangeDetect =     
            DeviceData->EnabledInterrupts.PortChangeDetect = 1;
    }        
    
    if (enabledIrqs.UsbInterrupt) {
        WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul, 
                             enabledIrqs.ul);
    }                             

}


VOID
EHCI_InterruptNextSOF(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    USBCMD cmd;
   
    hcOp = DeviceData->OperationalRegisters;

    // before we use the doorbell enable the async list
    EHCI_EnableAsyncList(DeviceData);        
    
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    cmd.IntOnAsyncAdvanceDoorbell = 1;
    
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);
//  TEST_TRAP();    
}


ULONG
EHCI_Get32BitFrameNumber(
     PDEVICE_DATA DeviceData
    )
{
    ULONG highPart, currentFrame, frameNumber;
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    FRINDEX frameIndex;

    hcOp = DeviceData->OperationalRegisters;
    
     // get Hcd's high part of frame number
    highPart = DeviceData->FrameNumberHighPart;

    // bugbug this code does not handle varaible frame list
    // sizes
    frameIndex.ul = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

    frameNumber = (ULONG) frameIndex.FrameListCurrentIndex;
    // shift off the microframes 
    frameNumber >>= 3;
       
    currentFrame = ((frameNumber & 0x0bff) | highPart) +
        ((frameNumber ^ highPart) & 0x0400);

    return currentFrame;

}


BOOLEAN
EHCI_HardwarePresent(
    PDEVICE_DATA DeviceData,
    BOOLEAN Notify
    )
{
    ULONG tmp;
    PHC_OPERATIONAL_REGISTER hcOp;

    hcOp = DeviceData->OperationalRegisters;

    tmp = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    if (tmp == 0xffffffff) { 
        if (Notify) {
            USBPORT_INVALIDATE_CONTROLLER(DeviceData, UsbMpControllerRemoved);
        }   
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\iso.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   iso.c

Abstract:

   miniport transfer code for interrupt endpoints

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    1-1-01 : created, jdunn

--*/

#include "common.h"

/*
    We build a table of 32 TDs for iso endpoints and insert them in the 
    schedule, these TDs are static -- we only change the buffer pointers.

    The TD 'table' represents a 32ms snapshot of time.

    We end up with each iso endpoint siTD list as a column in the table



frame  dummyQH iso1  iso2  iso3  staticQH
  1             |     |     |       |---> (periodic lists)
  2             |     |     |       |     
  3             |     |     |       |
  4             |     |     |       |
...             |     |     |       |
                |     |     |       |
1024            |     |     |       |
*/


#define     ISO_SCHEDULE_SIZE       32
#define     ISO_SCHEDULE_MASK       0x1f

#define HIGHSPEED(ed) ((ed)->Parameters.DeviceSpeed == HighSpeed ? TRUE : FALSE)

VOID
EHCI_RebalanceIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,        
    PENDPOINT_DATA EndpointData
    ) 
/*++

Routine Description:

    compute how much common buffer we will need
    for this endpoint

Arguments:

Return Value:

--*/
{
    PHCD_SI_TRANSFER_DESCRIPTOR siTd;
    ULONG i, f;
    ULONG currentFrame;
    
    currentFrame = EHCI_Get32BitFrameNumber(DeviceData);
    // should only have to deal with s-mask and c-mask changes

    EHCI_ASSERT(DeviceData, !HIGHSPEED(EndpointData));

    //NOTE: irql should be raised for us
    
    // update internal copy of parameters
    EndpointData->Parameters = *EndpointParameters;
 
    
    f = currentFrame & ISO_SCHEDULE_MASK;
    for (i=0; i<EndpointData->TdCount; i++) {

        siTd = &EndpointData->SiTdList->Td[f];

        siTd->HwTD.Control.cMask = 
            EndpointParameters->SplitCompletionMask;
        siTd->HwTD.Control.sMask = 
            EndpointParameters->InterruptScheduleMask;

        f++;
        f &= ISO_SCHEDULE_MASK;            
    }
            
}


VOID
EHCI_InitializeSiTD(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PHCD_SI_TRANSFER_DESCRIPTOR SiTd,
    PHCD_SI_TRANSFER_DESCRIPTOR PrevSiTd,
    HW_32BIT_PHYSICAL_ADDRESS PhysicalAddress
    )
/*++

Routine Description:

    Initailze a static SiTD for an endpoint

Arguments:

Return Value:

    none
--*/
{
    SiTd->Sig = SIG_HCD_SITD;
    SiTd->PhysicalAddress = PhysicalAddress;
    ISO_PACKET_PTR(SiTd->Packet) = NULL;
    
    SiTd->HwTD.Caps.ul = 0;        
    SiTd->HwTD.Caps.DeviceAddress = 
        EndpointParameters->DeviceAddress;
    SiTd->HwTD.Caps.EndpointNumber = 
        EndpointParameters->EndpointAddress;
    SiTd->HwTD.Caps.HubAddress = 
        EndpointParameters->TtDeviceAddress;
    SiTd->HwTD.Caps.PortNumber = 
        EndpointParameters->TtPortNumber;
    // 1 = IN 0 = OUT
    SiTd->HwTD.Caps.Direction = 
        (EndpointParameters->TransferDirection == In) ? 1 : 0;

    SiTd->HwTD.Control.ul = 0;
    SiTd->HwTD.Control.cMask = 
        EndpointParameters->SplitCompletionMask;
    SiTd->HwTD.Control.sMask = 
        EndpointParameters->InterruptScheduleMask;

    SiTd->HwTD.BackPointer.HwAddress = 
        PrevSiTd->PhysicalAddress;

    SiTd->HwTD.State.ul = 0;
}


VOID
EHCI_InsertIsoTdsInSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PENDPOINT_DATA PrevEndpointData,
    PENDPOINT_DATA NextEndpointData
    )
/*++

Routine Description:

   Insert an aync endpoint (queue head) 
   into the HW list

   schedule should look like:

   DUMMYQH->ISOQH-ISOQH->INTQH

Arguments:


--*/
{   
    //PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    ULONG i;

    LOGENTRY(DeviceData, G, '_iAD', PrevEndpointData, 
        NextEndpointData, EndpointData);

    //frameBase = DeviceData->FrameListBaseAddress;
    
    for (i=0; i<USBEHCI_MAX_FRAME; i++) {
    
        PHCD_SI_TRANSFER_DESCRIPTOR siTd, nextSiTd;            
        PHCD_QUEUEHEAD_DESCRIPTOR qh;
        PHCD_QUEUEHEAD_DESCRIPTOR dQh;
        ULONG phys;

        siTd = &EndpointData->SiTdList->Td[i&0x1f];

        // fixup next link
        if (NextEndpointData == NULL && 
            PrevEndpointData == NULL) {

            // list empty add to head
            if (i == 0) {
                EHCI_ASSERT(DeviceData, DeviceData->IsoEndpointListHead == NULL);
                DeviceData->IsoEndpointListHead = EndpointData;
                EndpointData->PrevEndpoint = NULL;
                EndpointData->NextEndpoint = NULL;
            }                
            // list empty add to head
            
            // no iso endpoints, link to the interrupt 
            // queue heads via the dummy qh
            //
            // point at the static perodic queue head pointed to 
            // by the appropriate dummy
            // DUMMY->INTQH
            //  to
            // ISOTD->INTQH
            dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
            siTd->HwTD.NextLink.HwAddress = dQh->HwQH.HLink.HwAddress; 
            HW_PTR(siTd->NextLink) = HW_PTR(dQh->NextLink);

            phys = siTd->PhysicalAddress;
            SET_SITD(phys);
            //
            // appropriate dummy should point to these TDs
            // DUMMY->INTQH, ISOTD->INTQH
            //  to
            // DUMMY->ISOTD->INTQH
            dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
            dQh->HwQH.HLink.HwAddress = phys; 
            HW_PTR(dQh->NextLink) = (PUCHAR) siTd; 
            
        } else {
           
            if (NextEndpointData == NULL) {
            // tail of list, list not empty
            // add to tail
                if (i == 0) {
                    EHCI_ASSERT(DeviceData, PrevEndpointData != NULL);
                    EHCI_ASSERT(DeviceData, DeviceData->IsoEndpointListHead != NULL);
                
                    PrevEndpointData->NextEndpoint = EndpointData;
                    EndpointData->PrevEndpoint = PrevEndpointData;
                    EndpointData->NextEndpoint = NULL;
                }                    

                LOGENTRY(DeviceData, G, '_iTL', PrevEndpointData, 
                        NextEndpointData, EndpointData);

                // tail of list, link to qh
                // ISOTD->INTQH
                //  to 
                // ISOTD->newISOTD->INTQH
                // 
                if (HIGHSPEED(PrevEndpointData)) {
                
                    PHCD_HSISO_TRANSFER_DESCRIPTOR previTd;
                    
                    PUCHAR next;
                    
                    previTd = &PrevEndpointData->HsIsoTdList->Td[i];
                    ASSERT_ITD(DeviceData, previTd);
                    
                    siTd = &EndpointData->SiTdList->Td[i&0x1f];
                    ASSERT_SITD(DeviceData, siTd);

                    // fixup current next ptr
                    phys = previTd->HwTD.NextLink.HwAddress;
                    next = HW_PTR(previTd->NextLink);
                    siTd->HwTD.NextLink.HwAddress = phys;
                    HW_PTR(siTd->NextLink) = next;

                    // fixup prev next ptr
                    HW_PTR(previTd->NextLink) = (PUCHAR) siTd;
                    phys = siTd->PhysicalAddress;
                    SET_SITD(phys);
                    previTd->HwTD.NextLink.HwAddress = phys;
                    
                } else  {

                    PHCD_SI_TRANSFER_DESCRIPTOR prevSiTd;
                    PUCHAR next;
                    
                    prevSiTd = &PrevEndpointData->SiTdList->Td[i&0x1f];
                    ASSERT_SITD(DeviceData, prevSiTd);
                    
                    siTd = &EndpointData->SiTdList->Td[i&0x1f];
                    ASSERT_SITD(DeviceData, siTd);

                    if (i<32) {
                        //newISOTD->INTQH
                        phys = prevSiTd->HwTD.NextLink.HwAddress;
                        next = HW_PTR(prevSiTd->NextLink);
                        siTd->HwTD.NextLink.HwAddress = phys;
                        HW_PTR(siTd->NextLink) = next;
                        LOGENTRY(DeviceData, G, '_in1', phys, next, siTd);

                        //ISOTD->newISOTD
                        phys = siTd->PhysicalAddress;
                        SET_SITD(phys);
                        next = (PUCHAR) siTd;
                        prevSiTd->HwTD.NextLink.HwAddress = phys;
                        HW_PTR(prevSiTd->NextLink) = next;

                        LOGENTRY(DeviceData, G, '_in2', phys, next, siTd);
                    }                        
                }

            // add to tail
            } else {
            // list not empty, not tail
            // add to middle OR head                
                //
                // link to the next iso endpoint
                // ISOTD->INTQH
                //  to
                // newISOTD->ISOTD->INTQH
                if (i == 0) {
                    EHCI_ASSERT(DeviceData, NextEndpointData != NULL);
                    EndpointData->NextEndpoint = NextEndpointData;
                    NextEndpointData->PrevEndpoint = EndpointData;
                }                    

                // link to next
                nextSiTd = &NextEndpointData->SiTdList->Td[i&0x1f];
                phys = nextSiTd->PhysicalAddress;
                SET_SITD(phys);

                // link to the next iso endpoint
                siTd->HwTD.NextLink.HwAddress = phys;
                HW_PTR(siTd->NextLink) = (PUCHAR) nextSiTd;

                // link to prev
                if (PrevEndpointData != NULL) {
                    // middle
                    // ISOTD->ISOTD->INTQH, newISOTD->ISOTD->INTQH
                    // to 
                    // ISOTD->newISOTD->ISOTD->INTQH

                    if (i == 0) {
                        PrevEndpointData->NextEndpoint = EndpointData;
                        EndpointData->PrevEndpoint = PrevEndpointData;
                    }                        
                        
                    if (HIGHSPEED(PrevEndpointData)) {
                    
                        PHCD_HSISO_TRANSFER_DESCRIPTOR previTd;
                        
                        previTd = &PrevEndpointData->HsIsoTdList->Td[i];
                        ASSERT_ITD(DeviceData, previTd);
                        
                        siTd = &EndpointData->SiTdList->Td[i&0x1f];
                        ASSERT_SITD(DeviceData, siTd);
                        
                        phys = siTd->PhysicalAddress;
                        SET_SITD(phys);
                        previTd->HwTD.NextLink.HwAddress = phys;
                        HW_PTR(previTd->NextLink) = (PUCHAR) siTd;
                    } else  {

                        PHCD_SI_TRANSFER_DESCRIPTOR prevSiTd;
                        
                        prevSiTd = &PrevEndpointData->SiTdList->Td[i&0x1f];
                        ASSERT_SITD(DeviceData, prevSiTd);
                        
                        siTd = &EndpointData->SiTdList->Td[i&0x1f];
                        ASSERT_SITD(DeviceData, siTd);

                        phys = siTd->PhysicalAddress;
                        SET_SITD(phys);
                        prevSiTd->HwTD.NextLink.HwAddress = phys;
                        HW_PTR(prevSiTd->NextLink) = (PUCHAR)siTd;
                    }
                } else {
                    // head of list, list not empty
                    if (i == 0) {
                        EHCI_ASSERT(DeviceData, NextEndpointData != NULL);
                        EHCI_ASSERT(DeviceData, NextEndpointData ==
                                        DeviceData->IsoEndpointListHead);

                        DeviceData->IsoEndpointListHead = EndpointData;
                        EndpointData->PrevEndpoint = NULL;
                    }                        
                    
                    phys = siTd->PhysicalAddress;
                    SET_SITD(phys);
                    // head of list, link to Dummy QH
                    //
                    // appropriate dummy should point to these TDs
                    // DUMMY->ISOTD->INTQH, newISOTD->ISOTD->INTQH
                    //  to
                    // DUMMY->newISOTD->ISOTD->INTQH
                    dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
                    dQh->HwQH.HLink.HwAddress = phys; 
                    HW_PTR(dQh->NextLink) = (PUCHAR) siTd;
                }
                      
            } 
        } // not empty
        
    } 

}


VOID
EHCI_RemoveIsoTdsFromSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData     
    )
/*++

Routine Description:

   unlink the iso TDs from the schedule

Arguments:


--*/
{   
    ULONG i;
    PENDPOINT_DATA prevEndpoint, nextEndpoint;     
    PHCD_QUEUEHEAD_DESCRIPTOR dQh;
    
    prevEndpoint = EndpointData->PrevEndpoint;
    nextEndpoint = EndpointData->NextEndpoint;

    LOGENTRY(DeviceData, G, '_iRM', prevEndpoint, 
        nextEndpoint, EndpointData);
    
    if (DeviceData->IsoEndpointListHead == EndpointData) {
        // this is the head
        
        for (i=0; i<USBEHCI_MAX_FRAME; i++) {
        
            PHCD_SI_TRANSFER_DESCRIPTOR siTd;            
            ULONG phys;

            siTd = &EndpointData->SiTdList->Td[i&0x1f];
            phys = siTd->HwTD.NextLink.HwAddress;

            dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
            dQh->HwQH.HLink.HwAddress = phys; 
            HW_PTR(dQh->NextLink) = HW_PTR(siTd->NextLink);
        }    

        DeviceData->IsoEndpointListHead = 
            EndpointData->NextEndpoint;
        if (nextEndpoint != NULL) {
            EHCI_ASSERT(DeviceData, 
                        nextEndpoint->PrevEndpoint == EndpointData);
            nextEndpoint->PrevEndpoint = NULL;            
        }                
    } else {
        // middle or tail
        EHCI_ASSERT(DeviceData, prevEndpoint != NULL);
        
        if (HIGHSPEED(prevEndpoint)) {
            
            for (i=0; i<USBEHCI_MAX_FRAME; i++) {
                PHCD_HSISO_TRANSFER_DESCRIPTOR previTd;
                PHCD_SI_TRANSFER_DESCRIPTOR siTd;            
                ULONG phys;

                siTd = &EndpointData->SiTdList->Td[i&0x1f];
                previTd = &prevEndpoint->HsIsoTdList->Td[i];
                
                phys = siTd->HwTD.NextLink.HwAddress;
                previTd->HwTD.NextLink.HwAddress = phys;

                HW_PTR(previTd->NextLink) = HW_PTR(siTd->NextLink);
            }   
            prevEndpoint->NextEndpoint = 
                    EndpointData->NextEndpoint;
            if (nextEndpoint) {                       
                nextEndpoint->PrevEndpoint = prevEndpoint;                    
            }                
        } else {
            
            for (i=0; i<ISO_SCHEDULE_SIZE; i++) {
            
                PHCD_SI_TRANSFER_DESCRIPTOR siTd, prevSiTd;            
                ULONG phys;

                siTd = &EndpointData->SiTdList->Td[i];
                prevSiTd = &prevEndpoint->SiTdList->Td[i];
                
                phys = siTd->HwTD.NextLink.HwAddress;
                prevSiTd->HwTD.NextLink.HwAddress = phys;
                HW_PTR(prevSiTd->NextLink) = HW_PTR(siTd->NextLink);
            }  
            prevEndpoint->NextEndpoint = 
                    EndpointData->NextEndpoint;
            if (nextEndpoint) {                    
                nextEndpoint->PrevEndpoint = prevEndpoint;
            }                
                    
        }            
    }
}


USB_MINIPORT_STATUS
EHCI_OpenIsochronousEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    ULONG i;
    ULONG bytes;
    PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    PENDPOINT_DATA prevEndpoint, nextEndpoint;
    
    LOGENTRY(DeviceData, G, '_opR', 0, 0, EndpointParameters);
    
    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
   
    // how much did we get
    bytes = EndpointParameters->CommonBufferBytes;
    
    EndpointData->SiTdList = (PHCD_SITD_LIST) buffer;
    // bugbug use manifest
    EndpointData->TdCount = ISO_SCHEDULE_SIZE;
    EndpointData->LastFrame = 0;
    
    for (i=0; i<EndpointData->TdCount; i++) {
        
        EHCI_InitializeSiTD(DeviceData,
                            EndpointData,
                            EndpointParameters,                                
                            &EndpointData->SiTdList->Td[i],
                            i > 0 ? 
                                &EndpointData->SiTdList->Td[i-1] :
                                &EndpointData->SiTdList->Td[EndpointData->TdCount-1],
                            phys);                                         
                             
        phys += sizeof(HCD_SI_TRANSFER_DESCRIPTOR); 
        
    }
    EndpointData->SiTdList->Td[0].HwTD.BackPointer.HwAddress = 
        EndpointData->SiTdList->Td[EndpointData->TdCount-1].PhysicalAddress;

    // split iso eps are inserted after any high speed eps
    
    if (DeviceData->IsoEndpointListHead == NULL) {
        // empty list
        prevEndpoint = NULL;
        nextEndpoint = NULL;
    } else {
    
        prevEndpoint = NULL;
        nextEndpoint = DeviceData->IsoEndpointListHead;
        // walk the list to the first non HS ep or to 
        // a NULL

        while (nextEndpoint != NULL && 
               HIGHSPEED(nextEndpoint)) {
            prevEndpoint = nextEndpoint;
            nextEndpoint = prevEndpoint->NextEndpoint;
        }               

        if (nextEndpoint != NULL) {
            // 
            // nextEndpoint is first non high speed endpoint
            // see what order it sould be added
            if (EndpointData->Parameters.Ordinal == 1) {
                // ordinal 1 add after this one
                prevEndpoint = nextEndpoint;
                nextEndpoint = prevEndpoint->NextEndpoint;
            }
        }
    }   

    // insert this column of TDs thru the schedule
    EHCI_InsertIsoTdsInSchedule(DeviceData, 
                                EndpointData,
                                prevEndpoint,
                                nextEndpoint);

    // init endpoint structures
    InitializeListHead(&EndpointData->TransferList);

    EHCI_EnablePeriodicList(DeviceData);
    
    return USBMP_STATUS_SUCCESS;            
}


VOID
EHCI_MapIsoPacketToTd(
    PDEVICE_DATA DeviceData, 
    PENDPOINT_DATA EndpointData,
    PMINIPORT_ISO_PACKET Packet,
    PHCD_SI_TRANSFER_DESCRIPTOR SiTd 
    )
/*++

Routine Description:

    

Arguments:

Returns:
    
--*/
{
    ULONG length;
    
    LOGENTRY(DeviceData, G, '_mpI', SiTd, 0, Packet); 

    SiTd->HwTD.State.ul = 0;
    SiTd->HwTD.BufferPointer0.ul = 0;
    SiTd->HwTD.BufferPointer1.ul = 0;

    SiTd->HwTD.BufferPointer0.ul = 
        Packet->BufferPointer0.Hw32;
    length = Packet->BufferPointer0Length;
    SiTd->StartOffset = SiTd->HwTD.BufferPointer0.CurrentOffset;

    SiTd->HwTD.BufferPointer1.ul = 0;
    if (Packet->BufferPointerCount > 1) {
        EHCI_ASSERT(DeviceData, 
                    (Packet->BufferPointer1.Hw32 & 0xFFF) == 0);
                    
        SiTd->HwTD.BufferPointer1.ul = 
            Packet->BufferPointer1.Hw32;
        length += Packet->BufferPointer1Length;                 
    } 

    // not sure if this is corrext for IN
    SiTd->HwTD.BufferPointer1.Tposition = TPOS_ALL;
    
    if (EndpointData->Parameters.TransferDirection == Out) {

        if (length == 0) {
           SiTd->HwTD.BufferPointer1.Tcount = 1;
        } else {
           SiTd->HwTD.BufferPointer1.Tcount = ((length -1) / 188) +1;
        }

        if (SiTd->HwTD.BufferPointer1.Tcount == 1) {
            SiTd->HwTD.BufferPointer1.Tposition = TPOS_ALL;
        } else {
            SiTd->HwTD.BufferPointer1.Tposition = TPOS_BEGIN;
        }
        
        EHCI_ASSERT(DeviceData, SiTd->HwTD.BufferPointer1.Tcount <= 6);      
        
    } else {
        SiTd->HwTD.BufferPointer1.Tcount = 0;
    }

    SiTd->HwTD.State.BytesToTransfer = length;
    SiTd->HwTD.State.Active = 1;
    SiTd->HwTD.State.InterruptOnComplete = 1;

    EHCI_ASSERT(DeviceData, SiTd->HwTD.BackPointer.HwAddress != 0);
}            


VOID
EHCI_CompleteIsoPacket(
    PDEVICE_DATA DeviceData,
    PMINIPORT_ISO_PACKET Packet,
    PHCD_SI_TRANSFER_DESCRIPTOR SiTd 
    )
/*++

Routine Description:

    

Arguments:

Returns:
    
--*/
{
    ULONG length;
    ULONG cf = EHCI_Get32BitFrameNumber(DeviceData);
    
    LOGENTRY(DeviceData, G, '_cpI', Packet, SiTd, cf);

    if (SiTd->HwTD.State.Active == 1) {
        // missed 
        Packet->LengthTransferred = 0;    
        LOGENTRY(DeviceData, G, '_cms', 
            Packet, 
            0,
            Packet->FrameNumber);
            
    } else {

        //length = SiTd->HwTD.BufferPointer0.CurrentOffset - 
        //    SiTd->StartOffset;
        //LOGENTRY(DeviceData, G, '_cp2', 
        //    Packet->FrameNumber, 
        //    SiTd->HwTD.BufferPointer0.CurrentOffset,
        //    SiTd->StartOffset);
        
        length = Packet->Length - SiTd->HwTD.State.BytesToTransfer;
        LOGENTRY(DeviceData, G, '_cp3', 
            Packet->FrameNumber, 
            Packet->Length ,
            SiTd->HwTD.State.BytesToTransfer);
        
        Packet->LengthTransferred = length;
        LOGENTRY(DeviceData, G, '_cpL', Packet, SiTd, length);
    }

     //Packet->LengthTransferred = 928;
    
    // map status
    LOGENTRY(DeviceData, G, '_cpS', Packet, SiTd->HwTD.State.ul, 
        Packet->UsbdStatus);

    Packet->UsbdStatus = USBD_STATUS_SUCCESS;
}         


PMINIPORT_ISO_PACKET
EHCI_GetPacketForFrame(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT *Transfer,
    ULONG Frame
    )
/*++

Routine Description:

    fetch the iso packet associated with the given frame 
    if we have one in our current transfer list

Arguments:

Returns:
    
--*/
{
    ULONG i;
    PLIST_ENTRY listEntry;
    
    listEntry = EndpointData->TransferList.Flink;
    while (listEntry != &EndpointData->TransferList) {
    
        PTRANSFER_CONTEXT transfer;
        
        transfer = (PTRANSFER_CONTEXT) CONTAINING_RECORD(
                     listEntry,
                     struct _TRANSFER_CONTEXT, 
                     TransferLink);
                     
        ASSERT_TRANSFER(DeviceData, transfer);
        
        if (Frame <= transfer->FrameComplete) {                     
            for(i=0; i<transfer->IsoTransfer->PacketCount; i++) {
                if (transfer->IsoTransfer->Packets[i].FrameNumber == Frame) {
                    *Transfer = transfer;
                    return &transfer->IsoTransfer->Packets[i];
                }
            }
        }
        
        listEntry = transfer->TransferLink.Flink;              
    }   

    return NULL;
}         

ULONG xCount = 0;
ULONG pCount = 0;

VOID
EHCI_InternalPollIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    BOOLEAN Complete
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'
    

    static iso TD table
    --------------------
    0                       < -- (lastFrame & 0x1f)
    1                       {completed} 
    2                       {completed}
    3                       {limbo}
    4                       < -- (currentframe & 0x1f)
    ...

    31
    ---------------------


Arguments:

Return Value:

--*/

{
    ULONG x, i;
    ULONG currentFrame, lastFrame;
    PHCD_SI_TRANSFER_DESCRIPTOR siTd;
    PMINIPORT_ISO_PACKET packet;
    PLIST_ENTRY listEntry;
    PTRANSFER_CONTEXT transfer;
    ULONG transfersPending, fc; 
    
    currentFrame = EHCI_Get32BitFrameNumber(DeviceData);
    lastFrame = EndpointData->LastFrame;

    LOGENTRY(DeviceData, G, '_pis', lastFrame, currentFrame, 
        EndpointData);

   // if (pCount > 60) {
   //     TEST_TRAP();
   // }
    
    if (currentFrame - lastFrame > ISO_SCHEDULE_SIZE) {
        // overrun
        lastFrame = currentFrame-1;
        LOGENTRY(DeviceData, G, '_ove', lastFrame, currentFrame, 0); 

        // dump the current contents
        for (i = 0; i <ISO_SCHEDULE_SIZE; i++) {

            siTd = &EndpointData->SiTdList->Td[i];

            transfer = ISO_TRANSFER_PTR(siTd->Transfer);

            if (transfer != NULL) {
                ISO_PACKET_PTR(siTd->Packet) = NULL;
                ISO_TRANSFER_PTR(siTd->Transfer) = NULL;
                transfer->PendingPackets--;
            }     
        }   
    }

    if (lastFrame == currentFrame) {
        // too early to do anything
        LOGENTRY(DeviceData, G, '_ear', lastFrame, currentFrame, 0); 
        return;
    }

    // TDs between lastframe and currentframe are complete, 
    // complete the packets associated with them


//    f0
//    f1 
//    f2  < ------- last frame   }
//    f3                         }  these are complete
//    f4                         <- backpointer may still be pointing here
//    f5  < ------- current frame       
//    f6
//    f7
//    f8

    x = (lastFrame & (ISO_SCHEDULE_MASK));

    LOGENTRY(DeviceData, G, '_frm', lastFrame, x, currentFrame); 
    while (x != ((currentFrame-1) & ISO_SCHEDULE_MASK)) {
        siTd = &EndpointData->SiTdList->Td[x];

        ASSERT_SITD(DeviceData, siTd);
        // complete this packet
        packet = ISO_PACKET_PTR(siTd->Packet);
        transfer = ISO_TRANSFER_PTR(siTd->Transfer);
        LOGENTRY(DeviceData, G, '_gpk', transfer, packet, x); 
        
        if (packet != NULL) {
            transfer = ISO_TRANSFER_PTR(siTd->Transfer);    
            ASSERT_TRANSFER(DeviceData, transfer);
            EHCI_CompleteIsoPacket(DeviceData, packet, siTd);
            ISO_PACKET_PTR(siTd->Packet) = NULL;
            ISO_TRANSFER_PTR(siTd->Transfer) = NULL;
            transfer->PendingPackets--;
        }            
        
        lastFrame++;
        x++;
        x &= ISO_SCHEDULE_MASK;
    } 

    // attempt to program what we can, if siTD is NULL 
    // then we can program this frame
    // NOTE: No scheduling if paused!
    if (EndpointData->State != ENDPOINT_PAUSE) {
        LOGENTRY(DeviceData, G, '_psh', 0, 0, 0); 
       
        for (i=0; i <ISO_SCHEDULE_SIZE; i++) {

            x = ((currentFrame+i) & ISO_SCHEDULE_MASK);

            siTd = &EndpointData->SiTdList->Td[x];
            ASSERT_SITD(DeviceData, siTd);

            LOGENTRY(DeviceData, G, '_gpf', siTd, x, currentFrame+i); 

            // open slot?
            if (ISO_PACKET_PTR(siTd->Packet) != NULL) {   
                // no, bail
                continue;
            }
                
            // yes, see if we have a packet
            packet = EHCI_GetPacketForFrame(DeviceData,
                                            EndpointData,
                                            &transfer,
                                            currentFrame+i);

            if (packet != NULL) {
                EHCI_ASSERT(DeviceData, ISO_PACKET_PTR(siTd->Packet) == NULL);         
                
                EHCI_MapIsoPacketToTd(DeviceData, EndpointData, 
                    packet, siTd);
                ISO_PACKET_PTR(siTd->Packet) = packet;
                ASSERT_TRANSFER(DeviceData, transfer);
                ISO_TRANSFER_PTR(siTd->Transfer) = transfer;
                transfer->PendingPackets++;
            } 
        }
    }

    EHCI_ASSERT(DeviceData, lastFrame < currentFrame);
    EndpointData->LastFrame = lastFrame;
    
    // walk our list of active iso transfers and see 
    // if any are complete
  
    listEntry = EndpointData->TransferList.Flink;
    transfersPending = 0;
    
    while (listEntry != &EndpointData->TransferList && Complete) {
        PTRANSFER_CONTEXT transfer;
        
        transfer = (PTRANSFER_CONTEXT) CONTAINING_RECORD(
                     listEntry,
                     struct _TRANSFER_CONTEXT, 
                     TransferLink);

        LOGENTRY(DeviceData, G, '_ckt', transfer, transfer->FrameComplete+2
            , currentFrame);

        EHCI_ASSERT(DeviceData, transfer->Sig == SIG_EHCI_TRANSFER);
        if (currentFrame >= transfer->FrameComplete + 2 &&
            transfer->PendingPackets == 0) {

            listEntry = transfer->TransferLink.Flink;                
            RemoveEntryList(&transfer->TransferLink); 
            LOGENTRY(DeviceData, G, '_cpi', transfer, 0, 0);

    // if (xCount==2) {
    //    TEST_TRAP();
    //}
            USBPORT_COMPLETE_ISO_TRANSFER(DeviceData,
                                          EndpointData,
                                          transfer->TransferParameters,
                                          transfer->IsoTransfer);
        } else {
            transfersPending++;
            fc = transfer->FrameComplete;
            listEntry = transfer->TransferLink.Flink;              
        }            
    }

    currentFrame = EHCI_Get32BitFrameNumber(DeviceData);
    if (transfersPending == 1 && 
        fc >= currentFrame &&
        (fc - currentFrame) < 2 ) {
        LOGENTRY(DeviceData, G, '_rei', fc, currentFrame, 0);

        EHCI_InterruptNextSOF(DeviceData);
    }        
}


VOID
EHCI_PollIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    )
{
    LOGENTRY(DeviceData, G, '_ipl', 0, 0, 0); 

    if (!IsListEmpty(&EndpointData->TransferList)) {
        LOGENTRY(DeviceData, G, '_III', 0, 0, 0); 

        if (HIGHSPEED(EndpointData)) {
            EHCI_InternalPollHsIsoEndpoint(DeviceData, EndpointData, TRUE);
        } else {
            EHCI_InternalPollIsoEndpoint(DeviceData, EndpointData, TRUE);
        }            
    }        
}


USB_MINIPORT_STATUS
EHCI_AbortIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/    
{
    PHCD_SI_TRANSFER_DESCRIPTOR siTd;
    ULONG i;
    
    // iso TD table should be idle at this point all we 
    // need to do is make sure we have no TDs still pointing
    // at this transfer and remove it frome any internal 
    // queues

    for (i = 0; i <ISO_SCHEDULE_SIZE; i++) {

        siTd = &EndpointData->SiTdList->Td[i];

        if (ISO_TRANSFER_PTR(siTd->Transfer) == TransferContext) {         
            ISO_TRANSFER_PTR(siTd->Transfer) = NULL;
            ISO_PACKET_PTR(siTd->Packet) = NULL;
            TransferContext->PendingPackets--;
        }     
    }   

    // remove this transfer from our lists
    RemoveEntryList(&TransferContext->TransferLink); 

    return USBMP_STATUS_SUCCESS;
    
}

USB_MINIPORT_STATUS
EHCI_SubmitIsoTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PMINIPORT_ISO_TRANSFER IsoTransfer
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/    
{
    // init the structures and queue the endpoint
    LOGENTRY(DeviceData, G, '_ISO', TransferContext, 0, 0);

    RtlZeroMemory(TransferContext, sizeof(TRANSFER_CONTEXT));
    TransferContext->Sig = SIG_EHCI_TRANSFER;
    TransferContext->IsoTransfer = IsoTransfer;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = TransferParameters;

    if (HIGHSPEED(EndpointData)) {
         TransferContext->FrameComplete = 
            IsoTransfer->Packets[0].FrameNumber + IsoTransfer->PacketCount/8;
    } else {
        TransferContext->FrameComplete = 
            IsoTransfer->Packets[0].FrameNumber + IsoTransfer->PacketCount;
    }            
    TransferContext->PendingPackets = 0;

    // if queues are empty the go ahead and reset the table
    // so we can fill now
    if (IsListEmpty(&EndpointData->TransferList)) {
        EndpointData->LastFrame = 0;
        LOGENTRY(DeviceData, G, '_rsi', 0, 0, 0); 
    }
    
    InsertTailList(&EndpointData->TransferList,
                   &TransferContext->TransferLink);

    // scehdule the initial part of the transfer if 
    // possible
    if (HIGHSPEED(EndpointData)) {
        EHCI_InternalPollHsIsoEndpoint(DeviceData,
                                       EndpointData,
                                       FALSE);
    } else {
        EHCI_InternalPollIsoEndpoint(DeviceData,
                                     EndpointData,
                                     FALSE);
    }                                     

    xCount++;
    //if (xCount==2) {
    //    TEST_TRAP();
    //}
    return USBMP_STATUS_SUCCESS;                         
}


VOID
EHCI_SetIsoEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATE State
    )    
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    ENDPOINT_TRANSFER_TYPE epType;
    ULONG i, j;
    
    epType = EndpointData->Parameters.TransferType;
    EHCI_ASSERT(DeviceData, epType == Isochronous);
    
    switch(State) {
    case ENDPOINT_ACTIVE:
        EndpointData->LastFrame =  EHCI_Get32BitFrameNumber(DeviceData);
        break;
        
    case ENDPOINT_PAUSE:
        // clear the active bit on all TDs
        if (HIGHSPEED(EndpointData)) {
            for (i=0; i<EndpointData->TdCount; i++) {
                for(j=0; j<8; j++) {
                    EndpointData->HsIsoTdList->Td[i].HwTD.Transaction[j].Active = 0;
                }                    
            }  
        } else {
            for (i=0; i<EndpointData->TdCount; i++) {
                EndpointData->SiTdList->Td[i].HwTD.State.Active = 0;
            }     
        }
        break;
        
    case ENDPOINT_REMOVE:
        if (HIGHSPEED(EndpointData)) {
            EHCI_RemoveHsIsoTdsFromSchedule(DeviceData,
                                          EndpointData);
        } else {
            EHCI_RemoveIsoTdsFromSchedule(DeviceData,
                                          EndpointData); 
        }                                          
        break;            
        
    default:        
        TEST_TRAP();
    }  

    EndpointData->State = State;
}    

/*
    High Speed Iso code


    We use a variation of the split Iso code here. We allocate 1024
    static TDs and insert them in the schedule.  These TDs are then 
    updated with the current transfers instead of inserted or removed.

    
*/

VOID
EHCI_Initialize_iTD(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PHCD_HSISO_TRANSFER_DESCRIPTOR IsoTd,
    HW_32BIT_PHYSICAL_ADDRESS PhysicalAddress,
    ULONG Frame
    )
/*++

Routine Description:

    Initailze a static SiTD for an endpoint

Arguments:

Return Value:

    none
--*/
{
    ULONG i;
    
    IsoTd->Sig = SIG_HCD_ITD;
    IsoTd->PhysicalAddress = PhysicalAddress;
    ISO_PACKET_PTR(IsoTd->FirstPacket) = NULL;
    IsoTd->HostFrame = Frame;
    
    for (i=0; i< 8; i++) {
        IsoTd->HwTD.Transaction[i].ul = 0;
    }
    
    IsoTd->HwTD.BufferPointer0.DeviceAddress = 
        EndpointParameters->DeviceAddress;        
    IsoTd->HwTD.BufferPointer0.EndpointNumber = 
        EndpointParameters->EndpointAddress;

    IsoTd->HwTD.BufferPointer1.MaxPacketSize = 
        EndpointParameters->MuxPacketSize;        
    // 1 = IN 0 = OUT        
    IsoTd->HwTD.BufferPointer1.Direction =
        (EndpointParameters->TransferDirection == In) ? 1 : 0;

    IsoTd->HwTD.BufferPointer2.Multi = 
        EndpointParameters->TransactionsPerMicroframe;        

}

#define EHCI_OFFSET_MASK    0x00000FFF
#define EHCI_PAGE_SHIFT     12

VOID
EHCI_MapHsIsoPacketsToTd(
    PDEVICE_DATA DeviceData, 
    PENDPOINT_DATA EndpointData,
    PMINIPORT_ISO_PACKET FirstPacket,
    PHCD_HSISO_TRANSFER_DESCRIPTOR IsoTd,
    BOOLEAN InterruptOnComplete
    )
/*++

Routine Description:

    

Arguments:

Returns:
    
--*/
{
    PHC_ITD_BUFFER_POINTER currentBp;
    PMINIPORT_ISO_PACKET pkt = FirstPacket;
    ULONG page, offset, bpCount, i;
    ULONG frame = FirstPacket->FrameNumber;

    LOGENTRY(DeviceData, G, '_HHS', IsoTd, 0, FirstPacket); 
    ASSERT_ITD(DeviceData, IsoTd);
    
    bpCount = 0;
    currentBp = (PHC_ITD_BUFFER_POINTER) &IsoTd->HwTD.BufferPointer0;

    // map the first packet
    page = (pkt->BufferPointer0.Hw32 >> EHCI_PAGE_SHIFT);
    currentBp->BufferPointer = page;
    
    // This Td will represent 8 packets
    for (i=0; i<8; i++) {

        EHCI_ASSERT(DeviceData, pkt->FrameNumber == frame);
        
        page = (pkt->BufferPointer0.Hw32 >> EHCI_PAGE_SHIFT);
        offset = pkt->BufferPointer0.Hw32 & EHCI_OFFSET_MASK;

        if (page != currentBp->BufferPointer) {
            currentBp++;
            bpCount++;
            currentBp->BufferPointer = page;
        }
        
        IsoTd->HwTD.Transaction[i].Offset = offset;
        IsoTd->HwTD.Transaction[i].Length = pkt->Length;
        IsoTd->HwTD.Transaction[i].PageSelect = bpCount;
        if (InterruptOnComplete && i==7) {
            IsoTd->HwTD.Transaction[i].InterruptOnComplete = 1;
        } else {
            IsoTd->HwTD.Transaction[i].InterruptOnComplete = 0;
        }
        IsoTd->HwTD.Transaction[i].Active = 1;

        if (pkt->BufferPointerCount > 1) {
            page = (pkt->BufferPointer1.Hw32 >> EHCI_PAGE_SHIFT);
            currentBp++;
            bpCount++;
            currentBp->BufferPointer = page;
            EHCI_ASSERT(DeviceData, bpCount <= 6)
        }

        pkt++;
        
    }  

    LOGENTRY(DeviceData, G, '_mhs', IsoTd, 0, bpCount); 
}


VOID
EHCI_CompleteHsIsoPackets(
    PDEVICE_DATA DeviceData,
    PMINIPORT_ISO_PACKET FirstPacket,
    PHCD_HSISO_TRANSFER_DESCRIPTOR IsoTd 
    )
/*++

Routine Description:

    Complete the eight high speed packets associated with this
    TD

Arguments:

Returns:
    
--*/
{
    ULONG length, i;
    ULONG cf = EHCI_Get32BitFrameNumber(DeviceData);
    PMINIPORT_ISO_PACKET pkt = FirstPacket;
    
    LOGENTRY(DeviceData, G, '_cpI', pkt, IsoTd, cf);

    for (i=0; i<8; i++) {
        if (IsoTd->HwTD.Transaction[i].Active == 1) {
            // missed 
            pkt->LengthTransferred = 0;    
            LOGENTRY(DeviceData, G, '_cms', 
                pkt, 
                i,
                pkt->FrameNumber);
            pkt->UsbdStatus = USBD_STATUS_ISO_NOT_ACCESSED_BY_HW;    
        } else {
            // if this is an out assume all data transferred
            if (IsoTd->HwTD.BufferPointer1.Direction == 0) {
                // out
                length = pkt->Length;
                LOGENTRY(DeviceData, G, '_cp3', 
                    pkt->FrameNumber, 
                    pkt->Length ,
                    pkt);
            } else {
                // in
                length = IsoTd->HwTD.Transaction[i].Length;
                LOGENTRY(DeviceData, G, '_cp4', 
                    pkt->FrameNumber, 
                    pkt->Length ,
                    pkt);
            }
            
            pkt->LengthTransferred = length;

            // check the errubit
        
            if (IsoTd->HwTD.Transaction[i].XactError) {
                pkt->UsbdStatus = USBD_STATUS_XACT_ERROR;
                //TEST_TRAP();
            } else if (IsoTd->HwTD.Transaction[i].BabbleDetect) {
                pkt->UsbdStatus = USBD_STATUS_BABBLE_DETECTED;
            } else if (IsoTd->HwTD.Transaction[i].DataBufferError) {
                pkt->UsbdStatus = USBD_STATUS_DATA_BUFFER_ERROR;
            } else {
                pkt->UsbdStatus = USBD_STATUS_SUCCESS;
            }                
            LOGENTRY(DeviceData, G, '_cpL', pkt, IsoTd, length);

            pkt++;
        }            
    }
}         


USB_MINIPORT_STATUS
EHCI_OpenHsIsochronousEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    ULONG i;
    ULONG bytes;
    PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    PENDPOINT_DATA prevEndpoint, nextEndpoint;
    
    LOGENTRY(DeviceData, G, '_opS', 0, 0, EndpointParameters);
    
    
    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
   
    // how much did we get
    bytes = EndpointParameters->CommonBufferBytes;
    
    EndpointData->HsIsoTdList = (PHCD_HSISOTD_LIST) buffer;
    // bugbug use manifest
    EndpointData->TdCount = USBEHCI_MAX_FRAME;
    EndpointData->LastFrame = 0;
    
    for (i=0; i<EndpointData->TdCount; i++) {
        
        EHCI_Initialize_iTD(DeviceData,
                            EndpointData,
                            EndpointParameters,                                
                            &EndpointData->HsIsoTdList->Td[i],
                            phys, 
                            i);                                         
                             
        phys += sizeof(HCD_HSISO_TRANSFER_DESCRIPTOR); 
        
    }

    // 
    if (DeviceData->IsoEndpointListHead == NULL) {
        // empty list, no iso endpoints
        prevEndpoint = NULL;
        nextEndpoint = NULL;
    } else {
        // currently we insert HS endpoints in front of split
        // iso endpoints, so for high speed we just stick them 
        // on the head of the list
        
        prevEndpoint = NULL;
        nextEndpoint = DeviceData->IsoEndpointListHead;
    }   

    // insert this column of TDs thru the schedule
    EHCI_InsertHsIsoTdsInSchedule(DeviceData, 
                                  EndpointData,
                                  prevEndpoint,
                                  nextEndpoint);

    // init endpoint structures
    InitializeListHead(&EndpointData->TransferList);

    EHCI_EnablePeriodicList(DeviceData);
    
    return USBMP_STATUS_SUCCESS;            
}


VOID
EHCI_RemoveHsIsoTdsFromSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData     
    )
/*++

Routine Description:

   unlink the iso TDs from the schedule

Arguments:


--*/
{   
    //PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    ULONG i;
    PENDPOINT_DATA prevEndpoint, nextEndpoint;     
    PHCD_QUEUEHEAD_DESCRIPTOR dQh;
   
    prevEndpoint = EndpointData->PrevEndpoint;
    nextEndpoint = EndpointData->NextEndpoint;

    LOGENTRY(DeviceData, G, '_iRM', prevEndpoint, 
        nextEndpoint, EndpointData);

    if (DeviceData->IsoEndpointListHead == EndpointData) {
        // this is the head
        
        //frameBase = DeviceData->FrameListBaseAddress;
        for (i=0; i<USBEHCI_MAX_FRAME; i++) {
        
            PHCD_HSISO_TRANSFER_DESCRIPTOR iTd;            
            ULONG phys;

            iTd = &EndpointData->HsIsoTdList->Td[i];
            phys = iTd->HwTD.NextLink.HwAddress;

            dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
            dQh->HwQH.HLink.HwAddress = phys; 

            dQh->NextLink = iTd->NextLink;
                         
            //*frameBase = phys;
            //frameBase++;
        }    

        DeviceData->IsoEndpointListHead = 
            EndpointData->NextEndpoint;

        if (nextEndpoint != NULL) {
            EHCI_ASSERT(DeviceData, 
                        nextEndpoint->PrevEndpoint == EndpointData);
            nextEndpoint->PrevEndpoint = NULL;            
        }            
    } else {
        // middle 
        TEST_TRAP();
        EHCI_ASSERT(DeviceData, HIGHSPEED(prevEndpoint));
        
        // link prev to next, prev will always be a HS ep
        prevEndpoint->NextEndpoint = nextEndpoint;
        if (nextEndpoint != NULL) {
            nextEndpoint->PrevEndpoint = prevEndpoint;
        }

        for (i=0; i<USBEHCI_MAX_FRAME; i++) {
        
            PHCD_HSISO_TRANSFER_DESCRIPTOR iTd, previTd;            
            ULONG phys;

            iTd = &EndpointData->HsIsoTdList->Td[i];
            previTd = &prevEndpoint->HsIsoTdList->Td[i];
            
            phys = iTd->HwTD.NextLink.HwAddress;
            previTd->HwTD.NextLink.HwAddress = phys;
        }    
        
    }        
}


VOID
EHCI_InsertHsIsoTdsInSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PENDPOINT_DATA PrevEndpointData,
    PENDPOINT_DATA NextEndpointData
    )
/*++

Routine Description:

   Insert an aync endpoint (queue head) 
   into the HW list

Arguments:


--*/
{   
    //PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    ULONG i;

    LOGENTRY(DeviceData, G, '_iAH', PrevEndpointData, 
        NextEndpointData, EndpointData);

    // always insert to head
    EHCI_ASSERT(DeviceData, PrevEndpointData == NULL);
    
    DeviceData->IsoEndpointListHead = EndpointData;
    EndpointData->PrevEndpoint = NULL;
    
    EndpointData->NextEndpoint = 
        NextEndpointData;
    if (NextEndpointData != NULL) {
        NextEndpointData->PrevEndpoint = EndpointData;
    }        
        
    //frameBase = DeviceData->FrameListBaseAddress;

    for (i=0; i<USBEHCI_MAX_FRAME; i++) {
    
        PHCD_HSISO_TRANSFER_DESCRIPTOR iTd, nextiTd, previTd;            
        HW_32BIT_PHYSICAL_ADDRESS qh;
        PHCD_QUEUEHEAD_DESCRIPTOR dQh;
        ULONG phys;

        iTd = &EndpointData->HsIsoTdList->Td[i];
        ASSERT_ITD(DeviceData, iTd);

        dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
        // fixup next link
        if (NextEndpointData == NULL) {
            // no iso endpoints, link to the interrupt 
            // queue heads via the dummy queue head
            // qh = *frameBase;
            qh = dQh->HwQH.HLink.HwAddress;
            iTd->HwTD.NextLink.HwAddress = qh; 
            iTd->NextLink = dQh->NextLink;
            
        } else {
            // link to the next iso endpoint 
    
            if (HIGHSPEED(NextEndpointData)) {
                PHCD_HSISO_TRANSFER_DESCRIPTOR tmp;
           
                tmp = &NextEndpointData->HsIsoTdList->Td[i];
                iTd->HwTD.NextLink.HwAddress = 
                    tmp->PhysicalAddress;
                HW_PTR(iTd->NextLink) = (PUCHAR) tmp;                    
            } else {
                PHCD_SI_TRANSFER_DESCRIPTOR tmp;
                ULONG phys;
                
                tmp = &NextEndpointData->SiTdList->Td[i%ISO_SCHEDULE_SIZE];
                phys = tmp->PhysicalAddress;
                SET_SITD(phys);
                
                iTd->HwTD.NextLink.HwAddress = phys;
                HW_PTR(iTd->NextLink) = (PUCHAR) tmp;                    
            }
            
        }

        // fixup prev link
        // since we always insert Hs iso on the head of the list 
        // prev endpoint should always be NULL
        EHCI_ASSERT(DeviceData, PrevEndpointData == NULL);
        phys = iTd->PhysicalAddress;

        // link dummy QH to this TD
        dQh->HwQH.HLink.HwAddress = phys;
        HW_PTR(dQh->NextLink) = (PUCHAR) iTd;
        
        //*frameBase = phys;
        //frameBase++;
        
        
    }    
}

#define     HSISO_SCHEDULE_MASK       0x3ff

VOID
EHCI_InternalPollHsIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    BOOLEAN Complete
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'
    

    static iso TD table
    --------------------
    0                       < -- (lastFrame & 0x3ff)
    1                       {completed} 
    2                       {completed}
    3                       {completed}
    4                       < -- (currentframe & 0x3ff)
    ...

    1023
    ---------------------


Arguments:

Return Value:

--*/

{
    ULONG x, i;
    ULONG currentFrame, lastFrame;
    PHCD_HSISO_TRANSFER_DESCRIPTOR iTd;
    PHCD_HSISO_TRANSFER_DESCRIPTOR lastiTd;
    PMINIPORT_ISO_PACKET packet;
    PLIST_ENTRY listEntry;
    PTRANSFER_CONTEXT transfer;
    
    currentFrame = EHCI_Get32BitFrameNumber(DeviceData);
    lastFrame = EndpointData->LastFrame;

    LOGENTRY(DeviceData, G, '_pis', lastFrame, currentFrame, 
        EndpointData);

    if (currentFrame - lastFrame > USBEHCI_MAX_FRAME) {
        // overrun
        lastFrame = currentFrame-1;
        LOGENTRY(DeviceData, G, '_ov1', lastFrame, currentFrame, 0); 

        // dump the current contents
        for (i=0; i <USBEHCI_MAX_FRAME; i++) {

            iTd = &EndpointData->HsIsoTdList->Td[i];

            transfer = ISO_TRANSFER_PTR(iTd->Transfer);

            if (transfer != NULL) {
                ISO_PACKET_PTR(iTd->FirstPacket) = NULL;
                ISO_TRANSFER_PTR(iTd->Transfer) = NULL;
                transfer->PendingPackets-=8;
            }     
        }   
    }

    if (lastFrame == currentFrame) {
        // too early to do anything
        LOGENTRY(DeviceData, G, '_ear', lastFrame, currentFrame, 0); 
        return;
    }

    // TDs between lastframe and currentframe are complete, 
    // complete the packets associated with them


//    f0
//    f1 
//    f2  < ------- last frame   }
//    f3                         }  these are complete
//    f4                         }
//    f5  < ------- current frame       
//    f6
//    f7
//    f8

    x = (lastFrame & (HSISO_SCHEDULE_MASK));

    lastiTd = NULL;
    
    LOGENTRY(DeviceData, G, '_frh', lastFrame, x, currentFrame); 
    while (x != ((currentFrame-1) & HSISO_SCHEDULE_MASK)) {
        iTd = &EndpointData->HsIsoTdList->Td[x];

        ASSERT_ITD(DeviceData, iTd);
        // complete this packet
        packet = ISO_PACKET_PTR(iTd->FirstPacket);
        transfer = ISO_TRANSFER_PTR(iTd->Transfer);
        LOGENTRY(DeviceData, G, '_gpk', transfer, packet, x); 
        
        if (packet != NULL) {
            transfer = ISO_TRANSFER_PTR(iTd->Transfer);    
            ASSERT_TRANSFER(DeviceData, transfer);
            EHCI_CompleteHsIsoPackets(DeviceData, packet, iTd);
            ISO_PACKET_PTR(iTd->FirstPacket) = NULL;
            ISO_TRANSFER_PTR(iTd->Transfer) = NULL;
            transfer->PendingPackets-=8;
        }            
        
        lastFrame++;
        x++;
        x &= HSISO_SCHEDULE_MASK;
    } 

    // attempt to program what we can, if iTD is NULL 
    // then we can program this frame
    // NOTE: No scheduling if paused!
    if (EndpointData->State != ENDPOINT_PAUSE) {
        LOGENTRY(DeviceData, G, '_psh', 0, 0, 0); 
       
        for (i=0; i <USBEHCI_MAX_FRAME; i++) {

            x = ((currentFrame+i) & HSISO_SCHEDULE_MASK);

            iTd = &EndpointData->HsIsoTdList->Td[x];
            ASSERT_ITD(DeviceData, iTd);

            LOGENTRY(DeviceData, G, '_gpf', iTd, x, currentFrame+i); 

            // open slot?
            if (ISO_PACKET_PTR(iTd->FirstPacket) != NULL) {   
                // no, bail
                continue;
            }
                
            // yes, see if we have a packet
            // this will fetch the first packet to transmit this frame
            packet = EHCI_GetPacketForFrame(DeviceData,
                                            EndpointData,
                                            &transfer,
                                            currentFrame+i);

            if (packet != NULL) {
                BOOLEAN ioc = FALSE;
                ULONG sf, ef;
                
                EHCI_ASSERT(DeviceData, ISO_PACKET_PTR(iTd->FirstPacket) == NULL);         
                if ((currentFrame+i) == transfer->FrameComplete) {
                    ioc = TRUE;
                }

                sf = transfer->FrameComplete - 
                    transfer->IsoTransfer->PacketCount +5;

                ef = transfer->FrameComplete -5;

                // generate some interrupts on the first few frames of the
                // transfer to help flush out any previous transfers
                if (currentFrame+i <= sf ||
                    currentFrame+i >= ef) {
                    ioc = TRUE;
                }
//interrupt every frame                
//ioc = TRUE;
                //if ((currentFrame % 2) == 0) {
                //    ioc = TRUE;
                //}
                // map 8 microframes
                EHCI_MapHsIsoPacketsToTd(DeviceData, EndpointData, 
                    packet, iTd, ioc);
                lastiTd = iTd;                    
                ISO_PACKET_PTR(iTd->FirstPacket) = packet;
                ASSERT_TRANSFER(DeviceData, transfer);
                ISO_TRANSFER_PTR(iTd->Transfer) = transfer;
                transfer->PendingPackets+=8;
            } else {
                ULONG j;
                // re-init itd
                for (j=0; j<8; j++) {
                    iTd->HwTD.Transaction[j].InterruptOnComplete = 0;
                }                    
            }
        }

        // take a interrupt on the last TD programmed
        if (lastiTd != NULL) {
            lastiTd->HwTD.Transaction[7].InterruptOnComplete = 1;
        }
    }

    EHCI_ASSERT(DeviceData, lastFrame < currentFrame);
    EndpointData->LastFrame = lastFrame;
    
    // walk our list of active iso transfers and see 
    // if any are complete
//restart:    
    listEntry = EndpointData->TransferList.Flink;
    while (listEntry != &EndpointData->TransferList && Complete) {
        PTRANSFER_CONTEXT transfer;
        
        transfer = (PTRANSFER_CONTEXT) CONTAINING_RECORD(
                     listEntry,
                     struct _TRANSFER_CONTEXT, 
                     TransferLink);

        LOGENTRY(DeviceData, G, '_ckt', transfer, transfer->FrameComplete+2
            , currentFrame);

        EHCI_ASSERT(DeviceData, transfer->Sig == SIG_EHCI_TRANSFER);
        if (currentFrame >= transfer->FrameComplete &&
            transfer->PendingPackets == 0) {

            listEntry = transfer->TransferLink.Flink;                
            RemoveEntryList(&transfer->TransferLink); 
            LOGENTRY(DeviceData, G, '_cpi', transfer, 0, 0);

            USBPORT_COMPLETE_ISO_TRANSFER(DeviceData,
                                          EndpointData,
                                          transfer->TransferParameters,
                                          transfer->IsoTransfer);
        } else {
            listEntry = transfer->TransferLink.Flink;              
        }            
    }
}


USB_MINIPORT_STATUS
EHCI_PokeIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{   
    ULONG i;
    
    if (HIGHSPEED(EndpointData)) {
        TEST_TRAP();
    } else {
        PHCD_SI_TRANSFER_DESCRIPTOR siTd;
        
        for (i=0; i<EndpointData->TdCount; i++) {

            siTd = &EndpointData->SiTdList->Td[i];
            ASSERT_SITD(DeviceData, siTd);
            
            siTd->HwTD.Caps.DeviceAddress = 
                EndpointParameters->DeviceAddress;
            siTd->HwTD.Caps.HubAddress = 
                EndpointParameters->TtDeviceAddress;

        }                
    }
    return USBMP_STATUS_SUCCESS;        
}


PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_GetDummyQueueHeadForFrame(
    PDEVICE_DATA DeviceData,
    ULONG Frame
    )
/*++

Routine Description:

Arguments:

Return Value:

    queue head

--*/
{
    PUCHAR base;

    base = DeviceData->DummyQueueHeads;

    return (PHCD_QUEUEHEAD_DESCRIPTOR)
        (base + sizeof(HCD_QUEUEHEAD_DESCRIPTOR) * Frame);
}


VOID
EHCI_AddDummyQueueHeads(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    NEC errata:
    
    Insert a table of 1024 dummy queue heads in the schedule for 
    HW to access and point them at the interrupt queue heads.
    
    These queue heads must be before any iso TDs
    
    This is a workaround for a law ine the NEC B0' stepping version 
    of the controller.  We must put 'dummy' QH at the front of the 
    peridoic list such that the first thing fetched is always a QH
    even when ISO TDs are in the schedule.
    
Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR dQh, stqh;
    HW_32BIT_PHYSICAL_ADDRESS qhPhys;
    PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    ULONG i;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    
    frameBase = DeviceData->FrameListBaseAddress;

    phys = DeviceData->DummyQueueHeadsPhys;
     
    for (i=0; i<USBEHCI_MAX_FRAME; i++) {
    
        // no iso endpoints should be in the schedule yet
        qhPhys = *frameBase;
        dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);

        // init the dummy queue head
        
        RtlZeroMemory(dQh, sizeof(*dQh));
        dQh->PhysicalAddress = phys;
        dQh->Sig = SIG_DUMMY_QH;
        
        dQh->HwQH.EpChars.DeviceAddress = 128;
        dQh->HwQH.EpChars.EndpointNumber = 0;
        dQh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_FullSpeed;
        dQh->HwQH.EpChars.MaximumPacketLength = 64;

        dQh->HwQH.EpCaps.InterruptScheduleMask = 0;
        dQh->HwQH.EpCaps.SplitCompletionMask = 0;
        dQh->HwQH.EpCaps.HubAddress = 0;
        dQh->HwQH.EpCaps.PortNumber = 0;             
        dQh->HwQH.EpCaps.HighBWPipeMultiplier = 0;   

        dQh->HwQH.CurrentTD.HwAddress = 0;

        dQh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;    
        dQh->HwQH.Overlay.qTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT; 
        dQh->HwQH.Overlay.qTD.Token.Active = 0;
        
        phys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

        // link dummy to first interrupt queue head
        dQh->HwQH.HLink.HwAddress = qhPhys;
        stqh = EHCI_GetQueueHeadForFrame(DeviceData, i);
        EHCI_ASSERT(DeviceData, (qhPhys & ~EHCI_DTYPE_Mask) == 
            stqh->PhysicalAddress);
        
        HW_PTR(dQh->NextLink) = (PUCHAR)stqh;

        // add dummy queue head to frame list
        qhPhys = dQh->PhysicalAddress;
        
        SET_QH(qhPhys);
        *frameBase = qhPhys;

        frameBase++;
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\roothub.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

   roothub.c

Abstract:

   miniport root hub

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    1-1-00 : created, jdunn

implements the following miniport functions:

MINIPORT_RH_GetStatus
MINIPORT_RH_GetPortStatus
MINIPORT_RH_GethubStatus

MINIPORT_RH_SetFeaturePortReset
MINIPORT_RH_SetFeaturePortSuspend
MINIPORT_RH_SetFeaturePortPower

MINIPORT_RH_ClearFeaturePortEnable
MINIPORT_RH_ClearFeaturePortSuspend
MINIPORT_RH_ClearFeaturePortPower

MINIPORT_RH_ClearFeaturePortConnectChange
MINIPORT_RH_ClearFeaturePortResetChange
MINIPORT_RH_ClearFeaturePortEnableChange
MINIPORT_RH_ClearFeaturePortSuspendChange
MINIPORT_RH_ClearFeaturePortOvercurrentChange


--*/

#include "common.h"

#include "usbpriv.h"


typedef struct _EHCI_PORT_EVENT_CONTEXT {
    USHORT PortNumber;
} EHCI_PORT_EVENT_CONTEXT, *PEHCI_PORT_EVENT_CONTEXT;


VOID
EHCI_RH_GetRootHubData(
     PDEVICE_DATA DeviceData,
    OUT PROOTHUB_DATA HubData
    )
/*++
    return info about the root hub
--*/
{
    HubData->NumberOfPorts =
        DeviceData->NumberOfPorts;

    if (DeviceData->PortPowerControl == 1) {
        HubData->HubCharacteristics.PowerSwitchType =
            USBPORT_RH_POWER_SWITCH_PORT;
    } else {
        HubData->HubCharacteristics.PowerSwitchType =
            USBPORT_RH_POWER_SWITCH_GANG;
    }

    HubData->HubCharacteristics.Reserved = 0;
    HubData->HubCharacteristics.OverCurrentProtection = 0;
    HubData->HubCharacteristics.CompoundDevice = 0;

    HubData->PowerOnToPowerGood = 2;
    // this value is the current consumed by the hub
    // brains, for the embeded hub this doesn't make
    // much sense.
    //
    // so we report zero
    HubData->HubControlCurrent = 0;

    LOGENTRY(DeviceData, G, '_hub', HubData->NumberOfPorts,
        DeviceData->PortPowerControl, 0);

}


USB_MINIPORT_STATUS
EHCI_RH_GetStatus(
     PDEVICE_DATA DeviceData,
    OUT PUSHORT Status
    )
/*++
    get the device status
--*/
{
    // the root hub is self powered
    *Status = USB_GETSTATUS_SELF_POWERED;

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortEnable (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    EHCI_KdPrint((DeviceData, 0, "port[%d] disable (1) %x\n", PortNumber, port.ul));

    port.PortEnable = 0;
    MASK_CHANGE_BITS(port);
    
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
                         port.ul); 
    
    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortPower (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    // turn power off

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);

    port.PortPower = 0;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
        port.ul);

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_RH_PortResumeComplete(
    PDEVICE_DATA DeviceData,
    PVOID Context
    )
/*++
    complete a port resume
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    PEHCI_PORT_EVENT_CONTEXT portResumeContext = Context;
    USHORT portNumber;

    hcOp = DeviceData->OperationalRegisters;
    portNumber = portResumeContext->PortNumber;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
    LOGENTRY(DeviceData, G, '_pRS', port.ul,
        DeviceData->PortSuspendChange, portNumber);

EHCI_KdPrint((DeviceData, 1, "port[%d] resume (1) %x\n", portNumber, port.ul));

    // writing a 0 stops resume
    MASK_CHANGE_BITS(port);
    port.ForcePortResume = 0;
    port.PortSuspend = 0;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul,
        port.ul);

    // indicate a change to suspend state ie resume complete
    SET_BIT(DeviceData->PortSuspendChange, portNumber-1);
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortSuspend (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    EHCI_PORT_EVENT_CONTEXT portResumeContext;

    // resume the port
    hcOp = DeviceData->OperationalRegisters;

    // mask off CC chirping on this port
    SET_BIT(DeviceData->PortPMChirp, PortNumber-1);

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);

    // writing a 1 generates resume signalling
    port.ForcePortResume = 1;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
        port.ul);

    // time it
    portResumeContext.PortNumber = PortNumber;
    // some hubs require us to wait longer if the downstream
    // device drivers resume for > 10 ms.  Looks like we need
    // 50 for the NEC B1 hub.
    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   50, // callback in ms,
                                   &portResumeContext,
                                   sizeof(portResumeContext),
                                   EHCI_RH_PortResumeComplete);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortSuspendChange (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    CLEAR_BIT(DeviceData->PortSuspendChange, PortNumber-1);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortOvercurrentChange (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    EHCI_KdPrint((DeviceData, 1,
                  "'EHCI_RH_ClearFeatureOvercurrentChange\n"));

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);

    MASK_CHANGE_BITS(port);
    port.OvercurrentChange = 1;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
        port.ul);

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
EHCI_RH_GetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    )
/*++
    get the status of a partuclar port
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    portStatus->ul = 0;
    LOGENTRY(DeviceData, G, '_Pp1', PortNumber, port.ul, 0);

    // low speed detect, if low speed then do an immediate
    // handoff to the CC
    // This field is only valid if enable status is 0 and 
    // connect status is 1
    if ((port.LineStatus == 1) &&
         port.PortOwnedByCC == 0 &&
         port.PortSuspend == 0 && 
         port.PortEnable == 0 &&
         port.PortConnect == 1 &&
        !CC_DISABLED(DeviceData)) {

        EHCI_KdPrint((DeviceData, 1, "'low speed device detected\n"));

        // low speed device detected
        port.PortOwnedByCC = 1;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
                             port.ul);

        return USBMP_STATUS_SUCCESS;
    }

    // map the bits to the port status structure

    portStatus->Connected =
        port.PortConnect;
    portStatus->Enabled =
        port.PortEnable;
    portStatus->Suspended =
        port.PortSuspend;
    portStatus->OverCurrent =
        port.OvercurrentActive;
    portStatus->Reset =
        port.PortReset;
    portStatus->PowerOn =
        port.PortPower;
    portStatus->OwnedByCC =
        port.PortOwnedByCC;


    if (portStatus->Connected == 1) {
        portStatus->HighSpeed = 1;
        portStatus->LowSpeed = 0;
    } else {
        // report high speed when no device connected
        // this should work around a bug in the usbhub
        // driver -- the hub driver does not refresh the
        // port status register if the first reset attempt
        // fails.
        portStatus->HighSpeed = 1;
    }

    // chirping support allows us to use the
    // port change status bit
    if (port.PortConnectChange == 1) {
        SET_BIT(DeviceData->PortConnectChange, PortNumber-1);
    }

    portStatus->EnableChange =
        port.PortEnableChange;
    portStatus->OverCurrentChange =
        port.OvercurrentChange;

    // these change bits must be emulated
    if (TEST_BIT(DeviceData->PortResetChange, PortNumber-1)) {
        portStatus->ResetChange = 1;
    }

    if (TEST_BIT(DeviceData->PortConnectChange, PortNumber-1)) {
        portStatus->ConnectChange = 1;
    }

    if (TEST_BIT(DeviceData->PortSuspendChange, PortNumber-1)) {
        portStatus->SuspendChange = 1;
    }

    LOGENTRY(DeviceData, G, '_gps',
        PortNumber, portStatus->ul, port.ul);

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_RH_FinishReset(
    PDEVICE_DATA DeviceData,
    PVOID Context
    )
/*++
    complete a port reset
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    PEHCI_PORT_EVENT_CONTEXT portResetContext = Context;
    USHORT portNumber;
    ULONG NecUsb2HubHack = 0;

    hcOp = DeviceData->OperationalRegisters;
    portNumber = portResetContext->PortNumber;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
    EHCI_KdPrint((DeviceData, 0, "port[%d] reset (4) %x\n", portNumber, port.ul));

    if (port.ul == 0xFFFFFFFF) {
        // just bail if hardware disappears
        return;
    }
    
    // at this point we will know if this is a high speed
    // device -- if it is not then we need to hand the port
    // to the CC

    // port enable of zero means we have a full or low speed
    // device (ie not chirping).
#if DBG
    if (port.PortConnect == 0) {
        EHCI_KdPrint((DeviceData, 0, "HS device dropped\n"));
    }        
#endif
    if (port.PortEnable == 0 && 
        port.PortConnect == 1 &&
        port.PortConnectChange == 0) {

        // do the handoff
        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
        port.PortOwnedByCC = 1;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul,
                             port.ul);

        // do not indicate a reset change, this will cause the
        // hub driver to timeout the reset and detect that
        // no device is connected.  when this occurs on a USB 2
        // controller the hub driver will ignore the error.
        //CLEAR_BIT(DeviceData->PortResetChange, portNumber-1);
        SET_BIT(DeviceData->PortResetChange, portNumber-1);
    } else {
        // we have a USB 2.0 device, indicate the reset change
        // NOTE if the device dropped off the bus (NEC USB 2 hub or 
        // user removed it) we still indicate a reset change on high 
        // speed
        SET_BIT(DeviceData->PortResetChange, portNumber-1);
        USBPORT_INVALIDATE_ROOTHUB(DeviceData);
    }

    CLEAR_BIT(DeviceData->PortPMChirp, portNumber-1);  

}


VOID
EHCI_RH_PortResetComplete(
    PDEVICE_DATA DeviceData,
    PVOID Context
    )
/*++
    complete a port reset
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    PEHCI_PORT_EVENT_CONTEXT portResetContext = Context;
    USHORT portNumber;
    BOOLEAN forceHighSpeed = FALSE;
    ULONG microsecs;
    
    hcOp = DeviceData->OperationalRegisters;
    portNumber = portResetContext->PortNumber;

EHCI_RH_PortResetComplete_Retry:

    microsecs = 0;
    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
    LOGENTRY(DeviceData, G, '_prC', port.ul,
        DeviceData->PortResetChange, portNumber);

EHCI_KdPrint((DeviceData, 0, "port[%d] reset (1) %x\n", portNumber, port.ul));

    // writing a 0 stops reset
    MASK_CHANGE_BITS(port);
    port.PortReset = 0;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul,
                         port.ul);

    // wait for reset to go low -- this should be on the order of
    // microseconds
    do {    
    
        KeStallExecutionProcessor(20);        // spec says 10 microseconds
                                              // Intel controller needs 20
        microsecs+=20;                                              
        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
        EHCI_KdPrint((DeviceData, 1, "port[%d] reset (2) %x\n", 
            portNumber, port.ul));

        if (microsecs > USBEHCI_MAX_RESET_TIME) {
            // > 1 microframe (125 us) has passed, retry
            EHCI_KdPrint((DeviceData, 0, "port[%d] reset (timeout) %x\n", portNumber, port.ul));
            goto EHCI_RH_PortResetComplete_Retry;
        }

      // bail if HW is gone
    } while (port.PortReset == 1 && port.ul != 0xFFFFFFFF);

EHCI_KdPrint((DeviceData, 0, "port[%d] reset (3) %x\n", portNumber, port.ul));

    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   50, // callback in 10 ms,
                                   portResetContext,
                                   sizeof(*portResetContext),
                                   EHCI_RH_FinishReset);

}


USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in reset
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    EHCI_PORT_EVENT_CONTEXT portResetContext;

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    LOGENTRY(DeviceData, G, '_spr', port.ul,
        0, PortNumber);

    // mask off CC chirping on this port
    SET_BIT(DeviceData->PortPMChirp, PortNumber-1);

    // do a normal reset sequence
    LOGENTRY(DeviceData, G, '_res', port.ul, 0, PortNumber);
    MASK_CHANGE_BITS(port);
    port.PortEnable = 0;
    port.PortReset = 1;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul, port.ul);

    // schedule a callback
    portResetContext.PortNumber = PortNumber;
    // note that usbport calls us back with a copy of this
    // structure not the pointer to the original structure

    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   50, // callback in x ms,
                                   &portResetContext,
                                   sizeof(portResetContext),
                                   EHCI_RH_PortResetComplete);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in suspend
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    // NOTE:
    // there should be no transactions in progress at the
    // time we suspend the port.
    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    LOGENTRY(DeviceData, G, '_sps', port.ul,
        0, PortNumber);

    // writing a 1 suspends the port
    MASK_CHANGE_BITS(port);
    port.PortSuspend = 1;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
        port.ul);
    // wiat 1 microframe for current transaction to finish
    KeStallExecutionProcessor(125);  

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    LOGENTRY(DeviceData, G, '_spp', port.ul,
        0, PortNumber);

    // writing a 1 turns on power
    MASK_CHANGE_BITS(port);
    port.PortPower = 1;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
        port.ul);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    // do nothing, independent enable not supported

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    //
    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    LOGENTRY(DeviceData, G, '_pcc', port.ul,
        0, PortNumber);

    // writing a 1 zeros the change bit
    if (port.PortConnectChange == 1) {
        // mask off other change bits
        MASK_CHANGE_BITS(port);
        port.PortConnectChange = 1;

        WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
            port.ul);
    }

    CLEAR_BIT(DeviceData->PortConnectChange, PortNumber-1);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    LOGENTRY(DeviceData, G, '_cpe', PortNumber, 0, 0);

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    MASK_CHANGE_BITS(port);
    port.PortEnableChange = 1;

    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul, port.ul);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_GetHubStatus(
     PDEVICE_DATA DeviceData,
    OUT PRH_HUB_STATUS HubStatus
    )
/*++
--*/
{
    // nothing intersting for the root
    // hub to report
    HubStatus->ul = 0;

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{

    CLEAR_BIT(DeviceData->PortResetChange, PortNumber-1);

    return USBMP_STATUS_SUCCESS;
}



VOID
EHCI_OptumtuseratePort(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Forces the port to high speed mode.

    NOTE:
    Current mechanism only works on the NEC controller.

--*/
{
      PHC_OPERATIONAL_REGISTER hcOp;
      PORTSC port;

      LOGENTRY(DeviceData, G, '_obt', PortNumber, 0, 0);

      hcOp = DeviceData->OperationalRegisters;

      port.ul = 0x5100a;

      WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
         port.ul);

      KeStallExecutionProcessor(10);        //stall for 10 microseconds

      // force high speed mode on the port
      port.ul = 0x01005;

      WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
          port.ul);

      KeStallExecutionProcessor(100);        //stall for 10 microseconds

}

USB_MINIPORT_STATUS
EHCI_RH_UsbprivRootPortStatus(
    PDEVICE_DATA DeviceData,
    ULONG ParameterLength,
    PVOID Parameters
    )
{

    PUSBPRIV_ROOTPORT_STATUS portStatusParams;
    PHC_OPERATIONAL_REGISTER hcOp;
    PRH_PORT_STATUS portStatus;
    PORTSC port;
    USHORT portNumber;

    if (ParameterLength < sizeof(USBPRIV_ROOTPORT_STATUS))
    {
        return (USBMP_STATUS_FAILURE);
    }

    //
    // Read the port status for this port from the registers
    //

    hcOp = DeviceData->OperationalRegisters;

    portStatusParams = (PUSBPRIV_ROOTPORT_STATUS) Parameters;

    portNumber = portStatusParams->PortNumber;
    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);

    LOGENTRY(DeviceData, G, '_Up1', portNumber, port.ul, 0);

    //
    // Check to see if the port is resuming.  If so, clear the bit and
    //  reenable the port.
    //

    if (port.ForcePortResume)
    {
        //
        // Clear the port resume
        //

        USBPORT_WAIT(DeviceData, 50);

        MASK_CHANGE_BITS(port);
        port.ForcePortResume = 0;
        port.PortSuspend = 0;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul, port.ul);

        //
        // Reread the port status
        //

        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);

        SET_BIT(DeviceData->PortSuspendChange, portNumber-1);

        LOGENTRY(DeviceData, G, '_Up2', portNumber, port.ul, 0);
    }

    //
    // Map the current port information to the port status
    //

    portStatus = &portStatusParams->PortStatus;

    portStatus->ul = 0;
    portStatus->Connected =
        port.PortConnect;
    portStatus->Enabled =
        port.PortEnable;
    portStatus->Suspended =
        port.PortSuspend;
    portStatus->OverCurrent =
        port.OvercurrentActive;
    portStatus->Reset =
        port.PortReset;
    portStatus->PowerOn =
        port.PortPower;
    portStatus->OwnedByCC =
        port.PortOwnedByCC;

    if (portStatus->Connected == 1) {
        portStatus->HighSpeed = 1;
        portStatus->LowSpeed = 0;
    } else {
        // report high speed when no device connected
        // this should work around a bug in the usbhub
        // driver -- the hub driver does not refresh the
        // port status register if the first reset attempt
        // fails.
        portStatus->HighSpeed = 1;
    }

    portStatus->ConnectChange =
        port.PortConnectChange;
    portStatus->EnableChange =
        port.PortEnableChange;
    portStatus->OverCurrentChange =
        port.OvercurrentChange;

    // these change bits must be emulated
    if (TEST_BIT(DeviceData->PortResetChange, portNumber-1)) {
        portStatus->ResetChange = 1;
    }

    if (TEST_BIT(DeviceData->PortConnectChange, portNumber-1)) {
        portStatus->ConnectChange = 1;
    }

    if (TEST_BIT(DeviceData->PortSuspendChange, portNumber-1)) {
        portStatus->SuspendChange = 1;
    }

    LOGENTRY(DeviceData, G, '_Ups',
        portNumber, portStatus->ul, port.ul);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ChirpRootPort(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    EHCI_PORT_EVENT_CONTEXT portResetContext;
    ULONG mics;
    
    hcOp = DeviceData->OperationalRegisters;

#if DBG
    {
    USBCMD cmd;
    
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    
    EHCI_ASSERT(DeviceData, cmd.HostControllerRun == 1);
    }
#endif

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    LOGENTRY(DeviceData, G, '_chr', port.ul,
        0, PortNumber);

    EHCI_KdPrint((DeviceData, 0, ">port[%d] chirp %x\n", PortNumber, port.ul));

    if (TEST_BIT(DeviceData->PortPMChirp, PortNumber-1)) {
        // skip the chirp if we have already done this
        EHCI_KdPrint((DeviceData, 0, "<skip port chirp[%d] %x\n", PortNumber, port.ul));
        return USBMP_STATUS_SUCCESS; 
    }

    if (!port.PortPower) {
        // skip if not powered, this will cause us to 
        // bypass the chirp if the controller has not initialized
        // such as in the case of BOOT
        EHCI_KdPrint((DeviceData, 0, "<skip port chirp[%d] %x, no power\n", PortNumber, port.ul));
        return USBMP_STATUS_SUCCESS; 
    }     
    
    // port is connect and not enabled and not owned by CC 
    // therefore we should probably chirp it
    if (port.PortConnect && 
        !port.PortEnable && 
        !port.PortOwnedByCC) {

        //TEST_TRAP();
        // quick check for handoff of LS devices
        if ((port.LineStatus == 1) &&
             port.PortOwnedByCC == 0 &&
             port.PortSuspend == 0 && 
             port.PortEnable == 0 &&
             port.PortConnect == 1 ) {

            // low speed device detected
            port.PortOwnedByCC = 1;
            WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
                                 port.ul);
            EHCI_KdPrint((DeviceData, 1, ">port chirp[%d] %x, ->cc(1)\n", PortNumber, 
                        port.ul));
            return USBMP_STATUS_SUCCESS;
        }
        
        // do a normal reset sequence
        LOGENTRY(DeviceData, G, '_rss', port.ul, 0, PortNumber);

        // set reset and clear connect change
        port.PortEnable = 0;
        port.PortReset = 1;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul, port.ul);

        USBPORT_WAIT(DeviceData, 10);

EHCI_RH_ChirpRootPort_Retry:    

        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
        MASK_CHANGE_BITS(port);
        port.PortReset = 0;
        mics = 0;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul, port.ul);
                          
        // wait for reset to go low -- this should be on the order of
        // microseconds
        do {    
            // writing a 0 stops reset
            KeStallExecutionProcessor(20);        // spec says 10 microseconds
                                                  // Intel controller needs 20
            mics +=20;                                                  
            port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
            EHCI_KdPrint((DeviceData, 1, "port reset (2) %x\n", port.ul));

            if (mics > USBEHCI_MAX_RESET_TIME) {
                // reset did not clear in 1 microframe, try again to clear it
                goto EHCI_RH_ChirpRootPort_Retry;
            }
        } while (port.PortReset == 1);

        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
        
        if (port.PortEnable == 0) {

            // do the handoff
            port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
            port.PortOwnedByCC = 1;
            WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
                                 port.ul);
                              
            EHCI_KdPrint((DeviceData, 0, "<port chirp[%d] %x, ->cc(2)\n", PortNumber, 
                        port.ul));
        } else {
            // clear the enable bit so the device does not listen 
            // on address 0
            port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
            port.PortEnable = 0;
            MASK_CHANGE_BITS(port);
            SET_BIT(DeviceData->PortPMChirp, PortNumber-1);         
            WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
                                 port.ul); 

            EHCI_KdPrint((DeviceData, 0, "<chirp port[%d] disable %x\n", 
                PortNumber, port.ul));
                      
        }
    } else {
         EHCI_KdPrint((DeviceData, 0, "<no port chirp[%d] %x\n", PortNumber, port.ul));
    }

    return USBMP_STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\sstool.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   async.c

Abstract:

   miniport transfer code for sstool (single step tool) interface

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    1-1-00 : created, jdunn

--*/

#include "common.h"

typedef struct _SS_PACKET_CONTEXT {
    MP_HW_POINTER    Qh;
    MP_HW_POINTER    Td;
    MP_HW_POINTER    Data;
    ULONG padTo8[2];
} SS_PACKET_CONTEXT, *PSS_PACKET_CONTEXT;

#define EHCI_TEST_TD_ALIGNMENT    256

C_ASSERT((sizeof(SS_PACKET_CONTEXT) <= EHCI_TEST_TD_ALIGNMENT));
C_ASSERT((sizeof(HCD_QUEUEHEAD_DESCRIPTOR) <= EHCI_TEST_TD_ALIGNMENT));
C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) <= EHCI_TEST_TD_ALIGNMENT));


//implements the following miniport functions:

//non paged
//EHCI_StartSendOnePacket
//EHCI_EndSendOnePacket

USB_MINIPORT_STATUS
USBMPFN
EHCI_StartSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     OUT USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

    insert structures to transmit a single packet -- this is for debug
    tool purposes only so we can be a little creative here.

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHCD_TRANSFER_DESCRIPTOR td;
    PUCHAR pch, data;
    PSS_PACKET_CONTEXT context;
    HW_LINK_POINTER hwQh, tdLink;
    ULONG phys, qhPhys, tdPhys, dataPhys, i;
    ULONG siz;

    hcOp = DeviceData->OperationalRegisters;
    
    // allocate an TD from the scratch space and 
    // initialize it
    phys = WorkspacePhysicalAddress;
    pch = WorkspaceVirtualAddress;

    LOGENTRY(DeviceData, G, '_ssS', phys, 0, pch); 

    // specify a TD alignment to work around HW bugs.
    siz = EHCI_TEST_TD_ALIGNMENT;
    
    context = (PSS_PACKET_CONTEXT) pch;
    pch += siz;
    phys += siz;

    // carve out a qh
    qhPhys = phys;
    qh = (PHCD_QUEUEHEAD_DESCRIPTOR) pch;
    pch += siz;
    phys += siz;
    LOGENTRY(DeviceData, G, '_ssQ', qh, 0, qhPhys); 

    // carve out a TD
    tdPhys = phys;
    td = (PHCD_TRANSFER_DESCRIPTOR) pch;
    pch += siz;
    phys += siz;
    LOGENTRY(DeviceData, G, '_ssT', td, 0, tdPhys); 


    // use the rest for data
    LOGENTRY(DeviceData, G, '_ssD', PacketData, *PacketLength, 0); 

    dataPhys = phys;
    data = pch;
    RtlCopyMemory(data, PacketData, *PacketLength);
    pch+=*PacketLength;
    phys+=*PacketLength;

    // init qh
    RtlZeroMemory(qh, sizeof(*qh));
    qh->PhysicalAddress = qhPhys;
    ENDPOINT_DATA_PTR(qh->EndpointData) = NULL;
    qh->Sig = SIG_HCD_DQH;

    hwQh.HwAddress = qh->PhysicalAddress;
    SET_QH(hwQh.HwAddress);
    
    //qh->HwQH.EpChars.HeadOfReclimationList = 1;

    // manual Toggle
    qh->HwQH.EpChars.DataToggleControl = HcEPCHAR_Toggle_From_qTD;
    
    // init the hw descriptor
    qh->HwQH.EpChars.DeviceAddress = 
        PacketParameters->DeviceAddress;
    qh->HwQH.EpChars.EndpointNumber = 
        PacketParameters->EndpointAddress;


    qh->HwQH.EpCaps.HighBWPipeMultiplier = 1;        
    qh->HwQH.EpCaps.HubAddress = 0;
    qh->HwQH.EpCaps.PortNumber = 0;

    // link back to ourselves
    //qh->HwQH.HLink.HwAddress = hwQh.HwAddress;        
        
    switch (PacketParameters->Speed) {
    case ss_Low:
        qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_LowSpeed;
        qh->HwQH.EpCaps.HubAddress = PacketParameters->HubDeviceAddress;
        qh->HwQH.EpCaps.PortNumber = PacketParameters->PortTTNumber;
        break;
    case ss_Full:
        qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_FullSpeed;
        qh->HwQH.EpCaps.HubAddress = PacketParameters->HubDeviceAddress;
        qh->HwQH.EpCaps.PortNumber = PacketParameters->PortTTNumber;
        break;
    case ss_High:
        qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_HighSpeed;
        break;
    default:
        USBPORT_BUGCHECK(DeviceData);
    } 
// jdxxx    
//qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_HighSpeed;    

    qh->HwQH.EpChars.MaximumPacketLength = 
        PacketParameters->MaximumPacketSize;

    // init td
    RtlZeroMemory(td, sizeof(*td));
    for (i=0; i<5; i++) {
        td->HwTD.BufferPage[i].ul = 0x0badf000;
    }

    td->PhysicalAddress = tdPhys;
    td->Sig = SIG_HCD_TD;
    
    switch(PacketParameters->Type) {
    case ss_Setup:
        LOGENTRY(DeviceData, G, '_sSU', 0, 0, 0); 
        td->HwTD.Token.Pid = HcTOK_Setup;
        break;
    case ss_In: 
        LOGENTRY(DeviceData, G, '_ssI', 0, 0, 0); 
        td->HwTD.Token.Pid = HcTOK_In;
        break;
    case ss_Out:
        td->HwTD.Token.Pid = HcTOK_Out;
        LOGENTRY(DeviceData, G, '_ssO', 0, 0, 0); 
        break;
    case ss_Iso_In:
        break;
    case ss_Iso_Out:       
        break;
    }

    switch(PacketParameters->Toggle) {
    case ss_Toggle0:
        td->HwTD.Token.DataToggle = HcTOK_Toggle0; 
        break;
    case ss_Toggle1:
        td->HwTD.Token.DataToggle = HcTOK_Toggle1;
        break;
    }  

    // prime the overlay with td so that this td
    // becomes the current td.
    qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = 
        td->PhysicalAddress;

    td->HwTD.Token.Active = 1;
    td->HwTD.Token.ErrorCounter = PacketParameters->ErrorCount;

    // point TD at the data
    td->HwTD.BufferPage[0].ul = dataPhys;
    td->HwTD.Token.BytesToTransfer = *PacketLength;

    tdLink.HwAddress = 0;
    SET_T_BIT(tdLink.HwAddress);
    td->HwTD.Next_qTD.HwAddress = tdLink.HwAddress;
    td->HwTD.AltNext_qTD.HwAddress = tdLink.HwAddress;

    QH_DESCRIPTOR_PTR(context->Qh) = qh;
    TRANSFER_DESCRIPTOR_PTR(context->Td) = td;
    HW_PTR(context->Data) = data;

    *UsbdStatus = USBD_STATUS_SUCCESS;

    // stick the QH in the schedule and wait for it to complete
    
    // swap the async qh, wait one frame then 
    // replace the old value.

    // NOTE: This will interrupt normal bus operation for one ms

    //WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr, hwQh.HwAddress);    
    EHCI_InsertQueueHeadInAsyncList(DeviceData, qh);                   

    EHCI_EnableAsyncList(DeviceData);        

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
USBMPFN
EHCI_EndSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     OUT USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PUCHAR pch;
    PSS_PACKET_CONTEXT context;
    HW_LINK_POINTER asyncHwQh;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHCD_TRANSFER_DESCRIPTOR td;
    PUCHAR data;

    LOGENTRY(DeviceData, G, '_ssE', 0, 0, 0); 

    hcOp = DeviceData->OperationalRegisters;
    context = (PSS_PACKET_CONTEXT) WorkspaceVirtualAddress;

    qh = QH_DESCRIPTOR_PTR(context->Qh);
    td = TRANSFER_DESCRIPTOR_PTR(context->Td);
    data = HW_PTR(context->Data);

    LOGENTRY(DeviceData, G, '_sE2', qh, td, *PacketLength ); 

    asyncHwQh.HwAddress = DeviceData->AsyncQueueHead->PhysicalAddress;
    SET_QH(asyncHwQh.HwAddress);

    *PacketLength = *PacketLength - td->HwTD.Token.BytesToTransfer;    

    LOGENTRY(DeviceData, G, '_sE3', td->HwTD.Token.BytesToTransfer, td,  
        *PacketLength );     
        
    RtlCopyMemory(PacketData, data, *PacketLength);

    EHCI_DisableAsyncList(DeviceData);

    EHCI_RemoveQueueHeadFromAsyncList(DeviceData, qh);                   
    
//    WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr, asyncHwQh.HwAddress);    

    // return the error here
    *UsbdStatus = USBD_STATUS_SUCCESS;
    if (td->HwTD.Token.Halted == 1) {
        if (td->HwTD.Token.XactErr) {
            *UsbdStatus = USBD_STATUS_XACT_ERROR;
        } else  if (td->HwTD.Token.BabbleDetected) {
            *UsbdStatus = USBD_STATUS_BABBLE_DETECTED;
        } else  if (td->HwTD.Token.DataBufferError) {
            *UsbdStatus = USBD_STATUS_DATA_BUFFER_ERROR;
        } else {
            *UsbdStatus = USBD_STATUS_STALL_PID;
        }
    }
    
    EHCI_KdPrint((DeviceData, 1, "'Status.XactErr %d\n",
        td->HwTD.Token.XactErr));    
    EHCI_KdPrint((DeviceData, 1, "'Status.BabbleDetected %d\n",
        td->HwTD.Token.BabbleDetected));  
    EHCI_KdPrint((DeviceData, 1, "'Status.DataBufferError %d\n",
        td->HwTD.Token.DataBufferError));
    
    return USBMP_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\periodic.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   periodic.c

Abstract:

   miniport transfer code for interrupt endpoints

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    1-1-00 : created, jdunn

--*/

#include "common.h"

/* 

For USB 2 period indicates a microframe polling interval so 
our tree structure is based on microframes.


      |- 1 ms frame -->|<---------  microframe ------------->|
      mic <32>  <16>  <08>   <04>      <02>              <01>
    
          (table entry)
          
[FRAME.MICROFRAME]          
[0.0] 0   ( 0) -\ 
                ( 0)-\
[2.0] 16  ( 1) -/     \
                      ( 0)-\
[1.0] 8   ( 2) -\     /     \
                ( 1)-/       \
[3.0] 24  ( 3) -/             \
                              (0)-\
[0.4] 4   ( 4) -\             /     \
                ( 2)-\       /       \
[2.4] 20  ( 5) -/     \     /         \
                      ( 1)-/           \
[1.4] 12  ( 6) -\     /                 \
                ( 3)-/                   \  
[3.4] 28  ( 7) -/                         \
                                          (0)-\
[0.2] 2   ( 8) -\                         /    \
                ( 4)-\                   /      \
[2.2] 18  ( 9) -/     \                 /        \
                       ( 2)-\          /          \
[1.2] 10  (10) -\     /      \        /            \
                ( 5)-/        \      /              \
[3.2] 26  (11) -/              \    /                \
                               (1)-/                  \
[0.6] 6   (12) -\              /                       \
                ( 6)-\        /                         \
[2.6] 22  (13) -/     \      /                           \
                       ( 3)-/                             \
[1.6] 14  (14) -\     /                                    \ 
                ( 7)-/                                      \
[3.6] 30  (15) -/                                            \
                                                             (0)                          
[0.1] 1   (16) -\                                            /
                ( 8)-\                                      /
[2.1] 17  (17) -/     \                                    /
                      ( 4)-\                              /
[1.1] 9   (18) -\     /     \                            /
                ( 9)-/       \                          /
[3.1] 25  (19) -/             \                        /
                              (2)-\                   /
[0.5] 5   (20) -\             /    \                 /
                (10)-\       /      \               /
[2.5] 21  (21) -/     \     /        \             /
                      ( 5)-/          \           /
[1.5] 13  (22) -\     /                \         /
                (11)-/                  \       /
[3.5] 29  (23) -/                        \     /
                                          (1)-/
[0.3] 3   (24) -\                        /
                (12)-\                  /
[2.3] 19  (25) -/     \                /
                      ( 6)-\          /
[1.3] 11  (26) -\     /     \        /
                (13)-/       \      /
[3.3] 27  (27) -/             \    /   
                              (3)-/
[0.7] 7   (28) -\             /
                (14)-\       /
[2.7] 23  (29) -/     \     /
                      ( 7)-/
[1.7] 15  (30) -\     /
                (15)-/
[3.7] 31  (31) -/


Allocations:
    period.offset           table entries
      1                    0, 1, 2.........31
      
      2.0                  0, 1, 2.........15
      2.1                 16,17,18.........31
      
      4.0                  0, 1, 2..........7
      4.1                  8, 9,10.........15 
      4.2                 16,17,18.........23
      4.3                 24,25,26.........31

      8.0                  0, 1, 2, 3
      8.1                  4, 5, 6, 7
      8.2                  8, 9,10,11
      8.3                 12,13,14,15
      8.4                 16,17,18,19
      8.5                 20,21,22,23
      8.6                 24,25,26,27
      8.7                 28,29,30,31

      ...


we mainatin a set of dummy queue heads that correspond to the 1ms nodes
in the chart above.

            the queue head table has 4 entries QH 0..3

            frame   mic frame      qh
              0       0..7         <0>
              1       0..7         <1>
              
driver maintains a mini tree that has seven QHs that are placed in the 
schedule.

period frame(microframes)

      32(4) 16(2)  1(8)

frame

 0   (a 0) -\ 
           (e 0)-\
 2   (b 1) -/     \
                 (g 0)-
 1   (c 2) -\     /     
           (f 1)-/       
 3   (d 3) -/             
                        


idx    QH  frame
 0       a    0
 1       b    2
 2       c    1
 3       d    3
 4       e    0,2
 5       f    1,3
 6       g    0,2,1,3
*/

/* 

We represent each possible node in the tree with a data structure that decodes
the appropriate queue head and S-Mask for the node

*e.g 
    for period 8 microframe, sched offset 0 QH = g s-mask = 1

    // The structure contains entries for the 64 possible nodes
    // plus the static ED for bulk and control (2) each entry 
    // corresponds to the period in the following table.
    //
    // the array looks like this:
    //  1, 2, 2, 4, 4, 4, 4, 8,
    //  8, 8, 8, 8, 8, 8, 8,16,
    // 16,16,16,16,16,16,16,16,
    // 16,16,16,16,16,16,16,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,

queue heads used for high speed

 0   (3) -\ 
           (1)-\
 2   (4) -/     \
                 (0)-
 1   (5) -\     /     
           (2)-/       
 3   (6) -/
 
*/

/* offsets for each period list */

#define ED_INTERRUPT_1mf    0 //period = 1mf
#define ED_INTERRUPT_2mf    1 //period = 2mf       
#define ED_INTERRUPT_4mf    3 //period = 4mf
#define ED_INTERRUPT_8mf    7 //period = 8mf
#define ED_INTERRUPT_16mf   15 //period = 16mf
#define ED_INTERRUPT_32mf   31 //period = 32mf

#define ED_INTERRUPT_1ms    0 //period = 1ms
#define ED_INTERRUPT_2ms    1 //period = 2ms       
#define ED_INTERRUPT_4ms    3 //period = 4ms
#define ED_INTERRUPT_8ms    7 //period = 8ms
#define ED_INTERRUPT_16ms   15 //period = 16ms
#define ED_INTERRUPT_32ms   31 //period = 32ms


PERIOD_TABLE periodTable[64] =
   {   // period, qh-idx, s-mask
        1,  0, 0xFF,        // 1111 1111 bits 0..7
        
        2,  0, 0x55,        // 0101 0101 bits 0,2,4,6
        2,  0, 0xAA,        // 1010 1010 bits 1,3,5,7
        
        4,  0, 0x11,        // 0001 0001 bits 0,4 
        4,  0, 0x44,        // 0100 0100 bits 2,6 
        4,  0, 0x22,        // 0010 0010 bits 1,5
        4,  0, 0x88,        // 1000 1000 bits 3,7
        
        8,  0, 0x01,        // 0000 0001 bits 0
        8,  0, 0x10,        // 0001 0000 bits 4
        8,  0, 0x04,        // 0000 0100 bits 2 
        8,  0, 0x40,        // 0100 0000 bits 6
        8,  0, 0x02,        // 0000 0010 bits 1
        8,  0, 0x20,        // 0010 0000 bits 5
        8,  0, 0x08,        // 0000 1000 bits 3
        8,  0, 0x80,        // 1000 0000 bits 7
 
        16,  1, 0x01,       // 0000 0001 bits 0 
        16,  2, 0x01,       // 0000 0001 bits 0 
        16,  1, 0x10,       // 0001 0000 bits 4
        16,  2, 0x10,       // 0001 0000 bits 4 
        16,  1, 0x04,       // 0000 0100 bits 2  
        16,  2, 0x04,       // 0000 0100 bits 2  
        16,  1, 0x40,       // 0100 0000 bits 6  
        16,  2, 0x40,       // 0100 0000 bits 6 
        16,  1, 0x02,       // 0000 0010 bits 1 
        16,  2, 0x02,       // 0000 0010 bits 1 
        16,  1, 0x20,       // 0010 0000 bits 5 
        16,  2, 0x20,       // 0010 0000 bits 5 
        16,  1, 0x08,       // 0000 1000 bits 3 
        16,  2, 0x08,       // 0000 1000 bits 3 
        16,  1, 0x80,       // 1000 0000 bits 7   
        16,  2, 0x80,       // 1000 0000 bits 7 

        32,  3, 0x01,       // 0000 0000 bits 0
        32,  5, 0x01,       // 0000 0000 bits 0
        32,  4, 0x01,       // 0000 0000 bits 0
        32,  6, 0x01,       // 0000 0000 bits 0
        32,  3, 0x10,       // 0000 0000 bits 4
        32,  5, 0x10,       // 0000 0000 bits 4
        32,  4, 0x10,       // 0000 0000 bits 4
        32,  6, 0x10,       // 0000 0000 bits 4
        32,  3, 0x04,       // 0000 0000 bits 2
        32,  5, 0x04,       // 0000 0000 bits 2
        32,  4, 0x04,       // 0000 0000 bits 2
        32,  6, 0x04,       // 0000 0000 bits 2
        32,  3, 0x40,       // 0000 0000 bits 6
        32,  5, 0x40,       // 0000 0000 bits 6
        32,  4, 0x40,       // 0000 0000 bits 6 
        32,  6, 0x40,       // 0000 0000 bits 6
        32,  3, 0x02,       // 0000 0000 bits 1
        32,  5, 0x02,       // 0000 0000 bits 1
        32,  4, 0x02,       // 0000 0000 bits 1
        32,  6, 0x02,       // 0000 0000 bits 1
        32,  3, 0x20,       // 0000 0000 bits 5
        32,  5, 0x20,       // 0000 0000 bits 5
        32,  4, 0x20,       // 0000 0000 bits 5
        32,  6, 0x20,       // 0000 0000 bits 5
        32,  3, 0x04,       // 0000 0000 bits 3
        32,  5, 0x04,       // 0000 0000 bits 3
        32,  4, 0x04,       // 0000 0000 bits 3
        32,  6, 0x04,       // 0000 0000 bits 3
        32,  3, 0x40,       // 0000 0000 bits 7
        32,  5, 0x40,       // 0000 0000 bits 7
        32,  4, 0x40,       // 0000 0000 bits 7
        32,  6, 0x40,       // 0000 0000 bits 7
        
    };

VOID
EHCI_EnablePeriodicList(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;
   
    hcOp = DeviceData->OperationalRegisters;
    
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    cmd.PeriodicScheduleEnable = 1;
    
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);
                         
    LOGENTRY(DeviceData, G, '_enP', cmd.ul, 0, 0); 
            
}    

 UCHAR ClassicPeriodIdx[8] = {
                           ED_INTERRUPT_1ms, //period = 1ms
                           ED_INTERRUPT_2ms, //period = 2ms       
                           ED_INTERRUPT_4ms, //period = 4ms       
                           ED_INTERRUPT_8ms, //period = 8ms       
                           ED_INTERRUPT_16ms,//period = 16ms       
                           ED_INTERRUPT_32ms,//period = 32ms       
                           ED_INTERRUPT_32ms,//period = 64ms               
                           ED_INTERRUPT_32ms //period = 128ms    
                           };

USB_MINIPORT_STATUS
EHCI_OpenInterruptEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, qhPhys;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG i;
    ULONG tdCount, bytes, offset;
    PPERIOD_TABLE periodTableEntry;
    BOOLEAN classic;
    PHCD_TRANSFER_DESCRIPTOR dummyTd;
    UCHAR periodIdx[8] = {
                           ED_INTERRUPT_1mf, //period = 1mf
                           ED_INTERRUPT_2mf, //period = 2mf       
                           ED_INTERRUPT_4mf, //period = 4mf       
                           ED_INTERRUPT_8mf, //period = 8mf       
                           ED_INTERRUPT_16mf,//period = 16mf       
                           ED_INTERRUPT_32mf,//period = 32mf       
                           ED_INTERRUPT_32mf,//period = 64mf               
                           ED_INTERRUPT_32mf //period = 128mf    
                           };

    classic = 
        (EndpointData->Parameters.DeviceSpeed != HighSpeed) ? TRUE : FALSE;
                    
    LOGENTRY(DeviceData, G, '_opI', EndpointData, EndpointParameters, classic);

    // select the proper list
    // the period is a power of 2 ie 
    // 32,16,8,4,2,1
    // we just need to find which bit is set
    GET_BIT_SET(EndpointParameters->Period, i);
    EHCI_ASSERT(DeviceData, i < 8);
    EHCI_ASSERT(DeviceData, EndpointParameters->Period < 64);

    InitializeListHead(&EndpointData->DoneTdList);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    offset = EndpointParameters->ScheduleOffset; 

    if (classic) {
        i = ClassicPeriodIdx[i];
        periodTableEntry = NULL;
    } else {
        i = periodIdx[i];
        periodTableEntry = &periodTable[i+offset];
    }        

    LOGENTRY(DeviceData, G, '_iep', EndpointData, 
        periodTableEntry, i);

    // locate the appropriate queue head and period 
    // table entry

    if (classic) {
        EndpointData->StaticQH = 
            DeviceData->StaticInterruptQH[i+offset];
        EndpointData->PeriodTableEntry = NULL;  
    } else {
        EndpointData->StaticQH = 
            DeviceData->StaticInterruptQH[periodTableEntry->qhIdx];
        EndpointData->PeriodTableEntry = periodTableEntry;         
    }

    // how much did we get
    bytes = EndpointParameters->CommonBufferBytes;

    EndpointData->QhChkPhys = phys;
    EndpointData->QhChk = buffer;  
    RtlZeroMemory(buffer, 256);
    phys += 256;
    buffer += 256;
    bytes -= 256;
    
    // make the Ed
    qh = (PHCD_QUEUEHEAD_DESCRIPTOR) buffer;
    qhPhys = phys;
   
    phys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    buffer += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    bytes -= sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

    tdCount = bytes/sizeof(HCD_TRANSFER_DESCRIPTOR);
    EHCI_ASSERT(DeviceData, tdCount >= TDS_PER_INTERRUPT_ENDPOINT);
    
    EndpointData->TdList = (PHCD_TD_LIST) buffer;
    EndpointData->TdCount = tdCount;
    for (i=0; i<tdCount; i++) {
        EHCI_InitializeTD(DeviceData,
                          EndpointData,
                          &EndpointData->TdList->Td[i],
                          phys);                                         
                             
        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);    
    }

    EndpointData->FreeTds = tdCount;

    EndpointData->QueueHead = 
        EHCI_InitializeQH(DeviceData,
                          EndpointData,
                          qh,
                          qhPhys);            

    if (classic) {    
        // use mask parameters passed to us
        qh->HwQH.EpCaps.InterruptScheduleMask = 
            EndpointParameters->InterruptScheduleMask;
        qh->HwQH.EpCaps.SplitCompletionMask = 
            EndpointParameters->SplitCompletionMask;
        
    } else {
        qh->HwQH.EpCaps.InterruptScheduleMask = 
            periodTableEntry->InterruptScheduleMask;        
    } 

    // init our polling variables
    dummyTd = EHCI_ALLOC_TD(DeviceData, EndpointData);
    dummyTd->HwTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
    TRANSFER_DESCRIPTOR_PTR(dummyTd->NextHcdTD) = NULL;
    dummyTd->HwTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
    TRANSFER_DESCRIPTOR_PTR(dummyTd->AltNextHcdTD) = NULL;
    dummyTd->HwTD.Token.Active = 0;
    SET_FLAG(dummyTd->Flags, TD_FLAG_DUMMY);
    EndpointData->DummyTd = dummyTd;
    EndpointData->HcdHeadP = dummyTd;
    
    // endpoint is not active, set up the overlay
    // so that the currentTD is the Dummy
    
    qh->HwQH.CurrentTD.HwAddress = dummyTd->PhysicalAddress;
    qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT; 
    qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;    
    qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;
    qh->HwQH.Overlay.qTD.Token.Active = 0;

    return USBMP_STATUS_SUCCESS;              
}


VOID
EHCI_InsertQueueHeadInPeriodicList(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

   Insert an interrupt endpoint into the h/w schedule

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR staticQH, qh, nxtQH, prvQH;
    HW_LINK_POINTER hLink;

    staticQH = EndpointData->StaticQH;
    qh = EndpointData->QueueHead;

    EHCI_ASSERT(DeviceData,
                TEST_FLAG(staticQH->QhFlags, EHCI_QH_FLAG_STATIC));

    EHCI_ASSERT(DeviceData,
                !TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE));
    
    nxtQH = QH_DESCRIPTOR_PTR(staticQH->NextQh); 
    prvQH = staticQH;

    // Note: This function must be coherent with the budgeter code
    // the budgeter inserts endpoints such that the newer endpoints
    // are at the end of the sublist, older are at the begining. The 
    // lower the ordinal value the older the endpoint.  The ordinal 
    // values are used to maintain the same ordering in the event the
    // schedule must be reconstructed

    // hook this queue head to the the static 
    // queue head list, two cases

    // case 1:
    // insert QH1, queue head list is not empty:
    //
    // |staticQH|<->QH2<->QH3<->|staticQH|<->QH4
    //
    // |staticQH|<->QH2<->QH3<->QH1<->|staticQH|<->QH4
    //              (o=1)  (o=2)  (o=3)
    //  for case one qeue must insert the queue head in the list 
    //  based on the ordinal value we need to compute prev and
    //  next
    

    // case 2:
    // insert QH1, queue head sublist is empty
    //
    // |staticQH|<->|staticQH|<->QH4 
    //
    // |staticQH|<->QH1<->|staticQH|<->QH4
    
    LOGENTRY(DeviceData, G, '_inQ', EndpointData, qh, staticQH);    

    // find the correct spot
    // prvQH, nxtQH are currently the beginnig and end of the 
    // sublist
    qh->Ordinal = EndpointData->Parameters.Ordinal;
    qh->Period = EndpointData->Parameters.Period;
   
    if (TEST_FLAG(prvQH->QhFlags, EHCI_QH_FLAG_STATIC) &&
        (nxtQH == NULL || TEST_FLAG(nxtQH->QhFlags, EHCI_QH_FLAG_STATIC))) {
        // case 2 qh list is empty
          
        LOGENTRY(DeviceData, G, '_iq1', prvQH, 0, nxtQH);    
        
    } else {
        // case 1 qh list is not empty 
        
        // find the correct position based on ordinal 
        while (nxtQH != NULL && 
               !TEST_FLAG(nxtQH->QhFlags, EHCI_QH_FLAG_STATIC) && 
               qh->Ordinal > nxtQH->Ordinal) {

            prvQH = nxtQH;
            nxtQH = QH_DESCRIPTOR_PTR(prvQH->NextQh);
            
        }                               
        
        //if (nxtQH != NULL && 
        //    !TEST_FLAG(nxtQH->QhFlags, EHCI_QH_FLAG_STATIC)) {
        //    // middle insertion
        //    TEST_TRAP();
        //}            
    }


    // do the insertion
    
    QH_DESCRIPTOR_PTR(qh->NextQh) = nxtQH;
    QH_DESCRIPTOR_PTR(qh->PrevQh) = prvQH;
    // next link points back
    if (nxtQH != NULL && 
        !TEST_FLAG(nxtQH->QhFlags, EHCI_QH_FLAG_STATIC)) {
        QH_DESCRIPTOR_PTR(nxtQH->PrevQh) = qh;
    }        

    // prev points to new qh
    QH_DESCRIPTOR_PTR(prvQH->NextQh) = qh;
    
    // now link to HW,order of operation is
    // important here
    hLink.HwAddress = qh->PhysicalAddress;
    SET_QH(hLink.HwAddress);
    
    qh->HwQH.HLink = prvQH->HwQH.HLink;
    prvQH->HwQH.HLink = hLink;

    SET_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE);
    
}


VOID
EHCI_RemoveQueueHeadFromPeriodicList(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

   remove an interrupt endpoint into from the h/w schedule

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR staticQH, qh, prevQH, nextQH;
    HW_LINK_POINTER hLink;

    staticQH = EndpointData->StaticQH;
    qh = EndpointData->QueueHead;

    if (!TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE))  {
        return;
    }
    
    LOGENTRY(DeviceData, G, '_rmQ', EndpointData, qh, staticQH);    

    
  
    // remove the queue head

    // remove QH2, two cases
    // |staticQH|<->QH1<->QH2<->QH3<->|staticQH|<->QH4
    //
    // |staticQH|<->QH1<->QH3<->|staticQH|<->QH4


    prevQH = QH_DESCRIPTOR_PTR(qh->PrevQh);
    nextQH = QH_DESCRIPTOR_PTR(qh->NextQh);

    // unlink next ptrs
    QH_DESCRIPTOR_PTR(prevQH->NextQh) = nextQH;
    if (nextQH != NULL && 
        !TEST_FLAG(nextQH->QhFlags, EHCI_QH_FLAG_STATIC)) {
        QH_DESCRIPTOR_PTR(nextQH->PrevQh) = prevQH;    
    }

    // hw unlink, nextqh will be null if this is period 1ms
    // qh
    if (nextQH == NULL) {
        hLink.HwAddress = 0;
        SET_T_BIT(hLink.HwAddress);
    } else {
        hLink.HwAddress = nextQH->PhysicalAddress;
        SET_QH(hLink.HwAddress);
    }             
    prevQH->HwQH.HLink = hLink;

    CLEAR_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE);
    QH_DESCRIPTOR_PTR(qh->NextQh) = NULL;
    QH_DESCRIPTOR_PTR(qh->PrevQh) = NULL;
}


USB_MINIPORT_STATUS
EHCI_InterruptTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferUrb,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    )
/*++

Routine Description:

    Initialize interrupt Transfer

    NOTES:
    
    HW pointers nextTD and AltNextTD are shadowed in 
    NextHcdTD and AltNextHcdTD.
    
    

Arguments:


--*/    
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHCD_TRANSFER_DESCRIPTOR firstTd, prevTd, td;
    ULONG lengthMapped;
    
    // if we have enough TDs do the transfer
    if (EndpointData->FreeTds == 0) {
        TEST_TRAP();            
        LOGENTRY(DeviceData, G, '_IIS', EndpointData, TransferUrb, 0);
        return USBMP_STATUS_BUSY;
    }

    EndpointData->PendingTransfers++;

    // if we have enough tds, program the transfer

    LOGENTRY(DeviceData, G, '_IIT', EndpointData, TransferUrb, 0);

    lengthMapped = 0;
    prevTd = NULL;
    
    while (lengthMapped < TransferUrb->TransferBufferLength) {

        TransferContext->PendingTds++;
        td = EHCI_ALLOC_TD(DeviceData, EndpointData);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

        if (TransferContext->PendingTds == 1) {
            firstTd = td;
        } else if (prevTd) {
            SET_NEXT_TD(DeviceData, prevTd, td);
        } 
    
        //
        // fields for data TD
        //

        // use direction specified in transfer
        if (TEST_FLAG(TransferUrb->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
            td->HwTD.Token.Pid = HcTOK_In;
        } else {
            td->HwTD.Token.Pid = HcTOK_Out;
        }                                   
        
        td->HwTD.Token.DataToggle = HcTOK_Toggle1;
        td->HwTD.Token.Active = 1;

        LOGENTRY(DeviceData, 
            G, '_dta', td, lengthMapped, TransferUrb->TransferBufferLength);

        lengthMapped = 
            EHCI_MapAsyncTransferToTd(DeviceData,
                                      EndpointData->Parameters.MaxPacketSize,     
                                      lengthMapped,
                                      NULL,
                                      TransferContext,
                                      td,
                                      TransferSGList);

        prevTd = td;
         
    }

    // interrupt on the last TD
    td->HwTD.Token.InterruptOnComplete = 1;

    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, td->PhysicalAddress, firstTd);

    // td points to last TD in this transfer, point it at the dummy
    SET_NEXT_TD(DeviceData, td, EndpointData->DummyTd);

    EHCI_LinkTransferToQueue(DeviceData,
                             EndpointData,
                             firstTd);

    ASSERT_DUMMY_TD(DeviceData, EndpointData->DummyTd);

    // tell the hc we have periodic transfers available
    EHCI_EnablePeriodicList(DeviceData);        

    return USBMP_STATUS_SUCCESS;
}


/* 
    CLASSIC

    The classic tree has 63 possible nodes, usport bw manager will select the 
    appropriate node based on a 'classic' bus.

    usbport maintains bandwidth management for each classic bus, however 
    budgeting the microframes is left to the miniport.

    classic 1ms interrupt schedule, NOTE:this schedule shares some queue heads with 
    the hish speed schedule.

    * = shared queue head

fr <32>  <16>  <08>   <04>      <02>              <01>
    
      
0   ( 0) -\ 
          ( 0)-\
16  ( 1) -/     \
                ( 0)-\
8   ( 2) -\     /     \
          ( 1)-/       \
24  ( 3) -/             \
                        *(0)-\
4   ( 4) -\             /    \
          ( 2)-\       /      \
20  ( 5) -/     \     /        \
                ( 1)-/          \
12  ( 6) -\     /                \
          ( 3)-/                  \  
28  ( 7) -/                        \
                                   *(0)-\
2   ( 8) -\                        /    \
          ( 4)-\                  /      \
18  ( 9) -/     \                /        \
                ( 2)-\          /          \
10  (10) -\     /     \        /            \
          ( 5)-/       \      /              \
26  (11) -/             \    /                \
                        *(1)-/                  \
6   (12) -\             /                       \
          ( 6)-\       /                         \
22  (13) -/     \     /                           \
                ( 3)-/                             \
14  (14) -\     /                                   \ 
          ( 7)-/                                     \
30  (15) -/                                           \
                                                      *(0)                          
1   (16) -\                                           /
          ( 8)-\                                     /
17  (17) -/     \                                   /
                ( 4)-\                             /
9   (18) -\     /     \                           /
          ( 9)-/       \                         /
25  (19) -/             \                       /
                        *(2)-\                  /
5   (20) -\             /    \                /
          (10)-\       /      \              /
21  (21) -/     \     /        \            /
                ( 5)-/          \          /
13  (22) -\     /                \        /
          (11)-/                  \      /
29  (23) -/                        \    /
                                   *(1)-/
3   (24) -\                        /
          (12)-\                  /
19  (25) -/     \                /
                ( 6)-\          /
11  (26) -\     /     \        /
          (13)-/       \      /
27  (27) -/             \    /   
                        *(3)-/
7   (28) -\             /
          (14)-\       /
23  (29) -/     \     /
                ( 7)-/
15  (30) -\     /
          (15)-/
31  (31) -/

     
    The node table is arrangened in the standard usb 1.1 fashion so that 
    the schedule offset passed to us by the budget engine applies
    
    // the static array looks like this:
    //  1, 2, 2, 4, 4, 4, 4, 8,
    //  8, 8, 8, 8, 8, 8, 8,16,
    // 16,16,16,16,16,16,16,16,
    // 16,16,16,16,16,16,16,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,


    CLASSIC BUDGET

    The classic budget is maintained by the port driver we 
    simply need to program the endpoint at the appropriate
    offset (node) with the given smask cmask

period(ms)    queue head(index)            
    1                0                          
    2                1                          
    2                2                                        
    4                3                          
    4                4                          
    4                5                          
    4                6                          
    8                7
    8                8
    8                9     
    8               10 
    8               11
    8               12
    8               13
    8               14
    
*/

UCHAR EHCI_Frame2Qhead[32] = {
/*
offset     ms frame
*/
0, //        0                    
16,//        1                 
8, //        2                
24,//        3               
4, //        4                
20,//        5               
12,//        6                 
28,//        7               
2, //        8                
18,//        9               
10,//       10
26,//       11
6, //       12               
22,//       13
14,//       14
30,//       15
1, //       16               
17,//       17
9, //       18
25,//       19
5, //       20               
21,//       21
13,//       22
29,//       23
3, //       24               
19,//       25
11,//       26
27,//       27
7, //       28               
23,//       29
15,//       30 
31,//       31
};

PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_GetQueueHeadForFrame(
     PDEVICE_DATA DeviceData,
     ULONG Frame
    )
/*++

Routine Description:

Arguments:

Return Value:

    static queue head associated with a particular frame
    
--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG f;

    // normalize frame
    f = Frame%32;
        
    qh = DeviceData->StaticInterruptQH[EHCI_Frame2Qhead[f]+ED_INTERRUPT_32ms];

    return qh;
    
}


/* 

Queue head index table, values correspond to index in StaticQueueHead List

fr <32>  <16>  <08>   <04>      <02>              <01>
    
      
0   (31) -\ 
          (15)-\
16  (32) -/     \
                (7)-\
8   (33) -\     /     \
          (16)-/       \
24  (34) -/             \
                       *(3)-\
4   (35) -\             /    \
          (17)-\       /      \
20  (36) -/     \     /        \
                (8)-/          \
12  (37) -\     /                \
          (18)-/                  \  
28  (38) -/                        \
                                  *(1)-\
2   (39) -\                        /    \
          (19)-\                  /      \
18  (40) -/     \                /        \
                (9)-\          /          \
10  (41) -\     /     \        /            \
          (20)-/       \      /              \
26  (42) -/             \    /                \
                       *(4)-/                  \
6   (43) -\             /                       \
          (21)-\       /                         \
22  (44) -/     \     /                           \
                (10)-/                             \
14  (45) -\     /                                   \ 
          (22)-/                                     \
30  (46) -/                                           \
                                                      *(0)                          
1   (47) -\                                           /
          (23)-\                                     /
17  (48) -/     \                                   /
                (11)-\                             /
9   (49) -\     /     \                           /
          (24)-/       \                         /
25  (50) -/             \                       /
                       *(5)-\                  /
5   (51) -\             /    \                /
          (25)-\       /      \              /
21  (51) -/     \     /        \            /
                (12)-/          \          /
13  (53) -\     /                \        /
          (26)-/                  \      /
29  (54) -/                        \    /
                                  *(2)-/
3   (55) -\                        /
          (27)-\                  /
19  (56) -/     \                /
                (13)-\          /
11  (57) -\     /     \        /
          (28)-/       \      /
27  (58) -/             \    /   
                       *(6)-/
7   (59) -\             /
          (29)-\       /
23  (60) -/     \     /
                (14)-/
15  (61) -\     /
          (30)-/
31  (62) -/

*/

UCHAR EHCI_QHeadLinkTable[63] = {
    /* nextQueueHead    QueueHead */
           0xff,      //      0
           0,         //      1
           0,         //      2  
           1,         //      3
           1,         //      4
           2,         //      5
           2,         //      6
           3,         //      7
           3,         //      8
           4,         //      9
           4,         //      10
           5,         //      11
           5,         //      12
           6,         //      13
           6,         //      14
           7,         //      15
           7,         //      16
           8,         //      17
           8,         //      18
           9,         //      19
           9,         //      20
          10,         //      21
          10,         //      22
          11,         //      23
          11,         //      24
          12,         //      25
          12,         //      26
          13,         //      27
          13,         //      28
          14,         //      29
          14,         //      30
          15,         //      31
          15,         //      32
          16,         //      33
          16,         //      34
          17,         //      35
          17,         //      36
          18,         //      37
          18,         //      38
          19,         //      39
          19,         //      40
          20,         //      41
          20,         //      42
          21,         //      43
          21,         //      44          
          22,         //      45
          22,         //      46
          23,         //      47
          23,         //      48
          24,         //      49
          24,         //      50
          25,         //      51
          25,         //      52     
          26,         //      53
          26,         //      54
          27,         //      55
          27,         //      56
          28,         //      57
          28,         //      58
          29,         //      59     
          29,         //      60
          30,         //      61
          30,         //      62     
};


VOID
EHCI_InitailizeInterruptSchedule(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG i;
    
    // first initialize all the 'dummy' queue heads
    
    for (i=0; i<63; i++) {
        qh = DeviceData->StaticInterruptQH[i];
        
        SET_T_BIT(qh->HwQH.Overlay.qTD.Next_qTD.HwAddress);
        qh->HwQH.Overlay.qTD.Token.Halted = 1;
        qh->HwQH.EpChars.HeadOfReclimationList = 0;
        qh->Sig = SIG_HCD_IQH;
    }

    
#define INIT_QH(q, nq, f) \
    do {\
    QH_DESCRIPTOR_PTR((q)->NextQh) = (nq); \
    QH_DESCRIPTOR_PTR((q)->PrevQh) = NULL; \
    (q)->HwQH.HLink.HwAddress = (nq)->PhysicalAddress; \
    (q)->HwQH.HLink.HwAddress |= EHCI_DTYPE_QH;\
    (q)->HwQH.EpCaps.InterruptScheduleMask =0xff;\
    (q)->QhFlags |= EHCI_QH_FLAG_STATIC;\
    (q)->QhFlags |= f;\
    } while(0)
    
    // now build the above tree
    for (i=1; i<63; i++) {        
        INIT_QH(DeviceData->StaticInterruptQH[i], 
                DeviceData->StaticInterruptQH[EHCI_QHeadLinkTable[i]],
                i<=6 ? EHCI_QH_FLAG_HIGHSPEED : 0);
    }

    // last qh has t bit set
    
    DeviceData->StaticInterruptQH[0]->HwQH.HLink.HwAddress = 0;        
    SET_T_BIT(DeviceData->StaticInterruptQH[0]->HwQH.HLink.HwAddress);
    DeviceData->StaticInterruptQH[0]->QhFlags |= 
        (EHCI_QH_FLAG_HIGHSPEED | EHCI_QH_FLAG_STATIC);
    
#undef INIT_QH    
}


VOID
EHCI_WaitFrames(
     PDEVICE_DATA DeviceData,
     ULONG Frames
    )
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    FRINDEX frameIndex;
    ULONG frameNumber, i, c;

    hcOp = DeviceData->OperationalRegisters;

    for (c=0; c< Frames; c++) {
        // bugbug this code does not handle varaible frame list
        // sizes
        frameIndex.ul = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

        frameNumber = (ULONG) frameIndex.FrameListCurrentIndex;
        // shift off the microframes 
        frameNumber >>= 3;

        i = frameNumber;

        do {
            frameIndex.ul = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

            frameNumber = (ULONG) frameIndex.FrameListCurrentIndex;
            // shift off the microframes 
            frameNumber >>= 3;
        } while (frameNumber == i);
    }                

}


VOID
EHCI_RebalanceInterruptEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,        
    PENDPOINT_DATA EndpointData
    ) 
/*++

Routine Description:

    compute how much common buffer we will need
    for this endpoint

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    qh = EndpointData->QueueHead;

    // update internal copy of parameters
    EndpointData->Parameters = *EndpointParameters;
    
    // period promotion?
    if (qh->Period != EndpointParameters->Period) {
        ULONG i, offset;
        
        EHCI_KdPrint((DeviceData, 1, "'period change old - %d new %d\n",
            qh->Period, EndpointParameters->Period));     
            
        EHCI_RemoveQueueHeadFromPeriodicList(DeviceData,
                                             EndpointData); 

        EHCI_WaitFrames(DeviceData, 2);

        // clear residual data from overlay area
        qh->HwQH.Overlay.qTD.Token.ErrorCounter = 0;           
        qh->HwQH.Overlay.qTD.Token.SplitXstate = 0;
        qh->HwQH.Overlay.Ov.OverlayDw8.CprogMask = 0;
        qh->HwQH.Overlay.Ov.OverlayDw9.Sbytes = 0;
        qh->HwQH.Overlay.Ov.OverlayDw9.fTag = 0;
        
        
        EHCI_ASSERT(DeviceData, 
                    EndpointData->Parameters.DeviceSpeed != HighSpeed);
                    
        // select the proper list
        // the period is a power of 2 ie 
        // 32,16,8,4,2,1
        // we just need to find which bit is set
        GET_BIT_SET(EndpointParameters->Period, i);
        EHCI_ASSERT(DeviceData, i < 8);
        EHCI_ASSERT(DeviceData, EndpointParameters->Period < 64);

        offset = EndpointParameters->ScheduleOffset; 

        i = ClassicPeriodIdx[i];
        EndpointData->StaticQH = 
            DeviceData->StaticInterruptQH[i+offset];
        EndpointData->PeriodTableEntry = NULL;  

        qh->Period = EndpointParameters->Period;
        qh->HwQH.EpCaps.InterruptScheduleMask = 
                EndpointParameters->InterruptScheduleMask;
        qh->HwQH.EpCaps.SplitCompletionMask = 
                EndpointParameters->SplitCompletionMask;

        EHCI_InsertQueueHeadInPeriodicList(DeviceData,
                                           EndpointData); 
        
    } else {

        EHCI_RemoveQueueHeadFromPeriodicList(DeviceData,
                                             EndpointData); 

        EHCI_WaitFrames(DeviceData, 2);

        // clear residual data from overlay area
        qh->HwQH.Overlay.qTD.Token.ErrorCounter = 0; 
        qh->HwQH.Overlay.qTD.Token.SplitXstate = 0;
        qh->HwQH.Overlay.Ov.OverlayDw8.CprogMask = 0;
        qh->HwQH.Overlay.Ov.OverlayDw9.Sbytes = 0;
        qh->HwQH.Overlay.Ov.OverlayDw9.fTag = 0;
        
        qh->HwQH.EpCaps.InterruptScheduleMask = 
                EndpointParameters->InterruptScheduleMask;
        qh->HwQH.EpCaps.SplitCompletionMask = 
                EndpointParameters->SplitCompletionMask;

        EHCI_InsertQueueHeadInPeriodicList(DeviceData,
                                           EndpointData);                 
    }                
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\mpinit.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

   mpinit.c

Abstract:

   miniport initialization

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2-19-99 : created, jdunn

--*/

#include "common.h"

// global registration packet for this miniport
USBPORT_REGISTRATION_PACKET RegistrationPacket;

NTSTATUS
DriverEntry(
     PDRIVER_OBJECT DriverObject,
     PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG mn;
    
    mn = USBPORT_GetHciMn();

    if (mn != USB_HCI_MN) {
        TEST_TRAP();
        return STATUS_UNSUCCESSFUL;
    }

    RegistrationPacket.DeviceDataSize =
        sizeof(DEVICE_DATA);
    RegistrationPacket.EndpointDataSize =
        sizeof(ENDPOINT_DATA);
    RegistrationPacket.TransferContextSize =
        sizeof(TRANSFER_CONTEXT);

    // enough for 4k frame list plus 4k of scratch space
    // plus static queue head table
    // plus 1024 'dummy' queue heads
    RegistrationPacket.CommonBufferBytes = 8192 +
        (sizeof(HCD_QUEUEHEAD_DESCRIPTOR) * 64) + 
        (sizeof(HCD_QUEUEHEAD_DESCRIPTOR) *1024);

    RegistrationPacket.MINIPORT_StartController =
        EHCI_StartController;
    RegistrationPacket.MINIPORT_StopController =
        EHCI_StopController;
    RegistrationPacket.MINIPORT_SuspendController =
        EHCI_SuspendController;
    RegistrationPacket.MINIPORT_ResumeController =
        EHCI_ResumeController;
    RegistrationPacket.MINIPORT_EnableInterrupts =
        EHCI_EnableInterrupts;
    RegistrationPacket.MINIPORT_DisableInterrupts =
        EHCI_DisableInterrupts;
    RegistrationPacket.MINIPORT_InterruptService =
        EHCI_InterruptService;

    // root hub functions
    RegistrationPacket.MINIPORT_RH_DisableIrq =
        EHCI_RH_DisableIrq;
    RegistrationPacket.MINIPORT_RH_EnableIrq =
        EHCI_RH_EnableIrq;
    RegistrationPacket.MINIPORT_RH_GetRootHubData =
        EHCI_RH_GetRootHubData;
    RegistrationPacket.MINIPORT_RH_GetStatus =
        EHCI_RH_GetStatus;
    RegistrationPacket.MINIPORT_RH_GetHubStatus =
        EHCI_RH_GetHubStatus;
    RegistrationPacket.MINIPORT_RH_GetPortStatus =
        EHCI_RH_GetPortStatus;

    RegistrationPacket.MINIPORT_RH_SetFeaturePortReset =
        EHCI_RH_SetFeaturePortReset;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortPower =
        EHCI_RH_SetFeaturePortPower;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortEnable =
        EHCI_RH_SetFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortSuspend =
        EHCI_RH_SetFeaturePortSuspend;

    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnable =
        EHCI_RH_ClearFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortPower =
        EHCI_RH_ClearFeaturePortPower;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspend =
        EHCI_RH_ClearFeaturePortSuspend;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnableChange =
        EHCI_RH_ClearFeaturePortEnableChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortConnectChange =
        EHCI_RH_ClearFeaturePortConnectChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange =
        EHCI_RH_ClearFeaturePortResetChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspendChange =
        EHCI_RH_ClearFeaturePortSuspendChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortOvercurrentChange =
        EHCI_RH_ClearFeaturePortOvercurrentChange;

    RegistrationPacket.MINIPORT_SetEndpointStatus =
        EHCI_SetEndpointStatus;
    RegistrationPacket.MINIPORT_GetEndpointStatus =
        EHCI_GetEndpointStatus;
    RegistrationPacket.MINIPORT_SetEndpointDataToggle =
        EHCI_SetEndpointDataToggle;
    RegistrationPacket.MINIPORT_OpenEndpoint =
        EHCI_OpenEndpoint;
    RegistrationPacket.MINIPORT_PokeEndpoint =
        EHCI_PokeEndpoint;
    RegistrationPacket.MINIPORT_QueryEndpointRequirements =
        EHCI_QueryEndpointRequirements;
    RegistrationPacket.MINIPORT_CloseEndpoint =
        EHCI_CloseEndpoint;
    RegistrationPacket.MINIPORT_PollEndpoint =
        EHCI_PollEndpoint;
    RegistrationPacket.MINIPORT_SetEndpointState =
        EHCI_SetEndpointState;
    RegistrationPacket.MINIPORT_GetEndpointState =
        EHCI_GetEndpointState;
    RegistrationPacket.MINIPORT_Get32BitFrameNumber =
        EHCI_Get32BitFrameNumber;
    RegistrationPacket.MINIPORT_PollController =
        EHCI_PollController;
    RegistrationPacket.MINIPORT_CheckController =
        EHCI_CheckController;        
    RegistrationPacket.MINIPORT_InterruptNextSOF =
        EHCI_InterruptNextSOF;
    RegistrationPacket.MINIPORT_SubmitTransfer =
        EHCI_SubmitTransfer;
    RegistrationPacket.MINIPORT_InterruptDpc =
        EHCI_InterruptDpc;
    RegistrationPacket.MINIPORT_AbortTransfer =
        EHCI_AbortTransfer;
    RegistrationPacket.MINIPORT_StartSendOnePacket =
        EHCI_StartSendOnePacket;
    RegistrationPacket.MINIPORT_EndSendOnePacket =
        EHCI_EndSendOnePacket;
    RegistrationPacket.MINIPORT_PassThru =
        EHCI_PassThru;
    RegistrationPacket.MINIPORT_SubmitIsoTransfer =
        EHCI_SubmitIsoTransfer;        
    RegistrationPacket.MINIPORT_RebalanceEndpoint =
        EHCI_RebalanceEndpoint;       
    RegistrationPacket.MINIPORT_FlushInterrupts =
        EHCI_FlushInterrupts;        
    RegistrationPacket.MINIPORT_Chirp_RH_Port =
        EHCI_RH_ChirpRootPort;                
    RegistrationPacket.MINIPORT_TakePortControl = 
        EHCI_TakePortControl;

    RegistrationPacket.OptionFlags = USB_MINIPORT_OPT_NEED_IRQ |
                                     USB_MINIPORT_OPT_NEED_MEMORY |
                                     USB_MINIPORT_OPT_USB20 |
                                    // disable ss sometimes for testing                                        
                                    // USB_MINIPORT_OPT_NO_SS |
                                     USB_MINIPORT_OPT_POLL_CONTROLLER;

    RegistrationPacket.HciType = USB_EHCI;
    RegistrationPacket.BusBandwidth = USB_20_BUS_BANDWIDTH;

    DriverObject->DriverUnload = NULL;

    return USBPORT_RegisterUSBPortDriver(
                DriverObject,
                USB_MINIPORT_HCI_VERSION_2,
                &RegistrationPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\usbehci.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    hydramp.c

Abstract:

    USB 2.0 EHCI driver

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2-19-99 : created, jdunn

--*/



#include "common.h"

#include <initguid.h>
#include "usbpriv.h"

//implements the following miniport functions:
//EHCI_StartController
//EHCI_StopController
//EHCI_DisableInterrupts
//EHCI_EnableInterrupts

USB_MINIPORT_STATUS
EHCI_InitializeHardware(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

   Initializes the hardware registers for the host controller.

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PHC_CAPABILITIES_REGISTER hcCap;
    USBCMD cmd;
    HCSPARAMS hcSparms;
    LARGE_INTEGER finishTime, currentTime;

    hcCap = DeviceData->CapabilitiesRegisters;
    hcOp = DeviceData->OperationalRegisters;

    // reset the controller
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    LOGENTRY(DeviceData, G, '_res', cmd.ul, 0, 0);
    cmd.HostControllerReset = 1;
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

    KeQuerySystemTime(&finishTime);
    // no spec'ed time -- we will graciously grant 0.1 sec.
    //
    // figure when we quit (.1 seconds later)
    finishTime.QuadPart += 1000000;

    // wait for reset bit to got to zero
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    while (cmd.HostControllerReset) {

        KeQuerySystemTime(&currentTime);

        if (currentTime.QuadPart >= finishTime.QuadPart) {

            EHCI_KdPrint((DeviceData, 0,
                "'EHCI controller failed to reset in .1 sec!\n"));

            return USBMP_STATUS_HARDWARE_FAILURE;
        }

        cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    }

    hcSparms.ul =
        READ_REGISTER_ULONG(&hcCap->HcStructuralParameters.ul);

    DeviceData->NumberOfPorts =
        (USHORT) hcSparms.NumberOfPorts;

    DeviceData->PortPowerControl =
        (USHORT) hcSparms.PortPowerControl;

    // inialize operational registers
    WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr, 0);
    WRITE_REGISTER_ULONG(&hcOp->PeriodicListBase, 0);

    // set the enabled interrupts cache, we'll enable
    // these interrupts when asked
    DeviceData->EnabledInterrupts.UsbInterrupt = 1;
    DeviceData->EnabledInterrupts.UsbError = 1;
    DeviceData->EnabledInterrupts.FrameListRollover = 1;
    DeviceData->EnabledInterrupts.HostSystemError = 1;
    DeviceData->EnabledInterrupts.IntOnAsyncAdvance = 1;

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_InitializeSchedule(
     PDEVICE_DATA DeviceData,
     PUCHAR StaticQHs,
     HW_32BIT_PHYSICAL_ADDRESS StaticQHsPhys
    )
/*++

Routine Description:

    Build the schedule of static Eds

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    ULONG length;
    ULONG i;
    PHC_OPERATIONAL_REGISTER hcOp;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_LINK_POINTER asyncHwQh;
    PHW_32BIT_PHYSICAL_ADDRESS frameBase;

    hcOp = DeviceData->OperationalRegisters;

    // allocate a frame list
    frameBase = DeviceData->FrameListBaseAddress =
            (PHW_32BIT_PHYSICAL_ADDRESS) StaticQHs;
    DeviceData->FrameListBasePhys =
        StaticQHsPhys;
    StaticQHs += USBEHCI_MAX_FRAME*sizeof(HW_32BIT_PHYSICAL_ADDRESS);
    StaticQHsPhys += USBEHCI_MAX_FRAME*sizeof(HW_32BIT_PHYSICAL_ADDRESS);

    // allocate a 'Dummy' QH for the Async list
    qh = (PHCD_QUEUEHEAD_DESCRIPTOR) StaticQHs;

    RtlZeroMemory(qh, sizeof(*qh));
    asyncHwQh.HwAddress =
        qh->PhysicalAddress = StaticQHsPhys;
    // no current TD
    // t-bit set on next TD
    SET_T_BIT(qh->HwQH.Overlay.qTD.Next_qTD.HwAddress);
    qh->HwQH.Overlay.qTD.Token.Halted = 1;
    qh->HwQH.EpChars.HeadOfReclimationList = 1;
    qh->Sig = SIG_HCD_AQH;
    SET_QH(asyncHwQh.HwAddress);
    // link to ourselves
    qh->HwQH.HLink.HwAddress = asyncHwQh.HwAddress;
    QH_DESCRIPTOR_PTR(qh->NextQh) = qh;
    QH_DESCRIPTOR_PTR(qh->PrevQh) = qh;

    DeviceData->AsyncQueueHead = qh;

    StaticQHs += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    StaticQHsPhys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

    // allocate 64 static interrupt queue heads
    for (i=0; i<64; i++) {
        qh = (PHCD_QUEUEHEAD_DESCRIPTOR) StaticQHs;
        qh->PhysicalAddress = StaticQHsPhys;

        DeviceData->StaticInterruptQH[i] = qh;

        StaticQHs += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
        StaticQHsPhys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    }

    EHCI_InitailizeInterruptSchedule(DeviceData);

    for (i=0; i<USBEHCI_MAX_FRAME; i++) {

        PHCD_QUEUEHEAD_DESCRIPTOR qh;
        HW_32BIT_PHYSICAL_ADDRESS qhPhys;
        
        qh = EHCI_GetQueueHeadForFrame(DeviceData, i);

        qhPhys = qh->PhysicalAddress;
        SET_QH(qhPhys);
        
        *frameBase = qhPhys;
        frameBase++;
    }

    DeviceData->DummyQueueHeads = StaticQHs;
    DeviceData->DummyQueueHeadsPhys = StaticQHsPhys;

    StaticQHs+= sizeof(HCD_QUEUEHEAD_DESCRIPTOR)*USBEHCI_MAX_FRAME;
    StaticQHsPhys+= sizeof(HCD_QUEUEHEAD_DESCRIPTOR)*USBEHCI_MAX_FRAME;

    EHCI_AddDummyQueueHeads(DeviceData);
    
    // program the frame list
    WRITE_REGISTER_ULONG(&hcOp->PeriodicListBase,
        DeviceData->FrameListBasePhys);

    // write the async qh to the controller
    WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr, asyncHwQh.HwAddress);

    mpStatus = USBMP_STATUS_SUCCESS;

    return mpStatus;
}


VOID
EHCI_ReadUlongRegFlag(
     PDEVICE_DATA DeviceData,
     PUCHAR DebugString,
     PWCHAR FlagName,
     ULONG FlagNameSize,
     ULONG FlagBit
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    ULONG flag;

    // get SOF modify value from registry
    mpStatus =
        USBPORT_GET_REGISTRY_KEY_VALUE(DeviceData,
                                       TRUE, // software branch
                                       FlagName,
                                       FlagNameSize,
                                       &flag,
                                       sizeof(flag));

    // if this call fails we just use the default

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        if (flag) {
            SET_FLAG(DeviceData->Flags, FlagBit);
        }
        EHCI_KdPrint((DeviceData, 1, "'%s: %d \n",
                DebugString, flag));

    }
}

VOID
EHCI_GetRegistryParameters(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    EHCI_ReadUlongRegFlag(DeviceData,
            "Disable Chirp Support",
            CHIRP_DISABLE,
            sizeof(CHIRP_DISABLE),
            EHCI_DD_FLAG_NOCHIRP);

    EHCI_ReadUlongRegFlag(DeviceData,
            "Soft Error Retry Enable",
            SOFT_ERROR_RETRY_ENABLE,
            sizeof(SOFT_ERROR_RETRY_ENABLE),
            EHCI_DD_FLAG_SOFT_ERROR_RETRY);

    EHCI_ReadUlongRegFlag(DeviceData,
            "CC Handoff Disable",
            CC_DISABLE,
            sizeof(CC_DISABLE),
            EHCI_DD_FLAG_CC_DISABLE);

}


VOID
USBMPFN
EHCI_StopController(
     PDEVICE_DATA DeviceData,
     BOOLEAN HwPresent
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USBCMD cmd;
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    CONFIGFLAG configFlag;
    
    hcOp = DeviceData->OperationalRegisters;

    // clear the run bit
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    LOGENTRY(DeviceData, G, '_stp', cmd.ul, 0, 0);
    cmd.HostControllerRun = 0;
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

    // mask off all interrupts
    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
                         0);

    // set cc control of the hc ports to the companion 
    // controllers
    configFlag.ul = 0;
    configFlag.RoutePortsToEHCI = 0;
    WRITE_REGISTER_ULONG(&hcOp->ConfigFlag.ul, configFlag.ul);
    
}


VOID
USBMPFN
EHCI_TakePortControl(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    CONFIGFLAG configFlag;

    hcOp = DeviceData->OperationalRegisters;

    configFlag.ul = READ_REGISTER_ULONG(&hcOp->ConfigFlag.ul);
    EHCI_KdPrint((DeviceData, 0, "'EHCI - configflag %x\n", configFlag.ul)); 
    DeviceData->LastConfigFlag.ul = configFlag.ul;
     
    // set default port routing
    configFlag.ul = 0;
    configFlag.RoutePortsToEHCI = 1;
    WRITE_REGISTER_ULONG(&hcOp->ConfigFlag.ul, configFlag.ul);

}


USB_MINIPORT_STATUS
USBMPFN
EHCI_StartController(
     PDEVICE_DATA DeviceData,
     PHC_RESOURCES HcResources
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    PHC_CAPABILITIES_REGISTER hcCap = NULL;
    PUCHAR base;
    USBCMD cmd;
    HCLENGTHVERSION hcLengthVersion;
    ULONG capLength;
    ULONG hciVersion;
    CONFIGFLAG configFlag;
    UCHAR fladj; // fBIOS set frame length adjustment
    
    DeviceData->Sig = SIG_EHCI_DD;
    DeviceData->ControllerFlavor =
        HcResources->ControllerFlavor;
    DeviceData->DeviceStarted = FALSE;

    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &DeviceData->Vid,
        0,
        sizeof(DeviceData->Vid));

    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &DeviceData->Dev,
        2,
        sizeof(DeviceData->Dev));         

#if DBG
    if (AGERE(DeviceData)) {        
        EHCI_KdPrint((DeviceData, 0, "'EHCI Agere Controller Detected\n"));     
    } else if (NEC(DeviceData)) {        
        EHCI_KdPrint((DeviceData, 0, "'EHCI NEC Controller Detected\n"));  
    } else {
        EHCI_KdPrint((DeviceData, 0, "'EHCI Generic Controller Detected\n"));  
    }
#endif

    // get the frame length adjustment value set by the BIOS
    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &fladj,
        0x61,
        sizeof(fladj));   
        
    DeviceData->SavedFladj = fladj;        

    DeviceData->IsoEndpointListHead = NULL;
    
    if (EHCI_PastExpirationDate(DeviceData)) {
        return USBMP_STATUS_INIT_FAILURE;
    }

    // assume success
    mpStatus = USBMP_STATUS_SUCCESS;

    EHCI_ASSERT(DeviceData, HcResources->CommonBufferVa != NULL);
    // validate our resources
    if ((HcResources->Flags & (HCR_MEM_REGS | HCR_IRQ)) !=
        (HCR_MEM_REGS | HCR_IRQ)) {
        mpStatus = USBMP_STATUS_INIT_FAILURE;
    }

    base = HcResources->DeviceRegisters;

    hcCap = DeviceData->CapabilitiesRegisters =
       (PHC_CAPABILITIES_REGISTER) base;

    hcLengthVersion.ul = READ_REGISTER_ULONG(&hcCap->HcLengthVersion.ul);

    capLength = hcLengthVersion.HcCapLength;
    hciVersion = hcLengthVersion.HcVersion;

    EHCI_KdPrint((DeviceData, 1, "'EHCI CAPLENGTH = 0x%x\n", capLength));
    EHCI_KdPrint((DeviceData, 1, "'EHCI HCIVERSION = 0x%x\n", hciVersion));

    // set up or device data structure
    hcOp = DeviceData->OperationalRegisters =
        (PHC_OPERATIONAL_REGISTER) (base + capLength);

    EHCI_KdPrint((DeviceData, 1, "'EHCI mapped Operational Regs = %x\n", hcOp));
    EHCI_KdPrint((DeviceData, 1, "'EHCI mapped Capabilities Regs = %x\n", hcCap));

    EHCI_GetRegistryParameters(DeviceData);

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        // got resources and schedule
        // init the controller
        mpStatus = EHCI_InitializeHardware(DeviceData);
    }

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        // inialize static Queue Heads
        PUCHAR staticQHs;
        HW_32BIT_PHYSICAL_ADDRESS staticQHsPhys;

        // carve the common buffer block in to
        // static QueueHeads
        //
        // set up the schedule

        staticQHs = HcResources->CommonBufferVa;
        staticQHsPhys = HcResources->CommonBufferPhys;

        // set up the schedule
        mpStatus = EHCI_InitializeSchedule(DeviceData,
                                           staticQHs,
                                           staticQHsPhys);


    }

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        USBPORT_READ_CONFIG_SPACE(
            DeviceData,
            &fladj,
            0x61,
            sizeof(fladj));   

        if (fladj != DeviceData->SavedFladj) {
            TEST_TRAP();

            fladj = DeviceData->SavedFladj;
            USBPORT_WRITE_CONFIG_SPACE(
                DeviceData,
                &fladj,
                0x61,
                sizeof(fladj));  
        }
        
        // set default port routing
        configFlag.ul = 0;
        configFlag.RoutePortsToEHCI = 1;
        WRITE_REGISTER_ULONG(&hcOp->ConfigFlag.ul, configFlag.ul);

        DeviceData->LastConfigFlag.ul = configFlag.ul;
        
        // start the controller
        cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
        LOGENTRY(DeviceData, G, '_run', cmd.ul, 0, 0);
        cmd.HostControllerRun = 1;

        // set the interrupt threshold to maximum
        cmd.InterruptThreshold = 1;
        WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

        DeviceData->DeviceStarted = TRUE;

        if (HcResources->Restart) {
            USHORT p;
            // we have a restart, re-power the ports here so that 
            // we can hand of devices that are on the 1.1 bus
            EHCI_KdPrint((DeviceData, 0, "'Restart, power chirpable ports\n"));
            // power the ports
            for (p = 1; p <= DeviceData->NumberOfPorts; p++) {
                EHCI_RH_SetFeaturePortPower(DeviceData, p);
            } 

            // no poweron2powergood for EHCI root ports, wait 
            // 100 ms for port power stabilization
            // 100 ms minimum debiunce time
            USBPORT_WAIT(DeviceData, 200);

// bugbug this will keep some HS mass storage devices from failing after 
// hibernate, however it will significantly increase resume from hibernate 
// time. see bug #586818
// USBPORT_WAIT(DeviceData, 500);
            for (p = 1; p <= DeviceData->NumberOfPorts; p++) {
                EHCI_RH_ChirpRootPort(DeviceData, p);
            } 
            
        }            
        
    } else {

        DEBUG_BREAK(DeviceData);
    }

    return mpStatus;
}


VOID
EHCI_SuspendController(
     PDEVICE_DATA DeviceData
    )
{
    USBCMD cmd;
    USBSTS status;
    USBINTR intr;
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    ULONG i,p;    
    USBSTS irqStatus;

    hcOp = DeviceData->OperationalRegisters;
    // save all volatile regs from the core power well 
    
    // since we may loose power on the controller chip (not bus) 
    // the miniport is resposnible for saving HW state
    DeviceData->PeriodicListBaseSave =             
        READ_REGISTER_ULONG(&hcOp->PeriodicListBase);       
    DeviceData->AsyncListAddrSave = 
        READ_REGISTER_ULONG(&hcOp->AsyncListAddr);   
    DeviceData->SegmentSelectorSave = 
        READ_REGISTER_ULONG(&hcOp->SegmentSelector);   
    // preserve the state of the list enable bits
    DeviceData->CmdSave.ul = 
        READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);  

    // reset the PM chirp state flags for another pass at power 
    // management
    DeviceData, DeviceData->PortPMChirp == 0;

    // Save away the command register
    // DeviceData->SuspendCommandReg.us = 
    //    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);

    // clear the int on async advance doorbell
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    cmd.IntOnAsyncAdvanceDoorbell = 0;
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);
                         

    // Stop the controller
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    LOGENTRY(DeviceData, G, '_stp', cmd.ul, 0, 0);
    cmd.HostControllerRun = 0;
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

    // ack any interrupts that may be left over from the halt
    // process.  The controller should not generate any new 
    // interrupts when it is stopped. For some reason the NEC 
    // controller generates a doorbel interrupt on halt.

    // wait 1 microframe        
    KeStallExecutionProcessor(125);  
    irqStatus.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
    // just look at the IRQ status bits
    irqStatus.ul &= HcInterruptStatusMask;
    if (irqStatus.ul != 0)  {
        WRITE_REGISTER_ULONG(&hcOp->UsbStatus.ul, 
                             irqStatus.ul);
    }                         
    
    // mask off all interrupts now
    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
                         0);
    

    // Wait for the HC to halt
    // Note that according to the sepc if we don't halt in ms 
    // (16ms) the hardware is busted.
    for (i=0; i<10; i++) {
        status.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
        if (status.HcHalted) {
            break;
        }
        USBPORT_WAIT(DeviceData, 1);
    } 

    if (status.HcHalted != 1) {
        // hardware is f'ed up
        TEST_TRAP();
    }

    //if (!status.HCHalted) {
    //    
    //    // Can't get the HCHalted bit to stick, so reset the controller.
    //    command.GlobalReset = 1;
    //    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);
    //    
    //    USBPORT_WAIT(DeviceData, 10);
    //    
    //    command.GlobalReset = 0;
    //    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);
        
    //    // Re-enable interrupts, since they are zero'd out on reset.
    //    WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us, DeviceData->EnabledInterrupts.us);
    //    
    //}

    // enable the port chage interrupt, this allows us to wake 
    // in the selective suspend case
    intr.ul = READ_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul);
    intr.PortChangeDetect = 1;
    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul, intr.ul);
}


USB_MINIPORT_STATUS
EHCI_ResumeController(
     PDEVICE_DATA DeviceData
    )
{
    USBCMD cmd;
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    CONFIGFLAG configFlag;
    
    hcOp = DeviceData->OperationalRegisters;

    EHCI_KdPrint((DeviceData, 1, "'>EHCI_ResumeController\n"));

    // don't mess with handoff regs for now
    //configFlag.ul = 0;
    //configFlag.RoutePortsToEHCI = 1;
    //WRITE_REGISTER_ULONG(&hcOp->ConfigFlag.ul, configFlag.ul);

    // restore volitile regs
    //configFlag.ul = READ_REGISTER_ULONG(&hcOp->ConfigFlag.ul);
    configFlag.ul = DeviceData->LastConfigFlag.ul;
    if (configFlag.RoutePortsToEHCI == 0) {
        // we have a reset
        EHCI_KdPrint((DeviceData, 1, "'Routing bit has reset to 0\n"));

        configFlag.RoutePortsToEHCI = 1;
        DeviceData->LastConfigFlag.ul = configFlag.ul;
        WRITE_REGISTER_ULONG(&hcOp->ConfigFlag.ul, configFlag.ul);

        return USBMP_STATUS_HARDWARE_FAILURE;    
    }

    // restore volitile regs
    WRITE_REGISTER_ULONG(&hcOp->SegmentSelector, DeviceData->SegmentSelectorSave);       
    WRITE_REGISTER_ULONG(&hcOp->PeriodicListBase, DeviceData->PeriodicListBaseSave);       
    WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr, DeviceData->AsyncListAddrSave);       

    // start the controller
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    LOGENTRY(DeviceData, G, '_run', cmd.ul, 0, 0);
    cmd.HostControllerRun = 1;

    // restore volatile cmd bits
    cmd.AsyncScheduleEnable = DeviceData->CmdSave.AsyncScheduleEnable;
    cmd.PeriodicScheduleEnable = DeviceData->CmdSave.PeriodicScheduleEnable;
    cmd.InterruptThreshold = DeviceData->CmdSave.InterruptThreshold;
  
    
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul, 
                         DeviceData->EnabledInterrupts.ul);

    EHCI_KdPrint((DeviceData, 1, "'<EHCI_ResumeController\n"));

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_OpenEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;

    EndpointData->Sig = SIG_EP_DATA;
    // save a copy of the parameters
    EndpointData->Parameters = *EndpointParameters;
    EndpointData->Flags = 0;
    EndpointData->PendingTransfers = 0;

    switch (EndpointParameters->TransferType) {

    case Control:

        EndpointData->MaxPendingTransfers = 1;
        mpStatus = EHCI_OpenBulkOrControlEndpoint(
                DeviceData,
                TRUE,
                EndpointParameters,
                EndpointData);

        break;

    case Interrupt:

        mpStatus = EHCI_OpenInterruptEndpoint(
                    DeviceData,
                    EndpointParameters,
                    EndpointData);

        break;

    case Bulk:

        EndpointData->MaxPendingTransfers = 1;
        mpStatus = EHCI_OpenBulkOrControlEndpoint(
                DeviceData,
                FALSE,
                EndpointParameters,
                EndpointData);

        break;
        
    case Isochronous:

        if (EndpointParameters->DeviceSpeed == HighSpeed) {
            mpStatus = EHCI_OpenHsIsochronousEndpoint(
                        DeviceData,
                        EndpointParameters,
                        EndpointData);
        } else {
            mpStatus = EHCI_OpenIsochronousEndpoint(
                        DeviceData,
                        EndpointParameters,
                        EndpointData);
        }
        break;

    default:
        TEST_TRAP();
        mpStatus = USBMP_STATUS_NOT_SUPPORTED;
    }

    return mpStatus;
}


VOID
EHCI_CloseEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // nothing to do here
}


USB_MINIPORT_STATUS
EHCI_PokeEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG oldBandwidth;

    LOGENTRY(DeviceData, G, '_Pok', EndpointData,
        EndpointParameters, 0);

    switch(EndpointData->Parameters.TransferType) {
    case Interrupt:
    case Control:
    case Bulk:
        return EHCI_PokeAsyncEndpoint(DeviceData, 
                                      EndpointParameters, 
                                      EndpointData);    
    case Isochronous:
        return EHCI_PokeIsoEndpoint(DeviceData, 
                                    EndpointParameters, 
                                    EndpointData);   
    }

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_RebalanceEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,        
    PENDPOINT_DATA EndpointData
    ) 
/*++

Routine Description:

    compute how much common buffer we will need
    for this endpoint

Arguments:

Return Value:

--*/
{
    switch (EndpointParameters->TransferType) {
    case Interrupt:
        EHCI_RebalanceInterruptEndpoint(DeviceData,
                                        EndpointParameters,        
                                        EndpointData);
        break;
        
    case Isochronous:
        EHCI_RebalanceIsoEndpoint(DeviceData,
                                  EndpointParameters,        
                                  EndpointData);
        break;
    }        
}


USB_MINIPORT_STATUS
EHCI_QueryEndpointRequirements(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_REQUIREMENTS EndpointRequirements
    )
/*++

Routine Description:

    compute how much common buffer we will need
    for this endpoint

Arguments:

Return Value:

--*/
{


    switch (EndpointParameters->TransferType) {

    case Control:

        EndpointRequirements->MinCommonBufferBytes =
            sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
                TDS_PER_CONTROL_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

        EndpointRequirements->MaximumTransferSize =
            MAX_CONTROL_TRANSFER_SIZE;
        break;

    case Interrupt:

        EndpointRequirements->MinCommonBufferBytes =
            sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
                TDS_PER_INTERRUPT_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

        EndpointRequirements->MaximumTransferSize =
            MAX_INTERRUPT_TRANSFER_SIZE;

        break;

    case Bulk:

        //
        // TDS_PER_ENDPOINT limits the largest transfer we
        // can handle.
        //

        // TDS_PER_ENDPOINT TDs plus an ED
        EndpointRequirements->MinCommonBufferBytes =
            sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
                TDS_PER_BULK_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

        EndpointRequirements->MaximumTransferSize =
            MAX_BULK_TRANSFER_SIZE;
        break;

     case Isochronous:

        if (EndpointParameters->DeviceSpeed == HighSpeed) {
            EndpointRequirements->MinCommonBufferBytes =
                    USBEHCI_MAX_FRAME*sizeof(HCD_HSISO_TRANSFER_DESCRIPTOR);

            EndpointRequirements->MaximumTransferSize =
                MAX_HSISO_TRANSFER_SIZE;
        } else {
            // TDS_PER_ENDPOINT TDs plus an ED
            EndpointRequirements->MinCommonBufferBytes =
                    TDS_PER_ISO_ENDPOINT*sizeof(HCD_SI_TRANSFER_DESCRIPTOR);

            EndpointRequirements->MaximumTransferSize =
                MAX_ISO_TRANSFER_SIZE;
        }                
        break;        

    default:
        USBPORT_BUGCHECK(DeviceData);
    }

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_PollEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    switch(EndpointData->Parameters.TransferType) {

    case Control:
    case Bulk:
    case Interrupt:
        EHCI_PollAsyncEndpoint(DeviceData, EndpointData);
        break;
    case Isochronous:
        EHCI_PollIsoEndpoint(DeviceData, EndpointData);
        break;
    }
}


PHCD_TRANSFER_DESCRIPTOR
EHCI_AllocTd(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Allocate a TD from an endpoints pool

Arguments:

Return Value:

--*/
{
    ULONG i;
    PHCD_TRANSFER_DESCRIPTOR td;

    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if (!TEST_FLAG(td->Flags, TD_FLAG_BUSY)) {
            SET_FLAG(td->Flags, TD_FLAG_BUSY);
            LOGENTRY(DeviceData, G, '_aTD', td, 0, 0);
            EndpointData->FreeTds--;
            return td;
        }
    }

    // we should always find one
    EHCI_ASSERT(DeviceData, FALSE);
    USBPORT_BUGCHECK(DeviceData);
    
    return NULL;
}


VOID
EHCI_SetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATUS Status
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Bulk:
    case Interrupt:
        EHCI_SetAsyncEndpointStatus(DeviceData,
                                    EndpointData,
                                    Status);
        break;
    case Isochronous:
        // nothing to do for iso
        break;
        
    default:
        USBPORT_BUGCHECK(DeviceData);
    }
}


MP_ENDPOINT_STATUS
EHCI_GetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Bulk:
    case Interrupt:
        return EHCI_GetAsyncEndpointStatus(DeviceData,
                                           EndpointData);
        break;
    }

    // return RUNNING for iso
    
    return ENDPOINT_STATUS_RUN;
}


VOID
EHCI_SetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    LOGENTRY(DeviceData, G, '_ses', EndpointData, 0, State);

    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Bulk:
    case Interrupt:
        EHCI_SetAsyncEndpointState(DeviceData,
                                   EndpointData,
                                   State);
        break;
    case Isochronous:
        EHCI_SetIsoEndpointState(DeviceData,
                                 EndpointData,
                                 State);
        break;
    default:
        USBPORT_BUGCHECK(DeviceData);
    }

}


MP_ENDPOINT_STATE
EHCI_GetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MP_ENDPOINT_STATE currentState;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    // assume we are active
    currentState = ENDPOINT_ACTIVE;

    qh = EndpointData->QueueHead;

    // removed from schedule?
    if (!TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE)) {
        // yes
        currentState = TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_QH_REMOVED) ?
                ENDPOINT_REMOVE : ENDPOINT_PAUSE;
    }

    LOGENTRY(DeviceData, G, '_ges', EndpointData, 0, currentState);

    return currentState;
}


VOID
EHCI_PollController(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    if (NO_CHIRP(DeviceData)) {

        // bugbug this only works for one instance of
        // the controller
        static toggle = 0;
        USHORT p;
        PHC_OPERATIONAL_REGISTER hcOp;
        PORTSC port;

        hcOp = DeviceData->OperationalRegisters;

        if (toggle) {

            for (p= 1; p< DeviceData->NumberOfPorts+1; p++) {

                port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[p-1].ul);

                if (port.PortOwnedByCC == 0 &&
                    port.PortConnect == 0 &&
                    port.HighSpeedDevice == 0 &&
                    !TEST_BIT(DeviceData->HighSpeedDeviceAttached, p-1)) {

                    EHCI_OptumtuseratePort(DeviceData, p);
                }
            }
            toggle = 0;

        } else {

            USBPORT_INVALIDATE_ROOTHUB(DeviceData);
            toggle = 1;
        }
    }

    USBPORT_INVALIDATE_ROOTHUB(DeviceData);
}


USB_MINIPORT_STATUS
EHCI_SubmitTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    )
{
    USB_MINIPORT_STATUS mpStatus;

    // init the context
    RtlZeroMemory(TransferContext, sizeof(*TransferContext));
    TransferContext->Sig = SIG_EHCI_TRANSFER;
    TransferContext->UsbdStatus = USBD_STATUS_SUCCESS;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = TransferParameters;

    switch (EndpointData->Parameters.TransferType) {
    case Control:
        mpStatus =
            EHCI_ControlTransfer(DeviceData,
                                 EndpointData,
                                 TransferParameters,
                                 TransferContext,
                                 TransferSGList);
        break;
    case Interrupt:
        mpStatus =
            EHCI_InterruptTransfer(DeviceData,
                                 EndpointData,
                                 TransferParameters,
                                 TransferContext,
                                 TransferSGList);
        break;
    case Bulk:
        mpStatus =
            EHCI_BulkTransfer(DeviceData,
                              EndpointData,
                              TransferParameters,
                              TransferContext,
                              TransferSGList);
        break;
    default:
        TEST_TRAP();
    }

    return mpStatus;
}


VOID
EHCI_AbortTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_CONTEXT TransferContext,
    OUT PULONG BytesTransferred
    )
{
    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Interrupt:
    case Bulk:
        EHCI_AbortAsyncTransfer(DeviceData,
                                EndpointData,
                                TransferContext);
        break;
    default:
        EHCI_AbortIsoTransfer(DeviceData,
                              EndpointData,
                              TransferContext);
    }
}


USB_MINIPORT_STATUS
EHCI_PassThru (
     PDEVICE_DATA DeviceData,
     GUID *FunctionGuid,
     ULONG ParameterLength,
     OUT PVOID Parameters
    )
{
    PUCHAR p = Parameters;
    UCHAR pdkApi;
    ULONG portNumber;
    USB_MINIPORT_STATUS mpStatus;

    mpStatus = USBMP_STATUS_NOT_SUPPORTED;
    if (RtlEqualMemory(FunctionGuid, &GUID_USBPRIV_ROOTPORT_STATUS, sizeof(GUID)))
    {
        mpStatus = EHCI_RH_UsbprivRootPortStatus(DeviceData, 
                                              ParameterLength,
                                              Parameters);
    }
    
#if 0
    portNumber = *(p+1);

    mpStatus = USBMP_STATUS_NOT_SUPPORTED;

    // pdkApi - force full speed

    pdkApi = *p;
    switch (pdkApi) {
    // obtumtuserate the port as requested
    case 0:
        {
        PHC_OPERATIONAL_REGISTER hcOp;
        USHORT portNumber;
        PORTSC port;

        portNumber = *(p+1);
        hcOp = DeviceData->OperationalRegisters;

        // first power the port up
        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
        port.PortPower = 1;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul,
                port.ul);

        KeStallExecutionProcessor(10);        //stall for 10 microseconds

        EHCI_OptumtuseratePort(DeviceData, portNumber);

        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);

        SET_BIT(DeviceData->HighSpeedDeviceAttached, portNumber-1);

        // see if it worked
        if (port.ul == 0x1205) {
            mpStatus = USBMP_STATUS_SUCCESS;
        } else {
            mpStatus = USBMP_STATUS_FAILURE;
        }

        LOGENTRY(DeviceData, G, '_hsE', portNumber, mpStatus, port.ul);
        TEST_TRAP();
        }
        break;

    case 1:
        // force a connect change

        // indicate a port change condition to the hub
        SET_BIT(DeviceData->PortConnectChange, portNumber-1);

        break;
    }
#endif

    return mpStatus;
}

    

VOID
EHCI_SetEndpointDataToggle(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     ULONG Toggle
    )
/*++

Routine Description:

Arguments:

    Toggle is 0 or 1

Return Value:

--*/

{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    if (EndpointData->Parameters.TransferType == Control ||
        EndpointData->Parameters.TransferType == Isochronous) {

        // nothing to do for control and iso
        return;
    }

    qh = EndpointData->QueueHead;
    qh->HwQH.Overlay.qTD.Token.DataToggle = Toggle;

    LOGENTRY(DeviceData, G, '_stg', EndpointData, 0, Toggle);
}

VOID
EHCI_CheckController(
    PDEVICE_DATA DeviceData
    )
{
    if (DeviceData->DeviceStarted) {
        EHCI_HardwarePresent(DeviceData, TRUE);
    }
}    

// Beta versions of our miniport driver have a hard coded exp date

#ifdef NO_EXP_DATE
#define EXPIRATION_DATE     0
#else 
//Sep 1, 2001
//#define EXPIRATION_DATE     0x01c133406ab2406c

//Oct 24, 2001
//#define EXPIRATION_DATE     0x01c15cd5887bc884 

//Dec 31, 2001
//#define EXPIRATION_DATE     0x01c19251a68bfac0
#endif                        

BOOLEAN
EHCI_PastExpirationDate(
    PDEVICE_DATA DeviceData
    )
{
    LARGE_INTEGER  systemTime;

    KeQuerySystemTime(&systemTime);

    EHCI_KdPrint((DeviceData, 1, "system time: %x %x\n", systemTime.QuadPart));
    EHCI_KdPrint((DeviceData, 1, "exp system time: %x %x\n", EXPIRATION_DATE));

    if (EXPIRATION_DATE &&
        systemTime.QuadPart > EXPIRATION_DATE) {
        EHCI_KdPrint((DeviceData, 1, "driver expired"));
        return TRUE;
    }        

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\common.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    common.h

Abstract:

   common header for OHCI miniport

Environment:

    Kernel mode

Revision History:

    12-31-99 : created jdunn

--*/


#ifndef COMMON_H
#define COMMON_H


#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usb.h"
#include "usbhcdi.h"

#include "openhci.h"
#include "dbg.h"
#include "usbohci.h"

#endif //COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbohci\dbg.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug only functions

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
//OHCI_KdPrintX

#if DBG


ULONG
_cdecl
OHCI_KdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function. 

    calls the port driver print function

Arguments:

Return Value:


--*/    
{
    va_list list;
    int i;
    int arg[6];
    
    va_start(list, Format);
    for (i=0; i<6; i++) {
        arg[i] = va_arg(list, int);
    }            
    
    USBPORT_DBGPRINT(
        DeviceData, Level, Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\hcd\miniport\usbehci\usbehci.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    usbehci.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    1-1-00 : created

--*/

#ifndef   __EHCI_H__
#define   __EHCI_H__

#define NO_EXP_DATE

#define MASK_CHANGE_BITS(p)\
    do {\
    (p).OvercurrentChange = 0;\
    (p).PortEnableChange = 0;\
    (p).PortConnectChange = 0;\
    } while (0);

/*
    define some known busted hardware types
*/
#define AGERE(dd) ((dd)->Vid == 0x11c1 && (dd)->Dev == 0x5805) ? TRUE : FALSE

//#define LUCENT(dd) ((dd)->ControllerFlavor == EHCI_Lucent) ? TRUE : FALSE
#define NEC(dd) ((dd)->ControllerFlavor == EHCI_NEC) ? TRUE : FALSE

#define MU_960(dd) ((dd)->ControllerFlavor == EHCI_960MUlator) ? TRUE : FALSE

/*
    define resource consumption for endpoints types
*/

#define T_256K          0x00040000
#define T_64K           0x00010000
#define T_4K            0x00001000
#define T_4MB           0x00400000


// Control:
// largest possible transfer for control is 64k
// therefore we support up to 2 transfers of this
// size in HW.  Most control transfers are much
// smaller than this.
// NOTE: we MUST support at least one 64k transfer in
// HW since a single control transfer cannot be
// broken up.

#define MAX_CONTROL_TRANSFER_SIZE   T_64K
// worst case 64k control transfer 4 + status and
// setup + dummy  =  
#define TDS_PER_CONTROL_ENDPOINT        7


// Bulk:
#define MAX_BULK_TRANSFER_SIZE        T_4MB
// enough for 4 MB
#define TDS_PER_BULK_ENDPOINT           210

// Interrupt:
#define MAX_INTERRUPT_TRANSFER_SIZE  T_4K
// enough for up to 4 4k transfers + dummy
#define TDS_PER_INTERRUPT_ENDPOINT      5

// Isochronous:
#define MAX_ISO_TRANSFER_SIZE        T_256K
// 2 256 packet transfers *3k packet size, we can actually 
// handle more
#define MAX_HSISO_TRANSFER_SIZE         0x00180000
#define TDS_PER_ISO_ENDPOINT            32


// default size of frame list
#define USBEHCI_MAX_FRAME            1024

/*
    Registry Keys
*/

// Software Branch PDO Keys
#define CHIRP_DISABLE L"ChirpDisable"
#define SOFT_ERROR_RETRY_ENABLE L"SoftErrorRetryEnable"
#define CC_DISABLE L"CCDisable"


// Hardware Branch PDO Keys


// debug signatures
#define  SIG_HCD_IQH            'qi02'
#define  SIG_HCD_AQH            'qa02'
#define  SIG_HCD_QH             'hq02'
#define  SIG_HCD_DQH            'qd02'
#define  SIG_HCD_TD             'dt02'
#define  SIG_HCD_SITD           'dtIS'
#define  SIG_HCD_ITD            'dtIH'
#define  SIG_EP_DATA            'pe02'
#define  SIG_EHCI_TRANSFER      'rt02'
#define  SIG_EHCI_DD            'iche'
#define  SIG_DUMMY_QH           'hqmd'


#undef PDEVICE_DATA

typedef struct _TRANSFER_CONTEXT {

    ULONG Sig;
    ULONG PendingTds;
    PTRANSFER_PARAMETERS TransferParameters;
    USBD_STATUS UsbdStatus;
    ULONG BytesTransferred;
    ULONG XactErrCounter;
    // struct _HCD_TRANSFER_DESCRIPTOR *NextTransferTd;
    struct _ENDPOINT_DATA *EndpointData;

    //for ISO
    ULONG FrameComplete;
    LIST_ENTRY TransferLink;
    PMINIPORT_ISO_TRANSFER IsoTransfer;
    ULONG PendingPackets;
} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;


// HCD Endpoint Descriptor (contains the HW descriptor)

// values for HCD_QUEUEHEAD_DESCRIPTOR.Flags
#define EHCI_QH_FLAG_IN_SCHEDULE        0x00000001
#define EHCI_QH_FLAG_QH_REMOVED         0x00000002
#define EHCI_QH_FLAG_STATIC             0x00000004
#define EHCI_QH_FLAG_HIGHSPEED          0x00000008
#define EHCI_QH_FLAG_UPDATING           0x00000010


typedef struct _HCD_QUEUEHEAD_DESCRIPTOR {
   HW_QUEUEHEAD_DESCRIPTOR    HwQH;     // 40 dwords
   
   HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
   ULONG                      Sig;
   ULONG                      QhFlags;
   ULONG                      Ordinal;
   ULONG                      Period;       
   ULONG                      Reserved;
   
   MP_HW_POINTER              EndpointData;
   //MP_HW_POINTER              HcdTail;
   MP_HW_POINTER              NextQh;
   MP_HW_POINTER              PrevQh;
   MP_HW_POINTER              NextLink;

#ifdef _WIN64
   ULONG                      PadTo256[6];
#else
   ULONG                      PadTo256[6];
#endif
} HCD_QUEUEHEAD_DESCRIPTOR, *PHCD_QUEUEHEAD_DESCRIPTOR;

C_ASSERT((sizeof(HCD_QUEUEHEAD_DESCRIPTOR) == 160));

//
// HCD Transfer Descriptor (contains the HW descriptor)
//

#define ENDPOINT_DATA_PTR(p) ((struct _ENDPOINT_DATA *) (p).Pointer)
#define TRANSFER_CONTEXT_PTR(p) ((struct _TRANSFER_CONTEXT *) (p).Pointer)
#define TRANSFER_DESCRIPTOR_PTR(p) ((struct _HCD_TRANSFER_DESCRIPTOR *) (p).Pointer)
#define QH_DESCRIPTOR_PTR(p) ((struct _HCD_QUEUEHEAD_DESCRIPTOR *) (p).Pointer)
#define HW_PTR(p) ((UCHAR * ) (p).Pointer)
#define ISO_PACKET_PTR(p) ((struct _MINIPORT_ISO_PACKET *) (p).Pointer)
#define ISO_TRANSFER_PTR(p) ((struct _TRANSFER_CONTEXT *) (p).Pointer)


// values for HCD_TRANSFER_DESCRIPTOR.Flags

#define TD_FLAG_BUSY                0x00000001
#define TD_FLAG_XFER                0x00000002
//#define TD_FLAG_CONTROL_STATUS      0x00000004
#define TD_FLAG_DONE                0x00000008
#define TD_FLAG_SKIP                0x00000010
#define TD_FLAG_DUMMY               0x00000020


typedef struct _HCD_TRANSFER_DESCRIPTOR {
    HW_QUEUE_ELEMENT_TD        HwTD;      //64 (16 dwords)
    ULONG                      Sig;
    ULONG                      Flags;
    ULONG                      TransferLength;
    HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
    
    UCHAR                      Packet[8]; // space for setup packet data
    MP_HW_POINTER              EndpointData;
    MP_HW_POINTER              TransferContext;
    MP_HW_POINTER              NextHcdTD;
    MP_HW_POINTER              AltNextHcdTD;

    LIST_ENTRY                 DoneLink;
#ifdef _WIN64
    ULONG                      PadToX[30];
#else
    ULONG                      PadToX[32];
#endif
} HCD_TRANSFER_DESCRIPTOR, *PHCD_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) == 256));

typedef struct _HCD_TD_LIST {
    HCD_TRANSFER_DESCRIPTOR Td[1];
} HCD_TD_LIST, *PHCD_TD_LIST;

/*
    Structures used for iso see iso.c
*/

typedef struct _HCD_SI_TRANSFER_DESCRIPTOR {
    HW_SPLIT_ISOCHRONOUS_TD    HwTD;    //64 (16dwords)
    
    ULONG                      Sig;
    HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
    ULONG                      StartOffset;
    ULONG                      Reserved;
    
    MP_HW_POINTER              Packet;
    MP_HW_POINTER              Transfer;
    MP_HW_POINTER              NextLink;
#ifdef _WIN64    
    ULONG                      PadToX[6];
#else 
    ULONG                      PadToX[6];
#endif    
} HCD_SI_TRANSFER_DESCRIPTOR, *PHCD_SI_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HCD_SI_TRANSFER_DESCRIPTOR) == 128));


typedef struct _HCD_SITD_LIST {
    HCD_SI_TRANSFER_DESCRIPTOR Td[1];
} HCD_SITD_LIST, *PHCD_SITD_LIST;


typedef struct _HCD_HSISO_TRANSFER_DESCRIPTOR {
    HW_ISOCHRONOUS_TD          HwTD; // 128 (32dwords)
    
    ULONG                      Sig;
    HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
    ULONG                      HostFrame;
    ULONG                      Reserved;
    
    MP_HW_POINTER              FirstPacket;
    MP_HW_POINTER              Transfer;
    MP_HW_POINTER              NextLink;
#ifdef _WIN64    
    ULONG                      PadTo256[22]; 
#else 
    ULONG                      PadTo256[22];
#endif

} HCD_HSISO_TRANSFER_DESCRIPTOR, *PHCD_HSISO_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HCD_HSISO_TRANSFER_DESCRIPTOR) == 256));


typedef struct _HCD_HSISOTD_LIST {
    HCD_HSISO_TRANSFER_DESCRIPTOR Td[1];
} HCD_HSISOTD_LIST, *PHCD_HSISOTD_LIST;


/*
    Used for data structure that describes the interrupt
    schedule (see periodic.c)
*/
typedef struct _PERIOD_TABLE {
    UCHAR Period;
    UCHAR qhIdx;
    UCHAR InterruptScheduleMask;
} PERIOD_TABLE, *PPERIOD_TABLE;

#define EHCI_EDFLAG_HALTED           0x00000001
//#define EHCI_EDFLAG_FLUSHED          0x00000002
#define EHCI_EDFLAG_NOHALT           0x00000004

typedef struct _ENDPOINT_DATA {

    ULONG Sig;
    ENDPOINT_PARAMETERS Parameters;
    PHCD_QUEUEHEAD_DESCRIPTOR QueueHead;
    ULONG Flags;
    ULONG PendingTransfers;
    ULONG MaxPendingTransfers;

   // PHCD_TRANSFER_DESCRIPTOR HcdTailP;
    PHCD_TRANSFER_DESCRIPTOR HcdHeadP;

    PHCD_QUEUEHEAD_DESCRIPTOR StaticQH;
    PPERIOD_TABLE PeriodTableEntry;

    PHCD_TD_LIST TdList;
    PHCD_SITD_LIST SiTdList;
    PHCD_HSISOTD_LIST HsIsoTdList;
    
    ULONG TdCount;
    ULONG FreeTds;
    ULONG LastFrame;
    ULONG QhChkPhys;
    PVOID QhChk;
    
    LIST_ENTRY TransferList;
    LIST_ENTRY DoneTdList;
    MP_ENDPOINT_STATE State;
    struct _ENDPOINT_DATA *PrevEndpoint;
    struct _ENDPOINT_DATA *NextEndpoint;

    PHCD_TRANSFER_DESCRIPTOR DummyTd;
//    ULONG MaxErrorCount;

} ENDPOINT_DATA, *PENDPOINT_DATA;

#define EHCI_DD_FLAG_NOCHIRP                0x000000001
#define EHCI_DD_FLAG_SOFT_ERROR_RETRY       0x000000002
#define EHCI_DD_FLAG_CC_DISABLE             0x000000004

typedef struct _DEVICE_DATA {

    ULONG                       Sig;
    ULONG                       Flags;
    PHC_OPERATIONAL_REGISTER    OperationalRegisters;
    PHC_CAPABILITIES_REGISTER   CapabilitiesRegisters;

    USBINTR                     EnabledInterrupts;

    PHCD_QUEUEHEAD_DESCRIPTOR   AsyncQueueHead;

    USB_CONTROLLER_FLAVOR       ControllerFlavor;

    ULONG                       LastFrame;
    ULONG                       FrameNumberHighPart;

    ULONG                       PortResetChange;
    ULONG                       PortSuspendChange;
    ULONG                       PortConnectChange;
    ULONG                       PortPMChirp;

    ULONG                       IrqStatus;

    USHORT                      NumberOfPorts;
    USHORT                      PortPowerControl;


    PHCD_QUEUEHEAD_DESCRIPTOR   LockPrevQh;
    PHCD_QUEUEHEAD_DESCRIPTOR   LockNextQh;
    PHCD_QUEUEHEAD_DESCRIPTOR   LockQh;

    // both these are used for non-chirping devices
    // port state masks
    //ULONG                       PortConnectState;
    ULONG                       HighSpeedDeviceAttached;

    PHCD_QUEUEHEAD_DESCRIPTOR   StaticInterruptQH[65];

    PHW_32BIT_PHYSICAL_ADDRESS  FrameListBaseAddress;
    HW_32BIT_PHYSICAL_ADDRESS   FrameListBasePhys;

    PENDPOINT_DATA              IsoEndpointListHead;  
    PVOID                       DummyQueueHeads;
    HW_32BIT_PHYSICAL_ADDRESS   DummyQueueHeadsPhys;

    ULONG                       PeriodicListBaseSave;
    ULONG                       AsyncListAddrSave;
    ULONG                       SegmentSelectorSave;
    USBCMD                      CmdSave;

    USHORT                      Vid;
    USHORT                      Dev; 

    CONFIGFLAG                  LastConfigFlag;

    // we only need this for older revs of usbport 
    // that will call checkController after start fails
    BOOLEAN                     DeviceStarted;
    UCHAR                       SavedFladj;

    
    
} DEVICE_DATA, *PDEVICE_DATA;

#define CHIRP(dd) (!((dd)->Flags & EHCI_DD_FLAG_NOCHIRP))
#define NO_CHIRP(dd) ((dd)->Flags & EHCI_DD_FLAG_NOCHIRP)
#define SOFT_ERROR(dd) ((dd)->Flags & EHCI_DD_FLAG_SOFT_ERROR_RETRY)
#define CC_DISABLED(dd) ((dd)->Flags & EHCI_DD_FLAG_CC_DISABLE)

/*
    Callouts to port driver services
*/
extern USBPORT_REGISTRATION_PACKET RegistrationPacket;

#define USBPORT_DBGPRINT(dd, l, f, arg0, arg1, arg2, arg3, arg4, arg5) \
        RegistrationPacket.USBPORTSVC_DbgPrint((dd), (l), (f), (arg0), (arg1), \
            (arg2), (arg3), (arg4), (arg5))

#define USBPORT_GET_REGISTRY_KEY_VALUE(dd, branch, keystring, keylen, data, datalen) \
        RegistrationPacket.USBPORTSVC_GetMiniportRegistryKeyValue((dd), (branch), \
            (keystring), (keylen), (data), (datalen))

#define USBPORT_INVALIDATE_ROOTHUB(dd) \
        RegistrationPacket.USBPORTSVC_InvalidateRootHub((dd));

#define USBPORT_COMPLETE_TRANSFER(dd, ep, tp, status, length) \
        RegistrationPacket.USBPORTSVC_CompleteTransfer((dd), (ep), (tp), \
            (status), (length));

#define USBPORT_INVALIDATE_ENDPOINT(dd, ep) \
        RegistrationPacket.USBPORTSVC_InvalidateEndpoint((dd), (ep));

#define USBPORT_PHYSICAL_TO_VIRTUAL(addr, dd, ep) \
        RegistrationPacket.USBPORTSVC_MapHwPhysicalToVirtual((addr), (dd), (ep));

#define USBPORT_INVALIDATE_ROOTHUB(dd) \
        RegistrationPacket.USBPORTSVC_InvalidateRootHub((dd));

#define USBPORT_REQUEST_ASYNC_CALLBACK(dd, t, c, cl, f) \
        RegistrationPacket.USBPORTSVC_RequestAsyncCallback((dd), (t), \
            (c), (cl), (f));

#define USBPORT_WAIT(dd, t) \
        RegistrationPacket.USBPORTSVC_Wait((dd), (t));

#define USBPORT_BUGCHECK(dd) \
        RegistrationPacket.USBPORTSVC_BugCheck(dd)

#define USBPORT_COMPLETE_ISO_TRANSFER(dd, ep, t, iso) \
        RegistrationPacket.USBPORTSVC_CompleteIsoTransfer((dd), (ep), (t), \
            (iso));               

#define USBPORT_INVALIDATE_CONTROLLER(dd, s) \
        RegistrationPacket.USBPORTSVC_InvalidateController((dd), (s))

#define USBPORT_READ_CONFIG_SPACE(dd, b, o, l) \
        RegistrationPacket.USBPORTSVC_ReadWriteConfigSpace