fResBase = 0;

    /*
     * Determine if this is an .ICO/.CUR file or an .ANI file.
     */
    pnh = (LPNEWHEADER)pfi->pFileMap;
    if (*(LPDWORD)pnh == FOURCC_RIFF) {

        RTAG tag;

        /*
         * It's an ANICURSOR!
         * Seek back to beginning + 1 tag.
         */
        pfi->pFilePtr = pfi->pFileMap + sizeof(tag);

        /* check RIFF type for ACON */
        if (*(LPDWORD)pfi->pFilePtr != FOURCC_ACON) {
            return NULL;
        }
        pfi->pFilePtr += sizeof(DWORD);
        if (pfi->pFilePtr > pfi->pFileEnd) {
            return NULL;
        }

        /*
         * Ok, we have a ACON chunk.  Find the first ICON chunk and set
         * things up so it looks we've just loaded the header of a normal
         * .CUR file, then fall into the .CUR bits handling code below.
         */
        while (ReadTag(pfi, &tag)) {
            /*
             * Handle each chunk type.
             */
            if (tag.ckID == FOURCC_anih) {

                ANIHEADER anih;

                if (!ReadChunk(pfi, &tag, &anih)) {
                    return NULL;
                }

                if (!(anih.fl & AF_ICON) || (anih.cFrames == 0)) {
                    return NULL;
                }

                // If this ACON has more than one frame then go ahead
                // and create an ACON, otherwise just use the first
                // frame to create a normal ICON/CURSOR.

                if (anih.cFrames > 1) {

                    *pfAni = TRUE;
                    *prt = RT_CURSOR;
                    return(LoadAniIcon(pfi,
                                       RT_CURSOR,
                                       cxDesired,
                                       cyDesired,
                                       LR_flags));
                }

            } else if (tag.ckID == FOURCC_LIST) {
                LPDWORD pdwType = NULL;
                BOOL fOK = FALSE;
                /*
                 * If this is the fram list, then get the first icon out of it
                 */

                /* check LIST type for fram */

                if( tag.ckSize >= sizeof(DWORD) &&
                        (fOK = ReadFilePtr( pfi,
                                            &pdwType,
                                            sizeof(DWORD))) &&
                        *pdwType == FOURCC_fram) {

                    if (!ReadTag(pfi, &tag)) {
                        return NULL;
                    }

                    if (tag.ckID == FOURCC_icon) {
                        /*
                         * We've found what we're looking for.  Get current position
                         * in file to be used as the base from which the icon data
                         * offsets are offset from.
                         */
                        offResBase = (int)(pfi->pFilePtr - pfi->pFileMap);

                        /*
                         * Grab the header first, since the following code assumes
                         * it was read above.
                         */
                        ReadFilePtr(pfi, &pnh, sizeof(NEWHEADER));

                        /*
                         * Break out and let the icon loading/cursor creating code
                         * take it from here.
                         */
                        break;
                    } else {
                        SkipChunk(pfi, &tag);
                    }
                } else {
                    /*
                     * Something bad happened in the type read, if it was
                     * a file error then close and exit, otherwise just
                     * skip the rest of the chunk
                     */
                    if(!fOK) {
                        return NULL;
                    }
                    /*
                     * take the type we just read out of the tag size and
                     * skip the rest
                     */
                    tag.ckSize -= sizeof(DWORD);
                    SkipChunk(pfi, &tag);
                }
            } else {
                /*
                 * We're not interested in this chunk, skip it.
                 */
                SkipChunk(pfi, &tag);
            }
        }
    } else { // not a RIFF file.
        if ((pnh->ResType != FT_ICON) && (pnh->ResType != FT_CURSOR)) {
            return NULL;
        }
    }
    {
        PCURSORRESOURCE pcres;

        pcres = ReadIconGuts(pfi,
                             pnh,
                             offResBase,
                             prt,
                             cxDesired,
                             cyDesired,
                             LR_flags);

        if (pcres == NULL) {
            return NULL;
        }

        return ConvertDIBIcon((LPBITMAPINFOHEADER)pcres,
                              NULL,
                              pfi->pszName,
                              *prt == RT_ICON,
                              cxDesired,
                              cyDesired,
                              LR_flags);
    }
}


/***********************************************************************\
* ReadIconGuts
*
* Returns: a pointer to a locally allocated buffer extraced from the
*          given file that looks like a icon/acon resource.
*          Also returns the type of the icon (RT_ICON or RT_CURSOR)
*
*
* 8/23/1995 SanfordS   Documented
* 11/16/1995 SanfordS  Added LR_flags support
\***********************************************************************/
PCURSORRESOURCE ReadIconGuts(
    IN  PFILEINFO  pfi,
    IN  NEWHEADER *pnhBase,
    IN  int        offResBase,
    OUT LPWSTR    *prt,
    IN  int        cxDesired,
    IN  int        cyDesired,
    IN  DWORD      LR_flags)
{
    NEWHEADER *pnh;
    int i, Id;
    ICONFILERESDIR UNALIGNED *pird;
    PCURSORRESOURCE pcres;
    RESDIR UNALIGNED *prd;
    DWORD cb;
    HOTSPOTREC UNALIGNED *phs;
    LPBITMAPINFOHEADER pbih;

    /*
     * Construct a fake array of RESDIR entries using the info at the head
     * of the file.  Store the data offset in the idIcon WORD so it can be
     * returned by RtlGetIdFromDirectory.
     */
    pnh = (NEWHEADER *)UserLocalAlloc(0, sizeof(NEWHEADER) +
            (pnhBase->ResCount * (sizeof(RESDIR) + sizeof(HOTSPOTREC))));
    if (pnh == NULL)
        return NULL;

    *pnh = *pnhBase;
    prd = (RESDIR UNALIGNED *)(pnh + 1);
    phs = (HOTSPOTREC UNALIGNED *)(prd + pnhBase->ResCount);

    for (i = 0; i < (int)pnh->ResCount; i++, prd++) {
        /*
         * Read the resource directory from the icon file.
         */
        ReadFilePtrUnaligned(pfi, &pird, sizeof(ICONFILERESDIR));

        /*
         * Convert from the icon editor's resource directory format
         * to the post-RC.EXE format LookupIconIdFromDirectory expects.
         */
        prd->Icon.Width  = pird->bWidth;
        prd->Icon.Height = pird->bHeight;
        prd->Icon.reserved = 0;
        prd->BytesInRes = pird->dwDIBSize;
        prd->idIcon = (WORD)pird->dwDIBOffset;

        if (pnh->ResType == FT_ICON) {
            /*
             * 10/18/2000 - dwaynen
             *
             * For icons, this is really an ICONDIRENTRY (which has 
             * wPlanes and wBitCount fields that overlap xHotSpot and
             * yHotSpot!
             */
            prd->Icon.ColorCount = pird->bColorCount;
            prd->Planes     = pird->xHotspot;
            prd->BitCount   = pird->yHotspot;
        } else {
            /*
             * 10/18/2000 - dwaynen
             *
             * Hopefully, cursors will only have one image.  Otherwise,
             * our selection logic is gonna be screwed up because we don't
             * store the color bit depth!  I suppose we could dig out the
             * actual bitmap header and find the info there.  Consider doing
             * this if we ever want to support multi-resource cursors.
             */
            prd->Icon.ColorCount = 0;
            prd->Planes     = 0;
            prd->BitCount   = 0;
        }

        phs->xHotspot = pird->xHotspot;
        phs->yHotspot = pird->yHotspot;
        phs++;
    }

    *prt = pnhBase->ResType == FT_ICON ? RT_ICON : RT_CURSOR;
    Id = RtlGetIdFromDirectory((PBYTE)pnh,
                                *prt == RT_ICON,
                                cxDesired,
                                cyDesired,
                                LR_flags,
                                &cb);

    /*
     * Allocate for worst case (cursor).
     */
    pcres = (PCURSORRESOURCE)UserLocalAlloc(0,
            cb + FIELD_OFFSET(CURSORRESOURCE, bih));
    if (pcres == NULL) {
        goto CleanExit;
    }

    if (*prt == RT_CURSOR) {
        /*
         * Fill in hotspot info for cursors.
         */
        prd = (RESDIR UNALIGNED *)(pnh + 1);
        phs = (HOTSPOTREC UNALIGNED *)(prd + pnh->ResCount);

        for( i = 0; i < pnh->ResCount; i++ ) {
            if (prd[i].idIcon == (WORD)Id) {
                pcres->xHotspot = phs[i].xHotspot;
                pcres->yHotspot = phs[i].yHotspot;
                break;
            }
        }

        if (i == pnh->ResCount) {
            pcres->xHotspot = pird->xHotspot;
            pcres->yHotspot = pird->yHotspot;
        }
        pbih = &pcres->bih;
    } else {
        pbih = (LPBITMAPINFOHEADER)pcres;
    }

    /*
     * Read in the header information into pcres.
     */
    pfi->pFilePtr = pfi->pFileMap + offResBase + Id;
    if (!ReadFilePtrCopy(pfi, pbih, cb)) {
        UserLocalFree(pnh);
        UserLocalFree(pcres);
        return NULL;
    }


CleanExit:
    UserLocalFree(pnh);
    return pcres;
}


/***************************************************************************\
* CreateAniIcon
*
* For now, CreateAniIcon copies the jif rate table and the sequence table
* but not the CURSOR structs.  This is ok as long as this routine is
* internal only.
*
* History:
* 10-02-91 DarrinM      Created.
\***************************************************************************/

HCURSOR CreateAniIcon(
    LPCWSTR pszName,
    LPWSTR  rt,
    int     cicur,
    DWORD   *aicur,
    int     cpcur,
    HCURSOR *ahcur,
    JIF     jifRate,
    PJIF    ajifRate,
    BOOL    fPublic)
{
    HCURSOR hacon;
    CURSORDATA acon;
    DWORD cbacon;
    HCURSOR *ahcurT;             // Array of image frame pointers
    DWORD *aicurT;               // Array of frame indices (sequence table)
    PJIF ajifRateT;              // Array of time offsets
    int i;

    /*
     * Start by allocating space for the ACON structure and the ahcur and
     * ajifRate arrays.
     */
    hacon = (HCURSOR)NtUserCallOneParam(fPublic,
                                        SFI__CREATEEMPTYCURSOROBJECT);
    if (hacon == NULL)
        return NULL;

    /*
     * Save a couple LocalAlloc calls by allocating the memory needed for
     * the CURSOR, JIF, and SEQ arrays at once.
     */
    RtlZeroMemory(&acon, sizeof(acon));
    cbacon = (cpcur * sizeof(HCURSOR)) +
            (cicur * sizeof(JIF)) + (cicur * sizeof(DWORD));
    ahcurT = (HCURSOR *)UserLocalAlloc(HEAP_ZERO_MEMORY, cbacon);
    if (ahcurT == NULL) {
        NtUserDestroyCursor((HCURSOR)hacon, CURSOR_ALWAYSDESTROY);
        return NULL;
    }
    acon.aspcur = (PCURSOR *)ahcurT;

    /*
     * Set up work pointers
     */
    ajifRateT = (PJIF)((PBYTE)ahcurT + (cpcur * sizeof(HCURSOR)));
    aicurT = (DWORD *)((PBYTE)ajifRateT + (cicur * sizeof(JIF)));

    /*
     * Save offsets to arrays to make copying them to the server
     * easier.
     */
    acon.ajifRate = (PJIF)(cpcur * sizeof(HCURSOR));
    acon.aicur = (KPDWORD)((KPBYTE)acon.ajifRate + (cicur * sizeof(JIF)));

    acon.cpcur = cpcur;
    acon.cicur = cicur;

    acon.CURSORF_flags = CURSORF_ACON;

    /*
     * Store this information away so we can identify
     * repeated calls to LoadCursor/Icon for the same
     * resource type/id.
     */
    acon.rt = PTR_TO_ID(rt);
    acon.lpModName = szUSER32;
    acon.lpName = (LPWSTR)pszName;

    /*
     * Make a private copy of the cursor pointers and the animation rate table.
     */
    for (i = 0; i < cpcur; i++) {
        ahcurT[i] = ahcur[i];
//        ahcurT[i]->fPointer |= PTRI_ANIMATED;   // if GDI needs it

    }

    for (i = 0; i < cicur; i++) {

        /*
         * If constant rate, initialize the rate table to a single value.
         */
        if (ajifRate == NULL)
            ajifRateT[i] = jifRate;
        else
            ajifRateT[i] = ajifRate[i];

        /*
         * If no sequence table then build a unity map to the cursor table.
         */
        if (aicur == NULL)
            aicurT[i] = i;
        else
            aicurT[i] = aicur[i];
    }

    /*
     * Stuff acon data into the cursor
     */
    if (!_SetCursorIconData(hacon, &acon)) {
        NtUserDestroyCursor(hacon, CURSOR_ALWAYSDESTROY);
        hacon = NULL;
    }
    UserLocalFree(ahcurT);

    return hacon;
}


/***************************************************************************\
* ReadIconFromFileMap
*
* LATER: Error handling.
*
* History:
* 12-21-91 DarrinM      Created.
\***************************************************************************/

HCURSOR ReadIconFromFileMap(
    PFILEINFO   pfi,
    int         cbSize,   // used to seek past this chunk in case of error
    DWORD       cxDesired,
    DWORD       cyDesired,
    DWORD       LR_flags)
{
    PCURSORRESOURCE pcres;
    HCURSOR         hcur = NULL;
    LPNEWHEADER     pnh;
    int             offResBase;
    LPWSTR          rt;

    /*
     * Get current position in file to be used as the base from which
     * the icon data offsets are offset from.
     */
    offResBase = (int)(pfi->pFilePtr - pfi->pFileMap);

    /*
     * Read the .ICO/.CUR data's header.
     */
    ReadFilePtr(pfi, &pnh, sizeof(NEWHEADER));

    pcres = ReadIconGuts(pfi,
                         pnh,
                         offResBase,
                         &rt,
                         cxDesired,
                         cyDesired,
                         LR_flags);

    if (pcres != NULL) {
        hcur = (HCURSOR)ConvertDIBIcon((LPBITMAPINFOHEADER)pcres,
                                       NULL,
                                       NULL,
                                       (rt == RT_ICON),
                                       cxDesired,
                                       cyDesired,
                                       LR_ACONFRAME | LR_flags);

        UserLocalFree(pcres);
    }

    /*
     * Seek to the end of this chunk, regardless of our current position.
     */
    pfi->pFilePtr = pfi->pFileMap + ((offResBase + cbSize + 1) & (~1));

    return hcur;
}


/***************************************************************************\
* LoadAniIcon
*
*   Loads an animatied cursor from a RIFF file.  The RIFF file format for
*   animated cursors looks like this:
*
*   RIFF( 'ACON'
*       LIST( 'INFO'
*           INAM( <name> )
*           IART( <artist> )
*       )
*       anih( <anihdr> )
*       [rate( <rateinfo> )  ]
*       ['seq '( <seq_info> )]
*   LIST( 'fram' icon( <icon_file> ) ... )
*   )
*
*
* History:
* 10-02-91 DarrinM      Created.
* 03-17-93 JonPa        Rewrote to use RIFF format instead of RAD
* 04-22-93 JonPa        Finalized RIFF format (changed from ANI to ACON etc)
* 11/16/1995 SanfordS   Added LR_flags support.
\***************************************************************************/

HICON LoadAniIcon(
    IN PFILEINFO pfi,
    IN LPWSTR    rt,
    IN DWORD     cxDesired,
    IN DWORD     cyDesired,
    IN DWORD     LR_flags)
{
    int cpcur, ipcur = 0, i, cicur;
    ANIHEADER anih;
    ANIHEADER *panih = NULL;
    HICON hacon = NULL;
    HCURSOR *phcur = NULL;
    JIF jifRate, *pjifRate;
    RTAG tag;
    DWORD *picur;

    /*
     * Position to the beginning of the file.
     */
    pfi->pFilePtr = pfi->pFileMap + sizeof(tag);

#if DBG
    if ((ULONG_PTR)pfi->pFileEnd != ((ULONG_PTR)(pfi->pFileMap + sizeof (RTAG) + ((RTAG *)(pfi->pFileMap))->ckSize + 1) & ~1)) {
        RIPMSG2(RIP_WARNING, "LoadAniIcon: First RIFF chunk has invalid ckSize. Actual:%#lx Expected:%#lx",
                ((RTAG *)(pfi->pFileMap))->ckSize, (pfi->pFileEnd - pfi->pFileMap - sizeof(RTAG)) & ~1);
    }
#endif

    /* read the chunk type */
    if(!ReadFilePtrCopy(pfi,
                        &tag.ckID,
                        sizeof(tag.ckID))) {
        goto laiFileErr;
    }

    if (tag.ckID != FOURCC_ACON)
        goto laiFileErr;

    /* look for 'anih', 'rate', 'seq ', and 'icon' chunks */
    while( ReadTag(pfi, &tag)) {

        switch( tag.ckID ) {
        case FOURCC_anih:
            if (!ReadChunk(pfi, &tag, &anih))
                goto laiFileErr;

            if (!(anih.fl & AF_ICON) || (anih.cFrames == 0))
                goto laiFileErr;

            /*
             * Allocate space for the ANIHEADER, HCURSOR array and a
             * rate table (in case we run into one later).
             */
            cpcur = anih.cFrames;
            cicur = anih.cSteps;
            panih = (PANIHEADER)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(ANIHEADER));

            if (panih == NULL)
                goto laiFileErr;

            phcur = UserLocalAlloc(HEAP_ZERO_MEMORY, cpcur * sizeof(HCURSOR) + cicur * sizeof(JIF) + cicur * sizeof(DWORD));
            UserAssert(phcur == NATURAL_ALIGNED_PTR(HCURSOR, phcur));
            if (phcur == NULL) {
                goto laiFileErr;
            }

            pjifRate = NULL;
            picur = NULL;

            *panih = anih;
            jifRate = panih->jifRate;
            break;


        case FOURCC_rate:
            /*
             * If we find a rate chunk, read it into its preallocated
             * space.
             */
            pjifRate = (PJIF)((PBYTE)phcur + cpcur * sizeof(HCURSOR));
            UserAssert(pjifRate == NATURAL_ALIGNED_PTR(JIF, pjifRate));
            if(!ReadChunk(pfi, &tag, (PBYTE)pjifRate))
                goto laiFileErr;
            break;


        case FOURCC_seq:
            /*
             * If we find a seq chunk, read it into its preallocated
             * space.
             */
            picur = (DWORD *)((PBYTE)phcur + cpcur * sizeof(HCURSOR) +
                    cicur * sizeof(JIF));
            UserAssert(picur == NATURAL_ALIGNED_PTR(DWORD, picur));
            if(!ReadChunk(pfi, &tag, (PBYTE)picur))
                goto laiFileErr;
            break;


        case FOURCC_LIST:
            {
                DWORD cbChunk = (tag.ckSize + 1) & ~1;

                /*
                 * See if this list is the 'fram' list of icon chunks
                 */
                if(!ReadFilePtrCopy(pfi, &tag.ckID, sizeof(tag.ckID))) {
                    goto laiFileErr;
                }

                cbChunk -= sizeof(tag.ckID);

                if (tag.ckID != FOURCC_fram) {
                    /*
                     * Not the fram list (probably the INFO list).  Skip
                     * the rest of this chunk.  (Don't forget that we have
                     * already skipped one dword!)
                     */
                    tag.ckSize = cbChunk;
                    SkipChunk(pfi, &tag);
                    break;
                }

                while(cbChunk >= sizeof(tag)) {
                    if (!ReadTag(pfi, &tag))
                        goto laiFileErr;

                    cbChunk -= sizeof(tag);

                    if(tag.ckID == FOURCC_icon) {

                        /*
                         * Ok, load the icon/cursor bits, create a cursor from
                         * them, and save a pointer to it away in the ACON
                         * cursor pointer array.
                         */
                        phcur[ipcur] = ReadIconFromFileMap(pfi,
                                                           tag.ckSize,
                                                           cxDesired,
                                                           cyDesired,
                                                           LR_flags);

                        if (phcur[ipcur] == NULL) {
                            for (i = 0; i < ipcur; i++)
                                NtUserDestroyCursor(phcur[i], 0);
                            goto laiFileErr;
                        }

                        ipcur++;
                    } else {
                        /*
                         * Unknown chunk in fram list, just ignore it
                         */
                        SkipChunk(pfi, &tag);
                    }

                    cbChunk -= (tag.ckSize + 1) & ~1;
                }
            }
            break;

        default:
            /*
             * We're not interested in this chunk, skip it.
             */
            if(!SkipChunk(pfi, &tag))
                goto laiFileErr;
            break;

        }

    }

    /*
     * Sanity check the count of frames so we won't fault trying
     * to select a nonexistant cursor
     */
    if (cpcur != ipcur) {
        RIPMSG2(RIP_WARNING, "LoadAniIcon: Invalid number of frames; Actual:%#lx Expected:%#lx",
                ipcur, cpcur);
        for (i = 0; i < ipcur; i++)
            NtUserDestroyCursor(phcur[i], CURSOR_ALWAYSDESTROY);
        goto laiFileErr;
    }



    if (cpcur != 0)
        hacon = CreateAniIcon(pfi->pszName,
                              rt,
                              cicur,
                              picur,
                              cpcur,
                              phcur,
                              jifRate,
                              pjifRate,
                              LR_flags & LR_GLOBAL);

laiFileErr:

#if DBG
    if (hacon == NULL) {
        RIPMSG0(RIP_WARNING, "LoadAniIcon: Invalid icon data format");
    }
#endif

    if (panih != NULL)
        UserLocalFree(panih);

    if (phcur != NULL) {
        UserLocalFree(phcur);
    }

    return hacon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\umpdproxy\umpdproxy.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    userver.c

Abstract:

    User Mode Server Test program for the LPC subcomponent of the NTOS project

Author:

    Steve Wood (stevewo) 28-Aug-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <wingdip.h>
#include <winddi.h>
#include <w32w64.h>
#include <w32wow64.h>
//#include <gdisplp.h>
#include <winspool.h>
#include <umpd.h>

#define PORT_NAME L"\\RPC Control\\UmpdProxy"

#define VERBOSE 1

#if defined(_IA64_)
#define RtlHandleToChar(a,b,c,d) RtlLargeIntegerToChar((PLARGE_INTEGER)&(a),(b),(c),(d))
#else
#define RtlHandleToChar(a,b,c,d) RtlIntegerToChar((ULONG)(a),(b),(c),(d))
#endif

UNICODE_STRING PortName;

char * LpcMsgTypes[] = {
    "** INVALID **",
    "LPC_REQUEST",
    "LPC_REPLY",
    "LPC_DATAGRAM",
    "LPC_LOST_REPLY",
    "LPC_PORT_CLOSED",
    "LPC_CLIENT_DIED",
    "LPC_EXCEPTION",
    "LPC_DEBUG_EVENT",
    "LPC_ERROR_EVENT",
    "LPC_CONNECTION_REQUEST",
    NULL
};

SECURITY_QUALITY_OF_SERVICE DynamicQos = {
    SecurityImpersonation,
    SECURITY_DYNAMIC_TRACKING,
    TRUE
    };

#define TLPC_MAX_MSG_DATA_LENGTH 16

PCH   ClientMemoryBase = 0;
SIZE_T ClientMemorySize = 0;

typedef struct _PAGE {
    CHAR Data[ 4096 ];
} PAGE, *PPAGE;

typedef struct _PROXYMSG {
    PORT_MESSAGE    h;
    ULONG           cjIn;
    PVOID           pvIn;
    ULONG           cjOut;
    PVOID           pvOut;
} PROXYMSG, *PPROXYMSG;

typedef ULONG (*GdiPrinterThunkProc) (UMTHDR*,PVOID,ULONG);

GdiPrinterThunkProc gGdiPrinterThunkProc = NULL;

void
HandleRequest(
    PPROXYMSG   Msg
    )
{
    ULONG i;
    ULONG ClientIndex;
    ULONG cbData = Msg->h.u1.s1.DataLength;
    ULONG Context;
    PULONG ServerMemoryPtr;
    PULONG ClientMemoryPtr;
    ULONG ExpectedContext;
    BOOLEAN Result;

    assert(Msg->h.u2.s2.Type == LPC_REQUEST);

    if (cbData == (sizeof(*Msg) - sizeof(Msg->h)) && gGdiPrinterThunkProc != NULL)
    {
        UMTHDR *    hdr = (UMTHDR*) Msg->pvIn;
        PVOID       pvOut = Msg->pvOut;
        ULONG       cjOut = Msg->cjOut;
        HINSTANCE   hInst;

        fprintf( stderr, "handling thunk %d\n", hdr->ulType);
        gGdiPrinterThunkProc(hdr, pvOut, cjOut);
    
    }

#if VERBOSE
    fprintf( stderr, "request ok\n" );
#endif

}

BOOLEAN
ShowHandleOrStatus(
    NTSTATUS Status,
    HANDLE Handle
    )
{
    if (NT_SUCCESS( Status )) {
        fprintf( stderr, " - Handle = 0x%p\n", Handle );
        return( TRUE );
        }
    else {
        fprintf( stderr, " - *** FAILED *** Status == %X\n", Status );
        return( FALSE );
        }
}


BOOLEAN
ShowStatus(
    NTSTATUS Status
    )
{
    if (NT_SUCCESS( Status )) {
        fprintf( stderr, " - success\n" );
        return( TRUE );
        }
    else {
        fprintf( stderr, " - *** FAILED *** Status == %X\n", Status );
        return( FALSE );
        }
}

PCH EnterString = ">>>>>>>>>>";
PCH InnerString = "||||||||||";
PCH LeaveString = "<<<<<<<<<<";

VOID
EnterThread(
    PSZ ThreadName,
    LPVOID Context
    )
{
    fprintf( stderr, "Entering %s thread, Context = 0x%p\n",
             ThreadName,
             Context
           );
}

#define MAX_REQUEST_THREADS 9
#define MAX_CONNECTIONS 4

HANDLE ServerConnectionPortHandle;
HANDLE ServerThreadHandles[ MAX_REQUEST_THREADS ];
DWORD  ServerThreadClientIds[ MAX_REQUEST_THREADS ];

HANDLE ServerClientPortHandles[ MAX_CONNECTIONS ];
ULONG CountServerClientPortHandles = 0;
ULONG CountClosedServerClientPortHandles = 0;

BOOLEAN TestCallBacks;

#define kUmpdConnectionMagic    0x12340123

typedef struct UmpdConnection
{
    struct UmpdConnection *     next;
    ULONG                       magic;
    HANDLE                      port;
} UmpdConnection;

UmpdConnection gUmpdConnectionList;

void
UmpdConnectionList_Init(void)
{
    gUmpdConnectionList.next = NULL;
}

UmpdConnection *
UmpdConnectionList_New(void)
{
    UmpdConnection * uc;

    uc = (UmpdConnection *) malloc(sizeof(UmpdConnection));

    if(uc != NULL)
    {
        uc->next = gUmpdConnectionList.next;
        uc->magic = kUmpdConnectionMagic;
        gUmpdConnectionList.next = uc;

        fprintf(stderr, "added UmpdConnection %p\n", uc);
    }
    else
    {
        fprintf(stderr, "failed adding UmpdConnection\n");
    }

    return uc;
}

void
UmpdConnectionList_Remove(UmpdConnection * uc)
{
    if(uc->magic != kUmpdConnectionMagic)
    {
        fprintf(stderr, "bad connection magic when removing\n");
    }
    else
    {
        UmpdConnection * prev = &gUmpdConnectionList;

        while(prev != NULL && prev->next != NULL)
        {
            if(prev->next == uc)
            {
                prev->next = uc->next;
                free(uc);
                fprintf(stderr, "removed UmpdConnection %p\n", uc);
                return;
            }

            prev = prev->next;
        }

        fprintf( stderr, "failed to find UmpdConnection %p\n", uc );
    }

}


void
ServerHandleConnectionRequest(
    IN PPROXYMSG Msg
    )
{
    BOOLEAN             AcceptConnection;
    LPSTR               ConnectionInformation;
    ULONG               ConnectionInformationLength;
    NTSTATUS            Status;
#if 0
    PORT_VIEW           ServerView;
#endif
    REMOTE_PORT_VIEW    ClientView;
    ULONG               i;
    PULONG              p;
    UmpdConnection *    uc;

    ConnectionInformation = (LPSTR)&Msg->cjIn;
    ConnectionInformationLength = Msg->h.u1.s1.DataLength;
    AcceptConnection = FALSE;
    fprintf( stderr, "\nConnection Request Received from CLIENT_ID 0x%08p.0x%08p:\n",
              Msg->h.ClientId.UniqueProcess,
              Msg->h.ClientId.UniqueThread
            );
    fprintf( stderr, "    MessageId: %ld\n",
              Msg->h.MessageId
            );
    fprintf( stderr, "    ClientViewSize: 0x%08lx\n",
              Msg->h.ClientViewSize
            );
    fprintf( stderr, "    ConnectionInfo: (%ld) '%.*s'\n",
              ConnectionInformationLength,
              ConnectionInformationLength,
              (PSZ)&ConnectionInformation[0]
            );

    ClientView.Length = sizeof( ClientView );
    ClientView.ViewSize = 0;
    ClientView.ViewBase = 0;

    uc = UmpdConnectionList_New();

    if (uc == NULL)
    {
        AcceptConnection = FALSE;
    }
    else
    {
        AcceptConnection = TRUE;
    }
#if 0
    if (AcceptConnection)
    {
        LARGE_INTEGER MaximumSize;

        fprintf( stderr, "Creating Port Memory Section" );
        MaximumSize.QuadPart = 0x4000;
        Status = NtCreateSection( &ServerView.SectionHandle,
                                  SECTION_MAP_READ | SECTION_MAP_WRITE,
                                  NULL,
                                  &MaximumSize,
                                  PAGE_READWRITE,
                                  SEC_COMMIT,
                                  NULL
                                );

        if (ShowHandleOrStatus( Status, ServerView.SectionHandle )) {
            ServerView.Length = sizeof( ServerView );
            ServerView.SectionOffset = 0;
            ServerView.ViewSize = 0x4000;
            ServerView.ViewBase = 0;
            ServerView.ViewRemoteBase = 0;
            }
        else {
            AcceptConnection = FALSE;
            }
        }
#endif
    fprintf( stderr, "Server calling NtAcceptConnectPort( AcceptConnection = %ld )\n",
              AcceptConnection
            );

    if (AcceptConnection) {
        strcpy( ConnectionInformation, "Server Accepting Connection\n" );
        }
    else {
        strcpy( ConnectionInformation, "Server Rejecting Connection\n" );
        }

    Msg->h.u1.s1.DataLength = strlen( ConnectionInformation ) + 1;
    Msg->h.u1.s1.TotalLength = Msg->h.u1.s1.DataLength + sizeof( Msg->h );

    Status = NtAcceptConnectPort( &uc->port,
                                  (PVOID) uc,
                                  &Msg->h,
                                  AcceptConnection,
                                  0,//&ServerView,
                                  &ClientView
                                );

    if (ShowHandleOrStatus( Status, uc->port )) {
#if 0
        fprintf( stderr, "    ServerView: Base=%p, Size=%lx, RemoteBase: %p\n",
                  ServerView.ViewBase,
                  ServerView.ViewSize,
                  ServerView.ViewRemoteBase
                );
#endif
        fprintf( stderr, "    ClientView: Base=%p, Size=%lx\n",
                  ClientView.ViewBase,
                  ClientView.ViewSize
                );

        ClientMemoryBase = ClientView.ViewBase;
        ClientMemorySize = ClientView.ViewSize;
//        ClientMemoryBase = ServerView.ViewRemoteBase;
//        ClientMemoryDelta = ClientMemoryBase - ServerMemoryBase;

#if 0
        p = (PULONG)(ClientView.ViewBase);
        i =ClientView.ViewSize;
        while (i) {
            *p = (ULONG)p;
            fprintf( stderr, "Server setting ClientView[ %lx ] = %lx\n",
                      p,
                      *p
                    );
            p += (0x1000/sizeof(ULONG));
            i -= 0x1000;
            }

        p = (PULONG)(ServerView.ViewBase);
        i = ServerView.ViewSize;

        while (i)
        {
            *p = (ULONG)p - ServerMemoryDelta;
            fprintf( stderr, "Server setting ServerView[ %lx ] = %lx\n",
                      p,
                      *p
                    );
            p += (0x1000/sizeof(ULONG));
            i -= 0x1000;
        }
#endif

        Status = NtCompleteConnectPort( uc->port );

    }

}

DWORD
ServerThread(
    LPVOID Context
    )
{
    NTSTATUS        Status;
    CHAR            ThreadName[ 64 ];
    PROXYMSG        Msg;
    PPROXYMSG       ReplyMsg;
    HANDLE          ReplyPortHandle;
    PVOID           PortContext;
    PTEB Teb = NtCurrentTeb();

    Teb->ActiveRpcHandle = NULL;

    strcpy( ThreadName, "Server Thread Id: " );
    RtlHandleToChar( Teb->ClientId.UniqueProcess, 16, 9,
                    ThreadName + strlen( ThreadName )
                  );
    strcat( ThreadName, "." );
    RtlHandleToChar( Teb->ClientId.UniqueThread, 16, 9,
                    ThreadName + strlen( ThreadName )
                  );

    EnterThread( ThreadName, Context );

    ReplyMsg = NULL;
    ReplyPortHandle = ServerConnectionPortHandle;
    
    while (TRUE) {

#if VERBOSE
        fprintf( stderr, "%s waiting for message...\n", ThreadName );
#endif

        Status = NtReplyWaitReceivePort( ReplyPortHandle,
                                         (PVOID*)&PortContext,
                                         (PPORT_MESSAGE)ReplyMsg,
                                         (PPORT_MESSAGE)&Msg
                                       );

        
        ReplyMsg = NULL;
        
        ReplyPortHandle = ServerConnectionPortHandle;
        
#if VERBOSE
        fprintf( stderr, "%s Receive (%s)  Id: %u\n", ThreadName, LpcMsgTypes[ Msg.h.u2.s2.Type ], Msg.h.MessageId );
#endif
        
        if (!NT_SUCCESS( Status ))
        {
            fprintf( stderr, " (Status == %08x)\n", Status );
        }
        else if (Msg.h.u2.s2.Type == LPC_CONNECTION_REQUEST)
        {
            ServerHandleConnectionRequest( &Msg );
            continue;
        }
        else
        {
            UmpdConnection * uc = (UmpdConnection *) PortContext;

            if(uc->magic != kUmpdConnectionMagic)
            {
                fprintf(stderr, "bad magic for uc\n");
            }
            else
            {
                if (Msg.h.u2.s2.Type == LPC_PORT_CLOSED ||
                    Msg.h.u2.s2.Type == LPC_CLIENT_DIED)
                {
                    fprintf( stderr, " - disconnect for client %p\n", PortContext );

                    UmpdConnectionList_Remove(uc);

                }
                else if (Msg.h.u2.s2.Type == LPC_REQUEST)
                {
                    HandleRequest( &Msg );

                    ReplyMsg = &Msg;
                    ReplyPortHandle = uc->port;

                }
            }
        }
    }

    fprintf( stderr, "Exiting %s\n", ThreadName );

    return RtlNtStatusToDosError( Status );
}

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    DWORD rc;
    ULONG i, NumberOfThreads;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HINSTANCE   hInst;

    hInst = LoadLibrary("GDI32.DLL");

    if(hInst == NULL)
    {
        fprintf(stderr, "unable to load gdi32.dll\n");
        ExitProcess(0);
    }

    gGdiPrinterThunkProc = (GdiPrinterThunkProc) GetProcAddress(hInst, "GdiPrinterThunk");

    if(gGdiPrinterThunkProc == NULL)
    {
        fprintf(stderr, "unable to get GdiPrinterThunk address\n");
        ExitProcess(0);
    }


    UmpdConnectionList_Init();

    Status = STATUS_SUCCESS;

    fprintf( stderr, "Umpdproxy Starting\n" );

    TestCallBacks = FALSE;
    NumberOfThreads = 1;

    RtlInitUnicodeString( &PortName, PORT_NAME );
    
    fprintf( stderr, "Creating %wZ connection port\n", (PUNICODE_STRING)&PortName );
    
    InitializeObjectAttributes( &ObjectAttributes, &PortName, 0, NULL, NULL );
    
    Status = NtCreatePort( &ServerConnectionPortHandle,
                           &ObjectAttributes,
                           40,
                           sizeof( PROXYMSG ),
                           256                  //????
                         );
    
    ShowHandleOrStatus( Status, ServerConnectionPortHandle );
    
    rc = RtlNtStatusToDosError( Status );
    
    if (rc == NO_ERROR)
    {
        
        ServerThreadHandles[ 0 ] = GetCurrentThread();
        ServerThreadClientIds[ 0 ] = GetCurrentThreadId();
        
        for (i=1; i<NumberOfThreads; i++)
        {

            fprintf( stderr, "Creating Server Request Thread %ld\n", i+1 );
            
            rc = NO_ERROR;
            
            ServerThreadHandles[ i ] = CreateThread( NULL,
                                                     0,
                                                     (LPTHREAD_START_ROUTINE)ServerThread,
                                                     (LPVOID)(i),
                                                     CREATE_SUSPENDED,
                                                     &ServerThreadClientIds[ i ]
                                                   );

            if (ServerThreadHandles[ i ] == NULL)
            {
                rc = GetLastError();
                break;
            }
        }

        if (rc == NO_ERROR) {

            for (i=1; i<NumberOfThreads; i++)
            {
                ResumeThread( ServerThreadHandles[ i ] );
            }

            ServerThread( 0 );
        }
    }

    if (rc != NO_ERROR)
    {
        fprintf( stderr, "USERVER: Initialization Failed - %u\n", rc );
    }

    ExitProcess( rc );

    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\callback.c ===
/****************************** Module Header ******************************\
* Module Name: callback.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager callback related functions
*
* Created: 11/11/91 Sanford Staab
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* DoCallback
*
* Description:
* Performs a synchronous callback to the given instance's callback proc.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
HDDEDATA DoCallback(
PCL_INSTANCE_INFO pcii,
WORD wType,
WORD wFmt,
HCONV hConv,
HSZ hsz1,
HSZ hsz2,
HDDEDATA hData,
ULONG_PTR dw1,
ULONG_PTR dw2)
{
    HDDEDATA hDataRet;
    PCLIENTINFO pci;

    CheckDDECritIn;


    /*
     * Zombie conversations don't generate callbacks!
     */
    if (hConv && TypeFromHandle(hConv) == HTYPE_ZOMBIE_CONVERSATION) {
        return(0);
    }

    pci = GetClientInfo();
    pci->cInDDEMLCallback++;

    pcii->cInDDEMLCallback++;
    LeaveDDECrit;
    CheckDDECritOut;

    /*
     * Bug 246472 - joejo
     * fixup all DDE Callbacks since some apps make their callbacks
     * C-Style instead of PASCAL.
     */
    hDataRet = UserCallDDECallback(*pcii->pfnCallback, (UINT)wType, (UINT)wFmt, hConv, hsz1, hsz2,
            hData, dw1, dw2);
    
    EnterDDECrit;
    pcii->cInDDEMLCallback--;
    pci->cInDDEMLCallback--;

    if (!(pcii->afCmd & APPCLASS_MONITOR) && pcii->MonitorFlags & MF_CALLBACKS) {
        PEVENT_PACKET pep;

        pep = (PEVENT_PACKET)DDEMLAlloc(sizeof(EVENT_PACKET) - sizeof(DWORD) +
                sizeof(MONCBSTRUCT));
        if (pep != NULL) {

            pep->EventType =    MF_CALLBACKS;
            pep->fSense =       TRUE;
            pep->cbEventData =  sizeof(MONCBSTRUCT);

#define pcbs ((MONCBSTRUCT *)&pep->Data)
            pcbs->cb =      sizeof(MONCBSTRUCT);
            pcbs->dwTime =  NtGetTickCount();
            pcbs->hTask =   (HANDLE)LongToHandle( pcii->tid );
            pcbs->dwRet =   HandleToUlong(hDataRet);
            pcbs->wType =   wType;
            pcbs->wFmt =    wFmt;
            pcbs->hConv =   hConv;
            pcbs->hsz1 =    (HSZ)LocalToGlobalAtom(LATOM_FROM_HSZ(hsz1));
            pcbs->hsz2 =    (HSZ)LocalToGlobalAtom(LATOM_FROM_HSZ(hsz2));
            pcbs->hData =   hData;
            pcbs->dwData1 = dw1;
            pcbs->dwData2 = dw2;
            if (((wType == XTYP_CONNECT) || (wType == XTYP_WILDCONNECT)) && dw1) {
                RtlCopyMemory(&pcbs->cc, (PVOID)dw1, sizeof(CONVCONTEXT));
            }

            LeaveDDECrit;

                if (wType & XCLASS_DATA) {
                    if (hDataRet && hDataRet != CBR_BLOCK) {
                        pcbs->cbData = DdeGetData(hDataRet, (LPBYTE)pcbs->Data, 32, 0);
                    }
                } else if (hData) {
                    pcbs->cbData = DdeGetData(hData, (LPBYTE)pcbs->Data, 32, 0);
                }

                Event(pep);

            EnterDDECrit;

            GlobalDeleteAtom(LATOM_FROM_HSZ(pcbs->hsz1));
            GlobalDeleteAtom(LATOM_FROM_HSZ(pcbs->hsz2));
            DDEMLFree(pep);
#undef pcbs
        }
    }
    return (hDataRet);
}



/***************************************************************************\
* _ClientEventCallback
*
* Description:
* Called from the server side to perform event callbacks.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
DWORD _ClientEventCallback(
PCL_INSTANCE_INFO pcii,
PEVENT_PACKET pep)
{
    HDDEDATA hData;

    EnterDDECrit;

    switch (pep->EventType) {
    case 0: // MonitorFlags change event - everybody gets it
        pcii->MonitorFlags = pep->Data;
        break;

    case MF_CALLBACKS:
        {
            MONCBSTRUCT mcb;

            mcb = *((MONCBSTRUCT *)&pep->Data);
            mcb.hsz1 = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)mcb.hsz1));
            mcb.hsz2 = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)mcb.hsz2));
            if (    mcb.wType == XTYP_REGISTER ||
                    mcb.wType == XTYP_UNREGISTER) {
                mcb.hsz2 = INST_SPECIFIC_HSZ_FROM_LATOM((LATOM)(ULONG_PTR)mcb.hsz2);
            }
            hData = InternalCreateDataHandle(pcii, (LPSTR)&mcb,
                    pep->cbEventData, 0,
                    HDATA_NOAPPFREE | HDATA_READONLY | HDATA_EXECUTE, 0, 0);
            if (hData) {
                DoCallback(pcii, (WORD)XTYP_MONITOR, 0, 0, 0, 0, hData, 0L,
                        pep->EventType);
                InternalFreeDataHandle((HDDEDATA)hData, TRUE);
                DeleteAtom(LATOM_FROM_HSZ(mcb.hsz1));
                DeleteAtom(LATOM_FROM_HSZ(mcb.hsz2));
            }
        }
        break;

    case MF_LINKS:
        {
            MONLINKSTRUCT ml;

            ml = *((MONLINKSTRUCT *)&pep->Data);
            ml.hszSvc = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)ml.hszSvc));
            ml.hszTopic = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)ml.hszTopic));
            ml.hszItem = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)ml.hszItem));
            hData = InternalCreateDataHandle(pcii, (LPSTR)&ml,
                    pep->cbEventData, 0,
                    HDATA_NOAPPFREE | HDATA_READONLY | HDATA_EXECUTE, 0, 0);
            if (hData) {
                DoCallback(pcii, (WORD)XTYP_MONITOR, 0, 0, 0, 0, hData, 0L,
                        pep->EventType);
                InternalFreeDataHandle((HDDEDATA)hData, TRUE);
                DeleteAtom(LATOM_FROM_HSZ(ml.hszSvc));
                DeleteAtom(LATOM_FROM_HSZ(ml.hszTopic));
                DeleteAtom(LATOM_FROM_HSZ(ml.hszItem));
            }
        }
        break;

    case MF_CONV:
        {
            MONCONVSTRUCT mc;

            mc = *((MONCONVSTRUCT *)&pep->Data);
            mc.hszSvc = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)mc.hszSvc));
            mc.hszTopic = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom((GATOM)(ULONG_PTR)mc.hszTopic));
            hData = InternalCreateDataHandle(pcii, (LPSTR)&mc,
                    pep->cbEventData, 0,
                    HDATA_NOAPPFREE | HDATA_READONLY | HDATA_EXECUTE, 0, 0);
            if (hData) {
                DoCallback(pcii, (WORD)XTYP_MONITOR, 0, 0, 0, 0, hData, 0L,
                        pep->EventType);
                InternalFreeDataHandle((HDDEDATA)hData, TRUE);
                DeleteAtom(LATOM_FROM_HSZ(mc.hszSvc));
                DeleteAtom(LATOM_FROM_HSZ(mc.hszTopic));
            }
        }
        break;

    case MF_HSZ_INFO:
        if (!(pcii->flags & IIF_UNICODE)) {
            LPSTR pszAnsi;
            /*
             * Translate HSZ string back into ANSI
             */
            if (WCSToMB(((PMONHSZSTRUCT)&pep->Data)->str,
                    ((int)pep->cbEventData - (int)((PMONHSZSTRUCT)&pep->Data)->cb) / sizeof(WCHAR),
                    &pszAnsi,
                    (int)pep->cbEventData - (int)((PMONHSZSTRUCT)&pep->Data)->cb,
                    TRUE)) {
                strcpy(((PMONHSZSTRUCTA)&pep->Data)->str, pszAnsi);
                UserLocalFree(pszAnsi);
            }
            ((PMONHSZSTRUCT)&pep->Data)->cb = sizeof(MONHSZSTRUCTA);
        }
        // fall through
    case MF_SENDMSGS:
    case MF_POSTMSGS:
        if (pep->EventType == MF_POSTMSGS) {
            PMONMSGSTRUCT pmms = (PMONMSGSTRUCT)&pep->Data;
            BYTE buf[32];

            /*
             * We may need to translate the Execute string to/from
             * UNICODE depending on what type of monitor this is
             * going to.
             */
            if (pmms->wMsg == WM_DDE_EXECUTE) {
                BOOL fUnicodeText;
                int flags;

                flags = (IS_TEXT_UNICODE_UNICODE_MASK |
                        IS_TEXT_UNICODE_REVERSE_MASK |
                        (IS_TEXT_UNICODE_NOT_UNICODE_MASK &
                        (~IS_TEXT_UNICODE_ILLEGAL_CHARS)) |
                        IS_TEXT_UNICODE_NOT_ASCII_MASK);
#ifdef ISTEXTUNICODE_WORKS
                fUnicodeText = RtlIsTextUnicode(pmms->dmhd.Data,
                        min(32, pmms->dmhd.cbData), &flags);
#else
                fUnicodeText = (*(LPSTR)pmms->dmhd.Data == '\0');
#endif

                if (pcii->flags & IIF_UNICODE && !fUnicodeText) {
                    /* Ascii->UNICODE */
                    RtlMultiByteToUnicodeN((LPWSTR)buf, 32, NULL,
                            (LPSTR)&pmms->dmhd.Data,
                            min(32, pmms->dmhd.cbData));
                    RtlCopyMemory(&pmms->dmhd.Data, buf, 32);
                } else if (!(pcii->flags & IIF_UNICODE) && fUnicodeText) {
                    /* UNICODE->Ascii */
                    RtlUnicodeToMultiByteN((LPSTR)buf, 32, NULL,
                            (LPWSTR)&pmms->dmhd.Data,
                            min(32, pmms->dmhd.cbData));
                    RtlCopyMemory(&pmms->dmhd.Data, buf, 32);
                }
            }
        }
    case MF_ERRORS:
        hData = InternalCreateDataHandle(pcii, (LPSTR)&pep->Data,
                pep->cbEventData, 0,
                HDATA_NOAPPFREE | HDATA_READONLY | HDATA_EXECUTE, 0, 0);
        if (hData) {
            DoCallback(pcii, (WORD)XTYP_MONITOR, 0, 0, 0, 0, hData, 0L,
                    pep->EventType);
            InternalFreeDataHandle((HDDEDATA)hData, TRUE);
        }
        break;
    }

    LeaveDDECrit;
    return (0);
}



/***************************************************************************\
* EnableEnumProc
*
* Description:
* Helper function for applying pees->wCmd to each client and server
* DDEML window.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL EnableEnumProc(
HWND hwnd,
PENABLE_ENUM_STRUCT pees)
{
    PCONV_INFO pcoi;

    for (pcoi = (PCONV_INFO)GetWindowLongPtr(hwnd, GWLP_PCI);
                pcoi != NULL; pcoi = pcoi->next) {
        pcoi->cLocks++;
        *pees->pfRet |= SetEnableState(pcoi, pees->wCmd);
        if (pees->wCmd2) {
            /*
             * Only let ES_CHECKQUEUEONCE be done on one window but
             * don't stop the wCmd from getting to all the other
             * windows.
             */
            if (SetEnableState(pcoi, pees->wCmd2) &&
                    pees->wCmd2 == EC_CHECKQUEUEONCE) {
                pees->wCmd2 = 0;
            }
        }
        pcoi->cLocks--;
        if (pcoi->cLocks == 0 && pcoi->state & ST_FREE_CONV_RES_NOW) {
            FreeConversationResources(pcoi);
            break;
        }
    }
    return (TRUE);
}


/***************************************************************************\
* DdeEnableCallback (DDEML API)
*
* Description:
* Turns on and off asynchronous callbacks (BLOCKABLE).
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeEnableCallback, DWORD, idInst, HCONV, hConv, UINT, wCmd)
BOOL DdeEnableCallback(
DWORD idInst,
HCONV hConv,
UINT wCmd)
{
    BOOL fRet = FALSE;
    PCL_INSTANCE_INFO pcii;
    PCONV_INFO pcoi;
    ENABLE_ENUM_STRUCT ees;

    EnterDDECrit;

    pcii = (PCL_INSTANCE_INFO)ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    switch (wCmd) {
    case EC_QUERYWAITING:
    case EC_DISABLE:
    case EC_ENABLEONE:
    case EC_ENABLEALL:
        break;

    default:
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (hConv) {
        pcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
                HTYPE_CLIENT_CONVERSATION, InstFromHandle(idInst));
        if (pcoi == NULL) {
            pcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
                    HTYPE_SERVER_CONVERSATION, InstFromHandle(idInst));
        }
        if (pcoi == NULL) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            goto Exit;
        }
        pcoi->cLocks++;
        fRet = SetEnableState(pcoi, wCmd);
        switch (wCmd) {
        case EC_ENABLEALL:
        case EC_ENABLEONE:
            CheckForQueuedMessages(pcoi);
        }
        pcoi->cLocks--;
        if (pcoi->cLocks == 0 && pcoi->state & ST_FREE_CONV_RES_NOW) {
            FreeConversationResources(pcoi);
        }
    } else {
        if (wCmd == EC_ENABLEONE) {
            wCmd = EC_ENABLEONEOFALL;
        }
        switch (wCmd) {
        case EC_ENABLEONEOFALL:
            pcii->ConvStartupState = ST_BLOCKNEXT | ST_BLOCKALLNEXT;
            break;

        case EC_DISABLE:
            pcii->ConvStartupState = ST_BLOCKED;
            break;

        case EC_ENABLEALL:
            pcii->ConvStartupState = 0;
            break;
        }
        ees.pfRet = &fRet;
        ees.wCmd = (WORD)wCmd;
        switch (wCmd) {
        case EC_ENABLEALL:
            ees.wCmd2 = EC_CHECKQUEUE;
            break;

        case EC_ENABLEONEOFALL:
            ees.wCmd2 = EC_CHECKQUEUEONCE;
            break;

        default:
            ees.wCmd2 = 0;
        }
        EnumChildWindows(pcii->hwndMother, (WNDENUMPROC)EnableEnumProc,
                (LPARAM)&ees);
    }

Exit:
    LeaveDDECrit;
    return (fRet);
}



/***************************************************************************\
* SetEnableState
*
* Description:
* Sets the given conversation's enable state based on the EC_ flag
* given.
*
* Returns: fSuccess/fProcessed.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SetEnableState(
PCONV_INFO pcoi,
UINT wCmd)
{
    BOOL fRet = TRUE;

    switch (wCmd) {
    case EC_CHECKQUEUEONCE:
    case EC_CHECKQUEUE:
        fRet = CheckForQueuedMessages(pcoi);
        break;

    case EC_QUERYWAITING:
        fRet = !(pcoi->dmqOut == NULL ||
                (pcoi->dmqOut->next == NULL &&
                GetClientInfo()->CI_flags & CI_PROCESSING_QUEUE));
        break;

    case EC_DISABLE:
        pcoi->state |= ST_BLOCKED;
        pcoi->state &= ~(ST_BLOCKNEXT | ST_BLOCKALLNEXT);
        break;

    case EC_ENABLEONE:
        pcoi->state &= ~ST_BLOCKED;
        pcoi->state |= ST_BLOCKNEXT;
        break;

    case EC_ENABLEONEOFALL:
        pcoi->state &= ~ST_BLOCKED;
        pcoi->state |= (ST_BLOCKNEXT | ST_BLOCKALLNEXT);
        break;

    case EC_ENABLEALL:
        pcoi->state &= ~(ST_BLOCKED | ST_BLOCKNEXT | ST_BLOCKALLNEXT);
        break;

    default:
        return(FALSE);
    }
    return (fRet);
}




/***************************************************************************\
* _ClientGetDDEHookData
*
* Description:
* Callback from server to extract data from lParam and place it into
* the pdmhd for use by DDESPY apps. This does a very similar thing
* to the CopyDDEDataIn/Out apis but this only grabs a limited amount
* of the data suitable for posting to the DDESPY app(s). This should
* be merged with the Copy APIs eventually.
*
* History:
* 12-16-91 sanfords Created.
\***************************************************************************/
DWORD _ClientGetDDEHookData(
UINT message,
LPARAM lParam,
PDDEML_MSG_HOOK_DATA pdmhd)
{
    PBYTE pb;
    HANDLE hDDE;

    UnpackDDElParam(message, lParam, &pdmhd->uiLo, &pdmhd->uiHi);
    switch (message) {
    case WM_DDE_DATA:
    case WM_DDE_POKE:
    case WM_DDE_ADVISE:
        hDDE = (HANDLE)pdmhd->uiLo;
        break;

    case WM_DDE_EXECUTE:
        hDDE = (HANDLE)pdmhd->uiHi;
        break;

    case WM_DDE_ACK:
    case WM_DDE_REQUEST:
    case WM_DDE_UNADVISE:
    case WM_DDE_TERMINATE:
        pdmhd->cbData = 0;
        return (1);
    }

    pdmhd->cbData = (DWORD)UserGlobalSize(hDDE);
    if (pdmhd->cbData) {
        USERGLOBALLOCK(hDDE, pb);
        if (pb == NULL) {
            pdmhd->cbData = 0;
        } else {
            RtlCopyMemory(&pdmhd->Data, pb, min(pdmhd->cbData,
                    sizeof(DDEML_MSG_HOOK_DATA) -
                    FIELD_OFFSET(DDEML_MSG_HOOK_DATA, Data)));
            USERGLOBALUNLOCK(hDDE);
        }
    }
    return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\callproc.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    callproc.h

Abstract:

    Private DialogProc call routines
    Copied from ldrthunk.asm

Author:

    Joe Jones (joejo) 11-30-98

Revision History:

--*/

#ifndef _CALLPROC_
#define _CALLPROC_

#if defined(_X86_)
LRESULT
InternalCallWinProc(
    WNDPROC proc,
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

/*
 * Bug 246472 - joejo
 * fixup all DDE Callbacks since some apps make their callbacks
 * C-Style instead of PASCAL.
 */
HDDEDATA
UserCallDDECallback(
    PFNCALLBACK pfnDDECallback,
    UINT wType,
    UINT wFmt,
    HCONV hConv,
    HSZ hsz1,
    HSZ hsz2,
    HDDEDATA hData,
    ULONG_PTR dwData1,
    ULONG_PTR dwData2
    );


#else

#define InternalCallWinProc(winproc, hwnd, message, wParam, lParam)    \
    (winproc)(hwnd, message, wParam, lParam)


#define UserCallDDECallback(pfnDDECallback, wType, wFmt, hConv, hsz1, hsz2, hData, dwData1, dwData2) \
    (pfnDDECallback)(wType, wFmt, hConv, hsz1, hsz2, hData, dwData1, dwData2)


#endif

PWND FASTCALL ValidateHwnd(HWND hwnd);

LRESULT UserCallWinProc(PACTIVATION_CONTEXT pActCtx, WNDPROC pfn, HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#endif /* _CALLPROC_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\btnctl.c ===
/**************************** Module Header ********************************\
* Module Name: btnctl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Radio Button and Check Box Handling Routines
*
* History:
* ??-???-???? ??????    Ported from Win 3.0 sources
* 01-Feb-1991 mikeke    Added Revalidation code
* 03-Jan-1992 ianja     Neutralized (ANSI/wide-character)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/* ButtonCalcRect codes */
#define CBR_CLIENTRECT 0
#define CBR_CHECKBOX   1
#define CBR_CHECKTEXT  2
#define CBR_GROUPTEXT  3
#define CBR_GROUPFRAME 4
#define CBR_PUSHBUTTON 5

CONST BYTE mpStyleCbr[] = {
    CBR_PUSHBUTTON,  /* BS_PUSHBUTTON */
    CBR_PUSHBUTTON,  /* BS_DEFPUSHBUTTON */
    CBR_CHECKTEXT,   /* BS_CHECKBOX */
    CBR_CHECKTEXT,   /* BS_AUTOCHECKBOX */
    CBR_CHECKTEXT,   /* BS_RADIOBUTTON */
    CBR_CHECKTEXT,   /* BS_3STATE */
    CBR_CHECKTEXT,   /* BS_AUTO3STATE */
    CBR_GROUPTEXT,   /* BS_GROUPBOX */
    CBR_CLIENTRECT,  /* BS_USERBUTTON */
    CBR_CHECKTEXT,   /* BS_AUTORADIOBUTTON */
    CBR_CLIENTRECT,  /* BS_PUSHBOX */
    CBR_CLIENTRECT,  /* BS_OWNERDRAW */
};

#define IMAGE_BMMAX    IMAGE_CURSOR+1
static CONST BYTE rgbType[IMAGE_BMMAX] = {
    BS_BITMAP,          // IMAGE_BITMAP
    BS_ICON,            // IMAGE_CURSOR
    BS_ICON             // IMAGE_ICON
};

#define IsValidImage(imageType, realType, max)   \
    ((imageType < max) && (rgbType[imageType] == realType))

typedef struct tagBTNDATA {
    LPWSTR  lpsz;       // Text string
    PBUTN   pbutn;      // Button data
    WORD    wFlags;     // Alignment flags
} BTNDATA, FAR * LPBTNDATA;

void xxxDrawButton(PBUTN pbutn, HDC hdc, UINT pbfPush);

LOOKASIDE ButtonLookaside;

/***************************************************************************\
*
*  IsPushButton()
*
*  Returns non-zero if the window is a push button.  Returns flags that
*  are interesting if it is.  These flags are
*
*
*
\***************************************************************************/

UINT IsPushButton(
    PWND pwnd)
{
    BYTE bStyle;
    UINT flags;

    bStyle = TestWF(pwnd, BFTYPEMASK);

    flags = 0;

    switch (bStyle) {
        case LOBYTE(BS_PUSHBUTTON):
            flags |= PBF_PUSHABLE;
            break;

        case LOBYTE(BS_DEFPUSHBUTTON):
            flags |= PBF_PUSHABLE | PBF_DEFAULT;
            break;

        default:
            if (TestWF(pwnd, BFPUSHLIKE))
                flags |= PBF_PUSHABLE;
            break;
    }

    return(flags);
}

/***************************************************************************\
*
*  GetAlignment()
*
*  Gets default alignment of button.  If BS_HORZMASK and/or BS_VERTMASK
*  is specified, uses those.  Otherwise, uses default for button.
*
* It's probably a fine time to describe what alignment flags mean for
* each type of button.  Note that the presence of a bitmap/icon affects
* the meaning of alignments.
*
* (1) Push like buttons
*      With one of {bitmap, icon, text}:
*          Just like you'd expect
*      With one of {bitmap, icon} AND text:
*          Image & text are centered as a unit; alignment means where
*          the image shows up.  E.G., left-aligned means the image
*          on the left, text on the right.
* (2) Radio/check like buttons
*      Left aligned means check/radio box is on left, then bitmap/icon
*          and text follows, left justified.
*      Right aligned means checkk/radio box is on right, preceded by
*          text and bitmap/icon, right justified.
*      Centered has no meaning.
*      With one of {bitmap, icon} AND text:
*          Top aligned means bitmap/icon above, text below
*          Bottom aligned means text above, bitmap/icon below
*      With one of {bitmap, icon, text}
*          Alignments mean what you'd expect.
* (3) Group boxes
*      Left aligned means text is left justified on left side
*      Right aligned means text is right justified on right side
*      Center aligned means text is in middle
*
*
\***************************************************************************/

WORD GetAlignment(
    PWND pwnd)
{
    BYTE bHorz;
    BYTE bVert;

    bHorz = TestWF(pwnd, BFHORZMASK);
    bVert = TestWF(pwnd, BFVERTMASK);

    if (!bHorz || !bVert) {
        if (IsPushButton(pwnd)) {
            if (!bHorz)
                bHorz = LOBYTE(BFCENTER);
        } else {
            if (!bHorz)
                bHorz = LOBYTE(BFLEFT);
        }

        if (!bVert)
            bVert = LOBYTE(BFVCENTER);
    }

    return bHorz | bVert;
}


/***************************************************************************\
*
*  BNSetFont()
*
*  Changes button font, and decides if we can use real bold font for default
*  push buttons or if we have to simulate it.
*
\***************************************************************************/

void BNSetFont(
    PBUTN pbutn,
    HFONT hfn,
    BOOL fRedraw)
{
    PWND pwnd = pbutn->spwnd;

    pbutn->hFont = hfn;

    if (fRedraw && IsVisible(pwnd)) {
        NtUserInvalidateRect(HWq(pwnd), NULL, TRUE);
    }

}


/***************************************************************************\
* xxxBNInitDC
*
* History:
\***************************************************************************/

HBRUSH xxxBNInitDC(
    PBUTN pbutn,
    HDC hdc)
{
    UINT    wColor;
    BYTE    bStyle;
    HBRUSH  hbr;
    PWND pwnd = pbutn->spwnd;

    CheckLock(pwnd);

    /*
     * Set BkMode before getting brush so that the app can change it to
     * transparent if it wants.
     */
    SetBkMode(hdc, OPAQUE);

    bStyle = TestWF(pwnd, BFTYPEMASK);

    switch (bStyle) {
        default:
            if (TestWF(pwnd, WFWIN40COMPAT) && !TestWF(pwnd, BFPUSHLIKE)) {
                wColor = WM_CTLCOLORSTATIC;
                break;
            }

        case LOBYTE(BS_PUSHBUTTON):
        case LOBYTE(BS_DEFPUSHBUTTON):
        case LOBYTE(BS_OWNERDRAW):
        case LOBYTE(BS_USERBUTTON):
            wColor = WM_CTLCOLORBTN;
            break;
    }

    hbr = GetControlBrush(HWq(pwnd), hdc, wColor);

    /*
     * Select in the user's font if set, and save the old font so that we can
     * restore it when we release the dc.
     */
    if (pbutn->hFont) {
        SelectObject(hdc, pbutn->hFont);
    }

    /*
     * Clip output to the window rect if needed.
     */
    if (bStyle != LOBYTE(BS_GROUPBOX)) {
        IntersectClipRect(hdc, 0, 0,
            pwnd->rcClient.right - pwnd->rcClient.left,
            pwnd->rcClient.bottom - pwnd->rcClient.top);
    }

    if (TestWF(pwnd,WEFRTLREADING))
        SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));

    return(hbr);
}

/***************************************************************************\
* xxxBNGetDC
*
* History:
\***************************************************************************/

HDC xxxBNGetDC(
    PBUTN pbutn,
    HBRUSH *lphbr)
{
    HDC hdc;
    PWND pwnd = pbutn->spwnd;

    CheckLock(pwnd);

    if (IsVisible(pwnd)) {
        HBRUSH  hbr;

        hdc = NtUserGetDC(HWq(pwnd));
        hbr = xxxBNInitDC(pbutn, hdc);

        if (lphbr!=NULL)
            *lphbr = hbr;

        return hdc;
    }

    return NULL;
}

/***************************************************************************\
* BNReleaseDC
*
* History:
\***************************************************************************/

void BNReleaseDC(
    PBUTN pbutn,
    HDC hdc)
{
    PWND pwnd = pbutn->spwnd;

    if (TestWF(pwnd,WEFRTLREADING))
        SetTextAlign(hdc, GetTextAlign(hdc) & ~TA_RTLREADING);

    if (pbutn->hFont) {
        SelectObject(hdc, ghFontSys);
    }

    ReleaseDC(HWq(pwnd), hdc);
}

/***************************************************************************\
* xxxBNOwnerDraw
*
* History:
\***************************************************************************/

void xxxBNOwnerDraw(
    PBUTN pbutn,
    HDC hdc,
    UINT itemAction)
{
    DRAWITEMSTRUCT drawItemStruct;
    TL tlpwndParent;
    PWND pwnd = pbutn->spwnd;
    UINT itemState = 0;

    if (TestWF(pwnd, WEFPUIFOCUSHIDDEN)) {
        itemState |= ODS_NOFOCUSRECT;
    }
    if (TestWF(pwnd, WEFPUIACCELHIDDEN)) {
        itemState |= ODS_NOACCEL;
    }
    if (BUTTONSTATE(pbutn) & BST_FOCUS) {
        itemState |= ODS_FOCUS;
    }
    if (BUTTONSTATE(pbutn) & BST_PUSHED) {
        itemState |= ODS_SELECTED;
    }

    if (TestWF(pwnd, WFDISABLED))
        itemState |= ODS_DISABLED;

    drawItemStruct.CtlType = ODT_BUTTON;
    drawItemStruct.CtlID = PtrToUlong(pwnd->spmenu);
    drawItemStruct.itemAction = itemAction;
    drawItemStruct.itemState = itemState;
    drawItemStruct.hwndItem = HWq(pwnd);
    drawItemStruct.hDC = hdc;
    _GetClientRect(pwnd, &drawItemStruct.rcItem);
    drawItemStruct.itemData = 0L;

    /*
     * Send a WM_DRAWITEM message to the parent
     * IanJa:  in this case pMenu is being used as the control ID
     */
    ThreadLock(REBASEPWND(pwnd, spwndParent), &tlpwndParent);
    SendMessage(HW(REBASEPWND(pwnd, spwndParent)), WM_DRAWITEM, (WPARAM)pwnd->spmenu,
            (LPARAM)&drawItemStruct);
    ThreadUnlock(&tlpwndParent);
}

/***************************************************************************\
* CalcBtnRect
*
* History:
\***************************************************************************/

void BNCalcRect(
    PWND pwnd,
    HDC hdc,
    LPRECT lprc,
    int code,
    UINT pbfFlags)
{
    int cch;
    SIZE extent;
    int dy;
    LPWSTR lpName;
    UINT align;

    _GetClientRect(pwnd, lprc);

    align = GetAlignment(pwnd);

    switch (code) {
    case CBR_PUSHBUTTON:
        // Subtract out raised edge all around
        InflateRect(lprc, -SYSMET(CXEDGE), -SYSMET(CYEDGE));

        if (pbfFlags & PBF_DEFAULT)
            InflateRect(lprc, -SYSMET(CXBORDER), -SYSMET(CYBORDER));
        break;

    case CBR_CHECKBOX:
        switch (align & LOBYTE(BFVERTMASK))
        {
        case LOBYTE(BFVCENTER):
                lprc->top = (lprc->top + lprc->bottom - gpsi->oembmi[OBI_CHECK].cy) / 2;
                break;

            case LOBYTE(BFTOP):
            case LOBYTE(BFBOTTOM):
                PSMGetTextExtent(hdc, (LPWSTR)szOneChar, 1, &extent);
                dy = extent.cy + extent.cy/4;

                // Save vertical extent
                extent.cx = dy;

                // Get centered amount

                dy = (dy - gpsi->oembmi[OBI_CHECK].cy) / 2;
                if ((align & LOBYTE(BFVERTMASK)) == LOBYTE(BFTOP))
                    lprc->top += dy;
                else
                    lprc->top = lprc->bottom - extent.cx + dy;
                break;
        }

        if (TestWF(pwnd, BFRIGHTBUTTON))
            lprc->left = lprc->right - gpsi->oembmi[OBI_CHECK].cx;
        else
            lprc->right = lprc->left + gpsi->oembmi[OBI_CHECK].cx;

        break;

    case CBR_CHECKTEXT:
        if (TestWF(pwnd, BFRIGHTBUTTON)) {
            lprc->right -= gpsi->oembmi[OBI_CHECK].cx;

            // More spacing for 4.0 dudes
            if (TestWF(pwnd, WFWIN40COMPAT)) {
                PSMGetTextExtent(hdc, szOneChar, 1, &extent);
                lprc->right -= extent.cx  / 2;
            }
        } else {
            lprc->left += gpsi->oembmi[OBI_CHECK].cx;

            // More spacing for 4.0 dudes
            if (TestWF(pwnd, WFWIN40COMPAT)) {
                PSMGetTextExtent(hdc, szOneChar, 1, &extent);
                lprc->left +=  extent.cx / 2;
            }
        }
        break;

    case CBR_GROUPTEXT:
        if (!pwnd->strName.Length)
            goto EmptyRect;

        lpName = REBASE(pwnd, strName.Buffer);
        if (!(cch = pwnd->strName.Length / sizeof(WCHAR))) {
EmptyRect:
            SetRectEmpty(lprc);
            break;
        }

        PSMGetTextExtent(hdc, lpName, cch, &extent);
        extent.cx += SYSMET(CXEDGE) * 2;

        switch (align & LOBYTE(BFHORZMASK))
        {
        // BFLEFT, nothing
        case LOBYTE(BFLEFT):
            lprc->left += (gpsi->cxSysFontChar - SYSMET(CXBORDER));
            lprc->right = lprc->left + (int)(extent.cx);
            break;

        case LOBYTE(BFRIGHT):
            lprc->right -= (gpsi->cxSysFontChar - SYSMET(CXBORDER));
            lprc->left = lprc->right - (int)(extent.cx);
            break;

        case LOBYTE(BFCENTER):
            lprc->left = (lprc->left + lprc->right - (int)(extent.cx)) / 2;
            lprc->right = lprc->left + (int)(extent.cx);
            break;
        }

        // Center aligned.
        lprc->bottom = lprc->top + extent.cy + SYSMET(CYEDGE);
        break;

    case CBR_GROUPFRAME:
        PSMGetTextExtent(hdc, (LPWSTR)szOneChar, 1, &extent);
        lprc->top += extent.cy / 2;
        break;
    }
}

/***************************************************************************\
*
*  BtnGetMultiExtent()
*
*  Calculates button text extent, given alignment flags.
*
\***************************************************************************/

void BNMultiExtent(
    WORD wFlags,
    HDC hdc,
    LPRECT lprcMax,
    LPWSTR lpsz,
    int cch,
    PINT pcx,
    PINT pcy)
{
    RECT rcT;

    UINT dtFlags = DT_CALCRECT | DT_WORDBREAK | DT_EDITCONTROL;
    CopyRect(&rcT, lprcMax);

    // Note that since we're just calculating the maximum dimensions,
    // left-justification and top-justification are not important.
    // Also, remember to leave margins horz and vert that follow our rules
    // in DrawBtnText().

    InflateRect(&rcT, -SYSMET(CXEDGE), -SYSMET(CYBORDER));

    if ((wFlags & LOBYTE(BFHORZMASK)) == LOBYTE(BFCENTER))
        dtFlags |= DT_CENTER;

    if ((wFlags & LOBYTE(BFHORZMASK)) == LOBYTE(BFRIGHT))
        dtFlags |= DT_RIGHT;

    if ((wFlags & LOBYTE(BFVERTMASK)) == LOBYTE(BFVCENTER))
        dtFlags |= DT_VCENTER;

    if ((wFlags & LOBYTE(BFVERTMASK)) == LOBYTE(BFBOTTOM))
        dtFlags |= DT_BOTTOM;

    DrawTextExW(hdc, lpsz, cch, &rcT, dtFlags, NULL);

    if (pcx)
        *pcx = rcT.right-rcT.left;
    if (pcy)
        *pcy = rcT.bottom-rcT.top;
}

/***************************************************************************\
*
*  BtnMultiDraw()
*
*  Draws multiline button text
*
\***************************************************************************/

BOOL CALLBACK BNMultiDraw(
    HDC hdc,
    LPARAM lData,
    WPARAM wData,
    int cx,
    int cy)
{
    LPBTNDATA lpbd = (LPBTNDATA)lData;
    int cch = (int)wData;
    RECT rcT;
    UINT dtFlags = DT_WORDBREAK | DT_EDITCONTROL;
    PBUTN pbutn = lpbd->pbutn;

    if (TestWF(pbutn->spwnd, WEFPUIACCELHIDDEN)) {
        dtFlags |= DT_HIDEPREFIX;
    } else if (pbutn->fPaintKbdCuesOnly){
        dtFlags |= DT_PREFIXONLY;
    }

    if (TestWF(pbutn->spwnd, WEFRIGHT)) {
        dtFlags |= DT_RIGHT;
    }
    
    rcT.left    = 0;
    rcT.top     = 0;
    rcT.right   = cx;
    rcT.bottom  = cy;

    // Horizontal alignment
    UserAssert(DT_LEFT == 0);
    switch (lpbd->wFlags & LOBYTE(BFHORZMASK)) {
        case LOBYTE(BFCENTER):
            dtFlags |= DT_CENTER;
            break;

        case LOBYTE(BFRIGHT):
            dtFlags |= DT_RIGHT;
            break;
    }

    // Vertical alignment
    UserAssert(DT_TOP == 0);
    switch (lpbd->wFlags & LOBYTE(BFVERTMASK)) {
        case LOBYTE(BFVCENTER):
            dtFlags |= DT_VCENTER;
            break;

        case LOBYTE(BFBOTTOM):
            dtFlags |= DT_BOTTOM;
            break;
    }

    DrawTextExW(hdc, lpbd->lpsz, cch, &rcT, dtFlags, NULL);
    return(TRUE);
}

/***************************************************************************\
* xxxBNSetCapture
*
* History:
\***************************************************************************/

BOOL xxxBNSetCapture(
    PBUTN pbutn,
    UINT codeMouse)
{
    PWND pwnd = pbutn->spwnd;

    BUTTONSTATE(pbutn) |= codeMouse;

    CheckLock(pwnd);

    if (!(BUTTONSTATE(pbutn) & BST_CAPTURED)) {
        NtUserSetCapture(HWq(pwnd));
        BUTTONSTATE(pbutn) |= BST_CAPTURED;

        /*
         * To prevent redundant CLICK messages, we set the INCLICK bit so
         * the WM_SETFOCUS code will not do a xxxButtonNotifyParent(BN_CLICKED).
         */

        BUTTONSTATE(pbutn) |= BST_INCLICK;

        NtUserSetFocus(HWq(pwnd));

        BUTTONSTATE(pbutn) &= ~BST_INCLICK;
    }
    return(BUTTONSTATE(pbutn) & BST_CAPTURED);
}


/***************************************************************************\
* xxxButtonNotifyParent
*
* History:
\***************************************************************************/

void xxxButtonNotifyParent(
    PWND pwnd,
    UINT code)
{
    TL tlpwndParent;
    PWND pwndParent;            // Parent if it exists

    CheckLock(pwnd);

    if (pwnd->spwndParent)
        pwndParent = REBASEPWND(pwnd, spwndParent);
    else
        pwndParent = pwnd;

    /*
     * Note: A button's pwnd->spmenu is used to store the control ID
     */
    ThreadLock(pwndParent, &tlpwndParent);
    SendMessage(HW(pwndParent), WM_COMMAND,
            MAKELONG(PTR_TO_ID(pwnd->spmenu), code), (LPARAM)HWq(pwnd));
    ThreadUnlock(&tlpwndParent);
}

/***************************************************************************\
* xxxBNReleaseCapture
*
* History:
\***************************************************************************/

void xxxBNReleaseCapture(
    PBUTN pbutn,
    BOOL fCheck)
{
    PWND pwndT;
    UINT check;
    BOOL fNotifyParent = FALSE;
    TL tlpwndT;
    PWND pwnd = pbutn->spwnd;

    CheckLock(pwnd);

    if (BUTTONSTATE(pbutn) & BST_PUSHED) {
        SendMessageWorker(pwnd, BM_SETSTATE, FALSE, 0, FALSE);
        if (fCheck) {
            switch (TestWF(pwnd, BFTYPEMASK)) {
            case BS_AUTOCHECKBOX:
            case BS_AUTO3STATE:
                check = (UINT)((BUTTONSTATE(pbutn) & BST_CHECKMASK) + 1);

                if (check > (UINT)(TestWF(pwnd, BFTYPEMASK) == BS_AUTO3STATE? BST_INDETERMINATE : BST_CHECKED)) {
                    check = BST_UNCHECKED;
                }
                SendMessageWorker(pwnd, BM_SETCHECK, check, 0, FALSE);
                break;

            case BS_AUTORADIOBUTTON:
                pwndT = pwnd;
                do {
                    ThreadLock(pwndT, &tlpwndT);

                    if ((UINT)SendMessage(HW(pwndT), WM_GETDLGCODE, 0, 0L) &
                            DLGC_RADIOBUTTON) {
                        SendMessage(HW(pwndT), BM_SETCHECK, (pwnd == pwndT), 0L);
                    }
                    pwndT = _GetNextDlgGroupItem(REBASEPWND(pwndT, spwndParent),
                            pwndT, FALSE);
                    ThreadUnlock(&tlpwndT);

                } while (pwndT != pwnd);
            }

            fNotifyParent = TRUE;
        }
    }

    if (BUTTONSTATE(pbutn) & BST_CAPTURED) {
        BUTTONSTATE(pbutn) &= ~(BST_CAPTURED | BST_MOUSE);
        NtUserReleaseCapture();
    }

    if (fNotifyParent) {

        /*
         * We have to do the notification after setting the buttonstate bits.
         */
        xxxButtonNotifyParent(pwnd, BN_CLICKED);
    }
}

/***************************************************************************\
*
*  DrawBtnText()
*
*  Draws text of button.
*
\***************************************************************************/

void xxxBNDrawText(
    PBUTN pbutn,
    HDC hdc,
    BOOL dbt,
    BOOL fDepress)
{
    RECT    rc;
    HBRUSH  hbr;
    int     x;
    int     y;
    int     cx;
    int     cy;
    LPWSTR   lpName;
    BYTE    bStyle;
    int     cch;
    UINT    dsFlags;
    BTNDATA bdt;
    UINT    pbfPush;
    PWND    pwnd = pbutn->spwnd;

    bStyle = TestWF(pwnd, BFTYPEMASK);

    if (bStyle > sizeof(mpStyleCbr)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid button style");
    } else if ((bStyle == LOBYTE(BS_GROUPBOX)) && (dbt == DBT_FOCUS))
        return;

    pbfPush = IsPushButton(pwnd);
    if (pbfPush) {
        BNCalcRect(pwnd, hdc, &rc, CBR_PUSHBUTTON, pbfPush);
        IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

        //
        // This is because we don't have WM_CTLCOLOR / CTLCOLOR_BTN
        // actually set up the button colors.  For old apps, CTLCOLOR_BTN
        // needs to work like CTLCOLOR_STATIC.
        //
        SetBkColor(hdc, SYSRGB(3DFACE));
        SetTextColor(hdc, SYSRGB(BTNTEXT));
        hbr = SYSHBR(BTNTEXT);
    } else {
        BNCalcRect(pwnd, hdc, &rc, mpStyleCbr[bStyle], pbfPush);

        // Skip stuff for ownerdraw buttons, since we aren't going to
        // draw text/image.
        if (bStyle == LOBYTE(BS_OWNERDRAW))
            goto DrawFocus;
        else
            hbr = SYSHBR(WINDOWTEXT);
    }

    // Alignment
    bdt.wFlags = GetAlignment(pwnd);
    bdt.pbutn = pbutn;

    // Bail if we have nothing to draw
    if (TestWF(pwnd, BFBITMAP)) {
        BITMAP bmp;

        // Bitmap button
        if (!pbutn->hImage)
            return;

        GetObject(pbutn->hImage, sizeof(BITMAP), &bmp);
        cx = bmp.bmWidth;
        cy = bmp.bmHeight;

        dsFlags = DST_BITMAP;
        goto UseImageForName;
    } else if (TestWF(pwnd, BFICON)) {
        // Icon button
        if (!pbutn->hImage)
            return;

        NtUserGetIconSize(pbutn->hImage, 0, &cx, &cy);
        cy /= 2;    // The bitmap height is half because a Mask is present in NT

        dsFlags = DST_ICON;
UseImageForName:
        lpName = (LPWSTR)pbutn->hImage;
        cch = TRUE;
    } else {
        // Text button
        if (!pwnd->strName.Length)
            return;

        lpName = REBASE(pwnd, strName.Buffer);
        cch    = pwnd->strName.Length / sizeof(WCHAR);

        if (TestWF(pwnd, BFMULTILINE)) {

            bdt.lpsz = lpName;

            BNMultiExtent(bdt.wFlags, hdc, &rc, lpName, cch, &cx, &cy);

            lpName = (LPWSTR)(LPBTNDATA)&bdt;
            dsFlags = DST_COMPLEX;

        } else {
            SIZE size;

            PSMGetTextExtent(hdc, lpName, cch, &size);
            cx = size.cx;
            cy = size.cy;
            /*
             * If the control doesn't need underlines, set DST_HIDEPREFIX and
             * also do not show the focus indicator
             */
            dsFlags = DST_PREFIXTEXT;
            if (TestWF(pwnd, WEFPUIACCELHIDDEN)) {
                dsFlags |= DSS_HIDEPREFIX;
            } else if (pbutn->fPaintKbdCuesOnly) {
                dsFlags |= DSS_PREFIXONLY;
            }
        }


        //
        // Add on a pixel or two of vertical space to make centering
        // happier.  That way underline won't abut focus rect unless
        // spacing is really tight.
        //
        cy++;
    }

    //
    // ALIGNMENT
    //

    // Horizontal
    switch (bdt.wFlags & LOBYTE(BFHORZMASK)) {
        //
        // For left & right justified, we leave a margin of CXEDGE on either
        // side for eye-pleasing space.
        //
        case LOBYTE(BFLEFT):
            x = rc.left + SYSMET(CXEDGE);
            break;

        case LOBYTE(BFRIGHT):
            x = rc.right - cx - SYSMET(CXEDGE);
            break;

        default:
            x = (rc.left + rc.right - cx) / 2;
            break;
    }

    // Vertical
    switch (bdt.wFlags & LOBYTE(BFVERTMASK)) {
        //
        // For top & bottom justified, we leave a margin of CYBORDER on
        // either side for more eye-pleasing space.
        //
        case LOBYTE(BFTOP):
            y = rc.top + SYSMET(CYBORDER);
            break;

        case LOBYTE(BFBOTTOM):
            y = rc.bottom - cy - SYSMET(CYBORDER);
            break;

        default:
            y = (rc.top + rc.bottom - cy) / 2;
            break;
    }

    //
    // Draw the text
    //
    if (dbt & DBT_TEXT) {
        //
        // This isn't called for USER buttons.
        //
        UserAssert(bStyle != LOBYTE(BS_USERBUTTON));

        if (fDepress) {
            x += SYSMET(CXBORDER);
            y += SYSMET(CYBORDER);
        }

        if (TestWF(pwnd, WFDISABLED)) {
            UserAssert(HIBYTE(BFICON) == HIBYTE(BFBITMAP));
            if (SYSMET(SLOWMACHINE)  &&
                !TestWF(pwnd, BFICON | BFBITMAP) &&
                (GetBkColor(hdc) != SYSRGB(GRAYTEXT)))
            {
                // Perf && consistency with menus, statics
                SetTextColor(hdc, SYSRGB(GRAYTEXT));
            }
            else
                dsFlags |= DSS_DISABLED;
        }

        //
        // Use transparent mode for checked push buttons since we're going to
        // fill background with dither.
        //
        if (pbfPush) {
            switch (BUTTONSTATE(pbutn) & BST_CHECKMASK) {
                case BST_INDETERMINATE:
                    hbr = SYSHBR(GRAYTEXT);
                    dsFlags |= DSS_MONO;
                    // FALL THRU

                case BST_CHECKED:
                    // Drawing on dithered background...
                    SetBkMode(hdc, TRANSPARENT);
                    break;
            }
        }

        //
        // Use brush and colors currently selected into hdc when we grabbed
        // color
        //
        DrawState(hdc, hbr, BNMultiDraw, (LPARAM)lpName,
            (WPARAM)cch, x, y, cx, cy,
            dsFlags);
    }

    // Draw focus rect.
    //
    // This can get called for OWNERDRAW and USERDRAW buttons. However, only
    // OWNERDRAW buttons let the owner change the drawing of the focus button.
DrawFocus:
    if (dbt & DBT_FOCUS) {
        if (bStyle == LOBYTE(BS_OWNERDRAW)) {
            // For ownerdraw buttons, this is only called in response to a
            // WM_SETFOCUS or WM_KILL FOCUS message.  So, we can check the
            // new state of the focus by looking at the BUTTONSTATE bits
            // which are set before this procedure is called.
            xxxBNOwnerDraw(pbutn, hdc, ODA_FOCUS);
        } else {
            // Don't draw the focus if underlines are not turned on
            if (!TestWF(pwnd, WEFPUIFOCUSHIDDEN)) {

                // Let focus rect always hug edge of push buttons.  We already
                // have the client area setup for push buttons, so we don't have
                // to do anything.
                if (!pbfPush) {

                    RECT rcClient;

                    _GetClientRect(pwnd, &rcClient);
                    if (bStyle == LOBYTE(BS_USERBUTTON))
                        CopyRect(&rc, &rcClient);
                    else {
                        // Try to leave a border all around text.  That causes
                        // focus to hug text.
                        rc.top = max(rcClient.top, y-SYSMET(CYBORDER));
                        rc.bottom = min(rcClient.bottom, rc.top + SYSMET(CYEDGE) + cy);

                        rc.left = max(rcClient.left, x-SYSMET(CXBORDER));
                        rc.right = min(rcClient.right, rc.left + SYSMET(CXEDGE) + cx);
                    }
                } else
                    InflateRect(&rc, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

                // Are back & fore colors set properly?
                DrawFocusRect(hdc, &rc);
            }
        }
    }
}


/***************************************************************************\
*
*  DrawCheck()
*
\***************************************************************************/

void xxxButtonDrawCheck(
    PBUTN pbutn,
    HDC hdc,
    HBRUSH hbr)
{
    RECT rc;
    int bm;
    UINT flags;
    BOOL fDoubleBlt = FALSE;
    TL tlpwnd;
    PWND pwnd = pbutn->spwnd;
    PWND pwndParent;

    BNCalcRect(pwnd, hdc, &rc, CBR_CHECKBOX, 0);

    flags = 0;
    if (BUTTONSTATE(pbutn) & BST_CHECKMASK)
        flags |= DFCS_CHECKED;
    if (BUTTONSTATE(pbutn) & BST_PUSHED)
        flags |= DFCS_PUSHED;
    if (TestWF(pwnd, WFDISABLED))
        flags |= DFCS_INACTIVE;

    bm = OBI_CHECK;
    switch (TestWF(pwnd, BFTYPEMASK)) {
        case BS_AUTORADIOBUTTON:
        case BS_RADIOBUTTON:
            fDoubleBlt = TRUE;
            bm = OBI_RADIO;
            flags |= DFCS_BUTTONRADIO;
            break;

        case BS_3STATE:
        case BS_AUTO3STATE:
            if ((BUTTONSTATE(pbutn) & BST_CHECKMASK) == BST_INDETERMINATE) {
                bm = OBI_3STATE;
                flags |= DFCS_BUTTON3STATE;
                break;
            }
            // FALL THRU

        default:
            flags |= DFCS_BUTTONCHECK;
            break;
    }

    rc.right = rc.left + gpsi->oembmi[bm].cx;
    rc.bottom = rc.top + gpsi->oembmi[bm].cy;

    ThreadLockAlways(pwnd->spwndParent, &tlpwnd);
    pwndParent = REBASEPWND(pwnd, spwndParent);
    PaintRect(HW(pwndParent), HWq(pwnd), hdc, hbr, &rc);
    ThreadUnlock(&tlpwnd);

    if (TestWF(pwnd, BFFLAT) && gpsi->BitCount != 1) {
        flags |= DFCS_MONO | DFCS_FLAT;
        DrawFrameControl(hdc, &rc, DFC_BUTTON, flags);
    } else {

        switch (flags & (DFCS_CHECKED | DFCS_PUSHED | DFCS_INACTIVE))
        {
        case 0:
            break;

        case DFCS_CHECKED:
            bm += DOBI_CHECK;
            break;

        // These are mutually exclusive!
        case DFCS_PUSHED:
        case DFCS_INACTIVE:
            bm += DOBI_DOWN;        // DOBI_DOWN == DOBI_INACTIVE
            break;

        case DFCS_CHECKED | DFCS_PUSHED:
            bm += DOBI_CHECKDOWN;
            break;

        case DFCS_CHECKED | DFCS_INACTIVE:
            bm += DOBI_CHECKDOWN + 1;
            break;
        }

        if (fDoubleBlt) {
            // This is a diamond-shaped radio button -- Blt with a mask so that
            // the exterior keeps the same color as the window's background
            DWORD clrTextSave = SetTextColor(hdc, 0x00000000L);
            DWORD clrBkSave   = SetBkColor(hdc, 0x00FFFFFFL);
            POEMBITMAPINFO pOem = gpsi->oembmi + OBI_RADIOMASK;

            NtUserBitBltSysBmp(hdc, rc.left, rc.top, pOem->cx, pOem->cy,
                    pOem->x, pOem->y, SRCAND);

            pOem = gpsi->oembmi + bm;
            NtUserBitBltSysBmp(hdc, rc.left, rc.top, pOem->cx, pOem->cy,
                    pOem->x, pOem->y, SRCINVERT);

            SetTextColor(hdc, clrTextSave);
            SetBkColor(hdc, clrBkSave);
        } else {
            POEMBITMAPINFO pOem = gpsi->oembmi + bm;
            DWORD dwROP = 0;

            // We do not want to mirror the check box.
            if (MIRRORED_HDC(hdc)) {
                dwROP = NOMIRRORBITMAP;
            }
            NtUserBitBltSysBmp(hdc, rc.left, rc.top, pOem->cx, pOem->cy,
                    pOem->x, pOem->y, SRCCOPY | dwROP);
        }
    }
}


/***************************************************************************\
* xxxButtonDrawNewState
*
* History:
\***************************************************************************/

void xxxButtonDrawNewState(
    PBUTN pbutn,
    HDC hdc,
    HBRUSH hbr,
    UINT sOld)
{
    PWND pwnd = pbutn->spwnd;

    CheckLock(pwnd);

    if (sOld != (UINT)(BUTTONSTATE(pbutn) & BST_PUSHED)) {
        UINT    pbfPush;

        pbfPush = IsPushButton(pwnd);

        switch (TestWF(pwnd, BFTYPEMASK)) {
        case BS_GROUPBOX:
        case BS_OWNERDRAW:
            break;

        default:
            if (!pbfPush) {
                xxxButtonDrawCheck(pbutn, hdc, hbr);
                break;
            }

        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
        case BS_PUSHBOX:
            xxxDrawButton(pbutn, hdc, pbfPush);
            break;
        }
    }
}

/***************************************************************************\
*
*  DrawButton()
*
*  Draws push-like button with text
*
\***************************************************************************/

void xxxDrawButton(
    PBUTN pbutn,
    HDC hdc,
    UINT pbfPush)
{
    RECT rc;
    UINT flags = 0;
    UINT state = 0;
    PWND pwnd = pbutn->spwnd;

    if (BUTTONSTATE(pbutn) & BST_PUSHED)
        state |= DFCS_PUSHED;

    if (!pbutn->fPaintKbdCuesOnly) {
        if (BUTTONSTATE(pbutn) & BST_CHECKMASK)
            state |= DFCS_CHECKED;

        if (TestWF(pwnd, WFWIN40COMPAT))
            flags = BF_SOFT;

        if (TestWF(pwnd, BFFLAT))
            flags |= BF_FLAT | BF_MONO;

        _GetClientRect(pwnd, &rc);

        if (pbfPush & PBF_DEFAULT) {
            DrawFrame(hdc, &rc, 1, DF_WINDOWFRAME);
            InflateRect(&rc, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

            if (state & DFCS_PUSHED)
                flags |= BF_FLAT;
        }

        DrawPushButton(hdc, &rc, state, flags);
    }

    xxxBNDrawText(pbutn, hdc, DBT_TEXT | (BUTTONSTATE(pbutn) &
           BST_FOCUS ? DBT_FOCUS : 0), (state & DFCS_PUSHED));
}


/***************************************************************************\
* xxxBNPaint
*
* History:
\***************************************************************************/

void xxxBNPaint(
    PBUTN pbutn,
    HDC hdc)
{
    UINT bsWnd;
    RECT rc;
    HBRUSH  hbr;
    HBRUSH hbrBtnSave;
    TL tlpwndParent;
    UINT pbfPush;
    PWND pwnd = pbutn->spwnd;
    PWND pwndParent;

    CheckLock(pwnd);

    hbr = xxxBNInitDC(pbutn, hdc);

    bsWnd = TestWF(pwnd, BFTYPEMASK);
    pbfPush = IsPushButton(pwnd);
    if (!pbfPush && !pbutn->fPaintKbdCuesOnly) {
        _GetClientRect(pwnd, &rc);

        if ((bsWnd != LOBYTE(BS_OWNERDRAW)) &&
            (bsWnd != LOBYTE(BS_GROUPBOX))) {
             ThreadLock(pwnd->spwndParent, &tlpwndParent);
             pwndParent = REBASEPWND(pwnd, spwndParent);
             PaintRect(HW(pwndParent), HWq(pwnd), hdc, hbr, &rc);
             ThreadUnlock(&tlpwndParent);
        }

        hbrBtnSave = SelectObject(hdc, hbr);
    }

    switch (bsWnd) {
    case BS_CHECKBOX:
    case BS_RADIOBUTTON:
    case BS_AUTORADIOBUTTON:
    case BS_3STATE:
    case BS_AUTOCHECKBOX:
    case BS_AUTO3STATE:
        if (!pbfPush) {
            xxxBNDrawText(pbutn, hdc,
                DBT_TEXT | (BUTTONSTATE(pbutn) & BST_FOCUS ? DBT_FOCUS : 0), FALSE);
            if (!pbutn->fPaintKbdCuesOnly) {
                xxxButtonDrawCheck(pbutn, hdc, hbr);
            }
            break;
        }
        /*
         * Fall through for PUSHLIKE buttons
         */

    case BS_PUSHBUTTON:
    case BS_DEFPUSHBUTTON:
        xxxDrawButton(pbutn, hdc, pbfPush);
        break;

    case BS_PUSHBOX:
        xxxBNDrawText(pbutn, hdc,
            DBT_TEXT | (BUTTONSTATE(pbutn) & BST_FOCUS ? DBT_FOCUS : 0), FALSE);

        xxxButtonDrawNewState(pbutn, hdc, hbr, 0);
        break;

    case BS_USERBUTTON:
        xxxButtonNotifyParent(pwnd, BN_PAINT);

        if (BUTTONSTATE(pbutn) & BST_PUSHED) {
            xxxButtonNotifyParent(pwnd, BN_PUSHED);
        }
        if (TestWF(pwnd, WFDISABLED)) {
            xxxButtonNotifyParent(pwnd, BN_DISABLE);
        }
        if (BUTTONSTATE(pbutn) & BST_FOCUS) {
            xxxBNDrawText(pbutn, hdc, DBT_FOCUS, FALSE);
        }
        break;

    case BS_OWNERDRAW:
        xxxBNOwnerDraw(pbutn, hdc, ODA_DRAWENTIRE);
        break;

    case BS_GROUPBOX:
        if (!pbutn->fPaintKbdCuesOnly) {
            BNCalcRect(pwnd, hdc, &rc, CBR_GROUPFRAME, 0);
            DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT |
                (TestWF(pwnd, BFFLAT) ? BF_FLAT | BF_MONO : 0));

            BNCalcRect(pwnd, hdc, &rc, CBR_GROUPTEXT, 0);
            ThreadLock(pwnd->spwndParent, &tlpwndParent);
            pwndParent = REBASEPWND(pwnd, spwndParent);
            PaintRect(HW(pwndParent), HWq(pwnd), hdc, hbr, &rc);
            ThreadUnlock(&tlpwndParent);
        }

        /*
         * FillRect(hdc, &rc, hbrBtn);
         */
        xxxBNDrawText(pbutn, hdc, DBT_TEXT, FALSE);
        break;
    }

    if (!pbfPush)
        SelectObject(hdc, hbrBtnSave);

    /*
     * Release the font which may have been loaded by xxxButtonInitDC.
     */
    if (pbutn->hFont) {
        SelectObject(hdc, ghFontSys);
    }
}
/***************************************************************************\
* RepaintButton
*
\***************************************************************************/
void RepaintButton (PBUTN pbutn)
{
    HDC hdc = xxxBNGetDC(pbutn, NULL);
    if (hdc != NULL) {
        xxxBNPaint(pbutn, hdc);
        BNReleaseDC(pbutn, hdc);
    }
}
/***************************************************************************\
* ButtonWndProc
*
* WndProc for buttons, check boxes, etc.
*
* History:
\***************************************************************************/

LRESULT APIENTRY ButtonWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    UINT bsWnd;
    UINT wOldState;
    RECT rc;
    POINT pt;
    HDC hdc;
    HBRUSH      hbr;
    PAINTSTRUCT ps;
    TL tlpwndParent;
    PBUTN pbutn;
    PWND pwndParent;
    static BOOL fInit = TRUE;
    LONG lResult;

    CheckLock(pwnd);

    bsWnd = TestWF(pwnd, BFTYPEMASK);

    VALIDATECLASSANDSIZE(pwnd, FNID_BUTTON);
    INITCONTROLLOOKASIDE(&ButtonLookaside, BUTN, spwnd, 8);

    /*
     * Get the pbutn for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,pbutn) when
     * we initially created the button control.
     */
    pbutn = ((PBUTNWND)pwnd)->pbutn;

    switch (message) {
    case WM_NCHITTEST:
        if (bsWnd == LOBYTE(BS_GROUPBOX)) {
            return (LONG)HTTRANSPARENT;
        } else {
            goto CallDWP;
        }

    case WM_ERASEBKGND:
        if (bsWnd == LOBYTE(BS_OWNERDRAW)) {

            /*
             * Handle erase background for owner draw buttons.
             */
            _GetClientRect(pwnd, &rc);
            ThreadLock(pwnd->spwndParent, &tlpwndParent);
            pwndParent = REBASEPWND(pwnd, spwndParent);
            PaintRect(HW(pwndParent), hwnd, (HDC)wParam, (HBRUSH)CTLCOLOR_BTN, &rc);
            ThreadUnlock(&tlpwndParent);
        }

        /*
         * Do nothing for other buttons, but don't let DefWndProc() do it
         * either.  It will be erased in xxxBNPaint().
         */
        return (LONG)TRUE;

    case WM_PRINTCLIENT:
        xxxBNPaint(pbutn, (HDC)wParam);
        break;

    case WM_PAINT:

        /*
         * If wParam != NULL, then this is a subclassed paint.
         */
        if ((hdc = (HDC)wParam) == NULL)
            hdc = NtUserBeginPaint(hwnd, &ps);

        if (IsVisible(pwnd))
            xxxBNPaint(pbutn, hdc);

        if (!wParam)
            NtUserEndPaint(hwnd, &ps);
        break;

    case WM_SETFOCUS:
        BUTTONSTATE(pbutn) |= BST_FOCUS;
        if ((hdc = xxxBNGetDC(pbutn, NULL)) != NULL) {
            xxxBNDrawText(pbutn, hdc, DBT_FOCUS, FALSE);

            BNReleaseDC(pbutn, hdc);
        }

        if (TestWF(pwnd, BFNOTIFY))
            xxxButtonNotifyParent(pwnd, BN_SETFOCUS);

        if (!(BUTTONSTATE(pbutn) & BST_INCLICK)) {
            switch (bsWnd) {
            case LOBYTE(BS_RADIOBUTTON):
            case LOBYTE(BS_AUTORADIOBUTTON):
                if (!(BUTTONSTATE(pbutn) & BST_DONTCLICK)) {
                    if (!(BUTTONSTATE(pbutn) & BST_CHECKMASK)) {
                        xxxButtonNotifyParent(pwnd, BN_CLICKED);
                    }
                }
                break;
            }
        }
        break;

    case WM_GETDLGCODE:
        switch (bsWnd) {
        case LOBYTE(BS_DEFPUSHBUTTON):
            wParam = DLGC_DEFPUSHBUTTON;
            break;

        case LOBYTE(BS_PUSHBUTTON):
        case LOBYTE(BS_PUSHBOX):
            wParam = DLGC_UNDEFPUSHBUTTON;
            break;

        case LOBYTE(BS_AUTORADIOBUTTON):
        case LOBYTE(BS_RADIOBUTTON):
            wParam = DLGC_RADIOBUTTON;
            break;

        case LOBYTE(BS_GROUPBOX):
            return (LONG)DLGC_STATIC;

        case LOBYTE(BS_CHECKBOX):
        case LOBYTE(BS_AUTOCHECKBOX):

            /*
             * If this is a char that is a '=/+', or '-', we want it
             */
            if (lParam && ((LPMSG)lParam)->message == WM_CHAR) {
                switch (wParam) {
                case TEXT('='):
                case TEXT('+'):
                case TEXT('-'):
                    wParam = DLGC_WANTCHARS;
                    break;

                default:
                    wParam = 0;
                }
            } else {
                wParam = 0;
            }
            break;

        default:
            wParam = 0;
        }
        return (LONG)(wParam | DLGC_BUTTON);

    case WM_CAPTURECHANGED:
        if (BUTTONSTATE(pbutn) & BST_CAPTURED) {
            // Unwittingly, we've been kicked out of capture,
            // so undepress etc.
            if (BUTTONSTATE(pbutn) & BST_MOUSE)
                SendMessageWorker(pwnd, BM_SETSTATE, FALSE, 0, FALSE);
            BUTTONSTATE(pbutn) &= ~(BST_CAPTURED | BST_MOUSE);
        }
        break;

    case WM_KILLFOCUS:

        /*
         * If we are losing the focus and we are in "capture mode", click
         * the button.  This allows tab and space keys to overlap for
         * fast toggle of a series of buttons.
         */
        if (BUTTONSTATE(pbutn) & BST_MOUSE) {

            /*
             * If for some reason we are killing the focus, and we have the
             * mouse captured, don't notify the parent we got clicked.  This
             * breaks Omnis Quartz otherwise.
             */
            SendMessageWorker(pwnd, BM_SETSTATE, FALSE, 0, FALSE);
        }

        xxxBNReleaseCapture(pbutn, TRUE);

        BUTTONSTATE(pbutn) &= ~BST_FOCUS;
        if ((hdc = xxxBNGetDC(pbutn, NULL)) != NULL) {
            xxxBNDrawText(pbutn, hdc, DBT_FOCUS, FALSE);

            BNReleaseDC(pbutn, hdc);
        }

        if (TestWF(pwnd, BFNOTIFY))
            xxxButtonNotifyParent(pwnd, BN_KILLFOCUS);

        /*
         * Since the bold border around the defpushbutton is done by
         * someone else, we need to invalidate the rect so that the
         * focus rect is repainted properly.
         */
        NtUserInvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_LBUTTONDBLCLK:

        /*
         * Double click messages are recognized for BS_RADIOBUTTON,
         * BS_USERBUTTON, and BS_OWNERDRAW styles.  For all other buttons,
         * double click is handled like a normal button down.
         */
        switch (bsWnd) {
        default:
            if (!TestWF(pwnd, BFNOTIFY))
                goto btnclick;

        case LOBYTE(BS_USERBUTTON):
        case LOBYTE(BS_RADIOBUTTON):
        case LOBYTE(BS_OWNERDRAW):
            xxxButtonNotifyParent(pwnd, BN_DOUBLECLICKED);
            break;
        }
        break;

    case WM_LBUTTONUP:
        if (BUTTONSTATE(pbutn) & BST_MOUSE) {
            xxxBNReleaseCapture(pbutn, TRUE);
        }
        break;

    case WM_MOUSEMOVE:
        if (!(BUTTONSTATE(pbutn) & BST_MOUSE)) {
            break;
        }

        /*
         *** FALL THRU **
         */
    case WM_LBUTTONDOWN:
btnclick:
        if (xxxBNSetCapture(pbutn, BST_MOUSE)) {
            _GetClientRect(pwnd, &rc);
            POINTSTOPOINT(pt, lParam);
            SendMessageWorker(pwnd, BM_SETSTATE, PtInRect(&rc, pt), 0, FALSE);
        }
        break;

    case WM_CHAR:
        if (BUTTONSTATE(pbutn) & BST_MOUSE)
            goto CallDWP;

        if (bsWnd != LOBYTE(BS_CHECKBOX) &&
            bsWnd != LOBYTE(BS_AUTOCHECKBOX))
            goto CallDWP;

        switch (wParam) {
        case TEXT('+'):
        case TEXT('='):
            wParam = 1;    // we must Set the check mark on.
            goto   SetCheck;

        case TEXT('-'):
            wParam = 0;    // Set the check mark off.
SetCheck:
            // Must notify only if the check status changes
            if ((WORD)(BUTTONSTATE(pbutn) & BST_CHECKMASK) != (WORD)wParam)
            {
                // We must check/uncheck only if it is AUTO
                if (bsWnd == LOBYTE(BS_AUTOCHECKBOX))
                {
                    if (xxxBNSetCapture(pbutn, 0))
                    {
                        SendMessageWorker(pwnd, BM_SETCHECK, wParam, 0, FALSE);

                        xxxBNReleaseCapture(pbutn, TRUE);
                    }
                }

                xxxButtonNotifyParent(pwnd, BN_CLICKED);
            }
            break;

        default:
            goto CallDWP;
        }
        break;

    case BM_CLICK:
        // Don't recurse into this code!
        if (BUTTONSTATE(pbutn) & BST_INBMCLICK)
            break;

        BUTTONSTATE(pbutn) |= BST_INBMCLICK;
        SendMessageWorker(pwnd, WM_LBUTTONDOWN, 0, 0, FALSE);
        SendMessageWorker(pwnd, WM_LBUTTONUP, 0, 0, FALSE);
        BUTTONSTATE(pbutn) &= ~BST_INBMCLICK;

        /*
         *** FALL THRU **
         */

    case WM_KEYDOWN:
        if (BUTTONSTATE(pbutn) & BST_MOUSE)
            break;

        if (wParam == VK_SPACE) {
            if (xxxBNSetCapture(pbutn, 0)) {
                SendMessageWorker(pwnd, BM_SETSTATE, TRUE, 0, FALSE);
            }
        } else {
            xxxBNReleaseCapture(pbutn, FALSE);
        }
        break;

    case WM_KEYUP:
    case WM_SYSKEYUP:
        if (BUTTONSTATE(pbutn) & BST_MOUSE) {
            goto CallDWP;
        }

        /*
         * Don't cancel the capture mode on the up of the tab in case the
         * guy is overlapping tab and space keys.
         */
        if (wParam == VK_TAB) {
            goto CallDWP;
        }

        /*
         * WARNING: pwnd is history after this call!
         */
        xxxBNReleaseCapture(pbutn, (wParam == VK_SPACE));

        if (message == WM_SYSKEYUP) {
            goto CallDWP;
        }
        break;

    case BM_GETSTATE:
        return (LONG)BUTTONSTATE(pbutn);

    case BM_SETSTATE:
        wOldState = (UINT)(BUTTONSTATE(pbutn) & BST_PUSHED);
        if (wParam) {
            BUTTONSTATE(pbutn) |= BST_PUSHED;
        } else {
            BUTTONSTATE(pbutn) &= ~BST_PUSHED;
        }

        if ((hdc = xxxBNGetDC(pbutn, &hbr)) != NULL) {
            if (bsWnd == LOBYTE(BS_USERBUTTON)) {
                xxxButtonNotifyParent(pwnd, (UINT)(wParam ? BN_PUSHED : BN_UNPUSHED));
            } else if (bsWnd == LOBYTE(BS_OWNERDRAW)) {
                if (wOldState != (UINT)(BUTTONSTATE(pbutn) & BST_PUSHED)) {
                    /*
                     * Only notify for drawing if state has changed..
                     */
                    xxxBNOwnerDraw(pbutn, hdc, ODA_SELECT);
                }
            } else {
                xxxButtonDrawNewState(pbutn, hdc, hbr, wOldState);
            }

            BNReleaseDC(pbutn, hdc);
        }
        if (wOldState != (BOOL)(BUTTONSTATE(pbutn) & BST_PUSHED)) {
            NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        }
        break;

    case BM_GETCHECK:
        return (LONG)(BUTTONSTATE(pbutn) & BST_CHECKMASK);

    case BM_SETCHECK:
        switch (bsWnd) {
        case LOBYTE(BS_RADIOBUTTON):
        case LOBYTE(BS_AUTORADIOBUTTON):
            if (wParam) {
                    SetWindowState(pwnd, WFTABSTOP);
            } else {
                    ClearWindowState(pwnd, WFTABSTOP);
            }

            /*
             *** FALL THRU **
             */
        case LOBYTE(BS_CHECKBOX):
        case LOBYTE(BS_AUTOCHECKBOX):
            if (wParam) {
                wParam = 1;
            }
            goto CheckIt;

        case LOBYTE(BS_3STATE):
        case LOBYTE(BS_AUTO3STATE):
            if (wParam > BST_INDETERMINATE) {
                wParam = BST_INDETERMINATE;
            }
CheckIt:
            if ((UINT)(BUTTONSTATE(pbutn) & BST_CHECKMASK) != (UINT)wParam) {
                BUTTONSTATE(pbutn) &= ~BST_CHECKMASK;
                BUTTONSTATE(pbutn) |= (UINT)wParam;

                if (!IsVisible(pwnd))
                    break;

                if ((hdc = xxxBNGetDC(pbutn, &hbr)) != NULL) {
                    if (TestWF(pwnd, BFPUSHLIKE)) {
                        xxxDrawButton(pbutn, hdc, PBF_PUSHABLE);
                    } else {
                        xxxButtonDrawCheck(pbutn, hdc, hbr);
                    }
                    BNReleaseDC(pbutn, hdc);
                }

                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
            }
            break;
        }
        break;

    case BM_SETSTYLE:
        NtUserAlterWindowStyle(hwnd, BS_TYPEMASK, (DWORD)wParam);

        if (lParam) {
            NtUserInvalidateRect(hwnd, NULL, TRUE);
        }
        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        break;

    case WM_SETTEXT:

        /*
         * In case the new group name is longer than the old name,
         * this paints over the old name before repainting the group
         * box with the new name.
         */
        if (bsWnd == LOBYTE(BS_GROUPBOX)) {
            hdc = xxxBNGetDC(pbutn, &hbr);
            if (hdc != NULL) {
                BNCalcRect(pwnd, hdc, &rc, CBR_GROUPTEXT, 0);
                NtUserInvalidateRect(hwnd, &rc, TRUE);

                pwndParent = REBASEPWND(pwnd, spwndParent);
                ThreadLock(pwnd->spwndParent, &tlpwndParent);
                PaintRect(HW(pwndParent), hwnd, hdc, hbr, &rc);
                ThreadUnlock(&tlpwndParent);

                BNReleaseDC(pbutn, hdc);
            }
        }

        lResult = _DefSetText(hwnd, (LPWSTR)lParam, (BOOL)fAnsi);

        NotifyWinEvent(EVENT_OBJECT_NAMECHANGE, hwnd, OBJID_WINDOW, INDEXID_CONTAINER);
        goto DoEnable;

        /*
         *** FALL THRU **
         */
    case WM_ENABLE:
        lResult = 0L;
DoEnable:
        RepaintButton(pbutn);
        return lResult;

    case WM_SETFONT:
        /*
         * wParam - handle to the font
         * lParam - if true, redraw else don't
         */
        BNSetFont(pbutn, (HFONT)wParam, (BOOL)(lParam != 0));
        break;

    case WM_GETFONT:
        return (LRESULT)pbutn->hFont;

    case BM_GETIMAGE:
    case BM_SETIMAGE:
        if (!IsValidImage(wParam, TestWF(pwnd, BFIMAGEMASK), IMAGE_BMMAX)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid button image type");
        } else {
            HANDLE  hOld = pbutn->hImage;

            if (message == BM_SETIMAGE) {
                pbutn->hImage = (HANDLE)lParam;
                if (TestWF(pwnd, WFVISIBLE)) {
                    NtUserInvalidateRect(hwnd, NULL, TRUE);
                }
            }
            return (LRESULT)hOld;
        }
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        if (pbutn) {
            Unlock(&pbutn->spwnd);
            FreeLookasideEntry(&ButtonLookaside, pbutn);
        }
        NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);
        break;

    case WM_NCCREATE:
        // Borland's OBEX has a button with style 0x98; We didn't strip
        // these bits in win3.1 because we checked for 0x08.
        // Stripping these bits cause a GP Fault in OBEX.
        // For win3.1 guys, I use the old code to strip the style bits.
        //
        if (TestWF(pwnd, WFWIN31COMPAT)) {
            if(((!TestWF(pwnd, WFWIN40COMPAT)) &&
                (((LOBYTE(pwnd->style)) & (LOBYTE(~BS_LEFTTEXT))) == LOBYTE(BS_USERBUTTON))) ||
               (TestWF(pwnd, WFWIN40COMPAT) &&
               (bsWnd == LOBYTE(BS_USERBUTTON))))
            {
                // BS_USERBUTTON is no longer allowed for 3.1 and beyond.
                // Just turn to normal push button.
                NtUserAlterWindowStyle(hwnd, BS_TYPEMASK, 0);
                RIPMSG0(RIP_WARNING, "BS_USERBUTTON no longer supported");
            }
        }
        if (TestWF(pwnd,WEFRIGHT)) {
            NtUserAlterWindowStyle(hwnd, BS_RIGHT | BS_RIGHTBUTTON, BS_RIGHT | BS_RIGHTBUTTON);
        }
        goto CallDWP;

    case WM_INPUTLANGCHANGEREQUEST:

        //
        // #115190
        // If the window is one of controls on top of dialogbox,
        // let the parent dialog handle it.
        //
        if (TestwndChild(pwnd) && pwnd->spwndParent) {
            PWND pwndParent = REBASEPWND(pwnd, spwndParent);
            if (pwndParent) {
                PCLS pclsParent = REBASEALWAYS(pwndParent, pcls);

                UserAssert(pclsParent != NULL);
                if (pclsParent->atomClassName == gpsi->atomSysClass[ICLS_DIALOG]) {
                    RIPMSG0(RIP_VERBOSE, "Button: WM_INPUTLANGCHANGEREQUEST is sent to parent.\n");
                    return SendMessageWorker(pwndParent, message, wParam, lParam, FALSE);
                }
            }
        }
        goto CallDWP;

    case WM_UPDATEUISTATE:
        {
            DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
            if (ISBSTEXTOROD(pwnd)) {
                pbutn->fPaintKbdCuesOnly = TRUE;
                RepaintButton(pbutn);
                pbutn->fPaintKbdCuesOnly = FALSE;
            }
        }
        break;

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }

    return 0L;
}

/***************************************************************************\
\***************************************************************************/

LRESULT WINAPI ButtonWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_BUTTON))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, TRUE);

    return ButtonWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI ButtonWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_BUTTON))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, FALSE);

    return ButtonWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\clenum.c ===
/****************************** Module Header ******************************\
* Module Name: clenum
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* For enumeration functions
*
* 04-27-91 ScottLu Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define IEP_UNICODE 0x1 // Convert Atom to unicode string (vs ANSI)
#define IEP_ENUMEX 0x2 // Pass lParam back to callback function (vs no lParam)

HWND *phwndCache = NULL;


/***************************************************************************\
* InternalEnumWindows
*
* Calls server and gets back a window list. This list is enumerated, for each
* window the callback address is called (into the application), until either
* end-of-list is reached or FALSE is return ed. lParam is passed into the
* callback function for app reference.
*
*
* If any windows are returned (cHwnd > 0) the caller is responsible for
* freeing the window buffer when done with the list
*
*
* 04-27-91 ScottLu Created.
\***************************************************************************/

DWORD BuildHwndList(
    HDESK hdesk,
    HWND hwndNext,
    BOOL fEnumChildren,
    DWORD idThread,
    HWND **pphwndFirst)
{
    UINT cHwnd;
    HWND *phwndFirst;
    NTSTATUS Status;
    int cTries;

    /*
     * Allocate a buffer to hold the names.
     */
    cHwnd = 64;
    phwndFirst = (HWND *)InterlockedExchangePointer(&(PVOID)phwndCache, 0);
    if (phwndFirst == NULL) {
        phwndFirst = UserLocalAlloc(0, cHwnd * sizeof(HWND));
        if (phwndFirst == NULL)
            return 0;
    }

    Status = NtUserBuildHwndList(hdesk, hwndNext, fEnumChildren,
            idThread, cHwnd, phwndFirst, &cHwnd);

    /*
     * If the buffer wasn't big enough, reallocate
     * the buffer and try again.
     */
    cTries = 0;
    while (Status == STATUS_BUFFER_TOO_SMALL) {
        UserLocalFree(phwndFirst);

        /*
         * If we can't seem to get it right,
         * call it quits
         */
        if (cTries++ == 10)
            return 0;

        phwndFirst = UserLocalAlloc(0, cHwnd * sizeof(HWND));
        if (phwndFirst == NULL)
            return 0;

        Status = NtUserBuildHwndList(hdesk, hwndNext, fEnumChildren,
                idThread, cHwnd, phwndFirst, &cHwnd);
    }

    if (!NT_SUCCESS(Status) || cHwnd <= 1) {
        UserLocalFree(phwndFirst);
        return 0;
    }

    *pphwndFirst = phwndFirst;
    return cHwnd - 1;
}

BOOL InternalEnumWindows(
    HDESK hdesk,
    HWND hwnd,
    WNDENUMPROC lpfn,
    LPARAM lParam,
    DWORD idThread,
    BOOL fEnumChildren)
{
    UINT i;
    UINT cHwnd;
    HWND *phwndT;
    HWND *phwndFirst;
    BOOL fSuccess = TRUE;

    /*
     * Get the hwnd list.  It is returned in a block of memory
     * allocated with LocalAlloc.
     */
    if ((cHwnd = BuildHwndList(hdesk, hwnd, fEnumChildren, idThread,
            &phwndFirst)) == -1) {
        return FALSE;
    }

    /*
     * In Win 3.1 it was not an error if there were no windows in the thread
     */
    if (cHwnd == 0) {
        if (idThread == 0)
            return FALSE;
        else
            return TRUE;
    }


    /*
     * Loop through the windows, call the function pointer back for each
     * one. End loop if either FALSE is return ed or the end-of-list is
     * reached.
     */
    phwndT = phwndFirst;
    for (i = 0; i < cHwnd; i++) {

        /*
         * call ValidateHwnd instead of RevalidateHwnd so that
         * restricted processes don't see handles they are not
         * suppose to see.
         */
        if (ValidateHwnd(*phwndT)) {
            if (!(fSuccess = (*lpfn)(*phwndT, lParam)))
                break;
        }
        phwndT++;
    }

    /*
     * Free up buffer and return status - TRUE if entire list was enumerated,
     * FALSE otherwise.
     */
    phwndT = (HWND *)InterlockedExchangePointer(&(PVOID)phwndCache, phwndFirst);
    if (phwndT != NULL) {
        UserLocalFree(phwndT);
    }
    return fSuccess;
}


/***************************************************************************\
* EnumWindows
*
* Enumerates all top-level windows. Calls back lpfn with each hwnd until
* either end-of-list or FALSE is return ed. lParam is passed into callback
* function for app reference.
*
* 04-27-91 ScottLu Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, EnumWindows, WNDENUMPROC, lpfn, LPARAM, lParam)
BOOL WINAPI EnumWindows(
    WNDENUMPROC lpfn,
    LPARAM lParam)
{
    return InternalEnumWindows(NULL, NULL, lpfn, lParam, 0L, FALSE);
}

/***************************************************************************\
* EnumChildWindows
*
* Enumerates all children of the passed in window. Calls back lpfn with each
* hwnd until either end-of-list or FALSE is return ed. lParam is passed into
* callback function for app reference.
*
* 04-27-91 ScottLu Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, EnumChildWindows, HWND, hwnd, WNDENUMPROC, lpfn, LPARAM, lParam)
BOOL WINAPI EnumChildWindows(
    HWND hwnd,
    WNDENUMPROC lpfn,
    LPARAM lParam)
{
    return InternalEnumWindows(NULL, hwnd, lpfn, lParam, 0L, TRUE);
}

/***************************************************************************\
* EnumThreadWindows
*
* Enumerates all top level windows created by idThread. Calls back lpfn with
* each hwnd until either end-of-list or FALSE is return ed. lParam is passed
* into callback function for app reference.
*
* 06-23-91 ScottLu Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumThreadWindows, DWORD, idThread, WNDENUMPROC, lpfn, LPARAM, lParam)
BOOL EnumThreadWindows(
    DWORD idThread,
    WNDENUMPROC lpfn,
    LPARAM lParam)
{
    return InternalEnumWindows(NULL, NULL, lpfn, lParam, idThread, FALSE);
}

/***************************************************************************\
* EnumDesktopWindows
*
* Enumerates all top level windows on the desktop specified by hdesk.
* Calls back lpfn with each hwnd until either end-of-list or FALSE
* is returned. lParam is passed into callback function for app reference.
*
* 10-10-94 JimA     Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDesktopWindows, HDESK, hdesk, WNDENUMPROC, lpfn, LPARAM, lParam)
BOOL EnumDesktopWindows(
    HDESK hdesk,
    WNDENUMPROC lpfn,
    LPARAM lParam)
{
    return InternalEnumWindows(hdesk, NULL, lpfn, lParam, 0, FALSE);
}




/***************************************************************************\
* InternalEnumProps
*
* Calls server and gets back a list of props for the specified window.
* The callback address is called (into the application), until either
* end-of-list is reached or FALSE is return ed.
* lParam is passed into the callback function for app reference when
* IEP_ENUMEX is set. Atoms are turned into UNICODE string if IEP_UNICODE
* is set.
*
* 22-Jan-1992 JohnC Created.
\***************************************************************************/

#define MAX_ATOM_SIZE 512
#define ISSTRINGATOM(atom)     ((WORD)(atom) >= 0xc000)

INT InternalEnumProps(
    HWND hwnd,
    PROPENUMPROC lpfn,
    LPARAM lParam,
    UINT flags)
{
    DWORD ii;
    DWORD cPropSets;
    PPROPSET pPropSet;
    WCHAR awch[MAX_ATOM_SIZE];
    PVOID pKey;
    INT iRetVal;
    DWORD cchName;
    NTSTATUS Status;
    int cTries;

    /*
     * Allocate a buffer to hold the names.
     */
    cPropSets = 32;
    pPropSet = UserLocalAlloc(0, cPropSets * sizeof(PROPSET));
    if (pPropSet == NULL)
        return -1;

    Status = NtUserBuildPropList(hwnd, cPropSets, pPropSet, &cPropSets);

    /*
     * If the buffer wasn't big enough, reallocate
     * the buffer and try again.
     */
    cTries = 0;
    while (Status == STATUS_BUFFER_TOO_SMALL) {
        UserLocalFree(pPropSet);

        /*
         * If we can't seem to get it right,
         * call it quits
         */
        if (cTries++ == 10)
            return -1;

        pPropSet = UserLocalAlloc(0, cPropSets * sizeof(PROPSET));
        if (pPropSet == NULL)
            return -1;

        Status = NtUserBuildPropList(hwnd, cPropSets, pPropSet, &cPropSets);
    }

    if (!NT_SUCCESS(Status)) {
        UserLocalFree(pPropSet);
        return -1;
    }

    for (ii=0; ii<cPropSets; ii++) {

        if (ISSTRINGATOM(pPropSet[ii].atom)) {

            pKey = (PVOID)awch;
            if (flags & IEP_UNICODE)
                cchName = GlobalGetAtomNameW(pPropSet[ii].atom, (LPWSTR)pKey, MAX_ATOM_SIZE);
            else
                cchName = GlobalGetAtomNameA(pPropSet[ii].atom, (LPSTR)pKey, sizeof(awch));

            /*
             * If cchName is zero, we must assume that the property belongs
             * to another process.  Because we can't get the name, just skip
             * it.
             */
            if (cchName == 0)
                continue;

        } else {
            pKey = (PVOID)pPropSet[ii].atom;
        }

        if (flags & IEP_ENUMEX) {
            iRetVal = (*(PROPENUMPROCEX)lpfn)(hwnd, pKey,
                    pPropSet[ii].hData, lParam);
        } else {
            iRetVal = (*lpfn)(hwnd, pKey, pPropSet[ii].hData);
        }

        if (!iRetVal)
            break;
    }

    UserLocalFree(pPropSet);

    return iRetVal;
}


/***************************************************************************\
* EnumProps
*
* This function enumerates all entries in the property list of the specified
* window. It enumerates the entries by passing them, one by one, to the
* callback function specified by lpEnumFunc. EnumProps continues until the
* last entry is enumerated or the callback function return s zero.
*
* 22-Jan-1992 JohnC Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, INT, WINAPI, EnumPropsA, HWND, hwnd, PROPENUMPROCA, lpfn)
INT WINAPI EnumPropsA(
    HWND hwnd,
    PROPENUMPROCA lpfn)
{
    return InternalEnumProps(hwnd, (PROPENUMPROC)lpfn, 0, 0);
}



FUNCLOG2(LOG_GENERAL, INT, WINAPI, EnumPropsW, HWND, hwnd, PROPENUMPROCW, lpfn)
INT WINAPI EnumPropsW(
    HWND hwnd,
    PROPENUMPROCW lpfn)
{
    return InternalEnumProps(hwnd, (PROPENUMPROC)lpfn, 0, IEP_UNICODE);
}

/***************************************************************************\
* EnumPropsEx
*
* This function enumerates all entries in the property list of the specified
* window. It enumerates the entries by passing them, one by one, to the
* callback function specified by lpEnumFunc. EnumProps continues until the
* last entry is enumerated or the callback function return s zero.
*
* 22-Jan-1992 JohnC Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, EnumPropsExA, HWND, hwnd, PROPENUMPROCEXA, lpfn, LPARAM, lParam)
BOOL WINAPI EnumPropsExA(
    HWND hwnd,
    PROPENUMPROCEXA lpfn,
    LPARAM lParam)
{
    return InternalEnumProps(hwnd, (PROPENUMPROC)lpfn, lParam, IEP_ENUMEX);
}


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, EnumPropsExW, HWND, hwnd, PROPENUMPROCEXW, lpfn, LPARAM, lParam)
BOOL WINAPI EnumPropsExW(
    HWND hwnd,
    PROPENUMPROCEXW lpfn,
    LPARAM lParam)
{
    return InternalEnumProps(hwnd, (PROPENUMPROC)lpfn, lParam, IEP_UNICODE|IEP_ENUMEX);
}



BOOL InternalEnumObjects(
    HWINSTA hwinsta,
    NAMEENUMPROCW lpfn,
    LPARAM lParam,
    BOOL fAnsi)
{
    PNAMELIST pNameList;
    DWORD i;
    UINT cbData;
    PWCHAR pwch;
    PCHAR pch;
    CHAR achTmp[MAX_PATH];
    BOOL iRetVal;
    NTSTATUS Status;
    int cTries;

    /*
     * Allocate a buffer to hold the names.
     */
    cbData = 256;
    pNameList = UserLocalAlloc(0, cbData);
    if (pNameList == NULL)
        return FALSE;

    Status = NtUserBuildNameList(hwinsta, cbData, pNameList, &cbData);

    /*
     * If the buffer wasn't big enough, reallocate
     * the buffer and try again.
     */
    cTries = 0;
    while (Status == STATUS_BUFFER_TOO_SMALL) {
        UserLocalFree(pNameList);

        /*
         * If we can't seem to get it right,
         * call it quits
         */
        if (cTries++ == 10)
            return FALSE;

        pNameList = UserLocalAlloc(0, cbData);
        if (pNameList == NULL)
            return FALSE;

        Status = NtUserBuildNameList(hwinsta, cbData, pNameList, &cbData);
    }

    if (!NT_SUCCESS(Status)) {
        UserLocalFree(pNameList);
        return FALSE;
    }

    pwch = pNameList->awchNames;
    pch = achTmp;

    for (i = 0; i < pNameList->cNames; i++) {
        if (fAnsi) {
            if (WCSToMB(pwch, -1, &pch, sizeof(achTmp), FALSE) ==
                    sizeof(achTmp)) {

                /*
                 * The buffer may have overflowed, so force it to be
                 * allocated.
                 */
                if (WCSToMB(pwch, -1, &pch, -1, TRUE) == 0) {
                    iRetVal = FALSE;
                    break;
                }
            }
            iRetVal = (*(NAMEENUMPROCA)lpfn)(pch, lParam);
            if (pch != achTmp) {
                UserLocalFree(pch);
                pch = achTmp;
            }
        } else {
            iRetVal = (*(NAMEENUMPROCW)lpfn)(pwch, lParam);
        }
        if (!iRetVal)
            break;

        pwch = pwch + wcslen(pwch) + 1;
    }

    UserLocalFree(pNameList);

    return iRetVal;
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, EnumWindowStationsA, WINSTAENUMPROCA, lpEnumFunc, LPARAM, lParam)
BOOL WINAPI EnumWindowStationsA(
    WINSTAENUMPROCA lpEnumFunc,
    LPARAM lParam)
{
    return InternalEnumObjects(NULL, (NAMEENUMPROCW)lpEnumFunc, lParam, TRUE);
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, EnumWindowStationsW, WINSTAENUMPROCW, lpEnumFunc, LPARAM, lParam)
BOOL WINAPI EnumWindowStationsW(
    WINSTAENUMPROCW lpEnumFunc,
    LPARAM lParam)
{
    return InternalEnumObjects(NULL, (NAMEENUMPROCW)lpEnumFunc, lParam, FALSE);
}



FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, EnumDesktopsA, HWINSTA, hwinsta, DESKTOPENUMPROCA, lpEnumFunc, LPARAM, lParam)
BOOL WINAPI EnumDesktopsA(
    HWINSTA hwinsta,
    DESKTOPENUMPROCA lpEnumFunc,
    LPARAM lParam)
{
    return InternalEnumObjects(hwinsta, (NAMEENUMPROCW)lpEnumFunc, lParam, TRUE);
}


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, EnumDesktopsW, HWINSTA, hwinsta, DESKTOPENUMPROCW, lpEnumFunc, LPARAM, lParam)
BOOL WINAPI EnumDesktopsW(
    HWINSTA hwinsta,
    DESKTOPENUMPROCW lpEnumFunc,
    LPARAM lParam)
{
    return InternalEnumObjects(hwinsta, (NAMEENUMPROCW)lpEnumFunc, lParam, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\clhook.c ===
/****************************** Module Header ******************************\
* Module Name: clhook.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Client-side hook code.
*
* 05-09-1991 ScottLu Created.
* 08-Feb-1992 IanJa Unicode/ANSI
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* SetWindowsHookExAW
*
* Client side routine for SetWindowsHookEx(). Needs to remember the library
* name since hmods aren't global. Remembers the hmod as well so that
* it can be used to calculate pfnFilter in different process contexts.
*
* History:
* 05-15-91 ScottLu Created.
\***************************************************************************/

HHOOK SetWindowsHookExAW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadID,
    DWORD dwFlags)
{
    WCHAR pwszLibFileName[MAX_PATH];

    /*
     * If we're passing an hmod, we need to grab the file name of the
     * module while we're still on the client since module handles
     * are NOT global.
     */
    if (hmod != NULL) {
        if (GetModuleFileNameW(hmod, pwszLibFileName,
                sizeof(pwszLibFileName)/sizeof(TCHAR)) == 0) {

            /*
             * hmod is bogus - return NULL.
             */
            return NULL;
        }
    }

    return _SetWindowsHookEx(hmod,
            (hmod == NULL) ? NULL : pwszLibFileName,
            dwThreadID, idHook, (PROC)lpfn, dwFlags);
}

/***************************************************************************\
* SetWindowsHookA,
* SetWindowsHookW
*
* ANSI and Unicode wrappers for NtUserSetWindowsHookAW(). Could easily be macros
* instead, but do we want to expose NtUserSetWindowsHookAW() ?
*
* History:
* 30-Jan-1992 IanJa   Created
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HHOOK, WINAPI, SetWindowsHookA, int, nFilterType, HOOKPROC, pfnFilterProc)
HHOOK
WINAPI
SetWindowsHookA(
    int nFilterType,
    HOOKPROC pfnFilterProc)
{
    return NtUserSetWindowsHookAW(nFilterType, pfnFilterProc, HF_ANSI);
}



FUNCLOG2(LOG_GENERAL, HHOOK, WINAPI, SetWindowsHookW, int, nFilterType, HOOKPROC, pfnFilterProc)
HHOOK
WINAPI
SetWindowsHookW(
    int nFilterType,
    HOOKPROC pfnFilterProc)
{
    return NtUserSetWindowsHookAW(nFilterType, pfnFilterProc, 0);
}


/***************************************************************************\
* SetWindowsHookExA,
* SetWindowsHookExW
*
* ANSI and Unicode wrappers for SetWindowsHookExAW(). Could easily be macros
* instead, but do we want to expose SetWindowsHookExAW() ?
*
* History:
* 30-Jan-1992 IanJa Created
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, HHOOK, WINAPI, SetWindowsHookExA, int, idHook, HOOKPROC, lpfn, HINSTANCE, hmod, DWORD, dwThreadId)
HHOOK WINAPI SetWindowsHookExA(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId)
{
    return SetWindowsHookExAW(idHook, lpfn, hmod, dwThreadId, HF_ANSI);
}


FUNCLOG4(LOG_GENERAL, HHOOK, WINAPI, SetWindowsHookExW, int, idHook, HOOKPROC, lpfn, HINSTANCE, hmod, DWORD, dwThreadId)
HHOOK WINAPI SetWindowsHookExW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId)
{
    return SetWindowsHookExAW(idHook, lpfn, hmod, dwThreadId, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\clienta.c ===
/**************************************************************************\
* Module Name: clienta.c
*
* Client/Server call related routines dealing with ANSI text.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 04-Dec-90
*
* History:
* 14-Jan-92 created by IanJa
*
\**************************************************************************/

#undef UNICODE

#define NONTOSPINTERLOCK
#include <ntosp.h>

#include <ntrtl.h>      // WINBASEP.H or something.
#include <nturtl.h>
#include <ntcsrmsg.h>

#include "..\client\usercli.h"

#include "cltxt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\cldib.c ===
/****************************** Module Header ******************************\
* Module Name: cldib.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*
* 09-26-95 ChrisWil  Ported dib-scale code.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Constants.
 */
#define FX1  65536   // 1.0 in fixed point


/*
 * Local Macros.
 */
#define BPPTOINDEX(bpp) ((UINT)(bpp) >> 3)

#define RGBQ(r,g,b) RGB(b, g, r)
#define RGBQR(rgb)  GetBValue(rgb)
#define RGBQG(rgb)  GetGValue(rgb)
#define RGBQB(rgb)  GetRValue(rgb)

#define Pel4(p,x)  (BYTE)(((x) & 1) ? (((LPBYTE)(p))[(x)/2] & 15) : (((LPBYTE)(p))[(x)/2] >> 4))
#define Pel8(p,x)  (BYTE)(((LPBYTE)(p))[(x)])
#define Pel16(p,x) (((WORD UNALIGNED *)(p))[(x)])
#define Pel24(p,x) (*(DWORD UNALIGNED *)((LPBYTE)(p) + (x) * 3))

/*
 * Function Typedefs.
 */
typedef VOID (*SCALEPROC)(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
typedef VOID (*INITPROC)(LPBITMAPINFOHEADER);

/*
 * Local Routines.
 */
BOOL     ScaleDIB(LPBITMAPINFOHEADER, LPVOID, LPBITMAPINFOHEADER, LPVOID);
VOID     InitDst8(LPBITMAPINFOHEADER);
VOID     Scale48(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
VOID     Scale88(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
VOID     Scale424(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
VOID     Scale824(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
VOID     Scale2424(LPDWORD, LPBYTE, long, int, int, int, int, LPBYTE, long, int, int);
BYTE     Map8(COLORREF);
COLORREF MixRGBI(LPDWORD, BYTE, BYTE,BYTE, BYTE, int, int);
COLORREF MixRGB(DWORD, DWORD, DWORD, DWORD, int, int);

/*
 * Globals needed for color-mapping of resources.
 */
SCALEPROC  ScaleProc[4][4] = {
    NULL,  Scale48, NULL, Scale424,
    NULL,  Scale88, NULL, Scale824,
    NULL,  NULL   , NULL, NULL,
    NULL,  NULL   , NULL, Scale2424
};

INITPROC InitDst[] = {
    NULL, InitDst8, NULL, NULL
};

BYTE rmap[256], gmap[256], bmap[256];


/***************************************************************************\
* SmartStretchDIBits
*
* calls GDI StretchDIBits, unless the stretch is 2:1 and the source
* is 4bpp, then is does it itself in a nice way.
*
* this optimization should just be put into GDI.
*
* can we change the passed bits? I assume we cant, could avoid a alloc
* if so.
*
\***************************************************************************/

int SmartStretchDIBits(
    HDC          hdc,
    int          xD,
    int          yD,
    int          dxD,
    int          dyD,
    int          xS,
    int          yS,
    int          dxS,
    int          dyS,
    LPVOID       lpBits,
    LPBITMAPINFO lpbi,
    UINT         wUsage,
    DWORD        rop)
{
    LPBYTE             lpBitsNew;
    UINT               bpp;
    RGBQUAD            rgb;
    LPBITMAPINFOHEADER lpbiNew = NULL;

    int i;

    /*
     * thunk to USER32
     */
    UserAssert(rop == SRCCOPY);
    UserAssert(wUsage == DIB_RGB_COLORS);
    UserAssert(xS == 0 && yS == 0);

    if ((GetDIBColorTable(hdc, 0, 1, &rgb) != 1) &&
        (dxD != dxS || dyD != dyS) &&           // 1:1 stretch just call GDI
        (dxD >= dxS/2) && (dyD >= dyS/2) &&     // less than 1:2 shrink call GDI
        (lpbi->bmiHeader.biCompression == 0) && // must be un-compressed
        (lpbi->bmiHeader.biBitCount == 4 ||     // input must be 4,8,24
         lpbi->bmiHeader.biBitCount == 8 ||
         lpbi->bmiHeader.biBitCount == 24)) {

        bpp = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

        bpp = (bpp > 8 ? 24 : 8);

        lpbiNew = (LPBITMAPINFOHEADER)UserLocalAlloc(0,
                 sizeof(BITMAPINFOHEADER) + (256 * sizeof(RGBQUAD)) +
                 (UINT)((((dxD * bpp) / 8) + 3) & ~3) * (UINT)dyD);

        if (lpbiNew) {

            *lpbiNew            = lpbi->bmiHeader;
            lpbiNew->biWidth    = dxD;
            lpbiNew->biHeight   = dyD;
            lpbiNew->biBitCount = (WORD)bpp;
            lpBitsNew = (LPBYTE)lpbiNew          +
                        sizeof(BITMAPINFOHEADER) +
                        (256 * sizeof(RGBQUAD));

            if (ScaleDIB((LPBITMAPINFOHEADER)lpbi,
                         (LPVOID)lpBits,
                         lpbiNew,
                         lpBitsNew)) {

                lpbi   = (LPBITMAPINFO)lpbiNew;
                lpBits = lpBitsNew;
                dxS    = dxD;
                dyS    = dyD;
            }
        }
    }

    i = StretchDIBits(hdc,
                      xD,
                      yD,
                      dxD,
                      dyD,
                      xS,
                      yS,
                      dxS,
                      dyS,
                      lpBits,
                      lpbi,
                      wUsage,
                      rop);

    if (lpbiNew)
        UserLocalFree(lpbiNew);

    return i;
}

/***************************************************************************\
* ScaleDIB
*
*   Parameters
*   ----------
*   lpbiSrc - BITMAPINFO of source.
*   lpSrc   - Input bits to crunch.
*   lpbiDst - BITMAPINFO of destination.
*   lpDst   - Output bits to crunch.
*
*
\***************************************************************************/

BOOL ScaleDIB(
    LPBITMAPINFOHEADER lpbiSrc,
    LPVOID             lpSrc,
    LPBITMAPINFOHEADER lpbiDst,
    LPVOID             lpDst)
{
    LPBYTE  pbSrc;
    LPBYTE  pbDst;
    LPDWORD pal;
    int     dxSrc;
    int     dySrc;
    int     dxDst;
    int     dyDst;
    int     iSrc;
    int     iDst;
    int     x0;
    int     y0;
    int     sdx;
    int     sdy;
    LONG    WidthBytesSrc;
    LONG    WidthBytesDst;

    if ((lpbiSrc->biCompression != BI_RGB) ||
        (lpbiDst->biCompression != BI_RGB)) {
        return FALSE;
    }

    iSrc = BPPTOINDEX(lpbiSrc->biBitCount);
    iDst = BPPTOINDEX(lpbiDst->biBitCount);

    if (ScaleProc[iSrc][iDst] == NULL)
        return FALSE;

    dxSrc = (int)lpbiSrc->biWidth;
    dySrc = (int)lpbiSrc->biHeight;

    dxDst = (int)lpbiDst->biWidth;
    dyDst = (int)lpbiDst->biHeight;

    WidthBytesDst = BitmapWidth(lpbiDst->biWidth, lpbiDst->biBitCount);
    WidthBytesSrc = BitmapWidth(lpbiSrc->biWidth, lpbiSrc->biBitCount);

    lpbiDst->biSizeImage = (WidthBytesDst * dyDst);

    pbSrc = (LPBYTE)lpSrc;
    pbDst = (LPBYTE)lpDst;

    pal = (LPDWORD)(lpbiSrc + 1);

    if (InitDst[iDst])
        InitDst[iDst](lpbiDst);

    if ((dxSrc == (dxDst * 2)) && (dySrc == (dyDst * 2))) {

        sdx = FX1 * 2;
        sdy = FX1 * 2;
        y0  = FX1 / 2;
        x0  = FX1 / 2;

    } else {

        sdx = (dxSrc - 1) * FX1 / (dxDst - 1);
        sdy = (dySrc - 1) * FX1 / (dyDst - 1);
        y0  = 0;
        x0  = 0;
    }

    /*
     * Make sure we don't croak on a bad bitmap since this can hose winlogon
     * if it's the desktop wallpaper.
     */
    try {
        ScaleProc[iSrc][iDst](pal,
                              pbSrc,
                              WidthBytesSrc,
                              x0,
                              y0,
                              sdx,
                              sdy,
                              pbDst,
                              WidthBytesDst,
                              dxDst,
                              dyDst);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* Scale48
*
*
\***************************************************************************/

VOID Scale48(
    LPDWORD pal,
    LPBYTE  pbSrc,
    LONG    WidthBytesSrc,
    int     x0,
    int     y0,
    int     sdx,
    int     sdy,
    LPBYTE  pbDst,
    LONG    WidthBytesDst,
    int     dxDst,
    int     dyDst)
{
    BYTE    b0;
    BYTE    b1;
    BYTE    b2;
    BYTE    b3;
    LPBYTE  pb;
    int     x;
    int     y;
    UINT    sx;
    UINT    sy;

    for (sy=y0, y=0; y < dyDst; y++, sy+=sdy) {

        pb = pbSrc + (WidthBytesSrc * (sy / FX1));

        for (sx=x0, x=0; x < dxDst; x++, sx+=sdx) {

            b0 = Pel4(pb, (sx / FX1));
            b1 = Pel4(pb, (sx / FX1) + 1);
            b2 = Pel4(pb + WidthBytesSrc, (sx / FX1));
            b3 = Pel4(pb + WidthBytesSrc, (sx / FX1) + 1);

            pbDst[x] = Map8(MixRGBI(pal, b0, b1, b2, b3, sx % FX1, sy % FX1));
        }

        pbDst += WidthBytesDst;
    }
}

/***************************************************************************\
* Scale88
*
*
\***************************************************************************/

VOID Scale88(
    LPDWORD pal,
    LPBYTE  pbSrc,
    LONG    WidthBytesSrc,
    int     x0,
    int     y0,
    int     sdx,
    int     sdy,
    LPBYTE  pbDst,
    LONG    WidthBytesDst,
    int     dxDst,
    int     dyDst)
{
    BYTE   b0;
    BYTE   b1;
    BYTE   b2;
    BYTE   b3;
    LPBYTE pb;
    int    x;
    int    y;
    UINT   sx;
    UINT   sy;

    for (sy=y0, y=0; y < dyDst; y++, sy+=sdy) {

        pb = pbSrc + (WidthBytesSrc * (sy / FX1));

        for (sx=x0, x=0; x < dxDst; x++, sx+=sdx) {

            b0 = Pel8(pb, (sx / FX1));
            b1 = Pel8(pb, (sx / FX1) + 1);
            b2 = Pel8(pb + WidthBytesSrc, (sx / FX1));
            b3 = Pel8(pb + WidthBytesSrc, (sx / FX1) + 1);

            pbDst[x] = Map8(MixRGBI(pal, b0, b1, b2, b3, sx % FX1, sy % FX1));
        }

        pbDst += WidthBytesDst;
    }
}

/***************************************************************************\
* Scale424
*
*
\***************************************************************************/

VOID Scale424(
    LPDWORD pal,
    LPBYTE  pbSrc,
    LONG    WidthBytesSrc,
    int     x0,
    int     y0,
    int     sdx,
    int     sdy,
    LPBYTE  pbDst,
    LONG    WidthBytesDst,
    int     dxDst,
    int     dyDst)
{
    BYTE     b0;
    BYTE     b1;
    BYTE     b2;
    BYTE     b3;
    LPBYTE   pb;
    int      x;
    int      y;
    UINT     sx;
    UINT     sy;
    COLORREF rgb;

    for (sy=y0, y=0; y < dyDst; y++, sy+=sdy) {

        pb = pbSrc + (WidthBytesSrc * (sy / FX1));

        for (sx=x0, x=0; x < dxDst; x++, sx+=sdx) {

            b0 = Pel4(pb, (sx / FX1));
            b1 = Pel4(pb, (sx / FX1) + 1);
            b2 = Pel4(pb + WidthBytesSrc, (sx / FX1));
            b3 = Pel4(pb + WidthBytesSrc, (sx / FX1) + 1);

            rgb = MixRGBI(pal, b0, b1, b2, b3, sx % FX1, sy % FX1);

            *pbDst++ = GetBValue(rgb);
            *pbDst++ = GetGValue(rgb);
            *pbDst++ = GetRValue(rgb);
        }

        pbDst += (WidthBytesDst - (dxDst * 3));
    }
}

/***************************************************************************\
* Scale824
*
*
\***************************************************************************/

VOID Scale824(
    LPDWORD pal,
    LPBYTE  pbSrc,
    LONG    WidthBytesSrc,
    int     x0,
    int     y0,
    int     sdx,
    int     sdy,
    LPBYTE  pbDst,
    LONG    WidthBytesDst,
    int     dxDst,
    int     dyDst)
{
    BYTE     b0;
    BYTE     b1;
    BYTE     b2;
    BYTE     b3;
    LPBYTE   pb;
    int      x;
    int      y;
    UINT     sx;
    UINT     sy;
    COLORREF rgb;

    for (sy=y0, y=0; y < dyDst; y++, sy+=sdy) {

        pb = pbSrc + (WidthBytesSrc * (sy / FX1));

        for (sx=x0, x=0; x < dxDst; x++, sx+=sdx) {

            b0 = Pel8(pb, (sx / FX1));
            b1 = Pel8(pb, (sx / FX1) + 1);
            b2 = Pel8(pb + WidthBytesSrc, (sx / FX1));
            b3 = Pel8(pb + WidthBytesSrc, (sx / FX1) + 1);

            rgb = MixRGBI(pal, b0, b1, b2, b3, sx % FX1, sy % FX1);

            *pbDst++ = GetBValue(rgb);
            *pbDst++ = GetGValue(rgb);
            *pbDst++ = GetRValue(rgb);
        }

        pbDst += (WidthBytesDst - (dxDst * 3));
    }
}

/***************************************************************************\
* Scale2424
*
*
\***************************************************************************/

VOID Scale2424(
    LPDWORD pal,
    LPBYTE  pbSrc,
    LONG    WidthBytesSrc,
    int     x0,
    int     y0,
    int     sdx,
    int     sdy,
    LPBYTE  pbDst,
    LONG    WidthBytesDst,
    int     dxDst,
    int     dyDst)
{
    DWORD    bgr0;
    DWORD    bgr1;
    DWORD    bgr2;
    DWORD    bgr3;
    LPBYTE   pb;
    int      x;
    int      y;
    UINT     sx;
    UINT     sy;
    COLORREF rgb;

    UNREFERENCED_PARAMETER(pal);

    for (sy=y0, y=0; y < dyDst; y++, sy+=sdy) {

        pb = pbSrc + (WidthBytesSrc * (sy / FX1));

        for (sx=x0, x=0; x < dxDst; x++, sx+=sdx) {

            bgr0 = Pel24(pb, (sx / FX1));
            bgr1 = Pel24(pb, (sx / FX1) + 1);
            bgr2 = Pel24(pb + WidthBytesSrc, (sx / FX1));
            bgr3 = Pel24(pb + WidthBytesSrc, (sx / FX1) + 1);

            rgb = MixRGB(bgr0, bgr1, bgr2, bgr3, sx % FX1, sy % FX1);

            *pbDst++ = GetBValue(rgb);
            *pbDst++ = GetGValue(rgb);
            *pbDst++ = GetRValue(rgb);
        }

        pbDst += (WidthBytesDst - (dxDst * 3));
    }
}

/***************************************************************************\
* MixRGB
*
*   r0  x   r1
*   y   *
*   r2  r3
*
* Note: inputs are RGBQUADs, output is a COLORREF.
*
\***************************************************************************/

COLORREF MixRGB(
    DWORD r0,
    DWORD r1,
    DWORD r2,
    DWORD r3,
    int   x,
    int   y)
{
    int r;
    int g;
    int b;

    if (x == 0 && y == 0) {

        r = RGBQR(r0);
        g = RGBQG(r0);
        b = RGBQB(r0);

    } else if (x == 0) {

        r = ((FX1-y) * RGBQR(r0) + y * RGBQR(r2))/FX1;
        g = ((FX1-y) * RGBQG(r0) + y * RGBQG(r2))/FX1;
        b = ((FX1-y) * RGBQB(r0) + y * RGBQB(r2))/FX1;
    }
    else if (y == 0)
    {
        r = ((FX1-x) * RGBQR(r0) + x * RGBQR(r1))/FX1;
        g = ((FX1-x) * RGBQG(r0) + x * RGBQG(r1))/FX1;
        b = ((FX1-x) * RGBQB(r0) + x * RGBQB(r1))/FX1;
    }
    else if (x == FX1/2 && y == FX1/2)
    {
        r = (RGBQR(r0) + RGBQR(r1) + RGBQR(r2) + RGBQR(r3))/4;
        g = (RGBQG(r0) + RGBQG(r1) + RGBQG(r2) + RGBQG(r3))/4;
        b = (RGBQB(r0) + RGBQB(r1) + RGBQB(r2) + RGBQB(r3))/4;
    }
    else
    {
        r =((ULONG)RGBQR(r0) * (FX1-x) / FX1 * (FX1-y) + (ULONG)RGBQR(r1) * x / FX1 * (FX1-y) +
            (ULONG)RGBQR(r2) * (FX1-x) / FX1 * y       + (ULONG)RGBQR(r3) * x / FX1 * y       )/FX1;

        g =((ULONG)RGBQG(r0) * (FX1-x) / FX1 * (FX1-y) + (ULONG)RGBQG(r1) * x / FX1 * (FX1-y) +
            (ULONG)RGBQG(r2) * (FX1-x) / FX1 * y       + (ULONG)RGBQG(r3) * x / FX1 * y       )/FX1;

        b =((ULONG)RGBQB(r0) * (FX1-x) / FX1 * (FX1-y) + (ULONG)RGBQB(r1) * x / FX1 * (FX1-y) +
            (ULONG)RGBQB(r2) * (FX1-x) / FX1 * y       + (ULONG)RGBQB(r3) * x / FX1 * y       )/FX1;
    }

    return RGB(r,g,b);
}

/***************************************************************************\
* MixRGBI
*
*
\***************************************************************************/

_inline COLORREF MixRGBI(
    LPDWORD pal,
    BYTE    b0,
    BYTE    b1,
    BYTE    b2,
    BYTE    b3,
    int     x,
    int     y)
{
    if (((b0 == b1) && (b1 == b2) && (b2 == b3)) || ((x == 0) && (y == 0)))
        return RGBX(pal[b0]);
    else
        return MixRGB(pal[b0], pal[b1], pal[b2], pal[b3], x, y);
}

/***************************************************************************\
* InitDst8
*
*
\***************************************************************************/

_inline VOID InitDst8(
    LPBITMAPINFOHEADER lpbi)
{
    int     r;
    int     g;
    int     b;
    LPDWORD pdw;

    pdw = (LPDWORD)(lpbi + 1);
    lpbi->biClrUsed = 6*6*6;

    for (r=0; r < 6; r++) {

        for (g=0; g < 6; g++) {

            for (b=0; b < 6; b++) {
                *pdw++ = RGBQ((r * 255) / 5, (g * 255) / 5, (b * 255) / 5);
            }
        }
    }

    for (b=0; b < 256; b++) {
        bmap[b] = (b * 5 + 128) / 255;
        gmap[b] = 6 * bmap[b];
        rmap[b] = 36 * bmap[b];
    }
}

/***************************************************************************\
* Map8
*
*
\***************************************************************************/

_inline BYTE Map8(
    COLORREF rgb)
{
    return rmap[GetRValue(rgb)] +
           gmap[GetGValue(rgb)] +
           bmap[GetBValue(rgb)];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\classc.c ===
/****************************** Module Header ******************************\
* Module Name: classc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains
*
* History:
* 15-Dec-1993 JohnC      Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * These arrays are used by GetClassWord/Long.
 */

// !!! can't we get rid of this and just special case GCW_ATOM

CONST BYTE afClassDWord[] = {
     FIELD_SIZE(CLS, spicnSm),          // GCL_HICONSM       (-34)
     0,
     FIELD_SIZE(CLS, atomNVClassName),    // GCW_ATOM          (-32)
     0,
     0,
     0,
     0,
     0,
     FIELD_SIZE(CLS, style),            // GCL_STYLE         (-26)
     0,
     FIELD_SIZE(CLS, lpfnWndProc),      // GCL_WNDPROC       (-24)
     0,
     0,
     0,
     FIELD_SIZE(CLS, cbclsExtra),       // GCL_CBCLSEXTRA    (-20)
     0,
     FIELD_SIZE(CLS, cbwndExtra),       // GCL_CBWNDEXTRA    (-18)
     0,
     FIELD_SIZE(CLS, hModule),          // GCL_HMODULE       (-16)
     0,
     FIELD_SIZE(CLS, spicn),            // GCL_HICON         (-14)
     0,
     FIELD_SIZE(CLS, spcur),            // GCL_HCURSOR       (-12)
     0,
     FIELD_SIZE(CLS, hbrBackground),    // GCL_HBRBACKGROUND (-10)
     0,
     FIELD_SIZE(CLS, lpszMenuName)      // GCL_HMENUNAME      (-8)
};

CONST BYTE aiClassOffset[] = {
    FIELD_OFFSET(CLS, spicnSm),         // GCL_HICONSM
    0,
    FIELD_OFFSET(CLS, atomNVClassName), // GCW_ATOM
    0,
    0,
    0,
    0,
    0,
    FIELD_OFFSET(CLS, style),           // GCL_STYLE
    0,
    FIELD_OFFSET(CLS, lpfnWndProc),     // GCL_WNDPROC
    0,
    0,
    0,
    FIELD_OFFSET(CLS, cbclsExtra),      // GCL_CBCLSEXTRA
    0,
    FIELD_OFFSET(CLS, cbwndExtra),      // GCL_CBWNDEXTRA
    0,
    FIELD_OFFSET(CLS, hModule),         // GCL_HMODULE
    0,
    FIELD_OFFSET(CLS, spicn),           // GCL_HICON
    0,
    FIELD_OFFSET(CLS, spcur),           // GCL_HCURSOR
    0,
    FIELD_OFFSET(CLS, hbrBackground),   // GCL_HBRBACKGROUND
    0,
    FIELD_OFFSET(CLS, lpszMenuName)     // GCL_MENUNAME
};

/*
 * INDEX_OFFSET must refer to the first entry of afClassDWord[]
 */
#define INDEX_OFFSET GCLP_HICONSM


/***************************************************************************\
* GetClassData
*
* GetClassWord and GetClassLong are now identical routines because they both
* can return DWORDs.  This single routine performs the work for them both
* by using two arrays; afClassDWord to determine whether the result should be
* a UINT or a DWORD, and aiClassOffset to find the correct offset into the
* CLS structure for a given GCL_ or GCL_ index.
*
* History:
* 11-19-90 darrinm      Wrote.
\***************************************************************************/

ULONG_PTR _GetClassData(
    PCLS pcls,
    PWND pwnd,   // used for transition to kernel-mode for GCL_WNDPROC
    int index,
    BOOL bAnsi)
{
    KERNEL_ULONG_PTR dwData;
    DWORD dwCPDType = 0;

    index -= INDEX_OFFSET;

    if (index < 0) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    }

    UserAssert(index >= 0);
    UserAssert(index < sizeof(afClassDWord));
    UserAssert(sizeof(afClassDWord) == sizeof(aiClassOffset));
    if (afClassDWord[index] == sizeof(DWORD)) {
        dwData = *(KPDWORD)(((KPBYTE)pcls) + aiClassOffset[index]);
    } else if (afClassDWord[index] == sizeof(KERNEL_ULONG_PTR)) {
        dwData = *(KPKERNEL_ULONG_PTR)(((KPBYTE)pcls) + aiClassOffset[index]);
    } else {
        dwData = (DWORD)*(KPWORD)(((KPBYTE)pcls) + aiClassOffset[index]);
    }

    index += INDEX_OFFSET;

    /*
     * If we're returning an icon or cursor handle, do the reverse
     * mapping here.
     */
    switch(index) {
    case GCLP_MENUNAME:
        if (IS_PTR(pcls->lpszMenuName)) {
            /*
             * The Menu Name is a real string: return the client-side address.
             * (If the class was registered by another app this returns an
             * address in that app's addr. space, but it's the best we can do)
             */
            dwData = bAnsi ?
                    (ULONG_PTR)pcls->lpszClientAnsiMenuName :
                    (ULONG_PTR)pcls->lpszClientUnicodeMenuName;
        }
        break;

    case GCLP_HICON:
    case GCLP_HCURSOR:
    case GCLP_HICONSM:
        /*
         * We have to go to the kernel to convert the pcursor to a handle because
         * cursors are allocated out of POOL, which is not accessable from the client.
         */
        if (dwData) {
            dwData = NtUserCallHwndParam(PtoH(pwnd), index, SFI_GETCLASSICOCUR);
        }
        break;

    case GCLP_WNDPROC:
        {

        /*
         * Always return the client wndproc in case this is a server
         * window class.
         */

        if (pcls->CSF_flags & CSF_SERVERSIDEPROC) {
            dwData = MapServerToClientPfn(dwData, bAnsi);
        } else {
            KERNEL_ULONG_PTR dwT = dwData;

            dwData = MapClientNeuterToClientPfn(pcls, dwT, bAnsi);

            /*
             * If the client mapping didn't change the window proc then see if
             * we need a callproc handle.
             */
            if (dwData == dwT) {
                /*
                 * Need to return a CallProc handle if there is an Ansi/Unicode mismatch
                 */
                if (bAnsi != !!(pcls->CSF_flags & CSF_ANSIPROC)) {
                    dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
                }
            }
        }

        if (dwCPDType) {
            ULONG_PTR dwCPD;

            dwCPD = GetCPD(pwnd, dwCPDType | CPD_WNDTOCLS, KERNEL_ULONG_PTR_TO_ULONG_PTR(dwData));

            if (dwCPD) {
                dwData = dwCPD;
            } else {
                RIPMSG0(RIP_WARNING, "GetClassLong unable to alloc CPD returning handle\n");
            }
        }
        }
        break;

    case GCL_CBCLSEXTRA:
        if ((pcls->CSF_flags & CSF_WOWCLASS) && (pcls->CSF_flags & CSF_WOWEXTRA)) {
            /*
             * The 16-bit app changed its Extra bytes value.  Return the changed
             * value.  FritzS
             */

            return PWCFromPCLS(pcls)->iClsExtra;
        }
        else
            return pcls->cbclsExtra;

        break;

    /*
     * WOW uses a pointer straight into the class structure.
     */
    case GCLP_WOWWORDS:
        if (pcls->CSF_flags & CSF_WOWCLASS) {
            return ((ULONG_PTR)PWCFromPCLS(pcls));
        } else
            return 0;

    case GCL_STYLE:
        dwData &= CS_VALID;
        break;
    }

    return KERNEL_ULONG_PTR_TO_ULONG_PTR(dwData);
}



/***************************************************************************\
* _GetClassLong (API)
*
* Return a class long.  Positive index values return application class longs
* while negative index values return system class longs.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 10-16-90 darrinm      Wrote.
\***************************************************************************/

ULONG_PTR _GetClassLongPtr(
    PWND pwnd,
    int index,
    BOOL bAnsi)
{
    PCLS pcls = REBASEALWAYS(pwnd, pcls);

    if (index < 0) {
        return _GetClassData(pcls, pwnd, index, bAnsi);
    } else {
        if (index + (int)sizeof(ULONG_PTR) > pcls->cbclsExtra) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return 0;
        } else {
            ULONG_PTR UNALIGNED * KPTR_MODIFIER pudw;
            pudw = (ULONG_PTR UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pcls + 1) + index);
            return *pudw;
        }
    }
}

#ifdef _WIN64
DWORD _GetClassLong(
    PWND pwnd,
    int index,
    BOOL bAnsi)
{
    PCLS pcls = REBASEALWAYS(pwnd, pcls);

    if (index < 0) {
        if (index < INDEX_OFFSET || afClassDWord[index - INDEX_OFFSET] > sizeof(DWORD)) {
            RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "GetClassLong: invalid index %d", index);
            return 0;
        }
        return (DWORD)_GetClassData(pcls, pwnd, index, bAnsi);
    } else {
        if (index + (int)sizeof(DWORD) > pcls->cbclsExtra) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return 0;
        } else {
            DWORD UNALIGNED * KPTR_MODIFIER pudw;
            pudw = (DWORD UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pcls + 1) + index);
            return *pudw;
        }
    }
}
#endif

/***************************************************************************\
* GetClassWord (API)
*
* Return a class word.  Positive index values return application class words
* while negative index values return system class words.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 10-16-90 darrinm      Wrote.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, WORD, DUMMYCALLINGTYPE, GetClassWord, HWND, hwnd, int, index)
WORD GetClassWord(
    HWND hwnd,
    int index)
{
    PWND pwnd;
    PCLS pclsClient;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    pclsClient = (PCLS)REBASEALWAYS(pwnd, pcls);

    try {
        if (index == GCW_ATOM) {
            return (WORD)_GetClassData(pclsClient, pwnd, index, FALSE);
        } else {
            if ((index < 0) || (index + (int)sizeof(WORD) > pclsClient->cbclsExtra)) {
                RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
                return 0;
            } else {
                WORD UNALIGNED * KPTR_MODIFIER puw;
                puw = (WORD UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pclsClient + 1) + index);
                return *puw;
            }
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
            RIP_WARNING,
            "Window %x no longer valid",
            hwnd);
        return 0;
    }

}

/***************************************************************************\
* ClassNameToVersion
*
* Map class name to class name+version.
* lpClassName   : Class name to be mapped, it may be ANSI, Unicode or an Atom.
* pClassVerName : Buffer to receive the class name+version.
* lpDllName     : if it is not NULL it will point to the DLL owns this class 
                  name.
* bIsANSI       : True of lpClassName is ANSI, FALSE if it is Unicode.
*
* Return: If it succeed it returns lpClassName or lpClassName.
*         if it failed it returns NULL.
*
* History:
* 08-01-00 MHamid      Wrote.
\***************************************************************************/
LPWSTR ClassNameToVersion (LPCWSTR lpClassName, LPWSTR pClassVerName, LPWSTR *lpDllName, BOOL bIsANSI)
{
    int cbSrc;
    int cbDst;
    UNICODE_STRING UnicodeClassName;
    ACTIVATION_CONTEXT_SECTION_KEYED_DATA acskd;
    ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION UNALIGNED * pRedirEntry;
    LPWSTR lpClassNameRet; 
    LPWSTR pwstr;
    ULONG strLength;
    LPWSTR Buffer;
    NTSTATUS Status;
    
    /*
     * Allocate local buffer.
     */
    Buffer = UserLocalAlloc(0, MAX_ATOM_LEN * sizeof(WCHAR));
    if (Buffer == NULL) {
        return NULL;
    }

    /*
     * Capture lpClassName into a local buffer.
     */
    if (IS_PTR(lpClassName)) {
        /*
         * lpClassName is string.
         */
        if (bIsANSI) {
            /*
             * it is ANSI then convert it to unicode.
             */
            cbSrc = strlen((LPSTR)lpClassName) + 1;
            RtlMultiByteToUnicodeN(Buffer,
                    MAX_ATOM_LEN * sizeof(WCHAR), &cbDst,
                    (LPSTR)lpClassName, cbSrc);
        } else {
            /*
             * It is already unicode, then just copy it.
             */
            cbSrc = min (wcslen(lpClassName) + 1, MAX_ATOM_LEN);
            cbSrc *= sizeof(WCHAR);
            RtlCopyMemory(Buffer, lpClassName, cbSrc);
        }
        /*
         * Build the UNICODE_STRING
         */
        RtlInitUnicodeString(&UnicodeClassName, Buffer);
    } else {
        /*
         * lpClassName is an atom, get its name and build the UNICODE_STRING
         */
        UnicodeClassName.MaximumLength = (USHORT)(MAX_ATOM_LEN * sizeof(WCHAR));
        UnicodeClassName.Buffer = Buffer;
        UnicodeClassName.Length = (USHORT)NtUserGetAtomName((ATOM)lpClassName, &UnicodeClassName) * sizeof(WCHAR);

        if (!UnicodeClassName.Length) {
            lpClassNameRet = NULL;
            goto Free_Buffer;
        }
    }

    /*
     * Call Fusion to map the class name.
     */
    RtlZeroMemory(&acskd, sizeof(acskd));
    acskd.Size = sizeof(acskd);

    Status = RtlFindActivationContextSectionString(
        0,
        NULL,
        ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION,
        &UnicodeClassName,
        &acskd);
    /*
     * If there is no Activation Section we will use the plain class name.
     */
    if ((Status == STATUS_SXS_SECTION_NOT_FOUND) ||
        (Status == STATUS_SXS_KEY_NOT_FOUND)) {
        lpClassNameRet = (LPWSTR)lpClassName;
        goto Free_Buffer;
    }

    /*
     * Case of failure return NULL.
     */
    if (!NT_SUCCESS(Status) || 
        acskd.DataFormatVersion != ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION_FORMAT_WHISTLER) {

        lpClassNameRet = NULL;
        goto Free_Buffer;
    }

    pRedirEntry = (PACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION) acskd.Data;

    UserAssert(pRedirEntry);

    pwstr = (LPWSTR)(((ULONG_PTR) pRedirEntry) + pRedirEntry->VersionSpecificClassNameOffset);
    strLength = pRedirEntry->VersionSpecificClassNameLength + sizeof(WCHAR);
    if (lpDllName) {
        *lpDllName = (LPWSTR)(((ULONG_PTR) acskd.SectionBase) + pRedirEntry->DllNameOffset);
    }

    UserAssert(pwstr);
    UserAssert(strLength <= MAX_ATOM_LEN * sizeof(WCHAR));
    /*
     * if the call is ANSI then convert the class name+version to ANSI string.
     */
    if (bIsANSI) {
        RtlUnicodeToMultiByteN((LPSTR)pClassVerName,
                MAX_ATOM_LEN, &cbDst,
                pwstr, strLength);
    } else {
        /*
         * if it is unicode then just copy the class name+version to the caller's buffer.
         */
        RtlCopyMemory(pClassVerName, pwstr, strLength);
    }
    /*
     * And return it.
     */
    lpClassNameRet = pClassVerName;

Free_Buffer: 
    /*
     * Don't forget to free the local memory.
     */
    UserLocalFree(Buffer);
    return lpClassNameRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\client.c ===
/**************************************************************************\
* Module Name: client.c
*
* Client/Server call related routines.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 04-Dec-1990 SMeans    Created.
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "kbd.h"
#include "ntsend.h"

/*
 *  NOTE --  this table must match the FNID list in user.h.  It provides a WOWCLASS for each FNID.
 */

int aiClassWow[] = {
    WOWCLASS_SCROLLBAR,
    WOWCLASS_ICONTITLE,
    WOWCLASS_MENU,
    WOWCLASS_DESKTOP,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_SWITCHWND,
    WOWCLASS_BUTTON,
    WOWCLASS_COMBOBOX,
    WOWCLASS_COMBOLBOX,
    WOWCLASS_DIALOG,
    WOWCLASS_EDIT,
    WOWCLASS_LISTBOX,
    WOWCLASS_MDICLIENT,
    WOWCLASS_STATIC,
    WOWCLASS_WIN16,    // 2A9
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,     // 2B1
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16,
    WOWCLASS_WIN16
    };

HBITMAP WOWLoadBitmapA(HINSTANCE hmod, LPCSTR lpName, LPBYTE pResData, DWORD cbResData);
HMENU WowServerLoadCreateMenu(HANDLE hMod, LPTSTR lpName, CONST LPMENUTEMPLATE pmt,
    DWORD cb, BOOL fCallClient);
DWORD GetFullUserHandle(WORD wHandle);

UINT GetClipboardCodePage(LCID, LCTYPE);

extern HANDLE WOWFindResourceExWCover(HANDLE hmod, LPCWSTR rt, LPCWSTR lpUniName, WORD LangId);

extern BOOL APIENTRY EnableEUDC();


CONST WCHAR szKLKey[]  = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Keyboard Layouts\\";
CONST WCHAR szKLFile[] = L"Layout File";
CONST WCHAR szKLAttributes[] = L"Attributes";
CONST WCHAR szKLId[]   = L"Layout ID";
#define NSZKLKEY   (sizeof szKLKey + 16)


CONST LPWSTR pwszKLLibSafety     = L"kbdus.dll";
CONST UINT   wKbdLocaleSafety    = 0x04090409;
CONST LPWSTR pwszKLLibSafetyJPN  = L"kbdjpn.dll";
CONST UINT   wKbdLocaleSafetyJPN = 0x04110411;
CONST LPWSTR pwszKLLibSafetyKOR  = L"kbdkor.dll";
CONST UINT   wKbdLocaleSafetyKOR = 0x04120412;

#define CCH_KL_LIBNAME 256
#define CCH_KL_ID 16

UNICODE_STRING strRootDirectory;

VOID CheckValidLayoutName( LPWSTR lpszName );

BOOL WOWModuleUnload(HANDLE hModule) {
    return (BOOL)NtUserCallOneParam((ULONG_PTR)hModule,
                                    SFI__WOWMODULEUNLOAD);
}

BOOL WOWCleanup(HANDLE hInstance, DWORD hTaskWow) {
    return (BOOL)NtUserCallTwoParam((ULONG_PTR)hInstance,
                                    (ULONG_PTR)hTaskWow,
                                    SFI__WOWCLEANUP);
}
/***************************************************************************\
* BringWindowToTop (API)
*
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, BringWindowToTop, HWND, hwnd)
BOOL BringWindowToTop(
    HWND hwnd)
{
    return NtUserSetWindowPos(hwnd,
                              HWND_TOP,
                              0,
                              0,
                              0,
                              0,
                              SWP_NOSIZE | SWP_NOMOVE);
}


FUNCLOG2(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, ChildWindowFromPoint, HWND, hwndParent, POINT, point)
HWND ChildWindowFromPoint(
    HWND  hwndParent,
    POINT point)
{
    /*
     * Cool Hack Alert... Corel Ventura 5.0
     * Dies after it calls ChildWindowFromPoint, and
     * the combobox doesn't have its edit window at 1,1...
     */
    if ((point.x == 1) && (point.y == 1)) {
        PCBOX pcCombo;
        PWND pwnd;

        pwnd = ValidateHwnd(hwndParent);
        if (pwnd == NULL)
            return NULL;

        if (!TestWF(pwnd, WFWIN40COMPAT)   &&
            GETFNID(pwnd) == FNID_COMBOBOX &&
            TestWindowProcess(pwnd) &&
            ((pcCombo = ((PCOMBOWND)pwnd)->pcbox) != NULL) &&
            !(pcCombo->fNoEdit)) {

            RIPMSG0(RIP_WARNING, "ChildWindowFromPoint: Combobox @1,1. Returning spwndEdit");
            return HWq(pcCombo->spwndEdit);
        }

    }

    return NtUserChildWindowFromPointEx(hwndParent, point, 0);
}



FUNCLOG1(LOG_GENERAL, HICON, DUMMYCALLINGTYPE, CopyIcon, HICON, hicon)
HICON CopyIcon(
    HICON hicon)
{
    HICON    hIconT = NULL;
    ICONINFO ii;

    if (GetIconInfo(hicon, &ii)) {
        hIconT = CreateIconIndirect(&ii);

        DeleteObject(ii.hbmMask);

        if (ii.hbmColor != NULL)
            DeleteObject(ii.hbmColor);
    }

    return hIconT;
}

/***************************************************************************\
* AdjustWindowRect (API)
*
* History:
* 01-Jul-1991 MikeKe    Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, AdjustWindowRect, LPRECT, lprc, DWORD, style, BOOL, fMenu)
BOOL WINAPI AdjustWindowRect(
    LPRECT lprc,
    DWORD  style,
    BOOL   fMenu)
{
    ConnectIfNecessary(0);

    return _AdjustWindowRectEx(lprc, style, fMenu, 0L);
}

/***************************************************************************\
* TranslateAcceleratorA/W
*
* Put here so we can check for NULL on client side, and before validation
* for both DOS and NT cases.
*
* 05-29-91 ScottLu Created.
* 01-05-93 IanJa   Unicode/ANSI.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, int, WINAPI, TranslateAcceleratorW, HWND, hwnd, HACCEL, hAccel, LPMSG, lpMsg)
int WINAPI TranslateAcceleratorW(
    HWND hwnd,
    HACCEL hAccel,
    LPMSG lpMsg)
{
    /*
     * NULL pwnd is a valid case - since this is called from the center
     * of main loops, pwnd == NULL happens all the time, and we shouldn't
     * generate a warning because of it.
     */
    if (hwnd == NULL)
        return FALSE;

    /*
     * We only need to pass key-down messages to the server,
     * everything else ends up returning 0/FALSE from this function.
     */
    switch (lpMsg->message) {

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_CHAR:
    case WM_SYSCHAR:
        return NtUserTranslateAccelerator(hwnd, hAccel, lpMsg);

    default:
        return 0;
    }
}


FUNCLOG3(LOG_GENERAL, int, WINAPI, TranslateAcceleratorA, HWND, hwnd, HACCEL, hAccel, LPMSG, lpMsg)
int WINAPI TranslateAcceleratorA(
    HWND   hwnd,
    HACCEL hAccel,
    LPMSG  lpMsg)
{
    WPARAM wParamT;
    int iT;

    /*
     * NULL pwnd is a valid case - since this is called from the center
     * of main loops, pwnd == NULL happens all the time, and we shouldn't
     * generate a warning because of it.
     */
    if (hwnd == NULL)
        return FALSE;

    /*
     * We only need to pass key-down messages to the server,
     * everything else ends up returning 0/FALSE from this function.
     */
    switch (lpMsg->message) {

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_CHAR:
    case WM_SYSCHAR:
        wParamT = lpMsg->wParam;
        RtlMBMessageWParamCharToWCS(lpMsg->message, &(lpMsg->wParam));
        iT = NtUserTranslateAccelerator(hwnd, hAccel, lpMsg);
        lpMsg->wParam = wParamT;
        return iT;

    default:
        return 0;
    }
}

/***************************************************************************\
* Clipboard functions
*
* 11-Oct-1991 mikeke Created.
\***************************************************************************/

typedef struct _HANDLENODE {
    struct _HANDLENODE *pnext;
    UINT   fmt;
    HANDLE handleServer;
    HANDLE handleClient;
    BOOL   fGlobalHandle;
} HANDLENODE;
typedef HANDLENODE *PHANDLENODE;

PHANDLENODE gphn = NULL;

/***************************************************************************\
* DeleteClientClipboardHandle
*
* 11-Oct-1991 MikeKe    Created.
\***************************************************************************/

BOOL DeleteClientClipboardHandle(
    PHANDLENODE phn)
{
    LPMETAFILEPICT lpMFP;

    UserAssert(phn->handleClient != (HANDLE)0);

    switch (phn->fmt) {
    case CF_BITMAP:
    case CF_DSPBITMAP:
    case CF_PALETTE:
        // Does nothing (should remove).
        //
        //GdiDeleteLocalObject((ULONG)hobjDelete);
        break;

    case CF_METAFILEPICT:
    case CF_DSPMETAFILEPICT:
        USERGLOBALLOCK(phn->handleClient, lpMFP);
        if (lpMFP) {
            DeleteMetaFile(lpMFP->hMF);
            USERGLOBALUNLOCK(phn->handleClient);
            UserGlobalFree(phn->handleClient);
        } else {
            RIPMSG1(RIP_ERROR,"DeleteClientClipboardHandle, can't lock client handle %#p\n",phn->handleClient);
            return FALSE;
        }
        break;

    case CF_ENHMETAFILE:
    case CF_DSPENHMETAFILE:
        DeleteEnhMetaFile((HENHMETAFILE)phn->handleClient);
        break;

    default:
    //case CF_TEXT:
    //case CF_OEMTEXT:
    //case CF_UNICODETEXT:
    //case CF_LOCALE:
    //case CF_DSPTEXT:
    //case CF_DIB:
    //case CF_DIBV5:
        if (phn->fGlobalHandle) {
            if (UserGlobalFree(phn->handleClient)) {
             RIPMSG1(RIP_WARNING, "CloseClipboard UserGlobalFree(%#p) Failed\n", phn->handleClient);
                return FALSE;
            }
        } else {
            UserAssert(GlobalFlags(phn->handleClient) == GMEM_INVALID_HANDLE);
        }
        break;
    }

    /*
     * Deleted successfully
     */
    return TRUE;

}

/***************************************************************************\
* ClientEmptyClipboard
*
* Empties the client side clipboard list.
*
* 01-15-93 ScottLu      Created.
\***************************************************************************/

void ClientEmptyClipboard(void)
{
    PHANDLENODE phnNext;
    PHANDLENODE phnT;

    RtlEnterCriticalSection(&gcsClipboard);

    phnT = gphn;
    while (phnT != NULL) {
        phnNext = phnT->pnext;

        if (phnT->handleClient != (HANDLE)0)
            DeleteClientClipboardHandle(phnT);

        LocalFree(phnT);

        phnT = phnNext;
    }
    gphn = NULL;

    /*
     * Tell wow to cleanup it's clipboard stuff
     */
    if (pfnWowEmptyClipBoard) {
        pfnWowEmptyClipBoard();
    }

    RtlLeaveCriticalSection(&gcsClipboard);
}


/***************************************************************************\
* GetClipboardData
*
* 11-Oct-1991 mikeke Created.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, HANDLE, WINAPI, GetClipboardData, UINT, uFmt)
HANDLE WINAPI GetClipboardData(
    UINT uFmt)
{
    HANDLE       handleClient;
    HANDLE       handleServer;
    PHANDLENODE  phn;
    PHANDLENODE  phnNew;
    GETCLIPBDATA gcd;

    /*
     * Get the Server's Data; return if there is no data.
     */
    if (!(handleServer = NtUserGetClipboardData(uFmt, &gcd)))
        return (HANDLE)NULL;

    /*
     * Handle any translation that must be done for text items.  The
     * format returned will only differ for text items.  Metafile and
     * Enhanced-Metafiles are handled through GDI for their converstions.
     * And Bitmap color space convertion also nessesary for CF_BITMAP,
     * CF_DIB and CF_DIBV5 with color space.
     */
    if (uFmt != gcd.uFmtRet) {

        LPBYTE       lpSrceData = NULL;
        LPBYTE       lpDestData = NULL;
        LPBYTE       lptData = NULL;
        LPDWORD      lpLocale;
        DWORD        uLocale;
        int          iSrce;
        int          iDest;
        UINT         uCPage;
        SETCLIPBDATA scd;
        UINT         cbNULL = 0;

        /*
         * Make sure handleServer is server-side memory handle
         */
        if ((gcd.uFmtRet == CF_TEXT)        || (gcd.uFmtRet == CF_OEMTEXT) ||
            (gcd.uFmtRet == CF_UNICODETEXT) ||
            (gcd.uFmtRet == CF_DIB)         || (gcd.uFmtRet == CF_DIBV5)) {

            lpSrceData = CreateLocalMemHandle(handleServer);

            /*
             * Allocate space for the converted TEXT data.
             */
            if (!(iSrce = (UINT)GlobalSize(lpSrceData)))
                goto AbortDummyHandle;

            /*
             * Only CF_xxxTEXT may have locale information.
             */
            if ((gcd.uFmtRet == CF_TEXT) || (gcd.uFmtRet == CF_OEMTEXT) ||
                (gcd.uFmtRet == CF_UNICODETEXT)) {

                /*
                 * Get the locale out of the parameter-struct.  We will
                 * use this to get the codepage for text-translation.
                 */
                if (lpLocale = (LPDWORD)CreateLocalMemHandle(gcd.hLocale)) {

                    uLocale = *lpLocale;
                    GlobalFree(lpLocale);
                } else {
                    uLocale = 0;
                }

                /*
                 * And also, pre-allocate translated buffer in same size as source.
                 */
                if ((lpDestData = GlobalAlloc(LPTR, iSrce)) == NULL) {
                    goto AbortDummyHandle;
                }
            }

            switch (uFmt) {
                case CF_TEXT:
                cbNULL = 1;
                if (gcd.uFmtRet == CF_OEMTEXT) {

                    /*
                     * CF_OEMTEXT --> CF_TEXT conversion
                     */
                    OemToAnsi((LPSTR)lpSrceData, (LPSTR)lpDestData);
                } else {

                    uCPage = GetClipboardCodePage(uLocale,
                                                  LOCALE_IDEFAULTANSICODEPAGE);

                    /*
                     * CF_UNICODETEXT --> CF_TEXT conversion
                     */
                    iDest = 0;
                    if ((iDest = WideCharToMultiByte(uCPage,
                                                     (DWORD)0,
                                                     (LPWSTR)lpSrceData,
                                                     (int)(iSrce / sizeof(WCHAR)),
                                                     (LPSTR)NULL,
                                                     (int)iDest,
                                                     (LPSTR)NULL,
                                                     (LPBOOL)NULL)) == 0) {
AbortGetClipData:
                        UserGlobalFree(lpDestData);
AbortDummyHandle:
                        UserGlobalFree(lpSrceData);
                        return NULL;
                    }

                    if (!(lptData = GlobalReAlloc( lpDestData, iDest, LPTR | LMEM_MOVEABLE)))
                        goto AbortGetClipData;

                    lpDestData = lptData;

                    if (WideCharToMultiByte(uCPage,
                                            (DWORD)0,
                                            (LPWSTR)lpSrceData,
                                            (int)(iSrce / sizeof(WCHAR)),
                                            (LPSTR)lpDestData,
                                            (int)iDest,
                                            (LPSTR)NULL,
                                            (LPBOOL)NULL) == 0)
                        goto AbortGetClipData;
                }
                break;

            case CF_OEMTEXT:
                cbNULL = 1;
                if (gcd.uFmtRet == CF_TEXT) {

                    /*
                     * CF_TEXT --> CF_OEMTEXT conversion
                     */
                    AnsiToOem((LPSTR)lpSrceData, (LPSTR)lpDestData);
                } else {

                    uCPage = GetClipboardCodePage(uLocale,
                                                  LOCALE_IDEFAULTCODEPAGE);

                    /*
                     * CF_UNICODETEXT --> CF_OEMTEXT conversion
                     */
                    iDest = 0;
                    if ((iDest = WideCharToMultiByte(uCPage,
                                                     (DWORD)0,
                                                     (LPWSTR)lpSrceData,
                                                     (int)(iSrce / sizeof(WCHAR)),
                                                     (LPSTR)NULL,
                                                     (int)iDest,
                                                     (LPSTR)NULL,
                                                     (LPBOOL)NULL)) == 0)
                        goto AbortGetClipData;

                    if (!(lptData = GlobalReAlloc( lpDestData, iDest, LPTR | LMEM_MOVEABLE)))
                        goto AbortGetClipData;

                    lpDestData = lptData;

                    if (WideCharToMultiByte(uCPage,
                                            (DWORD)0,
                                            (LPWSTR)lpSrceData,
                                            (int)(iSrce / sizeof(WCHAR)),
                                            (LPSTR)lpDestData,
                                            (int)iDest,
                                            (LPSTR)NULL,
                                            (LPBOOL)NULL) == 0)
                        goto AbortGetClipData;
                }
                break;

            case CF_UNICODETEXT:
                cbNULL = 2;
                if (gcd.uFmtRet == CF_TEXT) {

                    uCPage = GetClipboardCodePage(uLocale,
                                                  LOCALE_IDEFAULTANSICODEPAGE);

                    /*
                     * CF_TEXT --> CF_UNICODETEXT conversion
                     */
                    iDest = 0;
                    if ((iDest = MultiByteToWideChar(uCPage,
                                                     (DWORD)MB_PRECOMPOSED,
                                                     (LPSTR)lpSrceData,
                                                     (int)iSrce,
                                                     (LPWSTR)NULL,
                                                     (int)iDest)) == 0)
                        goto AbortGetClipData;

                    if (!(lptData = GlobalReAlloc(lpDestData,
                            iDest * sizeof(WCHAR), LPTR | LMEM_MOVEABLE)))
                        goto AbortGetClipData;

                    lpDestData = lptData;

                    if (MultiByteToWideChar(uCPage,
                                            (DWORD)MB_PRECOMPOSED,
                                            (LPSTR)lpSrceData,
                                            (int)iSrce,
                                            (LPWSTR)lpDestData,
                                            (int)iDest) == 0)
                        goto AbortGetClipData;

                } else {

                    uCPage = GetClipboardCodePage(uLocale,
                                                  LOCALE_IDEFAULTCODEPAGE);

                    /*
                     * CF_OEMTEXT --> CF_UNICDOETEXT conversion
                     */
                    iDest = 0;
                    if ((iDest = MultiByteToWideChar(uCPage,
                                                     (DWORD)MB_PRECOMPOSED,
                                                     (LPSTR)lpSrceData,
                                                     (int)iSrce,
                                                     (LPWSTR)NULL,
                                                     (int)iDest)) == 0)
                        goto AbortGetClipData;

                    if (!(lptData = GlobalReAlloc(lpDestData,
                            iDest * sizeof(WCHAR), LPTR | LMEM_MOVEABLE)))
                        goto AbortGetClipData;

                    lpDestData = lptData;

                    if (MultiByteToWideChar(uCPage,
                                            (DWORD)MB_PRECOMPOSED,
                                            (LPSTR)lpSrceData,
                                            (int)iSrce,
                                            (LPWSTR)lpDestData,
                                            (int)iDest) == 0)
                        goto AbortGetClipData;
                }
                break;

            case CF_BITMAP:
                if (gcd.uFmtRet == CF_DIBV5) {

                    /*
                     * CF_DIBV5 --> CF_BITMAP (sRGB)
                     *
                     * The GDI bitmap handle will be returned in handleServer.
                     */
                    if ((handleServer = GdiConvertBitmapV5(lpSrceData,iSrce,
                                                           gcd.hPalette,CF_BITMAP)) == NULL) {

                        /*
                         * GDI failed to convert.
                         */
                        RIPMSG0(RIP_ERROR, "GetClipboardData: Failed CF_DIBV5 -> CF_BITMAP\n");
                        goto AbortDummyHandle;
                    }
                } else {

                    RIPMSG0(RIP_ERROR, "GetClipboardData: bad conversion request\n");
                    goto AbortDummyHandle;
                }
                break;

            case CF_DIB:
                if (gcd.uFmtRet == CF_DIBV5) {

                    /*
                     * CF_DIBV5 --> CF_DIB (sRGB)
                     *
                     * The local memory handle will be returned in lpDestData.
                     */
                    if ((lpDestData = (LPBYTE) GdiConvertBitmapV5(lpSrceData,iSrce,
                                                                  gcd.hPalette,CF_DIB)) == NULL) {

                        /*
                         * GDI failed to convert.
                         */
                        RIPMSG0(RIP_ERROR, "GetClipboardData: Failed CF_DIBV5 -> CF_DIB\n");
                        goto AbortDummyHandle;
                    }
                } else {

                    RIPMSG0(RIP_ERROR, "GetClipboardData: bad conversion request\n");
                    goto AbortDummyHandle;
                }
                break;
            }
        }

        if (lpDestData) {
            /*
             * Replace the dummy user-mode memory handle with the actual handle.
             */
            handleServer = ConvertMemHandle(lpDestData, cbNULL);
            if (handleServer == NULL)
                goto AbortGetClipData;
        }

        /*
         * Update the server.  If that is successfull update the client
         */
        RtlEnterCriticalSection(&gcsClipboard);
        scd.fGlobalHandle    = gcd.fGlobalHandle;
        scd.fIncSerialNumber = FALSE;
        if (!NtUserSetClipboardData(uFmt, handleServer, &scd)) {
            handleServer = NULL;
        }
        RtlLeaveCriticalSection(&gcsClipboard);

        if (lpDestData)
            UserGlobalFree(lpDestData);
        if (lpSrceData)
            UserGlobalFree(lpSrceData);

        if (handleServer == NULL)
            return NULL;
    }

    /*
     * See if we already have a client side handle; validate the format
     * as well because some server objects, metafile for example, are dual mode
     * and yield two kinds of client objects enhanced and regular metafiles
     */
    handleClient = NULL;
    RtlEnterCriticalSection(&gcsClipboard);

    phn = gphn;
    while (phn) {
        if ((phn->handleServer == handleServer) && (phn->fmt == uFmt)) {
            handleClient = phn->handleClient;
            goto Exit;
        }
        phn = phn->pnext;
    }

    /*
     * We don't have a handle cached so we'll create one
     */
    phnNew = (PHANDLENODE)LocalAlloc(LPTR, sizeof(HANDLENODE));
    if (phnNew == NULL)
        goto Exit;

    phnNew->handleServer  = handleServer;
    phnNew->fmt           = gcd.uFmtRet;
    phnNew->fGlobalHandle = gcd.fGlobalHandle;

    switch (uFmt) {

        /*
         * Misc GDI Handles
         */
        case CF_BITMAP:
        case CF_DSPBITMAP:
        case CF_PALETTE:
            phnNew->handleClient = handleServer;
            break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
            phnNew->handleClient = GdiCreateLocalMetaFilePict(handleServer);
            break;

        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
            phnNew->handleClient = GdiCreateLocalEnhMetaFile(handleServer);
            break;

        /*
         * GlobalHandle Cases
         */
        case CF_TEXT:
        case CF_OEMTEXT:
        case CF_UNICODETEXT:
        case CF_LOCALE:
        case CF_DSPTEXT:
        case CF_DIB:
        case CF_DIBV5:
            phnNew->handleClient = CreateLocalMemHandle(handleServer);
            phnNew->fGlobalHandle = TRUE;
            break;

        default:
            /*
             * Private Data Format; If this is global data, create a copy of that
             * data here on the client. If it isn't global data, it is just a dword
             * in which case we just return a dword. If it is global data and
             * the server fails to give us that memory, return NULL. If it isn't
             * global data, handleClient is just a dword.
             */
            if (phnNew->fGlobalHandle) {
                phnNew->handleClient = CreateLocalMemHandle(handleServer);
            } else {
                phnNew->handleClient = handleServer;
            }
            break;
    }

    if (phnNew->handleClient == NULL) {
        /*
         * Something bad happened, gdi didn't give us back a
         * handle. Since gdi has logged the error, we'll just
         * clean up and return an error.
         */
        RIPMSG1(RIP_WARNING, "GetClipboardData unable to convert server handle %#p to client handle\n", handleServer);

        LocalFree(phnNew);
        goto Exit;
    }

#if DBG
    /*
     * If handleClient came from a GlobalAlloc, then fGlobalHandle must be TRUE.
     * Some formats are acutally global handles but require special cleanup.
     */
    switch (phnNew->fmt) {
        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
            break;

        default:
            UserAssert(phnNew->fGlobalHandle
                       ^ (GlobalFlags(phnNew->handleClient) == GMEM_INVALID_HANDLE));
            break;
    }
#endif

    /*
     * Cache the new handle by linking it into our list
     */
    phnNew->pnext = gphn;
    gphn = phnNew;
    handleClient = phnNew->handleClient;

Exit:
    RtlLeaveCriticalSection(&gcsClipboard);
    return handleClient;
}

/***************************************************************************\
* GetClipboardCodePage (internal)
*
*   This routine returns the code-page associated with the given locale.
*
* 24-Aug-1995 ChrisWil  Created.
\***************************************************************************/

#define GETCCP_SIZE 8

UINT GetClipboardCodePage(
    LCID   uLocale,
    LCTYPE uLocaleType)
{
    WCHAR wszCodePage[GETCCP_SIZE];
    DWORD uCPage;

    if (GetLocaleInfoW(uLocale, uLocaleType, wszCodePage, GETCCP_SIZE)) {

        uCPage = (UINT)wcstol(wszCodePage, NULL, 10);

    } else {

        switch(uLocaleType) {

        case LOCALE_IDEFAULTCODEPAGE:
            uCPage = CP_OEMCP;
            break;

        case LOCALE_IDEFAULTANSICODEPAGE:
            uCPage = CP_ACP;
            break;

        default:
            uCPage = CP_MACCP;
            break;
        }
    }

    return uCPage;
}

/***************************************************************************\
* SetClipboardData
*
* Stub routine needs to exist on the client side so any global data gets
* allocated DDESHARE.
*
* 05-20-91 ScottLu Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HANDLE, WINAPI, SetClipboardData, UINT, wFmt, HANDLE, hMem)
HANDLE WINAPI SetClipboardData(
    UINT   wFmt,
    HANDLE hMem)
{
    PHANDLENODE  phnNew;
    HANDLE       hServer = NULL;
    SETCLIPBDATA scd;
    BOOL         fGlobalHandle = FALSE;

    if (hMem != NULL) {

        switch(wFmt) {

            case CF_BITMAP:
            case CF_DSPBITMAP:
            case CF_PALETTE:
                hServer = hMem;
                break;

            case CF_METAFILEPICT:
            case CF_DSPMETAFILEPICT:
                hServer = GdiConvertMetaFilePict(hMem);
                break;

            case CF_ENHMETAFILE:
            case CF_DSPENHMETAFILE:
                hServer = GdiConvertEnhMetaFile(hMem);
                break;

            /*
             * Must have a valid hMem (GlobalHandle)
             */
            case CF_TEXT:
            case CF_OEMTEXT:
            case CF_LOCALE:
            case CF_DSPTEXT:
                hServer = ConvertMemHandle(hMem, 1);
                fGlobalHandle = TRUE;
                break;

            case CF_UNICODETEXT:
                hServer = ConvertMemHandle(hMem, 2);
                fGlobalHandle = TRUE;
                break;

            case CF_DIB:
            case CF_DIBV5:
                hServer = ConvertMemHandle(hMem, 0);
                fGlobalHandle = TRUE;
                break;

            /*
             * hMem should have been NULL but Write sends non-null when told
             * to render
             */
            case CF_OWNERDISPLAY:
                // Fall Through;

            /*
             * May have an hMem (GlobalHandle) or may be private handle\info
             */
            default:
                if (GlobalFlags(hMem) == GMEM_INVALID_HANDLE) {
                    hServer = hMem;    // No server equivalent; private data
                    goto SCD_AFTERNULLCHECK;
                } else {
                    fGlobalHandle = TRUE;
                    hServer = ConvertMemHandle(hMem, 0);
                }
                break;
        }

        if (hServer == NULL) {
            /*
             * Something bad happened, gdi didn't give us back a
             * handle. Since gdi has logged the error, we'll just
             * clean up and return an error.
             */
            RIPMSG0(RIP_WARNING, "SetClipboardData: bad handle\n");
            return NULL;
        }
    }

SCD_AFTERNULLCHECK:

    RtlEnterCriticalSection(&gcsClipboard);

    /*
     * Update the server if that is successfull update the client
     */
    scd.fGlobalHandle    = fGlobalHandle;
    scd.fIncSerialNumber = TRUE;

    if (!NtUserSetClipboardData(wFmt, hServer, &scd)) {
        RtlLeaveCriticalSection(&gcsClipboard);
        return NULL;
    }

    /*
     * See if we already have a client handle of this type.  If so
     * delete it.
     */
    phnNew = gphn;
    while (phnNew) {
        if (phnNew->fmt == wFmt) {
            if (phnNew->handleClient != NULL) {
                DeleteClientClipboardHandle(phnNew);
                /*
                 * Notify WOW to clear its associated cached h16 for this format
                 * so that OLE32 thunked calls, which bypass the WOW cache will work.
                 */
                if (pfnWowCBStoreHandle) {
                    pfnWowCBStoreHandle((WORD)wFmt, 0);
                }
            }
            break;
        }

        phnNew = phnNew->pnext;
    }

    /*
     * If we aren't re-using an old client cache entry alloc a new one
     */
    if (!phnNew) {
        phnNew = (PHANDLENODE)LocalAlloc(LPTR, sizeof(HANDLENODE));

        if (phnNew == NULL) {
            RIPMSG0(RIP_WARNING, "SetClipboardData: not enough memory\n");

            RtlLeaveCriticalSection(&gcsClipboard);
            return NULL;
        }

        /*
         * Link in the newly allocated cache entry
         */
        phnNew->pnext = gphn;
        gphn = phnNew;
    }

    phnNew->handleServer  = hServer;
    phnNew->handleClient  = hMem;
    phnNew->fmt           = wFmt;
    phnNew->fGlobalHandle = fGlobalHandle;

    RtlLeaveCriticalSection(&gcsClipboard);

    return hMem;
}

/**************************************************************************\
* SetDeskWallpaper
*
* 22-Jul-1991 mikeke Created
* 01-Mar-1992 GregoryW Modified to call SystemParametersInfo.
\**************************************************************************/

BOOL SetDeskWallpaper(
    IN LPCSTR pString OPTIONAL)
{
    return SystemParametersInfoA(SPI_SETDESKWALLPAPER, 0, (PVOID)pString, TRUE);
}

/***************************************************************************\
* ReleaseDC (API)
*
* A complete Thank cannot be generated for ReleaseDC because its first
* parameter (hwnd) unnecessary and should be discarded before calling the
* server-side routine _ReleaseDC.
*
* History:
* 03-28-91 SMeans Created.
* 06-17-91 ChuckWh Added support for local DCs.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, ReleaseDC, HWND, hwnd, HDC, hdc)
BOOL WINAPI ReleaseDC(
    HWND hwnd,
    HDC hdc)
{

    /*
     * NOTE: This is a smart stub that calls _ReleaseDC so there is
     * no need for a separate ReleaseDC layer or client-server stub.
     * _ReleaseDC has simpler layer and client-server stubs since the
     * hwnd can be ignored.
     */

    UNREFERENCED_PARAMETER(hwnd);

    /*
     * Translate the handle.
     */
    if (hdc == NULL)
        return FALSE;

    /*
     *  call GDI to release user mode DC resources
     */

    GdiReleaseDC(hdc);

    return (BOOL)NtUserCallOneParam((ULONG_PTR)hdc, SFI__RELEASEDC);
}

int WINAPI
ToAscii(
    UINT wVirtKey,
    UINT wScanCode,
    CONST BYTE *lpKeyState,
    LPWORD lpChar,
    UINT wFlags
    )
{
    WCHAR UnicodeChar[2];
    int cch, retval;

    retval = ToUnicode(wVirtKey, wScanCode, lpKeyState, UnicodeChar,2, wFlags);
    cch = (retval < 0) ? -retval : retval;
    if (cch != 0) {
        if (!NT_SUCCESS(RtlUnicodeToMultiByteN(
                (LPSTR)lpChar,
                (ULONG) sizeof(*lpChar),
                (PULONG)&cch,
                UnicodeChar,
                cch * sizeof(WCHAR)))) {
            return 0;
        }
    }
    return (retval < 0) ? -cch : cch;
}

static UINT uCachedCP = 0;
static HKL  hCachedHKL = 0;

int WINAPI
ToAsciiEx(
    UINT wVirtKey,
    UINT wScanCode,
    CONST BYTE *lpKeyState,
    LPWORD lpChar,
    UINT wFlags,
    HKL hkl
    )
{
    WCHAR UnicodeChar[2];
    int cch, retval;
    BOOL fUsedDefaultChar;

    retval = ToUnicodeEx(wVirtKey, wScanCode, lpKeyState, UnicodeChar,2, wFlags, hkl);
    cch = (retval < 0) ? -retval : retval;
    if (cch != 0) {
        if (hkl != hCachedHKL) {
            DWORD dwCodePage;
            if (!GetLocaleInfoW(
                     HandleToUlong(hkl) & 0xffff,
                     LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                     (LPWSTR)&dwCodePage,
                     sizeof(dwCodePage) / sizeof(WCHAR)
                     )) {
                return 0;
            }
            uCachedCP = dwCodePage;
            hCachedHKL = hkl;
        }
        if (!WideCharToMultiByte(
                 uCachedCP,
                 0,
                 UnicodeChar,
                 cch,
                 (LPSTR)lpChar,
                 sizeof(*lpChar),
                 NULL,
                 &fUsedDefaultChar)) {
            return 0;
        }
    }
    return (retval < 0) ? -cch : cch;
}

/**************************************************************************\
* ScrollDC *
* DrawIcon *
* ExcludeUpdateRgn *
* ValidateRgn *
* DrawFocusRect *
* FrameRect *
* ReleaseDC *
* GetUpdateRgn *
* *
* These USER entry points all need handles translated before the call is *
* passed to the server side handler. *
* *
* History: *
* Mon 17-Jun-1991 22:51:45 -by- Charles Whitmer [chuckwh] *
* Wrote the stubs. The final form of these routines depends strongly on *
* what direction the user stubs take in general. *
\**************************************************************************/


BOOL WINAPI ScrollDC(
    HDC hDC,
    int dx,
    int dy,
    CONST RECT *lprcScroll,
    CONST RECT *lprcClip,
    HRGN hrgnUpdate,
    LPRECT lprcUpdate)
{
    if (hDC == NULL)
        return FALSE;

    /*
     * If we're not scrolling, just empty the update region and return.
     */
    if (dx == 0 && dy == 0) {
        if (hrgnUpdate)
            SetRectRgn(hrgnUpdate, 0, 0, 0, 0);
        if (lprcUpdate)
            SetRectEmpty(lprcUpdate);
        return TRUE;
    }

    return NtUserScrollDC(hDC, dx, dy, lprcScroll, lprcClip,
            hrgnUpdate, lprcUpdate);
}


FUNCLOG4(LOG_GENERAL, BOOL, WINAPI, DrawIcon, HDC, hdc, int, x, int, y, HICON, hicon)
BOOL WINAPI DrawIcon(HDC hdc,int x,int y,HICON hicon)
{
    return DrawIconEx(hdc, x, y, hicon, 0, 0, 0, 0, DI_NORMAL | DI_COMPAT | DI_DEFAULTSIZE );
}



FUNCLOG9(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawIconEx, HDC, hdc, int, x, int, y, HICON, hIcon, int, cx, int, cy, UINT, istepIfAniCur, HBRUSH, hbrFlickerFreeDraw, UINT, diFlags)
BOOL DrawIconEx( HDC hdc, int x, int y, HICON hIcon,
                 int cx, int cy, UINT istepIfAniCur,
                 HBRUSH hbrFlickerFreeDraw, UINT diFlags)
{
    DRAWICONEXDATA did;
    HBITMAP hbmT;
    BOOL retval = FALSE;
    HDC hdcr;
    BOOL fAlpha = FALSE;
    LONG rop = (diFlags & DI_NOMIRROR) ? NOMIRRORBITMAP : 0;

    if (diFlags & ~DI_VALID) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return(FALSE);
    }

    if (diFlags & DI_DEFAULTSIZE) {
        cx = 0;
        cy = 0;
    }

    if (!IsMetaFile(hdc)) {
        hdcr = GdiConvertAndCheckDC(hdc);
        if (hdcr == (HDC)0)
            return FALSE;

        return NtUserDrawIconEx(hdcr, x, y, hIcon, cx, cy, istepIfAniCur,
                                hbrFlickerFreeDraw, diFlags, FALSE, &did);
    }

    if (!NtUserDrawIconEx(NULL, 0, 0, hIcon, cx, cy, 0, NULL, 0, TRUE, &did)) {
        return FALSE;
    }

    if ((diFlags & ~DI_NOMIRROR) == 0)
        return TRUE;

    RtlEnterCriticalSection(&gcsHdc);

    /*
     * We really want to draw an alpha icon if we can.  But we need to
     * respect the user's request to draw only the image or only the
     * mask.  We decide if we are, or are not, going to draw the icon
     * with alpha information here.
     */
    if (did.hbmUserAlpha != NULL && ((diFlags & DI_NORMAL) == DI_NORMAL)) {
        fAlpha = TRUE;
    }

    RIPMSG5(RIP_WARNING, "Drawing to metafile! fAlpha=%d, did.cx=%d, did.cy=%d, cx=%d, cy=%d", fAlpha, did.cx, did.cy, cx, cy);
    /*
     * Setup the attributes
     */
    if (!cx)
        cx = did.cx;
    if (!cy)
        cy = did.cy / 2;

    SetTextColor(hdc, 0x00000000L);
    SetBkColor(hdc, 0x00FFFFFFL);

    if (fAlpha) {
        BLENDFUNCTION bf;

        hbmT = SelectObject(ghdcBits2, did.hbmUserAlpha);

        bf.BlendOp = AC_SRC_OVER;
        bf.BlendFlags = AC_MIRRORBITMAP;
        bf.SourceConstantAlpha = 0xFF;
        bf.AlphaFormat = AC_SRC_ALPHA;

        AlphaBlend(hdc,
                   x,
                   y,
                   cx,
                   cy,
                   ghdcBits2,
                   0,
                   0,
                   did.cx,
                   did.cy / 2,
                   bf);
        SelectObject(ghdcBits2,hbmT);
        retval = TRUE;
    } else {
        if (diFlags & DI_MASK) {

            if (did.hbmMask) {

                hbmT = SelectObject(ghdcBits2, did.hbmMask);
                StretchBlt(hdc,
                           x,
                           y,
                           cx,
                           cy,
                           ghdcBits2,
                           0,
                           0,
                           did.cx,
                           did.cy / 2,
                           rop | SRCAND);
                SelectObject(ghdcBits2,hbmT);
                retval = TRUE;
            }
        }

        if (diFlags & DI_IMAGE) {

            if (did.hbmColor != NULL) {
                hbmT = SelectObject(ghdcBits2, did.hbmColor);
                StretchBlt(hdc,
                           x,
                           y,
                           cx,
                           cy,
                           ghdcBits2,
                           0,
                           0,
                           did.cx,
                           did.cy / 2,
                           rop | SRCINVERT);
                SelectObject(ghdcBits2, hbmT);
                retval = TRUE;
            } else {
                if (did.hbmMask) {
                    hbmT = SelectObject(ghdcBits2, did.hbmMask);
                    StretchBlt(hdc,
                               x,
                               y,
                               cx,
                               cy,
                               ghdcBits2,
                               0,
                               did.cy / 2,
                               did.cx,
                               did.cy / 2,
                               rop | SRCINVERT);
                    SelectObject(ghdcBits2, hbmT);
                    retval = TRUE;
                }
            }
        }
    }

    RtlLeaveCriticalSection(&gcsHdc);

    return retval;
}




FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, ValidateRgn, HWND, hWnd, HRGN, hRgn)
BOOL WINAPI ValidateRgn(HWND hWnd,HRGN hRgn)
{
    return (BOOL)NtUserCallHwndParamLock(hWnd, (ULONG_PTR)hRgn,
                                         SFI_XXXVALIDATERGN);
}


FUNCLOG3(LOG_GENERAL, int, WINAPI, GetUpdateRgn, HWND, hWnd, HRGN, hRgn, BOOL, bErase)
int WINAPI GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
{
    PWND pwnd;

    if (hRgn == NULL) {
        RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING, "Invalid region %#p", hRgn);
        return ERROR;
    }

    if ((pwnd = ValidateHwnd(hWnd)) == NULL) {
        return ERROR;
    }

    /*
     * Check for the simple case where nothing needs to be done.
     */
    if (pwnd->hrgnUpdate == NULL &&
            !TestWF(pwnd, WFSENDERASEBKGND) &&
            !TestWF(pwnd, WFSENDNCPAINT) &&
            !TestWF(pwnd, WFUPDATEDIRTY) &&
            !TestWF(pwnd, WFPAINTNOTPROCESSED)) {
        SetRectRgn(hRgn, 0, 0, 0, 0);
        return NULLREGION;
    }

    return NtUserGetUpdateRgn(hWnd, hRgn, bErase);
}



FUNCLOG3(LOG_GENERAL, int, WINAPI, GetUpdateRect, HWND, hWnd, LPRECT, lprc, BOOL, bErase)
int WINAPI GetUpdateRect(HWND hWnd, LPRECT lprc, BOOL bErase)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hWnd)) == NULL) {
        return FALSE;
    }

    /*
     * Check for the simple case where nothing needs to be done.
     */
    if (pwnd->hrgnUpdate == NULL &&
            !TestWF(pwnd, WFSENDERASEBKGND) &&
            !TestWF(pwnd, WFSENDNCPAINT) &&
            !TestWF(pwnd, WFUPDATEDIRTY) &&
            !TestWF(pwnd, WFPAINTNOTPROCESSED)) {
        if (lprc)
            SetRectEmpty(lprc);
        return FALSE;
    }

    return NtUserGetUpdateRect(hWnd, lprc, bErase);
}


/***************************************************************************\
* ScrollWindow (API)
*
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

#define SW_FLAG_RC  (SW_SCROLLWINDOW | SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN)
#define SW_FLAG_NRC (SW_SCROLLWINDOW | SW_INVALIDATE | SW_ERASE)

BOOL WINAPI
ScrollWindow(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip)
{
    return NtUserScrollWindowEx(
            hwnd,
            dx,
            dy,
            prcScroll,
            prcClip,
            NULL,
            NULL,
            !IS_PTR(prcScroll) ? SW_FLAG_RC : SW_FLAG_NRC) != ERROR;
}

/***************************************************************************\
*
*  SwitchToThisWindow()
*
\***************************************************************************/


FUNCLOGVOID2(LOG_GENERAL, WINAPI, SwitchToThisWindow, HWND, hwnd, BOOL, fAltTab)
void WINAPI SwitchToThisWindow(
    HWND hwnd,
    BOOL fAltTab)
{
    (VOID)NtUserCallHwndParamLock(hwnd, fAltTab, SFI_XXXSWITCHTOTHISWINDOW);
}


/***************************************************************************\
* WaitForInputIdle
*
* Waits for a given process to go idle.
*
* 09-18-91 ScottLu Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, WaitForInputIdle, HANDLE, hProcess, DWORD, dwMilliseconds)
DWORD WaitForInputIdle(
    HANDLE hProcess,
    DWORD dwMilliseconds)
{
    PROCESS_BASIC_INFORMATION processinfo;
    ULONG_PTR idProcess;
    NTSTATUS status;
    /*
     * First get the process id from the hProcess.
     */
    status = NtQueryInformationProcess(hProcess, ProcessBasicInformation,
            &processinfo, sizeof(processinfo), NULL);
    if (!NT_SUCCESS(status)) {
        if (status == STATUS_OBJECT_TYPE_MISMATCH) {
            if ((ULONG_PTR)hProcess & 0x2) {
            /*
             * WOW Process handles are really semaphore handles.
             * CreateProcess ORs in a 0x2 (the low 2 bits of handles
             * are not used) so we can identify it more clearly.
             */
                idProcess = ((ULONG_PTR)hProcess & ~0x03);
                return NtUserWaitForInputIdle(idProcess, dwMilliseconds, TRUE);
            }

            /*
             * VDM (DOS) Process handles are really semaphore handles.
             * CreateProcess ORs in a 0x1 (the low 2 bits of handles
             * are not used) so we can identify and return immidiately.
             */
            if ((ULONG_PTR)hProcess & 0x1) {
                return 0;
            }
        }

        RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING, "WaitForInputIdle invalid process", hProcess);
        return (DWORD)-1;
    }
    idProcess = processinfo.UniqueProcessId;
    return NtUserWaitForInputIdle(idProcess, dwMilliseconds, FALSE);
}

DWORD WINAPI MsgWaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *pHandles,
    BOOL fWaitAll,
    DWORD dwMilliseconds,
    DWORD dwWakeMask)
{
    return  MsgWaitForMultipleObjectsEx(nCount, pHandles,
                dwMilliseconds, dwWakeMask, fWaitAll?MWMO_WAITALL:0);
}


DWORD WINAPI MsgWaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *pHandles,
    DWORD dwMilliseconds,
    DWORD dwWakeMask,
    DWORD dwFlags)
#ifdef MESSAGE_PUMP_HOOK
{
    DWORD dwResult;

    BEGIN_MESSAGEPUMPHOOK()
        if (fInsideHook) {
            dwResult = gmph.pfnMsgWaitForMultipleObjectsEx(nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags);
        } else {
            dwResult = RealMsgWaitForMultipleObjectsEx(nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags);
        }
    END_MESSAGEPUMPHOOK()

    return dwResult;
}


DWORD WINAPI RealMsgWaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *pHandles,
    DWORD dwMilliseconds,
    DWORD dwWakeMask,
    DWORD dwFlags)
#endif
{
    HANDLE hEventInput;
    PHANDLE ph;
    DWORD dwIndex;
    BOOL  ReenterWowScheduler;
    PCLIENTINFO pci;
    HANDLE rgHandles[ 8 + 1 ];
    BOOL fWaitAll = ((dwFlags & MWMO_WAITALL) != 0);
    BOOL fAlertable = ((dwFlags & MWMO_ALERTABLE) != 0);
    CLIENTTHREADINFO *pcti;

    if (dwFlags & ~MWMO_VALID) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_ERROR, "MsgWaitForMultipleObjectsEx, invalid flags 0x%08lx\n", dwFlags);
        return (DWORD)-1;
    }

    pci = GetClientInfo();
    pcti = GETCLIENTTHREADINFO();
    if (pcti && (!fWaitAll || !nCount)) {
        if (GetInputBits(pcti, LOWORD(dwWakeMask), (dwFlags & MWMO_INPUTAVAILABLE))) {
            return nCount;
        }
    }

    /*
     * Note -- the wake mask is a WORD, and only 3 flags are defined, so
     * they can be combined for the call.
     */

    hEventInput = (HANDLE)NtUserCallOneParam(MAKELONG(dwWakeMask, dwFlags), SFI_XXXGETINPUTEVENT);

    if (hEventInput == NULL) {
        RIPMSG0(RIP_WARNING, "MsgWaitForMultipleObjectsEx, GetInputEvent failed\n");
        return (DWORD)-1;
    }

    /*
     * If needed, allocate a new array of handles that will include
     * the input event handle.
     */
    ph = rgHandles;
    if (pHandles) {

        if (nCount > 8) {
            ph = (PHANDLE)LocalAlloc(LPTR, sizeof(HANDLE) * (nCount + 1));
            if (ph == NULL) {
                NtUserCallNoParam(SFI_CLEARWAKEMASK);
                return (DWORD)-1;
            }
        }

        RtlCopyMemory((PVOID)ph, pHandles, sizeof(HANDLE) * nCount);

    } else {
        // if this isn't Zero, the function parameters are invalid
        nCount = 0;
    }

    ph[nCount] = hEventInput;


    /*
     *  WowApps must exit the Wow scheduler otherwise other tasks
     *  in this Wow scheduler can't run. The only exception is if
     *  the timeout is Zero.  We pass HEVENT_REMOVEME as the handle so we will go
     *  into the sleeptask AND return without going to sleep but letting
     *  other apps run.
     */
    if ((pci->dwTIFlags & TIF_16BIT) && dwMilliseconds) {
        ReenterWowScheduler = TRUE;
        NtUserWaitForMsgAndEvent(HEVENT_REMOVEME);
        /*
         * If our wait condition is satisfied, make sure we won't wait.
         * We must have a pcti now since we just went to the kernel
         */
        pcti = GETCLIENTTHREADINFO();
        if (GetInputBits(pcti, LOWORD(dwWakeMask), (dwFlags & MWMO_INPUTAVAILABLE))) {
            SetEvent(hEventInput);
        }
    } else {
        ReenterWowScheduler = FALSE;
    }

    dwIndex = WaitForMultipleObjectsEx(nCount + 1, ph, fWaitAll, dwMilliseconds, fAlertable);

    /*
     * Clear the wake mask since we're done waiting on these events.
     */
    NtUserCallNoParam(SFI_CLEARWAKEMASK);

    /*
     *  If needed reenter the wow scheduler
     */
    if (ReenterWowScheduler) {
        NtUserCallOneParam(DY_OLDYIELD, SFI_XXXDIRECTEDYIELD);
    }

    if (ph != rgHandles) {
        LocalFree(ph);
    }

    return dwIndex;
}

/***************************************************************************\
* GrayString
*
* GrayStingA used to convert the string and call GrayStringW but that
* did not work in a number of special cases such as the app passing in
* a pointer to a zero length string.  Eventually GrayStringA had almost as
* much code as GrayStringW so now they are one.
*
* History:
* 06-11-91 JimA     Created.
* 06-17-91 ChuckWh  Added GDI handle conversion.
* 02-12-92 mikeke   Made it completely client side
\***************************************************************************/

BOOL InnerGrayStringAorW(
    HDC            hdc,
    HBRUSH         hbr,
    GRAYSTRINGPROC lpfnPrint,
    LPARAM         lParam,
    int            cch,
    int            x,
    int            y,
    int            cx,
    int            cy,
    BOOL           bAnsi)
{
    HBITMAP hbm;
    HBITMAP hbmOld;
    BOOL    fResult;
    HFONT   hFontSave = NULL;
    BOOL    fReturn = FALSE;
    DWORD   dwOldLayout = GDI_ERROR;

    /*
     * Win 3.1 tries to calc the size even if we don't know if it is a string.
     */
    if (cch == 0) {

        try {

            cch = bAnsi ? strlen((LPSTR)lParam) : wcslen((LPWSTR)lParam);

        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            fReturn = TRUE;
        }

        if (fReturn)
            return FALSE;
    }

    if (cx == 0 || cy == 0) {

       SIZE size;

        /*
         * We use the caller supplied hdc (instead of hdcBits) since we may be
         * graying a font which is different than the system font and we want to
         * get the proper text extents.
         */
        try {
            if (bAnsi) {
                GetTextExtentPointA(hdc, (LPSTR)lParam, cch, &size);
            } else {
                GetTextExtentPointW(hdc, (LPWSTR)lParam, cch, &size);
            }

            cx = size.cx;
            cy = size.cy;

        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            fReturn = TRUE;
        }

        if (fReturn)
            return FALSE;
    }

    UserAssert (ghdcGray != NULL);

    RtlEnterCriticalSection(&gcsHdc);

    if (gcxGray < cx || gcyGray < cy) {

        if ((hbm = CreateBitmap(cx, cy, 1, 1, 0L)) != NULL) {

            hbmOld = SelectObject(ghdcGray, hbm);
            DeleteObject(hbmOld);

            gcxGray = cx;
            gcyGray = cy;

        } else {
            cx = gcxGray;
            cy = gcyGray;
        }
    }

    /*
     * If the caller hdc is mirrored then mirror ghdcGray.
     */
    if (MIRRORED_HDC(hdc)) {
        dwOldLayout = SetLayoutWidth(ghdcGray, cx, LAYOUT_RTL);
    }

    /*
     * Force the ghdcGray font to be the same as hDC; ghdcGray is always
     * the system font
     */
    hFontSave = SelectObject(hdc, ghFontSys);

    if (hFontSave != ghFontSys) {
        SelectObject(hdc, hFontSave);
        hFontSave = SelectObject(ghdcGray, hFontSave);
    }

    if (lpfnPrint != NULL) {
        PatBlt(ghdcGray, 0, 0, cx, cy, WHITENESS);
        fResult = (*lpfnPrint)(ghdcGray, lParam, cch);
    } else {

        if (bAnsi) {
            fResult = TextOutA(ghdcGray, 0, 0, (LPSTR)lParam, cch);
        } else {
            fResult = TextOutW(ghdcGray, 0, 0, (LPWSTR)lParam, cch);
        }
    }

    if (fResult)
        PatBlt(ghdcGray, 0, 0, cx, cy, DESTINATION | PATTERN);

    if (fResult || cch == -1) {

        HBRUSH hbrSave;
        DWORD  textColorSave;
        DWORD  bkColorSave;

        textColorSave = SetTextColor(hdc, 0x00000000L);
        bkColorSave = SetBkColor(hdc, 0x00FFFFFFL);

        hbrSave = SelectObject(hdc, hbr ? hbr : ghbrWindowText);

        BitBlt(hdc,
               x,
               y,
               cx,
               cy,
               ghdcGray,
               0,
               0,
               (((PATTERN ^ DESTINATION) & SOURCE) ^ PATTERN));

        SelectObject(hdc, hbrSave);

        /*
         * Restore saved colors
         */
        SetTextColor(hdc, textColorSave);
        SetBkColor(hdc, bkColorSave);
    }

    SelectObject(ghdcGray, hFontSave);

    /*
     * Restore ghdcGray layout state.
     */
    if (dwOldLayout != GDI_ERROR) {
        SetLayoutWidth(ghdcGray, cx, dwOldLayout);
    }

    RtlLeaveCriticalSection(&gcsHdc);

    return fResult;
}


FUNCLOG9(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GrayStringA, HDC, hdc, HBRUSH, hbr, GRAYSTRINGPROC, lpfnPrint, LPARAM, lParam, int, cch, int, x, int, y, int, cx, int, cy)
BOOL GrayStringA(
    HDC            hdc,
    HBRUSH         hbr,
    GRAYSTRINGPROC lpfnPrint,
    LPARAM         lParam,
    int            cch,
    int            x,
    int            y,
    int            cx,
    int            cy)
{
    return (InnerGrayStringAorW(hdc,
                                hbr,
                                lpfnPrint,
                                lParam,
                                cch,
                                x,
                                y,
                                cx,
                                cy,
                                TRUE));
}


FUNCLOG9(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GrayStringW, HDC, hdc, HBRUSH, hbr, GRAYSTRINGPROC, lpfnPrint, LPARAM, lParam, int, cch, int, x, int, y, int, cx, int, cy)
BOOL GrayStringW(
    HDC            hdc,
    HBRUSH         hbr,
    GRAYSTRINGPROC lpfnPrint,
    LPARAM         lParam,
    int            cch,
    int            x,
    int            y,
    int            cx,
    int            cy)
{
    return (InnerGrayStringAorW(hdc,
                                hbr,
                                lpfnPrint,
                                lParam,
                                cch,
                                x,
                                y,
                                cx,
                                cy,
                                FALSE));
}


/***************************************************************************\
* GetUserObjectSecurity (API)
*
* Gets the security descriptor of an object
*
* History:
* 07-01-91 JimA         Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetUserObjectSecurity, HANDLE, hObject, PSECURITY_INFORMATION, pRequestedInformation, PSECURITY_DESCRIPTOR, pSecurityDescriptor, DWORD, nLength, LPDWORD, lpnLengthRequired)
BOOL GetUserObjectSecurity(
    HANDLE hObject,
    PSECURITY_INFORMATION pRequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthRequired)
{
    NTSTATUS Status;

    Status = NtQuerySecurityObject(hObject,
                                   *pRequestedInformation,
                                   pSecurityDescriptor,
                                   nLength,
                                   lpnLengthRequired);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return FALSE;
    }
    return TRUE;
}


/***************************************************************************\
* SetUserObjectSecurity (API)
*
* Sets the security descriptor of an object
*
* History:
* 07-01-91 JimA         Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetUserObjectSecurity, HANDLE, hObject, PSECURITY_INFORMATION, pRequestedInformation, PSECURITY_DESCRIPTOR, pSecurityDescriptor)
BOOL SetUserObjectSecurity(
    HANDLE hObject,
    PSECURITY_INFORMATION pRequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    NTSTATUS Status;

    Status = NtSetSecurityObject(hObject,
                                 *pRequestedInformation,
                                 pSecurityDescriptor);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return FALSE;
    }
    return TRUE;
}


/***************************************************************************\
* GetUserObjectInformation (API)
*
* Gets information about an object
*
* History:
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetUserObjectInformationA, HANDLE, hObject, int, nIndex, PVOID, pvInfo, DWORD, nLength, LPDWORD, pnLengthNeeded)
BOOL GetUserObjectInformationA(
    HANDLE hObject,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD pnLengthNeeded)
{
    PVOID pvInfoW;
    DWORD nLengthW;
    BOOL fSuccess;

    if (nIndex == UOI_NAME || nIndex == UOI_TYPE) {
        nLengthW = nLength * sizeof(WCHAR);
        pvInfoW = LocalAlloc(LPTR, nLengthW);
        fSuccess = NtUserGetObjectInformation(hObject, nIndex, pvInfoW,
                nLengthW, pnLengthNeeded);
        if (fSuccess) {
            if (pnLengthNeeded != NULL)
                 *pnLengthNeeded /= sizeof(WCHAR);
            WCSToMB(pvInfoW, -1, &(PCHAR)pvInfo, nLength, FALSE);
        }
        LocalFree(pvInfoW);
        return fSuccess;
    } else {
        return NtUserGetObjectInformation(hObject, nIndex, pvInfo,
                nLength, pnLengthNeeded);
    }
}

BOOL GetWinStationInfo(
    WSINFO* pWsInfo)
{
    return (BOOL)NtUserCallOneParam((ULONG_PTR)pWsInfo, SFI__GETWINSTATIONINFO);
}

/***************************************************************************\
* GetServerIMEKeyboardLayout
*
* This routine finds HKL matches the IME module name sent from the Hydra
* client at its session startup.
* Hydra server tries to load the same IME module in the client, rather
* than to use the same HKL: that's because, on FE machines,
* the same IME might have different HKL dependent to each system.
*
* If the same IME name is found in registry, then it returns the HKL.
* If it cannot find, return value is 0.
*
* History:
\***************************************************************************/
ULONG GetServerIMEKeyboardLayout(
    LPTSTR pszImeFileName)
{
    BOOL fFound = FALSE;
    ULONG wLayoutId;
    UNICODE_STRING UnicodeStringKLKey;
    UNICODE_STRING UnicodeStringSubKLKey;
    UNICODE_STRING UnicodeStringIME;
    OBJECT_ATTRIBUTES OA;
    HANDLE hKey;
    ULONG Index;
    WCHAR awchKLRegKey[NSZKLKEY];
    LPWSTR lpszKLRegKey = awchKLRegKey;
    NTSTATUS Status;

    RtlInitUnicodeString(&UnicodeStringKLKey, szKLKey);
    InitializeObjectAttributes(&OA, &UnicodeStringKLKey, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &OA))) {

        for (Index = 0; TRUE; Index++) {

            BYTE KeyBuffer[sizeof(KEY_BASIC_INFORMATION) + KL_NAMELENGTH * sizeof(WCHAR)];
            PKEY_BASIC_INFORMATION pKeyInfo;
            ULONG ResultLength;

            pKeyInfo = (PKEY_BASIC_INFORMATION)KeyBuffer;
            Status = NtEnumerateKey(hKey,
                                    Index,
                                    KeyBasicInformation,
                                    pKeyInfo,
                                    sizeof(KeyBuffer),
                                    &ResultLength);

            if (NT_SUCCESS(Status)) {
                UnicodeStringSubKLKey.Buffer = (PWSTR)&(pKeyInfo->Name[0]);
                UnicodeStringSubKLKey.Length = (USHORT)pKeyInfo->NameLength;
                UnicodeStringSubKLKey.MaximumLength = (USHORT)pKeyInfo->NameLength;
                RtlUnicodeStringToInteger(&UnicodeStringSubKLKey, 16, &wLayoutId);

                if (IS_IME_KBDLAYOUT(wLayoutId)) {

                    HANDLE hSubKey;

                    wcscpy(lpszKLRegKey, szKLKey);
                    wcsncat(lpszKLRegKey, UnicodeStringSubKLKey.Buffer,
                                          UnicodeStringSubKLKey.Length / sizeof(WCHAR));
                    RtlInitUnicodeString(&UnicodeStringKLKey, lpszKLRegKey);
                    InitializeObjectAttributes(&OA, &UnicodeStringKLKey, OBJ_CASE_INSENSITIVE, NULL, NULL);

                    if (NT_SUCCESS(NtOpenKey(&hSubKey, KEY_READ, &OA))) {
                        /*
                         * GetIME file name from "HKLM\...\<Index>\IME File"
                         */
                        static CONST WCHAR szIMEfile[]  = L"IME file";
                        struct {
                            KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
                            WCHAR awchImeName[CCH_KL_LIBNAME];
                        } IMEfile;
                        LPWSTR pwszIME;
                        DWORD cbSize;

                        RtlInitUnicodeString(&UnicodeStringIME, szIMEfile);

                        Status = NtQueryValueKey(hSubKey,
                                                 &UnicodeStringIME,
                                                 KeyValuePartialInformation,
                                                 &IMEfile,
                                                 sizeof IMEfile,
                                                 &cbSize);
                        NtClose(hSubKey);

                        if (NT_SUCCESS(Status)) {
                            pwszIME = (LPWSTR)IMEfile.KeyInfo.Data;
                            pwszIME[CCH_KL_LIBNAME - 1] = L'\0';
                            if (!lstrcmpi(pwszIME, pszImeFileName)) {
                                /*
                                 * IME file name match !!
                                 */
                                fFound = TRUE;
                                break;
                            }
                        }
                    }
                }
            }
            else {
                break;
            }
        }
        NtClose(hKey);
    }

    if (fFound)
        return wLayoutId;

    return 0;
}

/***************************************************************************\
* GetRemoteKeyboardLayout
*
* Returns TRUE if the client winstation specified a keyboard layout.
* If TRUE, the LayoutBuf contains the name of the keyboard layout.
* History:
\***************************************************************************/

BOOL
GetRemoteKeyboardLayout(
    PWCHAR LayoutBuf)
{
    ULONG                        KeyboardLayout;
    ULONG                        Length;
    WINSTATIONCONFIG             ConfigData;

    /*
     * Skip if this is the main session
     */
    if (!ISREMOTESESSION()) {
        return FALSE;
    }

    /*
     * Fetch the WinStation's basic information
     */
    if (!WinStationQueryInformationW(SERVERNAME_CURRENT,
                                LOGONID_CURRENT,
                                WinStationConfiguration,
                                &ConfigData,
                                sizeof(ConfigData),
                                &Length)) {

        return FALSE;
    }

    KeyboardLayout = ConfigData.User.KeyboardLayout;

    if (IS_IME_ENABLED()) {
        WINSTATIONCLIENTW ClientData;

        // Fetch the WinStation's basic information
        if (!WinStationQueryInformationW(SERVERNAME_CURRENT,
                                           LOGONID_CURRENT,
                                           WinStationClient,
                                           &ClientData,
                                           sizeof(ClientData),
                                           &Length)) {
            return FALSE;
        }

        if (IS_IME_KBDLAYOUT(ConfigData.User.KeyboardLayout)) {
            KeyboardLayout = GetServerIMEKeyboardLayout(ClientData.imeFileName);
        }
    }

    if (KeyboardLayout != 0) {
        wsprintfW(LayoutBuf, L"%8.8lx", KeyboardLayout);
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* CreateWindowStation (API)
*
* Creates a windowstation object
*
* History:
\***************************************************************************/

HWINSTA CommonCreateWindowStation(
    PUNICODE_STRING         pstrName,
    ACCESS_MASK             amRequest,
    PSECURITY_ATTRIBUTES    lpsa)
{
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              hRootDirectory;
    HWINSTA             hwinstaNew = NULL;
    WCHAR               pwszKLID[KL_NAMELENGTH];
    HANDLE              hKeyboardFile = NULL;
    DWORD               offTable;
    UNICODE_STRING      strKLID;
    UINT                uKbdInputLocale, uFlags;
    NTSTATUS            Status;

    /*
     * Load initial keyboard layout.  Continue even if
     * this fails (esp. important with KLF_INITTIME set)
     */
    ULONG               KeyboardLayout = 0;
    ULONG               Length;
    PWINSTATIONCONFIG   pConfigData = NULL;
    BOOLEAN             bResult;

    KBDTABLE_MULTI_INTERNAL kbdTableMulti;

    extern BOOL CtxInitUser32(VOID);

    hKeyboardFile = NULL;

    /*
     * Allocate a buffer for the WINSTATION structure
     */
    if ((pConfigData = GlobalAlloc(LPTR, sizeof(WINSTATIONCONFIG))) == NULL) {
        return NULL;
    }


    /*
     * Get winstation info
     */
    if (ISREMOTESESSION()) {

        bResult = WinStationQueryInformationW(SERVERNAME_CURRENT,
                                                       LOGONID_CURRENT,
                                                       WinStationConfiguration,
                                                       pConfigData,
                                                       sizeof(WINSTATIONCONFIG),
                                                       &Length);
        if (bResult) {
            KeyboardLayout = pConfigData->User.KeyboardLayout;

            if (KeyboardLayout) {
                wsprintfW(pwszKLID, L"%8.8lx", KeyboardLayout);
                uFlags = KLF_ACTIVATE | KLF_INITTIME;

                hKeyboardFile = OpenKeyboardLayoutFile(pwszKLID,
                            &uFlags, &offTable, &uKbdInputLocale, &kbdTableMulti);

                RIPMSG0(RIP_WARNING, "OpenKeyboardLayoutFile() failed. Will use the fallback keyboard layout");
            }
        }
    }

    if (hKeyboardFile == NULL) {

        GetActiveKeyboardName(pwszKLID);
retry:
        uFlags = KLF_ACTIVATE | KLF_INITTIME;
        hKeyboardFile = OpenKeyboardLayoutFile(pwszKLID,
                &uFlags, &offTable, &uKbdInputLocale, &kbdTableMulti);
        if (hKeyboardFile == NULL) {
            if (wcscmp(pwszKLID, L"00000409")) {
                wcscpy(pwszKLID, L"00000409");
                RIPMSG0(RIP_WARNING, "OpendKeyboardLayoutFile() failed: will use the fallback keyboard layout.");
                goto retry;
            }
            uKbdInputLocale = 0x04090409;
        }
    }


    /*
     * Finish the rest of the DLL initialization for WinStations.
     * Until this point we had no video driver.
     *
     * clupu: We have to prevent this for NOIO windowstations !!!
     */
    if (ISTS()) {
        if (!CtxInitUser32()) {
            RIPMSG0(RIP_WARNING, "CtxInitUser32 failed");
            goto Exit;
        }
    }

    RtlInitUnicodeString(&strKLID, pwszKLID);

    /*
     * If a name was specified, open the parent directory.  Be sure
     * to test the length rather than the buffer because for NULL
     * string RtlCreateUnicodeStringFromAsciiz will allocate a
     * buffer pointing to an empty string.
     */
    if (pstrName->Length != 0) {
        InitializeObjectAttributes(&Obja,
                                   (PUNICODE_STRING)&strRootDirectory,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL, NULL);
        Status = NtOpenDirectoryObject(&hRootDirectory,
                DIRECTORY_CREATE_OBJECT, &Obja);
        if (!NT_SUCCESS(Status)) {
            RIPNTERR0(Status, RIP_VERBOSE, "");
            goto Exit;
        }
    } else {
        pstrName = NULL;
        hRootDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja, pstrName,
            OBJ_CASE_INSENSITIVE  | OBJ_OPENIF |
                ((lpsa && lpsa->bInheritHandle) ? OBJ_INHERIT : 0),
            hRootDirectory, lpsa ? lpsa->lpSecurityDescriptor : NULL);

    /*
     * NULL hKeyboardFile will let the kernel to utilize
     * the kbdnull layout which is a built in as a fallback layout
     * in Win32k.sys.
     */
    hwinstaNew = NtUserCreateWindowStation(
                            &Obja,
                            amRequest,
                            hKeyboardFile,
                            offTable,
                            &kbdTableMulti,
                            &strKLID,
                            uKbdInputLocale);

    if (hRootDirectory != NULL)
        NtClose(hRootDirectory);
Exit:
    if (hKeyboardFile) {
        NtClose(hKeyboardFile);
    }

    GlobalFree(pConfigData);
    return hwinstaNew;
}


FUNCLOG4(LOG_GENERAL, HWINSTA, DUMMYCALLINGTYPE, CreateWindowStationA, LPCSTR, pwinsta, DWORD, dwReserved, ACCESS_MASK, amRequest, PSECURITY_ATTRIBUTES, lpsa)
HWINSTA CreateWindowStationA(
    LPCSTR      pwinsta,
    DWORD       dwReserved,
    ACCESS_MASK amRequest,
    PSECURITY_ATTRIBUTES lpsa)
{
    UNICODE_STRING UnicodeString;
    HWINSTA hwinsta;

    if (!RtlCreateUnicodeStringFromAsciiz(&UnicodeString, pwinsta))
        return NULL;

    hwinsta = CommonCreateWindowStation(&UnicodeString, amRequest, lpsa);

    RtlFreeUnicodeString(&UnicodeString);

    return hwinsta;

    UNREFERENCED_PARAMETER(dwReserved);
}


FUNCLOG4(LOG_GENERAL, HWINSTA, DUMMYCALLINGTYPE, CreateWindowStationW, LPCWSTR, pwinsta, DWORD, dwReserved, ACCESS_MASK, amRequest, PSECURITY_ATTRIBUTES, lpsa)
HWINSTA CreateWindowStationW(
    LPCWSTR     pwinsta,
    DWORD       dwReserved,
    ACCESS_MASK amRequest,
    PSECURITY_ATTRIBUTES lpsa)
{
    UNICODE_STRING strWinSta;

    RtlInitUnicodeString(&strWinSta, pwinsta);

    return CommonCreateWindowStation(&strWinSta, amRequest, lpsa);

    UNREFERENCED_PARAMETER(dwReserved);
}


/***************************************************************************\
* OpenWindowStation (API)
*
* Opens a windowstation object
*
* History:
\***************************************************************************/

HWINSTA CommonOpenWindowStation(
    CONST UNICODE_STRING *pstrName,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    WCHAR awchName[sizeof(WINSTA_NAME) / sizeof(WCHAR)];
    UNICODE_STRING strDefaultName;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE hRootDirectory;
    HWINSTA hwinsta;
    NTSTATUS Status;

    InitializeObjectAttributes(&ObjA,
                               (PUNICODE_STRING)&strRootDirectory,
                               OBJ_CASE_INSENSITIVE,
                               NULL, NULL);
    Status = NtOpenDirectoryObject(&hRootDirectory,
                                   DIRECTORY_TRAVERSE,
                                   &ObjA);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return NULL;
    }

    if (pstrName->Length == 0) {
        RtlCopyMemory(awchName, WINSTA_NAME, sizeof(WINSTA_NAME));
        RtlInitUnicodeString(&strDefaultName, awchName);
        pstrName = &strDefaultName;
    }

    InitializeObjectAttributes( &ObjA,
                                (PUNICODE_STRING)pstrName,
                                OBJ_CASE_INSENSITIVE,
                                hRootDirectory,
                                NULL
                                );
    if (fInherit)
        ObjA.Attributes |= OBJ_INHERIT;

    hwinsta = NtUserOpenWindowStation(&ObjA, amRequest);

    NtClose(hRootDirectory);

    return hwinsta;
}


FUNCLOG3(LOG_GENERAL, HWINSTA, DUMMYCALLINGTYPE, OpenWindowStationA, LPCSTR, pwinsta, BOOL, fInherit, ACCESS_MASK, amRequest)
HWINSTA OpenWindowStationA(
    LPCSTR pwinsta,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    UNICODE_STRING UnicodeString;
    HWINSTA hwinsta;

    if (!RtlCreateUnicodeStringFromAsciiz(&UnicodeString, pwinsta))
        return NULL;

    hwinsta = CommonOpenWindowStation(&UnicodeString, fInherit, amRequest);

    RtlFreeUnicodeString(&UnicodeString);

    return hwinsta;
}


FUNCLOG3(LOG_GENERAL, HWINSTA, DUMMYCALLINGTYPE, OpenWindowStationW, LPCWSTR, pwinsta, BOOL, fInherit, ACCESS_MASK, amRequest)
HWINSTA OpenWindowStationW(
    LPCWSTR pwinsta,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    UNICODE_STRING strWinSta;

    RtlInitUnicodeString(&strWinSta, pwinsta);

    return CommonOpenWindowStation(&strWinSta, fInherit, amRequest);
}

/***************************************************************************\
* CommonCreateDesktop (API)
*
* Creates a desktop object
*
* History:
\***************************************************************************/

HDESK CommonCreateDesktop(
    PUNICODE_STRING pstrDesktop,
    PUNICODE_STRING pstrDevice,
    LPDEVMODEW      pDevmode,
    DWORD           dwFlags,
    ACCESS_MASK     amRequest,
    PSECURITY_ATTRIBUTES lpsa)
{
    OBJECT_ATTRIBUTES Obja;
    HDESK hdesk = NULL;

    InitializeObjectAttributes(&Obja,
                               pstrDesktop,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENIF |
                                   ((lpsa && lpsa->bInheritHandle) ? OBJ_INHERIT : 0),
                               NtUserGetProcessWindowStation(),
                               lpsa ? lpsa->lpSecurityDescriptor : NULL);

    hdesk = NtUserCreateDesktop(&Obja,
                                pstrDevice,
                                pDevmode,
                                dwFlags,
                                amRequest);

    return hdesk;
}

/***************************************************************************\
* CreateDesktopA (API)
*
* Creates a desktop object
*
* History:
\***************************************************************************/


FUNCLOG6(LOG_GENERAL, HDESK, DUMMYCALLINGTYPE, CreateDesktopA, LPCSTR, pDesktop, LPCSTR, pDevice, LPDEVMODEA, pDevmode, DWORD, dwFlags, ACCESS_MASK, amRequest, PSECURITY_ATTRIBUTES, lpsa)
HDESK CreateDesktopA(
    LPCSTR pDesktop,
    LPCSTR pDevice,
    LPDEVMODEA pDevmode,
    DWORD dwFlags,
    ACCESS_MASK amRequest,
    PSECURITY_ATTRIBUTES lpsa)
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeDesktop;
    UNICODE_STRING UnicodeDevice;
    PUNICODE_STRING pUnicodeDevice = NULL;
    LPDEVMODEW lpDevModeW = NULL;
    HDESK hdesk;

    RtlInitAnsiString(&AnsiString, pDesktop);
    Status = RtlAnsiStringToUnicodeString(&UnicodeDesktop, &AnsiString, TRUE);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status, RIP_VERBOSE, "CreateDesktop fails with Status = 0x%x", Status);
        return NULL;
    }

    if (pDevice) {

        pUnicodeDevice = &UnicodeDevice;
        RtlInitAnsiString(&AnsiString, pDevice);
        Status = RtlAnsiStringToUnicodeString( &UnicodeDevice, &AnsiString, TRUE );

        if (!NT_SUCCESS(Status)) {
            RIPNTERR0(Status, RIP_VERBOSE, "");
            RtlFreeUnicodeString(&UnicodeDesktop);
            return NULL;
        }
    }

    if (pDevmode) {

        lpDevModeW = GdiConvertToDevmodeW(pDevmode);

    }

    hdesk = CommonCreateDesktop(&UnicodeDesktop,
                                pUnicodeDevice,
                                lpDevModeW,
                                dwFlags,
                                amRequest,
                                lpsa);

    RtlFreeUnicodeString(&UnicodeDesktop);
    if (pDevice) {
        RtlFreeUnicodeString(&UnicodeDevice);
    }

    if (lpDevModeW) {
        LocalFree(lpDevModeW);
    }

    return hdesk;
}

/***************************************************************************\
* CreateDesktopW (API)
*
* Creates a desktop object
*
* History:
\***************************************************************************/


FUNCLOG6(LOG_GENERAL, HDESK, DUMMYCALLINGTYPE, CreateDesktopW, LPCWSTR, pDesktop, LPCWSTR, pDevice, LPDEVMODEW, pDevmode, DWORD, dwFlags, ACCESS_MASK, amRequest, PSECURITY_ATTRIBUTES, lpsa)
HDESK CreateDesktopW(
    LPCWSTR pDesktop,
    LPCWSTR pDevice,
    LPDEVMODEW pDevmode,
    DWORD dwFlags,
    ACCESS_MASK amRequest,
    PSECURITY_ATTRIBUTES lpsa)
{
    UNICODE_STRING strDesktop;
    UNICODE_STRING strDevice;

    RtlInitUnicodeString(&strDesktop, pDesktop);
    RtlInitUnicodeString(&strDevice, pDevice);

    return CommonCreateDesktop(&strDesktop,
                               pDevice ? &strDevice : NULL,
                               pDevmode,
                               dwFlags,
                               amRequest,
                               lpsa);
}

/***************************************************************************\
* OpenDesktop (API)
*
* Opens a desktop object
*
* History:
\***************************************************************************/

HDESK CommonOpenDesktop(
    PUNICODE_STRING pstrDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    OBJECT_ATTRIBUTES ObjA;

    InitializeObjectAttributes( &ObjA,
                                pstrDesktop,
                                OBJ_CASE_INSENSITIVE,
                                NtUserGetProcessWindowStation(),
                                NULL
                                );
    if (fInherit)
        ObjA.Attributes |= OBJ_INHERIT;

    return NtUserOpenDesktop(&ObjA, dwFlags, amRequest);
}


FUNCLOG4(LOG_GENERAL, HDESK, DUMMYCALLINGTYPE, OpenDesktopA, LPCSTR, pdesktop, DWORD, dwFlags, BOOL, fInherit, ACCESS_MASK, amRequest)
HDESK OpenDesktopA(
    LPCSTR pdesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    UNICODE_STRING UnicodeString;
    HDESK hdesk;

    if (!RtlCreateUnicodeStringFromAsciiz(&UnicodeString, pdesktop))
        return NULL;

    hdesk = CommonOpenDesktop(&UnicodeString, dwFlags, fInherit, amRequest);

    RtlFreeUnicodeString(&UnicodeString);

    return hdesk;
}


FUNCLOG4(LOG_GENERAL, HDESK, DUMMYCALLINGTYPE, OpenDesktopW, LPCWSTR, pdesktop, DWORD, dwFlags, BOOL, fInherit, ACCESS_MASK, amRequest)
HDESK OpenDesktopW(
    LPCWSTR pdesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK amRequest)
{
    UNICODE_STRING strDesktop;

    RtlInitUnicodeString(&strDesktop, pdesktop);

    return CommonOpenDesktop(&strDesktop, dwFlags, fInherit, amRequest);
}

/***************************************************************************\
* RegisterClassWOW(API)
*
* History:
* 28-Jul-1992 ChandanC Created.
\***************************************************************************/
ATOM
WINAPI
RegisterClassWOWA(
    WNDCLASSA *lpWndClass,
    LPDWORD pdwWOWstuff)
{
    WNDCLASSEXA wc;

    /*
     * On 64-bit plaforms we'll have 32 bits of padding between style and
     * lpfnWndProc in WNDCLASS, so start the copy from the first 64-bit
     * aligned field and hand copy the rest.
     */
    RtlCopyMemory(&(wc.lpfnWndProc), &(lpWndClass->lpfnWndProc), sizeof(WNDCLASSA) - FIELD_OFFSET(WNDCLASSA, lpfnWndProc));
    wc.style = lpWndClass->style;
    wc.hIconSm = NULL;
    wc.cbSize = sizeof(WNDCLASSEXA);

    return RegisterClassExWOWA(&wc, pdwWOWstuff, 0, 0);
}


/**************************************************************************\
* WowGetDefWindowProcBits - Fills in bit array for WOW
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

WORD WowGetDefWindowProcBits(
    PBYTE    pDefWindowProcBits,
    WORD     cbDefWindowProcBits)
{
    WORD  wMaxMsg;
    KPBYTE pbSrc;
    PBYTE pbDst, pbDstEnd;

    UNREFERENCED_PARAMETER(cbDefWindowProcBits);

    /*
     * Merge the bits from gpsi->gabDefWindowMsgs and
     * gpsi->gabDefWindowSpecMsgs into WOW's DefWindowProcBits.  These two
     * indicate which messages must go directly to the server and which
     * can be handled with some special code in DefWindowProcWorker.
     * Bitwise OR'ing the two gives a bit array with 1 in the bit field
     * for each message that must go to user32's DefWindowProc, and 0
     * for those that can be returned back to the client immediately.
     *
     * For speed we assume WOW has zeroed the buffer, in fact it's in
     * USER.EXE's code segment and is zeroed in the image.
     */

    wMaxMsg = max(gSharedInfo.DefWindowMsgs.maxMsgs,
            gSharedInfo.DefWindowSpecMsgs.maxMsgs);

    UserAssert((wMaxMsg / 8 + 1) <= cbDefWindowProcBits);

    //
    // If the above assertion fires, the size of the DWPBits array in
    // \nt\private\mvdm\wow16\user\user.asm needs to be increased.
    //

    /* First copy the bits from DefWindowMsgs */

    RtlCopyMemory(
        pDefWindowProcBits,
        gSharedInfo.DefWindowMsgs.abMsgs,
        gSharedInfo.DefWindowMsgs.maxMsgs / 8 + 1
        );

    /* Next OR in the bits from DefWindowSpecMsgs */

    pbSrc = gSharedInfo.DefWindowSpecMsgs.abMsgs;
    pbDst = pDefWindowProcBits;
    pbDstEnd = pbDst + (gSharedInfo.DefWindowSpecMsgs.maxMsgs / 8 + 1);

    while (pbDst < pbDstEnd)
    {
        *pbDst++ |= *pbSrc++;
    }

    return wMaxMsg;
}



FUNCLOG2(LOG_GENERAL, ULONG_PTR, DUMMYCALLINGTYPE, UserRegisterWowHandlers, APFNWOWHANDLERSIN, apfnWowIn, APFNWOWHANDLERSOUT, apfnWowOut)
ULONG_PTR UserRegisterWowHandlers(
    APFNWOWHANDLERSIN apfnWowIn,
    APFNWOWHANDLERSOUT apfnWowOut)
{

    // In'ees
    pfnLocalAlloc = apfnWowIn->pfnLocalAlloc;
    pfnLocalReAlloc = apfnWowIn->pfnLocalReAlloc;
    pfnLocalLock = apfnWowIn->pfnLocalLock;
    pfnLocalUnlock = apfnWowIn->pfnLocalUnlock;
    pfnLocalSize = apfnWowIn->pfnLocalSize;
    pfnLocalFree = apfnWowIn->pfnLocalFree;
    pfnGetExpWinVer = apfnWowIn->pfnGetExpWinVer;
    pfn16GlobalAlloc = apfnWowIn->pfn16GlobalAlloc;
    pfn16GlobalFree = apfnWowIn->pfn16GlobalFree;
    pfnWowEmptyClipBoard = apfnWowIn->pfnEmptyCB;
    pfnWowEditNextWord = apfnWowIn->pfnWowEditNextWord;
    pfnWowCBStoreHandle = apfnWowIn->pfnWowCBStoreHandle;
    pfnFindResourceExA = apfnWowIn->pfnFindResourceEx;
    pfnLoadResource = apfnWowIn->pfnLoadResource;
    pfnLockResource = apfnWowIn->pfnLockResource;
    pfnUnlockResource = apfnWowIn->pfnUnlockResource;
    pfnFreeResource = apfnWowIn->pfnFreeResource;
    pfnSizeofResource = apfnWowIn->pfnSizeofResource;
    pfnFindResourceExW = WOWFindResourceExWCover;
    pfnWowDlgProcEx = apfnWowIn->pfnWowDlgProcEx;
    pfnWowWndProcEx = apfnWowIn->pfnWowWndProcEx;
    pfnWowGetProcModule = apfnWowIn->pfnGetProcModule16;
    pfnWowTask16SchedNotify = apfnWowIn->pfnWowTask16SchedNotify;
    pfnWOWTellWOWThehDlg = apfnWowIn->pfnWOWTellWOWThehDlg;
    pfnWowMsgBoxIndirectCallback = apfnWowIn->pfnWowMsgBoxIndirectCallback;
    pfnWowIlstrcmp = apfnWowIn->pfnWowIlstrsmp;

    // Out'ees
#if DBG
    apfnWowOut->dwBldInfo = (WINVER << 16) | 0x80000000;
#else
    apfnWowOut->dwBldInfo = (WINVER << 16);
#endif
    apfnWowOut->pfnCsCreateWindowEx            = _CreateWindowEx;
    apfnWowOut->pfnDirectedYield               = DirectedYield;
    apfnWowOut->pfnFreeDDEData                 = FreeDDEData;
    apfnWowOut->pfnGetClassWOWWords            = GetClassWOWWords;
    apfnWowOut->pfnInitTask                    = InitTask;
    apfnWowOut->pfnRegisterClassWOWA           = RegisterClassWOWA;
    apfnWowOut->pfnRegisterUserHungAppHandlers = RegisterUserHungAppHandlers;
    apfnWowOut->pfnServerCreateDialog          = InternalCreateDialog;
    apfnWowOut->pfnServerLoadCreateCursorIcon  = WowServerLoadCreateCursorIcon;
    apfnWowOut->pfnServerLoadCreateMenu        = WowServerLoadCreateMenu;
    apfnWowOut->pfnWOWCleanup                  = WOWCleanup;
    apfnWowOut->pfnWOWModuleUnload             = WOWModuleUnload;
    apfnWowOut->pfnWOWFindWindow               = WOWFindWindow;
    apfnWowOut->pfnWOWLoadBitmapA              = WOWLoadBitmapA;
    apfnWowOut->pfnWowWaitForMsgAndEvent       = NtUserWaitForMsgAndEvent;
    apfnWowOut->pfnYieldTask                   = NtUserYieldTask;
    apfnWowOut->pfnGetFullUserHandle           = GetFullUserHandle;
    apfnWowOut->pfnGetMenuIndex                = NtUserGetMenuIndex;
    apfnWowOut->pfnWowGetDefWindowProcBits     = WowGetDefWindowProcBits;
    apfnWowOut->pfnFillWindow                  = FillWindow;
    apfnWowOut->aiWowClass                     = aiClassWow;
    return (ULONG_PTR)&gSharedInfo;
}

/***************************************************************************\
* GetEditDS
*
* This is a callback to WOW used to allocate a segment for DS_LOCALEDIT
* edit controls.  The segment is disguised to look like a WOW hInstance.
*
* 06-19-92 sanfords Created
\***************************************************************************/
HANDLE GetEditDS()
{
    UserAssert(pfn16GlobalAlloc != NULL);

    return((HANDLE)((*pfn16GlobalAlloc)(GHND | GMEM_SHARE, 256)));
}



/***************************************************************************\
* ReleaseEditDS
*
* This is a callback to WOW used to free a segment for DS_LOCALEDIT
* edit controls.
*
* 06-19-92 sanfords Created
\***************************************************************************/
VOID ReleaseEditDS(
HANDLE h)
{
    UserAssert(pfn16GlobalFree != NULL);

    (*pfn16GlobalFree)(LOWORD(HandleToUlong(h)));
}



/***************************************************************************\
* TellWOWThehDlg
*
* This is a callback to WOW used to inform WOW of the hDlg of a newly
* created dialog window.
*
* 08-31-97 cmjones  Created
\***************************************************************************/
VOID TellWOWThehDlg(
HWND hDlg)
{
    UserAssert(pfnWOWTellWOWThehDlg != NULL);

    (*pfnWOWTellWOWThehDlg)(hDlg);
}



/***************************************************************************\
* DispatchClientMessage
*
* pwnd is threadlocked in the kernel and thus always valid.
*
* 19-Aug-1992 mikeke   created
\***************************************************************************/
LRESULT DispatchClientMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR pfn)
{
    PCLIENTINFO pci = GetClientInfo();
    HWND hwnd = KHWND_TO_HWND(pci->CallbackWnd.hwnd);
    PACTIVATION_CONTEXT pActCtx = pci->CallbackWnd.pActCtx;
    LRESULT lRet = 0;

    /*
     * Assert that the header comment is legit (it must be). For WM_TIMER
     * messages not associated with a window, pwnd can be NULL. So don't
     * rip validating the handle.
     */
    UserAssert(pwnd == ValidateHwndNoRip(hwnd));

    /*
     * Add assert to catch dispatching messages to a thread not associated
     * with a desktop.
     */
    UserAssert(GetClientInfo()->ulClientDelta != 0);

    if (message == WM_TIMER && lParam != 0) {
        /*
         * Console windows use WM_TIMER for the caret. However, they don't
         * use a timer callback, so if this is CSRSS and there's a WM_TIMER
         * for us, the only way lParam would be non-zero is if someone's trying
         * to make us fault. No, this isn't a nice thing to do, but there
         * are bad, bad people out there. Windows Bug #361246.
         */
        if (!gfServerProcess) {
            /*
             * We can't really trust what's in lParam, so make sure we
             * handle any exceptions that occur during this call.
             */
            try {
                lRet = UserCallWinProcCheckWow(pActCtx,
                                               (WNDPROC)pfn,
                                               hwnd,
                                               message,
                                               wParam,
                                               NtGetTickCount(),
                                               &(pwnd->state),
                                               TRUE);
            } except ((GetAppCompatFlags2(VER40) & GACF2_NO_TRYEXCEPT_CALLWNDPROC) ?
                      EXCEPTION_CONTINUE_SEARCH : W32ExceptionHandler(FALSE, RIP_WARNING)) {
                      /*
                       * Windows NT Bug #359866.
                       * Some applications like Hagaki Studio 2000 need to handle
                       * the exception in WndProc in their handler, even though it
                       * skips the API calls. For those apps, we have to honor the
                       * behavior of NT4, with no protection.
                       */
            }
        }
    } else {
        lRet = UserCallWinProcCheckWow(pActCtx, (WNDPROC)pfn, hwnd, message, wParam, lParam, &(pwnd->state), TRUE);
    }

    return lRet;
}

/**************************************************************************\
* ArrangeIconicWindows
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, ArrangeIconicWindows, HWND, hwnd)
UINT ArrangeIconicWindows(
    HWND hwnd)
{
    return (UINT)NtUserCallHwndLock(hwnd, SFI_XXXARRANGEICONICWINDOWS);
}

/**************************************************************************\
* BeginDeferWindowPos
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, HANDLE, DUMMYCALLINGTYPE, BeginDeferWindowPos, int, nNumWindows)
HANDLE BeginDeferWindowPos(
    int nNumWindows)
{
    if (nNumWindows < 0) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"nNumWindows\" (%ld) to BeginDeferWindowPos",
                nNumWindows);

        return 0;
    }

    return (HANDLE)NtUserCallOneParam(nNumWindows, SFI__BEGINDEFERWINDOWPOS);
}

/**************************************************************************\
* EndDeferWindowPos
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EndDeferWindowPos, HDWP, hWinPosInfo)
BOOL EndDeferWindowPos(
    HDWP hWinPosInfo)
{
    return NtUserEndDeferWindowPosEx(hWinPosInfo, FALSE);
}

/**************************************************************************\
* CascadeChildWindows
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CascadeChildWindows, HWND, hwndParent, UINT, nCode)
BOOL CascadeChildWindows(
    HWND hwndParent,
    UINT nCode)
{
    return (BOOL) CascadeWindows(hwndParent, nCode, NULL, 0, NULL);
}

/**************************************************************************\
* CloseWindow
*
* 22-Jul-1991 mikeke    Created
* 17-Feb-1998 MCostea   Use xxxShowWindow instead of xxxCloseWindow
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CloseWindow, HWND, hwnd)
BOOL CloseWindow(
    HWND hwnd)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return FALSE;
    }
    if (!TestWF(pwnd, WFMINIMIZED)) {
        NtUserShowWindow(hwnd, SW_SHOWMINIMIZED);
    }
    return TRUE;
}

/**************************************************************************\
* CreateMenu
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

HMENU CreateMenu()
{
    return (HMENU)NtUserCallNoParam(SFI__CREATEMENU);
}

/**************************************************************************\
* CreatePopupMenu
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

HMENU CreatePopupMenu()
{
    return (HMENU)NtUserCallNoParam(SFI__CREATEPOPUPMENU);
}

/**************************************************************************\
* CurrentTaskLock
*
* 21-Apr-1992 jonpa    Created
\**************************************************************************/
#if 0 /* WOW is not using this but they might some day */
DWORD CurrentTaskLock(
    DWORD hlck)
{
    return (DWORD)NtUserCallOneParam(hlck, SFI_CURRENTTASKLOCK);
}
#endif
/**************************************************************************\
* DestroyCaret
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

BOOL DestroyCaret()
{
    return (BOOL)NtUserCallNoParam(SFI_ZZZDESTROYCARET);
}

/**************************************************************************\
* DirectedYield
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

void DirectedYield(
    DWORD dwThreadId)
{
    NtUserCallOneParam(dwThreadId, SFI_XXXDIRECTEDYIELD);
}

/**************************************************************************\
* DrawMenuBar
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawMenuBar, HWND, hwnd)
BOOL DrawMenuBar(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwndLock(hwnd, SFI_XXXDRAWMENUBAR);
}

/**************************************************************************\
* EnableWindow
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnableWindow, HWND, hwnd, BOOL, bEnable)
BOOL EnableWindow(
    HWND hwnd,
    BOOL bEnable)
{
    return (BOOL)NtUserCallHwndParamLock(hwnd, bEnable,
                                         SFI_XXXENABLEWINDOW);
}

/**************************************************************************\
* EnumClipboardFormats
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, EnumClipboardFormats, UINT, fmt)
UINT EnumClipboardFormats(
    UINT fmt)
{
    /*
     * So apps can tell if the API failed or just ran out of formats
     * we "clear" the last error.
     */
    UserSetLastError(ERROR_SUCCESS);

    return (UINT)NtUserCallOneParam(fmt, SFI__ENUMCLIPBOARDFORMATS);
}

/**************************************************************************\
* FlashWindow
*
* 22-Jul-1991 mikeke    Created
* 08-Aug-1997 Gerardob  Added FlashWindowEx.
* 16-Nov-1997 MCostea   Make it use NtUserFlashWindowEx
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, FlashWindow, HWND, hwnd, BOOL, bInvert)
BOOL FlashWindow(
    HWND hwnd,
    BOOL bInvert)
{
    FLASHWINFO fwi = {
            sizeof(FLASHWINFO), // cbSize
            hwnd,   // hwnd
            bInvert ? (FLASHW_CAPTION | FLASHW_TRAY) : 0,   // flags
            1,      // uCount
            0       // dwTimeout
        };
    return (BOOL)NtUserFlashWindowEx(&fwi);
}

/**************************************************************************\
* GetDialogBaseUnits
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

long GetDialogBaseUnits()
{
    return MAKELONG(gpsi->cxSysFontChar, gpsi->cySysFontChar);
}

/**************************************************************************\
* GetInputDesktop
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

HDESK GetInputDesktop()
{
    return (HDESK)NtUserCallNoParam(SFI_XXXGETINPUTDESKTOP);
}

/***************************************************************************\
* GetClientKeyboardType
*
* This routine returns the keyboard type sent from the Hydra client.
* Hydra client sends keyboard types at session startup.
*
* Returns the client winstation specified a keyboard type.
* History:
\***************************************************************************/

BOOL
GetClientKeyboardType(PCLIENTKEYBOARDTYPE KeyboardType)
{
    ULONG Length;
    WINSTATIONCLIENTW ClientData;
    static CLIENTKEYBOARDTYPE ClientKeyboard = { (ULONG)-1, (ULONG)-1, (ULONG)-1 };

    //
    // Should be called only if this is a HYDRA remote session.
    //
    UserAssert(ISREMOTESESSION());

    //  Skip if this is the console
    if (!ISREMOTESESSION()) {
        return FALSE;
    }

    if (ClientKeyboard.Type == (ULONG)-1) {

        // Fetch the WinStation's basic information
        if (!WinStationQueryInformationW(SERVERNAME_CURRENT,
                                   LOGONID_CURRENT,
                                   WinStationClient,
                                   &ClientData,
                                   sizeof(ClientData),
                                   &Length)) {
            return FALSE;
        }

        ClientKeyboard.Type        = ClientData.KeyboardType;
        ClientKeyboard.SubType     = ClientData.KeyboardSubType;
        ClientKeyboard.FunctionKey = ClientData.KeyboardFunctionKey;

    }

    *KeyboardType = ClientKeyboard;

    return TRUE;
}


/**************************************************************************\
* GetKeyboardType
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetKeyboardType, int, nTypeFlags)
int GetKeyboardType(
    int nTypeFlags)
{
    if (ISREMOTESESSION()) {
        //
        //  Get keyboard type from Hydra client if this is not the console
        //
        CLIENTKEYBOARDTYPE KeyboardType;

        if (GetClientKeyboardType(&KeyboardType)) {
            switch (nTypeFlags) {
            case 0:
                return KeyboardType.Type;
            case 1:
                if (KeyboardType.Type == 7) {               /* 7 is a Japanese */
                    // Because HIWORD has been using private value
                    // for Japanese keyboard layout.
                    return LOWORD(KeyboardType.SubType);
                }
                else
                    return KeyboardType.SubType;
            case 2:
                return KeyboardType.FunctionKey;
            default:
                break;
            }
        }
        return 0;
    }
    return (int)NtUserCallOneParam(nTypeFlags, SFI__GETKEYBOARDTYPE);
}

/**************************************************************************\
* GetMessagePos
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

DWORD GetMessagePos()
{
    return (DWORD)NtUserCallNoParam(SFI__GETMESSAGEPOS);
}

/**************************************************************************\
* GetQueueStatus
*
* 22-Jul-1991   mikeke      Created
* 14-Dec-2000   JStall      Converted to WMH
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetQueueStatus, UINT, flags)
DWORD GetQueueStatus(
    UINT flags)
#ifdef MESSAGE_PUMP_HOOK
{
    DWORD dwResult;

    BEGIN_MESSAGEPUMPHOOK()
        if (fInsideHook) {
            dwResult = gmph.pfnGetQueueStatus(flags);
        } else {
            dwResult = RealGetQueueStatus(flags);
        }
    END_MESSAGEPUMPHOOK()

    return dwResult;
}


DWORD RealGetQueueStatus(
    UINT flags)
#endif
{
    if (flags & ~QS_VALID) {
        RIPERR2(ERROR_INVALID_FLAGS, RIP_WARNING, "Invalid flags %x & ~%x != 0",
              flags, QS_VALID);
        return 0;
    }

    return (DWORD)NtUserCallOneParam(flags, SFI__GETQUEUESTATUS);
}

/**************************************************************************\
* KillSystemTimer
*
* 7-Jul-1992 mikehar    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, KillSystemTimer, HWND, hwnd, UINT, nIDEvent)
BOOL KillSystemTimer(
    HWND hwnd,
    UINT nIDEvent)
{
    return (BOOL)NtUserCallHwndParam(hwnd, nIDEvent, SFI__KILLSYSTEMTIMER);
}

/**************************************************************************\
* LoadRemoteFonts
*  02-Dec-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void LoadRemoteFonts(void)
{
    NtUserCallOneParam(TRUE,SFI_XXXLW_LOADFONTS);

    /*
     * After load remote fonts, let eudc enabled.
     */
    EnableEUDC(TRUE);
}


/**************************************************************************\
* LoadLocalFonts
*  31-Mar-1994 -by- Bodin Dresevic [gerritv]
* Wrote it.
\**************************************************************************/

void LoadLocalFonts(void)
{
    NtUserCallOneParam(FALSE,SFI_XXXLW_LOADFONTS);
}


/**************************************************************************\
* MessageBeep
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, MessageBeep, UINT, wType)
BOOL MessageBeep(
    UINT wType)
{
    return (BOOL)NtUserCallOneParam(wType, SFI_XXXMESSAGEBEEP);
}

/**************************************************************************\
* OpenIcon
*
* 22-Jul-1991 mikeke    Created
* 17-Feb-1998 MCostea   Use xxxShowWindow instead of xxxCloseWindow
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, OpenIcon, HWND, hwnd)
BOOL OpenIcon(
    HWND hwnd)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return FALSE;
    }
    if (TestWF(pwnd, WFMINIMIZED)) {
        NtUserShowWindow(hwnd, SW_NORMAL);
    }
    return TRUE;
}

HWND GetShellWindow(void) {
    PCLIENTINFO pci;
    PWND pwnd;

    ConnectIfNecessary(0);

    pci = GetClientInfo();
    pwnd = pci->pDeskInfo->spwndShell;
    if (pwnd != NULL) {
        pwnd = (PWND)((KERNEL_ULONG_PTR)pwnd - pci->ulClientDelta);
        return HWq(pwnd);
    }
    return NULL;
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetShellWindow, HWND, hwnd)
BOOL  SetShellWindow(HWND hwnd)
{
    return (BOOL)NtUserSetShellWindowEx(hwnd, hwnd);
}

HWND GetProgmanWindow(void) {
    PCLIENTINFO pci;
    PWND pwnd;

    ConnectIfNecessary(0);

    pci = GetClientInfo();
    pwnd = pci->pDeskInfo->spwndProgman;
    if (pwnd != NULL) {
        pwnd = (PWND)((KERNEL_ULONG_PTR)pwnd - pci->ulClientDelta);
        return HWq(pwnd);
    }
    return NULL;
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetProgmanWindow, HWND, hwnd)
BOOL  SetProgmanWindow(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwndOpt(hwnd, SFI__SETPROGMANWINDOW);
}

HWND GetTaskmanWindow(void) {
    PCLIENTINFO pci;
    PWND pwnd;

    ConnectIfNecessary(0);

    pci = GetClientInfo();
    pwnd = pci->pDeskInfo->spwndTaskman;
    if (pwnd != NULL) {
        pwnd = (PWND)((KERNEL_ULONG_PTR)pwnd - pci->ulClientDelta);
        return HWq(pwnd);
    }
    return NULL;
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetTaskmanWindow, HWND, hwnd)
BOOL  SetTaskmanWindow(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwndOpt(hwnd, SFI__SETTASKMANWINDOW);
}

/**************************************************************************\
* SetWindowContextHelpId
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetWindowContextHelpId, HWND, hwnd, DWORD, id)
BOOL SetWindowContextHelpId(
    HWND hwnd,
    DWORD id)
{
    return (BOOL)NtUserCallHwndParam(hwnd, id, SFI__SETWINDOWCONTEXTHELPID);
}

/**************************************************************************\
* GetWindowContextHelpId
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetWindowContextHelpId, HWND, hwnd)
DWORD GetWindowContextHelpId(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwnd(hwnd, SFI__GETWINDOWCONTEXTHELPID);
}

void SetWindowState(
    PWND pwnd,
    UINT flags)
{
    if (TestWF(pwnd, flags) != LOBYTE(flags))
        NtUserCallHwndParam(HWq(pwnd), flags, SFI_SETWINDOWSTATE);
}

void ClearWindowState(
    PWND pwnd,
    UINT flags)
{
    if (TestWF(pwnd, flags))
        NtUserCallHwndParam(HWq(pwnd), flags, SFI_CLEARWINDOWSTATE);
}

/**************************************************************************\
* PostQuitMessage
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOGVOID1(LOG_GENERAL, DUMMYCALLINGTYPE, PostQuitMessage, int, nExitCode)
VOID PostQuitMessage(
    int nExitCode)
{
    NtUserCallOneParam(nExitCode, SFI__POSTQUITMESSAGE);
}

/**************************************************************************\
* REGISTERUSERHUNAPPHANDLERS
*
* 01-Apr-1992 jonpa    Created
\**************************************************************************/

BOOL RegisterUserHungAppHandlers(
    PFNW32ET pfnW32EndTask,
    HANDLE   hEventWowExec)
{
    return (BOOL)NtUserCallTwoParam((ULONG_PTR)pfnW32EndTask,
                                    (ULONG_PTR)hEventWowExec,
                                    SFI_XXXREGISTERUSERHUNGAPPHANDLERS);
}

/**************************************************************************\
* ReleaseCapture
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

BOOL ReleaseCapture()
{
    return (BOOL)NtUserCallNoParam(SFI_XXXRELEASECAPTURE);
}

/**************************************************************************\
* ReplyMessage
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ReplyMessage, LRESULT, pp1)
BOOL ReplyMessage(
    LRESULT pp1)
{
    return (BOOL)NtUserCallOneParam(pp1, SFI__REPLYMESSAGE);
}

/**************************************************************************\
* RegisterSystemThread
*
* 21-Jun-1994 johnc    Created
\**************************************************************************/


FUNCLOGVOID2(LOG_GENERAL, DUMMYCALLINGTYPE, RegisterSystemThread, DWORD, dwFlags, DWORD, dwReserved)
VOID RegisterSystemThread(
    DWORD dwFlags, DWORD dwReserved)
{
    NtUserCallTwoParam(dwFlags, dwReserved, SFI_ZZZREGISTERSYSTEMTHREAD);
}

/**************************************************************************\
* SetCaretBlinkTime
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetCaretBlinkTime, UINT, wMSeconds)
BOOL SetCaretBlinkTime(
    UINT wMSeconds)
{
    return (BOOL)NtUserCallOneParam(wMSeconds, SFI__SETCARETBLINKTIME);
}

/**************************************************************************\
* SetCaretPos
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetCaretPos, int, X, int, Y)
BOOL SetCaretPos(
    int X,
    int Y)
{
    return (BOOL)NtUserCallTwoParam(X, Y, SFI_ZZZSETCARETPOS);
}

/**************************************************************************\
* SetCursorPos
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetCursorPos, int, X, int, Y)
BOOL SetCursorPos(
    int X,
    int Y)
{
    return (BOOL)NtUserCallTwoParam(X, Y, SFI_ZZZSETCURSORPOS);
}

/**************************************************************************\
* SetDoubleClickTime
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetDoubleClickTime, UINT, cms)
BOOL SetDoubleClickTime(
    UINT cms)
{
    return (BOOL)NtUserCallOneParam(cms, SFI__SETDOUBLECLICKTIME);
}

/**************************************************************************\
* SetForegroundWindow
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetForegroundWindow, HWND, hwnd)
BOOL SetForegroundWindow(
    HWND hwnd)
{
    return NtUserSetForegroundWindow(hwnd);
}
/**************************************************************************\
* AllowSetForegroundWindow
*
* 28-Jan-1998 GerardoB    Created
\**************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, AllowSetForegroundWindow, DWORD, dwProcessId)
BOOL AllowSetForegroundWindow(
    DWORD dwProcessId)
{
    return (BOOL)NtUserCallOneParam(dwProcessId, SFI_XXXALLOWSETFOREGROUNDWINDOW);
}
/**************************************************************************\
* LockSetForegroundWindow
*
* 07-Apr-1998 GerardoB    Created
\**************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, LockSetForegroundWindow, UINT, uLockCode)
BOOL LockSetForegroundWindow(
    UINT uLockCode)
{
    return (BOOL)NtUserCallOneParam(uLockCode, SFI__LOCKSETFOREGROUNDWINDOW);
}

/**************************************************************************\
* ShowCursor
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, int, DUMMYCALLINGTYPE, ShowCursor, BOOL, bShow)
int ShowCursor(
    BOOL bShow)
{
    return (int)NtUserCallOneParam(bShow, SFI_ZZZSHOWCURSOR);
}

/**************************************************************************\
* ShowOwnedPopups
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ShowOwnedPopups, HWND, hwnd, BOOL, fShow)
BOOL ShowOwnedPopups(
    HWND hwnd,
    BOOL fShow)
{
    return (BOOL)NtUserCallHwndParamLock(hwnd, fShow,
                                         SFI_XXXSHOWOWNEDPOPUPS);
}

/**************************************************************************\
* ShowStartGlass
*
* 10-Sep-1992 scottlu    Created
\**************************************************************************/


FUNCLOGVOID1(LOG_GENERAL, DUMMYCALLINGTYPE, ShowStartGlass, DWORD, dwTimeout)
void ShowStartGlass(
    DWORD dwTimeout)
{
    NtUserCallOneParam(dwTimeout, SFI_ZZZSHOWSTARTGLASS);
}

/**************************************************************************\
* SwapMouseButton
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SwapMouseButton, BOOL, fSwap)
BOOL SwapMouseButton(
    BOOL fSwap)
{
    return (BOOL)NtUserCallOneParam(fSwap, SFI__SWAPMOUSEBUTTON);
}

/**************************************************************************\
* TileChildWindows
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, TileChildWindows, HWND, hwndParent, UINT, flags)
BOOL TileChildWindows(
    HWND hwndParent,
    UINT flags)
{
    return (BOOL)TileWindows(hwndParent, flags, NULL, 0, NULL);
}

/**************************************************************************\
* UnhookWindowsHook
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, UnhookWindowsHook, int, nCode, HOOKPROC, pfnFilterProc)
BOOL UnhookWindowsHook(
    int nCode,
    HOOKPROC pfnFilterProc)
{
    return (BOOL)NtUserCallTwoParam(nCode, (ULONG_PTR)pfnFilterProc,
                                    SFI_ZZZUNHOOKWINDOWSHOOK);
}

/**************************************************************************\
* UpdateWindow
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, UpdateWindow, HWND, hwnd)
BOOL UpdateWindow(
    HWND hwnd)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return FALSE;
    }

    /*
     * Don't need to do anything if this window does not need any painting
     * and it has no child windows
     */
    if (!NEEDSPAINT(pwnd) && (pwnd->spwndChild == NULL)) {
        return TRUE;
    }

    return (BOOL)NtUserCallHwndLock(hwnd, SFI_XXXUPDATEWINDOW);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, RegisterShellHookWindow, HWND, hwnd)
BOOL RegisterShellHookWindow(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwnd(hwnd, SFI__REGISTERSHELLHOOKWINDOW);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DeregisterShellHookWindow, HWND, hwnd)
BOOL DeregisterShellHookWindow(
    HWND hwnd)
{
    return (BOOL)NtUserCallHwnd(hwnd, SFI__DEREGISTERSHELLHOOKWINDOW);
}

/**************************************************************************\
* UserRealizePalette
*
* 13-Nov-1992 mikeke     Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, UserRealizePalette, HDC, hdc)
UINT UserRealizePalette(
    HDC hdc)
{
    return (UINT)NtUserCallOneParam((ULONG_PTR)hdc, SFI_XXXREALIZEPALETTE);
}

/**************************************************************************\
* WindowFromDC
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, WindowFromDC, HDC, hdc)
HWND WindowFromDC(
    HDC hdc)
{
    return (HWND)NtUserCallOneParam((ULONG_PTR)hdc, SFI__WINDOWFROMDC);
}

/***************************************************************************\
* GetWindowRgn
*
* Parameters:
*     hwnd    --  Window handle
*     hrgn    --  Region to copy window region into
*
* Returns:
*     Region complexity code
*
* Comments:
*     hrgn gets returned in window rect coordinates (not client rect)
*
* 30-JUl-1994 ScottLu    Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetWindowRgn, HWND, hwnd, HRGN, hrgn)
int GetWindowRgn(HWND hwnd, HRGN hrgn)
{
    int code;
    PWND pwnd;

    if (hrgn == NULL)
        return ERROR;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return ERROR;
    }

    /*
     * If there is no region selected into this window, then return error
     */
    if (pwnd->hrgnClip == NULL || TestWF(pwnd, WFMAXFAKEREGIONAL)) {
        return ERROR;
    }

    code = CombineRgn(hrgn, KHRGN_TO_HRGN(pwnd->hrgnClip), NULL, RGN_COPY);

    if (code == ERROR)
        return ERROR;

    /*
     * Offset it to window rect coordinates (not client rect coordinates)
     */
    if (GETFNID(pwnd) != FNID_DESKTOP) {
        code = OffsetRgn(hrgn, -pwnd->rcWindow.left, -pwnd->rcWindow.top);
    }

    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        MirrorRgn(HW(pwnd), hrgn);
    }

    return code;
}

/***************************************************************************\
* GetWindowRgnBox
*
* Parameters:
*     hwnd    --  Window handle
*     lprc    --  Rectangle for bounding box
*
* Returns:
*     Region complexity code
*
* Comments:
*     This function is designed after GetWindowRgn(), but does not require
*     an HRGN to be passed in since it only returns the complexity code.
*
* 06-JUN-2000 JStall    Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetWindowRgnBox, HWND, hwnd, LPRECT, lprc)
int GetWindowRgnBox(HWND hwnd, LPRECT lprc)
{
    int code;
    PWND pwnd;

    if (lprc == NULL)
        return ERROR;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return ERROR;
    }

    /*
     * If there is no region selected into this window, then return error
     */
    if (pwnd->hrgnClip == NULL || TestWF(pwnd, WFMAXFAKEREGIONAL)) {
        return ERROR;
    }

    code = GetRgnBox(KHRGN_TO_HRGN(pwnd->hrgnClip), lprc);

    if (code == ERROR)
        return ERROR;

    /*
     * Offset it to window rect coordinates (not client rect coordinates)
     */
    if (GETFNID(pwnd) != FNID_DESKTOP) {
        OffsetRect(lprc, -pwnd->rcWindow.left, -pwnd->rcWindow.top);
    }

    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        MirrorWindowRect(pwnd, lprc);
    }

    return code;
}

/***************************************************************************\
* GetActiveKeyboardName
*
* Retrieves the active keyboard layout ID from the registry.
*
* 01-11-95 JimA         Created.
* 03-06-95 GregoryW     Modified to use new registry layout
\***************************************************************************/

VOID GetActiveKeyboardName(
    LPWSTR lpszName)
{
    LPTSTR szKbdActive = TEXT("Active");
    LPTSTR szKbdLayout = TEXT("Keyboard Layout");
    LPTSTR szKbdLayoutPreload = TEXT("Keyboard Layout\\Preload");
    NTSTATUS rc;
    DWORD cbSize;
    HANDLE UserKeyHandle, hKey, hKeyPreload;
    OBJECT_ATTRIBUTES ObjA;
    UNICODE_STRING UnicodeString;
    ULONG CreateDisposition;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        WCHAR KeyLayoutId[KL_NAMELENGTH];
    } KeyValueId;

    /*
     * Load initial keyboard name ( HKEY_CURRENT_USER\Keyboard Layout\Preload\1 )
     */
    rc = RtlOpenCurrentUser( MAXIMUM_ALLOWED, &UserKeyHandle );
    if (!NT_SUCCESS( rc ))
    {
        RIPMSG1( RIP_WARNING, "GetActiveKeyboardName - Could NOT open HKEY_CURRENT_USER (%lx).\n", rc );
        wcscpy( lpszName, L"00000409" );
        return;
    }

    RtlInitUnicodeString( &UnicodeString, szKbdLayoutPreload );
    InitializeObjectAttributes( &ObjA,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                UserKeyHandle,
                                NULL );
    rc = NtOpenKey( &hKey,
                    KEY_ALL_ACCESS,
                    &ObjA );
    if (NT_SUCCESS( rc ))
    {
        /*
         *  Query the value from the registry.
         */
        RtlInitUnicodeString( &UnicodeString, L"1" );

        rc = NtQueryValueKey( hKey,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              &KeyValueId,
                              sizeof(KeyValueId),
                              &cbSize );

        if ( rc == STATUS_BUFFER_OVERFLOW ) {
            RIPMSG0(RIP_WARNING, "GetActiveKeyboardName - Buffer overflow.");
            rc = STATUS_SUCCESS;
        }
        if (NT_SUCCESS( rc )) {
            wcsncpycch( lpszName, (LPWSTR)KeyValueId.KeyInfo.Data, KL_NAMELENGTH - 1 );
            lpszName[KL_NAMELENGTH - 1] = L'\0';
        } else {
            /*
             * Error reading value...use default
             */
            wcscpy( lpszName, L"00000409" );
        }

        NtClose( hKey );
        NtClose( UserKeyHandle );
        if (IS_IME_ENABLED()) {
            CheckValidLayoutName( lpszName );
        }
        return;
    }

    /*
     * NOTE: The code below is only executed the first time a user logs
     *       on after an upgrade from NT3.x to NT4.0.
     */
    /*
     * The Preload key does not exist in the registry.  Try reading the
     * old registry entry "Keyboard Layout\Active".  If it exists, we
     * convert it to the new style Preload key.
     */
    RtlInitUnicodeString( &UnicodeString, szKbdLayout );
    InitializeObjectAttributes( &ObjA,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                UserKeyHandle,
                                NULL );
    rc = NtOpenKey( &hKey,
                    KEY_ALL_ACCESS,
                    &ObjA );

    NtClose( UserKeyHandle );

    if (!NT_SUCCESS( rc ))
    {
        RIPMSG1( RIP_WARNING, "GetActiveKeyboardName - Could not determine active keyboard layout (%lx).\n", rc  );
        wcscpy( lpszName, L"00000409" );
        return;
    }

    /*
     *  Query the value from the registry.
     */
    RtlInitUnicodeString( &UnicodeString, szKbdActive );

    rc = NtQueryValueKey( hKey,
                          &UnicodeString,
                          KeyValuePartialInformation,
                          &KeyValueId,
                          sizeof(KeyValueId),
                          &cbSize );

    if ( rc == STATUS_BUFFER_OVERFLOW ) {
        RIPMSG0(RIP_WARNING, "GetActiveKeyboardName - Buffer overflow.");
        rc = STATUS_SUCCESS;
    }
    if (NT_SUCCESS( rc )) {
        wcsncpycch( lpszName, (LPWSTR)KeyValueId.KeyInfo.Data, KL_NAMELENGTH - 1 );
        lpszName[KL_NAMELENGTH - 1] = L'\0';
    } else {
        /*
         * Error reading value...use default
         */
        RIPMSG1( RIP_WARNING, "GetActiveKeyboardName - Could not query active keyboard layout (%lx).\n", rc );
        wcscpy( lpszName, L"00000409" );
        NtClose( hKey );
        return;
    }

    /*
     * if 'Active' keyboard layout is for Japanese/Korean layout. just put
     * IME prefix, because user prefer to have keyboard layout with IME as
     * default.
     */
    if (IS_IME_ENABLED()) {
        UINT wLanguageId = (UINT)wcstoul(lpszName, NULL, 16);

        /*
         * Default keyboard layout values.
         *
         * [LATER, if needed]
         *
         * The hard-codeed default value might be wanted
         * come from registry or somewhere...
         */
        CONST LPWSTR lpszJapaneseDefaultLayout = L"E0010411";
        CONST LPWSTR lpszKoreanDefaultLayout   = L"E0010412";

        /*
         * Need to mask off hi-word to look up locale ID, because
         * NEC PC-9800 Series version of Windows NT 3.5 contains
         * bogus value in hi-word.
         */
        wLanguageId &= 0x0000FFFF;

        if (PRIMARYLANGID(wLanguageId) == LANG_JAPANESE) {

            /*
             * Set Japanese default layout Id.
             */
            wcscpy(lpszName,lpszJapaneseDefaultLayout);

        } else if (PRIMARYLANGID(wLanguageId) == LANG_KOREAN) {

            /*
             * Set Korean default layout Id.
             */
            wcscpy(lpszName,lpszKoreanDefaultLayout);
        }
    }

    /*
     * We have the Active value.  Now create the Preload key.
     */
    RtlInitUnicodeString( &UnicodeString, L"Preload" );
    InitializeObjectAttributes( &ObjA,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                hKey,
                                NULL );
    rc = NtCreateKey( &hKeyPreload,
                      STANDARD_RIGHTS_WRITE |
                        KEY_QUERY_VALUE |
                        KEY_ENUMERATE_SUB_KEYS |
                        KEY_SET_VALUE |
                        KEY_CREATE_SUB_KEY,
                      &ObjA,
                      0,
                      NULL,
                      0,
                      &CreateDisposition );

    if (!NT_SUCCESS( rc ))
    {
        RIPMSG1( RIP_WARNING, "GetActiveKeyboardName - Could NOT create Preload key (%lx).\n", rc );
        NtClose( hKey );
        return;
    }

    /*
     * Set the new value entry.
     */
    RtlInitUnicodeString( &UnicodeString, L"1" );
    rc = NtSetValueKey( hKeyPreload,
                        &UnicodeString,
                        0,
                        REG_SZ,
                        lpszName,
                        (wcslen(lpszName)+1) * sizeof(WCHAR)
                      );

    if (!NT_SUCCESS( rc ))
    {
        RIPMSG1( RIP_WARNING, "GetActiveKeyboardName - Could NOT create value entry 1 for Preload key (%lx).\n", rc );
        NtClose( hKey );
        NtClose( hKeyPreload );
        return;
    }

    /*
     * Success: attempt to delete the Active value key.
     */
    RtlInitUnicodeString( &UnicodeString, szKbdActive );
    rc = NtDeleteValueKey( hKey, &UnicodeString );

    if (!NT_SUCCESS( rc ))
    {
        RIPMSG1( RIP_WARNING, "GetActiveKeyboardName - Could NOT delete value key 'Active'.\n", rc );
    }
    NtClose( hKey );
    NtClose( hKeyPreload );
}


/***************************************************************************\
* LoadPreloadKeyboardLayouts
*
* Loads the keyboard layouts stored under the Preload key in the user's
* registry. The first layout, the default, was already loaded.  Start with #2.
*
* 03-06-95 GregoryW     Created.
\***************************************************************************/

// size allows up to 999 preloaded!!!!!
#define NSIZEPRELOAD    (4)

VOID LoadPreloadKeyboardLayouts(void)
{
    UINT  i;
    WCHAR szPreLoadee[NSIZEPRELOAD];
    WCHAR lpszName[KL_NAMELENGTH];

    if (!ISREMOTESESSION()) {
        /*
         * Console doesn't have a client layout, so start from 2.
         */
        i = 2;
    } else {
        /*
         * Client might have specified a keyboard layout, if this
         * is so, then Preload\1 was not loaded, so start from 1.
         */
        i = 1;
    }

    for (; i < 1000; i++) {
        wsprintf(szPreLoadee, L"%d", i );
        if ((GetPrivateProfileStringW(
                 L"Preload",
                 szPreLoadee,
                 L"",                            // default = NULL
                 lpszName,                       // output buffer
                 KL_NAMELENGTH,
                 L"keyboardlayout.ini") == -1 ) || (*lpszName == L'\0')) {
            break;
        }
        LoadKeyboardLayoutW(lpszName, KLF_REPLACELANG |KLF_SUBSTITUTE_OK |KLF_NOTELLSHELL);
    }
}


LPWSTR GetKeyboardDllName1(
    LPWSTR pwszLibIn,
    LPWSTR pszKLName,
    PUINT puFlags,
    PUINT pKbdInputLocale)
{
    NTSTATUS Status;
    WCHAR awchKL[KL_NAMELENGTH];
    WCHAR awchKLRegKey[NSZKLKEY];
    LPWSTR lpszKLRegKey = &awchKLRegKey[0];
    LPWSTR pwszLib;
    LPWSTR pwszId;
    UINT wLayoutId;
    UINT wLanguageId;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES OA;
    HANDLE hKey;
    DWORD cbSize;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        WCHAR awchLibName[CCH_KL_LIBNAME];
    } KeyFile;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        WCHAR awchId[CCH_KL_ID];
    } KeyId;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        DWORD Attributes;
    } KeyAttributes;

    if (pszKLName == NULL) {
        return NULL;
    }

    wLanguageId = (UINT)wcstoul(pszKLName, NULL, 16);
    /*
     * Substitute Layout if required.
     */
    if (*puFlags & KLF_SUBSTITUTE_OK) {
        GetPrivateProfileStringW(
                L"Substitutes",
                pszKLName,
                pszKLName,        // default == no change (no substitute found)
                awchKL,
                sizeof(awchKL)/sizeof(WCHAR),
                L"keyboardlayout.ini");

        /*
         * #273562 : Flush the registry cache, because the cpanel applet
         * destroys and recreates the Substitutes section a lot, which
         * would otherwise leave us with STATUS_KEY_DELETED.
         */
        WritePrivateProfileStringW(NULL, NULL, NULL, NULL);

        awchKL[KL_NAMELENGTH - 1] = L'\0';
        wcscpy(pszKLName, awchKL);
    }

    wLayoutId = (UINT)wcstoul(pszKLName, NULL, 16);

    /*
     * Get DLL name from the registry, load it, and get the entry point.
     */
    pwszLib = NULL;
    wcscpy(lpszKLRegKey, szKLKey);
    wcscat(lpszKLRegKey, pszKLName);
    RtlInitUnicodeString(&UnicodeString, lpszKLRegKey);
    InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &OA))) {
        /*
         * Read the "Layout File" value.
         */
        RtlInitUnicodeString(&UnicodeString, szKLFile);

        Status = NtQueryValueKey(hKey,
                &UnicodeString,
                KeyValuePartialInformation,
                &KeyFile,
                sizeof(KeyFile),
                &cbSize);

        if (Status == STATUS_BUFFER_OVERFLOW) {
            RIPMSG0(RIP_WARNING, "GetKeyboardDllName (Layout File) - Buffer overflow.");
            Status = STATUS_SUCCESS;
        }
        if (NT_SUCCESS(Status)) {
            pwszLib = (LPWSTR)KeyFile.KeyInfo.Data;
            pwszLib[CCH_KL_LIBNAME - 1] = L'\0';

        } else {
            RIPMSG1(RIP_WARNING, "GetKeyboardDllName: failed to get the DLL name for %ws", pszKLName);
        }

        RtlInitUnicodeString(&UnicodeString, szKLAttributes);
        Status = NtQueryValueKey(hKey,
                &UnicodeString,
                KeyValuePartialInformation,
                &KeyAttributes,
                sizeof(KeyAttributes),
                &cbSize);

        if (NT_SUCCESS(Status)) {
#if DBG
            if ((*((PDWORD)KeyAttributes.KeyInfo.Data) & ~KLF_ATTRMASK) != 0) {
                RIPMSG1(RIP_WARNING,
                        "GetKeyboardDllName - Unexpected attributes %lx",
                        *((PDWORD)KeyAttributes.KeyInfo.Data));
            }
#endif
            *puFlags |= (*(PDWORD)KeyAttributes.KeyInfo.Data & KLF_ATTRMASK);
        }

        /*
         * If the high word of wLayoutId is 0xE??? then this is an IME based
         * keyboard layout.
         */
        if (IS_IME_KBDLAYOUT(wLayoutId)) {
            wLayoutId = (UINT)HIWORD(wLayoutId);
        } else if (HIWORD(wLayoutId)) {
            /*
             * If the high word of wLayoutId is non-null then read the "Layout ID" value.
             * Layout IDs start at 1, increase sequentially and are unique.
             */
            RtlInitUnicodeString(&UnicodeString, szKLId);

            Status = NtQueryValueKey(hKey,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    &KeyId,
                    sizeof(KeyId),
                    &cbSize);

            if (Status == STATUS_BUFFER_OVERFLOW) {
                RIPMSG0(RIP_WARNING, "GetKeyboardDllName - Buffer overflow.");
                Status = STATUS_SUCCESS;
            }
            if (NT_SUCCESS(Status)) {
                pwszId = (LPWSTR)KeyId.KeyInfo.Data;
                pwszId[CCH_KL_ID - 1] = L'\0';
                wLayoutId = (wcstol(pwszId, NULL, 16) & 0x0fff) | 0xf000;
            } else {
                wLayoutId = (UINT)0xfffe ;    // error in layout ID, load separately
            }
        }
        NtClose(hKey);
    } else {
        /*
         * This is a temporary case to allow booting the new multilingual user on top of a
         * Daytona registry.
         */
        /*
         * Get DLL name from the registry, load it, and get the entry point.
         */
        pwszLib = NULL;
        RtlInitUnicodeString(&UnicodeString,
                L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Keyboard Layout");
        InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

        if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &OA))) {
            RtlInitUnicodeString(&UnicodeString, pszKLName);

            Status = NtQueryValueKey(hKey,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    &KeyFile,
                    sizeof(KeyFile),
                    &cbSize);

            if (Status == STATUS_BUFFER_OVERFLOW) {
                RIPMSG0(RIP_WARNING, "GetKeyboardDllName - Buffer overflow.");
                Status = STATUS_SUCCESS;
            }
            if (NT_SUCCESS(Status)) {
                pwszLib = (LPWSTR)KeyFile.KeyInfo.Data;
                pwszLib[CCH_KL_LIBNAME - 1] = L'\0';
            }

            NtClose(hKey);
        }

        if (pwszLib == NULL) {
            RIPMSG1(RIP_WARNING, "GetKeyboardDllName: daytona: failed to get the library name for %ws", pszKLName);
        }
    }

    *pKbdInputLocale = (UINT)MAKELONG(LOWORD(wLanguageId),LOWORD(wLayoutId));

    if (pwszLib == NULL) {
        if (ISREMOTESESSION() && IS_IME_KBDLAYOUT(wLayoutId)) {
            /*
             * -- port from HYDRA --
             * Could not find the keyboard KL for FE, so give them some reasonable one.
             * If the high word of wLayoutId is 0xE??? then this is an IME based
             * keyboard layout.
             * And, the safe KL name is KBDJPN.DLL for Japanese.
             *                       or KBDKOR.DLL for Korean
             *                       or KBDUS.DLL  for other Far East
             */
            if (PRIMARYLANGID(wLanguageId) == LANG_JAPANESE) {
                pwszLib = pwszKLLibSafetyJPN;
                *pKbdInputLocale = wKbdLocaleSafetyJPN;
            }
            else if (PRIMARYLANGID(wLanguageId) == LANG_KOREAN) {
                pwszLib = pwszKLLibSafetyKOR;
                *pKbdInputLocale = wKbdLocaleSafetyKOR;
            }
            else {
                pwszLib = pwszKLLibSafety;
                *pKbdInputLocale = MAKELONG(LOWORD(wLanguageId), LOWORD(wLanguageId));
            }
        }
        else if (*puFlags & KLF_INITTIME) {
            pwszLib = pwszKLLibSafety;
            *pKbdInputLocale = wKbdLocaleSafety;
        } else {
            RIPMSG1(RIP_WARNING, "no DLL name for %ws", pszKLName);
            /*
             * We're going to use the fallback layout...
             * This could happen when IMM32 is trying to unload the IME,
             * by making any non IME keyboard layout tentatively active.
             */
            pwszLib = pwszKLLibSafety;
            *pKbdInputLocale = wKbdLocaleSafety;
        }
    }

    if (pwszLib) {
        wcscpy(pwszLibIn, pwszLib);
        pwszLib = pwszLibIn;
    }
    return pwszLib;
}


/***************************************************************************\
* OpenKeyboardLayoutFile
*
* Opens a layout file and computes the table offset.
*
* 01-11-95 JimA         Moved LoadLibrary code from server.
\***************************************************************************/


HANDLE OpenKeyboardLayoutFileWorker(
    LPWSTR pwszLib,
    LPWSTR lpszKLName,
    CONST UINT* puFlags,
    PUINT poffTable,
    OUT OPTIONAL PKBDTABLE_MULTI_INTERNAL pKbdTableMultiIn)
{
    WCHAR awchRealLayoutFile[MAX_PATH];
    HANDLE hLibModule, hLibMulti = NULL;
    WCHAR awchModName[MAX_PATH];

    PKBDTABLES (*pfn)(void);            // @1
    PKBDNLSTABLES (* pfnNls)(void);     // @2
    BOOL (*pfnLayerNT4)(LPWSTR);        // @3
    BOOL (*pfnLayer)(HKL, LPWSTR, PCLIENTKEYBOARDTYPE, LPVOID);  // @5
    BOOL (*pfnMulti)(PKBDTABLE_MULTI);  // @6

    TAGMSG1(DBGTAG_KBD, "OpenKeyboardLayoutFileWorker: opening '%S'", pwszLib);

RetryLoad:
    hLibModule = LoadLibraryW(pwszLib);

    if (hLibModule == NULL) {
        RIPMSG1(RIP_WARNING, "Keyboard Layout: cannot load %ws\n", pwszLib);
        /*
         * It is OK to fail to load DLL here:
         * if this ever happens, the fallback keyboard layout built in
         * win32k.sys shall be used.
         */
        return NULL;
    }

    if (pwszLib != pwszKLLibSafety) {
        /*
         * if the layout driver is not "REAL" layout driver, the driver has
         * "3" or "5" entry point, then we call this to get real layout driver..
         * This is neccesary for Japanese and Korean systems. because their
         * keyboard layout driver is "KBDJPN.DLL" or "KBDKOR.DLL", but its
         * "REAL" driver becomes different depending their keyboard hardware.
         */

        /*
         * Get the entrypoints.
         */
        pfnLayerNT4 = (BOOL(*)(LPWSTR))GetProcAddress(hLibModule, (LPCSTR)3);
        pfnLayer  = (BOOL(*)(HKL, LPWSTR, PCLIENTKEYBOARDTYPE, LPVOID))GetProcAddress(hLibModule, (LPCSTR)5);

        if (pKbdTableMultiIn && !ISREMOTESESSION()) {
            pfnMulti = (BOOL(*)(PKBDTABLE_MULTI))GetProcAddress(hLibModule, (LPCSTR)6);
        } else {
            pfnMulti = NULL;
        }

        /*
         * Firstly check if multiple layout is included.
         * This needs to be done before the dll name is redirected to
         * the real one (if layered).
         */
        if (pfnMulti) {
            UserAssert(pKbdTableMultiIn);
            UserAssert(!ISREMOTESESSION());

            if (pfnMulti(&pKbdTableMultiIn->multi)) {
                UINT i;

                /*
                 * Do multi layout stuff only if the layout dll returns
                 * a legitimate result.
                 */
                if (pKbdTableMultiIn->multi.nTables < KBDTABLE_MULTI_MAX) {
                    for (i = 0; i < pKbdTableMultiIn->multi.nTables; ++i) {
                        UINT uiOffset;

                        TAGMSG2(DBGTAG_KBD | RIP_THERESMORE, "OpenKeyboardLayoutFileWorker: opening %d, %S", i, pKbdTableMultiIn->multi.aKbdTables[i].wszDllName);

                        UserAssert(i < KBDTABLE_MULTI_MAX);

                        pKbdTableMultiIn->files[i].hFile = OpenKeyboardLayoutFileWorker(pKbdTableMultiIn->multi.aKbdTables[i].wszDllName,
                                                                                        NULL,
                                                                                        puFlags,
                                                                                        &uiOffset,
                                                                                        NULL);
                        TAGMSG1(DBGTAG_KBD, "hFile = %p", pKbdTableMultiIn->files[i].hFile);
                        if (pKbdTableMultiIn->files[i].hFile) {
                            pKbdTableMultiIn->files[i].wTable = LOWORD(uiOffset);
                            pKbdTableMultiIn->files[i].wNls = HIWORD(uiOffset);
                        }
                    }
                } else {
                    pKbdTableMultiIn->multi.nTables = 0;
                    RIPMSG2(RIP_ERROR, "OpenKeyboardLayoutFileWorker: KL=%S returned bogus nTables=%x",
                            lpszKLName, pKbdTableMultiIn->multi.nTables);
                }
            }
        }

        /*
         * If there are private entries, call them.
         */
        if (pfnLayer || pfnLayerNT4) {
            HKL hkl;
            UNICODE_STRING UnicodeString;
            CLIENTKEYBOARDTYPE clientKbdType;
            PCLIENTKEYBOARDTYPE pClientKbdType = NULL;

            UserAssert(lpszKLName);

            RtlInitUnicodeString(&UnicodeString, lpszKLName);
            RtlUnicodeStringToInteger(&UnicodeString, 0x10, (PULONG)&hkl);

            /*
             * When we reach here, the layout DLL may have KBDNLSTABLE
             * even if we fail from now on. Our temporary layout
             * dll should have the fallback tables for just in case.
             */

            if (ISREMOTESESSION() && GetClientKeyboardType(&clientKbdType)) {
                pClientKbdType = &clientKbdType;
            }

            /*
             * Call the entry.
             * a. NT5 / Hydra (oridinal=5)
             * b. NT4 compatible (3)
             */
            if ((pfnLayer && pfnLayer(hkl, awchRealLayoutFile, pClientKbdType, NULL)) ||
                    (pfnLayerNT4 && pfnLayerNT4(awchRealLayoutFile))) {

                HANDLE hLibModuleNew;
                /*
                 * Try to load "REAL" keyboard layout file.
                 */
                TAGMSG1(DBGTAG_KBD, "awchRealLayoutFile='%S'\n", awchRealLayoutFile);
                if (hLibModuleNew = LoadLibraryW(awchRealLayoutFile)) {
                    /*
                     * Set "REAL" layout file name.
                     */
                    pwszLib = awchRealLayoutFile;
                    /*
                     * Unload temporary layout driver.
                     */
                    FreeLibrary(hLibModule);
                    /*
                     * Updates it.
                     */
                    hLibModule = hLibModuleNew;
                }
            }
        }
    }

    /*
     * HACK Part 1!  Get the pointer to the layout table and
     * change it to a virtual offset.  The server will then
     * use this offset when poking through the file header to
     * locate the table within the file.
     */
    pfn = (PKBDTABLES(*)(void))GetProcAddress(hLibModule, (LPCSTR)1);
    if (pfn == NULL) {
        RIPMSG0(RIP_ERROR, "OpenKeyboardLayoutFileWorker: cannot get proc addr of '1'");
        if (pKbdTableMultiIn) {
            /*
             * Main load somehow failed. Need to clean up
             * the dynamic layout switching stuff.
             */
            UINT i;

            RIPMSG0(RIP_WARNING, "OpenKeyboardLayoutFileWorker: multi table exists, cleaning up");

            for (i = 0; i < pKbdTableMultiIn->multi.nTables && i < KBDTABLE_MULTI_MAX; ++i) {
                if (pKbdTableMultiIn->files[i].hFile) {
                    NtClose(pKbdTableMultiIn->files[i].hFile);
                    pKbdTableMultiIn->files[i].hFile = NULL;
                }
            }
            pKbdTableMultiIn->multi.nTables = 0;
        }
        if ((*puFlags & KLF_INITTIME) && (pwszLib != pwszKLLibSafety)) {
            pwszLib = pwszKLLibSafety;
            goto RetryLoad;
        }
        return NULL;
    }
    *poffTable = (UINT)((PBYTE)pfn() - (PBYTE)hLibModule);

    if (pKbdTableMultiIn) {
        /*
         * Save the toplevel Dll name
         */
        lstrcpyn(pKbdTableMultiIn->wszDllName, pwszLib, ARRAY_SIZE(pKbdTableMultiIn->wszDllName));
        pKbdTableMultiIn->wszDllName[ARRAY_SIZE(pKbdTableMultiIn->wszDllName) - 1] = 0;
        TAGMSG1(DBGTAG_KBD, "OpenKeyboardLayoutFile: the real DllName is '%ls'", pKbdTableMultiIn->wszDllName);
    }

    pfnNls = (PKBDNLSTABLES(*)(void))GetProcAddress(hLibModule, (LPCSTR)2);
    if (pfnNls != NULL) {
        UINT offNlsTable;

        offNlsTable = (UINT)((PBYTE)pfnNls() - (PBYTE)hLibModule);

        TAGMSG2(DBGTAG_KBD | RIP_THERESMORE, "OpenKeyboardLayoutFile: Offset to KBDTABLES    = %d (%x)\n", *poffTable, *poffTable);
        TAGMSG2(DBGTAG_KBD, "OpenKeyboardLayoutFile: Offset to KBDNLSTABLES = %d (%x)\n", offNlsTable, offNlsTable);

        /*
         * Combine these offsets...
         *
         *  LOWORD(*poffTable) = Offset to KBDTABLES.
         *  HIWORD(*poffTable) = Offset to KBDNLSTABLES.
         */
        *poffTable |= (offNlsTable << 16);
    }

    /*
     * Open the dll for read access.
     */
    GetModuleFileName(hLibModule, awchModName, ARRAY_SIZE(awchModName));
    FreeLibrary(hLibModule);

    return CreateFileW(
            awchModName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL);
}

HANDLE OpenKeyboardLayoutFile(
    LPWSTR lpszKLName,
    PUINT puFlags,
    PUINT poffTable,
    PUINT pKbdInputLocale,
    OUT OPTIONAL PKBDTABLE_MULTI_INTERNAL pKbdTableMultiIn)
{
    LPWSTR pwszLib;
    WCHAR awchModName[MAX_PATH];

    if (pKbdTableMultiIn) {
        RtlZeroMemory(pKbdTableMultiIn, sizeof(*pKbdTableMultiIn));
    }

    pwszLib = GetKeyboardDllName1(awchModName, lpszKLName, puFlags, pKbdInputLocale);
    if (pwszLib == NULL) {
        return NULL;
    }

    TAGMSG0(DBGTAG_KBD, "=================");
    TAGMSG1(DBGTAG_KBD, "OpenKeyboardLayoutFile: loading '%S'", lpszKLName);

    return OpenKeyboardLayoutFileWorker(pwszLib, lpszKLName, puFlags, poffTable, pKbdTableMultiIn);
}


/***************************************************************************\
* LoadKeyboardLayoutEx
*
* Loads a keyboard translation table from a dll, replacing the layout associated
* with hkl.  This routine is needed to provide Win95 compatibility.
*
* 10-27-95 GregoryW    Created.
\***************************************************************************/

HKL LoadKeyboardLayoutWorker(
    HKL hkl,
    LPCWSTR lpszKLName,
    UINT uFlags,
    BOOL fFailSafe)
{
    UINT offTable;
    KBDTABLE_MULTI_INTERNAL kbdTableMulti;
    UINT i;
    UINT KbdInputLocale;
    HANDLE hFile;
    HKL hKbdLayout;
    WCHAR awchKL[KL_NAMELENGTH];

    TAGMSG1(DBGTAG_KBD, "LoadKeyboardLayoutWorker called with KLNAME=%S", lpszKLName);

    /*
     * If there is a substitute keyboard layout OpenKeyboardLayoutFile returns
     * the substitute keyboard layout name to load.
     */
    wcsncpy(awchKL, lpszKLName, KL_NAMELENGTH - 1);
    awchKL[KL_NAMELENGTH - 1] = L'\0';

    /*
     * Open the layout file
     */
    hFile = OpenKeyboardLayoutFile(awchKL, &uFlags, &offTable, &KbdInputLocale, &kbdTableMulti);
    if (hFile == NULL) {
        RIPMSG1(RIP_WARNING, "LoadKeyboardLayoutWorker: couldn't open layout file for '%S'", awchKL);
        if (!fFailSafe && (uFlags & KLF_FAILSAFE) == 0) {
            // If not fail safe mode, just bail to fail.
            return NULL;
        }
        uFlags &= ~KLF_SUBSTITUTE_OK;
        /*
         * If the first attempt fails, we should not try to setup the dynamic switching.
         */
        kbdTableMulti.multi.nTables = 0;
        if (wcscmp(awchKL, L"00000409")) {
            wcscpy(awchKL, L"00000409");
            hFile = OpenKeyboardLayoutFile(awchKL, &uFlags, &offTable, &KbdInputLocale, NULL);
        }
    }

    /*
     * Call the server to read the keyboard tables.  Note that
     * the server will close the file handle when it is done.
     */
    hKbdLayout = _LoadKeyboardLayoutEx(hFile, offTable,
                                       &kbdTableMulti,
                                       hkl, awchKL, KbdInputLocale, uFlags);
    NtClose(hFile);

    /*
     * Free opened files for dynamic layout switching.
     */
    for (i = 0; i < kbdTableMulti.multi.nTables && i < KBDTABLE_MULTI_MAX; ++i) {
        if (kbdTableMulti.files[i].hFile) {
            NtClose(kbdTableMulti.files[i].hFile);
        }
    }

    CliImmInitializeHotKeys(ISHK_ADD, (HKL)IntToPtr( KbdInputLocale ));

    return hKbdLayout;
}


FUNCLOG3(LOG_GENERAL, HKL, DUMMYCALLINGTYPE, LoadKeyboardLayoutEx, HKL, hkl, LPCWSTR, lpszKLName, UINT, uFlags)
HKL LoadKeyboardLayoutEx(
    HKL hkl,
    LPCWSTR lpszKLName,
    UINT uFlags)
{
    RIPMSG0(RIP_WARNING, "LoadKeyboardLayoutEx is called.");
    /*
     * NULL hkl is not allowed.
     */
    if (hkl == (HKL)NULL) {
        return NULL;
    }

    return LoadKeyboardLayoutWorker(hkl, lpszKLName, uFlags, FALSE);
}

/***************************************************************************\
* LoadKeyboardLayout
*
* Loads a keyboard translation table from a dll.
*
* 01-09-95 JimA         Moved LoadLibrary code from server.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HKL, DUMMYCALLINGTYPE, LoadKeyboardLayoutW, LPCWSTR, lpszKLName, UINT, uFlags)
HKL LoadKeyboardLayoutW(
    LPCWSTR lpszKLName,
    UINT uFlags)
{
    return LoadKeyboardLayoutWorker(NULL, lpszKLName, uFlags, FALSE);
}


FUNCLOG2(LOG_GENERAL, HKL, DUMMYCALLINGTYPE, LoadKeyboardLayoutA, LPCSTR, lpszKLName, UINT, uFlags)
HKL LoadKeyboardLayoutA(
    LPCSTR lpszKLName,
    UINT uFlags)
{
    WCHAR awchKLName[MAX_PATH];
    LPWSTR lpBuffer = awchKLName;

    if (!MBToWCS(lpszKLName, -1, &lpBuffer, sizeof(awchKLName), FALSE))
        return (HKL)NULL;

    return LoadKeyboardLayoutW(awchKLName, uFlags);
}

BOOL UnloadKeyboardLayout(IN HKL hkl)
{
    BOOL fRet = NtUserUnloadKeyboardLayout(hkl);

    if (fRet) {
        CliImmInitializeHotKeys(ISHK_REMOVE, hkl);
        return TRUE;
    }

    return FALSE;
}


/**************************************************************************\
* GetKeyboardLayout()
*
* 01-17-95 GregoryW     Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, HKL, DUMMYCALLINGTYPE, GetKeyboardLayout, DWORD, idThread)
HKL GetKeyboardLayout(
    DWORD idThread)
{
    return (HKL)NtUserCallOneParam(idThread, SFI__GETKEYBOARDLAYOUT);
}



FUNCLOGVOID1(LOG_GENERAL, DUMMYCALLINGTYPE, SetDebugErrorLevel, DWORD, dwLevel)
VOID SetDebugErrorLevel(DWORD dwLevel)
{
    UNREFERENCED_PARAMETER(dwLevel);
//    NtUserCallNoParam(SFI__SETDEBUGERRORLEVEL);
    return;
}

VOID CheckValidLayoutName( LPWSTR lpszKLName )
{
    UINT wLayoutId;
    WCHAR awchKLRegKey[NSZKLKEY];
    LPWSTR lpszKLRegKey = &awchKLRegKey[0];
    OBJECT_ATTRIBUTES OA;
    HANDLE hKey;
    UNICODE_STRING UnicodeString;

    UserAssert(IS_IME_ENABLED());

    wLayoutId = (UINT)wcstoul(lpszKLName, NULL, 16);

    if (IS_IME_KBDLAYOUT(wLayoutId)) {
    //
    // if it's an IME layout, we need to check if
    // the layout name does exist in the HKEY_LOCAL_MACHINE.
    // if we've upgraded from NT 3.51 the corresponding
    // entry might be lost, because those process-type IMEs that
    // are supported on NT 3.51 are not supported NT 4.0 any more.
    //
        wcscpy(lpszKLRegKey, szKLKey);
        wcscat(lpszKLRegKey, lpszKLName);
        RtlInitUnicodeString(&UnicodeString, lpszKLRegKey);
        InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

        if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &OA))) {
            NtClose( hKey );
        } else {
            // quick'n dirty way to make the fallback name...
            lpszKLName[0] = lpszKLName[1] = lpszKLName[2] = lpszKLName[3] = L'0';
#ifdef LATER
            // display a message box to warn user
#endif
        }
    }
}

/**************************************************************************\
* GetProcessDefaultLayout
*
* 22-Jan-1998 SamerA    Created
\**************************************************************************/

BOOL WINAPI GetProcessDefaultLayout(DWORD *pdwDefaultLayout)
{
    return (BOOL)NtUserCallOneParam((ULONG_PTR)pdwDefaultLayout,
                                    SFI__GETPROCESSDEFAULTLAYOUT);
}

/**************************************************************************\
* SetProcessDefaultLayout
*
* 22-Jan-1998 SamerA    Created
\**************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, SetProcessDefaultLayout, DWORD, dwDefaultLayout)
BOOL WINAPI SetProcessDefaultLayout(
    DWORD dwDefaultLayout)
{
    return (BOOL)NtUserCallOneParam(dwDefaultLayout, SFI__SETPROCESSDEFAULTLAYOUT);
}

/***************************************************************************\
* IsWinEventHookInstalled
*
* History:
* Jul-18-2000 DwayneN Created
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsWinEventHookInstalled, DWORD, event)
BOOL
IsWinEventHookInstalled(
    DWORD event)
{
    /*
     * We need to ensure that we are a GUI thread.  If we fail to convert
     * to a GUI thread, we have to return TRUE to indicate that there might
     * be a hook installed for the event - since we can't check it for sure.
     * In reality, any future calls to User APIs like NotifyWinEvent will
     * probably fail as well, so this is probably a dead-end anyway.
     */
    ConnectIfNecessary(TRUE);

    return(FEVENTHOOKED(event));
};

HWND
VerNtUserCreateWindowEx(
    IN DWORD dwExStyle,
    IN PLARGE_STRING pstrClassName,
    IN PLARGE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwStyle,
    IN int x,
    IN int y,
    IN int nWidth,
    IN int nHeight,
    IN HWND hwndParent,
    IN HMENU hmenu,
    IN HANDLE hModule,
    IN LPVOID pParam,
    IN DWORD dwFlags)
{
    HWND hwnd = NULL;
    PACTIVATION_CONTEXT pActCtx = NULL;
    LARGE_IN_STRING strClassNameVer;
    PLARGE_STRING pstrClassNameVer = pstrClassName;
    NTSTATUS Status;
    WCHAR ClassNameVer[MAX_ATOM_LEN];
    LPWSTR lpClassNameVer;
#ifdef LAME_BUTTON
    PWND pwnd;
#endif // LAME_BUTTON
    LPWSTR lpDllName = NULL;
    HMODULE hDllMod = NULL;
    PREGISTERCLASSNAMEW pRegisterClassNameW = NULL;
    BOOL bRegistered = FALSE;

    strClassNameVer.fAllocated = FALSE;

    if(GetClientInfo()->dwTIFlags & TIF_16BIT) {
       /*
        * No Fusion redirection for 16BIT apps
        */
       if(!(GetAppCompatFlags2(VERMAX) & GACF2_FORCEFUSION)) {
          dwFlags &= ~CW_FLAGS_VERSIONCLASS;
       }
    }

    if (dwFlags & CW_FLAGS_VERSIONCLASS) {
        /*
         * Get the current active App context to be activated whenever we call
         * the user WndProc.
         * Be aware that RtlGetActiveActivationContext will increment the pActCtx
         * ref count for that reason we have to release it in fnNCDESTROY.
         */
        ACTIVATION_CONTEXT_BASIC_INFORMATION ActivationContextInfo = {0};
        const ACTIVATIONCONTEXTINFOCLASS ActivationContextInfoClass = ActivationContextBasicInformation;
        Status =
            RtlQueryInformationActiveActivationContext(
                ActivationContextInfoClass,
                &ActivationContextInfo,
                sizeof(ActivationContextInfo),
                NULL
                );
        UserAssert (NT_SUCCESS(Status));
        if ((ActivationContextInfo.Flags & ACTIVATION_CONTEXT_FLAG_NO_INHERIT) == 0) {
            pActCtx = ActivationContextInfo.ActivationContext;
        } else {
            RtlReleaseActivationContext(ActivationContextInfo.ActivationContext);
        }

        /*
         * Now convert the class name to class name+version.
         */
        if (IS_PTR(pstrClassName)) {
            lpClassNameVer = ClassNameToVersion((LPWSTR)pstrClassName->Buffer, ClassNameVer, &lpDllName, FALSE);
        } else {
            lpClassNameVer = ClassNameToVersion((LPWSTR)pstrClassName, ClassNameVer, &lpDllName, FALSE);
        }
        if (lpClassNameVer == NULL) {
            RIPMSG0(RIP_WARNING, "CreateWindowEx: Couldn't resolve the class name\n");
            return NULL;
        }

        if (IS_PTR(lpClassNameVer)) {
            RtlInitLargeUnicodeString(
                    (PLARGE_UNICODE_STRING)&strClassNameVer.strCapture,
                    lpClassNameVer, (UINT)-1);
            pstrClassNameVer = (PLARGE_STRING)&strClassNameVer.strCapture;
        } else {
            pstrClassNameVer = (PLARGE_STRING)lpClassNameVer;
        }
    }

TryAgian:

    hwnd =  NtUserCreateWindowEx(
        dwExStyle,
        pstrClassName,
        pstrClassNameVer,
        pstrWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hwndParent,
        hmenu,
        hModule,
        pParam,
        dwFlags,
        pActCtx);

    /*
     * If we failed to create the window, and it is because the class is not registered.
     */
    if ((hwnd == NULL) &&
        (dwFlags & CW_FLAGS_VERSIONCLASS) &&
        (lpDllName != NULL) &&
        (!bRegistered) &&
        (GetLastError() == ERROR_CANNOT_FIND_WND_CLASS)
       ) {
        /*
         * Then try to register it, By loading its DLL. Notice that this DLL
         * will never get unloaded unless we failed to create the window.
         * but once we created a window by loading this DLL will never free it.
         */
        if ((hDllMod = LoadLibraryW(lpDllName)) &&
             (pRegisterClassNameW = (PREGISTERCLASSNAMEW)GetProcAddress(hDllMod, "RegisterClassNameW"))) {

            if (IS_PTR(pstrClassName)) {
                bRegistered = (*pRegisterClassNameW)((LPCWSTR)pstrClassName->Buffer);
            } else {
                UNICODE_STRING UnicodeClassName;
                WCHAR Buffer[MAX_ATOM_LEN];

                UnicodeClassName.MaximumLength = (USHORT)(MAX_ATOM_LEN * sizeof(WCHAR));
                UnicodeClassName.Buffer = Buffer;
                if (NtUserGetAtomName((ATOM)pstrClassName, &UnicodeClassName)) {
                    bRegistered = (*pRegisterClassNameW)(Buffer);
                }
            }

            if (bRegistered) {
                goto TryAgian;
            }
        }
    }

    if ((hwnd == NULL) && (hDllMod != NULL)){
        FreeLibrary(hDllMod);
    }

#ifdef LAME_BUTTON
    pwnd = ValidateHwnd(hwnd);
    if (pwnd != NULL && TestWF(pwnd, WEFLAMEBUTTON)) {
        ULONG nCallers;
        PVOID stack[16];
        PVOID pStackTrace = NULL;

        /*
         * Get a stack trace and store it for use when the button is
         * pressed.
         */
        nCallers = RtlWalkFrameChain(stack, ARRAY_SIZE(stack), 0);
        if (nCallers > 0) {
            pStackTrace = UserLocalAlloc(HEAP_ZERO_MEMORY, (nCallers + 1) * sizeof(PVOID));

            if (pStackTrace == NULL) {
                RIPMSG0(RIP_WARNING, "Failed to allocate stack trace");
                goto Failure;
            }

            RtlCopyMemory(pStackTrace, stack, nCallers * sizeof(PVOID));

            /*
             * NULL terminate the array so we know where it ends
             */
            ((PVOID*)pStackTrace)[nCallers] = NULL;
        }
Failure:
        NtUserCallTwoParam((ULONG_PTR)hwnd, (ULONG_PTR)pStackTrace, SFI_SETSTACKTRACE);
    }
#endif // LAME_BUTTON

    CLEANUPLPSTRW(strClassNameVer);

    return hwnd;
}

/**************************************************************************\
* AllowForegroundActivation
*
* 26-Apr-2001 clupu    Created
\**************************************************************************/

VOID AllowForegroundActivation(VOID)
{
    NtUserCallNoParam(SFI__ALLOWFOREGROUNDACTIVATION);
}

/**************************************************************************\
* DisableProcessWindowGhosting
*
* 31-May-2001 msadek   Created
\**************************************************************************/
VOID DisableProcessWindowsGhosting(VOID)
{
    NtUserCallNoParam(SFI__DISABLEPROCESSWINDOWSGHOSTING);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\clglobal.c ===
/****************************** Module Header ******************************\
* Module Name: clglobal.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all of USER.DLL's global variables. These are all
* instance-specific, i.e. each client has his own copy of these. In general,
* there shouldn't be much reason to create instance globals.
*
* NOTE: In this case what we mean by global is that this data is shared by
* all threads of a given process, but not shared between processes
* or between the client and the server. None of this data is useful
* (or even accessable) to the server.
*
* History:
* 10-18-90 DarrinM Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


// Debug globals
#if DBG
INT gbCheckHandleLevel;
#endif

/*
 * We get this warning if we don't explicitly initalize gZero:
 *
 * C4132: 'gZero' : const object should be initialized
 *
 * But we can't explicitly initialize it since it is a union. So
 * we turn the warning off.
 */
#pragma warning(disable:4132)
CONST ALWAYSZERO gZero;
#pragma warning(default:4132)

/*
 * Amount wheel has been scrolled in a control less than WHEEL_DELTA. Each
 * control resets this variable to 0 in WM_KILLFOCUS, and verifies it is
 * 0 in WM_SETFOCUS.
 * CONSIDER: Should be per-queue rather than per client?
 */
int gcWheelDelta;

WCHAR awchSlashStar[] = L"\\*";
CHAR achSlashStar[] = "\\*";

PSERVERINFO gpsi;
SHAREDINFO gSharedInfo;
HMODULE hmodUser;               // USER.DLL's hmodule
ULONG_PTR gHighestUserAddress;

BOOL gfServerProcess;           // USER is linked on the CSR server side
BOOL gfSystemInitialized;       // System has been initialized

ACCESS_MASK gamWinSta;          // ACCESS_MASK for the current WindowStation

PVOID pUserHeap;

WCHAR szUSER32[] = TEXT("USER32");
CONST WCHAR szNull[2] = { TEXT('\0'), TEXT('\015') };
CONST WCHAR szOneChar[] = TEXT("0");
WCHAR szSLASHSTARDOTSTAR[] = TEXT("\\*");  /* This is a single "\"  */

LPWSTR pwcHighContrastScheme;
LPSTR  pcHighContrastScheme;

/* Maps MessageBox type to number of buttons in the MessageBox */
CONST BYTE mpTypeCcmd[] = { 1, 2, 3, 3, 2, 2, 3 };

/* Maps MessageBox type to index into SEBbuttons array */
CONST BYTE mpTypeIich[] = { 0, 2, 5, 12, 9, 16, 19 };

CONST UINT SEBbuttons[] = {
    SEB_OK, SEB_HELP,
    SEB_OK, SEB_CANCEL, SEB_HELP,
    SEB_ABORT, SEB_RETRY, SEB_IGNORE, SEB_HELP,
    SEB_YES, SEB_NO, SEB_HELP,
    SEB_YES, SEB_NO, SEB_CANCEL, SEB_HELP,
    SEB_RETRY, SEB_CANCEL, SEB_HELP,
    SEB_CANCEL, SEB_TRYAGAIN, SEB_CONTINUE, SEB_HELP,
};

ATOM atomMDIActivateProp;

CRITICAL_SECTION gcsLookaside;
CRITICAL_SECTION gcsHdc;
CRITICAL_SECTION gcsClipboard;
CRITICAL_SECTION gcsAccelCache;

#ifdef _JANUS_
BOOL gfEMIEnable;
DWORD gdwEMIControl;
BOOL gfDMREnable;
HANDLE gEventSource;
#endif

HDC    ghdcBits2;
HDC    ghdcGray;
HFONT  ghFontSys;
HBRUSH ghbrWindowText;
int    gcxGray;
int    gcyGray;

FPLPKTABBEDTEXTOUT fpLpkTabbedTextOut = UserLpkTabbedTextOut;
FPLPKPSMTEXTOUT fpLpkPSMTextOut       = UserLpkPSMTextOut;
FPLPKDRAWTEXTEX fpLpkDrawTextEx       = (FPLPKDRAWTEXTEX)NULL;
PLPKEDITCALLOUT fpLpkEditControl      = (PLPKEDITCALLOUT)NULL;

/*
 * These are the resource call procedure addresses. If WOW is running,
 * it makes a call to set all these up to point to it. If it isn't
 * running, it defaults to the values you see below.
 */
PFNFINDA pfnFindResourceExA; // Assigned dynamically - _declspec (PFNFINDA)FindResourceExA,
PFNFINDW pfnFindResourceExW; // Assigned dynamically - _declspec (PFNFINDW)FindResourceExW,
PFNLOAD pfnLoadResource; // Assigned dynamically - _declspec (PFNLOAD)LoadResource,
PFNLOCK pfnLockResource             = (PFNLOCK)_LockResource;
PFNUNLOCK pfnUnlockResource         = (PFNUNLOCK)_UnlockResource;
PFNFREE pfnFreeResource             = (PFNFREE)_FreeResource;
PFNSIZEOF pfnSizeofResource; // Assigned dynamically - _declspec (PFNSIZEOF)SizeofResource
PFNLALLOC pfnLocalAlloc             = (PFNLALLOC)DispatchLocalAlloc;
PFNLREALLOC pfnLocalReAlloc         = (PFNLREALLOC)DispatchLocalReAlloc;
PFNLLOCK pfnLocalLock               = (PFNLLOCK)DispatchLocalLock;
PFNLUNLOCK pfnLocalUnlock           = (PFNUNLOCK)DispatchLocalUnlock;
PFNLSIZE pfnLocalSize               = (PFNLSIZE)DispatchLocalSize;
PFNLFREE pfnLocalFree               = (PFNLFREE)DispatchLocalFree;
PFNGETEXPWINVER pfnGetExpWinVer     = RtlGetExpWinVer;
PFN16GALLOC pfn16GlobalAlloc;
PFN16GFREE pfn16GlobalFree;
PFNEMPTYCB pfnWowEmptyClipBoard;
PFNWOWWNDPROCEX  pfnWowWndProcEx;
PFNWOWDLGPROCEX  pfnWowDlgProcEx;
PFNWOWEDITNEXTWORD   pfnWowEditNextWord;
PFNWOWCBSTOREHANDLE pfnWowCBStoreHandle;
PFNGETPROCMODULE16  pfnWowGetProcModule;
PFNWOWTELLWOWTHEHDLG pfnWOWTellWOWThehDlg;
PFNWOWMSGBOXINDIRECTCALLBACK pfnWowMsgBoxIndirectCallback;
PFNWOWILSTRCMP  pfnWowIlstrcmp;
PFNWOWTASK16SCHEDNOTIFY pfnWowTask16SchedNotify;

/*
 * UserApiHook
 *
 * It is important to keep guah initialization in sync with ResetUserApiHook()
 * and the definition of USERAPIHOOK. This initialization must be done here
 * so that the function pointers are valid immediately on startup.
 */
BYTE grgbDwpLiteHookMsg[(WM_USER + 7) / 8];
BYTE grgbWndLiteHookMsg[(WM_USER + 7) / 8];
BYTE grgbDlgLiteHookMsg[(WM_USER + 7) / 8];

HMODULE ghmodUserApiHook;
USERAPIHOOK guah =
{
    sizeof(USERAPIHOOK),
    RealDefWindowProcA,
    RealDefWindowProcW,
    {
        NULL,
        0
    },
    RealGetScrollInfo,
    RealSetScrollInfo,
    RealEnableScrollBar,
    RealAdjustWindowRectEx,
    RealSetWindowRgn,
    {
        DefaultOWP,
        DefaultOWP,
        NULL,
        0
    },
    {
        DefaultOWP,
        DefaultOWP,
        NULL,
        0
    },
    RealGetSystemMetrics,
    RealSystemParametersInfoA,
    RealSystemParametersInfoW,
    ForceResetUserApiHook,
    RealDrawFrameControl,
    RealDrawCaption,
    RealMDIRedrawFrame
};
BOOL    gfUserApiHook;
LONG    gcCallUserApiHook;
LONG    gcLoadUserApiHook;
RTL_CRITICAL_SECTION gcsUserApiHook;
INITUSERAPIHOOK      gpfnInitUserApi;

#ifdef MESSAGE_PUMP_HOOK

/*
 * MessagePumpHook
 */
BOOL                gfMessagePumpHook;
LONG                gcLoadMPH;
MESSAGEPUMPHOOK     gmph = 
{
    sizeof(gmph),
    NtUserRealInternalGetMessage,
    NtUserRealWaitMessageEx,
    RealGetQueueStatus,
    RealMsgWaitForMultipleObjectsEx,
};
RTL_CRITICAL_SECTION gcsMPH;
INITMESSAGEPUMPHOOK  gpfnInitMPH;

#if TEST_DUSER_WMH
HDCONTEXT g_hctx = NULL;           // DirectUser Context
#endif // TEST_DUSER_WMH

#endif // MESSAGE_PUMP_HOOK


/*
 * Menu Drag and Drop
 */
HINSTANCE ghinstOLE;
FARPROC gpfnOLEOleUninitialize;
FARPROC gpfnOLERegisterDD;
FARPROC gpfnOLERevokeDD;
FARPROC gpfnOLEDoDD;

/*
 * Accelerator table resources list.
 */
PACCELCACHE gpac;

/*
 * IME Window Handling.
 */
DWORD gfConIme = UNKNOWN_CONIME;

/*
 * Used for TS Services Message Box handling
 */
FARPROC     gfnWinStationSendMessageW;
HINSTANCE   ghinstWinStaDll;

/*
 * Are we winlogon?
 */
BOOL gfLogonProcess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\clientw.c ===
/**************************************************************************\
* Module Name: clientw.c
*
* Client/Server call related routines dealing with UNICODE text.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 04-Dec-90
*
* History:
* 14-Jan-92 created by IanJa
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifndef UNICODE
#define UNICODE
#endif

#include "cltxt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\clrect.c ===
/****************************** Module Header ******************************\
* Module Name: clrect.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the various rectangle manipulation APIs.
*
* History:
* 04-05-91 DarrinM Pulled these routines from RTL because they call GDI.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* DrawFocusRect (API)
*
* Draw a rectangle in the style used to indicate focus
* Since this is an XOR function, calling it a second time with the same
* rectangle removes the rectangle from the screen
*
* History:
* 19-Jan-1993 mikeke   Client side version
\***************************************************************************/

BOOL DrawFocusRect(
    HDC hDC,
    CONST RECT *pRect)
{
    UserAssert(ghdcGray != NULL);
    return ClientFrame(hDC, pRect, KHBRUSH_TO_HBRUSH(gpsi->hbrGray), PATINVERT,
            max(1, gpsi->aiSysMet[SM_CXFOCUSBORDER]), max(1, gpsi->aiSysMet[SM_CYFOCUSBORDER]));
}

/***************************************************************************\
* FrameRect (API)
*
* History:
*  01-25-91 DavidPe     Created.
\***************************************************************************/

int APIENTRY FrameRect(
    HDC hdc,
    CONST RECT *lprc,
    HBRUSH hbr)
{
    return ClientFrame(hdc, lprc, hbr, PATCOPY, 1, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\combo.c ===
/**************************** Module Header ********************************\
* Module Name: combo.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* The WndProc for combo boxes and other often used combo routines
*
* History:
* ??-???-???? ??????    Ported from Win 3.0 sources
* 01-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

LOOKASIDE ComboboxLookaside;

BOOL NtUserTrackMouseEvent(TRACKMOUSEEVENT *ptme);
LONG xxxCBGetTextLengthHelper(PCBOX pcbox, BOOL fAnsi);
LONG xxxCBGetTextHelper(PCBOX pcbox, int len, LPWSTR lpstr, BOOL fAnsi);

/***************************************************************************\
*
*  PressButton()
*
*  Pops combobox button back up.
*
\***************************************************************************/
void xxxPressButton(PCBOX pcbox, BOOL fPress)
{
    //
    // Publisher relies on getting a WM_PAINT message after the combo list
    // pops back up.  On a WM_PAINT they change the focus, which causes
    // toolbar combos to send CBN_SELENDCANCEL notifications.  On this
    // notification they apply the font/pt size change you made to the
    // selection.
    //
    // This happened in 3.1 because the dropdown list overlapped the button
    // on the bottom or top by a pixel.  Since we'd end up painting under
    // the list SPB, when it went away USER would reinvalidate the dirty
    // area.  This would cause a paint message.
    //
    // In 4.0, this doesn't happen because the dropdown doesn't overlap.  So
    // we need to make sure Publisher gets a WM_PAINT anyway.  We do this
    // by changing where the dropdown shows up for 3.x apps
    //
    //

    if ((pcbox->fButtonPressed != 0) != (fPress != 0)) {

        HWND hwnd = HWq(pcbox->spwnd);

        pcbox->fButtonPressed = (fPress != 0);
        if (pcbox->f3DCombo)
            NtUserInvalidateRect(hwnd, KPRECT_TO_PRECT(&pcbox->buttonrc), TRUE);
        else
        {
            RECT    rc;

            CopyRect(&rc, KPRECT_TO_PRECT(&pcbox->buttonrc));
            InflateRect(&rc, 0, SYSMET(CYEDGE));
            NtUserInvalidateRect(hwnd, &rc, TRUE);
        }
        UpdateWindow(hwnd);

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
    }
}

/***************************************************************************\
* HotTrack
*
* If we're not already hot-tracking and the mouse is over the combobox,
* turn on hot-tracking and invalidate the drop-down button.
*
\***************************************************************************/

#ifdef COLOR_HOTTRACKING

void HotTrack(PCBOX pcbox)
{
    if (!pcbox->fButtonHotTracked && !pcbox->fMouseDown) {
        HWND hwnd = HWq(pcbox->spwnd);
        TRACKMOUSEEVENT tme = {sizeof(TRACKMOUSEEVENT), TME_LEAVE, hwnd, 0};
        if (NtUserTrackMouseEvent(&tme)) {
            pcbox->fButtonHotTracked = TRUE;
            NtUserInvalidateRect(hwnd, &pcbox->buttonrc, TRUE);
        }
    }
}

#endif // COLOR_HOTTRACKING

/***************************************************************************\
* xxxComboBoxDBCharHandler
*
* Double Byte character handler for ANSI ComboBox
*
* History:
\***************************************************************************/

LRESULT ComboBoxDBCharHandler(
    PCBOX pcbox,
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    WORD w;
    PWND pwndSend;

    w = DbcsCombine(hwnd, (BYTE)wParam);
    if (w == 0) {
        return CB_ERR;  // Failed to assemble DBCS
    }

    UserAssert(pcbox->spwndList);
    if (pcbox->fNoEdit) {
        pwndSend = pcbox->spwndList;
    } else if (pcbox->spwndEdit) {
        RIPMSG1(RIP_WARNING, "ComboBoxWndProcWorker: WM_CHAR is posted to Combobox itself(%08x).",
                hwnd);
        pwndSend = pcbox->spwndEdit;
    } else {
        return CB_ERR;
    }

    RIPMSG1(RIP_VERBOSE, "ComboBoxWndProcWorker: sending WM_CHAR %04x", w);

    if (!TestWF(pwndSend, WFANSIPROC)) {
        //
        // If receiver is not ANSI WndProc (may be subclassed?),
        // send a UNICODE message.
        //
        WCHAR wChar;
        LPWSTR lpwstr = &wChar;

        if (MBToWCSEx(THREAD_CODEPAGE(), (LPCSTR)&w, 2, &lpwstr, 1, FALSE) == 0) {
            RIPMSG1(RIP_WARNING, "ComboBoxWndProcWorker: cannot convert 0x%04x to UNICODE.", w);
            return CB_ERR;
        }
        return SendMessageWorker(pwndSend, message, wChar, lParam, FALSE);
    }

    /*
     * Post the Trailing byte to the target
     * so that they can peek the second WM_CHAR
     * message later.
     * Note: it's safe since sender is A and receiver is A,
     * translation layer does not perform any DBCS combining and cracking.
     */
    PostMessageA(HWq(pwndSend), message, CrackCombinedDbcsTB(w), lParam);
    return SendMessageWorker(pwndSend, message, wParam, lParam, TRUE);
}

BOOL ComboBoxMsgOKInInit(UINT message, LRESULT* plRet)
{
    switch (message) {
    default:
        break;
    case WM_SIZE:
        *plRet = 0;
        return FALSE;
    case WM_STYLECHANGED:
    case WM_GETTEXT:
    case WM_GETTEXTLENGTH:
    case WM_PRINT:
    case WM_COMMAND:
    case CBEC_KILLCOMBOFOCUS:
    case WM_PRINTCLIENT:
    case WM_SETFONT:
    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_MOUSEWHEEL:
    case WM_CAPTURECHANGED:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
    case WM_SETFOCUS:
    case WM_KILLFOCUS:
    case WM_SETREDRAW:
    case WM_ENABLE:
    case CB_SETDROPPEDWIDTH:
    case CB_DIR:
    case CB_ADDSTRING:
        /*
         * Cannot handle those messages yet. Bail out.
         */
        *plRet = CB_ERR;
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* xxxComboBoxCtlWndProc
*
* Class procedure for all combo boxes
*
* History:
\***************************************************************************/

LRESULT APIENTRY ComboBoxWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    PCBOX pcbox;
    POINT pt;
    TL tlpwndEdit;
    TL tlpwndList;
    PAINTSTRUCT ps;
    LPWSTR lpwsz = NULL;
    LRESULT lReturn;
    static BOOL fInit = TRUE;
    int  i;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, FNID_COMBOBOX);
    INITCONTROLLOOKASIDE(&ComboboxLookaside, CBOX, spwnd, 8);

    /*
     * Get the pcbox for the given window now since we will use it a lot in
     * various handlers.  This is stored by NtUserSetWindowLongPtr() in the
     * INITCONTROLLOOKASIDE macro above.
     */
    pcbox = ((PCOMBOWND)pwnd)->pcbox;

    /*
     * Protect the combobox during the initialization.
     */
    if (pcbox->spwndList == NULL) {
        LRESULT lRet;

        if (!ComboBoxMsgOKInInit(message, &lRet)) {
            RIPMSG2(RIP_WARNING, "ComboBoxWndProcWorker: msg=%04x is sent to hwnd=%08x in the middle of initialization.",
                    message, hwnd);
            return lRet;
        }
    }

    /*
     * Dispatch the various messages we can receive
     */
    switch (message) {
    case CBEC_KILLCOMBOFOCUS:

        /*
         * Private message coming from editcontrol informing us that the combo
         * box is losing the focus to a window which isn't in this combo box.
         */
        xxxCBKillFocusHelper(pcbox);
        break;

    case WM_COMMAND:

        /*
         * So that we can handle notification messages from the listbox and
         * edit control.
         */
        return xxxCBCommandHandler(pcbox, (DWORD)wParam, (HWND)lParam);

    case WM_STYLECHANGED:
        UserAssert(pcbox->spwndList != NULL);
        {
            LONG OldStyle;
            LONG NewStyle = 0;

            pcbox->fRtoLReading = (TestWF(pwnd, WEFRTLREADING) != 0);
            pcbox->fRightAlign  = (TestWF(pwnd, WEFRIGHT) != 0);
            if (pcbox->fRtoLReading)
                NewStyle |= (WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);
            if (pcbox->fRightAlign)
                NewStyle |= WS_EX_RIGHT;

            ThreadLock(pcbox->spwndList, &tlpwndList);
            OldStyle = GetWindowLong(HWq(pcbox->spwndList), GWL_EXSTYLE) & ~(WS_EX_RIGHT|WS_EX_RTLREADING|WS_EX_LEFTSCROLLBAR);
            SetWindowLong(HWq(pcbox->spwndList), GWL_EXSTYLE, OldStyle|NewStyle);
            ThreadUnlock(&tlpwndList);

            if (!pcbox->fNoEdit && pcbox->spwndEdit) {
                ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
                OldStyle = GetWindowLong(HWq(pcbox->spwndEdit), GWL_EXSTYLE) & ~(WS_EX_RIGHT|WS_EX_RTLREADING|WS_EX_LEFTSCROLLBAR);
                SetWindowLong(HWq(pcbox->spwndEdit), GWL_EXSTYLE, OldStyle|NewStyle);
                ThreadUnlock(&tlpwndEdit);
            }
            xxxCBPosition(pcbox);
            NtUserInvalidateRect(hwnd, NULL, FALSE);
        }
        break;

    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOR:
        //
        // Causes compatibility problems for 3.X apps.  Forward only
        // for 4.0
        //
        if (TestWF(pwnd, WFWIN40COMPAT)) {
            TL tlpwndParent;
            LRESULT ret;
            PWND pwndParent;

            pwndParent = REBASEPWND(pwnd, spwndParent);
            ThreadLock(pwndParent, &tlpwndParent);
            ret = SendMessage(HW(pwndParent), message, wParam, lParam);
            ThreadUnlock(tlpwndParent);
            return ret;
        } else
            return(DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi));
        break;

    case WM_GETTEXT:
        if (pcbox->fNoEdit) {
            return xxxCBGetTextHelper(pcbox, (int)wParam, (LPWSTR)lParam, fAnsi);
        }
        goto CallEditSendMessage;
        break;

    case WM_GETTEXTLENGTH:

        /*
         * If the is not edit control, CBS_DROPDOWNLIST, then we have to
         * ask the list box for the size
         */

        if (pcbox->fNoEdit) {
            return xxxCBGetTextLengthHelper(pcbox, fAnsi);
        }

        // FALL THROUGH

    case WM_CLEAR:
    case WM_CUT:
    case WM_PASTE:
    case WM_COPY:
    case WM_SETTEXT:
        goto CallEditSendMessage;
        break;

    case WM_CREATE:

        /*
         * wParam - not used
         * lParam - Points to the CREATESTRUCT data structure for the window.
         */
        return xxxCBCreateHandler(pcbox, pwnd);

    case WM_ERASEBKGND:

        /*
         * Just return 1L so that the background isn't erased
         */
        return 1L;

    case WM_GETFONT:
        return (LRESULT)pcbox->hFont;

    case WM_PRINT:
        if (!DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi))
            return(FALSE);

        if ((lParam & PRF_OWNED) && (pcbox->CBoxStyle & SDROPPABLE) &&
            TestWF(pcbox->spwndList, WFVISIBLE)) {
            TL tpwndList;
            int iDC = SaveDC((HDC) wParam);
            OffsetWindowOrgEx((HDC) wParam, 0, pwnd->rcWindow.top - pcbox->spwndList->rcWindow.top, NULL);
            lParam &= ~PRF_CHECKVISIBLE;
            ThreadLock(pcbox->spwndList, &tpwndList);
            SendMessageWorker(pcbox->spwndList, WM_PRINT, wParam, lParam, FALSE);
            RestoreDC((HDC) wParam, iDC);
        }
        return TRUE;

    case WM_PRINTCLIENT:
        xxxCBPaint(pcbox, (HDC) wParam);
        break;

    case WM_PAINT: {
        HDC hdc;

        /*
         * wParam - perhaps a hdc
         */
        hdc = (wParam) ? (HDC) wParam : NtUserBeginPaint(hwnd, &ps);

        if (IsComboVisible(pcbox))
            xxxCBPaint(pcbox, hdc);

        if (!wParam)
            NtUserEndPaint(hwnd, &ps);
        break;
    }
    case WM_GETDLGCODE:

        /*
         * wParam - not used
         * lParam - not used
         */
        {
            LRESULT code = DLGC_WANTCHARS | DLGC_WANTARROWS;

            // If the listbox is dropped and the ENTER key is pressed,
            // we want this message so we can close up the listbox
            if ((lParam != 0) &&
                (((LPMSG)lParam)->message == WM_KEYDOWN) &&
                pcbox->fLBoxVisible &&
                ((wParam == VK_RETURN) || (wParam == VK_ESCAPE)))
            {
                code |= DLGC_WANTMESSAGE;
            }
            return code;
        }
        /*
         * No fall through
         */

    case WM_SETFONT:
        xxxCBSetFontHandler(pcbox, (HANDLE)wParam, LOWORD(lParam));
        break;

    case WM_SYSKEYDOWN:
        if (lParam & 0x20000000L)  /* Check if the alt key is down */ {

            /*
             * Handle Combobox support.  We want alt up or down arrow to behave
             * like F4 key which completes the combo box selection
             */
            if (lParam & 0x1000000) {

                /*
                 * This is an extended key such as the arrow keys not on the
                 * numeric keypad so just drop the combobox.
                 */
                if (wParam == VK_DOWN || wParam == VK_UP)
                    goto DropCombo;

                goto CallDWP;
            }

            if (GetKeyState(VK_NUMLOCK) & 0x1) {
                /*
                 * If numlock down, just send all system keys to dwp
                 */
                goto CallDWP;
            } else {

                /*
                 * We just want to ignore keys on the number pad...
                 */
                if (!(wParam == VK_DOWN || wParam == VK_UP))
                    goto CallDWP;
            }
DropCombo:
            if (!pcbox->fLBoxVisible) {

                /*
                 * If the listbox isn't visible, just show it
                 */
                xxxCBShowListBoxWindow(pcbox, TRUE);
            } else {

                /*
                 * Ok, the listbox is visible.  So hide the listbox window.
                 */
                if (!xxxCBHideListBoxWindow(pcbox, TRUE, TRUE))
                    return(0L);
            }
        }
        goto CallDWP;
        break;

    case WM_KEYDOWN:
        /*
         * If the listbox is dropped and the ENTER key is pressed,
         * close up the listbox successfully.  If ESCAPE is pressed,
         * close it up like cancel.
         */
        if (pcbox->fLBoxVisible) {
            if ((wParam == VK_RETURN) || (wParam == VK_ESCAPE)) {
                xxxCBHideListBoxWindow(pcbox, TRUE, (wParam != VK_ESCAPE));
                break;
            }
        }
        // FALL THROUGH

    case WM_CHAR:
        if (fAnsi && IS_DBCS_ENABLED() && IsDBCSLeadByteEx(THREAD_CODEPAGE(), (BYTE)wParam)) {
            return ComboBoxDBCharHandler(pcbox, hwnd, message, wParam, lParam);
        }

        if (pcbox->fNoEdit) {
            goto CallListSendMessage;
        }
        else
            goto CallEditSendMessage;
        break;

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:

#ifdef COLOR_HOTTRACKING
        pcbox->fButtonHotTracked = FALSE;
#endif // COLOR_HOTTRACKING

        /*
         * Set the focus to the combo box if we get a mouse click on it.
         */
        if (!pcbox->fFocus) {
            NtUserSetFocus(hwnd);
            if (!pcbox->fFocus) {

                /*
                 * Don't do anything if we still don't have the focus.
                 */
                break;
            }
        }

        /*
         * If user clicked in button rect and we are a combobox with edit, then
         * drop the listbox.  (The button rect is 0 if there is no button so the
         * ptinrect will return false.) If a drop down list (no edit), clicking
         * anywhere on the face causes the list to drop.
         */

        POINTSTOPOINT(pt, lParam);
        if ((pcbox->CBoxStyle == SDROPDOWN &&
                PtInRect(KPRECT_TO_PRECT(&pcbox->buttonrc), pt)) ||
                pcbox->CBoxStyle == SDROPDOWNLIST) {

            /*
             * Set the fMouseDown flag so that we can handle clicking on
             * the popdown button and dragging into the listbox (when it just
             * dropped down) to make a selection.
             */
            pcbox->fButtonPressed = TRUE;
            if (pcbox->fLBoxVisible) {
                if (pcbox->fMouseDown) {
                    pcbox->fMouseDown = FALSE;
                    NtUserReleaseCapture();
                }
                xxxPressButton(pcbox, FALSE);

                if (!xxxCBHideListBoxWindow(pcbox, TRUE, TRUE))
                    return(0L);
            } else {
                xxxCBShowListBoxWindow(pcbox, FALSE);

                // Setting and resetting this flag must always be followed
                // imediately by SetCapture or ReleaseCapture
                //
                pcbox->fMouseDown = TRUE;
                NtUserSetCapture(hwnd);
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
            }
        }
        break;

    case WM_MOUSEWHEEL:
        /*
         * Handle only scrolling.
         */
        if (wParam & (MK_CONTROL | MK_SHIFT))
            goto CallDWP;

        /*
         * If the listbox is visible, send it the message to scroll.
         */
        if (pcbox->fLBoxVisible)
            goto CallListSendMessage;

        /*
         * If we're in extended UI mode or the edit control isn't yet created,
         * bail.
         */
        if (pcbox->fExtendedUI || pcbox->spwndEdit == NULL)
            return TRUE;

        /*
         * Emulate arrow up/down messages to the edit control.
         */
        i = abs(((short)HIWORD(wParam))/WHEEL_DELTA);
        wParam = ((short)HIWORD(wParam) > 0) ? VK_UP : VK_DOWN;

        ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
        while (i-- > 0) {
            SendMessageWorker(
                    pcbox->spwndEdit, WM_KEYDOWN, wParam, 0, fAnsi);
        }
        ThreadUnlock(&tlpwndEdit);
        return TRUE;

    case WM_CAPTURECHANGED:
        if (!(TestWF(pwnd, WFWIN40COMPAT)))
            return 0;

        if ((pcbox->fMouseDown)) {
            pcbox->fMouseDown = FALSE;
            xxxPressButton(pcbox, FALSE);

            //
            // Pop combo listbox back up, canceling.
            //
            if (pcbox->fLBoxVisible)
                xxxCBHideListBoxWindow(pcbox, TRUE, FALSE);
        }
        break;

    case WM_LBUTTONUP:
        xxxPressButton(pcbox, FALSE);

        /*
         * Clear this flag so that mouse moves aren't sent to the listbox
         */
        if (pcbox->fMouseDown) {
            pcbox->fMouseDown = FALSE;

            if (pcbox->CBoxStyle == SDROPDOWN) {
                // If an item in the listbox matches the text in the edit
                // control, scroll it to the top of the listbox. Select the
                // item only if the mouse button isn't down otherwise we
                // will select the item when the mouse button goes up.
                xxxCBUpdateListBoxWindow(pcbox, TRUE);
                xxxCBCompleteEditWindow(pcbox);
            }
            NtUserReleaseCapture();

            // Now, we want listbox to track mouse moves while mouse up
            // until mouse down, and select items as though they were
            // clicked on.
            if (TestWF(pwnd, WFWIN40COMPAT)) {

                ThreadLock(pcbox->spwndList, &tlpwndList);
                SendMessageWorker(pcbox->spwndList, LBCB_STARTTRACK, FALSE, 0, FALSE);
                ThreadUnlock(&tlpwndList);
            }
        }
#ifdef COLOR_HOTTRACKING
        HotTrack(pcbox);
        break;

    case WM_MOUSELEAVE:
        pcbox->fButtonHotTracked = FALSE;
        NtUserInvalidateRect(hwnd, &pcbox->buttonrc, TRUE);
#endif // COLOR_HOTTRACKING
        break;

    case WM_MOUSEMOVE:
        if (pcbox->fMouseDown) {
            POINTSTOPOINT(pt, lParam);

            // Note conversion of INT bit field to BOOL (1 or 0)

            if (PtInRect(KPRECT_TO_PRECT(&pcbox->buttonrc), pt) != !!pcbox->fButtonPressed) {
                xxxPressButton(pcbox, (pcbox->fButtonPressed == 0));
            }

            _ClientToScreen(pwnd, &pt);
            if (PtInRect(KPRECT_TO_PRECT(&pcbox->spwndList->rcClient), pt)) {

                /*
                 * This handles dropdown comboboxes/listboxes so that clicking
                 * on the dropdown button and dragging into the listbox window
                 * will let the user make a listbox selection.
                 */
                pcbox->fMouseDown = FALSE;
                NtUserReleaseCapture();

                if (pcbox->CBoxStyle & SEDITABLE) {

                    /*
                     * If an item in the listbox matches the text in the edit
                     * control, scroll it to the top of the listbox.  Select the
                     * item only if the mouse button isn't down otherwise we
                     * will select the item when the mouse button goes up.
                     */

                    /*
                     * We need to select the item which matches the editcontrol
                     * so that if the user drags out of the listbox, we don't
                     * cancel back to his origonal selection
                     */
                    xxxCBUpdateListBoxWindow(pcbox, TRUE);
                }

                /*
                 * Convert point to listbox coordinates and send a buttondown
                 * message to the listbox window.
                 */
                _ScreenToClient(pcbox->spwndList, &pt);
                lParam = POINTTOPOINTS(pt);
                message = WM_LBUTTONDOWN;
                goto CallListSendMessage;
            }
        }
#ifdef COLOR_HOTTRACKING
        HotTrack(pcbox);
#endif // COLOR_HOTTRACKING
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        xxxCBNcDestroyHandler(pwnd, pcbox);
        break;

    case WM_SETFOCUS:
        if (pcbox->fNoEdit) {

            /*
             * There is no editcontrol so set the focus to the combo box itself.
             */
            xxxCBGetFocusHelper(pcbox);
        } else if (pcbox->spwndEdit) {
            /*
             * Set the focus to the edit control window if there is one
             */
            ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
            NtUserSetFocus(HWq(pcbox->spwndEdit));
            ThreadUnlock(&tlpwndEdit);
        }
        break;

    case WM_KILLFOCUS:

        /*
         * wParam has the new focus hwnd
         */
        if (wParam != 0)
            wParam = (WPARAM)ValidateHwnd((HWND)wParam);
        if ((wParam == 0) || !_IsChild(pwnd, (PWND)wParam)) {

            /*
             * We only give up the focus if the new window getting the focus
             * doesn't belong to the combo box.
             */
            xxxCBKillFocusHelper(pcbox);
        }

        UserAssert(pcbox->spwndList);
        {
            PLBIV plb = ((PLBWND)pcbox->spwndList)->pLBIV;

            if ((plb != NULL) && (plb != (PLBIV)-1)) {
                plb->iTypeSearch = 0;
                if (plb->pszTypeSearch) {
                    UserLocalFree(plb->pszTypeSearch);
                    plb->pszTypeSearch = NULL;
                }
            }
        }
        break;

    case WM_SETREDRAW:

        /*
         * wParam - specifies state of the redraw flag.  nonzero = redraw
         * lParam - not used
         */

        /*
         * effects: Sets the state of the redraw flag for this combo box
         * and its children.
         */
        pcbox->fNoRedraw = (UINT)!((BOOL)wParam);

        /*
         * Must check pcbox->spwnEdit in case we get this message before
         * WM_CREATE - PCBOX won't be initialized yet. (Eudora does this)
         */
        if (!pcbox->fNoEdit && pcbox->spwndEdit) {
            ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
            SendMessageWorker(pcbox->spwndEdit, message, wParam, lParam, FALSE);
            ThreadUnlock(&tlpwndEdit);
        }
        goto CallListSendMessage;
        break;

    case WM_ENABLE:

        /*
         * Invalidate the rect to cause it to be drawn in grey for its
         * disabled view or ungreyed for non-disabled view.
         */
        NtUserInvalidateRect(hwnd, NULL, FALSE);
        if ((pcbox->CBoxStyle & SEDITABLE) && pcbox->spwndEdit) {

            /*
             * Enable/disable the edit control window
             */
            ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
            NtUserEnableWindow(HWq(pcbox->spwndEdit), (TestWF(pwnd, WFDISABLED) == 0));
            ThreadUnlock(&tlpwndEdit);
        }

        /*
         * Enable/disable the listbox window
         */
        UserAssert(pcbox->spwndList);
        ThreadLock(pcbox->spwndList, &tlpwndList);
        NtUserEnableWindow(HWq(pcbox->spwndList), (TestWF(pwnd, WFDISABLED) == 0));
        ThreadUnlock(&tlpwndList);
      break;

    case WM_SIZE:

        /*
         * wParam - defines the type of resizing fullscreen, sizeiconic,
         *          sizenormal etc.
         * lParam - new width in LOWORD, new height in HIGHUINT of client area
         */
        UserAssert(pcbox->spwndList);
        if (LOWORD(lParam) == 0 || HIWORD(lParam) == 0) {

            /*
             * If being sized to a zero width or to a zero height or we aren't
             * fully initialized, just return.
             */
            return 0;
        }

        // OPTIMIZATIONS -- first check if old and new widths are the same
        if (pcbox->cxCombo == pwnd->rcWindow.right - pwnd->rcWindow.left) {
            int iNewHeight = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

            // now check if new height is the dropped down height
            if (pcbox->fLBoxVisible) {
                // Check if new height is the full size height
                if (pcbox->cyDrop + pcbox->cyCombo == iNewHeight)
                    return(0L);
            } else {
                // Check if new height is the closed up height
                if (pcbox->cyCombo == iNewHeight)
                    return(0L);
            }
        }

        xxxCBSizeHandler(pcbox);
        break;

    case CB_GETDROPPEDSTATE:

        /*
         * returns 1 if combo is dropped down else 0
         * wParam - not used
         * lParam - not used
         */
        return pcbox->fLBoxVisible;

    case CB_GETDROPPEDCONTROLRECT:

        /*
         * wParam - not used
         * lParam - lpRect which will get the dropped down window rect in
         *          screen coordinates.
         */
        ((LPRECT)lParam)->left      = pwnd->rcWindow.left;
        ((LPRECT)lParam)->top       = pwnd->rcWindow.top;
        ((LPRECT)lParam)->right     = pwnd->rcWindow.left + max(pcbox->cxDrop, pcbox->cxCombo);
        ((LPRECT)lParam)->bottom    = pwnd->rcWindow.top + pcbox->cyCombo + pcbox->cyDrop;
        break;

    case CB_SETDROPPEDWIDTH:
        if (pcbox->CBoxStyle & SDROPPABLE) {
            if (wParam) {
                wParam = max(wParam, (UINT)pcbox->cxCombo);

                if (wParam != (UINT) pcbox->cxDrop)
                {
                    pcbox->cxDrop = (int)wParam;
                    xxxCBPosition(pcbox);
                }
            }
        }
        // fall thru

    case CB_GETDROPPEDWIDTH:
        if (pcbox->CBoxStyle & SDROPPABLE)
            return((LRESULT) max(pcbox->cxDrop, pcbox->cxCombo));
        else
            return(CB_ERR);
        break;

    case CB_DIR:
        /*
         * wParam - Dos attribute value.
         * lParam - Points to a file specification string
         */
        if (fAnsi && lParam != 0) {
            if (MBToWCS((LPSTR)lParam, -1, &lpwsz, -1, TRUE) == 0)
                return CB_ERR;
            lParam = (LPARAM)lpwsz;
        }
        lReturn = xxxCBDir(pcbox, LOWORD(wParam), (LPWSTR)lParam);
        if (fAnsi && lParam != 0) {
            UserLocalFree(lpwsz);
        }
        return lReturn;

    case CB_SETEXTENDEDUI:

        /*
         * wParam - specifies state to set extendui flag to.
         * Currently only 1 is allowed.  Return CB_ERR (-1) if
         * failure else 0 if success.
         */
        if (pcbox->CBoxStyle & SDROPPABLE) {
            if (!wParam) {
                pcbox->fExtendedUI = 0;
                return 0;
            }

            if (wParam == 1) {
              pcbox->fExtendedUI = 1;
              return 0;
            }

            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "Invalid parameter \"wParam\" (%ld) to ComboBoxWndProcWorker",
                    wParam);

        } else {
            RIPERR1(ERROR_INVALID_MESSAGE,
                    RIP_WARNING,
                    "Invalid message (%ld) sent to ComboBoxWndProcWorker",
                    message);
        }

        return CB_ERR;

    case CB_GETEXTENDEDUI:
        if (pcbox->CBoxStyle & SDROPPABLE) {
            if (pcbox->fExtendedUI)
                return TRUE;
        }
        return FALSE;

    case CB_GETEDITSEL:

        /*
         * wParam - not used
         * lParam - not used
         * effects: Gets the selection range for the given edit control.  The
         * starting BYTE-position is in the low order word.  It contains the
         * the BYTE-position of the first nonselected character after the end
         * of the selection in the high order word.  Returns CB_ERR if no
         * editcontrol.
         */
        message = EM_GETSEL;
        goto CallEditSendMessage;
        break;

    case CB_LIMITTEXT:

        /*
         * wParam - max number of bytes that can be entered
         * lParam - not used
         * effects: Specifies the maximum number of bytes of text the user may
         * enter.  If maxLength is 0, we may enter MAXINT number of BYTES.
         */
        message = EM_LIMITTEXT;
        goto CallEditSendMessage;
        break;

    case CB_SETEDITSEL:

        /*
         * wParam - ichStart
         * lParam - ichEnd
         *
         */
        message = EM_SETSEL;

        wParam = (int)(SHORT)LOWORD(lParam);
        lParam = (int)(SHORT)HIWORD(lParam);
        goto CallEditSendMessage;
        break;

    case CB_ADDSTRING:

        /*
         * wParam - not used
         * lParam - Points to null terminated string to be added to listbox
         */
        if (!pcbox->fCase)
            message = LB_ADDSTRING;
        else
            message = (pcbox->fCase & UPPERCASE) ? LB_ADDSTRINGUPPER : LB_ADDSTRINGLOWER;
        goto CallListSendMessage;
        break;

    case CB_DELETESTRING:

        /*
         * wParam - index to string to be deleted
         * lParam - not used
         */
        message = LB_DELETESTRING;
        goto CallListSendMessage;
        break;

    case CB_INITSTORAGE:
        // wParamLo - number of items
        // lParam - number of bytes of string space
        message = LB_INITSTORAGE;
        goto CallListSendMessage;

    case CB_SETTOPINDEX:
        // wParamLo - index to make top
        // lParam - not used
        message = LB_SETTOPINDEX;
        goto CallListSendMessage;

    case CB_GETTOPINDEX:
        // wParamLo / lParam - not used
        message = LB_GETTOPINDEX;
        goto CallListSendMessage;

    case CB_GETCOUNT:

        /*
         * wParam - not used
         * lParam - not used
         */
        message = LB_GETCOUNT;
        goto CallListSendMessage;
        break;

    case CB_GETCURSEL:

        /*
         * wParam - not used
         * lParam - not used
         */
        message = LB_GETCURSEL;
        goto CallListSendMessage;
        break;

    case CB_GETLBTEXT:

        /*
         * wParam - index of string to be copied
         * lParam - buffer that is to receive the string
         */
        message = LB_GETTEXT;
        goto CallListSendMessage;
        break;

    case CB_GETLBTEXTLEN:

        /*
         * wParam - index to string
         * lParam - now used for cbANSI
         */
        message = LB_GETTEXTLEN;
        goto CallListSendMessage;
        break;

    case CB_INSERTSTRING:

        /*
         * wParam - position to receive the string
         * lParam - points to the string
         */
        if (!pcbox->fCase)
            message = LB_INSERTSTRING;
        else
            message = (pcbox->fCase & UPPERCASE) ? LB_INSERTSTRINGUPPER : LB_INSERTSTRINGLOWER;
        goto CallListSendMessage;
        break;

    case CB_RESETCONTENT:

        /*
         * wParam - not used
         * lParam - not used
         * If we come here before WM_CREATE has been processed,
         * pcbox->spwndList will be NULL.
         */
        UserAssert(pcbox->spwndList);
        ThreadLock(pcbox->spwndList, &tlpwndList);
        SendMessageWorker(pcbox->spwndList, LB_RESETCONTENT, 0, 0, FALSE);
        ThreadUnlock(&tlpwndList);
        xxxCBInternalUpdateEditWindow(pcbox, NULL);
        break;

    case CB_GETHORIZONTALEXTENT:
        message = LB_GETHORIZONTALEXTENT;
        goto CallListSendMessage;

    case CB_SETHORIZONTALEXTENT:
        message = LB_SETHORIZONTALEXTENT;
        goto CallListSendMessage;

    case CB_FINDSTRING:

        /*
         * wParam - index of starting point for search
         * lParam - points to prefix string
         */
        message = LB_FINDSTRING;
        goto CallListSendMessage;
        break;

    case CB_FINDSTRINGEXACT:

        /*
         * wParam - index of starting point for search
         * lParam - points to a exact string
         */
        message = LB_FINDSTRINGEXACT;
        goto CallListSendMessage;
        break;

    case CB_SELECTSTRING:

        /*
         * wParam - index of starting point for search
         * lParam - points to prefix string
         */
        UserAssert(pcbox->spwndList);
        ThreadLock(pcbox->spwndList, &tlpwndList);
        lParam = SendMessageWorker(pcbox->spwndList, LB_SELECTSTRING,
                wParam, lParam, fAnsi);
        ThreadUnlock(&tlpwndList);
        xxxCBInternalUpdateEditWindow(pcbox, NULL);
        return lParam;

    case CB_SETCURSEL:

        /*
         * wParam - Contains index to be selected
         * lParam - not used
         * If we come here before WM_CREATE has been processed,
         * pcbox->spwndList will be NULL.
         */

        UserAssert(pcbox->spwndList);

        ThreadLock(pcbox->spwndList, &tlpwndList);
        lParam = SendMessageWorker(pcbox->spwndList, LB_SETCURSEL, wParam, lParam, FALSE);
        if (lParam != -1) {
            SendMessageWorker(pcbox->spwndList, LB_SETTOPINDEX, wParam, 0, FALSE);
        }
        ThreadUnlock(&tlpwndList);
        xxxCBInternalUpdateEditWindow(pcbox, NULL);
        return lParam;

    case CB_GETITEMDATA:
        message = LB_GETITEMDATA;
        goto CallListSendMessage;
        break;

    case CB_SETITEMDATA:
        message = LB_SETITEMDATA;
        goto CallListSendMessage;
        break;

    case CB_SETITEMHEIGHT:
        if (wParam == -1) {
            if (HIWORD(lParam) != 0)
                return CB_ERR;
            return xxxCBSetEditItemHeight(pcbox, LOWORD(lParam));
        }

        message = LB_SETITEMHEIGHT;
        goto CallListSendMessage;
        break;

    case CB_GETITEMHEIGHT:
        if (wParam == -1)
            return pcbox->editrc.bottom - pcbox->editrc.top;

        message = LB_GETITEMHEIGHT;
        goto CallListSendMessage;
        break;

    case CB_SHOWDROPDOWN:

        /*
         * wParam - True then drop down the listbox if possible else hide it
         * lParam - not used
         */
        if (wParam && !pcbox->fLBoxVisible) {
            xxxCBShowListBoxWindow(pcbox, TRUE);
        } else {
            if (!wParam && pcbox->fLBoxVisible) {
                xxxCBHideListBoxWindow(pcbox, TRUE, FALSE);
            }
        }
        break;

    case CB_SETLOCALE:

        /*
         * wParam - locale id
         * lParam - not used
         */
        message = LB_SETLOCALE;
        goto CallListSendMessage;
        break;

    case CB_GETLOCALE:

        /*
         * wParam - not used
         * lParam - not used
         */
        message = LB_GETLOCALE;
        goto CallListSendMessage;
        break;

    case CB_GETCOMBOBOXINFO:
        return NtUserGetComboBoxInfo(hwnd, (PCOMBOBOXINFO)lParam);

    case WM_MEASUREITEM:
    case WM_DELETEITEM:
    case WM_DRAWITEM:
    case WM_COMPAREITEM:
        return xxxCBMessageItemHandler(pcbox, message, (LPVOID)lParam);

    case WM_NCCREATE:

        /*
         * wParam - Contains a handle to the window being created
         * lParam - Points to the CREATESTRUCT data structure for the window.
         */
        return CBNcCreateHandler(pcbox, pwnd);

    case WM_PARENTNOTIFY:
        if (LOWORD(wParam) == WM_DESTROY) {
            if ((HWND)lParam == HW(pcbox->spwndEdit)) {
                pcbox->CBoxStyle &= ~SEDITABLE;
                pcbox->fNoEdit = TRUE;
                pcbox->spwndEdit = pwnd;
            } else if ((HWND)lParam == HW(pcbox->spwndList)) {
                pcbox->CBoxStyle &= ~SDROPPABLE;
                pcbox->spwndList = NULL;
            }
        }
        break;

    case WM_UPDATEUISTATE:
        /*
         * Propagate the change to the list control, if any
         */
        UserAssert(pcbox->spwndList);
        ThreadLock(pcbox->spwndList, &tlpwndList);
        SendMessageWorker(pcbox->spwndList, WM_UPDATEUISTATE,
                          wParam, lParam, fAnsi);
        ThreadUnlock(&tlpwndList);
        goto CallDWP;

    case WM_HELP:
        {
            LPHELPINFO lpHelpInfo;

            /*
             * Check if this message is from a child of this combo
             */
            if ((lpHelpInfo = (LPHELPINFO)lParam) != NULL &&
                ((pcbox->spwndEdit && lpHelpInfo->iCtrlId == (SHORT)(PTR_TO_ID(pcbox->spwndEdit->spmenu))) ||
                 lpHelpInfo->iCtrlId == (SHORT)(PTR_TO_ID(pcbox->spwndList->spmenu)) )) {

                /*
                 * Make it look like the WM_HELP is coming form this combo.
                 * Then DefWindowProcWorker will pass it up to our parent,
                 * who can do whatever he wants with it.
                 */
                lpHelpInfo->iCtrlId = (SHORT)(PTR_TO_ID(pwnd->spmenu));
                lpHelpInfo->hItemHandle = hwnd;
                lpHelpInfo->dwContextId = GetContextHelpId(pwnd);
            }
        }
        /*
         * Fall through to DefWindowProc
         */

    default:

        if (SYSMET(PENWINDOWS) &&
                (message >= WM_PENWINFIRST && message <= WM_PENWINLAST))
            goto CallEditSendMessage;

CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }  /* switch (message) */

    return TRUE;

/*
 * The following forward messages off to the child controls.
 */
CallEditSendMessage:
    if (!pcbox->fNoEdit && pcbox->spwndEdit) {
        /*
         * pcbox->spwndEdit will be NULL if we haven't done WM_CREATE yet!
         */
        ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
        lReturn = SendMessageWorker(pcbox->spwndEdit, message,
                wParam, lParam, fAnsi);
        ThreadUnlock(&tlpwndEdit);
    }
    else {
        RIPERR0(ERROR_INVALID_COMBOBOX_MESSAGE, RIP_VERBOSE, "");
        lReturn = CB_ERR;
    }
    return lReturn;

CallListSendMessage:
    /*
     * pcbox->spwndList will be NULL if we haven't done WM_CREATE yet!
     */
    UserAssert(pcbox->spwndList);
    ThreadLock(pcbox->spwndList, &tlpwndList);
    lReturn = SendMessageWorker(pcbox->spwndList, message,
            wParam, lParam, fAnsi);
    ThreadUnlock(&tlpwndList);
    return lReturn;

}  /* ComboBoxWndProcWorker */


/***************************************************************************\
\***************************************************************************/

LRESULT WINAPI ComboBoxWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_COMBOBOX) &&
            !(SYSMET(PENWINDOWS) &&
                    (message >= WM_PENWINFIRST && message <= WM_PENWINLAST)))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, TRUE);

    return ComboBoxWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI ComboBoxWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_COMBOBOX) &&
            !(SYSMET(PENWINDOWS) &&
                    (message >= WM_PENWINFIRST && message <= WM_PENWINLAST)))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, FALSE);

    return ComboBoxWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}


/***************************************************************************\
* xxxCBMessageItemHandler
*
* Handles WM_DRAWITEM,WM_MEASUREITEM,WM_DELETEITEM,WM_COMPAREITEM
* messages from the listbox.
*
* History:
\***************************************************************************/

LRESULT xxxCBMessageItemHandler(
    PCBOX pcbox,
    UINT message,
    LPVOID lpfoo)  /* Actually can be any of the structs below */
{
    LRESULT lRet;
    TL tlpwndParent;

    CheckLock(pcbox->spwnd);

    /*
     * Send the <foo>item message back to the application after changing some
     * parameters to their combo box specific versions.
     */
    ((LPMEASUREITEMSTRUCT)lpfoo)->CtlType = ODT_COMBOBOX;
    ((LPMEASUREITEMSTRUCT)lpfoo)->CtlID = PtrToUlong(pcbox->spwnd->spmenu);
    if (message == WM_DRAWITEM)
        ((LPDRAWITEMSTRUCT)lpfoo)->hwndItem = HWq(pcbox->spwnd);
    else if (message == WM_DELETEITEM)
        ((LPDELETEITEMSTRUCT)lpfoo)->hwndItem = HWq(pcbox->spwnd);
    else if (message == WM_COMPAREITEM)
        ((LPCOMPAREITEMSTRUCT)lpfoo)->hwndItem = HWq(pcbox->spwnd);

    ThreadLock(pcbox->spwndParent, &tlpwndParent);
    lRet = SendMessage(HW(pcbox->spwndParent), message,
            (WPARAM)pcbox->spwnd->spmenu, (LPARAM)lpfoo);
    ThreadUnlock(&tlpwndParent);

    return lRet;
}


/***************************************************************************\
* xxxCBPaint
*
* History:
\***************************************************************************/

void xxxCBPaint(
    PCBOX pcbox,
    HDC hdc)
{
    RECT rc;
    UINT msg;
    HBRUSH hbr;

    CheckLock(pcbox->spwnd);

    rc.left = rc.top = 0;
    rc.right = pcbox->cxCombo;
    rc.bottom = pcbox->cyCombo;
    if (pcbox->f3DCombo)
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
    else
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST | BF_FLAT | BF_MONO);

    if (pcbox->buttonrc.left != 0) {
    // Draw in the dropdown arrow button
        DrawFrameControl(hdc, KPRECT_TO_PRECT(&pcbox->buttonrc), DFC_SCROLL,
            DFCS_SCROLLCOMBOBOX |
            (pcbox->fButtonPressed ? DFCS_PUSHED | DFCS_FLAT : 0) |
            (TestWF(pcbox->spwnd, WFDISABLED) ? DFCS_INACTIVE : 0));
#ifdef COLOR_HOTTRACKING
            (pcbox->fButtonHotTracked ? DFCS_HOT: 0)));
#endif // COLOR_HOTTRACKING
        if (pcbox->fRightAlign )
            rc.left = pcbox->buttonrc.right;
        else
            rc.right = pcbox->buttonrc.left;
    }

    // Erase the background behind the edit/static item.  Since a combo
    // is an edit field/list box hybrid, we use the same coloring
    // conventions.
    msg = WM_CTLCOLOREDIT;
    if (TestWF(pcbox->spwnd, WFWIN40COMPAT)) {
        if (TestWF(pcbox->spwnd, WFDISABLED) ||
            (!pcbox->fNoEdit && pcbox->spwndEdit && TestWF(pcbox->spwndEdit, EFREADONLY)))
            msg = WM_CTLCOLORSTATIC;
    } else
        msg = WM_CTLCOLORLISTBOX;

    hbr = GetControlBrush(HWq(pcbox->spwnd), hdc, msg);

    if (pcbox->fNoEdit)
        xxxCBInternalUpdateEditWindow(pcbox, hdc);
    else
        FillRect(hdc, &rc, hbr);
}


/***************************************************************************\
* xxxCBCommandHandler
*
* Check the various notification codes from the controls and do the
* proper thing.
* always returns 0L
*
* History:
\***************************************************************************/

long xxxCBCommandHandler(
    PCBOX pcbox,
    DWORD wParam,
    HWND hwndControl)
{

    CheckLock(pcbox->spwnd);

    /*
     * Check the edit control notification codes.  Note that currently, edit
     * controls don't send EN_KILLFOCUS messages to the parent.
     */
    if (!pcbox->fNoEdit &&
            SAMEWOWHANDLE(hwndControl, HWq(pcbox->spwndEdit))) {

        /*
         * Edit control notification codes
         */
        switch (HIWORD(wParam)) {
        case EN_SETFOCUS:
            if (!pcbox->fFocus) {

                /*
                 * The edit control has the focus for the first time which means
                 * this is the first time the combo box has received the focus
                 * and the parent must be notified that we have the focus.
                 */
                xxxCBGetFocusHelper(pcbox);
            }
            break;

        case EN_CHANGE:
            xxxCBNotifyParent(pcbox, CBN_EDITCHANGE);
            xxxCBUpdateListBoxWindow(pcbox, FALSE);
            break;

        case EN_UPDATE:
            xxxCBNotifyParent(pcbox, CBN_EDITUPDATE);
            break;

        case EN_ERRSPACE:
            xxxCBNotifyParent(pcbox, CBN_ERRSPACE);
            break;
        }
    }

    /*
     * Check listbox control notification codes
     */
    if (SAMEWOWHANDLE(hwndControl, HWq(pcbox->spwndList))) {

        /*
         * Listbox control notification codes
         */
        switch ((int)HIWORD(wParam)) {
        case LBN_DBLCLK:
            xxxCBNotifyParent(pcbox, CBN_DBLCLK);
            break;

        case LBN_ERRSPACE:
            xxxCBNotifyParent(pcbox, CBN_ERRSPACE);
            break;

        case LBN_SELCHANGE:
        case LBN_SELCANCEL:
            if (!pcbox->fKeyboardSelInListBox) {

                /*
                 * If the selchange is caused by the user keyboarding through,
                 * we don't want to hide the listbox.
                 */
                if (!xxxCBHideListBoxWindow(pcbox, TRUE, TRUE))
                    return(0L);
            } else {
                pcbox->fKeyboardSelInListBox = FALSE;
            }

            xxxCBNotifyParent(pcbox, CBN_SELCHANGE);
            xxxCBInternalUpdateEditWindow(pcbox, NULL);
        
            /*
             * If this combobox doesn't have an edit control, it needs to send
             * this notification itself when the user is cycling through the
             * items with the keyboard.
             * See bug #54766.
             */
            if (pcbox->fNoEdit) {
                NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, HWq(pcbox->spwnd), OBJID_CLIENT, INDEX_COMBOBOX);
            }
            break;
        }
    }

    return 0L;
}


/***************************************************************************\
* xxxCBNotifyParent
*
* Sends the notification code to the parent of the combo box control
*
* History:
\***************************************************************************/

void xxxCBNotifyParent(
    PCBOX pcbox,
    short notificationCode)
{
    PWND pwndParent;            // Parent if it exists
    TL tlpwndParent;

    CheckLock(pcbox->spwnd);

    if (pcbox->spwndParent)
        pwndParent = pcbox->spwndParent;
    else
        pwndParent = pcbox->spwnd;

    /*
     * wParam contains Control ID and notification code.
     * lParam contains Handle to window
     */
    ThreadLock(pwndParent, &tlpwndParent);
    SendMessageWorker(pwndParent, WM_COMMAND,
            MAKELONG(PTR_TO_ID(pcbox->spwnd->spmenu), notificationCode),
            (LPARAM)HWq(pcbox->spwnd), FALSE);
    ThreadUnlock(&tlpwndParent);
}

/***************************************************************************\
*
*
* Completes the text in the edit box with the closest match from the
* listbox.  If a prefix match can't be found, the edit control text isn't
* updated. Assume a DROPDOWN style combo box.
*
*
* History:
\***************************************************************************/
void xxxCBCompleteEditWindow(
    PCBOX pcbox)
{
    int cchText;
    int cchItemText;
    int itemNumber;
    LPWSTR pText;
    TL tlpwndEdit;
    TL tlpwndList;

    CheckLock(pcbox->spwnd);

    /*
     * Firstly check the edit control.
     */
    if (pcbox->spwndEdit == NULL) {
        return;
    }

    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
    ThreadLock(pcbox->spwndList, &tlpwndList);

    /*
     * +1 for null terminator
     */
    cchText = (int)SendMessageWorker(pcbox->spwndEdit, WM_GETTEXTLENGTH, 0, 0, FALSE);

    if (cchText) {
        cchText++;
        if (!(pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR))))
            goto Unlock;

        /*
         * We want to be sure to free the above allocated memory even if
         * the client dies during callback (xxx) or some of the following
         * window revalidation fails.
         */
        try {
            SendMessageWorker(pcbox->spwndEdit, WM_GETTEXT, cchText, (LPARAM)pText, FALSE);
            itemNumber = (int)SendMessageWorker(pcbox->spwndList,
                    LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pText, FALSE);
            if (itemNumber == -1)
                itemNumber = (int)SendMessageWorker(pcbox->spwndList,
                        LB_FINDSTRING, (WPARAM)-1, (LPARAM)pText, FALSE);
        } finally {
            UserLocalFree((HANDLE)pText);
        }

        if (itemNumber == -1) {

            /*
             * No close match.  Blow off.
             */
            goto Unlock;
        }

        cchItemText = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXTLEN,
                itemNumber, 0, FALSE);
        if (cchItemText) {
            cchItemText++;
            if (!(pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchItemText*sizeof(WCHAR))))
                goto Unlock;

            /*
             * We want to be sure to free the above allocated memory even if
             * the client dies during callback (xxx) or some of the following
             * window revalidation fails.
             */
            try {
                SendMessageWorker(pcbox->spwndList, LB_GETTEXT,
                        itemNumber, (LPARAM)pText, FALSE);
                SendMessageWorker(pcbox->spwndEdit, WM_SETTEXT,
                        0, (LPARAM)pText, FALSE);
            } finally {
                UserLocalFree((HANDLE)pText);
            }

            SendMessageWorker(pcbox->spwndEdit, EM_SETSEL, 0, MAXLONG, !!TestWF(pcbox->spwnd, WFANSIPROC));
        }
    }

Unlock:
    ThreadUnlock(&tlpwndList);
    ThreadUnlock(&tlpwndEdit);
}


/***************************************************************************\
* xxxCBHideListBoxWindow
*
* Hides the dropdown listbox window if it is a dropdown style.
*
* History:
\***************************************************************************/

BOOL xxxCBHideListBoxWindow(
    PCBOX pcbox,
    BOOL fNotifyParent,
    BOOL fSelEndOK)
{
    HWND hwnd = HWq(pcbox->spwnd);
    HWND hwndList = HWq(pcbox->spwndList);
    TL tlpwndList;


    CheckLock(pcbox->spwnd);

    // For 3.1+ apps, send CBN_SELENDOK to all types of comboboxes but only
    // allow CBN_SELENDCANCEL to be sent for droppable comboboxes
    if (fNotifyParent && TestWF(pcbox->spwnd, WFWIN31COMPAT) &&
        ((pcbox->CBoxStyle & SDROPPABLE) || fSelEndOK)) {
        if (fSelEndOK)
        {
            xxxCBNotifyParent(pcbox, CBN_SELENDOK);
        }
        else
        {
            xxxCBNotifyParent(pcbox, CBN_SELENDCANCEL);
        }
        if (!IsWindow(hwnd))
            return(FALSE);
    }

    /*
     * return, we don't hide simple combo boxes.
     */
    if (!(pcbox->CBoxStyle & SDROPPABLE)) {
        return TRUE;
    }

    /*
     * Send a faked buttonup message to the listbox so that it can release
     * the capture and all.
     */
    ThreadLock(pcbox->spwndList, &tlpwndList);

    SendMessageWorker(pcbox->spwndList, LBCB_ENDTRACK, fSelEndOK, 0, FALSE);

    if (pcbox->fLBoxVisible) {
        WORD swpFlags = SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE;

        if (!TestWF(pcbox->spwnd, WFWIN31COMPAT))
            swpFlags |= SWP_FRAMECHANGED;

        pcbox->fLBoxVisible = FALSE;

        /*
         * Hide the listbox window
         */
        NtUserShowWindow(hwndList, SW_HIDE);

        //
        // Invalidate the item area now since SWP() might update stuff.
        // Since the combo is CS_VREDRAW/CS_HREDRAW, a size change will
        // redraw the whole thing, including the item rect.  But if it
        // isn't changing size, we still want to redraw the item anyway
        // to show focus/selection.
        //
        if (!(pcbox->CBoxStyle & SEDITABLE))
            NtUserInvalidateRect(hwnd, KPRECT_TO_PRECT(&pcbox->editrc), TRUE);

        NtUserSetWindowPos(hwnd, HWND_TOP, 0, 0,
                pcbox->cxCombo, pcbox->cyCombo, swpFlags);

        // In case size didn't change
        UpdateWindow(hwnd);

        if (pcbox->CBoxStyle & SEDITABLE) {
            xxxCBCompleteEditWindow(pcbox);
        }

        if (fNotifyParent) {

            /*
             * Notify parent we will be popping up the combo box.
             */
            xxxCBNotifyParent(pcbox, CBN_CLOSEUP);
            if (!IsWindow(hwnd))
                return(FALSE);
        }
    }

    ThreadUnlock(&tlpwndList);

    return(TRUE);
}

/***************************************************************************\
* xxxCBShowListBoxWindow
*
* Lowers the dropdown listbox window.
*
* History:
\***************************************************************************/

void xxxCBShowListBoxWindow(
    PCBOX pcbox, BOOL fTrack)
{
    RECT        editrc;
    int         itemNumber;
    int         iHeight;
    int         yTop;
    DWORD       dwMult;
    int         cyItem;
    HWND        hwnd = HWq(pcbox->spwnd);
    HWND        hwndList = HWq(pcbox->spwndList);
    BOOL        fAnimPos;
    TL          tlpwndList;
    PMONITOR    pMonitor;

    //
    // THIS FUNCTION IS ONLY CALLED FOR DROPPABLE LIST COMBOBOXES
    //
    UserAssert(pcbox->CBoxStyle & SDROPPABLE);

    CheckLock(pcbox->spwnd);

    ThreadLock(pcbox->spwndList, &tlpwndList);

    /*
     * Notify parent we will be dropping down the combo box.
     */

    xxxCBNotifyParent(pcbox, CBN_DROPDOWN);
    /*
     * Invalidate the button rect so that the depressed arrow is drawn.
     */
    NtUserInvalidateRect(hwnd, KPRECT_TO_PRECT(&pcbox->buttonrc), TRUE);

    pcbox->fLBoxVisible = TRUE;

    if (pcbox->CBoxStyle == SDROPDOWN) {

        /*
         * If an item in the listbox matches the text in the edit control,
         * scroll it to the top of the listbox.  Select the item only if the
         * mouse button isn't down otherwise we will select the item when the
         * mouse button goes up.
         */
        xxxCBUpdateListBoxWindow(pcbox, !pcbox->fMouseDown);
        if (!pcbox->fMouseDown)
            xxxCBCompleteEditWindow(pcbox);
    } else {

        /*
         * Scroll the currently selected item to the top of the listbox.
         */
        itemNumber = (int)SendMessageWorker(pcbox->spwndList, LB_GETCURSEL,
                0, 0, FALSE);
        if (itemNumber == -1) {
            itemNumber = 0;
        }
        SendMessageWorker(pcbox->spwndList, LB_SETTOPINDEX, itemNumber, 0, FALSE);
        SendMessageWorker(pcbox->spwndList, LBCB_CARETON, 0, 0, FALSE);

        /*
         * We need to invalidate the edit rect so that the focus frame/invert
         * will be turned off when the listbox is visible.  Tandy wants this for
         * his typical reasons...
         */
        NtUserInvalidateRect(hwnd, KPRECT_TO_PRECT(&pcbox->editrc), TRUE);
    }

    //
    // Figure out where to position the dropdown listbox.  We want it just
    // touching the edge around the edit rectangle.  Note that since the
    // listbox is a popup, we need the position in screen coordinates.
    //

    // We want the dropdown to pop below or above the combo

    // Get screen coords
    editrc.left   = pcbox->spwnd->rcWindow.left;
    editrc.top    = pcbox->spwnd->rcWindow.top;
    editrc.right  = pcbox->spwnd->rcWindow.left + pcbox->cxCombo;
    editrc.bottom = pcbox->spwnd->rcWindow.top  + pcbox->cyCombo;

    // List area
    cyItem = (int)SendMessageWorker(pcbox->spwndList, LB_GETITEMHEIGHT, 0, 0, FALSE);

    if (cyItem == 0) {
        // Make sure that it's not 0
        RIPMSG0( RIP_WARNING, "LB_GETITEMHEIGHT is returning 0\n" );

        cyItem = gpsi->cySysFontChar;
    }

    //  we shoulda' just been able to use cyDrop here, but thanks to VB's need
    //  to do things their OWN SPECIAL WAY, we have to keep monitoring the size
    //  of the listbox 'cause VB changes it directly (jeffbog 03/21/94)
    iHeight = max(pcbox->cyDrop, pcbox->spwndList->rcWindow.bottom -
                                 pcbox->spwndList->rcWindow.top);

    if (dwMult = (DWORD)SendMessageWorker(pcbox->spwndList, LB_GETCOUNT, 0, 0, FALSE)) {
        dwMult = (DWORD)(LOWORD(dwMult) * cyItem);
        dwMult += SYSMET(CYEDGE);

        if (dwMult < 0x7FFF)
            iHeight = min(LOWORD(dwMult), iHeight);
    }

    if (!TestWF(pcbox->spwnd, CBFNOINTEGRALHEIGHT)) {
        UserAssert(cyItem);
        iHeight = ((iHeight - SYSMET(CYEDGE)) / cyItem) * cyItem + SYSMET(CYEDGE);
    }

    //
    // Other 1/2 of old app combo fix.  Make dropdown overlap combo window
    // a little.  That way we can have a chance of invalidating the overlap
    // and causing a repaint to help out Publisher 2.0's toolbar combos.
    // See comments for PressButton() above.
    //
    pMonitor = _MonitorFromWindow(pcbox->spwnd, MONITOR_DEFAULTTOPRIMARY);
    if (editrc.bottom + iHeight <= pMonitor->rcMonitor.bottom) {
        yTop = editrc.bottom;
        if (!pcbox->f3DCombo)
            yTop -= SYSMET(CYBORDER);

        fAnimPos = TRUE;
    } else {
        yTop = max(editrc.top - iHeight, pMonitor->rcMonitor.top);
        if (!pcbox->f3DCombo)
            yTop += SYSMET(CYBORDER);

        fAnimPos = FALSE;
    }

    if ( ! TestWF( pcbox->spwnd, WFWIN40COMPAT) )
    {
      // fix for Winword B#7504, Combo-ListBox text gets
      // truncated by a small width, this is do to us
      // now setting size here in SetWindowPos, rather than
      // earlier where we did this in Win3.1

      if ( (pcbox->spwndList->rcWindow.right - pcbox->spwndList->rcWindow.left ) >
            pcbox->cxDrop )

            pcbox->cxDrop = pcbox->spwndList->rcWindow.right - pcbox->spwndList->rcWindow.left;
    }

    NtUserSetWindowPos(hwndList, HWND_TOPMOST, editrc.left,
        yTop, max(pcbox->cxDrop, pcbox->cxCombo), iHeight, SWP_NOACTIVATE);

    /*
     * Get any drawing in the combo box window out of the way so it doesn't
     * invalidate any of the SPB underneath the list window.
     */
    UpdateWindow(hwnd);

    if (!(TEST_EffectPUSIF(PUSIF_COMBOBOXANIMATION))
        || (GetAppCompatFlags2(VER40) & GACF2_ANIMATIONOFF)) {
        NtUserShowWindow(hwndList, SW_SHOWNA);
    } else {
        AnimateWindow(hwndList, CMS_QANIMATION, (fAnimPos ? AW_VER_POSITIVE :
                AW_VER_NEGATIVE) | AW_SLIDE);
    }

#ifdef LATER
//
// we don't have sys modal windows.
//
    if (pwndSysModal) {

        /*
         * If this combo is in a system modal dialog box, we need to explicitly
         * call update window otherwise we won't automatically send paint
         * messages to the toplevel listbox window.  This is especially
         * noticeable in the File Open/Save sys modal dlgs which are put up at
         * ExitWindows time.
         */
        UpdateWindow(hwndList);
    }
#endif

    /*
     * Restart search buffer from first char
     */
    {
    PLBIV plb = ((PLBWND)pcbox->spwndList)->pLBIV;

        if ((plb != NULL) && (plb != (PLBIV)-1)) {
            plb->iTypeSearch = 0;
        }
    }

    if (fTrack && TestWF(pcbox->spwnd, WFWIN40COMPAT))
        SendMessageWorker(pcbox->spwndList, LBCB_STARTTRACK, FALSE, 0, FALSE);

    ThreadUnlock(&tlpwndList);
}

/***************************************************************************\
* xxxCBInternalUpdateEditWindow
*
* Updates the editcontrol/statictext window so that it contains the text
* given by the current selection in the listbox.  If the listbox has no
* selection (ie. -1), then we erase all the text in the editcontrol.
*
* hdcPaint is from WM_PAINT messages Begin/End Paint hdc. If null, we should
* get our own dc.
*
* History:
\***************************************************************************/

void xxxCBInternalUpdateEditWindow(
    PCBOX pcbox,
    HDC hdcPaint)
{
    int cchText = 0;
    LPWSTR pText = NULL;
    int sItem;
    HDC hdc;
    UINT msg;
    HBRUSH hbrSave;
    HBRUSH hbrControl;
    HANDLE hOldFont;
    DRAWITEMSTRUCT dis;
    RECT rc;
    HWND hwnd = HWq(pcbox->spwnd);
    TL tlpwndList;
    TL tlpwndEdit;
    TL tlpwndParent;

    CheckLock(pcbox->spwnd);

    /* This check is also commented out in Win3.1 and Win95 */
    // if (!TestWF(pcbox->spwnd, WFVISIBLE)) {
    //    return;
    // }

    ThreadLock(pcbox->spwndParent, &tlpwndParent);
    ThreadLock(pcbox->spwndList, &tlpwndList);
    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);

    sItem = (int)SendMessageWorker(pcbox->spwndList, LB_GETCURSEL, 0, 0, FALSE);

    /*
     * This 'try-finally' block ensures that the allocated 'pText' will
     * be freed no matter how this routine is exited.
     */
    try {
        if (sItem != -1) {
            cchText = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXTLEN,
                    (DWORD)sItem, 0, FALSE);
            if ((pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, (cchText+1) * sizeof(WCHAR)))) {
                cchText = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXT,
                        (DWORD)sItem, (LPARAM)pText, FALSE);
            }
        }

        if (!pcbox->fNoEdit) {

            if (pcbox->spwndEdit) {
                if (TestWF(pcbox->spwnd, CBFHASSTRINGS))
                    SetWindowText(HWq(pcbox->spwndEdit), pText ? pText : TEXT(""));

                if (pcbox->fFocus) {
                    /*
                     * Only hilite the text if we have the focus.
                     */
                    SendMessageWorker(pcbox->spwndEdit, EM_SETSEL, 0, MAXLONG, !!TestWF(pcbox->spwnd, WFANSIPROC));
                }
            }
        } else if (IsComboVisible(pcbox)) {
            if (hdcPaint) {
                hdc = hdcPaint;
            } else {
                hdc = NtUserGetDC(hwnd);
            }

            SetBkMode(hdc, OPAQUE);
            if (TestWF(pcbox->spwnd, WFWIN40COMPAT)) {
                if (TestWF(pcbox->spwnd, WFDISABLED))
                    msg = WM_CTLCOLORSTATIC;
                else
                    msg = WM_CTLCOLOREDIT;
            } else
                msg = WM_CTLCOLORLISTBOX;

            hbrControl = GetControlBrush(hwnd, hdc, msg);
            hbrSave = SelectObject(hdc, hbrControl);

            CopyInflateRect(&rc, KPRECT_TO_PRECT(&pcbox->editrc), SYSMET(CXBORDER), SYSMET(CYBORDER));
            PatBlt(hdc, rc.left, rc.top, rc.right - rc.left,
                rc.bottom - rc.top, PATCOPY);
            InflateRect(&rc, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

            if (pcbox->fFocus && !pcbox->fLBoxVisible) {
                //
                // Fill in the selected area
                //


                // only do the FillRect if we know its not
                // ownerdraw item, otherwise we mess up people up
                // BUT: for Compat's sake we still do this for Win 3.1 guys

                if (!TestWF( pcbox->spwnd, WFWIN40COMPAT) || !pcbox->OwnerDraw)
                    FillRect(hdc, &rc, SYSHBR(HIGHLIGHT));

                SetBkColor(hdc, SYSRGB(HIGHLIGHT));
                SetTextColor(hdc, SYSRGB(HIGHLIGHTTEXT));
            } else if (TestWF(pcbox->spwnd, WFDISABLED) && !pcbox->OwnerDraw) {
                if ((COLORREF)SYSRGB(GRAYTEXT) != GetBkColor(hdc))
                    SetTextColor(hdc, SYSRGB(GRAYTEXT));
            }

            if (pcbox->hFont != NULL)
                hOldFont = SelectObject(hdc, pcbox->hFont);

            if (pcbox->OwnerDraw) {

                /*
                 * Let the app draw the stuff in the static text box.
                 */
                dis.CtlType = ODT_COMBOBOX;
                dis.CtlID = PtrToUlong(pcbox->spwnd->spmenu);
                dis.itemID = sItem;
                dis.itemAction = ODA_DRAWENTIRE;
                dis.itemState = (UINT)
                    ((pcbox->fFocus && !pcbox->fLBoxVisible ? ODS_SELECTED : 0) |
                    (TestWF(pcbox->spwnd, WFDISABLED) ? ODS_DISABLED : 0) |
                    (pcbox->fFocus && !pcbox->fLBoxVisible ? ODS_FOCUS : 0) |
                    (TestWF(pcbox->spwnd, WFWIN40COMPAT) ? ODS_COMBOBOXEDIT : 0) |
                    (TestWF(pcbox->spwnd, WEFPUIFOCUSHIDDEN) ? ODS_NOFOCUSRECT : 0) |
                    (TestWF(pcbox->spwnd, WEFPUIACCELHIDDEN) ? ODS_NOACCEL : 0));

                dis.hwndItem = hwnd;
                dis.hDC = hdc;
                CopyRect(&dis.rcItem, &rc);

                // Don't let ownerdraw dudes draw outside of the combo client
                // bounds.
                IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

                dis.itemData = (ULONG_PTR)SendMessageWorker(pcbox->spwndList,
                        LB_GETITEMDATA, (UINT)sItem, 0, FALSE);

                SendMessage(HW(pcbox->spwndParent), WM_DRAWITEM, dis.CtlID,
                        (LPARAM)&dis);
            } else {

                /*
                 * Start the text one pixel within the rect so that we leave a
                 * nice hilite border around the text.
                 */

                int x ;
                UINT align ;

                if (pcbox->fRightAlign ) {
                    align = TA_RIGHT;
                    x = rc.right - SYSMET(CXBORDER);
                } else {
                    x = rc.left + SYSMET(CXBORDER);
                    align = 0;
                }

                if (pcbox->fRtoLReading )
                    align |= TA_RTLREADING;

                if (align)
                    SetTextAlign(hdc, GetTextAlign(hdc) | align);

                // Draw the text, leaving a gap on the left & top for selection.
                ExtTextOut(hdc, x, rc.top + SYSMET(CYBORDER), ETO_CLIPPED | ETO_OPAQUE,
                       &rc, pText ? pText : TEXT(""), cchText, NULL);
                if (pcbox->fFocus && !pcbox->fLBoxVisible) {
                    if (!TestWF(pcbox->spwnd, WEFPUIFOCUSHIDDEN)) {
                        DrawFocusRect(hdc, &rc);
                    }
                }
            }

            if (pcbox->hFont && hOldFont) {
                SelectObject(hdc, hOldFont);
            }

            if (hbrSave) {
                SelectObject(hdc, hbrSave);
            }

            if (!hdcPaint) {
                NtUserReleaseDC(hwnd, hdc);
            }
        }

    } finally {
        if (pText != NULL)
            UserLocalFree((HANDLE)pText);
    }

    ThreadUnlock(&tlpwndEdit);
    ThreadUnlock(&tlpwndList);
    ThreadUnlock(&tlpwndParent);
}

/***************************************************************************\
* xxxCBInvertStaticWindow
*
* Inverts the static text/picture window associated with the combo
* box.  Gets its own hdc, if the one given is null.
*
* History:
\***************************************************************************/

void xxxCBInvertStaticWindow(
    PCBOX pcbox,
    BOOL fNewSelectionState,  /* True if inverted else false */
    HDC hdc)
{
    BOOL focusSave = pcbox->fFocus;

    CheckLock(pcbox->spwnd);

    pcbox->fFocus = (UINT)fNewSelectionState;
    xxxCBInternalUpdateEditWindow(pcbox, hdc);

    pcbox->fFocus = (UINT)focusSave;
}

/***************************************************************************\
* xxxCBUpdateListBoxWindow
*
* matches the text in the editcontrol. If fSelectionAlso is false, then we
* unselect the current listbox selection and just move the caret to the item
* which is the closest match to the text in the editcontrol.
*
* History:
\***************************************************************************/

void xxxCBUpdateListBoxWindow(
    PCBOX pcbox,
    BOOL fSelectionAlso)
{
    int cchText;
    int sItem, sSel;
    LPWSTR pText = NULL;
    TL tlpwndEdit;
    TL tlpwndList;

    if (pcbox->spwndEdit == NULL) {
        return;
    }

    CheckLock(pcbox->spwnd);

    ThreadLock(pcbox->spwndList, &tlpwndList);
    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);

    /*
     * +1 for null terminator
     */

    cchText = (int)SendMessageWorker(pcbox->spwndEdit, WM_GETTEXTLENGTH, 0, 0, FALSE);

    if (cchText) {
        cchText++;
        pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR));
        if (pText != NULL) {
            try {
                SendMessageWorker(pcbox->spwndEdit, WM_GETTEXT, cchText, (LPARAM)pText, FALSE);
                sItem = (int)SendMessageWorker(pcbox->spwndList, LB_FINDSTRING,
                        (WPARAM)-1L, (LPARAM)pText, FALSE);
            } finally {
                UserLocalFree((HANDLE)pText);
            }
        }
    }
    else
        sItem = -1;

    if (fSelectionAlso) {
        sSel = sItem;
    } else {
        sSel = -1;
    }

    if (sItem == -1)
    {
        sItem = 0;

        //
        // Old apps:  w/ editable combos, selected 1st item in list even if
        // it didn't match text in edit field.  This is not desirable
        // behavior for 4.0 dudes esp. with cancel allowed.  Reason:
        //      (1) User types in text that doesn't match list choices
        //      (2) User drops combo
        //      (3) User pops combo back up
        //      (4) User presses OK in dialog that does stuff w/ combo
        //          contents.
        // In 3.1, when the combo dropped, we'd select the 1st item anyway.
        // So the last CBN_SELCHANGE the owner got would be 0--which is
        // bogus because it really should be -1.  In fact if you type anything
        // into the combo afterwards it will reset itself to -1.
        //
        // 4.0 dudes won't get this bogus 0 selection.
        //
        if (fSelectionAlso && !TestWF(pcbox->spwnd, WFWIN40COMPAT))
            sSel = 0;
    }


    SendMessageWorker(pcbox->spwndList, LB_SETCURSEL, (DWORD)sSel, 0, FALSE);
    SendMessageWorker(pcbox->spwndList, LB_SETCARETINDEX, (DWORD)sItem, 0, FALSE);
    SendMessageWorker(pcbox->spwndList, LB_SETTOPINDEX, (DWORD)sItem, 0, FALSE);

    ThreadUnlock(&tlpwndEdit);
    ThreadUnlock(&tlpwndList);
}

/***************************************************************************\
* xxxCBGetFocusHelper
*
* Handles getting the focus for the combo box
*
* History:
\***************************************************************************/

void xxxCBGetFocusHelper(
    PCBOX pcbox)
{
    TL tlpwndList;
    TL tlpwndEdit;

    CheckLock(pcbox->spwnd);

    if (pcbox->fFocus)
        return;

    ThreadLock(pcbox->spwndList, &tlpwndList);
    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);

    /*
     * The combo box has gotten the focus for the first time.
     */

    /*
     * First turn on the listbox caret
     */

    if (pcbox->CBoxStyle == SDROPDOWNLIST)
       SendMessageWorker(pcbox->spwndList, LBCB_CARETON, 0, 0, FALSE);

    /*
     * and select all the text in the editcontrol or static text rectangle.
     */

    if (pcbox->fNoEdit) {

        /*
         * Invert the static text rectangle
         */
        xxxCBInvertStaticWindow(pcbox, TRUE, (HDC)NULL);
    } else if (pcbox->spwndEdit) {
        UserAssert(pcbox->spwnd);
        SendMessageWorker(pcbox->spwndEdit, EM_SETSEL, 0, MAXLONG, !!TestWF(pcbox->spwnd, WFANSIPROC));
    }

    pcbox->fFocus = TRUE;

    /*
     * Notify the parent we have the focus
     */
    xxxCBNotifyParent(pcbox, CBN_SETFOCUS);

    ThreadUnlock(&tlpwndEdit);
    ThreadUnlock(&tlpwndList);
}

/***************************************************************************\
* xxxCBKillFocusHelper
*
* Handles losing the focus for the combo box.
*
* History:
\***************************************************************************/

void xxxCBKillFocusHelper(
    PCBOX pcbox)
{
    TL tlpwndList;
    TL tlpwndEdit;

    CheckLock(pcbox->spwnd);

    if (!pcbox->fFocus || pcbox->spwndList == NULL)
        return;

    ThreadLock(pcbox->spwndList, &tlpwndList);
    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);

    /*
     * The combo box is losing the focus.  Send buttonup clicks so that
     * things release the mouse capture if they have it...  If the
     * pwndListBox is null, don't do anything.  This occurs if the combo box
     * is destroyed while it has the focus.
     */
    SendMessageWorker(pcbox->spwnd, WM_LBUTTONUP, 0L, 0xFFFFFFFFL, FALSE);
     if (!xxxCBHideListBoxWindow(pcbox, TRUE, FALSE))
         return;

    /*
     * Turn off the listbox caret
     */

    if (pcbox->CBoxStyle == SDROPDOWNLIST)
       SendMessageWorker(pcbox->spwndList, LBCB_CARETOFF, 0, 0, FALSE);

    if (pcbox->fNoEdit) {

        /*
         * Invert the static text rectangle
         */
        xxxCBInvertStaticWindow(pcbox, FALSE, (HDC)NULL);
    } else if (pcbox->spwndEdit) {
        SendMessageWorker(pcbox->spwndEdit, EM_SETSEL, 0, 0, !!TestWF(pcbox->spwnd, WFANSIPROC));
    }

    pcbox->fFocus = FALSE;
    xxxCBNotifyParent(pcbox, CBN_KILLFOCUS);

    ThreadUnlock(&tlpwndEdit);
    ThreadUnlock(&tlpwndList);
}


/***************************************************************************\
* xxxCBGetTextLengthHelper
*
* For the combo box without an edit control, returns size of current selected
* item
*
* History:
\***************************************************************************/

LONG xxxCBGetTextLengthHelper(
    PCBOX pcbox,
    BOOL fAnsi)
{
    int item;
    int cchText;
    TL tlpwndList;

    ThreadLock(pcbox->spwndList, &tlpwndList);
    item = (int)SendMessageWorker(pcbox->spwndList, LB_GETCURSEL, 0, 0, fAnsi);

    if (item == LB_ERR) {

        /*
         * No selection so no text.
         */
        cchText = 0;
    } else {
        cchText = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXTLEN,
                item, 0, fAnsi);
    }

    ThreadUnlock(&tlpwndList);

    return cchText;
}

/***************************************************************************\
* xxxCBGetTextHelper
*
* For the combo box without an edit control, copies cbString bytes of the
* string in the static text box to the buffer given by pString.
*
* History:
\***************************************************************************/

LONG xxxCBGetTextHelper(
    PCBOX pcbox,
    int cchString,
    LPWSTR pString,
    BOOL fAnsi)
{
    int item;
    int cchText;
    LPWSTR pText;
    DWORD dw;
    TL tlpwndList;

    CheckLock(pcbox->spwnd);

    if (!cchString || !pString)
        return 0;

    /*
     * Null the buffer to be nice.
     */
    if (fAnsi) {
        *((LPSTR)pString) = 0;
    } else {
        *((LPWSTR)pString) = 0;
    }

    ThreadLock(pcbox->spwndList, &tlpwndList);
    item = (int)SendMessageWorker(pcbox->spwndList, LB_GETCURSEL, 0, 0, fAnsi);

    if (item == LB_ERR) {

        /*
         * No selection so no text.
         */
        ThreadUnlock(&tlpwndList);
        return 0;
    }

    cchText = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXTLEN, item, 0, fAnsi);

    cchText++;
    if ((cchText <= cchString) ||
            (!TestWF(pcbox->spwnd, WFWIN31COMPAT) && cchString == 2)) {
        /*
         * Just do the copy if the given buffer size is large enough to hold
         * everything.  Or if old 3.0 app.  (Norton used to pass 2 & expect 3
         * chars including the \0 in 3.0; Bug #7018 win31: vatsanp)
         */
        dw = (int)SendMessageWorker(pcbox->spwndList, LB_GETTEXT, item,
                (LPARAM)pString, fAnsi);
        ThreadUnlock(&tlpwndList);
        return dw;
    }

    if (!(pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR)))) {

        /*
         * Bail.  Not enough memory to chop up the text.
         */
        ThreadUnlock(&tlpwndList);
        return 0;
    }

    try {
        SendMessageWorker(pcbox->spwndList, LB_GETTEXT, item, (LPARAM)pText, fAnsi);
        if (fAnsi) {
            RtlCopyMemory((PBYTE)pString, (PBYTE)pText, cchString);
            ((LPSTR)pString)[cchString - 1] = 0;
        } else {
            RtlCopyMemory((PBYTE)pString, (PBYTE)pText, cchString * sizeof(WCHAR));
            ((LPWSTR)pString)[cchString - 1] = 0;
        }
    } finally {
        UserLocalFree((HANDLE)pText);
    }

    ThreadUnlock(&tlpwndList);
    return cchString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\cltxt.h ===
/**************************************************************************\
* Module Name: cltxt.h
*
* Neutral Client/Server call related routines involving text.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 04-Dec-90
*
* History:
*   04-Dec-90 created by SMeans
*
\**************************************************************************/

#ifdef UNICODE
  #define IS_ANSI FALSE
#else
  #define IS_ANSI TRUE
  #if IS_ANSI != CW_FLAGS_ANSI
  # error("IS_ANSI != CW_FLAGS_ANSI)
  #endif
#endif
#include "ntsend.h"
#include "powrprofp.h"

/***************************************************************************\
* CreateWindowEx (API)
*
* A complete Thank cannot be generated for CreateWindowEx because its last
* parameter (lpParam) is polymorphic depending on the window's class.  If
* the window class is "MDIClient" then lpParam points to a CLIENTCREATESTRUCT.
*
* History:
* 04-23-91 DarrinM      Created.
* 04-Feb-92 IanJa       Unicode/ANSI neutral
\***************************************************************************/

#ifdef UNICODE
FUNCLOG12(LOG_GENERAL, HWND, WINAPI, CreateWindowExW, DWORD, dwExStyle, LPCTSTR, lpClassName, LPCTSTR, lpWindowName, DWORD, dwStyle, int, X, int, Y, int, nWidth, int, nHeight, HWND, hWndParent, HMENU, hMenu, HINSTANCE, hModule, LPVOID, lpParam)
#else
FUNCLOG12(LOG_GENERAL, HWND, WINAPI, CreateWindowExA, DWORD, dwExStyle, LPCTSTR, lpClassName, LPCTSTR, lpWindowName, DWORD, dwStyle, int, X, int, Y, int, nWidth, int, nHeight, HWND, hWndParent, HMENU, hMenu, HINSTANCE, hModule, LPVOID, lpParam)
#endif // UNICODE
HWND WINAPI CreateWindowEx(
    DWORD dwExStyle,
    LPCTSTR lpClassName,
    LPCTSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hModule,
    LPVOID lpParam)
{

#if 0
    /*
     * We use some of the undocumented bits in dwExStyle to mark a window
     * with certain attributes.  Make sure this bits aren't turned on by
     * the app
     */
    dwExStyle &= ~(WS_EX_MDICHILD | WS_EX_ANSICREATOR);
#endif

#if TEST_DUSER_WMH
    //
    // TEMPORARY:
    // Force test DirectUser's MessagePumpHook's
    //

    PCLIENTINFO pci = GetClientInfo();

    if ((pci != NULL) &&
            ((pci->dwTIFlags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD | TIF_RESTRICTED)) == 0)) {

        PCLIENTTHREADINFO pcti = GETCLIENTTHREADINFO();
        if ((pcti != NULL) && (pcti->cMessagePumpHooks == 0)) {
            HINSTANCE hinst = LoadLibrary(TEXT("duser.dll"));
            if (hinst != NULL) {
                InitGadgetsProc pfnInit = (InitGadgetsProc) GetProcAddress(hinst, "InitGadgets");
                if (pfnInit != NULL) {
                    INITGADGET ig;

                    UserAssertMsg0(g_hctx == NULL, "DirectUser should not already be initialized");

                    ZeroMemory(&ig, sizeof(ig));
                    ig.cbSize       = sizeof(ig);
                    ig.nThreadMode  = IGTM_SEPARATE;
                    ig.nMsgMode     = IGMM_STANDARD;

                    g_hctx = (pfnInit)(&ig);
                }
            }
        }
    }
#endif


    return _CreateWindowEx(dwExStyle, lpClassName, lpWindowName,
                dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu,
                hModule, lpParam, IS_ANSI | CW_FLAGS_VERSIONCLASS);
}

/***************************************************************************\
* fnHkINLPCWPSTRUCT
*
* This gets thunked through the message thunks, so it has the format
* of a c/s message thunk call.
*
* 05-09-91 ScottLu      Created.
* 04-Feb-92 IanJa       Unicode/ANSI neutral
\***************************************************************************/

LRESULT TEXT_FN(fnHkINLPCWPSTRUCT)(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    CWPSTRUCT cwp;

    cwp.hwnd = HW(pwnd);
    cwp.message = message;
    cwp.wParam = wParam;
    cwp.lParam = lParam;

    return TEXT_FN(DispatchHook)(MAKELONG(HC_ACTION, WH_CALLWNDPROC),
            (GetClientInfo()->CI_flags & CI_INTERTHREAD_HOOK) != 0,
            (LPARAM)&cwp, (HOOKPROC)xParam);
}

LRESULT TEXT_FN(fnHkINLPCWPRETSTRUCT)(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    CWPRETSTRUCT cwp;
    PCLIENTINFO pci = GetClientInfo();

    cwp.hwnd = HW(pwnd);
    cwp.message = message;
    cwp.wParam = wParam;
    cwp.lParam = lParam;
    cwp.lResult = KERNEL_LRESULT_TO_LRESULT(pci->dwHookData);

    return TEXT_FN(DispatchHook)(MAKELONG(HC_ACTION, WH_CALLWNDPROCRET),
            (GetClientInfo()->CI_flags & CI_INTERTHREAD_HOOK) != 0,
            (LPARAM)&cwp, (HOOKPROC)xParam);
}

/***************************************************************************\
* DispatchHook
*
* This routine exists simply to remember the hook type in the CTI structure
* so that later inside of CallNextHookEx we know how to thunk the hook
* call.
*
* 05-09-91 ScottLu      Created.
* 04-Feb-92 IanJa       Unicode/ANSI neutral
\***************************************************************************/

LRESULT TEXT_FN(DispatchHook)(
    int dw,
    WPARAM wParam,
    LPARAM lParam,
    HOOKPROC pfn)
{
    int dwHookSave;
    LRESULT nRet;
    PCLIENTINFO pci;
#if IS_ANSI
    WPARAM wParamSave;
#endif
    /* -FE-
     * * THIS VARIABLE SHOULD BE THREAD AWARE *
     */
    static EVENTMSG CachedEvent = {0,0,0,(DWORD)0,(HWND)0};

    /*
     * First save the current hook stored in the CTI structure in case we're
     * being recursed into. dw contains MAKELONG(nCode, nFilterType).
     */
    pci = GetClientInfo();
    dwHookSave = pci->dwHookCurrent;
    pci->dwHookCurrent = (dw & 0xFFFF0000) | IS_ANSI;

#if IS_ANSI       // TEXT_FN(DispatchHook)()
    if (IS_DBCS_ENABLED()) {
        PMSG pMsg;
        PEVENTMSG pEMsg;
        switch (HIWORD(dw)) {
        case WH_JOURNALPLAYBACK:
            switch (LOWORD(dw)) {
            case HC_SKIP:
                CachedEvent.message = 0;
                break;
            case HC_GETNEXT:
            case HC_NOREMOVE:
                pEMsg = (PEVENTMSG)lParam;
                if (CachedEvent.message != 0 && pEMsg != NULL) {
                    RtlCopyMemory((PEVENTMSG)lParam,&CachedEvent,sizeof(EVENTMSG));
                    return 0;
                }
                break;
            }
            break;
        case WH_MSGFILTER:
        case WH_SYSMSGFILTER:
        case WH_GETMESSAGE:
            pMsg = (PMSG)lParam;
            if (pMsg) {
                /*
                 * Save original message.
                 */
                wParamSave = pMsg->wParam;
                switch (pMsg->message) {
                case WM_CHAR:
                case EM_SETPASSWORDCHAR:
                    /*
                     * Here... pMsg->wParam contains..
                     *
                     * HIWORD(wParam)         = Information for DBCS messgaing.
                     * HIBYTE(LOWORD(wParam)) = Dbcs LeadingByte Byte.
                     * LOBYTE(LOWORD(wParam)) = Dbcs TrailingByte or Sbcs character.
                     *
                     */
                    if (pMsg->wParam & WMCR_IR_DBCSCHAR) {
                        /*
                         * Mask off DBCS messaging infomation area.
                         * (Look up only DBCS character code data).
                         */
                        pMsg->wParam &= 0x0000FFFF;
                    } else {
                        if (IS_DBCS_MESSAGE(LOWORD(pMsg->wParam))) {
                            PKERNEL_MSG pDbcsMsg = GetCallBackDbcsInfo();
                            /*
                             * Copy this message to CLIENTINFO for next GetMessage
                             * or PeekMesssage() call.
                             */
                            COPY_MSG_TO_KERNELMSG(pDbcsMsg,pMsg);
                            /*
                             * Only Dbcs Trailingbyte is nessesary for pushed message. we'll
                             * pass this message when GetMessage/PeekMessage is called at next.
                             */
                            pDbcsMsg->wParam = (WPARAM)((pMsg->wParam & 0x0000FF00) >> 8);
                            /*
                             * Return DbcsLeading byte to Apps.
                             */
                            pMsg->wParam = (WPARAM)(pMsg->wParam & 0x000000FF);
                        } else {
                            /*
                             * This is SBCS char, make sure it.
                             */
                            pMsg->wParam &= 0x000000FF;
                        }
                    }
                }
            } /* if (pMsg) */
        } /* switch (HIWORD(dw)) */
GetNextHookData:
        ;
    }
#endif // IS_ANSI

    /*
     * Call the hook. dw contains MAKELONG(nCode, nFilterType).
     */
    nRet = pfn(LOWORD(dw), wParam, lParam);

#if IS_ANSI   // TEXT_FN(DispatchHook)()
    if (IS_DBCS_ENABLED()) {
        PMSG pMsg;
        PEVENTMSG pEMsg;
        switch (HIWORD(dw)) {
        case WH_JOURNALPLAYBACK:
            switch (LOWORD(dw)) {
            case HC_GETNEXT:
            case HC_NOREMOVE:
                pEMsg = (PEVENTMSG)lParam;
                if ((nRet == 0) && pEMsg) {
                    WPARAM dwAnsi = LOWORD(pEMsg->paramL);
                    switch(pEMsg->message) {
                    case WM_CHAR:
                    case EM_SETPASSWORDCHAR:
                        /*
                         * Chech wParam is DBCS character or not.
                         */
                        if (IS_DBCS_MESSAGE((dwAnsi))) {
                            /*
                             * DO NOT NEED TO MARK FOR IR_DBCSCHAR
                             */
                        } else {
                            PBYTE pchDbcsCF = GetDispatchDbcsInfo();
                            /*
                             * If we have cached Dbcs LeadingByte character, build A Dbcs character
                             * with the TrailingByte in wParam...
                             */
                            if (*pchDbcsCF) {
                                WORD DbcsLeadChar = (WORD)(*pchDbcsCF);
                                /*
                                 * HIBYTE(LOWORD(dwAnsi)) = Dbcs LeadingByte.
                                 * LOBYTE(LOWORD(dwAnsi)) = Dbcs TrailingByte.
                                 */
                                dwAnsi |= (DbcsLeadChar << 8);
                                /*
                                 * Invalidate cached data..
                                 */
                                *pchDbcsCF = 0;
                            } else if (IsDBCSLeadByteEx(THREAD_CODEPAGE(),LOBYTE(dwAnsi))) {
                                /*
                                 * if this is Dbcs LeadByte character, we should wait Dbcs TrailingByte
                                 * to convert this to Unicode. then we cached it here...
                                 */
                                *pchDbcsCF = LOBYTE(dwAnsi);
                                /*
                                 * Get DBCS TrailByte...
                                 */
                                pfn(HC_SKIP,0,0);
                                goto GetNextHookData;
                            }
                        }
                        /*
                         * Convert to Unicode...
                         */
                        RtlMBMessageWParamCharToWCS(pEMsg->message, &dwAnsi);
                        /*
                         * Restore converted Unicode to EVENTMSG..
                         */
                        pEMsg->paramL = (UINT)dwAnsi;
                        /*
                         * Keep this EVENTMSG to local buffer...
                         */
                        RtlCopyMemory(&CachedEvent,pEMsg,sizeof(EVENTMSG));
                    } /* switch(pEMsg->message) */
                } /* if (pEMsg) */
            }
            break;
        case WH_MSGFILTER:
        case WH_SYSMSGFILTER:
        case WH_GETMESSAGE:
            pMsg = (PMSG)lParam;
            if (pMsg) {
                switch (pMsg->message) {
                case WM_CHAR:
                case EM_SETPASSWORDCHAR:
                    if (GetCallBackDbcsInfo()->wParam) {
                        PKERNEL_MSG pmsgDbcs = GetCallBackDbcsInfo();
                        /*
                         * Get pushed message.
                         *
                         * Backup current message. this backupped message will be used
                         * when Apps peek (or get) message from thier WndProc.
                         * (see GetMessageA(), PeekMessageA()...)
                         *
                         * pmsg->hwnd    = pmsgDbcs->hwnd;
                         * pmsg->message = pmsgDbcs->message;
                         * pmsg->wParam  = pmsgDbcs->wParam;
                         * pmsg->lParam  = pmsgDbcs->lParam;
                         * pmsg->time    = pmsgDbcs->time;
                         * pmsg->pt      = pmsgDbcs->pt;
                         */
                        COPY_KERNELMSG_TO_MSG(pMsg,pmsgDbcs);
                        /*
                         * Invalidate pushed message in CLIENTINFO.
                         */
                        pmsgDbcs->wParam = 0;
                        /*
                         * Call the hook with DBCS TrailByte..
                         */
                        nRet = pfn(LOWORD(dw), wParam, lParam);
                    }
                    /*
                     * Restore original message..
                     * #96571 [hiroyama]
                     * Other messages than WM_CHAR and EM_SETPASSWORDCHAR can be
                     * modifed by a hooker.
                     * Wparam for WM_CHAR and EM_SETPASSWORDCHAR must be restored.
                     * *by design*
                     */
                    pMsg->wParam = wParamSave;
                }
            } /* if (pMsg) */
        } /* switch (HIWORD(dw)) */
    }
#endif // IS_ANSI

    /*
     * Restore the hook number and return the return code.
     */
    pci->dwHookCurrent = dwHookSave;
    return nRet;
}


/***************************************************************************\
* GetWindowLong, SetWindowLong, GetClassLong
*
* History:
* 02-Feb-92 IanJa       Neutral version.
\***************************************************************************/

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, LONG_PTR, APIENTRY, GetWindowLongPtrW, HWND, hwnd, int, nIndex)
#else
FUNCLOG2(LOG_GENERAL, LONG_PTR, APIENTRY, GetWindowLongPtrA, HWND, hwnd, int, nIndex)
#endif // UNICODE
LONG_PTR APIENTRY GetWindowLongPtr(HWND hwnd, int nIndex)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    try {
        return _GetWindowLongPtr(pwnd, nIndex, IS_ANSI);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hwnd);
        return 0;
    }
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, LONG_PTR, APIENTRY, SetWindowLongPtrW, HWND, hWnd, int, nIndex, LONG_PTR, dwNewLong)
#else
FUNCLOG3(LOG_GENERAL, LONG_PTR, APIENTRY, SetWindowLongPtrA, HWND, hWnd, int, nIndex, LONG_PTR, dwNewLong)
#endif // UNICODE
LONG_PTR APIENTRY SetWindowLongPtr(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
{
    return _SetWindowLongPtr(hWnd, nIndex, dwNewLong, IS_ANSI);
}

#ifdef _WIN64
LONG  APIENTRY GetWindowLong(HWND hwnd, int nIndex)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    try {
        return _GetWindowLong(pwnd, nIndex, IS_ANSI);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hwnd);
        return 0;
    }
}

LONG  APIENTRY SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong)
{
    return _SetWindowLong(hWnd, nIndex, dwNewLong, IS_ANSI);
}
#endif

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, ULONG_PTR, APIENTRY, GetClassLongPtrW, HWND, hWnd, int, nIndex)
#else
FUNCLOG2(LOG_GENERAL, ULONG_PTR, APIENTRY, GetClassLongPtrA, HWND, hWnd, int, nIndex)
#endif // UNICODE

ULONG_PTR APIENTRY GetClassLongPtr(HWND hWnd, int nIndex)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hWnd);

    if (pwnd == NULL)
        return 0;

    try {
        return _GetClassLongPtr(pwnd, nIndex, IS_ANSI);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hWnd);
        return 0;
    }
}

#ifdef _WIN64
DWORD  APIENTRY GetClassLong(HWND hWnd, int nIndex)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hWnd);

    if (pwnd == NULL)
        return 0;

    try {
        return _GetClassLong(pwnd, nIndex, IS_ANSI);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hWnd);
        return 0;
    }
}
#endif


#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, BOOL, APIENTRY, PeekMessageW, LPMSG, lpMsg, HWND, hWnd, UINT, wMsgFilterMin, UINT, wMsgFilterMax, UINT, wRemoveMsg)
#else
FUNCLOG5(LOG_GENERAL, BOOL, APIENTRY, PeekMessageA, LPMSG, lpMsg, HWND, hWnd, UINT, wMsgFilterMin, UINT, wMsgFilterMax, UINT, wRemoveMsg)

#endif // UNICODE

BOOL APIENTRY PeekMessage(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg)
{
    CLIENTTHREADINFO *pcti;
    PCLIENTINFO pci;
    UINT fsWakeMaskFilter;
    UINT fsWakeMask;
    UINT cSpinLimit;

    pci = GetClientInfo();

    if (hWnd != NULL) {
        goto lbCallServer;
    }

#if IS_ANSI
    /*
     * If we have a DBCS TrailingByte that should be returned to App,
     * we should pass it, never can fail....
     */
    UserAssert(IS_DBCS_ENABLED() || GetCallBackDbcsInfo()->wParam == 0);
    if (GetCallBackDbcsInfo()->wParam) {    // accesses fs:xxx, but no speed penalty
        /*
         * Check message filter... WM_CHAR should be in the Range...
         */
        if ((!wMsgFilterMin && !wMsgFilterMax) ||
            (wMsgFilterMin <= WM_CHAR && wMsgFilterMax >=WM_CHAR))
        {
            goto lbCallServer;
        }
    }
#endif

    if (   (pci->dwTIFlags & TIF_16BIT)
        && !(wRemoveMsg & PM_NOYIELD)
        && ((gpsi->nEvents != 0) || (pci->dwTIFlags & (TIF_FIRSTIDLE | TIF_DELAYEDEVENT)))) {

        goto lbCallServer;
    }

    /*
     * If we can't see the client thread info, we need to go to the kernel.
     */
    if ((pcti = CLIENTTHREADINFO(pci)) == NULL) {
        goto lbCallServer;
    }

    fsWakeMaskFilter = HIWORD(wRemoveMsg);
#if DBG
    /*
     * New for NT5: HIWORD(wRemoveMsg) contains a QS_ mask. This is
     *  validated for real in the kernel side.
     */
    if (fsWakeMaskFilter & ~QS_VALID) {
        RIPMSG1(RIP_WARNING, "PeekMessage: Invalid QS_ bits:%#lx", fsWakeMaskFilter);
    }
#endif
    /*
     * If any appropriate input is available, we need to go to the kernel.
     */
    if (wMsgFilterMax == 0 && fsWakeMaskFilter == 0) {
        fsWakeMask = (QS_ALLINPUT | QS_EVENT | QS_ALLPOSTMESSAGE);
    } else {
        fsWakeMask = CalcWakeMask(wMsgFilterMin, wMsgFilterMax, fsWakeMaskFilter);
    }
    if ((pcti->fsChangeBits | pcti->fsWakeBits) & fsWakeMask) {
        goto lbCallServer;
    }

    /*
     * If this thread has the queue locked, we have to go to the kernel
     * or other threads on the same queue may be prevented from getting
     * input messages.
     */
    if (pcti->CTIF_flags & CTIF_SYSQUEUELOCKED) {
        goto lbCallServer;
    }

    /*
     * This is the peek message count (not going idle count). If it gets
     * to be 100 or greater, call the server. This'll cause this app to be
     * put at background priority until it sleeps. This is really important
     * for compatibility because win3.1 peek/getmessage usually takes a trip
     * through the win3.1 scheduler and runs the next task.
     */
    pci->cSpins++;

    if ((pci->cSpins >= CSPINBACKGROUND) && !(pci->dwTIFlags & TIF_SPINNING)) {
        goto lbCallServer;
    }

    /*
     * We have to go to the server if someone is waiting on this event.
     * We used to just wait until the spin cound got large but for some
     * apps like terminal.  They always just call PeekMessage and after
     * just a few calls they would blink their caret which bonks the spincount
     */
    if (pci->dwTIFlags & TIF_WAITFORINPUTIDLE){
        goto lbCallServer;
    }

    /*
     * Make sure we go to the kernel at least once a second so that
     * hung app painting won't occur.
     */
    if ((NtGetTickCount() - pcti->timeLastRead) > 1000) {
        NtUserGetThreadState(UserThreadStatePeekMessage);
    }

    /*
     * Determine the maximum number of spins before we yield. Yields
     * are performed more frequently for 16 bit apps.
     */
    if ((pci->dwTIFlags & TIF_16BIT) && !(wRemoveMsg & PM_NOYIELD)) {
        cSpinLimit = CSPINBACKGROUND / 10;
    } else {
        cSpinLimit = CSPINBACKGROUND;
    }

    /*
     * If the PeekMessage() is just spinning, then we should sleep
     * just enough so that we allow other processes to gain CPU time.
     * A problem was found when an OLE app tries to communicate to a
     * background app (via SendMessage) running at the same priority as a
     * background/spinning process.  This will starve the CPU from those
     * processes.  Sleep on every re-cycle of the spin-count.  This will
     * assure that apps doing peeks are degraded.
     *
     */
    if ((pci->dwTIFlags & TIF_SPINNING) && (pci->cSpins >= cSpinLimit)) {
        pci->cSpins = 0;
        NtYieldExecution();
    }

    return FALSE;

lbCallServer:

    return _PeekMessage(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax,
            wRemoveMsg, IS_ANSI);
}


#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, LRESULT, APIENTRY, DefWindowProcW, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG4(LOG_GENERAL, LRESULT, APIENTRY, DefWindowProcA, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE
LRESULT APIENTRY DefWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet;

    BEGIN_USERAPIHOOK()

        BOOL fOverride = IsMsgOverride(message, &guah.mmDWP);

        if (fOverride) {
            /*
             * This message is being overridden, so we need to callback to
             * process.  During this callback, the override may call the real
             * DWP for processing.
             */

#ifdef UNICODE
            lRet = guah.pfnDefWindowProcW(hwnd, message, wParam, lParam);
#else
            lRet = guah.pfnDefWindowProcA(hwnd, message, wParam, lParam);
#endif
        } else {
            /*
             * This message is not being overridden, so we can just call the
             * real DWP for processing.
             */

#ifdef UNICODE
            lRet = RealDefWindowProcW(hwnd, message, wParam, lParam);
#else
            lRet = RealDefWindowProcA(hwnd, message, wParam, lParam);
#endif
        }

    END_USERAPIHOOK()

    return lRet;
}


LRESULT APIENTRY TEXT_FN(RealDefWindowProc)(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        switch (message) {
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSTATIC:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORMSGBOX:

            /*
             * Draw default colors
             */
            break;
        default:
            return 0;
        }
    }

    return RealDefWindowProcWorker(pwnd, message, wParam, lParam, IS_ANSI);
}


LRESULT APIENTRY TEXT_FN(DispatchDefWindowProc)(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR pfn)
{
    HWND hwnd = KHWND_TO_HWND(GetClientInfo()->CallbackWnd.hwnd);

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(pfn);

    return DefWindowProc(hwnd, message, wParam, lParam);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, LRESULT, APIENTRY, SendMessageW, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG4(LOG_GENERAL, LRESULT, APIENTRY, SendMessageA, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE
LRESULT APIENTRY SendMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    PWND pwnd;

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (message & RESERVED_MSG_BITS) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"message\" (%ld) to SendMessage",
                message);

        return 0;
    }

    /*
     * Thunk through a special sendmessage for -1 hwnd's so that the general
     * purpose thunks don't allow -1 hwnd's.
     */
    if (hwnd == (HWND)-1 || hwnd == (HWND)0x0000FFFF) {
        /*
         * Get a real hwnd so the thunks will validation ok. Note that since
         * -1 hwnd is really rare, calling GetDesktopWindow() here is not a
         * big deal.
         */
        hwnd = GetDesktopWindow();

        /*
         * Always send broadcast requests straight to the server.
         * Note: if the xParam needs to be used, must update
         * SendMsgTimeout, FNID_SENDMESSAGEFF uses it to id who
         * it is from...
         */
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                FNID_SENDMESSAGEFF, IS_ANSI);
    }

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    return SendMessageWorker(pwnd, message, wParam, lParam, IS_ANSI);
}


#ifdef UNICODE
FUNCLOG7(LOG_GENERAL, LRESULT, APIENTRY, SendMessageTimeoutW, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam, UINT, fuFlags, UINT, uTimeout, PULONG_PTR, lpdwResult)
#else
FUNCLOG7(LOG_GENERAL, LRESULT, APIENTRY, SendMessageTimeoutA, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam, UINT, fuFlags, UINT, uTimeout, PULONG_PTR, lpdwResult)
#endif // UNICODE
LRESULT APIENTRY SendMessageTimeout(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam,
        UINT fuFlags, UINT uTimeout, PULONG_PTR lpdwResult)

{
    return SendMessageTimeoutWorker(hwnd, message, wParam, lParam,
            fuFlags, uTimeout, lpdwResult, IS_ANSI);
}


/***************************************************************************\
* SendDlgItemMessage
*
* Translates the message, calls SendDlgItemMessage on server side. The
* dialog item's ID is passed as the xParam. On the server side, a stub
* rearranges the parameters to put the ID where it belongs and calls
* xxxSendDlgItemMessage.
*
* 04-17-91 DarrinM Created.
\***************************************************************************/

#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, SendDlgItemMessageW, HWND, hwnd, int, id, UINT, message, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, SendDlgItemMessageA, HWND, hwnd, int, id, UINT, message, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE

LRESULT WINAPI SendDlgItemMessage(
    HWND hwnd,
    int id,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    if (hwnd == (HWND)-1 || hwnd == (HWND)0x0000FFFF)
        return 0;

    if (hwnd = GetDlgItem(hwnd, id))
        return SendMessage(hwnd, message, wParam, lParam);

    return 0L;
}

/***************************************************************************\
* GetDlgItemText
*
* History:
*    04 Feb 1992 GregoryW  Neutral ANSI/Unicode version
\***************************************************************************/
#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetDlgItemTextW, HWND, hwnd, int, id, LPTSTR, lpch, int, cchMax)
#else
FUNCLOG4(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetDlgItemTextA, HWND, hwnd, int, id, LPTSTR, lpch, int, cchMax)
#endif // UNICODE

UINT GetDlgItemText(
    HWND hwnd,
    int id,
    LPTSTR lpch,
    int cchMax)
{
    if ((hwnd = GetDlgItem(hwnd, id)) != NULL) {
        return GetWindowText(hwnd, lpch, cchMax);
    }

    /*
     * If we couldn't find the window, just null terminate lpch so that the
     * app doesn't gp fault if it tries to run through the text.
     */
    if (cchMax)
        *lpch = (TCHAR)0;

    return 0;
}


/***************************************************************************\
* SetDlgItemText
*
* History:
*    04 Feb 1992 GregoryW  Neutral ANSI/Unicode version
\***************************************************************************/
#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetDlgItemTextW , HWND, hwnd, int, id, LPCTSTR, lpch)
#else
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetDlgItemTextA , HWND, hwnd, int, id, LPCTSTR, lpch)
#endif // UNICODE

BOOL SetDlgItemText(
    HWND hwnd,
    int id,
    LPCTSTR lpch)
{
    if ((hwnd = GetDlgItem(hwnd, id)) != NULL) {
        return SetWindowText(hwnd, lpch);
    }

    return FALSE;
}


#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, int, WINAPI, GetWindowTextW, HWND, hwnd, LPTSTR, lpName, int, nMaxCount)
#else
FUNCLOG3(LOG_GENERAL, int, WINAPI, GetWindowTextA, HWND, hwnd, LPTSTR, lpName, int, nMaxCount)
#endif // UNICODE

int WINAPI GetWindowText(
    HWND hwnd,
    LPTSTR lpName,
    int nMaxCount)
{
    PWND pwnd;

    /*
     * Don't try to fill a non-existent buffer
     */
    if (lpName == NULL || nMaxCount == 0) {
        return 0;
    }

    try {
        /*
         * Initialize string empty, in case SendMessage aborts validation
         */
        *lpName = TEXT('\0');

        /*
         * Make sure we have a valid window.
         */
        if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
            return 0;
        }

        /*
         * This process comparison is bogus, but it is what win3.1 does.
         */
        if (TestWindowProcess(pwnd)) {
            return (int)SendMessageWorker(pwnd, WM_GETTEXT, nMaxCount, (LPARAM)lpName, IS_ANSI);
        } else {
            return (int)DefWindowProcWorker(pwnd, WM_GETTEXT, nMaxCount, (LPARAM)lpName, IS_ANSI);
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hwnd);
        return 0;
    }
}

#ifdef UNICODE
FUNCLOG1(LOG_GENERAL, int, WINAPI, GetWindowTextLengthW, HWND, hwnd)
#else
FUNCLOG1(LOG_GENERAL, int, WINAPI, GetWindowTextLengthA, HWND, hwnd)
#endif // UNICODE
int WINAPI GetWindowTextLength(
    HWND hwnd)
{
    PWND pwnd;

    /*
     * Make sure we have a valid window.
     */
    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return 0;
    }

    /*
     * This process comparison is bogus, but it is what win3.1 does.
     */
    if (TestWindowProcess(pwnd)) {
        return (int)SendMessageWorker(pwnd, WM_GETTEXTLENGTH, 0, 0, IS_ANSI);
    } else {
        return (int)DefWindowProcWorker(pwnd, WM_GETTEXTLENGTH, 0, 0, IS_ANSI);
    }
}


#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, SetWindowTextW , HWND, hwnd, LPCTSTR, pString)
#else
FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, SetWindowTextA , HWND, hwnd, LPCTSTR, pString)
#endif // UNICODE
BOOL WINAPI SetWindowText(
    HWND hwnd,
    LPCTSTR pString)
{
    LRESULT lReturn;
    PWND pwnd;

    /*
     * Make sure we have a valid window.
     */
    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return FALSE;
    }

    /*
     * This process comparison is bogus, but it is what win3.1 does.
     */
    if (TestWindowProcess(pwnd)) {
        lReturn = SendMessageWorker(pwnd, WM_SETTEXT, 0, (LPARAM)pString, IS_ANSI);
    } else {
        lReturn = DefWindowProcWorker(pwnd, WM_SETTEXT, 0, (LPARAM)pString, IS_ANSI);
    }
    return (lReturn >= 0);
}


LRESULT APIENTRY DispatchMessage(CONST MSG *lpMsg)
{
    extern LRESULT DispatchMessageWorker(CONST MSG *lpMsg, BOOL fAnsi);

    return DispatchMessageWorker(lpMsg, IS_ANSI);
}

#if IS_ANSI
VOID CopyLogFontAtoW(
    PLOGFONTW pdest,
    PLOGFONTA psrc)
{
    LPSTR lpstrFont = (LPSTR)(&psrc->lfFaceName);
    LPWSTR lpstrFontW = (LPWSTR)(&pdest->lfFaceName);

    RtlCopyMemory((LPBYTE)pdest, psrc, sizeof(LOGFONTA) - LF_FACESIZE);
    RtlZeroMemory(pdest->lfFaceName, LF_FACESIZE * sizeof(WCHAR));
    MBToWCS(lpstrFont, -1, &lpstrFontW, LF_FACESIZE, FALSE);
}

VOID CopyLogFontWtoA(
    PLOGFONTA pdest,
    PLOGFONTW psrc)
{
    LPSTR lpstrFont = (LPSTR)(&pdest->lfFaceName);

    RtlCopyMemory((LPBYTE)pdest, (LPBYTE)psrc, sizeof(LOGFONTA) - LF_FACESIZE);
    RtlZeroMemory(pdest->lfFaceName, LF_FACESIZE);
    WCSToMB(psrc->lfFaceName, -1, &lpstrFont, LF_FACESIZE, FALSE);
}
#else

/**************************************************************************\
* SetVideoTimeout
*
* Updates the video timeout values in the current power profile.
*
* 15-Apr-1999 JerrySh   Created.
\**************************************************************************/

typedef BOOLEAN (*PFNGETACTIVEPWRSCHEME)(PUINT);
typedef BOOLEAN (*PFNSETACTIVEPWRSCHEME)(UINT, PGLOBAL_POWER_POLICY, PPOWER_POLICY);
typedef BOOLEAN (*PFNREADPWRSCHEME)(UINT, PPOWER_POLICY);

BOOL SetVideoTimeout(
    DWORD dwVideoTimeout)
{
    POWER_POLICY pp;
    UINT uiID;
    BOOL fRet = FALSE;

    if (GetActivePwrScheme(&uiID)) {
        if (ReadPwrScheme(uiID, &pp)) {
            pp.user.VideoTimeoutDc = dwVideoTimeout;
            pp.user.VideoTimeoutAc = dwVideoTimeout;

            fRet = SetActivePwrScheme(uiID, NULL, &pp);
        }
    }

    return fRet;
}
#endif  // IS_ANSI

/***************************************************************************\
* SystemParametersInfo
*
*
\***************************************************************************/

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, SystemParametersInfoW, UINT, wFlag, UINT, wParam, PVOID, lParam, UINT, flags)
#else
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, SystemParametersInfoA, UINT, wFlag, UINT, wParam, PVOID, lParam, UINT, flags)
#endif // UINCODE
BOOL APIENTRY SystemParametersInfo(
    UINT  wFlag,
    UINT  wParam,
    PVOID lParam,
    UINT  flags)
{
    BOOL bRet;

    BEGIN_USERAPIHOOK()
#ifdef UNICODE
        bRet = guah.pfnSystemParametersInfoW(wFlag, wParam, lParam, flags);
#else
        bRet = guah.pfnSystemParametersInfoA(wFlag, wParam, lParam, flags);
#endif
    END_USERAPIHOOK()

    return bRet;
}
BOOL APIENTRY TEXT_FN(RealSystemParametersInfo)(
    UINT  wFlag,
    UINT  wParam,
    PVOID lParam,
    UINT  flags)
{
#if IS_ANSI
    NONCLIENTMETRICSW ClientMetricsW;
    ICONMETRICSW      IconMetricsW;
    LOGFONTW          LogFontW;
    /*
     * Bug 257718 - joejo
     * Add SPI_GETDESKWALLPAPER to SystemParametersInfo
     */
    WCHAR             szTemp[MAX_PATH];
    UINT              oldwParam = wParam;
#endif
    INTERNALSETHIGHCONTRAST ihc;
    IN_STRING         strlParam;
    PVOID             oldlParam = lParam;

    /*
     * Make sure cleanup will work successfully
     */
    strlParam.fAllocated = FALSE;

    BEGINCALL();

    switch (wFlag) {
    case SPI_SETSCREENSAVERRUNNING:     // same as SPI_SCREENSAVERRUNNING
        MSGERROR();

    case SPI_SETDESKPATTERN:

        if (wParam == 0x0000FFFF)
            wParam = (UINT)-1;

        /*
         * lParam not a string (and already copied)
         */
        if (wParam == (UINT)-1)
            break;

        /*
         * lParam is possibly 0 or -1 (filled in already) or a string
         */
        if ((lParam != (PVOID)0) && (lParam != (PVOID)-1)) {
            COPYLPTSTR(&strlParam, (LPTSTR)lParam);
            lParam = strlParam.pstr;
        }
        break;

    case SPI_SETDESKWALLPAPER: {

            /*
             * lParam is possibly 0, -1 or -2 (filled in already) or a string.
             * Get a pointer to the string so we can use it later.  We're
             * going to a bit of normalizing here for consistency.
             *
             * If the caller passes in 0, -1 or -2, we're going to set
             * the wParam to -1, and use the lParam to pass the string
             * representation of the wallpaper.
             */
            if ((lParam != (PVOID) 0) &&
                (lParam != (PVOID)-1) &&
                (lParam != (PVOID)-2)) {

                COPYLPTSTR(&strlParam, (LPTSTR)lParam);
                lParam = strlParam.pstr;
                wParam = 0;

            } else {
                wParam = (UINT)-1;
            }
        }
        break;

    /*
     * Bug 257718 - joejo
     * Add SPI_GETDESKWALLPAPER to SystemParametersInfo
     */
    case SPI_GETDESKWALLPAPER:
        if ((lParam == NULL) || (wParam == 0))
            MSGERROR();
#if IS_ANSI
        lParam = szTemp;
        wParam = ARRAY_SIZE(szTemp);
#else
        /*
         * Bug 283318 - joejo
         * Leave space for a null termination
         */
        wParam--;
#endif

        break;


    case SPI_GETANIMATION:
        if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(ANIMATIONINFO)))
                MSGERROR();
        break;

    case SPI_GETNONCLIENTMETRICS:
#if IS_ANSI
        if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(NONCLIENTMETRICSA)))
            MSGERROR();
        lParam = &ClientMetricsW;
#else
        if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(NONCLIENTMETRICSW)))
            MSGERROR();
#endif
        break;

    case SPI_GETMINIMIZEDMETRICS:
        if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(MINIMIZEDMETRICS)))
            MSGERROR();
        break;

    case SPI_GETICONMETRICS:
#if IS_ANSI
        if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(ICONMETRICSA)))
            MSGERROR();
        lParam = &IconMetricsW;
#else
        if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(ICONMETRICSW)))
            MSGERROR();
#endif
        break;

    case SPI_GETHIGHCONTRAST:
#if IS_ANSI
        {
            LPHIGHCONTRASTA pHC = (HIGHCONTRASTA *)lParam;
            if (!pHC || (pHC->cbSize != sizeof(HIGHCONTRASTA))) {
                MSGERROR();
            }
            if (!pcHighContrastScheme) {
                pcHighContrastScheme = LocalAlloc(LPTR, MAX_SCHEME_NAME_SIZE * sizeof(WCHAR));
                if (!pcHighContrastScheme)
                    MSGERROR();
            }
            if (!pwcHighContrastScheme) {
                pwcHighContrastScheme = LocalAlloc(LPTR, MAX_SCHEME_NAME_SIZE * sizeof(WCHAR));
                if (!pwcHighContrastScheme)
                    MSGERROR();
            }
            ((LPHIGHCONTRASTW)(lParam))->lpszDefaultScheme = pwcHighContrastScheme;
        }
#else
        {
            LPHIGHCONTRASTW pHC = (HIGHCONTRASTW *)lParam;
            if (!pHC || (pHC->cbSize != sizeof(HIGHCONTRASTW)))
                MSGERROR();
            if (!pwcHighContrastScheme) {
                pwcHighContrastScheme = LocalAlloc(LPTR, MAX_SCHEME_NAME_SIZE * sizeof(WCHAR));
                if (!pwcHighContrastScheme)
                    MSGERROR();
            }
            pHC->lpszDefaultScheme = pwcHighContrastScheme;
        }
#endif

        break;

#if IS_ANSI
    case SPI_GETICONTITLELOGFONT:
        lParam = &LogFontW;
        break;
#endif

    case SPI_SETANIMATION:
        {
            if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(ANIMATIONINFO)))
                MSGERROR();
        }
        break;

    case SPI_SETHIGHCONTRAST:
        ihc.cbSize = sizeof (HIGHCONTRASTW);
        {
            LPHIGHCONTRAST pHC = (HIGHCONTRAST *)lParam;
            if ((lParam == NULL) || (pHC->cbSize != sizeof(HIGHCONTRAST)))
                MSGERROR();

            lParam = &ihc;
            ihc.dwFlags = pHC->dwFlags;
            COPYLPTSTR(&strlParam, pHC->lpszDefaultScheme);
            ihc.usDefaultScheme = *strlParam.pstr;
        }
        break;

    case SPI_SETNONCLIENTMETRICS:
#if IS_ANSI
        {
            PNONCLIENTMETRICSA psrc = (PNONCLIENTMETRICSA)lParam;

            if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(NONCLIENTMETRICSA)))
                MSGERROR();

            if( psrc->iCaptionWidth > 256 )
                psrc->iCaptionWidth = 256;

            if( psrc->iCaptionHeight > 256 )
                psrc->iCaptionHeight = 256;

            ClientMetricsW.cbSize           = psrc->cbSize;
            ClientMetricsW.iBorderWidth     = psrc->iBorderWidth;
            ClientMetricsW.iScrollWidth     = psrc->iScrollWidth;
            ClientMetricsW.iScrollHeight    = psrc->iScrollHeight;
            ClientMetricsW.iCaptionWidth    = psrc->iCaptionWidth;
            ClientMetricsW.iCaptionHeight   = psrc->iCaptionHeight;
            ClientMetricsW.iSmCaptionWidth  = psrc->iSmCaptionWidth;
            ClientMetricsW.iSmCaptionHeight = psrc->iSmCaptionHeight;
            ClientMetricsW.iMenuWidth       = psrc->iMenuWidth;
            ClientMetricsW.iMenuHeight      = psrc->iMenuHeight;

            CopyLogFontAtoW(&(ClientMetricsW.lfCaptionFont), &(psrc->lfCaptionFont));
            CopyLogFontAtoW(&(ClientMetricsW.lfSmCaptionFont), &(psrc->lfSmCaptionFont));
            CopyLogFontAtoW(&(ClientMetricsW.lfMenuFont), &(psrc->lfMenuFont));
            CopyLogFontAtoW(&(ClientMetricsW.lfStatusFont), &(psrc->lfStatusFont));
            CopyLogFontAtoW(&(ClientMetricsW.lfMessageFont), &(psrc->lfMessageFont));

            lParam = &ClientMetricsW;
        }
#else
        {
            PNONCLIENTMETRICSA psrc;

            if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(NONCLIENTMETRICSW)))
                MSGERROR();

            psrc = (PNONCLIENTMETRICSA)lParam;

            if( psrc->iCaptionWidth > 256 )
                psrc->iCaptionWidth = 256;

            if( psrc->iCaptionHeight > 256 )
                psrc->iCaptionHeight = 256;
        }
#endif
        wParam = sizeof(NONCLIENTMETRICSW);
        break;

    case SPI_SETMINIMIZEDMETRICS:
        if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(MINIMIZEDMETRICS)))
            MSGERROR();
        wParam = sizeof(MINIMIZEDMETRICS);
        break;

    case SPI_SETICONMETRICS:
#if IS_ANSI
        {
            PICONMETRICSA psrc = (PICONMETRICSA)lParam;

            if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(ICONMETRICSA)))
                MSGERROR();

            RtlCopyMemory(&IconMetricsW, psrc, sizeof(ICONMETRICSA) - sizeof(LOGFONTA));

            CopyLogFontAtoW(&(IconMetricsW.lfFont), &(psrc->lfFont));
            lParam = &IconMetricsW;
        }
#else
        if ((lParam == NULL) || (*((DWORD *)(lParam)) != sizeof(ICONMETRICSW)))
            MSGERROR();
#endif
        wParam = sizeof(ICONMETRICSW);
        break;

    case SPI_SETICONTITLELOGFONT:
#if IS_ANSI
        CopyLogFontAtoW(&LogFontW, lParam);
        lParam = &LogFontW;
#endif
        wParam = sizeof(LOGFONTW);
        break;

    case SPI_GETFILTERKEYS:
        {
            if ((((LPFILTERKEYS)lParam)->cbSize == 0) ||
                    (((LPFILTERKEYS)lParam)->cbSize) > sizeof(FILTERKEYS)) {
                MSGERROR();
            }
        }
        break;

    case SPI_GETSTICKYKEYS:
        {
            if ((((LPSTICKYKEYS)lParam)->cbSize == 0) ||
                    (((LPSTICKYKEYS)lParam)->cbSize) > sizeof(STICKYKEYS)) {
                MSGERROR();
            }
        }
        break;

    case SPI_GETTOGGLEKEYS:
        {
            if ((((LPTOGGLEKEYS)lParam)->cbSize == 0) ||
                    (((LPTOGGLEKEYS)lParam)->cbSize) > sizeof(TOGGLEKEYS)) {
                MSGERROR();
            }
        }
        break;

    case SPI_GETMOUSEKEYS:
        {
            if ((((LPMOUSEKEYS)lParam)->cbSize == 0) ||
                    (((LPMOUSEKEYS)lParam)->cbSize) > sizeof(MOUSEKEYS)) {
                MSGERROR();
            }
        }
        break;

    case SPI_GETACCESSTIMEOUT:
        {
            if ((((LPACCESSTIMEOUT)lParam)->cbSize == 0) ||
                    (((LPACCESSTIMEOUT)lParam)->cbSize) > sizeof(ACCESSTIMEOUT)) {
                MSGERROR();
            }
        }
        break;

    case SPI_GETSOUNDSENTRY:
        /*
         * Note: Currently we don't support the windows effect dll
         * option for sound sentry.  Therefore, we don't have to
         * deal with the lpszWindowsEffectDLL field (which can be
         * ANSI or Unicode).
         */
        {
            if ((((LPSOUNDSENTRY)lParam)->cbSize == 0) ||
                    (((LPSOUNDSENTRY)lParam)->cbSize) > sizeof(SOUNDSENTRY)) {
                MSGERROR();
            }
        }
        break;
    }

    retval = NtUserSystemParametersInfo(wFlag, wParam, lParam, flags);

    switch (wFlag) {
#if IS_ANSI
    case SPI_GETNONCLIENTMETRICS:
        {
            PNONCLIENTMETRICSA pdst = (PNONCLIENTMETRICSA)oldlParam;

            pdst->cbSize           = sizeof(NONCLIENTMETRICSA);
            pdst->iBorderWidth     = ClientMetricsW.iBorderWidth;
            pdst->iScrollWidth     = ClientMetricsW.iScrollWidth;
            pdst->iScrollHeight    = ClientMetricsW.iScrollHeight;
            pdst->iCaptionWidth    = ClientMetricsW.iCaptionWidth;
            pdst->iCaptionHeight   = ClientMetricsW.iCaptionHeight;
            pdst->iSmCaptionWidth  = ClientMetricsW.iSmCaptionWidth;
            pdst->iSmCaptionHeight = ClientMetricsW.iSmCaptionHeight;
            pdst->iMenuWidth       = ClientMetricsW.iMenuWidth;
            pdst->iMenuHeight      = ClientMetricsW.iMenuHeight;

            CopyLogFontWtoA(&(pdst->lfCaptionFont), &(ClientMetricsW.lfCaptionFont));
            CopyLogFontWtoA(&(pdst->lfSmCaptionFont), &(ClientMetricsW.lfSmCaptionFont));
            CopyLogFontWtoA(&(pdst->lfMenuFont), &(ClientMetricsW.lfMenuFont));
            CopyLogFontWtoA(&(pdst->lfStatusFont), &(ClientMetricsW.lfStatusFont));
            CopyLogFontWtoA(&(pdst->lfMessageFont), &(ClientMetricsW.lfMessageFont));
        }
        break;

    case SPI_GETICONMETRICS:
        {
            PICONMETRICSA pdst = (PICONMETRICSA)oldlParam;

            RtlCopyMemory(pdst, &IconMetricsW, sizeof(ICONMETRICSA) - sizeof(LOGFONTA));
            pdst->cbSize = sizeof(ICONMETRICSA);

            CopyLogFontWtoA(&(pdst->lfFont), &(IconMetricsW.lfFont));
        }
        break;

    case SPI_GETICONTITLELOGFONT:
        {
            CopyLogFontWtoA((PLOGFONTA)oldlParam, &LogFontW);
        }
        break;

    case SPI_GETHIGHCONTRAST:
        WCSToMB(pwcHighContrastScheme, -1, &pcHighContrastScheme, MAX_SCHEME_NAME_SIZE, FALSE);
        ((LPHIGHCONTRASTA)(lParam))->lpszDefaultScheme = pcHighContrastScheme;
        break;

#endif  // IS_ANSI

    /*
     * Bug 257718 - joejo
     * Add SPI_GETDESKWALLPAPER to SystemParametersInfo
     */
    case SPI_GETDESKWALLPAPER:
        {
        /*
         * Bug 283318 - joejo
         * Make sure strings are null terminated.
         */
#if IS_ANSI
            INT cchAnsiCopy = WCSToMB(lParam,
                                        -1,
                                        (LPSTR*)&oldlParam,
                                        oldwParam - 1,
                                        FALSE);

            cchAnsiCopy = min(cchAnsiCopy, (INT)(oldwParam - 1));
            ((LPSTR)oldlParam)[cchAnsiCopy] = 0;
#else   //UNICODE
            ((LPWSTR)oldlParam)[wParam] = (WCHAR)0;
#endif  //IS_ANSI
            break;
        }
    case SPI_SETLOWPOWERTIMEOUT:
    case SPI_SETPOWEROFFTIMEOUT:
        if (retval && (flags & SPIF_UPDATEINIFILE)) {
            retval = SetVideoTimeout(wParam);
        }
        break;
    }

    ERRORTRAP(FALSE);
    CLEANUPLPTSTR(strlParam);
    ENDCALL(BOOL);
}


#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, HANDLE, APIENTRY, GetPropW, HWND, hwnd, LPCTSTR, pString)
#else
FUNCLOG2(LOG_GENERAL, HANDLE, APIENTRY, GetPropA, HWND, hwnd, LPCTSTR, pString)
#endif // UNICODE
HANDLE APIENTRY GetProp(HWND hwnd, LPCTSTR pString)
{
    PWND pwnd;
    int iString;

    if (IS_PTR(pString)) {
        iString = (int)GlobalFindAtom(pString);
        if (iString == 0)
            return NULL;
    } else
        iString = PTR_TO_ID(pString);

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return NULL;

    return _GetProp(pwnd, (LPWSTR)UIntToPtr( iString ), FALSE);
}


/***************************************************************************\
* RegisterClassW(API)
*
* History:
* 28-Jul-1992 ChandanC Created.
\***************************************************************************/
ATOM
WINAPI
TEXT_FN(RegisterClass)(
    CONST WNDCLASS *lpWndClass )
{
    WNDCLASSEX wc;

    /*
     * On 64-bit plaforms we'll have 32-bits of padding between style and
     * lpfnWndProc in WNDCLASS, so start the copy from the first 64-bit
     * aligned field and hand copy the rest.
     */
    RtlCopyMemory(&(wc.lpfnWndProc), &(lpWndClass->lpfnWndProc), sizeof(WNDCLASS) - FIELD_OFFSET(WNDCLASS, lpfnWndProc));
    wc.style = lpWndClass->style;
    wc.hIconSm = NULL;
    wc.cbSize = sizeof(WNDCLASSEX);

    return TEXT_FN(RegisterClassExWOW)(&wc, NULL, 0, CSF_VERSIONCLASS);
}

/***************************************************************************\
* RegisterClassExW(API)
*
* History:
* 28-Jul-1992 ChandanC Created.
\***************************************************************************/
ATOM
WINAPI
TEXT_FN(RegisterClassEx)(
    CONST WNDCLASSEX *lpWndClass)
{
    if (lpWndClass->cbSize != sizeof(WNDCLASSEX)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "RegisterClassEx: cbsize is wrong %lX",
                lpWndClass->cbSize);

        return 0;
    } else {
        return TEXT_FN(RegisterClassExWOW)((LPWNDCLASSEX)lpWndClass,
                NULL, 0, CSF_VERSIONCLASS);
    }
}

/***************************************************************************\
* GetMenuItemInfoInternal
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
BOOL TEXT_FN(GetMenuItemInfoInternal) (HMENU hMenu, UINT uID, BOOL fByPosition,
    LPMENUITEMINFOW lpInfo)
{
     VALIDATIONFNNAME(GetMenuItemInfoInternal)

     PITEM pItem;
     PMENU pMenu;
     PMENU pMenuT;

     pMenu = VALIDATEHMENU(hMenu);
     if (pMenu == NULL) {
        VALIDATIONFAIL(hMenu);
     }

     pMenuT = pMenu;         // need to check the ORIGINAL menu if popup

     pItem = MNLookUpItem(pMenu, uID, fByPosition, &pMenu);
    if (pItem == NULL) {
        /*
         * Don't display a warning. The explorer makes a lot of calls
         *  that fail here.
         * VALIDATIONFAIL(uID);
         */
        SetLastError(ERROR_MENU_ITEM_NOT_FOUND);
        return FALSE;

    }

    if (lpInfo->fMask & MIIM_STATE) {
        lpInfo->fState = pItem->fState & MFS_MASK;
    }

    if (lpInfo->fMask & MIIM_ID) {
        lpInfo->wID = pItem->wID;
    }

    if ((lpInfo->fMask & MIIM_SUBMENU) && (pItem->spSubMenu != NULL)) {
        lpInfo->hSubMenu = PtoH(REBASEPTR(pMenu, pItem->spSubMenu));
    } else {
        lpInfo->hSubMenu = NULL;
    }

    if (lpInfo->fMask & MIIM_CHECKMARKS) {
        lpInfo->hbmpChecked  = KHBITMAP_TO_HBITMAP(pItem->hbmpChecked);
        lpInfo->hbmpUnchecked= KHBITMAP_TO_HBITMAP(pItem->hbmpUnchecked);
    }

    if (lpInfo->fMask & MIIM_DATA) {
       lpInfo->dwItemData = KERNEL_ULONG_PTR_TO_ULONG_PTR(pItem->dwItemData);
    }

    if (lpInfo->fMask & MIIM_FTYPE) {
        lpInfo->fType = pItem->fType & MFT_MASK;
        if (TestMF(pMenuT,MFRTL))
            lpInfo->fType |= MFT_RIGHTORDER;
    }

    if ( lpInfo->fMask & MIIM_BITMAP) {
        lpInfo->hbmpItem = KHBITMAP_TO_HBITMAP(pItem->hbmp);
    }

    if (lpInfo->fMask & MIIM_STRING) {
        if ((lpInfo->cch == 0)
            || (lpInfo->dwTypeData == NULL)

            /*
             * If this is an old caller (MIIM_TYPE set), and this item
             *  has a bitmap or it's ownerdraw, then don't attempt to
             *  copy a string since they probably didn't pass a pointer
            */

            || ((lpInfo->fMask & MIIM_TYPE)
                    && ((lpInfo->fType & MFT_OWNERDRAW)
                            /*
                             * Bug 278750 - jojoe
                             *
                             * Soemone forgot to check for separator in the list
                             * of menuitems that do NOT return string data!
                             */
                            || (lpInfo->fType & MFT_SEPARATOR)
                            || ((pItem->hbmp != NULL)  && ((pItem->hbmp < HBMMENU_POPUPFIRST) || (pItem->hbmp > HBMMENU_POPUPLAST)))))) {



            /*
             * When DBCS is enabled, one UNICODE character may occupy two bytes.
             * GetMenuItemInfoA should return the byte count, rather than the character count.
             * On NT5, pItem->lpstr is guaranteed to be a valid string, if it is not NULL.
             */
            if (IS_ANSI && IS_DBCS_ENABLED() && pItem->lpstr != NULL) {
                NTSTATUS Status;
                ULONG cch;

                Status = RtlUnicodeToMultiByteSize(&cch, REBASEPTR(pMenu, pItem->lpstr), pItem->cch * sizeof(WCHAR));
                UserAssert(NT_SUCCESS(Status)); // RtlUnicodeToMultiByteSize is not expected to fail
                lpInfo->cch = cch;
            } else {
                lpInfo->cch = pItem->cch;
            }
            lpInfo->dwTypeData = NULL;


        } else {
            int cch = 0;

            if (pItem->lpstr != NULL) {

                // originally:
                // cch = min(lpInfo->cch - 1, (pItem->cch * sizeof(WORD)));
                cch = pItem->cch;
                UserAssert(cch >= 0);
                if (IS_DBCS_ENABLED()) {
                    /* pItem->cch contains Unicode character counts,
                     * we guess max DBCS string size for the Unicode string.
                     */
                    cch *= DBCS_CHARSIZE;
                }
                cch = min(lpInfo->cch - 1, (DWORD)cch);

#if IS_ANSI
                cch = WCSToMB(REBASEPTR(pMenu, pItem->lpstr), pItem->cch,
                        (LPSTR *)&(lpInfo->dwTypeData), cch, FALSE);
#else
                wcsncpy(lpInfo->dwTypeData, (LPWSTR)REBASEPTR(pMenu, pItem->lpstr),
    cch);
#endif
            }

#if IS_ANSI
            *((LPSTR)lpInfo->dwTypeData + cch) = (CHAR)0;
#else
            *(lpInfo->dwTypeData + cch) = (WCHAR)0;
#endif
            lpInfo->cch = cch;
        }
     }

     return TRUE;

     VALIDATIONERROR(FALSE);

}
/***************************************************************************\
* GetMenuString()
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetMenuStringW, HMENU, hMenu, UINT, wID, LPTSTR, lpsz, int, cchMax, UINT, flags)
#else
FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetMenuStringA, HMENU, hMenu, UINT, wID, LPTSTR, lpsz, int, cchMax, UINT, flags)
#endif // UNICODE
int GetMenuString(HMENU hMenu, UINT wID, LPTSTR lpsz, int cchMax, UINT flags)
{
    MENUITEMINFOW    miiLocal;

    miiLocal.fMask      = MIIM_STRING;
    miiLocal.dwTypeData = (LPWSTR)lpsz;
    miiLocal.cch        = cchMax;

    if (cchMax != 0) {
        *lpsz = (TCHAR)0;
    }

    if (TEXT_FN(GetMenuItemInfoInternal)(hMenu, wID, (BOOL)(flags & MF_BYPOSITION), &miiLocal)) {
        return miiLocal.cch;
    } else {
        return 0;
    }
}

/***************************************************************************\
* GetMenuItemInfo
*
*  1) converts a MENUITEMINFO95 or a new-MENUITEMINFO-with-old-flags to a new
*     MENUITEMINFO -- this way all internal code can assume one look for the
*     structure
*  2) calls the internal GetMenuItemInfo which performs validation and work
*  3) converts the new MENUITEMINFO back to the original MENUITEMINFO
*
* History:
*  07-22-96 GerardoB - Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetMenuItemInfoW, HMENU, hMenu, UINT, wID, BOOL, fByPos, LPMENUITEMINFO, lpmii)
#else
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetMenuItemInfoA, HMENU, hMenu, UINT, wID, BOOL, fByPos, LPMENUITEMINFO, lpmii)
#endif // UNICODE

BOOL GetMenuItemInfo(HMENU hMenu, UINT wID, BOOL fByPos, LPMENUITEMINFO lpmii)
{
    UINT cbCallercbSize = lpmii->cbSize;
    MENUITEMINFOW miiLocal;


    if (!ValidateMENUITEMINFO((LPMENUITEMINFOW)lpmii, &miiLocal, MENUAPI_GET)) {
        return FALSE;
    }

    if (!TEXT_FN(GetMenuItemInfoInternal)(hMenu, wID, fByPos, &miiLocal)) {
        return FALSE;
    }

    /*
     * Copy the structure and map old flags back. Only requested fields were
     *   modified, so it's OK  to copy all fields back.
     */
    RtlCopyMemory(lpmii, &miiLocal, SIZEOFMENUITEMINFO95);
    lpmii->cbSize = cbCallercbSize;
    if (cbCallercbSize > SIZEOFMENUITEMINFO95) {
        lpmii->hbmpItem = miiLocal.hbmpItem;
    }

    if (lpmii->fMask & MIIM_TYPE) {
        if ((miiLocal.hbmpItem != NULL) && (miiLocal.dwTypeData == NULL)) {
            lpmii->fType |= MFT_BITMAP;
            lpmii->dwTypeData = (LPTSTR)miiLocal.hbmpItem;
        } else if (miiLocal.cch == 0) {
            lpmii->dwTypeData = NULL;
        }
        lpmii->fMask &= ~(MIIM_FTYPE | MIIM_BITMAP | MIIM_STRING);
    }

    return TRUE;
}
/***************************************************************************\
* SetMenuItemInfo
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetMenuItemInfoW, HMENU, hMenu, UINT, uID, BOOL, fByPosition, LPCMENUITEMINFO, lpmii)
#else
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetMenuItemInfoA, HMENU, hMenu, UINT, uID, BOOL, fByPosition, LPCMENUITEMINFO, lpmii)
#endif // UNICODE
BOOL SetMenuItemInfo(HMENU hMenu, UINT uID, BOOL fByPosition, LPCMENUITEMINFO lpmii)
{

    MENUITEMINFOW miiLocal;

    if (!ValidateMENUITEMINFO((LPMENUITEMINFOW)lpmii, &miiLocal, MENUAPI_SET)) {
        return FALSE;
    }

    return (ThunkedMenuItemInfo(hMenu, uID, fByPosition, FALSE, &miiLocal, IS_ANSI));
}
/***************************************************************************\
* InsertMenuItem
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
BOOL InsertMenuItem (HMENU hMenu, UINT uID, BOOL fByPosition, LPCMENUITEMINFO lpmii)
{

    MENUITEMINFOW miiLocal;

    if (!ValidateMENUITEMINFO((LPMENUITEMINFOW)lpmii, &miiLocal, MENUAPI_SET)) {
        return FALSE;
    }

    return (ThunkedMenuItemInfo(hMenu, uID, fByPosition, TRUE, &miiLocal, IS_ANSI));
}

/***************************************************************************\
* InsertMenu
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, InsertMenuW, HMENU, hMenu, UINT, uPosition, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#else
FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, InsertMenuA, HMENU, hMenu, UINT, uPosition, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#endif // UNICODE
BOOL InsertMenu(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCTSTR lpNewItem)
{
    MENUITEMINFOW miiLocal;

    SetMenuItemInfoStruct(hMenu, uFlags, uIDNewItem, (LPWSTR)lpNewItem, &miiLocal);
    return ThunkedMenuItemInfo(hMenu, uPosition, (BOOL) (uFlags & MF_BYPOSITION), TRUE, (LPMENUITEMINFOW)&miiLocal, IS_ANSI);
}

/***************************************************************************\
* AppendMenu
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, AppendMenuW, HMENU, hMenu, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#else
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, AppendMenuA, HMENU, hMenu, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#endif // UNICODE
BOOL AppendMenu(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCTSTR lpNewItem)
{
    MENUITEMINFOW miiLocal;

    SetMenuItemInfoStruct(hMenu, uFlags, uIDNewItem, (LPWSTR)lpNewItem, &miiLocal);
    return ThunkedMenuItemInfo(hMenu, MFMWFP_NOITEM, MF_BYPOSITION, TRUE, (LPMENUITEMINFOW)&miiLocal, IS_ANSI);
}
/***************************************************************************\
* ModifyMenu
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ModifyMenuW, HMENU, hMenu, UINT, uPosition, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#else
FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ModifyMenuA, HMENU, hMenu, UINT, uPosition, UINT, uFlags, UINT_PTR, uIDNewItem, LPCTSTR, lpNewItem)
#endif // UNICODE
BOOL ModifyMenu(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCTSTR lpNewItem)
{
    MENUITEMINFOW miiLocal;

    SetMenuItemInfoStruct(hMenu, uFlags, uIDNewItem, (LPWSTR)lpNewItem, &miiLocal);
    return ThunkedMenuItemInfo(hMenu, uPosition, (BOOL) (uFlags & MF_BYPOSITION), FALSE, (LPMENUITEMINFOW)&miiLocal, IS_ANSI);
}

/***************************************************************************\
* BroadcastSystemMessageEx
*
* History:
*
\***************************************************************************/
#ifdef UNICODE
FUNCLOG6(LOG_GENERAL, LONG, WINUSERAPI, BroadcastSystemMessageExW, DWORD, dwFlags, LPDWORD, lpdwRecipients, UINT, uiMessage, WPARAM, wParam, LPARAM, lParam, PBSMINFO, pBSMInfo)
#else
FUNCLOG6(LOG_GENERAL, LONG, WINUSERAPI, BroadcastSystemMessageExA, DWORD, dwFlags, LPDWORD, lpdwRecipients, UINT, uiMessage, WPARAM, wParam, LPARAM, lParam, PBSMINFO, pBSMInfo)
#endif // UNICODE

WINUSERAPI LONG BroadcastSystemMessageEx(DWORD dwFlags, LPDWORD lpdwRecipients,
    UINT uiMessage, WPARAM wParam, LPARAM lParam, PBSMINFO pBSMInfo)
{
    return BroadcastSystemMessageWorker(dwFlags, lpdwRecipients,
        uiMessage, wParam, lParam, pBSMInfo, IS_ANSI);
}

/***************************************************************************\
* BroadcastSystemMessage
*
* History:
*  07-22-96 GerardoB - Added header
\***************************************************************************/
#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, LONG, WINUSERAPI, BroadcastSystemMessageW, DWORD, dwFlags, LPDWORD, lpdwRecipients, UINT, uiMessage, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG5(LOG_GENERAL, LONG, WINUSERAPI, BroadcastSystemMessageA, DWORD, dwFlags, LPDWORD, lpdwRecipients, UINT, uiMessage, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE

WINUSERAPI LONG BroadcastSystemMessage(DWORD dwFlags, LPDWORD lpdwRecipients,
    UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    return BroadcastSystemMessageWorker(dwFlags, lpdwRecipients,
        uiMessage, wParam, lParam, NULL, IS_ANSI);
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, UINT, WINUSERAPI, GetWindowModuleFileNameW, HWND, hwnd, LPTSTR, pszFileName, UINT, cchFileNameMax)
#else
FUNCLOG3(LOG_GENERAL, UINT, WINUSERAPI, GetWindowModuleFileNameA, HWND, hwnd, LPTSTR, pszFileName, UINT, cchFileNameMax)
#endif // UNICODE

WINUSERAPI UINT WINAPI
GetWindowModuleFileName(HWND hwnd, LPTSTR pszFileName, UINT cchFileNameMax)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL) {
        return 0;
    }

    return GetModuleFileName(KHANDLE_TO_HANDLE(pwnd->hModule), pszFileName, cchFileNameMax);
}

/***************************************************************************\
* RegisterDeviceNotification
*
* History:
*  01-23-97 PaulaT - Added header
\***************************************************************************/

WINUSERAPI HDEVNOTIFY WINAPI
RegisterDeviceNotification(
    IN HANDLE hRecipient,
    IN LPVOID NotificationFilter,
    IN DWORD Flags
    )
{
    extern HDEVNOTIFY RegisterDeviceNotificationWorker(IN HANDLE hRecipient,
                                                       IN LPVOID NotificationFilter,
                                                       IN DWORD Flags,
                                                       IN BOOL IsAnsi
                                                       );

    // translate strings in NotificationFilter (if any)

    return RegisterDeviceNotificationWorker(hRecipient,
                                            NotificationFilter,
                                            Flags,
                                            IS_ANSI
                                            );
}



/***************************************************************************\
* GetMonitorInfo
*
* History:
* 31-Mar-1997 adams     Doesn't call into kernel.
* 06-Jul-1998 MCostea   Has to call into kernel #190510
\***************************************************************************/
#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, BOOL, WINUSERAPI, GetMonitorInfoW, HMONITOR, hMonitor, LPMONITORINFO, lpmi)
#else
FUNCLOG2(LOG_GENERAL, BOOL, WINUSERAPI, GetMonitorInfoA, HMONITOR, hMonitor, LPMONITORINFO, lpmi)
#endif // UNICODE

BOOL WINUSERAPI
GetMonitorInfo(HMONITOR hMonitor, LPMONITORINFO lpmi)
{
    PMONITOR    pMonitor;
    BOOL        bRetVal;
    int         cbSize;

    pMonitor = VALIDATEHMONITOR(hMonitor);
    if (!pMonitor) {
        return FALSE;
    }

    cbSize = lpmi->cbSize;
    if (cbSize == sizeof(MONITORINFO)) {
        /*
         * Check for this first, since it is the most
         * common size. All the work for filling in
         * MONITORINFO fields is done after the else-if
         * statements.
         */

    } else if (cbSize == sizeof(MONITORINFOEX)) {
        /*
         * The ANSI version has to translate the szDevice field
         */
        ULONG_PTR pName;
#if IS_ANSI
        WCHAR szDevice[CCHDEVICENAME];
        pName = (ULONG_PTR)szDevice;
#else
        pName = (ULONG_PTR)(((LPMONITORINFOEX)lpmi)->szDevice);
#endif
        bRetVal = (BOOL)NtUserCallTwoParam((ULONG_PTR)(hMonitor),
                           pName,
                           SFI_GETHDEVNAME);
        if (!bRetVal) {
            return FALSE;
        }
#if IS_ANSI
        WideCharToMultiByte(
            CP_ACP, 0,                                  // ANSI -> Unicode
            (LPWSTR)pName, -1,                          // source & length
            (LPSTR)((LPMONITORINFOEX)lpmi)->szDevice,   // destination & length
            sizeof(WCHAR)*CCHDEVICENAME,
            NULL, NULL);

#endif
    } else {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid lpmi->cbSize, %d", lpmi->cbSize);

        return FALSE;
    }

    lpmi->dwFlags = (pMonitor == GetPrimaryMonitor()) ? MONITORINFOF_PRIMARY : 0;
    lpmi->rcMonitor = pMonitor->rcMonitor;
    lpmi->rcWork = pMonitor->rcWork;

    return TRUE;
}

#ifdef GENERIC_INPUT
#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, UINT, WINUSERAPI, GetRawInputDeviceInfoW, HANDLE, hDevice, UINT, uiCommand, LPVOID, pData, PUINT, pcbSize)
#else
FUNCLOG4(LOG_GENERAL, UINT, WINUSERAPI, GetRawInputDeviceInfoA, HANDLE, hDevice, UINT, uiCommand, LPVOID, pData, PUINT, pcbSize)
#endif // UNICODE
UINT WINUSERAPI
GetRawInputDeviceInfo(
    HANDLE hDevice,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize)
{
#if IS_ANSI
    UINT uiRet;
    LPVOID lpParam = pData;
    WCHAR wszPath[MAX_PATH];
    UINT cbBufferSize = 0;

    if (uiCommand == RIDI_DEVICENAME) {
        if (pData) {
            lpParam = wszPath;
            cbBufferSize = *pcbSize;
        }
    }

    uiRet = NtUserGetRawInputDeviceInfo(hDevice, uiCommand, lpParam, pcbSize);

    if (uiCommand == RIDI_DEVICENAME) {
        if (uiRet == (UINT)-1 && pData != NULL) {
            /* Insufficient buffer */
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                *pcbSize *= DBCS_CHARSIZE;
            }
        } else if (uiRet == 0 && pData == NULL) {
            /* The app wants the buffer size for the device name */
            *pcbSize *= DBCS_CHARSIZE;
        } else {
            uiRet = WCSToMB(lpParam, uiRet, (LPSTR*)&pData, cbBufferSize, FALSE);

            /* TODO:
             * Handle the case if cbBufferSize was not enough.
             */
        }
    }

    return uiRet;
#else
    return NtUserGetRawInputDeviceInfo(hDevice, uiCommand, pData, pcbSize);
#endif
}
#endif // GENERIC_INPUT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\clres.c ===
/****************************** Module Header ******************************\
* Module Name: clres.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Resource Loading/Creation Routines
*
* History:
* 24-Sep-1990 MikeKe    From win30
* 19-Sep-1995 ChrisWil  Win95/NT merge.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Constants.
 */
#define BPP01_MAXCOLORS     2
#define BPP04_MAXCOLORS    16
#define BPP08_MAXCOLORS   256
#define ICON_DEFAULTDEPTH   8
#define ICON_MAXWIDTH     256
#define ICON_MAXHEIGHT    256

#define RESCLR_BLACK      0x00000000
#define RESCLR_WHITE      0x00FFFFFF

typedef struct {
    ACCEL accel;
    WORD  padding;
} RESOURCE_ACCEL, *PRESOURCE_ACCEL;

/*
 * Bitmap resource IDs
 */
#define BMR_ICON    1
#define BMR_BITMAP  2
#define BMR_CURSOR  3

typedef struct _OLDCURSOR {
    BYTE bType;
    BYTE bFormat;
    WORD xHotSpot;  // 0 for icons
    WORD yHotSpot;  // 0 for icons
    WORD cx;
    WORD cy;
    WORD cxBytes;
    WORD wReserved2;
    BYTE abBitmap[1];
} OLDCURSOR, *POLDCURSOR;
typedef OLDCURSOR UNALIGNED *UPOLDCURSOR;

/*
 * Local Macros.
 */
#define GETINITDC() \
    (gfSystemInitialized ? NtUserGetDC(NULL) : CreateDCW(L"DISPLAY", L"", NULL, NULL))

#define RELEASEINITDC(hdc) \
    (gfSystemInitialized ? ReleaseDC(NULL, hdc) : DeleteDC(hdc))

#define ISRIFFFORMAT(p) \
    (((UNALIGNED RTAG *)(p))->ckID == FOURCC_RIFF)

#define MR_FAILFOR40    0x01
#define MR_MONOCHROME   0x02


typedef struct tagMAPRES {
    WORD idDisp;                // display driver ID
    WORD idUser;                // USER ID
    BYTE bFlags;                // Flags
    BYTE bReserved;             // unused
} MAPRES, *LPMAPRES, *PMAPRES;


HBITMAP CopyBmp(HBITMAP hbmpOrg, int cxNew, int cyNew, UINT LR_flags);

/***************************************************************************\
* SplFindResource
*
* Check whether the hInstance passed is that of the present display driver;
* if so, it will call the GetDriverResourceId() in the display to allow
* it to map the given id/name to a new id/name.  Then it will call
* FindResource9) in KERNEL.
*
* 13-Nov-1995 SanfordS  Added mapping for DEFAULT constants.
\***************************************************************************/

HANDLE SplFindResource(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    LPCWSTR   lpType)
{
    return FINDRESOURCEW(hmod, lpName, lpType);
}

/***************************************************************************\
* SplFreeResource
*
* Really frees a resource that is shared (won't be touched again unless
* LR_COPYFROMRESOURCE is used) or system.
*
* 13-Nov-1995 SanfordS  Added mapping for DEFAULT constants.
\***************************************************************************/

VOID SplFreeResource(
    HANDLE    hRes,
    HINSTANCE hmod,
    UINT      lrFlags)
{
    if (!FREERESOURCE(hRes, hmod) &&
        ((hmod == hmodUser) || (lrFlags & LR_SHARED))) {

        FREERESOURCE(hRes, hmod);
    }
}

/***********************************************************************\
* WowGetModuleFileName
*
* This converts a WOW or non-WOW module handle to a string form that
* can be restored even for WOW handles.
*
* Returns: fSuccess
*
* 29-Nov-1995 SanfordS  Created.
\***********************************************************************/

BOOL WowGetModuleFileName(
    HMODULE hModule,
    LPWSTR  pwsz,
    DWORD   cchMax)
{
    if (!GetModuleFileName(hModule, pwsz, cchMax)) {

        if (cchMax < 10) {
            RIPMSG0(RIP_WARNING, "WowGetModuleFileName: exceeded Char-Max");
            return FALSE;
        }

        wsprintf(pwsz, TEXT("\001%08lx"), hModule);
    }

    return TRUE;
}

/***********************************************************************\
* WowGetModuleHandle
*
* This restores the string form of a module handle created by
* WowGetModuleFileName to the original handle.
*
* Returns: fSuccess
*
* 29-Nov-1995 Created   SanfordS
\***********************************************************************/

HMODULE WowGetModuleHandle(
    LPCWSTR pwsz)
{
    HMODULE hMod = NULL;
    DWORD   digit;

    if (pwsz[0] == TEXT('\001')) {

        /*
         * Cant seem to link to swscanf without CRT0 problems so just
         * do it by hand.
         */
        while (*(++pwsz)) {

            if (*pwsz == TEXT(' '))
                continue;

            digit = *pwsz - TEXT('0');

            if (digit > 9)
                digit += (DWORD)(TEXT('0') - TEXT('a') + 10);

            (ULONG_PTR)hMod <<= 4;
            (ULONG_PTR)hMod += digit;
        }

    } else {

        hMod = GetModuleHandle(pwsz);
    }

    return hMod;
}

/***************************************************************************\
* CreateAcceleratorTableA (API)
*
* Creates an accel table, returns handle to accel table.
*
* 02-May-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HACCEL, WINAPI, CreateAcceleratorTableA, LPACCEL, paccel, int, cAccel)
HACCEL WINAPI CreateAcceleratorTableA(
    LPACCEL paccel,
    int     cAccel)
{
    int     nAccel = cAccel;
    LPACCEL pAccelT = paccel;

    /*
     * Convert any character keys from ANSI to Unicode.
     */
    while (nAccel--) {

        if ((pAccelT->fVirt & FVIRTKEY) == 0) {

            if (!NT_SUCCESS(RtlMultiByteToUnicodeN((LPWSTR)&(pAccelT->key),
                                                   sizeof(WCHAR),
                                                   NULL,
                                                   (LPSTR)&(pAccelT->key),
                                                   sizeof(CHAR)))) {
                pAccelT->key = 0xFFFF;
            }
        }

        pAccelT++;
    }

    return NtUserCreateAcceleratorTable(paccel, cAccel);
}

/***************************************************************************\
* CopyAcceleratorTableA (API)
*
* Copies an accel table
*
* 02-May-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, CopyAcceleratorTableA, HACCEL, hacc, LPACCEL, paccel, int, length)
int CopyAcceleratorTableA(
    HACCEL hacc,
    LPACCEL paccel,
    int length)
{
    int retval;

    retval = NtUserCopyAcceleratorTable(hacc, paccel, length);

    /*
     * If we are doing a copy and we succeeded then convert the accelerator
     */
    if ((paccel != NULL) && (retval > 0)) {

        /*
         * Translate UNICODE character keys to ANSI
         */
        int nAccel = retval;
        LPACCEL pAccelT = paccel;

        while (nAccel--) {
            if ((pAccelT->fVirt & FVIRTKEY) == 0) {
                if (!NT_SUCCESS(RtlUnicodeToMultiByteN((PCHAR)&(pAccelT->key),
                                                       sizeof(WCHAR),
                                                       NULL,
                                                       (PWSTR)&(pAccelT->key),
                                                        sizeof(pAccelT->key)))) {
                        pAccelT->key = 0;
                    }
                }
            pAccelT++;
        }
    }

    return retval;
}

/***************************************************************************\
* FindAccResource
*
* Resource accelerator tables are to be loaded only once to be compatible
*  with Win95. So we keep track of the addresses we've loaded tables from
*  and the corresponding handle.
*
* This function finds an entry in the table. It returns the address
*  of the pacNext pointer that contains the requested entry.
*
* 01/31/97 GerardoB     Created.
\***************************************************************************/
PACCELCACHE * FindAccResource (HACCEL hAccel, PVOID pRes)
{
     /************************************
     * The caller must own gcsAccelCache *
     *************************************/

    PACCELCACHE * ppacNext = &gpac;
    PACCELCACHE pac;

    /*
     * This is meant to search by handle or by pointer, not both
     * So at least one of the parameters must be NULL.
     */
    UserAssert(!(hAccel && pRes));
    /*
     * Walk the table
     */
    while (*ppacNext != NULL) {
        pac = *ppacNext;
        if ((pac->pRes == pRes) || (pac->hAccel == hAccel)) {
            /*
            * Found it. Validate this entry before returning.
            */
            UserAssert(pac->dwLockCount != 0);
            UserAssert(HMValidateHandleNoDesktop(pac->hAccel, TYPE_ACCELTABLE));
            break;
        }

        ppacNext = &(pac->pacNext);
    }

    return ppacNext;
}
/***************************************************************************\
* AddAccResource
*
* This is called everytime LoadAcc loads a new table. It adds an
*  entry (handle and resource address) to the global list and
*  sets the lock count to 1
*
* 01/31/97 GerardoB     Created.
\***************************************************************************/
void AddAccResource (HACCEL hAccel, PVOID pRes)
{
    PACCELCACHE pac;

    UserAssert(HMValidateHandleNoDesktop(hAccel, TYPE_ACCELTABLE));
    UserAssert(pRes != NULL);

    /*
     * Allocate and initialize a new entry.
     */
    pac = (PACCELCACHE)LocalAlloc(LPTR, sizeof(ACCELCACHE));
    if (pac != NULL) {
        pac->dwLockCount = 1;
        pac->hAccel = hAccel;
        pac->pRes = pRes;

        /*
         * Make it the new head of the list
         */
        RtlEnterCriticalSection(&gcsAccelCache);
            pac->pacNext = gpac;
            gpac = pac;
        RtlLeaveCriticalSection(&gcsAccelCache);

    }
}
/***************************************************************************\
* DestroyAcceleratorTable
*
* 01/31/97 GerardoB     Created.
\***************************************************************************/
BOOL DestroyAcceleratorTable (HACCEL hAccel)
{
    BOOL fUnlocked = TRUE;
    PACCELCACHE *ppacNext, pac;

    /*
     * If we added this table to our list, decrement the lock count
     */
    RtlEnterCriticalSection(&gcsAccelCache);
        ppacNext = FindAccResource(hAccel, NULL);
        if (*ppacNext != NULL) {
            pac = *ppacNext;
            /*
             * Found it. Decrement lock count.
             */
            UserAssert(pac->dwLockCount != 0);
            fUnlocked = (--pac->dwLockCount == 0);
            /*
             * If noboby else wants this around, unlink it and nuke it.
             */
            if (fUnlocked) {
                *ppacNext = pac->pacNext;
                LocalFree(pac);
            }
        }
    RtlLeaveCriticalSection(&gcsAccelCache);

    /*
     * If not totally deref'ed, return FALSE (win95 compat).
     */
    if (fUnlocked) {
        return NtUserDestroyAcceleratorTable(hAccel);
    } else {
        return FALSE;
    }
}
/***************************************************************************\
* LoadAcc (Worker)
*
* This is the worker-routine for loading accelerator tables.
*
\***************************************************************************/

#define FACCEL_VALID (FALT | FCONTROL | FNOINVERT | FSHIFT | FVIRTKEY | FLASTKEY)

HANDLE LoadAcc(
    HINSTANCE hmod,
    HANDLE    hrl)
{
    PACCELCACHE * ppacNext;
    HANDLE handle = NULL;

    if (hrl != NULL) {

        if (hrl = LOADRESOURCE(hmod, hrl)) {

            PRESOURCE_ACCEL paccel;

            if ((paccel = (PRESOURCE_ACCEL)LOCKRESOURCE(hrl, hmod)) != NULL) {

                int nAccel = 0;
                int i;
                LPACCEL paccelT;

                /*
                 * Check if we've already loaded accelerators from this
                 *  same address
                 */
                RtlEnterCriticalSection(&gcsAccelCache);
                    ppacNext = FindAccResource(NULL, paccel);
                    if (*ppacNext != NULL) {
                        (*ppacNext)->dwLockCount++;
                        handle = (*ppacNext)->hAccel;
                    }
                RtlLeaveCriticalSection(&gcsAccelCache);
                /*
                 * If we found this table on the global list,
                 *  return the same handle (Win95 compat)
                 */
                if (handle != NULL) {
                    goto UnlockAndFree;
                }

                while (!((paccel[nAccel].accel.fVirt) & FLASTKEY)) {

                    if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {
                        RIPMSG0(RIP_WARNING, "LoadAcc: Invalid Parameter");
                        goto UnlockAndFree;
                    }

                    nAccel++;
                }

                if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {
                    RIPMSG0(RIP_WARNING, "LoadAcc: Invalid Parameter");
                    goto UnlockAndFree;
                }

                /*
                 * Since the accelerator table is coming from a resource, each
                 * element has an extra WORD of padding which we strip here
                 * to conform with the public (and internal) ACCEL structure.
                 */
                paccelT = UserLocalAlloc(0, sizeof(ACCEL) * (nAccel + 1));
                if (paccelT == NULL) {
                    goto UnlockAndFree;
                }
                for (i = 0; i < nAccel + 1; i++) {
                    paccelT[i] = paccel[i].accel;
                }

                handle = NtUserCreateAcceleratorTable(paccelT,
                                                      nAccel + 1);

                UserLocalFree(paccelT);

                /*
                 * Add this handle/address to the global table so
                 *  we won't load it twice.
                 */
                if (handle != NULL) {
                    AddAccResource(handle, paccel);
                }
UnlockAndFree:

                UNLOCKRESOURCE(hrl, hmod);
            }

            FREERESOURCE(hrl, hmod);
        }
    }

    return handle;
}

/***************************************************************************\
* LoadAcceleratorsA (API)
* LoadAcceleratorsW (API)
*
*
* 24-Sep-1990 MikeKe    From Win30
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HACCEL, WINAPI, LoadAcceleratorsA, HINSTANCE, hmod, LPCSTR, lpAccName)
HACCEL WINAPI LoadAcceleratorsA(
    HINSTANCE hmod,
    LPCSTR    lpAccName)
{
    HANDLE hRes;

    hRes = FINDRESOURCEA((HANDLE)hmod, lpAccName, (LPSTR)RT_ACCELERATOR);

    return (HACCEL)LoadAcc(hmod, hRes);
}


FUNCLOG2(LOG_GENERAL, HACCEL, WINAPI, LoadAcceleratorsW, HINSTANCE, hmod, LPCWSTR, lpAccName)
HACCEL WINAPI LoadAcceleratorsW(
    HINSTANCE hmod,
    LPCWSTR   lpAccName)
{
    HANDLE hRes;

    hRes = FINDRESOURCEW((HANDLE)hmod, lpAccName, RT_ACCELERATOR);

    return (HACCEL)LoadAcc(hmod, hRes);
}

/***************************************************************************\
* LoadStringA (API)
* LoadStringW (API)
*
*
* 05-Apr-1991 ScottLu   Fixed to work with client/server.
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, int, WINAPI, LoadStringA, HINSTANCE, hmod, UINT, wID, LPSTR, lpAnsiBuffer, int, cchBufferMax)
int WINAPI LoadStringA(
    HINSTANCE hmod,
    UINT      wID,
    LPSTR     lpAnsiBuffer,
    int       cchBufferMax)
{
    LPWSTR          lpUniBuffer;
    INT             cchUnicode;
    INT             cbAnsi = 0;

    /*
     * LoadStringOrError appends a NULL but does not include it in the
     * return count-of-bytes
     */
    cchUnicode = LoadStringOrError((HANDLE)hmod,
                                      wID,
                                      (LPWSTR)&lpUniBuffer,
                                      0,
                                      0);

    if (cchUnicode) {

        cbAnsi = WCSToMB(lpUniBuffer,
                         cchUnicode,
                         &lpAnsiBuffer,
                         cchBufferMax - 1,
                         FALSE);

        cbAnsi = min(cbAnsi, cchBufferMax - 1);
    }

    /*
     * Append a NULL but do not include it in the count returned
     */
    lpAnsiBuffer[cbAnsi] = 0;
    return cbAnsi;
}


FUNCLOG4(LOG_GENERAL, int, WINAPI, LoadStringW, HINSTANCE, hmod, UINT, wID, LPWSTR, lpBuffer, int, cchBufferMax)
int WINAPI LoadStringW(
    HINSTANCE hmod,
    UINT      wID,
    LPWSTR    lpBuffer,
    int       cchBufferMax)
{
    return LoadStringOrError((HANDLE)hmod,
                                wID,
                                lpBuffer,
                                cchBufferMax,
                                0);
}

/***************************************************************************\
* SkipIDorString
*
* Skips string (or ID) and returns the next aligned WORD.
*
\***************************************************************************/

PBYTE SkipIDorString(
    LPBYTE pb)
{
    if (*((LPWORD)pb) == 0xFFFF)
        return (pb + 4);

    while (*((PWCHAR)pb)++ != 0);

    return pb;
}

/***************************************************************************\
* GetSizeDialogTemplate
*
* This gets called by thank produced stubs. It returns the size of a
* dialog template.
*
* 07-Apr-1991 ScottLu   Created.
\***************************************************************************/

DWORD GetSizeDialogTemplate(
    HINSTANCE      hmod,
    LPCDLGTEMPLATE pdt)
{
    UINT           cdit;
    LPBYTE         pb;
    BOOL           fChicago;
    LPDLGTEMPLATE2 pdt2;

    if (HIWORD(pdt->style) == 0xFFFF) {

        pdt2 = (LPDLGTEMPLATE2)pdt;
        fChicago = TRUE;

        /*
         * Fail if the app is passing invalid style bits.
         */
        if (pdt2->style & ~(DS_VALID40 | 0xffff0000)) {
            RIPMSG0(RIP_WARNING, "Bad dialog style bits - please remove");
            return 0;
        }

        pb = (LPBYTE)(((LPDLGTEMPLATE2)pdt) + 1);

    } else {

        fChicago = FALSE;

        /*
         * Check if invalid style bits are being passed. Fail if the app
         * is a new app ( >= VER40).
         * This is to ensure that we are compatible with Chicago.
         */
        if ((pdt->style & ~(DS_VALID40 | 0xffff0000)) &&
                (GETEXPWINVER(hmod) >= VER40)) {

            /*
             * It's a new app with invalid style bits - fail.
             */
            RIPMSG0(RIP_WARNING, "Bad dialog style bits - please remove");
            return 0;
        }

        pb = (LPBYTE)(pdt + 1);
    }

    /*
     * If there is a menu ordinal, add 4 bytes skip it. Otherwise it is a
     * string or just a 0.
     */
    pb = SkipIDorString(pb);

    /*
     * Skip window class and window text, adjust to next word boundary.
     */
    pb = SkipIDorString(pb);
    pb = SkipIDorString(pb);

    /*
     * Skip font type, size and name, adjust to next dword boundary.
     */
    if ((fChicago ? pdt2->style : pdt->style) & DS_SETFONT) {
        pb += fChicago ? sizeof(DWORD) + sizeof(WORD): sizeof(WORD);
        pb = SkipIDorString(pb);
    }
    pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);

    /*
     * Loop through dialog items now...
     */
    cdit = fChicago ? pdt2->cDlgItems : pdt->cdit;

    while (cdit-- != 0) {

        UINT cbCreateParams;

        pb += fChicago ? sizeof(DLGITEMTEMPLATE2) : sizeof(DLGITEMTEMPLATE);

        /*
         * Skip the dialog control class name.
         */
        pb = SkipIDorString(pb);

        /*
         * Look at window text now.
         */
        pb = SkipIDorString(pb);

        cbCreateParams = *((LPWORD)pb);

        /*
         * skip any CreateParams which include the generated size WORD.
         */
        if (cbCreateParams)
            pb += cbCreateParams;

        pb += sizeof(WORD);

        /*
         * Point at the next dialog item. (DWORD aligned)
         */
        pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);
    }

    /*
     * Return template size.
     */
    return (DWORD)(pb - (LPBYTE)pdt);
}

/***************************************************************************\
* DialogBoxIndirectParamA (API)
* DialogBoxIndirectParamW (API)
*
* Creates the dialog and goes into a modal loop processing input for it.
*
* 05-Apr-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, INT_PTR, WINAPI, DialogBoxIndirectParamA, HINSTANCE, hmod, LPCDLGTEMPLATEA, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
INT_PTR WINAPI DialogBoxIndirectParamA(
    HINSTANCE       hmod,
    LPCDLGTEMPLATEA lpDlgTemplate,
    HWND            hwndOwner,
    DLGPROC         lpDialogFunc,
    LPARAM          dwInitParam)
{
    return DialogBoxIndirectParamAorW(hmod,
                                      (LPCDLGTEMPLATEW)lpDlgTemplate,
                                      hwndOwner,
                                      lpDialogFunc,
                                      dwInitParam,
                                      SCDLG_ANSI);
}


FUNCLOG5(LOG_GENERAL, INT_PTR, WINAPI, DialogBoxIndirectParamW, HINSTANCE, hmod, LPCDLGTEMPLATEW, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
INT_PTR WINAPI DialogBoxIndirectParamW(
    HINSTANCE       hmod,
    LPCDLGTEMPLATEW lpDlgTemplate,
    HWND            hwndOwner,
    DLGPROC         lpDialogFunc,
    LPARAM          dwInitParam)
{
    return DialogBoxIndirectParamAorW(hmod,
                                      lpDlgTemplate,
                                      hwndOwner,
                                      lpDialogFunc,
                                      dwInitParam,
                                      0);
}


FUNCLOG6(LOG_GENERAL, INT_PTR, WINAPI, DialogBoxIndirectParamAorW, HINSTANCE, hmod, LPCDLGTEMPLATEW, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam, UINT, fAnsiFlags)
INT_PTR WINAPI DialogBoxIndirectParamAorW(
    HINSTANCE       hmod,
    LPCDLGTEMPLATEW lpDlgTemplate,
    HWND            hwndOwner,
    DLGPROC         lpDialogFunc,
    LPARAM          dwInitParam,
    UINT            fAnsiFlags)
{
    DWORD cb;

    /*
     * The server routine destroys the menu if it fails.
     */
    cb = GetSizeDialogTemplate(hmod, lpDlgTemplate);

    if (!cb) {
        RIPMSG0(RIP_WARNING, "DialogBoxIndirectParam: Invalid Paramter");
        return -1;
    }

    return InternalDialogBox(hmod,
                            (LPDLGTEMPLATE)lpDlgTemplate,
                            hwndOwner,
                            lpDialogFunc,
                            dwInitParam,
                            SCDLG_CLIENT | (fAnsiFlags & (SCDLG_ANSI | SCDLG_16BIT)));
}

/***************************************************************************\
* CreateDialogIndirectParamA (API)
* CreateDialogIndirectParamW (API)
*
* Creates a dialog given a template and return s the window handle.
* fAnsi determines if the dialog has an ANSI or UNICODE lpDialogFunc
*
* 05-Apr-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, HWND, WINAPI, CreateDialogIndirectParamA, HINSTANCE, hmod, LPCDLGTEMPLATEA, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
HWND WINAPI CreateDialogIndirectParamA(
    HINSTANCE       hmod,
    LPCDLGTEMPLATEA lpDlgTemplate,
    HWND            hwndOwner,
    DLGPROC         lpDialogFunc,
    LPARAM          dwInitParam)
{
    return CreateDialogIndirectParamAorW(hmod,
                                         (LPCDLGTEMPLATE)lpDlgTemplate,
                                         hwndOwner,
                                         lpDialogFunc,
                                         dwInitParam,
                                         SCDLG_ANSI);
}


FUNCLOG5(LOG_GENERAL, HWND, WINAPI, CreateDialogIndirectParamW, HINSTANCE, hmod, LPCDLGTEMPLATEW, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
HWND WINAPI CreateDialogIndirectParamW(
    HINSTANCE       hmod,
    LPCDLGTEMPLATEW lpDlgTemplate,
    HWND            hwndOwner,
    DLGPROC         lpDialogFunc,
    LPARAM          dwInitParam)
{
    return CreateDialogIndirectParamAorW(hmod,
                                         (LPCDLGTEMPLATE)lpDlgTemplate,
                                         hwndOwner,
                                         lpDialogFunc,
                                         dwInitParam,
                                         0);
}


FUNCLOG6(LOG_GENERAL, HWND, WINAPI, CreateDialogIndirectParamAorW, HANDLE, hmod, LPCDLGTEMPLATE, lpDlgTemplate, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam, UINT, fAnsi)
HWND WINAPI CreateDialogIndirectParamAorW(
    HANDLE         hmod,
    LPCDLGTEMPLATE lpDlgTemplate,
    HWND           hwndOwner,
    DLGPROC        lpDialogFunc,
    LPARAM         dwInitParam,
    UINT           fAnsi)
{
    DWORD cb;
    HWND  hwndRet;

    /*
     * The server routine destroys the menu if it fails.
     */
    cb = GetSizeDialogTemplate(hmod, lpDlgTemplate);

    if (!cb) {
        RIPMSG0(RIP_WARNING, "CreateDialogIndirect: Invalid Parameter");
        return NULL;
    }

    hwndRet = InternalCreateDialog(hmod,
                                   (LPDLGTEMPLATE)lpDlgTemplate,
                                   cb,
                                   hwndOwner,
                                   lpDialogFunc,
                                   dwInitParam,
                                   SCDLG_CLIENT | (fAnsi & (SCDLG_ANSI|SCDLG_16BIT)));

    return hwndRet;
}

/***************************************************************************\
* DialogBoxParamA (API)
* DialogBoxParamW (API)
*
* Loads the resource, creates the dialog and goes into a modal loop processing
* input for it.
*
* 05-Apr-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, INT_PTR, WINAPI, DialogBoxParamA, HINSTANCE, hmod, LPCSTR, lpName, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
INT_PTR WINAPI DialogBoxParamA(
    HINSTANCE hmod,
    LPCSTR    lpName,
    HWND      hwndOwner,
    DLGPROC   lpDialogFunc,
    LPARAM    dwInitParam)
{
    HANDLE h;
    PVOID  p;
    INT_PTR i = -1;

    if (h = FINDRESOURCEA(hmod, (LPSTR)lpName, (LPSTR)RT_DIALOG)) {

        if (h = LOADRESOURCE(hmod, h)) {

            if (p = LOCKRESOURCE(h, hmod)) {

                i = DialogBoxIndirectParamAorW(hmod,
                                               p,
                                               hwndOwner,
                                               lpDialogFunc,
                                               dwInitParam,
                                               SCDLG_ANSI);

                UNLOCKRESOURCE(h, hmod);
            }

            FREERESOURCE(h, hmod);
        }
    }

    return i;
}


FUNCLOG5(LOG_GENERAL, INT_PTR, WINAPI, DialogBoxParamW, HINSTANCE, hmod, LPCWSTR, lpName, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
INT_PTR WINAPI DialogBoxParamW(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    HWND      hwndOwner,
    DLGPROC   lpDialogFunc,
    LPARAM    dwInitParam)
{
    HANDLE h;
    PVOID  p;
    INT_PTR i = -1;

    if (h = FINDRESOURCEW(hmod, lpName, RT_DIALOG)) {

        if (p = LoadResource(hmod, h)) {

            i = DialogBoxIndirectParamAorW(hmod,
                                           p,
                                           hwndOwner,
                                           lpDialogFunc,
                                           dwInitParam,
                                           0);
        }
    }

    return i;
}

/***************************************************************************\
* CreateDialogParamA (API)
* CreateDialogParamW (API)
*
* Loads the resource, creates a dialog from that template, return s the
* window handle.
*
* 05-Apr-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, HWND, WINAPI, CreateDialogParamA, HINSTANCE, hmod, LPCSTR, lpName, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
HWND WINAPI CreateDialogParamA(
    HINSTANCE hmod,
    LPCSTR    lpName,
    HWND      hwndOwner,
    DLGPROC   lpDialogFunc,
    LPARAM    dwInitParam)
{
    HANDLE         h;
    LPDLGTEMPLATEA p;
    HWND           hwnd = NULL;

    if (h = FINDRESOURCEA(hmod, lpName, (LPSTR)RT_DIALOG)) {

        if (h = LOADRESOURCE(hmod, h)) {

            if (p = (LPDLGTEMPLATEA)LOCKRESOURCE(h, hmod)) {

                hwnd = CreateDialogIndirectParamAorW(hmod,
                                                     (LPCDLGTEMPLATE)p,
                                                     hwndOwner,
                                                     lpDialogFunc,
                                                     dwInitParam,
                                                     SCDLG_ANSI);

                UNLOCKRESOURCE(h, hmod);
            }

            FREERESOURCE(h, hmod);
        }
    }

    return hwnd;
}


FUNCLOG5(LOG_GENERAL, HWND, WINAPI, CreateDialogParamW, HINSTANCE, hmod, LPCWSTR, lpName, HWND, hwndOwner, DLGPROC, lpDialogFunc, LPARAM, dwInitParam)
HWND WINAPI CreateDialogParamW(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    HWND      hwndOwner,
    DLGPROC   lpDialogFunc,
    LPARAM    dwInitParam)
{
    HANDLE h;
    PVOID  p;
    HWND   hwnd = NULL;

    if (h = FINDRESOURCEW(hmod, lpName, RT_DIALOG)) {

        if (h = LOADRESOURCE(hmod, h)) {

            if (p = LOCKRESOURCE(h, hmod)) {

                hwnd = CreateDialogIndirectParamAorW(hmod,
                                                     p,
                                                     hwndOwner,
                                                     lpDialogFunc,
                                                     dwInitParam,
                                                     0);

                UNLOCKRESOURCE(h, hmod);
            }

            FREERESOURCE(h, hmod);
        }
    }

    return hwnd;
}

/***************************************************************************\
* DestroyCursor (API)
*
* Client wrapper for NtUserDestroyCursor.
*
* 28-Nov-1994 JimA      Created.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, DestroyCursor, HCURSOR, hcur)
BOOL WINAPI DestroyCursor(
    HCURSOR hcur)
{
    return NtUserDestroyCursor(hcur, CURSOR_CALLFROMCLIENT);
}

/***************************************************************************\
* CreateIcoCur
*
*
\***************************************************************************/

HICON CreateIcoCur(
    PCURSORDATA lpi)
{
    HCURSOR hcur;

    UserAssert(lpi->hbmColor || lpi->hbmMask);

    hcur = (HCURSOR)NtUserCallOneParam((lpi->CURSORF_flags & CURSORF_GLOBAL),
                                       SFI__CREATEEMPTYCURSOROBJECT);

    if (hcur == NULL)
        return NULL;

#if DBG
    {
        BITMAP bmMask;
        BITMAP bmColor;

        UserAssert(GetObject(KHBITMAP_TO_HBITMAP(lpi->hbmMask), sizeof(BITMAP), &bmMask));

        /* Bug 252902 - joejo
         * Since the width and height of the mask bitmap is set below
         * we really don't need to assert on the width/height check. Throwing
         * a warning should be good enough.
         */
        if (bmMask.bmWidth != (LONG)lpi->cx) {
           RIPMSG1(RIP_WARNING, "Mask width not equal to requested width: lpi %#p", lpi);
        }

        if (bmMask.bmHeight != (LONG)lpi->cy) {
           RIPMSG1(RIP_WARNING, "Mask height not equal to requested height: lpi %#p", lpi);
        }

        if (lpi->hbmColor) {
            UserAssert(GetObject(KHBITMAP_TO_HBITMAP(lpi->hbmColor), sizeof(BITMAP), &bmColor));
            UserAssert(bmMask.bmHeight == bmColor.bmHeight * 2);
            UserAssert(bmMask.bmWidth  == bmColor.bmWidth);
        }
    }
#endif

    if (_SetCursorIconData(hcur, lpi))
        return hcur;

    NtUserDestroyCursor(hcur, CURSOR_ALWAYSDESTROY);

    return NULL;
}

/***************************************************************************\
* CreateIcoCurIndirect
*
*
\***************************************************************************/

HCURSOR CreateIcoCurIndirect(
    PCURSORDATA pcurCreate,
    UINT        cPlanes,
    UINT        cBitsPixel,
    CONST BYTE  *lpANDbits,
    CONST BYTE  *lpXORbits)
{
    int     cbBits;
    HCURSOR hcurNew;
    BOOL    bColor;
    UINT    cx;
    UINT    cy;
    LPBYTE  pBits = NULL;

    /*
     * Allocate CURSOR structure.
     */
    hcurNew = (HCURSOR)NtUserCallOneParam(0, SFI__CREATEEMPTYCURSOROBJECT);

    if (hcurNew == NULL)
        return NULL;

    /*
     * If there is no Color bitmap, create a single buffer that contains both
     * the AND and XOR bits.  The AND bitmap is always MonoChrome
     */
    bColor = (cPlanes | cBitsPixel) > 1;

    if (!bColor) {

        cbBits = (((pcurCreate->cx + 0x0F) & ~0x0F) >> 3) * pcurCreate->cy;

        pBits = (LPBYTE)UserLocalAlloc(HEAP_ZERO_MEMORY, (cbBits * 2));

        if (pBits == NULL) {
            NtUserDestroyCursor(hcurNew, CURSOR_ALWAYSDESTROY);
            return NULL;
        }

        RtlCopyMemory(pBits, lpANDbits, cbBits);
        RtlCopyMemory(pBits + cbBits, lpXORbits, cbBits);
        lpANDbits = pBits;
    }

    /*
     * Create hbmMask (its always MonoChrome)
     */
    cx = pcurCreate->cx;
    cy = pcurCreate->cy * 2;

    pcurCreate->hbmMask = CreateBitmap(cx, cy, 1, 1, lpANDbits);

    if (pcurCreate->hbmMask == NULL) {

        /*
         * If this is a COLOR icon/cursor, lpANDBits doesn't need to be
         * pcurCreate->cy * 2; indeed, we don't use this double height at all.
         * This is a bug that will be fixed post 4.0.
         * For now, let's try to handle the case where the CreateBitmap call
         * failed because the caller didn't pass in a double height AND mask
         * (Win95 doesn't have this bug)
         */
        if (bColor) {

            RIPMSG0(RIP_WARNING, "CreateIcoCurIndirect: Retrying hbmMask creation.");

            cbBits = (((pcurCreate->cx + 0x0F) & ~0x0F) >> 3) * pcurCreate->cy;
            pBits = (LPBYTE)UserLocalAlloc(HEAP_ZERO_MEMORY, cbBits*2);

            if (pBits == NULL) {
                NtUserDestroyCursor(hcurNew, CURSOR_ALWAYSDESTROY);
                return NULL;
            }

            RtlCopyMemory(pBits, lpANDbits, cbBits);
            pcurCreate->hbmMask = CreateBitmap(cx, cy, 1, 1, pBits);
            UserLocalFree(pBits);

            pBits = NULL;
        }

        if (pcurCreate->hbmMask == NULL) {

            /*
             * CreateBitmap() failed.  Clean-up and get out of here.
             */
            NtUserDestroyCursor(hcurNew, CURSOR_ALWAYSDESTROY);

            if (pBits != NULL)
                UserLocalFree(pBits);

            return NULL;
        }
    }

    /*
     * Create hbmColor or NULL it so that CallOEMCursor doesn't think we are
     * color.
     */
    if (bColor) {
        pcurCreate->hbmColor = CreateBitmap(cx,
                                            cy / 2,
                                            cPlanes,
                                            cBitsPixel,
                                            lpXORbits);

        if (pcurCreate->hbmColor == NULL) {

            /*
             * CreateBitmap() failed.  Clean-up and get out of here.
             */
            DeleteObject(KHBITMAP_TO_HBITMAP(pcurCreate->hbmMask));
            NtUserDestroyCursor(hcurNew, CURSOR_ALWAYSDESTROY);
            return NULL;
        }

        pcurCreate->bpp = (cPlanes * cBitsPixel);

    } else {
        pcurCreate->hbmColor = NULL;
        pcurCreate->bpp      = 1;
    }

    /*
     * Load contents into the cursor/icon object
     */
    pcurCreate->cy            = cy;
    pcurCreate->lpModName     = NULL;
    pcurCreate->lpName        = NULL;
    pcurCreate->rt            = 0;
    pcurCreate->CURSORF_flags = 0;

    if (_SetCursorIconData(hcurNew, pcurCreate)) {
        if (pBits != NULL)
            UserLocalFree(pBits);
        return hcurNew;
    }

    /*
     * Could not set up cursor/icon, so free resources.
     */
    NtUserDestroyCursor(hcurNew, CURSOR_ALWAYSDESTROY);
    DeleteObject(KHBITMAP_TO_HBITMAP(pcurCreate->hbmMask));

    if (pcurCreate->hbmColor)
        DeleteObject(KHBITMAP_TO_HBITMAP(pcurCreate->hbmColor));
    if (pBits != NULL)
        UserLocalFree(pBits);

    return NULL;
}

/***************************************************************************\
* CreateCursor (API)
*
* History:
* 26-Feb-1991 MikeKe    Created.
* 01-Aug-1991 IanJa     Init cur.pszModname or DestroyCursor will work
\***************************************************************************/


HCURSOR WINAPI CreateCursor(
    HINSTANCE hModule,
    int       iXhotspot,
    int       iYhotspot,
    int       iWidth,
    int       iHeight,
    LPBYTE    lpANDplane,
    LPBYTE    lpXORplane)
{
    CURSORDATA cur;
    UNREFERENCED_PARAMETER(hModule);

    if ((iXhotspot < 0) || (iXhotspot > iWidth) ||
        (iYhotspot < 0) || (iYhotspot > iHeight)) {
        return 0;
    }

    RtlZeroMemory(&cur, sizeof(cur));
    cur.xHotspot = (SHORT)iXhotspot;
    cur.yHotspot = (SHORT)iYhotspot;
    cur.cx       = (DWORD)iWidth;
    cur.cy       = (DWORD)iHeight;

    return CreateIcoCurIndirect(&cur, 1, 1, lpANDplane, lpXORplane);
}

/***************************************************************************\
* CreateIcon (API)
*
* History:
* 26-Feb-1991 MikeKe    Created.
* 01-Aug-1991 IanJa     Init cur.pszModname so DestroyIcon will work
\***************************************************************************/

HICON WINAPI CreateIcon(
    HINSTANCE  hModule,
    int        iWidth,
    int        iHeight,
    BYTE       planes,
    BYTE       bpp,
    CONST BYTE *lpANDplane,
    CONST BYTE *lpXORplane)
{
    CURSORDATA cur;
    UNREFERENCED_PARAMETER(hModule);

    RtlZeroMemory(&cur, sizeof(cur));
    cur.xHotspot = (SHORT)(iWidth / 2);
    cur.yHotspot = (SHORT)(iHeight / 2);
    cur.cx       = (DWORD)iWidth;
    cur.cy       = (DWORD)iHeight;

    return CreateIcoCurIndirect(&cur, planes, bpp, lpANDplane, lpXORplane);
}

/***************************************************************************\
* CreateIconIndirect (API)
*
* Creates an icon or cursor from an ICONINFO structure. Does not destroy
* cursor/icon bitmaps.
*
* 24-Jul-1991 ScottLu   Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, HICON, WINAPI, CreateIconIndirect, PICONINFO, piconinfo)
HICON WINAPI CreateIconIndirect(
    PICONINFO piconinfo)
{
    HCURSOR    hcur;
    CURSORDATA cur;
    BITMAP     bmMask;
    BITMAP     bmColor;
    HBITMAP    hbmpBits2, hbmpMem;
    HDC        hdcMem;
    UINT       LR_flags = LR_DEFAULTCOLOR;

    /*
     * Make sure the bitmaps are real, and get their dimensions.
     */
    if (!GetObjectW(piconinfo->hbmMask, sizeof(BITMAP), &bmMask))
        return NULL;

    if (piconinfo->hbmColor != NULL) {
        if (GetObjectW(piconinfo->hbmColor, sizeof(BITMAP), &bmColor)) {
            if (bmColor.bmPlanes == 1 && bmColor.bmBitsPixel == 32) {
                /*
                 * The color bitmap is a single plane, 32bpp image.  As such,
                 * it might contain an alpha channel, so we have to preserve
                 * it as a DIB.
                 */
                LR_flags |= LR_CREATEREALDIB;
            }
        } else {
            return NULL;
        }
    }


    /*
     * Allocate CURSOR structure.
     */
    hcur = (HCURSOR)NtUserCallOneParam(0, SFI__CREATEEMPTYCURSOROBJECT);
    if (hcur == NULL)
        return NULL;

    /*
     * Internally, USER stores the height as 2 icons high - because when
     * loading bits from a resource, in both b/w and color icons, the
     * bits are stored on top of one another (AND/XOR mask, AND/COLOR bitmap).
     * When bitmaps are passed in to CreateIconIndirect(), they are passed
     * as two bitmaps in the color case, and one bitmap (with the stacked
     * masks) in the black and white case.  Adjust cur.cy so it is 2 icons
     * high in both cases.
     */

    RtlZeroMemory(&cur, sizeof(cur));
    cur.cx = bmMask.bmWidth;

    if (piconinfo->hbmColor == NULL) {

        cur.cy  = bmMask.bmHeight;
        cur.bpp = 1;

    } else {
        cur.cy       = bmMask.bmHeight * 2;
        cur.bpp      = (DWORD)(bmColor.bmBitsPixel * bmColor.bmPlanes);
        cur.hbmColor = CopyBmp(piconinfo->hbmColor, 0, 0, LR_flags);

        if (cur.hbmColor == NULL) {
            RIPMSG0(RIP_WARNING, "CreateIconIndirect: Failed to copy piconinfo->hbmColor");
            goto CleanUp;
        }
    }

    /*
     * hbmMask must always be double height, even for color icons.
     * So cy might be equal to bmMask.bmHeight * 2 at this point.
     * If this is the case, the second half of hbmMask won't be initilized;
     * nobody is supposed to use it but GDI expects it there when checking the
     * bitmap dimensions (for cursors)
     */
    cur.hbmMask  =  CreateBitmap(cur.cx, cur.cy, 1, 1, NULL);

    if (cur.hbmMask == NULL) {
        RIPMSG0(RIP_WARNING, "CreateIconIndirect: Failed to create cur.hbmMask");
        goto CleanUp;
    }

    RtlEnterCriticalSection(&gcsHdc);


    if (hdcMem = CreateCompatibleDC (ghdcBits2)) {

        hbmpMem = SelectObject(hdcMem, KHBITMAP_TO_HBITMAP(cur.hbmMask));
        hbmpBits2 = SelectObject(ghdcBits2, piconinfo->hbmMask);

        BitBlt(hdcMem,
               0,
               0,
               bmMask.bmWidth,
               bmMask.bmHeight,
               ghdcBits2,
               0,
               0,
               SRCCOPY);

        SelectObject(hdcMem, hbmpMem);
        SelectObject(ghdcBits2, hbmpBits2);
        DeleteDC (hdcMem);

    } else {

        RtlLeaveCriticalSection(&gcsHdc);
        RIPMSG0(RIP_WARNING, "CreateIconIndirect: CreateCompatibleDC failed");
        goto CleanUp;
    }

    RtlLeaveCriticalSection(&gcsHdc);

    /*
     * rt and Hotspot
     */
    if (piconinfo->fIcon) {
        cur.rt        = PTR_TO_ID(RT_ICON);
        cur.xHotspot = (SHORT)(cur.cx / 2);
        cur.yHotspot = (SHORT)(cur.cy / 4);
    } else {
        cur.rt        = PTR_TO_ID(RT_CURSOR);
        cur.xHotspot = ((SHORT)piconinfo->xHotspot);
        cur.yHotspot = ((SHORT)piconinfo->yHotspot);
    }


    if (_SetCursorIconData(hcur, &cur)) {
        return hcur;
    }

CleanUp:
    /*
     * Note that if this fails, the bitmaps have NOT been made public.
     */
    if (cur.hbmMask != NULL) {
        DeleteObject(KHBITMAP_TO_HBITMAP(cur.hbmMask));
    }
    if (cur.hbmColor != NULL) {
        DeleteObject(KHBITMAP_TO_HBITMAP(cur.hbmColor));
    }

    NtUserDestroyCursor(hcur, CURSOR_ALWAYSDESTROY);
    return NULL;
}

/***************************************************************************\
* GetIconInfo (API)
*
* Returns icon information, including bitmaps.
*
* 24-Jul-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, GetIconInfo, HICON, hicon, PICONINFO, piconinfo)
BOOL WINAPI GetIconInfo(
    HICON     hicon,
    PICONINFO piconinfo)
{
    return NtUserGetIconInfo(hicon, piconinfo, NULL, NULL, NULL, FALSE);
}

/***************************************************************************\
* GetCursorFrameInfo (API)
*
* Returns cursor information.
*
* 24-Jul-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, HCURSOR, WINAPI, GetCursorFrameInfo, HCURSOR, hcur, LPWSTR, lpName, int, iFrame, LPDWORD, pjifRate, LPINT, pccur)
HCURSOR WINAPI GetCursorFrameInfo(
    HCURSOR hcur,
    LPWSTR  lpName,
    int     iFrame,
    LPDWORD pjifRate,
    LPINT   pccur)
{
    /*
     * Caller wants us to return the version of this cursor that is stored
     * in the display driver.
     */
    if (hcur == NULL) {

        return LoadIcoCur(NULL,
                          lpName,
                          RT_CURSOR,
                          0,
                          0,
                          LR_DEFAULTSIZE);
    }

    return NtUserGetCursorFrameInfo(hcur, iFrame, pjifRate, pccur);
}

/***************************************************************************\
* _FreeResource   (API)
* _LockResource   (API)
* _UnlockResource (API)
*
* These are dummy routines that need to exist for the apfnResCallNative
* array, which is used when calling the run-time libraries.
*
\***************************************************************************/

BOOL WINAPI _FreeResource(
    HANDLE    hResData,
    HINSTANCE hModule)
{
    UNREFERENCED_PARAMETER(hResData);
    UNREFERENCED_PARAMETER(hModule);

    return FALSE;
}

LPSTR WINAPI _LockResource(
    HANDLE    hResData,
    HINSTANCE hModule)
{
    UNREFERENCED_PARAMETER(hModule);

    return (LPSTR)(hResData);
}

BOOL WINAPI _UnlockResource(
    HANDLE    hResData,
    HINSTANCE hModule)
{
    UNREFERENCED_PARAMETER(hResData);
    UNREFERENCED_PARAMETER(hModule);

    return TRUE;
}

/***************************************************************************\
* LookupIconIdFromDirectory (API)
*
* This searches through an icon directory for the icon that best fits the
* current display device.
*
* 24-07-1991 ScottLu    Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, int, WINAPI, LookupIconIdFromDirectory, PBYTE, presbits, BOOL, fIcon)
int WINAPI LookupIconIdFromDirectory(
    PBYTE presbits,
    BOOL  fIcon)
{
    return LookupIconIdFromDirectoryEx(presbits, fIcon, 0, 0, 0);
}

/***************************************************************************\
* LookupIconIdFromDirectoryEx (API)
*
*
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, int, WINAPI, LookupIconIdFromDirectoryEx, PBYTE, presbits, BOOL, fIcon, int, cxDesired, int, cyDesired, UINT, LR_flags)
int WINAPI LookupIconIdFromDirectoryEx(
    PBYTE           presbits,
    BOOL            fIcon,
    int             cxDesired,
    int             cyDesired,
    UINT            LR_flags)
{
    ConnectIfNecessary(0);

    return RtlGetIdFromDirectory(presbits,
                                 fIcon,
                                 cxDesired,
                                 cyDesired,
                                 LR_flags,
                                 NULL);
}
/***************************************************************************\
* LoadCursorIconFromResource (API)
*
* Loads animated icon/cursor from a pointer to a resource
*
* 02-20-1996 GerardoB    Created.
\***************************************************************************/
HANDLE LoadCursorIconFromResource(
    PBYTE   presbits,
    LPCWSTR lpName,
    int     cxDesired,
    int     cyDesired,
    UINT    LR_flags)
{
    BOOL     fAni;
    FILEINFO fi;
    LPWSTR   lpwszRT;

    fi.pFileMap = presbits;
    fi.pFilePtr = fi.pFileMap;
    fi.pFileEnd = fi.pFileMap + sizeof (RTAG) + ((RTAG *)presbits)->ckSize;
    fi.pszName  = lpName;

    return LoadCursorIconFromFileMap(&fi,
                                     &lpwszRT,
                                     cxDesired,
                                     cyDesired,
                                     LR_flags,
                                     &fAni);
}
/***************************************************************************\
* CreateIconFromResource (API)
*
* Takes resource bits and creates either an icon or cursor.
*
* 24-07-1991 ScottLu    Created.
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, HICON, WINAPI, CreateIconFromResource, PBYTE, presbits, DWORD, dwResSize, BOOL, fIcon, DWORD, dwVer)
HICON WINAPI CreateIconFromResource(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL  fIcon,
    DWORD dwVer)
{
    return CreateIconFromResourceEx(presbits,
                                    dwResSize,
                                    fIcon,
                                    dwVer,
                                    0,
                                    0,
                                    LR_DEFAULTSIZE | LR_SHARED);
}

/***************************************************************************\
* CreateIconFromResourceEx (API)
*
* Takes resource bits and creates either an icon or cursor.
*
* 30-Aug-1994 FritzS    Created
\***************************************************************************/


FUNCLOG7(LOG_GENERAL, HICON, WINAPI, CreateIconFromResourceEx, PBYTE, presbits, DWORD, dwResSize, BOOL, fIcon, DWORD, dwVer, int, cxDesired, int, cyDesired, UINT, LR_flags)
HICON WINAPI CreateIconFromResourceEx(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL  fIcon,
    DWORD dwVer,
    int   cxDesired,
    int   cyDesired,
    UINT  LR_flags)
{
    UNREFERENCED_PARAMETER(dwResSize);

    /*
     * NT Specific code to validate the version.
     */
    if ((dwVer < 0x00020000) || (dwVer > 0x00030000)) {
        RIPMSG0(RIP_WARNING, "CreateIconFromResourceEx: Invalid Paramter");
        return NULL;
    }

    /*
     * Set desired size of resource based on flags and/or true
     * dimensions passed in.
     */
    cxDesired = GetIcoCurWidth(cxDesired , fIcon, LR_flags, 0);
    cyDesired = GetIcoCurHeight(cyDesired, fIcon, LR_flags, 0);

    if (ISRIFFFORMAT(presbits)) {
        return LoadCursorIconFromResource (presbits, NULL, cxDesired, cyDesired, LR_flags);
    } else {
        return ConvertDIBIcon((LPBITMAPINFOHEADER)presbits,
                              NULL,
                              NULL,
                              fIcon,
                              cxDesired,
                              cyDesired,
                              LR_flags);
    }
}

/***************************************************************************\
* Convert1BppToMonoBitmap
*
* This routine converts a 1bpp bitmap to a true monochrome surface.  This
* is done for bitmaps which need to do foreground/background color matching
* at output time.  Otherwise, a 1bpp will just match to its palette.
*
* NOTE: This routine deletes the original bitmap if successful.  If failure
*       we'll return the original bitmap.
*
* History:
* 17-Apr-1996 ChrisWil  Created
\***************************************************************************/

HBITMAP Convert1BppToMonoBitmap(
    HDC     hdcSrc,
    HBITMAP hbm1Bpp)
{
    HBITMAP hbmMono = hbm1Bpp;
    HBITMAP hbmDst;
    HBITMAP hbmS;
    HBITMAP hbmD;
    HDC     hdcDst;
    BITMAP  bm;

    if (hdcDst = CreateCompatibleDC(hdcSrc)) {

        GetObject(hbm1Bpp, sizeof(BITMAP), &bm);

        if (hbmDst = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL)) {

            hbmS = SelectBitmap(hdcSrc, hbm1Bpp);
            hbmD = SelectBitmap(hdcDst, hbmDst);

            BitBlt(hdcDst,
                   0,
                   0,
                   bm.bmWidth,
                   bm.bmHeight,
                   hdcSrc,
                   0,
                   0,
                   SRCCOPY);

            SelectBitmap(hdcSrc, hbmS);
            SelectBitmap(hdcDst, hbmD);

            hbmMono = hbmDst;
            DeleteObject(hbm1Bpp);
        }

        DeleteDC(hdcDst);
    }

    return hbmMono;
}

/***************************************************************************\
* CreateScreenBitmap
*
* This routine creates a screen bitmap.  We use the CreateDIBitmap call
* to do compatible color-matching with Win95.  Also, note that this
* routine takes in WORD aligned bits.
*
\***************************************************************************/

HBITMAP CreateScreenBitmap(
    int    cx,
    int    cy,
    UINT   planes,
    UINT   bpp,
    LPSTR  lpBits,
    LPBOOL pf1Bpp)
{
    HDC     hdcScreen;
    HBITMAP hbm = NULL;
    DWORD   dwCount;

    static struct {
        BITMAPINFOHEADER bi;
        DWORD            ct[16];
    } dib4Vga = {{sizeof(BITMAPINFOHEADER),
                  0,
                  0,
                  1,
                  4,
                  BI_RGB,
                  0,
                  0,
                  0,
                  16,
                  0
                 },
                 {0x00000000,
                  0x00800000,
                  0x00008000,
                  0x00808000,
                  0x00000080,
                  0x00800080,
                  0x00008080,
                  0x00C0C0C0,
                  0x00808080,
                  0x00FF0000,
                  0x0000FF00,
                  0x00FFFF00,
                  0x000000FF,
                  0x00FF00FF,
                  0x0000FFFF,
                  0x00FFFFFF
                 }
                };

    static struct {
        BITMAPINFOHEADER bi;
        DWORD            ct[2];
    } dib1Vga = {{sizeof(BITMAPINFOHEADER),
                  0,
                  0,
                  1,
                  1,
                  BI_RGB,
                  0,
                  0,
                  0,
                  2,
                  0
                 },
                 {0x00000000,
                  0x00FFFFFF
                 }
                };


    /*
     * Create the surface.
     */
    if (hdcScreen = GETINITDC()) {

        /*
         * This appears to mess up color to mono conversion by losing all
         * the data and forcing all non-forground colors to black.
         * (try copyimage with IDC_WARNING_DEFAULT)
         * This is what win95 does but their system works.  The scary thing
         * (according to marke) is that win95 may have changed GDI to make
         * this work.
         *
         * In order to get nearest-color-matching compatible with Win95,
         * we're going to need to use the CreateDIBitmap() for mono-surfaces.
         * This code-path will do nearest-color, rather than color-matching.
         */
        if ((bpp == 1) && (planes == 1)) {

            dib1Vga.bi.biWidth  = cx;
            dib1Vga.bi.biHeight = cy;

            hbm = CreateDIBitmap(hdcScreen,
                                 (LPBITMAPINFOHEADER)&dib1Vga,
                                 CBM_CREATEDIB,
                                 NULL,
                                 (LPBITMAPINFO)&dib1Vga,
                                 DIB_RGB_COLORS);

            *pf1Bpp = TRUE;

        } else {

            if (((planes == 0) || (planes == gpsi->Planes)) &&
                ((bpp == 0) || (bpp == gpsi->BitsPixel))) {

                hbm = CreateCompatibleBitmap(hdcScreen, cx, cy);

            } else {

                dib4Vga.bi.biBitCount = planes * bpp ? planes * bpp : gpsi->BitCount;

#if 0 // We use to do the dib-section create, but this breaks icons
      // when they are made public (can't make a dibsection public). So
      // we now wil create this as a real-dib.
      //
                {
                DWORD dwDummy;

                dib4Vga.bi.biWidth    =  cx;
                dib4Vga.bi.biHeight   = -cy;     // top-down DIB (like a DDB)

                hbm = CreateDIBSection(hdcScreen,
                                       (LPBITMAPINFO)&dib4Vga,
                                       DIB_RGB_COLORS,
                                       (LPVOID)&dwDummy,
                                       0,
                                       0);
                }
#else
                dib4Vga.bi.biWidth  = cx;
                dib4Vga.bi.biHeight = cy;

                hbm = CreateDIBitmap(hdcScreen,
                                     (LPBITMAPINFOHEADER)&dib4Vga,
                                     CBM_CREATEDIB,
                                     NULL,
                                     (LPBITMAPINFO)&dib4Vga,
                                     DIB_RGB_COLORS);
#endif
            }
        }

        RELEASEINITDC(hdcScreen);
    }

    if (hbm && lpBits) {

        BITMAP bm;

        GetObject(hbm, sizeof(BITMAP), &bm);
        dwCount = (DWORD)(UINT)(bm.bmWidthBytes * bm.bmPlanes) * (DWORD)(UINT)cy;
        SetBitmapBits(hbm, dwCount, lpBits);
    }

    return hbm;
}

/***************************************************************************\
* LoadBmp (Worker)
*
* This routine decides whether the bitmap to be loaded is in old or new (DIB)
* format and calls appropriate handlers.
*
* History:
* 24-Sep-1990 MikeKe    From Win30.
* 18-Jun-1991 ChuckWh   Added local bitmap handle support.
* 05-Sep-1995 ChrisWil  Port/Change for Chicago functionality.
\***************************************************************************/

HBITMAP LoadBmp(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    int       cxDesired,
    int       cyDesired,
    UINT      flags)
{
    HBITMAP hbmp = NULL;
    BOOL    fFree = FALSE;
    BOOL    f1Bpp = FALSE;

/***************************************************************************\
* Bitmap Resource Table
*
* As of WIN4.0, most system bitmaps are rendered instead of grabbed from the
* display driver.  However, a lot of apps, especially those that fake their
* own MDI, do LoadBitmap(NULL, OBM_...) to grab a system bitmap.  So we
* hook those requests here and copy our rendered bitmaps into a newly-
* created bitmap.  Note that this is actually faster than loading from a
* resource table!
*
* BOGUS -- give 'em old close buttons, not new cool X's
*
\***************************************************************************/
#define MAX_BMPMAP  32

    CONST static MAPRES MapOemBmp[MAX_BMPMAP] = {

        {OBM_BTNCORNERS , OBI_RADIOMASK      ,               },
        {OBM_BTSIZE     , OBI_NCGRIP         ,               },
        {OBM_CHECK      , OBI_MENUCHECK      , MR_MONOCHROME },
        {OBM_CHECKBOXES , OBI_CHECK          ,               },
        {OBM_COMBO      , OBI_DNARROW        ,               },
        {OBM_DNARROW    , OBI_DNARROW        ,               },
        {OBM_DNARROWD   , OBI_DNARROW_D      ,               },
        {OBM_DNARROWI   , OBI_DNARROW_I      ,               },
        {OBM_LFARROW    , OBI_LFARROW        ,               },
        {OBM_LFARROWD   , OBI_LFARROW_D      ,               },
        {OBM_LFARROWI   , OBI_LFARROW_I      ,               },

        /*
         * Use MONO bitmaps in future once flat/mono controls are worked out.
         */
        {OBM_OLD_DNARROW, OBI_DNARROW        , MR_FAILFOR40  },
        {OBM_OLD_LFARROW, OBI_LFARROW        , MR_FAILFOR40  },
        {OBM_OLD_REDUCE , OBI_REDUCE_MBAR    , MR_FAILFOR40  },
        {OBM_OLD_RESTORE, OBI_RESTORE_MBAR   , MR_FAILFOR40  },
        {OBM_OLD_RGARROW, OBI_RGARROW        , MR_FAILFOR40  },
        {OBM_OLD_UPARROW, OBI_UPARROW        , MR_FAILFOR40  },
        {OBM_OLD_ZOOM   , OBI_ZOOM           , MR_FAILFOR40  },

        {OBM_MNARROW    , OBI_MENUARROW      , MR_MONOCHROME },
        {OBM_REDUCE     , OBI_REDUCE_MBAR    ,               },
        {OBM_REDUCED    , OBI_REDUCE_MBAR_D  ,               },
        {OBM_RESTORE    , OBI_RESTORE_MBAR   ,               },
        {OBM_RESTORED   , OBI_RESTORE_MBAR_D ,               },
        {OBM_RGARROW    , OBI_RGARROW        ,               },
        {OBM_RGARROWD   , OBI_RGARROW_D      ,               },
        {OBM_RGARROWI   , OBI_RGARROW_I      ,               },
        {OBM_SIZE       , OBI_NCGRIP         ,               },
        {OBM_UPARROW    , OBI_UPARROW        ,               },
        {OBM_UPARROWD   , OBI_UPARROW_D      ,               },
        {OBM_UPARROWI   , OBI_UPARROW_I      ,               },
        {OBM_ZOOM       , OBI_ZOOM           ,               },
        {OBM_ZOOMD      , OBI_ZOOM_D         ,               }
    };


    /*
     * If hmod is valid, load the client-side bits.
     */
    if (hmod == NULL) {

        HBITMAP hOldBmp;
        WORD    bm;
        WORD    wID;
        BOOL    fCombo;
        BOOL    fCheckBoxes;
        int     i;
        RECT    rc;
        BOOL    fSysMenu = FALSE;
        BOOL    fMenu = FALSE;
        BOOL    fMono = FALSE;

        hmod = hmodUser;

        /*
         * Since the resource is coming from USER32, we only
         * deal with ID types.
         */
        wID = PTR_TO_ID(lpName);

        switch(wID) {
        case OBM_OLD_CLOSE:
            if (GETAPPVER() >= VER40)
                goto FailOldLoad;

            /*
             * fall through to the Close case.
             */

        case OBM_CLOSE:
            /* the new look for the system menu is to use the window's
             * class icon -- but since here we don't know which window
             * they'll be using this for, fall back on the good ole'
             * windows logo icon
             */
            cxDesired = (SYSMET(CXMENUSIZE) + SYSMET(CXEDGE)) * 2;
            cyDesired = SYSMET(CYMENUSIZE) + (2 * SYSMET(CYEDGE));
            fSysMenu  = TRUE;
            break;

        case OBM_TRUETYPE: {

                PVOID  p;
                HANDLE h;
                int    nOffset;

                /*
                 * Offset into resource.
                 */
                if (gpsi->dmLogPixels == 120) {
                    nOffset = OFFSET_120_DPI;
                } else {
                    nOffset = OFFSET_96_DPI;
                }

                lpName = (LPWSTR)(MAX_RESOURCE_INDEX -
                        ((ULONG_PTR)lpName) + nOffset);

                if (h = FINDRESOURCEW(hmod, (LPWSTR)lpName, RT_BITMAP)) {

                    if (h = LOADRESOURCE(hmod, h)) {

                        if (p = LOCKRESOURCE(h, hmod)) {


                            hbmp = (HBITMAP)ObjectFromDIBResource(hmod,
                                                                  lpName,
                                                                  RT_BITMAP,
                                                                  cxDesired,
                                                                  cyDesired,
                                                                  flags);

                            UNLOCKRESOURCE(h, hmod);
                        }

                        FREERESOURCE(h, hmod);
                    }
                }

                goto LoadBmpDone;
            }
            break;

        default:
            fCombo      = (wID == OBM_COMBO);
            fCheckBoxes = (wID == OBM_CHECKBOXES);

            /*
             * hard loop to check for mapping.
             */
            for (i=0; (i < MAX_BMPMAP) && (MapOemBmp[i].idDisp != wID); i++);

            if (i == MAX_BMPMAP)
                goto LoadForReal;

            if ((MapOemBmp[i].bFlags & MR_FAILFOR40) &&
                    (GETAPPVER() >= VER40)) {

FailOldLoad:
                RIPMSG0(RIP_WARNING, "LoadBitmap: old IDs not allowed for 4.0 apps");
                return NULL;
            }

            if (MapOemBmp[i].bFlags & MR_MONOCHROME)
                fMono = TRUE;

            bm = MapOemBmp[i].idUser;

            if ((bm == OBI_REDUCE_MBAR) || (bm == OBI_RESTORE_MBAR))
                fMenu = TRUE;

            cxDesired = gpsi->oembmi[bm].cx;
            cyDesired = gpsi->oembmi[bm].cy;

            if (fMenu)
                cyDesired += (2 * SYSMET(CYEDGE));

            if (fCheckBoxes) {
                cxDesired *= NUM_BUTTON_STATES;
                cyDesired *= NUM_BUTTON_TYPES;
            } else if (fCombo) {
                cxDesired -= (2 * SYSMET(CXEDGE));
                cyDesired -= (2 * SYSMET(CYEDGE));
            }
            break;
        }

        /*
         * Creates DIB section or color compatible.
         */
        if (fMono) {

            /*
             * Create mono-bitmaps as DIBs on NT.  On Win95 this is
             * called as:
             *
             *   hbmp = CreateBitmap(cxDesired, cyDesired, 1, 1, NULL);
             *
             * However, due to color-matching differences, we need to
             * use dibs to get the nearest-color-matching.  At the
             * end of this routine we will convert to a true-mono so that
             * foreground/background matching can be performed normally.
             */
            hbmp = CreateScreenBitmap(cxDesired, cyDesired, 1, 1, NULL, &f1Bpp);

        } else {

            hbmp = CreateScreenBitmap(cxDesired, cyDesired, 0, 0, NULL, &f1Bpp);
        }

        if (hbmp == NULL)
            goto LoadBmpDone;

        RtlEnterCriticalSection(&gcsHdc);
        hOldBmp = SelectBitmap(ghdcBits2, hbmp);
        UserAssert(GetBkColor(ghdcBits2) == RGB(255,255,255));
        UserAssert(GetTextColor(ghdcBits2) == RGB(0, 0, 0));

        rc.top    = 0;
        rc.left   = 0;
        rc.bottom = cyDesired;
        rc.right  = cxDesired;

        if (fMono) {
            PatBlt(ghdcBits2, 0, 0, cxDesired, cyDesired, WHITENESS);
        } else {
            FillRect(ghdcBits2,
                     &rc,
                     ((fMenu | fSysMenu) ? SYSHBR(MENU) : SYSHBR(WINDOW)));
        }

        if (fSysMenu) {
            int x = SYSMET(CXEDGE);
            int i;

            cxDesired /= 2;

            for (i=0; i < 2; i++) {

                DrawIconEx(ghdcBits2,
                           x,
                           SYSMET(CYEDGE),
                           KHICON_TO_HICON(gpsi->hIconSmWindows),
                           cxDesired - 2 * SYSMET(CXEDGE),
                           SYSMET(CYMENUSIZE) - SYSMET(CYEDGE),
                           0,
                           NULL,
                           DI_NORMAL);

                x += cxDesired;
            }

        } else if (fCombo) {

            /*
             * Revisit when we start using TTF -- that'll take care of
             * this hack.
             */
            rc.top     = -SYSMET(CYEDGE);
            rc.bottom +=  SYSMET(CYEDGE);
            rc.left    = -SYSMET(CXEDGE);
            rc.right  +=  SYSMET(CXEDGE);

            DrawFrameControl(ghdcBits2,
                             &rc,
                             DFC_SCROLL,
                             DFCS_SCROLLDOWN);

        } else if (fCheckBoxes) {

            int   wType;
            int   wState;
            int   x;
            DWORD clrTextSave;
            DWORD clrBkSave;
            int   y = 0;

            for (wType=0; wType < NUM_BUTTON_TYPES; wType++) {

                x = 0;

                cxDesired = gpsi->oembmi[bm].cx;
                cyDesired = gpsi->oembmi[bm].cy;

                if (wType == 1) {

                    /*
                     * BOGUS UGLINESS -- will be fixed once the Graphics dudes
                     * get me the icon TTF -- I'll revisit this then and make
                     * REAL
                     */
                    clrTextSave = SetTextColor(ghdcBits2, RESCLR_BLACK);
                    clrBkSave   = SetBkColor  (ghdcBits2, RESCLR_WHITE);

                    for (wState = 0; wState < NUM_BUTTON_STATES; wState++) {

                        NtUserBitBltSysBmp(ghdcBits2,
                                           x,
                                           y,
                                           cxDesired,
                                           cyDesired,
                                           gpsi->oembmi[OBI_RADIOMASK].x,
                                           gpsi->oembmi[OBI_RADIOMASK].y,
                                           SRCAND);

                        NtUserBitBltSysBmp(ghdcBits2,
                                           x,
                                           y,
                                           cxDesired,
                                           cyDesired,
                                           gpsi->oembmi[bm].x,
                                           gpsi->oembmi[bm].y,
                                           SRCINVERT);
                        x += cxDesired;
                        bm++;
                    }

                    SetTextColor(ghdcBits2, clrTextSave);
                    SetBkColor(ghdcBits2, clrBkSave);

                } else {

                    for (wState=0; wState < NUM_BUTTON_STATES; wState++) {

                        BitBltSysBmp(ghdcBits2, x, y, bm);
                        x += cxDesired;
                        bm++;
                    }

                    /*
                     * Skip OBI_*_CDI.
                     */
                    bm++;
                }

                y += cyDesired;
            }

        } else {

            BitBltSysBmp(ghdcBits2, 0, fMenu ? SYSMET(CYEDGE) : 0, bm);
        }

        SelectBitmap(ghdcBits2, hOldBmp);

        /*
         * If the bitmap was created as a 1bpp, we need to convert to a
         * true mono-bitmap.  GDI performs different color-matching depending
         * upon this case.
         */
        if (f1Bpp && hbmp)
            hbmp = Convert1BppToMonoBitmap(ghdcBits2, hbmp);

        RtlLeaveCriticalSection(&gcsHdc);

    } else {

LoadForReal:

        hbmp = (HBITMAP)ObjectFromDIBResource(hmod,
                                              lpName,
                                              RT_BITMAP,
                                              cxDesired,
                                              cyDesired,
                                              flags);
    }

LoadBmpDone:

    return hbmp;
}

/***************************************************************************\
* LoadBitmapA (API)
* LoadBitmapW (API)
*
* Loads a bitmap from client.  If hmod == NULL, loads a bitmap from the
* system.
*
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HBITMAP, WINAPI, LoadBitmapA, HINSTANCE, hmod, LPCSTR, lpName)
HBITMAP WINAPI LoadBitmapA(
    HINSTANCE hmod,
    LPCSTR    lpName)
{
    LPWSTR  lpUniName;
    HBITMAP hRet;

    if (ID(lpName))
        return LoadBmp(hmod, (LPCWSTR)lpName, 0, 0, 0);

    if (!MBToWCS(lpName, -1, &lpUniName, -1, TRUE))
        return NULL;

    hRet = LoadBmp(hmod, lpUniName, 0, 0, 0);

    UserLocalFree(lpUniName);

    return hRet;
}


FUNCLOG2(LOG_GENERAL, HBITMAP, WINAPI, LoadBitmapW, HINSTANCE, hmod, LPCWSTR, lpName)
HBITMAP WINAPI LoadBitmapW(
    HINSTANCE hmod,
    LPCWSTR   lpName)
{
    return LoadBmp(hmod, lpName, 0, 0, 0);
}

/***************************************************************************\
* LoadCursorA (API)
* LoadCursorW (API)
*
* Loads a cursor from client.  If hmod == NULL, loads a cursor from the
* system.
*
* 05-Apr-1991 ScottLu   Rewrote to work with client server.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HCURSOR, WINAPI, LoadCursorA, HINSTANCE, hmod, LPCSTR, lpName)
HCURSOR WINAPI LoadCursorA(
    HINSTANCE hmod,
    LPCSTR    lpName)
{
    HCURSOR hRet;
    LPWSTR  lpUniName;

    if (ID(lpName))
        return LoadCursorW(hmod, (LPWSTR)lpName);

    if (!MBToWCS(lpName, -1, &lpUniName, -1, TRUE))
        return NULL;

    hRet = LoadCursorW(hmod, lpUniName);

    UserLocalFree(lpUniName);

    return hRet;
}


FUNCLOG2(LOG_GENERAL, HCURSOR, WINAPI, LoadCursorW, HINSTANCE, hmod, LPCWSTR, lpName)
HCURSOR WINAPI LoadCursorW(
    HINSTANCE hmod,
    LPCWSTR   lpName)
{

    return LoadIcoCur(hmod,
                      lpName,
                      RT_CURSOR,
                      0,
                      0,
                      LR_DEFAULTSIZE | LR_SHARED);

}

/***************************************************************************\
* LoadIconA (API)
* LoadIconW (API)
*
* Loads an icon from client.  If hmod == NULL, loads an icon from the
* system.
*
* 05-Apr-1991 ScottLu   Rewrote to work with client server.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, HICON, WINAPI, LoadIconA, HINSTANCE, hmod, LPCSTR, lpName)
HICON WINAPI LoadIconA(
    HINSTANCE hmod,
    LPCSTR    lpName)
{
    HICON  hRet;
    LPWSTR lpUniName;

    if (ID(lpName))
        return LoadIconW(hmod, (LPWSTR)lpName);

    if (!MBToWCS(lpName, -1, &lpUniName, -1, TRUE))
        return NULL;

    hRet = LoadIconW(hmod, lpUniName);

    UserLocalFree(lpUniName);

    return hRet;
}


FUNCLOG2(LOG_GENERAL, HICON, WINAPI, LoadIconW, HINSTANCE, hmod, LPCWSTR, lpName)
HICON WINAPI LoadIconW(
    HINSTANCE hmod,
    LPCWSTR   lpName)
{
    return LoadIcoCur(hmod,
                      lpName,
                      RT_ICON,
                      0,
                      0,
                      LR_DEFAULTSIZE | LR_SHARED);
}

/***************************************************************************\
* LoadImageA (API)
* LoadImageW (API)
*
* Loads a bitmap, icon or cursor resource from client.  If hmod == NULL,
* then it will load from system-resources.
*
\***************************************************************************/


FUNCLOG6(LOG_GENERAL, HANDLE, WINAPI, LoadImageA, HINSTANCE, hmod, LPCSTR, lpName, UINT, type, int, cxDesired, int, cyDesired, UINT, flags)
HANDLE WINAPI LoadImageA(
    HINSTANCE hmod,
    LPCSTR    lpName,
    UINT      type,
    int       cxDesired,
    int       cyDesired,
    UINT      flags)
{
    LPWSTR lpUniName;
    HANDLE hRet;

    if (ID(lpName))
        return LoadImageW(hmod,
                          (LPCWSTR)lpName,
                          type,
                          cxDesired,
                          cyDesired,
                          flags);

    if (!MBToWCS(lpName, -1, &lpUniName, -1, TRUE))
        return NULL;

    hRet = LoadImageW(hmod, lpUniName, type, cxDesired, cyDesired, flags);

    UserLocalFree(lpUniName);

    return hRet;
}


FUNCLOG6(LOG_GENERAL, HANDLE, WINAPI, LoadImageW, HINSTANCE, hmod, LPCWSTR, lpName, UINT, IMAGE_code, int, cxDesired, int, cyDesired, UINT, flags)
HANDLE WINAPI LoadImageW(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    UINT      IMAGE_code,
    int       cxDesired,
    int       cyDesired,
    UINT      flags)
{
    /*
     * If we specified LR_LOADFROMFILE, then we can tweak the
     * flags to turn off LR_SHARED.
     */
    if (flags & LR_LOADFROMFILE)
        flags &= ~LR_SHARED;

    switch (IMAGE_code) {
    case IMAGE_BITMAP:
        return (HANDLE)LoadBmp(hmod, lpName, cxDesired, cyDesired, flags);

    case IMAGE_CURSOR:
#if 0 //CHRISWIL : oemInfo.fColorCursors doesn't exist on NT.
        if (!oemInfo.fColorCursors)
            flags |= LR_MONOCHROME;
#endif

    case IMAGE_ICON:

        /*
         * On WinNT 3.51, an app can successfully load a
         * USER icon without specifying LR_SHARED. We enable
         * these apps to succeed, but make 4.0 apps conform to
         * Windows95 behavior.
         */

        if (!hmod && GETEXPWINVER(NULL) < VER40) {
            flags |= LR_SHARED;
        }

        return (HANDLE)LoadIcoCur(hmod,
                                  lpName,
                                  ((IMAGE_code == IMAGE_ICON) ? RT_ICON : RT_CURSOR),
                                  cxDesired,
                                  cyDesired,
                                  flags);

    default:
        RIPMSG0(RIP_WARNING, "LoadImage: invalid IMAGE_code");
        return NULL;
    }
}

/***************************************************************************\
* GetIconIdEx
*
* This one accepts width, height, and other flags.  Just not exported right
* now.
*
\***************************************************************************/

UINT GetIconIdEx(
    HINSTANCE hmod,
    HANDLE    hrsd,
    LPCWSTR   lpszType,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags)
{
    int         idIcon = 0;
    LPNEWHEADER lpnh;

    if (lpnh = (LPNEWHEADER)LOCKRESOURCE(hrsd, hmod)) {

        /*
         * Do a sanity check on this data structure.  Otherwise we'll GP FAULT
         * when extracting an icon from a corrupted area.  Fix for B#9290.
         * SANKAR, 08/13/91
         */
        if ((lpnh->Reserved == 0) &&
            ((lpnh->ResType == IMAGE_ICON) || (lpnh->ResType == IMAGE_CURSOR))) {

            idIcon = LookupIconIdFromDirectoryEx((PBYTE)lpnh,
                                                 (lpszType == RT_ICON),
                                                 cxDesired,
                                                 cyDesired,
                                                 LR_flags);
        }

        UNLOCKRESOURCE(hrsd, hmod);
    }

    return idIcon;
}

/***************************************************************************\
* LoadDib (Worker)
*
* This is the worker-routine for loading a resource and returning a handle
* to the object as a dib.
*
\***************************************************************************/

HANDLE LoadDIB(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    LPWSTR    type,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags)
{
    HANDLE  hDir;
    UINT    idIcon;
    LPWSTR  lpszGroupType;
    HANDLE  hRes = NULL;

    switch (PTR_TO_ID(type)) {

    case PTR_TO_ID(RT_ICON):
    case PTR_TO_ID(RT_CURSOR):

        lpszGroupType = RT_GROUP_CURSOR + (type - RT_CURSOR);

        /*
         * For WOW support, OIC_ICON and OIC_SIZE need to be supported.
         * Since these resources match other existing resources, we map
         * them here so we produce results that emulates
         * behavor as if we had the actual resources in USER.
         *
         * Note that obsolete mapping of lpName in LoadIcoCur prevents
         * win4.0 apps from getting here.
         */
        if (hmod == hmodUser) {

            switch ((ULONG_PTR)lpName) {
            case OCR_SIZE:
                lpName = (LPCWSTR)OCR_SIZEALL_DEFAULT;
                break;

            case OCR_ICON:
                lpName = (LPCWSTR)OCR_ICON_DEFAULT;
                break;
            }
        }
        /*
         * The resource is actually a directory which contains multiple
         * individual image resources we must choose from.
         * Locate the directory
         */
        if (hDir = SplFindResource(hmod, lpName, (LPCWSTR)lpszGroupType)) {

            /*
             * Load the directory.
             */
            if (hDir = LOADRESOURCE(hmod, hDir)) {

                /*
                 * Get the name of the best individual image.
                 */
                if (idIcon = GetIconIdEx(hmod,
                                         hDir,
                                         type,
                                         cxDesired,
                                         cyDesired,
                                         LR_flags)) {

                    /*
                     * NOTE: Don't free the directory resource!!! - ChipA.
                     * We can't call SplFindResource here, because idIcon
                     * is internal to us and GetDriverResourceId()
                     * doesn't know how to map it.
                     */
                    hRes = FINDRESOURCEW(hmod, MAKEINTRESOURCE(idIcon), type);
                }

                /*
                 * BOGUS:
                 * It would be very cool if we could loop through all the
                 * items in the directory and free 'em too.  Free the ones
                 * except for the one we're about to load, that is.
                 *
                 * Free directory resources TWICE so they get really freed.
                 */
                SplFreeResource(hDir, hmod, LR_flags);
            }
        } else {
            /*
             * Failed to load a regular icon\cursor.
             * Try to load an animated icon/cursor with the same name
             */
            hRes = SplFindResource(hmod, lpName,
                    PTR_TO_ID(type) == PTR_TO_ID(RT_CURSOR) ? RT_ANICURSOR : RT_ANIICON);
        }
        break;

    case PTR_TO_ID(RT_BITMAP):
        hRes = SplFindResource(hmod, lpName, RT_BITMAP);
        break;

    default:
        RIPMSG0(RIP_WARNING, "LoadDIB: Invalid resource type");
        break;
    }

    if (hRes)
        hRes = LOADRESOURCE(hmod, hRes);

    return hRes;
}

/***************************************************************************\
* LoadIcoCur (Worker)
*
*
\***************************************************************************/

HICON LoadIcoCur(
    HINSTANCE hmod,
    LPCWSTR   pszResName,
    LPWSTR    type,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags)
{
    HICON     hico;
    LPWSTR    pszModName;
    WCHAR     achModName[MAX_PATH];

    ConnectIfNecessary(0);

    /*
     * Setup module name and handles for lookup.
     */
    if (hmod == NULL)  {

        hmod = hmodUser;
        pszModName = szUSER32;

    } else {

        WowGetModuleFileName(hmod,
                             achModName,
                             sizeof(achModName) / sizeof(WCHAR));

        pszModName = achModName;
    }

    if (LR_flags & LR_CREATEDIBSECTION)
        LR_flags = (LR_flags & ~LR_CREATEDIBSECTION) | LR_CREATEREALDIB;

    /*
     * Setup defaults.
     */
    if ((hmod == hmodUser) && !IS_PTR(pszResName)) {

        int      imapMax;
        LPMAPRES lpMapRes;

        /*
         * Map some old OEM IDs for people.
         */
        if (type == RT_ICON) {

            static MAPRES MapOemOic[] = {
                {OCR_ICOCUR, OIC_WINLOGO, MR_FAILFOR40}
            };

            lpMapRes = MapOemOic;
            imapMax  = 1;

        } else {

            static MAPRES MapOemOcr[] = {
                {OCR_ICON, OCR_ICON, MR_FAILFOR40},
                {OCR_SIZE, OCR_SIZE, MR_FAILFOR40}
            };

            lpMapRes = MapOemOcr;
            imapMax  = 2;
        }

        while (--imapMax >= 0) {

            if (lpMapRes->idDisp == PTR_TO_ID(pszResName)) {

                if ((lpMapRes->bFlags & MR_FAILFOR40) &&
                    GETAPPVER() >= VER40) {

                    RIPMSG1(RIP_WARNING,
                          "LoadIcoCur: Old ID 0x%x not allowed for 4.0 apps",
                          PTR_TO_ID(pszResName));

                    return NULL;
                }

                pszResName = MAKEINTRESOURCE(lpMapRes->idUser);
                break;
            }

            ++lpMapRes;
        }
    }

    /*
     * Determine size of requested object.
     */
    cxDesired = GetIcoCurWidth(cxDesired , (type == RT_ICON), LR_flags, 0);
    cyDesired = GetIcoCurHeight(cyDesired, (type == RT_ICON), LR_flags, 0);

    /*
     * See if this is a cached icon/cursor, and grab it if we have one
     * already.
     */
    if (LR_flags & LR_SHARED) {

        CURSORFIND cfSearch;

        /*
         * Note that win95 fails to load any USER resources unless
         * LR_SHARED is specified - so we do too.  Also, win95 will
         * ignore your cx, cy and LR_flag parameters and just give
         * you whats in the cache so we do too.
         * A shame but thats life...
         *
         * Setup search criteria.  Since this is a load, we will have
         * no source-cursor to lookup.  Find something respectable.
         */
        cfSearch.hcur = (HCURSOR)NULL;
        cfSearch.rt   = PtrToUlong(type);

        if (hmod == hmodUser) {

            cfSearch.cx  = 0;
            cfSearch.cy  = 0;
            cfSearch.bpp = 0;

        } else {

            cfSearch.cx  = cxDesired;
            cfSearch.cy  = cyDesired;

/*
 * On NT we have a more strict cache-lookup.  By passing in (zero), we
 * will tell the cache-lookup to ignore the bpp.  This fixes a problem
 * in Crayola Art Studio where the coloring-book cursor was being created
 * as an invisible cursor.  This lookup is compatible with Win95.
 */
#if 0
            cfSearch.bpp = GetIcoCurBpp(LR_flags);
#else
            cfSearch.bpp = 0;
#endif
        }

        hico = FindExistingCursorIcon(pszModName, pszResName, &cfSearch);

        if (hico != NULL)
            goto IcoCurFound;
    }

#ifdef LATER // SanfordS
    /*
     * We need to handle the case where a configurable icon has been
     * loaded from some arbitrary module or file and someone now wants
     * to load the same thing in a different size or color content.
     *
     * A cheezier alternative is to just call CopyImage on what we
     * found.
     */
    if (hmod == hmodUser) {
        hico = FindExistingCursorIcon(NULL,
                                      szUSER,
                                      type,
                                      pszResName,
                                      0,
                                      0,
                                      0);
        if (hico != NULL) {
            /*
             * Find out where the original came from and load it.
             * This may require some redesign to remember the
             * filename that LR_LOADFROMFILE images came from.
             */
            _GetIconInfo(....);
            return LoadIcoCur(....);
        }
    }
#endif

    hico = (HICON)ObjectFromDIBResource(hmod,
                                        pszResName,
                                        type,
                                        cxDesired,
                                        cyDesired,
                                        LR_flags);

IcoCurFound:

    return hico;
}

/***************************************************************************\
* ObjectFromDIBResource
*
*
\***************************************************************************/
HANDLE ObjectFromDIBResource(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    LPWSTR    type,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags)
{
    HANDLE  hObj = NULL;

    if (LR_flags & LR_LOADFROMFILE) {

        hObj = RtlLoadObjectFromDIBFile(lpName,
                                        type,
                                        cxDesired,
                                        cyDesired,
                                        LR_flags);
    } else {

        HANDLE hdib;

        hdib = LoadDIB(hmod, lpName, type, cxDesired, cyDesired, LR_flags);

        if (hdib != NULL) {

            LPBITMAPINFOHEADER lpbih;

            /*
             * We cast the resource-bits to a BITMAPINFOHEADER.  If the
             * resource is a CURSOR type, then there are actually two
             * WORDs preceeding the BITMAPINFOHDEADER indicating the
             * hot-spot.  Be careful in assuming you have a real
             * dib in this case.
             */
            if(lpbih = (LPBITMAPINFOHEADER)LOCKRESOURCE(hdib, hmod)) {

                switch (PTR_TO_ID(type)) {
                case PTR_TO_ID(RT_BITMAP):
                    /*
                     * Create a physical bitmap from the DIB.
                     */
                    hObj = ConvertDIBBitmap(lpbih,
                                            cxDesired,
                                            cyDesired,
                                            LR_flags,
                                            NULL,
                                            NULL);
                    break;

                case PTR_TO_ID(RT_ICON):
                case PTR_TO_ID(RT_CURSOR):
                case PTR_TO_ID(RT_ANICURSOR):
                case PTR_TO_ID(RT_ANIICON):
                    /*
                     * Animated icon\cursors resources use the RIFF format
                     */
                    if (ISRIFFFORMAT(lpbih)) {
                        hObj = LoadCursorIconFromResource ((PBYTE)lpbih, lpName, cxDesired, cyDesired, LR_flags);
                    } else {
                        /*
                         * Create the object from the DIB.
                         */
                        hObj = ConvertDIBIcon(lpbih,
                                              hmod,
                                              lpName,
                                              (type == RT_ICON),
                                              cxDesired,
                                              cyDesired,
                                              LR_flags);
                    }
                    break;
                }

                UNLOCKRESOURCE(hdib, hmod);
            }

            /*
             * DO THIS TWICE!  The resource compiler always makes icon images
             * (RT_ICON) in a group icon discardable, whether the group dude
             * is or not!  So the first free won't really free the thing;
             * it'll just set the ref count to 0 and let the discard logic
             * go on its merry way.
             *
             * We take care of shared guys, so we don't need this dib no more.
             * Don't need this DIB no more no more, no more no more no more
             * don't need this DIB no more.
             */
            SplFreeResource(hdib, hmod, LR_flags);
        }
    }

    return hObj;
}

/***************************************************************************\
* BitmapFromDIB
*
* Creates a bitmap-handle from a DIB-Spec.  This function supports the
* LR_CREATEDIBSECTION flag, sets proper color depth, and stretches the
* DIBs as requested.
*
\***************************************************************************/

HBITMAP BitmapFromDIB(
    int          cxNew,
    int          cyNew,
    WORD         bPlanesNew,
    WORD         bBitsPixelNew,
    UINT         LR_flags,
    int          cxOld,
    int          cyOld,
    LPSTR        lpBits,
    LPBITMAPINFO lpbi,
    HPALETTE     hpal)
{
    HBITMAP hbmpNew = NULL;
    BOOL    fStretch;
    BOOL    f1Bpp = FALSE;

    RtlEnterCriticalSection(&gcsHdc);

    if (cxNew == 0)
        cxNew = cxOld;

    if (cyNew == 0)
        cyNew = cyOld;

    fStretch = ((cxNew != cxOld) || (cyNew != cyOld));

    /*
     * If LR_flags indicate DIB-Section, then return that as the
     * bitmap handle.
     */
    if (LR_flags & (LR_CREATEDIBSECTION | LR_CREATEREALDIB)) {

        int   cxTemp;
        int   cyTemp;
        BOOL  fOldFormat;
        LPVOID dwDummy;
        DWORD dwTemp;

#define lpbch ((LPBITMAPCOREHEADER)lpbi)

        fOldFormat = ((WORD)lpbi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER));

        if (fOldFormat) {

            cxTemp = lpbch->bcWidth;
            cyTemp = lpbch->bcHeight;

            lpbch->bcWidth  = (WORD)cxNew;
            lpbch->bcHeight = (WORD)cyNew;

        } else {

            cxTemp = lpbi->bmiHeader.biWidth;
            cyTemp = lpbi->bmiHeader.biHeight;
            dwTemp = lpbi->bmiHeader.biCompression;

            lpbi->bmiHeader.biWidth  = cxNew;
            lpbi->bmiHeader.biHeight = cyNew;

            if (dwTemp != BI_BITFIELDS)
                lpbi->bmiHeader.biCompression = BI_RGB;
        }

        if (LR_flags & LR_CREATEREALDIB) {
            hbmpNew = CreateDIBitmap(ghdcBits2,
                                     (LPBITMAPINFOHEADER)lpbi,
                                     CBM_CREATEDIB,
                                     NULL,
                                     lpbi,
                                     DIB_RGB_COLORS);
        } else {
            hbmpNew = CreateDIBSection(ghdcBits2,
                                       lpbi,
                                       DIB_RGB_COLORS,
                                       &dwDummy,
                                       0,
                                       0);
        }

        if (fOldFormat) {
            lpbch->bcWidth  = (WORD)cxTemp;
            lpbch->bcHeight = (WORD)cyTemp;
        } else {
            lpbi->bmiHeader.biWidth       = cxTemp;
            lpbi->bmiHeader.biHeight      = cyTemp;
            lpbi->bmiHeader.biCompression = dwTemp;
        }
#undef lpbch
    }

    if (hbmpNew == NULL) {

        hbmpNew = CreateScreenBitmap(cxNew,
                                     cyNew,
                                     bPlanesNew,
                                     bBitsPixelNew,
                                     NULL,
                                     &f1Bpp);
    }

    if (hbmpNew) {

        int     nStretchMode;
        DWORD   rgbBk;
        DWORD   rgbText;
        HBITMAP hbmpT;
        BOOL    fFail;

        /*
         * We need to select in appropriate bitmap immediately!  That way,
         * if we need to handle palette realization, the color matching
         * will work properly.
         */
        hbmpT = SelectBitmap(ghdcBits2, hbmpNew);

        /*
         * Setup for stretching
         */
        if (fStretch) {
            nStretchMode = SetBestStretchMode(ghdcBits2,
                                              bPlanesNew,
                                              bBitsPixelNew);
        }

        rgbBk   = SetBkColor(ghdcBits2, RESCLR_WHITE);
        rgbText = SetTextColor(ghdcBits2, RESCLR_BLACK);

        /*
         * Realize the palette.
         */
        if (hpal) {
#if DBG
            UserAssert(TEST_PUSIF(PUSIF_PALETTEDISPLAY));
#endif // DBG

            hpal = SelectPalette(ghdcBits2, hpal, FALSE);
            RealizePalette(ghdcBits2);
        }

        if (fStretch) {

            fFail = SmartStretchDIBits(ghdcBits2,
                               0,
                               0,
                               cxNew,
                               cyNew,
                               0,
                               0,
                               cxOld,
                               cyOld,
                               lpBits,
                               lpbi,
                               DIB_RGB_COLORS,
                               SRCCOPY) <= 0;
        } else {

            fFail = SetDIBits(ghdcBits2,
                      hbmpNew,
                      0,
                      cyNew,
                      lpBits,
                      lpbi,
                      DIB_RGB_COLORS) <= 0;
        }

        /*
         * Unrealize the palette
         */
        if (hpal) {
            SelectPalette(ghdcBits2, hpal, TRUE);
            RealizePalette(ghdcBits2);
        }

        /*
         * Cleanup after stretching
         */
        SetTextColor(ghdcBits2, rgbText);
        SetBkColor(ghdcBits2, rgbBk);
        if (fStretch)
            SetStretchBltMode(ghdcBits2, nStretchMode);

        SelectBitmap(ghdcBits2, hbmpT);

        /*
         * If the SetDIBits() of StretchDIBits() failed, it is probably because
         * GDI or the driver did not like the DIB format.  This may happen if
         * the file is truncated and we are using a memory mapped file to read
         * the DIB in.  In this case, an exception gets thrown in GDI, that it
         * traps and will return failure from the GDI call.
         */

        if (fFail) {
            DeleteObject(hbmpNew);
            hbmpNew = NULL;
        }
    }

    /*
     * If the bitmap was created as a 1bpp, we need to convert to a
     * true mono-bitmap.  GDI performs different color-matching depending
     * upon this case.
     */
    if (f1Bpp && hbmpNew)
        hbmpNew = Convert1BppToMonoBitmap(ghdcBits2, hbmpNew);

    RtlLeaveCriticalSection(&gcsHdc);
    return hbmpNew;
}

/***************************************************************************\
* HowManyColors
*
* Aug-01-2000 DwayneN - Fixed high color support
\***************************************************************************/

DWORD HowManyColors(
    IN  UPBITMAPINFOHEADER upbih,
    IN  BOOL               fOldFormat,
    OUT OPTIONAL LPBYTE    *ppColorTable)
{
#define upbch ((UPBITMAPCOREHEADER)upbih)

    if (fOldFormat) {
        if (ppColorTable != NULL) {
            *ppColorTable = (LPBYTE)(upbch + 1);
        }
        if (upbch->bcBitCount <= 8)
            return (1 << upbch->bcBitCount);
    } else {
        if (ppColorTable != NULL) {
            *ppColorTable = (LPBYTE)(upbih + 1);
        }

        if (upbih->biClrUsed) {
            /*
             * If the bitmap header explicitly provides the number of colors
             * in the color table, use it.
             */
            return (DWORD)upbih->biClrUsed;
        } else if (upbih->biBitCount <= 8) {
            /*
             * If the bitmap header describes a pallete-bassed bitmap
             * (8bpp or less) then the color table must be big enough
             * to hold all palette indecies.
             */
            return (1 << upbih->biBitCount);
        } else {
            /*
             * Finally, if the bitmap header describes a highcolor+ bitmap
             * (anything over 8bpp, but typically 16bpp, 24bpp, or 32bpp)
             * there isn't a need for a color table.  However, 16bpp and
             * 32bpp bitmaps are special cases since it is not obvious how
             * they should be split into triplets (Red, Green, and Blue).  For
             * instance, 16bpp bitmaps can have 6 red bits, 5 green bits, and
             * 5 blue bits.  Or some other combination.  To specify this, the
             * 16bpp and 32bpp bitmaps provide BI_BITFIELDS in the 
             * biCompression field.  This indicates that the color table will
             * have 3 DWORDS that describe the masks for the red, green, and
             * blue components of entry in the bitmap.  If this isn't 
             * specified, then GDI assumes "555" for 16bpp and "XBGR" for
             * 32bpp.  24bpp bitmaps are always "XBGR" and consume a 32-bit
             * entry in the form of an RGBQUAD.
             */
            if (upbih->biCompression == BI_BITFIELDS) {
                if ((upbih->biBitCount != 16) && (upbih->biBitCount != 32)) {
                    RIPMSG1(RIP_WARNING, "HowManyColors: biCompression==BI_BITFIELDS on a %dbpp bitmap!", upbih->biBitCount);
                }

                return 3;
            }
        }
    }

    /*
     * Evidently, there is no color table.
     */
    return 0;

#undef upbch
}

/***************************************************************************\
* ChangeDibColors
*
* Given a DIB, processes LR_MONOCHROME, LR_LOADTRANSPARENT and
* LR_LOADMAP3DCOLORS flags on the given header and colortable.
*
*
\***************************************************************************/

VOID ChangeDibColors(
    IN LPBITMAPINFOHEADER lpbih,
    IN UINT               LR_flags)
{
    LPDWORD lpColorTable;
    DWORD  rgb;
    UINT   iColor;
    UINT   cColors;

    cColors = HowManyColors(lpbih, FALSE, &(LPBYTE)lpColorTable);

    /*
     * NT Bug 366661: Don't check the color count here b/c we will do different
     * things depending on what type of change we are performing.  For example,
     * when loading hi-color/true-color icons, we always need to do the
     * monochrome conversion in order to properly get an icon-mask.
     */

    /*
     * LR_MONOCHROME is the only option that handles PM dibs.
     */
    if (LR_flags & LR_MONOCHROME) {
        /*
         * LR_MONOCHROME is the only option that handles PM dibs.
         *
         * DO THIS NO MATTER WHETHER WE HAVE A COLOR TABLE!  We need
         * to do this for mono conversion and for > 8 BPP
         * icons/cursors.  In CopyDibHdr, we already made a copy of
         * the header big enough to hold 2 colors even on high-color+
         * bpp images.
         */
        lpbih->biBitCount = lpbih->biPlanes = 1;
        lpbih->biCompression = 0;
        lpColorTable[0] = RESCLR_BLACK;
        lpColorTable[1] = RESCLR_WHITE;
    } else if (LR_flags & LR_LOADTRANSPARENT) {

        LPBYTE pb;

        /*
         * No color table!  Do nothing.
         */
        if (cColors == 0) {
            RIPMSG0(RIP_WARNING, "ChangeDibColors: DIB doesn't have a color table");
            return;
        }

        pb = (LPBYTE)(lpColorTable + cColors);

        /*
         * Change the first pixel's color table entry to RGB_WINDOW
         * Gosh, I love small-endian
         */
        if (lpbih->biCompression == 0)
            iColor = (UINT)pb[0];
        else
            /*
             * RLE bitmap, will start with cnt,clr  or  0,cnt,clr
             */
            iColor = (UINT)(pb[0] == 0 ? pb[2] : pb[1]);

        switch (cColors) {
        case BPP01_MAXCOLORS:
            iColor &= 0x01;
            break;

        case BPP04_MAXCOLORS:
            iColor &= 0x0F;
            break;

        case BPP08_MAXCOLORS:
            iColor &= 0xFF;
            break;
        }

        rgb = (LR_flags & LR_LOADMAP3DCOLORS ? SYSRGB(3DFACE) : SYSRGB(WINDOW));

        lpColorTable[iColor] = RGBX(rgb);

    } else  if (LR_flags & LR_LOADMAP3DCOLORS) {

        /*
         * Fix up the color table, mapping shades of grey to the current
         * 3D colors.
         */
        for (iColor = 0; iColor < cColors; iColor++) {

            switch (*lpColorTable & 0x00FFFFFF) {

            case RGBX(RGB(223, 223, 223)):
                rgb = SYSRGB(3DLIGHT);
                goto ChangeColor;

            case RGBX(RGB(192, 192, 192)):
                rgb = SYSRGB(3DFACE);
                goto ChangeColor;

            case RGBX(RGB(128, 128, 128)):
                rgb = SYSRGB(3DSHADOW);

                /*
                 * NOTE: byte-order is different in DIBs than in RGBs
                 */
ChangeColor:
                *lpColorTable = RGBX(rgb);
                break;
            }
            lpColorTable++;
        }
    }
}

/***************************************************************************\
* ConvertDIBIcon
*
* Called when a cursor/icon in DIB format is loaded.  This converts the
* cursor/icon into the old format and returns the resource handle.  IE,
* grabs the DIB bits and transforms them into physical bitmap bits.
*
*
* DIB Formats for icons/cursors 101
*
* Old Win 3.0 format icons/cursors start with an OLDICON/OLDCURSOR header
* followed by a double high monochrome DIB.  The height refered to in the
* header is the icon/cursor height, not the DIB height which is twice as
* high.  The XOR mask is in the first-half of the DIB bits.
*
* Old PM format icons/cursors start with a BITMAPCOREHEADER and
* are identical to the current win 3.1/NT format thereafter.
*
* Current NT/Chicago/Win 3.1 format icons/cursors start with
* a BITAMPINFOHEADER.  The height of this header refers to the height
* of the first bitmap which may either be color or truely monochrome.
* If its color, it is followed by the monochrome AND mask bits imediately
* after the color bits.  If it is truely monochrome, the AND and XOR
* masks are totally contained in the first DIB bits and no more bits
* follow.
*
* 5-Oct-1994 SanfordS   Recreated
\***************************************************************************/

HICON ConvertDIBIcon(
    LPBITMAPINFOHEADER lpbih,
    HINSTANCE          hmod,
    LPCWSTR            lpName,
    BOOL               fIcon,
    DWORD              cxNew,
    DWORD              cyNew,
    UINT               LR_flags)
{
    LPBITMAPINFOHEADER lpbihNew = NULL;
    LPSTR              lpBitsNextMask = NULL;
    HICON              hicoNew = NULL;
    BOOL               fOldFormat = FALSE;
    CURSORDATA         cur;
    WCHAR              achModName[MAX_PATH];

    /*
     * Because Icons/Cursors always get public bitmaps, we cannot use
     * LR_CREATEDIBSECTION on them.
     */
    if (LR_flags & LR_CREATEDIBSECTION) {
        LR_flags = (LR_flags & ~LR_CREATEDIBSECTION) | LR_CREATEREALDIB;
    }

    RtlZeroMemory(&cur, sizeof(cur));

    if (!fIcon) {
        /*
         * Cursors have an extra two words preceeding the BITMAPINFOHEADER
         * indicating the hot-spot.  After doing the increments, the
         * pointer should be at the dib-header.
         */
        cur.xHotspot = (short)(int)*(((LPWORD)lpbih)++);
        cur.yHotspot = (short)(int)*(((LPWORD)lpbih)++);
    }

    /*
     * If the color bitmap is a single plane, 32bpp image, it might
     * contain an alpha channel, so we have to preserve it as a DIB.
     */
    if (lpbih->biPlanes == 1 && lpbih->biBitCount == 32) {
        LR_flags |= LR_CREATEREALDIB;
    }

    /*
     * Get the XOR/Color mask.
     * The XOR bits are first in the DIB because the header info
     * pertains to them.
     * The AND mask is always monochrome.
     */
    lpBitsNextMask = NULL;  // not passing lpBits in.
    cur.hbmColor = ConvertDIBBitmap(lpbih,
                                    cxNew,
                                    cyNew,
                                    LR_flags,
                                    &lpbihNew,
                                    &lpBitsNextMask);
    if (cur.hbmColor == NULL)
        return NULL;

    if (hmod == NULL) {
        cur.lpModName = NULL;
    } else {
        cur.CURSORF_flags = CURSORF_FROMRESOURCE;
        if (hmod == hmodUser) {
            cur.lpModName     = szUSER32;
        } else  {
            WowGetModuleFileName(hmod,
                              achModName,
                              sizeof(achModName) / sizeof(WCHAR));
            cur.lpModName = achModName;
        }
    }
    cur.rt     = (fIcon ? PTR_TO_ID(RT_ICON) : PTR_TO_ID(RT_CURSOR));
    cur.lpName = (LPWSTR)lpName;
    cur.bpp    = lpbihNew->biBitCount * lpbihNew->biPlanes;

    if (cxNew == 0)
        cxNew = lpbihNew->biWidth;

    if (cyNew == 0)
        cyNew = lpbihNew->biHeight / 2;

    if (!fIcon) {

        cur.xHotspot = MultDiv(cur.xHotspot,
                               cxNew,
                               lpbihNew->biWidth);
        cur.yHotspot = MultDiv(cur.yHotspot,
                               cyNew,
                               lpbihNew->biHeight / 2);
    } else {

        /*
         * For an icon the hot spot is the center of the icon
         */
        cur.xHotspot = (INT)(cxNew) / 2;
        cur.yHotspot = (INT)(cyNew) / 2;
    }

    /*
     * Setup header for monochrome DIB.  Note that we use the COPY.
     */
    ChangeDibColors(lpbihNew, LR_MONOCHROME);

    if (lpBitsNextMask != NULL) {
        cur.hbmMask = BitmapFromDIB(cxNew,
                                    cyNew * 2,
                                    1,
                                    1,
                                    0,
                                    lpbihNew->biWidth,
                                    lpbihNew->biHeight,
                                    lpBitsNextMask,
                                    (LPBITMAPINFO)lpbihNew,
                                    NULL);

        if (cur.hbmMask == NULL) {
            DeleteObject(KHBITMAP_TO_HBITMAP(cur.hbmColor));
            UserLocalFree(lpbihNew);
            return NULL;
        }

    } else {
        cur.hbmMask = cur.hbmColor;
        cur.hbmColor = NULL;
    }

    cur.cx = cxNew;
    cur.cy = cyNew * 2;

    /*
     * Free our dib header copy allocated by ConvertDIBBitmap
     */
    UserLocalFree(lpbihNew);

    if (LR_flags & LR_SHARED)
        cur.CURSORF_flags |= CURSORF_LRSHARED;

    if (LR_flags & LR_GLOBAL)
        cur.CURSORF_flags |= CURSORF_GLOBAL;

    if (LR_flags & LR_ACONFRAME)
        cur.CURSORF_flags |= CURSORF_ACONFRAME;

    return CreateIcoCur(&cur);
}

/***************************************************************************\
* TrulyMonochrome
*
* Checks to see if a DIB colro table is truly monochrome.  ie: the color
* table has black & white entries only.
*
\***************************************************************************/

BOOL TrulyMonochrome(
    LPVOID lpColorTable,
    BOOL   fOldFormat)
{
    #define lpRGB  ((UNALIGNED LONG *)lpColorTable)
    #define lpRGBw ((UNALIGNED WORD *)lpColorTable)

    if (fOldFormat) {

        /*
         * Honey - its triplets.
         */
        if (lpRGBw[0] == 0x0000)
            return (lpRGBw[1] == 0xFF00) && (lpRGBw[2] == 0xFFFF);
        else if (lpRGBw[0] == 0xFFFF)
            return (lpRGBw[1] == 0x00FF) && (lpRGBw[2] == 0x0000);

    } else {

        /*
         * Honey - its quadruplets!
         */
        if (lpRGB[0] == RESCLR_BLACK)
            return (lpRGB[1] == RESCLR_WHITE);
        else if (lpRGB[0] == RESCLR_WHITE)
            return (lpRGB[1] == RESCLR_BLACK);
    }

    #undef lpRGB
    #undef lpRGBw

    return FALSE;
}

/***************************************************************************\
* CopyDibHdr
*
* Copies and converts a DIB resource header
*
* Handles conversion of OLDICON, OLDCURSOR and BITMAPCOREHEADER
* structures to BITMAPINFOHEADER headers.
*
* Note: fSingleHeightMasks is set for OLDICON and OLDCURSOR formats.
*       This identifies that a monochrome AND/Color mask
*       is NOT double height as it is in the newer formats.
*
* NOTE:  On the off chance that LR_LOADTRANSPARENT is used, we want to
*     copy a DWORD of the bits.  Since DIB bits are DWORD aligned, we know
*     at least a DWORD is there, even if the thing is a 1x1 mono bmp.
*
* The returned buffer is allocated in this function and needs to be
* freed by the caller.
*
* 22-Oct-1995 SanfordS  Revised
\***************************************************************************/

LPBITMAPINFOHEADER CopyDibHdr(
    IN  UPBITMAPINFOHEADER upbih,
    OUT LPSTR             *lplpBits,
    OUT LPBOOL             lpfMono)
{

#define upbch ((UPBITMAPCOREHEADER)upbih)
    DWORD              cColors;
    DWORD              cMinColors;
    DWORD              i;
    LPBITMAPINFOHEADER lpbihNew;
    DWORD              cbAlloc;
    LPBYTE             lpColorTable;
    struct  {
        BITMAPINFOHEADER   bih;
        DWORD              rgb[256];
        DWORD              dwBuffer;
    } Fake;

    switch (upbih->biSize) {
    case sizeof(BITMAPINFOHEADER):
        /*
         * Cool.  No conversion needed.
         */
        cColors   = HowManyColors(upbih, FALSE, &lpColorTable);
        *lplpBits = (LPSTR)(((LPDWORD)lpColorTable) + cColors);
        break;

    case sizeof(BITMAPCOREHEADER):
        /*
         * Convert the BITMAPCOREHEADER to a BITMAPINFOHEADER
         */
        Fake.bih.biSize          = sizeof(BITMAPINFOHEADER);
        Fake.bih.biWidth         = upbch->bcWidth;
        Fake.bih.biHeight        = upbch->bcHeight;
        Fake.bih.biPlanes        = upbch->bcPlanes;
        Fake.bih.biBitCount      = upbch->bcBitCount;
        Fake.bih.biCompression   =
        Fake.bih.biXPelsPerMeter =
        Fake.bih.biYPelsPerMeter =
        Fake.bih.biClrImportant  = 0;
        Fake.bih.biClrUsed       = cColors = HowManyColors(upbih, TRUE, &lpColorTable);
        Fake.bih.biSizeImage     = BitmapWidth(Fake.bih.biWidth, Fake.bih.biBitCount) * Fake.bih.biHeight;

        /*
         * Copy and convert tripplet color table to rgbQuad color table.
         */
        for (i = 0; i < cColors; i++, lpColorTable += 3) {

            Fake.rgb[i] = lpColorTable[0]        +
                          (lpColorTable[1] << 8) +
                          (lpColorTable[2] << 16);
        }

        Fake.rgb[i] = *(DWORD UNALIGNED *)lpColorTable;  // For LR_LOADTRANSPARENT
        upbih       = (UPBITMAPINFOHEADER)&Fake;
        *lplpBits   = lpColorTable;
        break;

    default:

#define upOldIcoCur ((UPOLDCURSOR)upbih)

        if (upOldIcoCur->bType == BMR_ICON ||
                upOldIcoCur->bType == BMR_CURSOR) {
            /*
             * Convert OLDICON/OLDCURSOR header to BITMAPINFHEADER
             */
            RIPMSG0(RIP_WARNING, "USER32:Converting a OLD header. - email sanfords if you see this");
            Fake.bih.biSize          = sizeof(BITMAPINFOHEADER);
            Fake.bih.biWidth         = upOldIcoCur->cx;
            Fake.bih.biHeight        = upOldIcoCur->cy * 2;
            Fake.bih.biPlanes        =
            Fake.bih.biBitCount      = 1;
            Fake.bih.biCompression   =
            Fake.bih.biXPelsPerMeter =
            Fake.bih.biYPelsPerMeter =
            Fake.bih.biClrImportant  = 0;
            Fake.bih.biClrUsed       = cColors = BPP01_MAXCOLORS;
            Fake.bih.biSizeImage     = BitmapWidth(upOldIcoCur->cx, 1) * upOldIcoCur->cy;
            Fake.rgb[0]              = RESCLR_BLACK;
            Fake.rgb[1]              = RESCLR_WHITE;
            upbih                    = (LPBITMAPINFOHEADER)&Fake;
            *lplpBits                = upOldIcoCur->abBitmap;
            Fake.rgb[2]              = *((LPDWORD)*lplpBits);  // For LR_LOADTRANSPARENT

        } else {

            RIPMSG0(RIP_WARNING, "ConvertDIBBitmap: not a valid format");
            return NULL;
        }

#undef pOldIcoCur

        break;
    }

    *lpfMono = (cColors == BPP01_MAXCOLORS) &&
            TrulyMonochrome((LPBYTE)upbih + sizeof(BITMAPINFOHEADER), FALSE);

    /*
     * Note: We have to allocate at least 2 color entries so that we have
     * room in the color table to define black and white for monochrome
     * conversions.  See ChangeDibColors() and ConvertDIBIcon().
     */
    cMinColors = cColors >= 2 ? cColors : 2;

    /*
     * LR_LOADTRANSPARENT needs to examine the first pixel to determine the
     * transparent color.  This routine splits the bitmap header away
     * from the actual bitmap bits.  However, the routines that process the
     * LR_LOADTRANSPARENT style expect the first pixel to immediately follow
     * the bitmap header.  Above we copied the first pixel of the bitmap
     * bits right after the color table.  Now we just need to make room for
     * it in our buffer.
     */
    cMinColors++;

    cbAlloc = sizeof(BITMAPINFOHEADER) + (cMinColors * sizeof(RGBQUAD));

    if (lpbihNew = UserLocalAlloc(0, cbAlloc)) {
        RtlCopyMemory(lpbihNew, upbih, cbAlloc);
    }

    return lpbihNew;

#undef upbch

}

/***************************************************************************\
* ConvertDIBBitmap
*
* This takes a BITMAPCOREHEADER, OLDICON, OLDCURSOR or BITMAPINFOHEADER DIB
* specification and creates a physical object from it.
* Handles Color fixups, DIB sections, color depth, and stretching options.
*
* Passes back: (if lplpbih is not NULL)
*   lplpbih = copy of given header converted to BITMAPINFOHEADER form.
*   lplpBits = pointer to next mask bits, or NULL if no second mask.
*   Caller must free lplpbih returned.
*
* If lplpBits is not NULL and points to a non-NULL value, it supplies
* the location of the DIB bits allowing the header to be from a different
* location.
*
* 04-Oct-1995 SanfordS  Recreated.
\***************************************************************************/

HBITMAP ConvertDIBBitmap(
    IN  UPBITMAPINFOHEADER           upbih,
    IN  DWORD                        cxDesired,
    IN  DWORD                        cyDesired,
    IN  UINT                         LR_flags,
    OUT OPTIONAL LPBITMAPINFOHEADER *lplpbih,
    IN OUT OPTIONAL LPSTR           *lplpBits)
{
    LPBITMAPINFOHEADER lpbihNew;
    BOOL               fMono, fMonoGiven;
    BYTE               bPlanesDesired;
    BYTE               bppDesired;
    LPSTR              lpBits;
    HBITMAP            hBmpRet;

    /*
     * Make a copy of the DIB-Header.  This returns a pointer
     * which was allocated, so it must be freed later.
     * The also converts the header to BITMAPINFOHEADER format.
     */
    if ((lpbihNew = CopyDibHdr(upbih, &lpBits, &fMono)) == NULL) {
        return NULL;
    }

    /*
     * When loading a DIB file, we may need to use a different
     * bits pointer.  See RtlRes.c/RtlLoadObjectFromDIBFile.
     */
    if (lplpBits && *lplpBits) {
        lpBits = *lplpBits;
    }

    fMonoGiven = fMono;

    if (!fMono) {

        if (LR_flags & (LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS))
            ChangeDibColors(lpbihNew, LR_flags & ~LR_MONOCHROME);

        if (LR_flags & LR_CREATEREALDIB) {
            bPlanesDesired = (BYTE) lpbihNew->biPlanes;
            bppDesired = (BYTE) lpbihNew->biBitCount;
        } else {
            bPlanesDesired = gpsi->Planes;
            bppDesired = gpsi->BitsPixel;
        }

        fMono = LR_flags & LR_MONOCHROME;
    }

    if (fMono) {
        bPlanesDesired =
        bppDesired     = 1;
    }

    /*
     * HACK area
     */
    if (lplpbih != NULL) {

        /*
         * pass back the translated/copied header
         */
        *lplpbih = lpbihNew;

        /*
         * When loading icon/cursors on a system with multiple monitors
         * with different color depths, always convert to VGA color.
         *
         * dwaynen - 1/12/2001
         * Note: This used to also check the SM_SAMEDISPLAYFORMAT metric.  If
         * the display formats (on a multi-mon system) were different, it
         * would force the bpp to 4,  We have removed this code because we
         * suspect that it isn't really needed.
         * Refer to bug 258022.
         *
        if (!fMono && !SYSMET(SAMEDISPLAYFORMAT)) {
            bPlanesDesired = 1;
            bppDesired = 4;
        }
        */

        /*
         * Return a ponter to the bits following this set of bits
         * if there are any there.
         *
         * Note that the header given with an ICON DIB always reflects
         * twice the height of the icon desired but the COLOR bitmap
         * (if there is one) will only be half that high.  We need to
         * fixup cyDesired for monochrome icons so that the mask isnt
         * stretched to half the height its supposed to be.  Color
         * bitmaps, however, must have the header corrected to reflect
         * the bits actual height which is half what the header said.
         * The correction must later be backed out so that the returned
         * header reflects the dimensions of the XOR mask that immediately
         * follows the color mask.
         */
        if (fMonoGiven) {

            *lplpBits = NULL;

            if (cyDesired)
                cyDesired <<= 1;    // mono icon bitmaps are double high.

        } else {

            UserAssert(!(lpbihNew->biHeight & 1));
            lpbihNew->biHeight >>= 1;  // color icon headers are off by 2

            /*
             * Gross calculation!  We subtract the XOR part of the mask
             * for this calculation so that we submit a double-high mask.
             * The first half of this is garbage, but for icons its not
             * used.  This may be a bug for cursor use of icons.
             */
            *lplpBits = lpBits +
                    (BitmapWidth(lpbihNew->biWidth, lpbihNew->biBitCount) -
                    BitmapWidth(lpbihNew->biWidth, 1)) *
                    lpbihNew->biHeight;
        }
    }

    if (cxDesired == 0)
        cxDesired = lpbihNew->biWidth;

    if (cyDesired == 0)
        cyDesired = lpbihNew->biHeight;

    hBmpRet = BitmapFromDIB(cxDesired,
                            cyDesired,
                            bPlanesDesired,
                            bppDesired,
                            LR_flags,
                            lpbihNew->biWidth,
                            lpbihNew->biHeight,
                            lpBits,
                            (LPBITMAPINFO)lpbihNew,
                            NULL);

    if (lplpbih == NULL || hBmpRet == NULL) {
        UserLocalFree(lpbihNew);
    } else if (!fMonoGiven) {
        lpbihNew->biHeight <<= 1;   // restore header for next mask
    }

    return hBmpRet;
}

/***************************************************************************\
* MyAbs
*
* Calcules my weighted absolute value of the difference between 2 nums.
* This of course normalizes values to >= zero.  But it can also "punish" the
* returned value by a factor of two if valueHave < valueWant.  This is
* because you get worse results trying to extrapolate from less info up then
* interpolating from more info down.
*
\***************************************************************************/

UINT MyAbs(
    int valueHave,
    int valueWant,
    BOOL fPunish)
{
    int diff = (valueHave - valueWant);

    if (diff < 0)
        diff = (fPunish ? -2 : -1) * diff;

    return (UINT)diff;
}

/***************************************************************************\
* Magnitude
*
* Used by the color-delta calculations.  The reason is that num colors is
* always a power of 2.  So we use the log 2 of the want vs. have values
* to avoid having weirdly huge sets.
*
\***************************************************************************/

UINT Magnitude(
    int nValue)
{
    if (nValue < 4)
        return 1;
    else if (nValue < 8)
        return 2;
    else if (nValue < 16)
        return 3;
    else if (nValue < 256)
        return 4;
    else
        return 8;
}

/***************************************************************************\
* GetResourceBpp
*
* Extract the bpp for a icon/cursor resource.  Handle low and high-color
* formats.
*
\***************************************************************************/
UINT GetResourceBpp(LPRESDIR lprd, BOOL fIcon)
{
    UINT bpp = 0;

    if (fIcon) {
        if (lprd->Icon.ColorCount != 0) {
            bpp = Magnitude(lprd->Icon.ColorCount);
            TAGMSG2(DBGTAG_Icon, "GetResourceBpp: icon color count = %d, bpp = %d", lprd->Icon.ColorCount, bpp);
        } else {
            bpp = lprd->BitCount;
            TAGMSG1(DBGTAG_Icon, "GetResourceBpp: icon bpp = %d", bpp);
        }
    } else {
        /*
         * NTRAID#NTBUG9-360375-2001/04/05-dwaynen  
         * This seems really suspicious to me.
         * Forcing bppNew to 1.
         *    Cursors provide a hotspot where an icon provides bit-depth
         *    information.  So we just set the bppNew to 1, since we don't
         *    have any better ideas.  We just hope that there is only
         *    one cursor candidate, otherwise our scoring logic is broken.
         *    Also this is broken when we try to load a cursor resource
         *    as an icon.  We won't match color depth properly!
         */
        bpp = 1;
        TAGMSG1(DBGTAG_Icon, "GetResourceBpp: cursor bpp = %d", bpp);
    }

    /*
     * Nothing has 0 bpp.
     */
    if(bpp == 0) {
    	bpp = ICON_DEFAULTDEPTH;
        TAGMSG1(DBGTAG_Icon, "GetResourceBpp: icon color depth unknown!  Assuming %d!", bpp);
    }

    return bpp;
}

/***************************************************************************\
* MatchImage
*
* This function takes LPINTs for width & height in case of "real size".
* For this option, we use dimensions of 1st icon in resdir as size to
* load, instead of system metrics.
*
* Returns a number that measures how "far away" the given image is
* from a desired one.  The value is 0 for an exact match.  Note that our
* formula has the following properties:
*     (1) Differences in width/height count much more than differences in
*         color format.
*     (2) Bigger images are better than smaller, since shrinking produces
*         better results than stretching.
*     (3) Color matching is done by the difference in bit depth.  No
*         preference is given to having a candidate equally different
*         above and below the target.
*
* The formula is the sum of the following terms:
*     abs(bppCandidate - bppTarget)
*     abs(cxCandidate - cxTarget), times 2 if the image is
*         narrower than what we'd like.  This is because we will get a
*         better result when consolidating more information into a smaller
*         space, than when extrapolating from less information to more.
*     abs(cxCandidate - cxTarget), times 2 if the image is
*         shorter than what we'd like.  This is for the same reason as
*         the width.
*
* Let's step through an example.  Suppose we want a 4bpp (16 color),
* 32x32 image.  We would choose the various candidates in the following order:
* 
* Candidate     Score   Formula
*
* 32x32x4bpp  = 0       abs(32-32)*1 + abs(32-32)*1 + 2*abs(4-4)*1
* 32x32x2bpp  = 4
* 32x32x8bpp  = 8
* 32x32x16bpp = 24
* 48x48x4bpp  = 32
* 48x48x2bpp  = 36
* 48x48x8bpp  = 40
* 32x32x32bpp = 56
* 48x48x16bpp = 56      abs(48-32)*1 + abs(48-32)*1 + 2*abs(16-4)*1
* 16x16x4bpp  = 64
* 16x16x2bpp  = 68      abs(16-32)*2 + abs(16-32)*2 + 2*abs(2-4)*1
* 16x16x8bpp  = 72
* 48x48x32bpp = 88      abs(48-32)*1 + abs(48-32)*1 + 2*abs(32-4)*1
* 16x16x16bpp = 88
* 16x16x32bpp = 104
*
\***************************************************************************/

UINT MatchImage(
    LPRESDIR lprd,
    LPINT    lpcxWant,
    LPINT    lpcyWant,
    UINT     bppWant,
    BOOL     fIcon)
{
    UINT bppNew;
    int  cxNew;
    int  cyNew;
    UINT score;

    cxNew = lprd->Icon.Width;
    cyNew = lprd->Icon.Height;
	bppNew = GetResourceBpp(lprd, fIcon);

    if (!fIcon) {
        /*
         * NTRAID#NTBUG9-360375-2001/04/05-dwaynen  
         *
         * This seems really suspicious to me.
         * Cutting the height in half.
         *    This is because cursors store a 2X height for legacy reasons.
         *    Unfortunately, this code path can also be used to load an
         *    icon resource AS a cursor.  Maybe we should only do this for
         *    cursor resources.  But how to tell?
         */
        cyNew >>= 1;
    }

    /*
     * 0 really means maximum size (256) or colors (256).
     */
    if (!cxNew) {
        cxNew = ICON_MAXWIDTH;
        TAGMSG1(DBGTAG_Icon, "MatchImage: icon width unknown!  Assuming %d!", cxNew);
    }

    if (!*lpcxWant) {
        *lpcxWant = cxNew;
    }

    if (!cyNew) {
        cyNew = ICON_MAXHEIGHT;
        TAGMSG1(DBGTAG_Icon, "MatchImage: icon height unknown!  Assuming %d!", cyNew);
    }

    if (!*lpcyWant) {
        *lpcyWant = cyNew;
    }

	/*
     * Here are the rules for our "match" formula:
     *      (1) A close size match is much preferable to a color match
     *      (2) Bigger icons are better than smaller
     *      (3) The smaller the difference in bit depths the better
     */
    score = 2*MyAbs(bppNew, bppWant, FALSE) +
            MyAbs(cxNew, *lpcxWant, TRUE) +
            MyAbs(cyNew, *lpcyWant, TRUE);

    TAGMSG4(DBGTAG_Icon, "MatchImage: Candidate Summary: cx=%d, cy=%d, bpp=%d, score=%d", cxNew, cyNew, bppNew, score);

    return score;
}

/***************************************************************************\
* GetBestImage
*
* Among the different forms of images, choose the one that best matches the
* color format & dimensions of the request.
*
* Here are the rules for our "match" formula:
*      (1) A close size match is much preferable to a color match
*      (2) Bigger icons are better than smaller
*      (3) Closer bit depths are better
*
* Here are some additional rules:
*      (4) A tie is broken by choosing the one with the largest bpp.
*      (5) A further tie is broken by choosing the first in the resource.
*      (6) If we find an identical match, we return immediately.
*
\***************************************************************************/

UINT GetBestImage(
    LPRESDIR lprd,
    UINT     uCount,
    int      cxDesired,
    int      cyDesired,
    UINT     bppDesired,
    BOOL     fIcon)
{
    UINT i;
    UINT iBest = 0;
    UINT score;
    UINT scoreBest = (UINT)-1;
    UINT bppBest;
    UINT bppCandidate;

    TAGMSG0(DBGTAG_Icon, "GetBestImage: Icon dir has %d candidates.");
    TAGMSG4(DBGTAG_Icon, "GetBestImage: Looking for cx=%d, cy=%d, bpp=%d, fIcon=%s", cxDesired, cyDesired, bppDesired, fIcon ? "TRUE" : "FALSE");

    /*
     * If the bpp was not specified, grab the primary monitor's color depth.
     */
    if (bppDesired == 0) {
        bppDesired = (UINT)gpsi->BitCount;
        TAGMSG1(DBGTAG_Icon, "GetBestImage: Using screen bpp=%d", bppDesired);
    }

    /*
     * 10/18/2000 - dwaynen
     *
     * We no longer do the following, because we now pass along the
     * actuall bpp, instead of a color count.  The old code (commented out
     * below) used to crop the supported bpp to 8, and to convert the bpp
     * into an actual color count.  We used to pass the color count because
     * the resource format (see ICONDIR) stores the color count in a byte,
     * and we would simply compare the desired colors against the available
     * colors.  If an icon had 256 colors, it actually just stored a 0 in
     * the ICONDIR::ColorCount field.  The problem is obvious, what about
     * icons/cursors with more than 256 colors?
     *
     * Fortunately, the resource format also stores the bits-per-pixel (bpp).
     * So, we now pass along the desired bpp, instead of the desired color
     * count, to do our matching against.  
     *
     * Old code and comments below:
     * --------
     *
     * Get desired number of colors in # value, not bits value.  Note that
     * we do NOT allow you to have  16- or 32- or 24- bit color icons.
     *
     * the icon resources can be 16, 24, 32 bpp, but the restable only has
     * a color count, so a HiColor icon would have a max value in the
     * restable.  we treat a 0 in the color count as "max colors"
     *
     
    if (bpp > 8)
        bpp = 8;

    bpp = 1 << bpp;
    */

    /*
     * Loop through resource entries, saving the "closest" item so far.  Most
     * of the real work is in MatchImage(), which uses a fabricated formula
     * to give us the results that we desire.  Namely, an image as close in
     * size to what we want preferring bigger over smaller, then an image
     * with the right color format
     */
    for (i = 0; i < uCount; i++, lprd++) {
        TAGMSG1(DBGTAG_Icon, "GetBestImage: Checking candidate %d...", i);
        bppCandidate = GetResourceBpp(lprd, fIcon);

        /*
         * Get "matching" value.  How close are we to what we want?
         */
        score = MatchImage(lprd, &cxDesired, &cyDesired, bppDesired, fIcon);

        TAGMSG0(DBGTAG_Icon, "---------------------------------------------");

        if (score == 0) {
            /*
             * We've found an exact match!
             */
            TAGMSG1(DBGTAG_Icon, "GetBestImage: Found exact match: candidate=%d", i);
            iBest = i;
            break;
        } else if (score < scoreBest) {
            /*
             * We've found a better match than the current alternative.
             */
            scoreBest = score;
            iBest = i;
            bppBest = bppCandidate;
        } else if (score == scoreBest) {
            /*
             * Tie breaker: choose the higher color depth.  If that fails, choose first one.
             */
            if (bppBest < bppCandidate) {
                iBest = i;
                bppBest = bppCandidate;
            }
        }
    }

    TAGMSG2(DBGTAG_Icon, "GetBestImage: Using best match: candidate=%d, score=%d", iBest, scoreBest);
    return iBest;
}

/***************************************************************************\
* GetIcoCurWidth
*
* When zero is passed in for a dimension, calculates what size we should
* really used.  Done in a couple o' places, so made it a FN().
*
\***************************************************************************/

_inline DWORD GetIcoCurWidth(
    DWORD cxOrg,
    BOOL  fIcon,
    UINT  lrFlags,
    DWORD cxDes)
{
    if (cxOrg) {
        return cxOrg;
    } else if (lrFlags & LR_DEFAULTSIZE) {
        return (fIcon ? SYSMET(CXICON) : SYSMET(CXCURSOR));
    } else {
        return cxDes;
    }
}

/***************************************************************************\
* GetIcoCurHeight
*
* Vertical counterpart to GetWidth().
*
\***************************************************************************/

_inline DWORD GetIcoCurHeight(
    DWORD cyOrg,
    BOOL  fIcon,
    UINT  lrFlags,
    DWORD cyDes)
{
    if (cyOrg) {
        return cyOrg;
    } else if (lrFlags & LR_DEFAULTSIZE) {
        return (fIcon ? SYSMET(CYICON) : SYSMET(CYCURSOR));
    } else {
        return cyDes;
    }
}

/***************************************************************************\
* GetIcoCurBpp
*
* Returns best match Bpp based on lr-flags.
*
\***************************************************************************/

_inline DWORD GetIcoCurBpp(
    UINT lrFlags)
{
    if (lrFlags & LR_MONOCHROME) {

#if DBG
        if (lrFlags & LR_VGACOLOR) {
            RIPMSG0(RIP_WARNING, "lrFlags has both MONOCHROME and VGACOLOR; assuming MONOCHROME");
        }
#endif
        return 1;

    } else if (TEST_PUSIF(PUSIF_PALETTEDISPLAY) || (lrFlags & LR_VGACOLOR)) {
        /*
         * dwaynen - 1/12/2001
         * Note: This used to also check the SM_SAMEDISPLAYFORMAT metric.  If
         * the display formats (on a multi-mon system) were different, it
         * would also return 4,  We have removed this code because we suspect
         * that it isn't really needed.
         * Refer to bug 258022.
         *
         * || !SYSMET(SAMEDISPLAYFORMAT)
         *
         */

        return 4;
    } else {
        return 0;
    }
}

/***************************************************************************\
* WOWFindResourceExWCover
*
* The WOW FindResource routines expect an ansi string so we have to
* convert the calling string IFF it is not an ID
*
\***************************************************************************/

HANDLE WOWFindResourceExWCover(
    HANDLE  hmod,
    LPCWSTR rt,
    LPCWSTR lpUniName,
    WORD    LangId)
{
    LPSTR  lpAnsiName;
    HANDLE hRes;

    if (ID(lpUniName))
        return FINDRESOURCEEXA(hmod, (LPSTR)lpUniName, (LPSTR)rt, LangId);

    /*
     * Otherwise convert the name of the menu then call LoadMenu
     */
    if (!WCSToMB(lpUniName, -1, &lpAnsiName, -1, TRUE))
        return NULL;

    hRes = FINDRESOURCEEXA(hmod, lpAnsiName, (LPSTR)rt, LangId);

    UserLocalFree(lpAnsiName);

    return hRes;
}

/***************************************************************************\
* WOWLoadBitmapA
*
*
\***************************************************************************/

HBITMAP WOWLoadBitmapA(
    HINSTANCE hmod,
    LPCSTR    lpName,
    LPBYTE    pResData,
    DWORD     cbResData)
{
    LPWSTR  lpUniName;
    HBITMAP hRet;

    UNREFERENCED_PARAMETER(cbResData);

    if (pResData == NULL) {

        if (ID(lpName))
            return LoadBmp(hmod, (LPCWSTR)lpName, 0, 0, 0);

        if (!MBToWCS(lpName, -1, &lpUniName, -1, TRUE))
            return NULL;

        hRet = LoadBmp(hmod, lpUniName, 0, 0, 0);

        UserLocalFree(lpUniName);

    } else {

        hRet = ConvertDIBBitmap((LPBITMAPINFOHEADER)pResData,
                                0,
                                0,
                                LR_DEFAULTSIZE,
                                NULL,
                                NULL);
    }

    return hRet;
}

/***************************************************************************\
*
* WOWServerLoadCreateCursorIcon
*
\***************************************************************************/

HICON WowServerLoadCreateCursorIcon(
    HANDLE  hmod,
    LPWSTR  pszModName,
    DWORD   dwExpWinVer,
    LPCWSTR lpName,
    DWORD   cb,
    PVOID   pResData,
    LPWSTR  type,
    BOOL    fClient)
{
    HICON hRet;
    BOOL  fIcon = (type == RT_ICON);
    UINT  LR_Flags = LR_SHARED;

    UNREFERENCED_PARAMETER(pszModName);
    UNREFERENCED_PARAMETER(dwExpWinVer);
    UNREFERENCED_PARAMETER(cb);
    UNREFERENCED_PARAMETER(fClient);

    if (!fIcon)
        LR_Flags |= LR_MONOCHROME;

    if (pResData == NULL) {

        hRet = LoadIcoCur(hmod,
                          lpName,
                          type,
                          0,
                          0,
                          LR_Flags | LR_DEFAULTSIZE);

    } else {

        hRet = ConvertDIBIcon((LPBITMAPINFOHEADER)pResData,
                              hmod,
                              lpName,
                              fIcon,
                              GetIcoCurWidth(0 , fIcon, LR_DEFAULTSIZE, 0),
                              GetIcoCurHeight(0, fIcon, LR_DEFAULTSIZE, 0),
                              LR_Flags);
    }

    return hRet;
}

/***************************************************************************\
* WOWServerLoadCreateMenu
*
*
\***************************************************************************/
HMENU WowServerLoadCreateMenu(
    HANDLE hMod,
    LPCSTR lpName,
    CONST  LPMENUTEMPLATE pmt,
    DWORD  cb,
    BOOL   fCallClient)
{
    UNREFERENCED_PARAMETER(cb);
    UNREFERENCED_PARAMETER(fCallClient);

    if (pmt == NULL) {
        return LoadMenuA(hMod, lpName);
    } else
        return CreateMenuFromResource(pmt);
}

/***********************************************************************\
* DIBFromBitmap()
*
*  Creates a memory block with DIB information from a physical bitmap tagged
*  to a specific DC.
*
*  A DIB block consists of a BITMAPINFOHEADER + RGB colors + DIB bits.
*
* Returns: UserLocalAlloc pointer to DIB info.
*
* 03-Nov-1995 SanfordS  Created.
\***********************************************************************/

PVOID DIBFromBitmap(
    HBITMAP hbmp,
    HDC     hdc)
{
    BITMAP             bmp;
    LPBITMAPINFOHEADER lpbi;
    DWORD              cbBits;
    DWORD              cbPalette;
    DWORD              cbTotal;
    WORD               cBits;

    UserAssert(hbmp);
    UserAssert(hdc);

    if (GetObject(hbmp, sizeof(BITMAP), &bmp) == 0)
        return NULL;

    cBits = ((WORD)bmp.bmPlanes * (WORD)bmp.bmBitsPixel);

TrySmallerDIB:

    cbBits = (DWORD)WIDTHBYTES((WORD)bmp.bmWidth * cBits) * (DWORD)bmp.bmHeight;

    cbPalette = 0;
    if (cBits <= 8)
        cbPalette = (1 << cBits) * sizeof(RGBQUAD);
    else
        cbPalette = 3 * sizeof(RGBQUAD);

    cbTotal  = sizeof(BITMAPINFOHEADER) + cbPalette + cbBits;
    lpbi = (LPBITMAPINFOHEADER)UserLocalAlloc(HEAP_ZERO_MEMORY, cbTotal);
    if (lpbi == NULL) {

        /*
         * Try a smaller DIB, if we can.  We can't if the DIB is mono.
         */
        switch (cBits) {
        case 4:
            cBits = 1;
            break;

        case 8:
            cBits = 4;
            break;

        case 16:
            cBits = 8;
            break;

        case 24:
            cBits = 16;
            break;

        case 32:
            cBits = 24;
            break;

        default:
            return NULL;   // 1 or wierd.
        }

        RIPMSG1(RIP_WARNING, "Not enough memory to create large color DIB, trying %d bpp.", cBits);
        goto TrySmallerDIB;
    }

    RtlZeroMemory(lpbi, sizeof(BITMAPINFOHEADER));
    lpbi->biSize        = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth       = bmp.bmWidth;
    lpbi->biHeight      = bmp.bmHeight;
    lpbi->biPlanes      = 1;
    lpbi->biBitCount    = cBits;

    /*
     * Get old bitmap's DIB bits, using the current DC.
     */
    GetDIBits(hdc,
              hbmp,
              0,
              lpbi->biHeight,
              ((LPSTR)lpbi) + lpbi->biSize + cbPalette,
              (LPBITMAPINFO)lpbi,
              DIB_RGB_COLORS);

    lpbi->biClrUsed   = cbPalette / sizeof(RGBQUAD);
    lpbi->biSizeImage = cbBits;

    return lpbi;
}

/***************************************************************************\
* CopyBmp
*
* Creates a new bitmap and copies the given bitmap to the new one,
* stretching and color-converting the bits if desired.
*
* 03-Nov-1995 SanfordS  Created.
\***************************************************************************/

HBITMAP CopyBmp(
    HBITMAP hbmpOrg,
    int     cxNew,
    int     cyNew,
    UINT    LR_flags)
{
    HBITMAP hbmNew = NULL;
    LPBITMAPINFOHEADER pdib;

    RtlEnterCriticalSection(&gcsHdc);

    if (pdib = DIBFromBitmap(hbmpOrg, ghdcBits2)) {

#if 0  // Win-9x comments this code out
        if (LR_flags & LR_COPYRETURNORG) {

            DWORD bpp = GetIcoCurBpp(LR_flags);

            if ((cxNew == 0 || cxNew == pdib->biWidth)  &&
                (cyNew == 0 || cyNew == pdib->biHeight) &&
                (bpp == 0 || bpp == pdib->biBitCount)) {

                hbmNew = hbmpOrg;
            }
        }

        if (hbmNew == NULL)
            hbmNew = ConvertDIBBitmap(pdib, cxNew, cyNew, LR_flags, NULL, NULL);
#endif

        hbmNew = ConvertDIBBitmap(pdib, cxNew, cyNew, LR_flags, NULL, NULL);

        UserLocalFree(pdib);
    }

    RtlLeaveCriticalSection(&gcsHdc);

    if ((LR_flags & LR_COPYDELETEORG) && hbmNew && (hbmNew != hbmpOrg))
        DeleteObject(hbmpOrg);

    return hbmNew;
}

/***********************************************************************\
* CopyImageFromRes
*
* This is used by the LR_COPYFROMRESOURCE option.  We assume that the
* icon/cursor passed in is among the process list of loaded shared
* icons.  If we find it there, we can attempt to load the icon from
* the resource to get an image that looks better than a stretched or
* compressed one.
*
* That way we will not stretch a 32x32 icon to 16x16 if someone added
* a 16x16 image to their class icon--a simple way for apps to jazz up
* their appearance.
*
* 12-Mar-1996 ChrisWil  Created.
\***********************************************************************/

HICON CopyImageFromRes(
    LPWSTR      pszModName,
    LPWSTR      pszResName,
    PCURSORFIND pcfSearch,
    UINT        LR_flags)
{
    HINSTANCE hmod;
    HICON     hicoDst = NULL;

    /*
     * Override the search-criteria if this is the user-module.  By
     * setting these to zero, we are basically saying "don't care" for
     * these attributes.
     */
    hmod = (pszModName ? WowGetModuleHandle(pszModName) : hmodUser);

    if (hmod == hmodUser) {

        pcfSearch->cx  = 0;
        pcfSearch->cy  = 0;
        pcfSearch->bpp = 0;

        pszModName = szUSER32;
    }

    /*
     * If a resource has been found with this name/bpp, then attempt
     * to load the resource with the desired dimensions.
     */
    if (FindExistingCursorIcon(pszModName, pszResName, pcfSearch)) {

        hicoDst = LoadIcoCur(hmod,
                             pszResName,
                             (LPWSTR)ULongToPtr( pcfSearch->rt ),
                             pcfSearch->cx,
                             pcfSearch->cy,
                             LR_flags);
    }

    return hicoDst;
}

/***********************************************************************\
*  CopyIcoCur()
*
*  Allocates a new icon resource and transmogrifies the old icon into the
*  newly desired format.
*
*  Note that if we have to stretch the icon, the hotspot area changes.  For
*  icons, the hotspot is set to be the middle of the icon.
*
* Returns:
*
* 01-Nov-1995 SanfordS  Created.
* 12-Mar-1996 ChrisWil  Added lookup for existing icon/cursor.
\***********************************************************************/

HICON CopyIcoCur(
    HICON hicoSrc,
    BOOL  fIcon,
    int   cxNew,
    int   cyNew,
    UINT  LR_flags)
{
    HBITMAP        hbmMaskNew;
    HBITMAP        hbmColorNew;
    int            cx;
    int            cy;
    DWORD          bpp;
    DWORD          bppDesired;
    HICON          hicoDst = NULL;
    ICONINFO       ii;
    CURSORDATA     cur;
    UNICODE_STRING strModName;
    UNICODE_STRING strResName;
    WCHAR          awszModName[MAX_PATH];
    WCHAR          awszResName[MAX_PATH];

    /*
     * Extract needed info from existing icon/cursor from the kernel
     */
    if (!NtUserGetIconSize(hicoSrc, 0, &cx, &cy))
        return NULL;

    cy >>= 1;

    if (LR_flags & LR_CREATEDIBSECTION)
        LR_flags = (LR_flags & ~LR_CREATEDIBSECTION) | LR_CREATEREALDIB;

    /*
     * Setup unicode-strings for calls to kernel-side.
     */
    strModName.Length        = 0;
    strModName.MaximumLength = MAX_PATH;
    strModName.Buffer        = awszModName;

    strResName.Length        = 0;
    strResName.MaximumLength = MAX_PATH;
    strResName.Buffer        = awszResName;

    /*
     * Note: this creates copies of hbmMask and hbmColor that need to be
     * freed before we leave.
     */
    if (!NtUserGetIconInfo(hicoSrc,
                           &ii,
                           &strModName,
                           &strResName,
                           &bpp,
                           TRUE)) {

        return NULL;
    }

    cxNew = GetIcoCurWidth(cxNew, fIcon, LR_flags, cx);
    cyNew = GetIcoCurHeight(cyNew, fIcon, LR_flags, cy);

    if (LR_flags & LR_COPYFROMRESOURCE) {

        CURSORFIND cfSearch;
        LPWSTR     pszModName;

        /*
         * Setup the search criteria.
         */
        cfSearch.hcur = hicoSrc;
        cfSearch.rt   = PtrToUlong((fIcon ? RT_ICON : RT_CURSOR));
        cfSearch.cx   = cxNew;
        cfSearch.cy   = cyNew;
        cfSearch.bpp  = bpp;

        /*
         * Copy the image.  This performs a lookup for the hicoSrc.  If
         * it is not found in the process and shared caches, then we
         * will proceed with copying the hicoSrc.  If an icon is found
         * in the cache, then we will attempt to reload the image for
         * the best resolution possible.
         */
        pszModName = (strModName.Length ? strModName.Buffer : NULL);

        hicoDst = CopyImageFromRes(pszModName,
                                   strResName.Buffer,
                                   &cfSearch,
                                   LR_flags);

        if (hicoDst)
            goto CleanupExit;
    }

    bppDesired = GetIcoCurBpp(LR_flags);

    if ((cxNew != cx) ||
        (cyNew != cy) ||
        ((bpp != 1) && (bppDesired != 0) && (bppDesired != bpp))) {

        /*
         * Since we have to stretch or maybe fixup the colors just get
         * the DIB bits and let ConverDIBBitmap do all the magic.
         */
        hbmMaskNew = CopyBmp(ii.hbmMask, cxNew, cyNew * 2, LR_MONOCHROME);

        if (hbmMaskNew == NULL)
            goto CleanupExit;

        hbmColorNew = NULL;

        if (ii.hbmColor) {

            hbmColorNew = CopyBmp(ii.hbmColor, cxNew, cyNew, LR_flags);

            if (hbmColorNew == NULL) {
                DeleteObject(hbmMaskNew);
                goto CleanupExit;
            }
        }

        /*
         * Replace ii.hbmxxx guys with our fixed up copies and delete the old.
         */
        DeleteObject(ii.hbmMask);
        ii.hbmMask = hbmMaskNew;

        if (ii.hbmColor && (ii.hbmColor != hbmColorNew)) {
            DeleteObject(ii.hbmColor);
            ii.hbmColor = hbmColorNew;
        }

        /*
         * tweak the hotspots for changes in size.
         */
        if (cxNew != cx)
            ii.xHotspot = MultDiv(ii.xHotspot, cxNew, cx);

        if (cyNew != cy)
            ii.yHotspot = MultDiv(ii.yHotspot, cyNew, cy);

    } else if (LR_flags & LR_COPYRETURNORG) {

        hicoDst = hicoSrc;

CleanupExit:

        /*
         * Free up the bitmaps which were created by GetIconInfo().
         */
        DeleteObject(ii.hbmMask);

        if (ii.hbmColor)
            DeleteObject(ii.hbmColor);

        goto Exit;
    }

    /*
     * Build the icon/cursor object from the info.  The bitmaps
     * are not freed in this case.
     */
    hicoDst = (HICON)NtUserCallOneParam(0, SFI__CREATEEMPTYCURSOROBJECT);

    if (hicoDst == NULL)
        goto CleanupExit;

    RtlZeroMemory(&cur, sizeof(cur));
    cur.lpName    = strResName.Length ? strResName.Buffer : NULL;
    cur.lpModName = strModName.Length ? strModName.Buffer : NULL;
    cur.rt        = ii.fIcon ? PTR_TO_ID(RT_ICON) : PTR_TO_ID(RT_CURSOR);
    cur.bpp       = bpp;
    cur.cx        = cxNew;
    cur.cy        = cyNew * 2;
    cur.xHotspot  = (short)ii.xHotspot;
    cur.yHotspot  = (short)ii.yHotspot;
    cur.hbmMask   = ii.hbmMask;
    cur.hbmColor  = ii.hbmColor;

    if (!_SetCursorIconData(hicoDst, &cur)) {
        NtUserDestroyCursor(hicoDst, CURSOR_ALWAYSDESTROY);
        return NULL;
    }

Exit:

    /*
     * destroy the original if asked to.
     */
    if (hicoDst != hicoSrc && (LR_flags & LR_COPYDELETEORG))
        DestroyCursor(hicoSrc);

    return hicoDst;
}

/***********************************************************************\
* CopyImage
*
* Allocates a new icon resource and copies the attributes of the old icon
* to the new icon.
*
* Returns: hIconNew
*
* 01-Nov-1995 SanfordS  Created.
\***********************************************************************/


FUNCLOG5(LOG_GENERAL, HANDLE, WINAPI, CopyImage, HANDLE, hImage, UINT, IMAGE_flag, int, cxNew, int, cyNew, UINT, LR_flags)
HANDLE WINAPI CopyImage(
    HANDLE hImage,
    UINT   IMAGE_flag,
    int    cxNew,
    int    cyNew,
    UINT   LR_flags)
{
    if (LR_flags & ~LR_VALID) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "CopyImage: bad LR_flags.");
        return NULL;
    }

    return InternalCopyImage(hImage, IMAGE_flag, cxNew, cyNew, LR_flags);
}

/***********************************************************************\
* InternalCopyImage
*
* Performs the copyimage work.  This is called from the callback-thunk.
*
\***********************************************************************/

HANDLE InternalCopyImage(
    HANDLE hImage,
    UINT   IMAGE_flag,
    int    cxNew,
    int    cyNew,
    UINT   LR_flags)
{
    switch (IMAGE_flag) {

    case IMAGE_BITMAP:
        if (GetObjectType(hImage) != OBJ_BITMAP) {
            RIPMSG0(RIP_ERROR, "CopyImage: invalid bitmap");
            return NULL;
        }

        return (HICON)CopyBmp(hImage, cxNew, cyNew, LR_flags);

    case IMAGE_CURSOR:
    case IMAGE_ICON:

        return CopyIcoCur(hImage,
                          (IMAGE_flag == IMAGE_ICON),
                          cxNew,
                          cyNew,
                          LR_flags);
    }

    RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "CopyImage: bad IMAGE_flag.");

    return NULL;
}

/***************************************************************************\
* RtlGetIdFromDirectory
*
* History:
* 06-Apr-1991 ScottLu   Cleaned up, make work with client/server.
* 16-Nov-1995 SanfordS  Now uses LookupIconIdFromDirectoryEx
\***************************************************************************/

int RtlGetIdFromDirectory(
    PBYTE  presbits,
    BOOL   fIcon,
    int    cxDesired,
    int    cyDesired,
    DWORD  LR_flags,
    PDWORD pdwResSize)
{
    LPNEWHEADER lpnh;
    LPRESDIR    lprsd;
    UINT        iImage;
    UINT        cImage;
    UINT        bpp;

    /*
     * Make sure this is pointing to valid resource bits.
     */
    if (presbits == NULL)
        return 0;

    lpnh = (LPNEWHEADER)presbits;

    /*
     * Fill in defaults.
     */
    cxDesired = GetIcoCurWidth(cxDesired, fIcon, LR_flags, 0);
    cyDesired = GetIcoCurHeight(cyDesired, fIcon, LR_flags, 0);

    bpp = GetIcoCurBpp(LR_flags);

    /*
     * We'll use the first image in the directory if we can't find one
     * that's appropriate.
     */
    cImage = lpnh->ResCount;
    lprsd  = (LPRESDIR)(lpnh + 1);

    iImage = GetBestImage(lprsd, cImage, cxDesired, cyDesired, bpp, fIcon);

    if (iImage == cImage)
        iImage = 0;

    if (pdwResSize != NULL)
        *pdwResSize = (lprsd + iImage)->BytesInRes;

    return ((LPRESDIR)(lprsd + iImage))->idIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\clmenu.c ===
/****************************** Module Header ******************************\
*
* Module Name: clmenu.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Loading Routines
*
* History:
* 24-Sep-1990 mikeke        From win30
* 29-Nov-1994 JimA          Moved from server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* MenuLoadWinTemplates
*
* Recursive routine that loads in the new style menu template and
* builds the menu. Assumes that the menu template header has already been
* read in and processed elsewhere...
*
* History:
* 28-Sep-1990 mikeke     from win30
\***************************************************************************/

LPBYTE MenuLoadWinTemplates(
    LPBYTE lpMenuTemplate,
    HMENU *phMenu)
{
    HMENU hMenu;
    UINT menuFlags = 0;
    ULONG_PTR menuId = 0;
    LPWSTR lpmenuText;
    MENUITEMINFO    mii;
    UNICODE_STRING str;

    if (!(hMenu = NtUserCreateMenu()))
        goto memoryerror;

    do {

        /*
         * Get the menu flags.
         */
        menuFlags = (UINT)(*(WORD *)lpMenuTemplate);
        lpMenuTemplate += 2;

        if (menuFlags & ~MF_VALID) {
            RIPERR1(ERROR_INVALID_DATA, RIP_WARNING, "Menu Flags %lX are invalid", menuFlags);
            goto memoryerror;
        }


        if (!(menuFlags & MF_POPUP)) {
            menuId = *(WORD *)lpMenuTemplate;
            lpMenuTemplate += 2;
        }

        lpmenuText = (LPWSTR)lpMenuTemplate;

        if (*lpmenuText) {
            /*
             * Some Win3.1 and Win95 16 bit apps (chessmaster, mavis typing) know that
             * dwItemData for MFT_OWNERDRAW items is a pointer to a string in the resource data.
             * So WOW has given us the proper pointer from the 16 bit resource.
             *
             * Sundown Note:
             * __unaligned unsigned long value pointed by lpMenuTemplate is zero-extended to
             * update lpmenuText. WOW restrictions.
             */
            if ((menuFlags & MFT_OWNERDRAW)
                    && (GetClientInfo()->dwTIFlags & TIF_16BIT)) {
                lpmenuText = (LPWSTR)ULongToPtr( (*(DWORD UNALIGNED *)lpMenuTemplate) );
                /*
                 * We'll skip one WCHAR later; so skip only the difference now.
                 */
                lpMenuTemplate += sizeof(DWORD) - sizeof(WCHAR);
            } else {
                /*
                 * If a string exists, then skip to the end of it.
                 */
                RtlInitUnicodeString(&str, lpmenuText);
                lpMenuTemplate = lpMenuTemplate + str.Length;
            }

        } else {
            lpmenuText = NULL;
        }

        /*
         * Skip over terminating NULL of the string (or the single NULL
         * if empty string).
         */
        lpMenuTemplate += sizeof(WCHAR);
        lpMenuTemplate = NextWordBoundary(lpMenuTemplate);

        RtlZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_STATE | MIIM_FTYPE;
        if (lpmenuText) {
            mii.fMask |= MIIM_STRING;
        }

        if (menuFlags & MF_POPUP) {
            mii.fMask |= MIIM_SUBMENU;
            lpMenuTemplate = MenuLoadWinTemplates(lpMenuTemplate,
                    (HMENU *)&menuId);
            if (!lpMenuTemplate)
                goto memoryerror;

            mii.hSubMenu = (HMENU)menuId;
        }

        /*
         * We have to take out MF_HILITE since that bit marks the end of a
         * menu in a resource file.  Since we shouldn't have any pre hilited
         * items in the menu anyway, this is no big deal.
         */
        if (menuFlags & MF_BITMAP) {

            /*
             * Don't allow bitmaps from the resource file.
             */
            menuFlags = (UINT)((menuFlags | MFT_RIGHTJUSTIFY) & ~MF_BITMAP);
        }

        // We have to take out MFS_HILITE since that bit marks the end of a menu in
        // a resource file.  Since we shouldn't have any pre hilited items in the
        // menu anyway, this is no big deal.
        mii.fState = (menuFlags & MFS_OLDAPI_MASK) & ~MFS_HILITE;
        mii.fType = (menuFlags & MFT_OLDAPI_MASK);
        if (menuFlags & MFT_OWNERDRAW)
        {
            mii.fMask |= MIIM_DATA;
            mii.dwItemData = (ULONG_PTR) lpmenuText;
            lpmenuText = 0;
        }
        mii.dwTypeData = (LPWSTR) lpmenuText;
        mii.cch = (UINT)-1;
        mii.wID = (UINT)menuId;

        if (!NtUserThunkedMenuItemInfo(hMenu, MFMWFP_NOITEM, TRUE, TRUE,
                    &mii, lpmenuText ? &str : NULL)) {
            if (menuFlags & MF_POPUP)
                NtUserDestroyMenu(mii.hSubMenu);
            goto memoryerror;
        }

    } while (!(menuFlags & MF_END));

    *phMenu = hMenu;
    return lpMenuTemplate;

memoryerror:
    if (hMenu != NULL)
        NtUserDestroyMenu(hMenu);
    *phMenu = NULL;
    return NULL;
}


/***************************************************************************\
* MenuLoadChicagoTemplates
*
* Recursive routine that loads in the new new style menu template and
* builds the menu. Assumes that the menu template header has already been
* read in and processed elsewhere...
*
* History:
* 15-Dec-93 SanfordS    Created
\***************************************************************************/

PMENUITEMTEMPLATE2 MenuLoadChicagoTemplates(
    PMENUITEMTEMPLATE2 lpMenuTemplate,
    HMENU *phMenu,
    WORD wResInfo,
    UINT mftRtl)
{
    HMENU hMenu;
    HMENU hSubMenu;
    long menuId = 0;
    LPWSTR lpmenuText;
    MENUITEMINFO    mii;
    UNICODE_STRING str;
    DWORD           dwHelpID;

    if (!(hMenu = NtUserCreateMenu()))
        goto memoryerror;

    do {
        if (!(wResInfo & MFR_POPUP)) {
            /*
             * If the PREVIOUS wResInfo field was not a POPUP, the
             * dwHelpID field is not there.  Back up so things fit.
             */
            lpMenuTemplate = (PMENUITEMTEMPLATE2)(((LPBYTE)lpMenuTemplate) -
                    sizeof(lpMenuTemplate->dwHelpID));
            dwHelpID = 0;
        } else
            dwHelpID = lpMenuTemplate->dwHelpID;

        menuId = lpMenuTemplate->menuId;

        RtlZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_STATE | MIIM_FTYPE ;

        mii.fType = lpMenuTemplate->fType | mftRtl;
        if (mii.fType & ~MFT_MASK) {
            RIPERR1(ERROR_INVALID_DATA, RIP_WARNING, "Menu Type flags %lX are invalid", mii.fType);
            goto memoryerror;
        }

        mii.fState  = lpMenuTemplate->fState;
        if (mii.fState & ~MFS_MASK) {
            RIPERR1(ERROR_INVALID_DATA, RIP_WARNING, "Menu State flags %lX are invalid", mii.fState);
            goto memoryerror;
        }

        wResInfo = lpMenuTemplate->wResInfo;
        if (wResInfo & ~(MF_END | MFR_POPUP)) {
            RIPERR1(ERROR_INVALID_DATA, RIP_WARNING, "Menu ResInfo flags %lX are invalid", wResInfo);
            goto memoryerror;
        }

        if (dwHelpID) {
            NtUserSetMenuContextHelpId(hMenu,dwHelpID);
        }
        if (lpMenuTemplate->mtString[0]) {
            lpmenuText = lpMenuTemplate->mtString;
            mii.fMask |= MIIM_STRING;
        } else {
            lpmenuText = NULL;
        }
        RtlInitUnicodeString(&str, lpmenuText);

        mii.dwTypeData = (LPWSTR) lpmenuText;

        /*
         * skip to next menu item template (DWORD boundary)
         */
        lpMenuTemplate = (PMENUITEMTEMPLATE2)
                (((LPBYTE)lpMenuTemplate) +
                sizeof(MENUITEMTEMPLATE2) +
                ((str.Length + 3) & ~3));

        if (mii.fType & MFT_OWNERDRAW)
        {
            mii.fMask |= MIIM_DATA;
            mii.dwItemData = (ULONG_PTR) mii.dwTypeData;
            mii.dwTypeData = 0;
        }

        /*
         * If MFT_RIGHTORDER is specified then all subsequent
         * menus are right-to-left as well.
         */
        if (mii.fType & MFT_RIGHTORDER)
        {
            mftRtl = MFT_RIGHTORDER;
            NtUserSetMenuFlagRtoL(hMenu);
        }

        if (wResInfo & MFR_POPUP) {
            mii.fMask |= MIIM_SUBMENU;
            lpMenuTemplate = MenuLoadChicagoTemplates(lpMenuTemplate,
                    &hSubMenu, MFR_POPUP, mftRtl);
            if (lpMenuTemplate == NULL)
                goto memoryerror;
            mii.hSubMenu = hSubMenu;
        }

        if (mii.fType & MFT_BITMAP) {

            /*
             * Don't allow bitmaps from the resource file.
             */
            mii.fType = (mii.fType | MFT_RIGHTJUSTIFY) & ~MFT_BITMAP;
        }

        mii.cch = (UINT)-1;
        mii.wID = menuId;
        if (!NtUserThunkedMenuItemInfo(hMenu, MFMWFP_NOITEM, TRUE, TRUE,
                    &mii, &str)) {
            if (wResInfo & MFR_POPUP)
                NtUserDestroyMenu(mii.hSubMenu);
            goto memoryerror;
        }
        wResInfo &= ~MFR_POPUP;
    } while (!(wResInfo & MFR_END));

    *phMenu = hMenu;
    return lpMenuTemplate;

memoryerror:
    if (hMenu != NULL)
        NtUserDestroyMenu(hMenu);
    *phMenu = NULL;
    return NULL;
}


/***************************************************************************\
* CreateMenuFromResource
*
* Loads the menu resource named by the lpMenuTemplate parameter. The
* template specified by lpMenuTemplate is a collection of one or more
* MENUITEMTEMPLATE structures, each of which may contain one or more items
* and popup menus. If successful, returns a handle to the menu otherwise
* returns NULL.
*
* History:
* 28-Sep-1990 mikeke     from win30
\***************************************************************************/

HMENU CreateMenuFromResource(
    LPBYTE lpMenuTemplate)
{
    HMENU hMenu = NULL;
    UINT menuTemplateVersion;
    UINT menuTemplateHeaderSize;

    /*
     * Win3 menu resource: First, strip version number word out of the menu
     * template.  This value should be 0 for Win3, 1 for win4.
     */
    menuTemplateVersion = *((WORD *)lpMenuTemplate)++;
    if (menuTemplateVersion > 1) {
        RIPMSG0(RIP_WARNING, "Menu Version number > 1");
        return NULL;
    }
    menuTemplateHeaderSize = *((WORD *)lpMenuTemplate)++;
    lpMenuTemplate += menuTemplateHeaderSize;
    switch (menuTemplateVersion) {
    case 0:
        MenuLoadWinTemplates(lpMenuTemplate, &hMenu);
        break;

    case 1:
        MenuLoadChicagoTemplates((PMENUITEMTEMPLATE2)lpMenuTemplate, &hMenu, 0, 0);
        break;
    }
    return hMenu;
}

/***************************************************************************\
* SetMenu (API)
*
* Sets the menu for the hwnd.
*
* History:
* 10-Mar-1996 ChrisWil  Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetMenu, HWND, hwnd, HMENU, hmenu)
BOOL SetMenu(
    HWND  hwnd,
    HMENU hmenu)
{
    return NtUserSetMenu(hwnd, hmenu, TRUE);
}

/***************************************************************************\
* LoadMenu (API)
*
* Loads the menu resource named by lpMenuName from the executable
* file associated by the module specified by the hInstance parameter. The
* menu is loaded only if it hasn't been previously loaded. Otherwise it
* retrieves a handle to the loaded resource. Returns NULL if unsuccessful.
*
* History:
* 04-05-91 ScottLu Fixed to work with client/server.
* 28-Sep-1990 mikeke from win30
\***************************************************************************/

HMENU CommonLoadMenu(
    HINSTANCE hmod,
    HANDLE hResInfo
    )
{
    HANDLE h;
    PVOID p;
    HMENU hMenu = NULL;

    if (h = LOADRESOURCE(hmod, hResInfo)) {

        if (p = LOCKRESOURCE(h, hmod)) {

            hMenu = CreateMenuFromResource(p);

            UNLOCKRESOURCE(h, hmod);
        }
        /*
         * Win95 and Win3.1 do not free this resource; some 16 bit apps (chessmaster
         * and mavis typing) require this for their ownerdraw menu stuff.
         * For 32 bit apps, FreeResource is a nop anyway. For 16 bit apps,
         * Wow frees the 32 bit resource (returned by LockResource16)
         * in UnlockResource16; the actual 16 bit resource is freed when the task
         * goes away.
         *
         *   FREERESOURCE(h, hmod);
         */
    }

    return (hMenu);
}


FUNCLOG2(LOG_GENERAL, HMENU, WINAPI, LoadMenuA, HINSTANCE, hmod, LPCSTR, lpName)
HMENU WINAPI LoadMenuA(
    HINSTANCE hmod,
    LPCSTR lpName)
{
    HANDLE hRes;

    if (hRes = FINDRESOURCEA(hmod, (LPSTR)lpName, (LPSTR)RT_MENU))
        return CommonLoadMenu(hmod, hRes);
    else
        return NULL;
}


FUNCLOG2(LOG_GENERAL, HMENU, WINAPI, LoadMenuW, HINSTANCE, hmod, LPCWSTR, lpName)
HMENU WINAPI LoadMenuW(
    HINSTANCE hmod,
    LPCWSTR lpName)
{
    HANDLE hRes;

    if (hRes = FINDRESOURCEW(hmod, (LPWSTR)lpName, RT_MENU))
        return CommonLoadMenu(hmod, hRes);
    else
        return NULL;
}
/***************************************************************************\
* InternalInsertMenuItem
*
* History:
*  09/20/96 GerardoB - Created
\***************************************************************************/
BOOL InternalInsertMenuItem (HMENU hMenu, UINT uID, BOOL fByPosition, LPCMENUITEMINFO lpmii)
{
 return ThunkedMenuItemInfo(hMenu, uID, fByPosition, TRUE, (LPMENUITEMINFOW)lpmii, FALSE);
}

/***************************************************************************\
* ValidateMENUITEMINFO() -
*   it converts and validates a MENUITEMINFO95 or a new-MENUITEMINFO-with-old-flags
*     to a new MENUITEMINFO -- this way all internal code can assume one look for the
*   structure
*
* History:
*  12-08-95 Ported from Nashville - jjk
*  07-19-96 GerardoB - Fixed up for 5.0
\***************************************************************************/
BOOL ValidateMENUITEMINFO(LPMENUITEMINFO lpmiiIn, LPMENUITEMINFO lpmii, DWORD dwAPICode)
{

    VALIDATIONFNNAME(ValidateMENUITEMINFO)
    BOOL fOldApp;

    if (lpmiiIn == NULL) {
        VALIDATIONFAIL(lpmiiIn);
    }

    /*
     * In order to map the old flags to the new ones, we might have to modify
     *  the lpmiiIn structure. So we make a copy to avoid breaking anyone.
     */
    fOldApp = (lpmiiIn->cbSize == SIZEOFMENUITEMINFO95);
    UserAssert(SIZEOFMENUITEMINFO95 < sizeof(MENUITEMINFO));
    RtlCopyMemory(lpmii, lpmiiIn, SIZEOFMENUITEMINFO95);
    if (fOldApp) {
        lpmii->cbSize = sizeof(MENUITEMINFO);
        lpmii->hbmpItem = NULL;
    } else if (lpmiiIn->cbSize == sizeof(MENUITEMINFO)) {
        lpmii->hbmpItem = lpmiiIn->hbmpItem;
    } else {
        VALIDATIONFAIL(lpmiiIn->cbSize);
    }


    if (lpmii->fMask & ~MIIM_MASK) {
        VALIDATIONFAIL(lpmii->fMask);
    } else if ((lpmii->fMask & MIIM_TYPE)
            && (lpmii->fMask & (MIIM_FTYPE | MIIM_STRING | MIIM_BITMAP))) {
        /*
         * Don't let them mix new and old flags
         */
        VALIDATIONFAIL(lpmii->fMask);
    }

    /*
     * No more validation needed for Get calls
     */
    if (dwAPICode == MENUAPI_GET) {
        /*
         * Map MIIM_TYPE for old apps doing a Get.
         * Keep the MIIM_TYPE flag so we'll know this guy passed the old flags.
         * GetMenuItemInfo uses lpmii->hbmpItem to determine if a bitmap
         *  was returned. So we NULL it out here. The caller is using the
         *  old flags so he shouldn't care about it.
         */
        if (lpmii->fMask & MIIM_TYPE) {
            lpmii->fMask |= MIIM_FTYPE | MIIM_BITMAP | MIIM_STRING;
            lpmii->hbmpItem = NULL;
        }
        return TRUE;
    }

    /*
     * Map MIIM_TYPE to MIIM_FTYPE
     */
    if (lpmii->fMask & MIIM_TYPE) {
        lpmii->fMask |= MIIM_FTYPE;
    }

    if (lpmii->fMask & MIIM_FTYPE) {
        if (lpmii->fType & ~MFT_MASK) {
            VALIDATIONFAIL(lpmii->fType);
        }
        /*
         * If using MIIM_TYPE, Map MFT_BITMAP to MIIM_BITMAP
         *  and MFT_NONSTRING to MIIM_STRING.
         * Old applications couldn't use string and bitmap simultaneously
         *  so setting one implies clearing the other.
         */
        if (lpmii->fMask & MIIM_TYPE) {
            if (lpmii->fType & MFT_BITMAP) {
                /*
                 * Don't display a warning. A lot of shell menus hit this
                 * if (!fOldApp) {
                 *     VALIDATIONOBSOLETE(MFT_BITMAP, MIIM_BITMAP);
                 *  }
                 */
                lpmii->fMask |= MIIM_BITMAP | MIIM_STRING;
                lpmii->hbmpItem = (HBITMAP)lpmii->dwTypeData;
                lpmii->dwTypeData = 0;
            } else if (!(lpmii->fType & MFT_NONSTRING)) {
                /*
                 * Don't display a warning. A lot of shell menus hit this
                 * if (!fOldApp) {
                 *     VALIDATIONOBSOLETE(MFT_STRING, MIIM_STRING);
                 *  }
                 */
                lpmii->fMask |= MIIM_BITMAP | MIIM_STRING;
                lpmii->hbmpItem = NULL;
            }
        } else if (lpmii->fType & MFT_BITMAP) {
            /*
             * Don't let them mix new and old flags
             */
            VALIDATIONFAIL(lpmii->fType);
        }
    }

    if ((lpmii->fMask & MIIM_STATE) && (lpmii->fState & ~MFS_MASK)){
        VALIDATIONFAIL(lpmii->fState);
    }

    if (lpmii->fMask & MIIM_CHECKMARKS) {
        if ((lpmii->hbmpChecked != NULL) && !GdiValidateHandle((HBITMAP)lpmii->hbmpChecked)) {
            VALIDATIONFAIL(lpmii->hbmpChecked);
        }
        if ((lpmii->hbmpUnchecked != NULL) && !GdiValidateHandle((HBITMAP)lpmii->hbmpUnchecked)) {
            VALIDATIONFAIL(lpmii->hbmpUnchecked);
        }
    }

    if (lpmii->fMask & MIIM_SUBMENU) {
        if ((lpmii->hSubMenu != NULL) && !VALIDATEHMENU(lpmii->hSubMenu)) {
            VALIDATIONFAIL(lpmii->hSubMenu);
        }
    }

    /*
     * Warning: NULL lpmii->hbmpItem accepted as valid (or the explorer breaks)
     */
    if (lpmii->fMask & MIIM_BITMAP) {
        if ((lpmii->hbmpItem != HBMMENU_CALLBACK)
                && (lpmii->hbmpItem >= HBMMENU_MAX)
                && !GdiValidateHandle(lpmii->hbmpItem)) {

            /*
             * Compatibility hack
             */
            if (((HBITMAP)LOWORD(HandleToUlong(lpmii->hbmpItem)) >= HBMMENU_MAX) || !IS_PTR(lpmii->hbmpItem)) {
                VALIDATIONFAIL(lpmii->hbmpItem);
            }
        }
    }

    /*
     * Warning: No dwTypeData / cch validation
     */

    return TRUE;

    VALIDATIONERROR(FALSE);
}

/***************************************************************************\
* ValidateMENUINFO() -
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/

BOOL ValidateMENUINFO(LPCMENUINFO lpmi, DWORD dwAPICode)
{
    VALIDATIONFNNAME(ValidateMENUINFO)

    if (lpmi == NULL) {
        VALIDATIONFAIL(lpmi);
    }

    if (lpmi->cbSize != sizeof(MENUINFO)) {
        VALIDATIONFAIL(lpmi->cbSize);
    }

    if (lpmi->fMask & ~MIM_MASK) {
        VALIDATIONFAIL(lpmi->fMask);
    }

    /*
     * No more validation needed for Get calls
     */
    if (dwAPICode == MENUAPI_GET){
        return TRUE;
    }

    if ((lpmi->fMask & MIM_STYLE) && (lpmi->dwStyle & ~MNS_VALID)) {
        VALIDATIONFAIL(lpmi->dwStyle);
    }

    if (lpmi->fMask & MIM_BACKGROUND) {
        if ((lpmi->hbrBack != NULL)
                && !GdiValidateHandle((HBRUSH)lpmi->hbrBack)) {

            VALIDATIONFAIL(lpmi->hbrBack);
        }
    }

    return TRUE;

    VALIDATIONERROR(FALSE);
}
/***************************************************************************\
* GetMenuInfo
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetMenuInfo, HMENU, hMenu, LPMENUINFO, lpmi)
BOOL GetMenuInfo(HMENU hMenu, LPMENUINFO lpmi)
{
    PMENU pMenu;

    if (!ValidateMENUINFO(lpmi, MENUAPI_GET)) {
        return FALSE;
    }

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return FALSE;
    }

    if (lpmi->fMask & MIM_STYLE) {
        lpmi->dwStyle = pMenu->fFlags & MNS_VALID;
    }

    if (lpmi->fMask & MIM_MAXHEIGHT) {
        lpmi->cyMax = pMenu->cyMax;
    }

    if (lpmi->fMask & MIM_BACKGROUND) {
        lpmi->hbrBack = KHBRUSH_TO_HBRUSH(pMenu->hbrBack);
    }

    if (lpmi->fMask & MIM_HELPID) {
        lpmi->dwContextHelpID = pMenu->dwContextHelpId;
    }

    if (lpmi->fMask & MIM_MENUDATA) {
        lpmi->dwMenuData = KERNEL_ULONG_PTR_TO_ULONG_PTR(pMenu->dwMenuData);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\combodir.c ===
/**************************** Module Header ********************************\
* Module Name: combodir.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Directory Combo Box Routines
*
* History:
* ??-???-???? ??????    Ported from Win 3.0 sources
* 01-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#define CTLMGR
#define LSTRING

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxCBDir
*
* Supports the CB_DIR message which adds a list of files from the
* current directory to the combo box.
*
* History:
\***************************************************************************/

int xxxCBDir(
    PCBOX pcbox,
    UINT attrib,
    LPWSTR pFileName)
{
    PLBIV plb;
    int errorValue;
    TL tlpwnd;

    CheckLock(pcbox->spwnd);
    UserAssert(pcbox->spwndList);

    plb = ((PLBWND)pcbox->spwndList)->pLBIV;

    ThreadLock(plb->spwnd, &tlpwnd);
    errorValue = xxxLbDir(plb, attrib, pFileName);
    ThreadUnlock(&tlpwnd);

    switch (errorValue) {
    case LB_ERR:
        return CB_ERR;
        break;
    case LB_ERRSPACE:
        return CB_ERRSPACE;
        break;
    default:
        return errorValue;
        break;
    }
}

/***************************************************************************\
* DlgDirSelectComboBoxEx
*
* Retrieves the current selection from the listbox of a combobox.
* It assumes that the combo box was filled by xxxDlgDirListComboBox()
* and that the selection is a drive letter, a file, or a directory name.
*
* History:
* 12-05-90 IanJa    converted to internal version
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, int, DUMMYCALLINGTYPE, DlgDirSelectComboBoxExA, HWND, hwndDlg, LPSTR, pszOut, int, cchOut, int, idComboBox)
int DlgDirSelectComboBoxExA(
    HWND hwndDlg,
    LPSTR pszOut,
    int cchOut,
    int idComboBox)
{
    LPWSTR lpwsz;
    BOOL fRet;

    lpwsz = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchOut * sizeof(WCHAR));
    if (!lpwsz) {
        return FALSE;
    }

    fRet = DlgDirSelectComboBoxExW(hwndDlg, lpwsz, cchOut, idComboBox);

    WCSToMB(lpwsz, -1, &pszOut, cchOut, FALSE);

    UserLocalFree(lpwsz);

    return fRet;
}


FUNCLOG4(LOG_GENERAL, int, DUMMYCALLINGTYPE, DlgDirSelectComboBoxExW, HWND, hwndDlg, LPWSTR, pwszOut, int, cchOut, int, idComboBox)
int DlgDirSelectComboBoxExW(
    HWND hwndDlg,
    LPWSTR pwszOut,
    int cchOut,
    int idComboBox)
{
    PWND pwndDlg;
    PWND pwndComboBox;
    PCBOX pcbox;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return FALSE;

    pwndComboBox = _GetDlgItem(pwndDlg, idComboBox);
    if (pwndComboBox == NULL) {
        RIPERR0(ERROR_CONTROL_ID_NOT_FOUND, RIP_VERBOSE, "");
        return 0;
    }
    pcbox = ((PCOMBOWND)pwndComboBox)->pcbox;
    if (pcbox == NULL) {
        RIPERR0(ERROR_WINDOW_NOT_COMBOBOX, RIP_VERBOSE, "");
        return 0;
    }

    return DlgDirSelectHelper(pwszOut, cchOut, HWq(pcbox->spwndList));
}


/***************************************************************************\
* xxxDlgDirListComboBox
*
* History:
* 12-05-90 IanJa    converted to internal version
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, DlgDirListComboBoxA, HWND, hwndDlg, LPSTR, lpszPathSpecClient, int, idComboBox, int, idStaticPath, UINT, attrib)
int DlgDirListComboBoxA(
    HWND hwndDlg,
    LPSTR lpszPathSpecClient,
    int idComboBox,
    int idStaticPath,
    UINT attrib)
{
    LPWSTR lpszPathSpec;
    TL tlpwndDlg;
    PWND pwndDlg;
    BOOL fRet;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return FALSE;

    lpszPathSpec = NULL;
    if (lpszPathSpecClient) {
        if (!MBToWCS(lpszPathSpecClient, -1, &lpszPathSpec, -1, TRUE))
            return FALSE;
    }

    ThreadLock(pwndDlg, &tlpwndDlg);
    fRet = xxxDlgDirListHelper(pwndDlg, lpszPathSpec, lpszPathSpecClient,
            idComboBox, idStaticPath, attrib, FALSE);
    ThreadUnlock(&tlpwndDlg);

    if (lpszPathSpec) {
        if (fRet) {
            /*
             * Non-zero retval means some text to copy out.  Copy out up to
             * the nul terminator (buffer will be big enough).
             */
            WCSToMB(lpszPathSpec, -1, &lpszPathSpecClient, MAXLONG, FALSE);
        }
        UserLocalFree(lpszPathSpec);
    }

    return fRet;
}


FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, DlgDirListComboBoxW, HWND, hwndDlg, LPWSTR, lpszPathSpecClient, int, idComboBox, int, idStaticPath, UINT, attrib)
int DlgDirListComboBoxW(
    HWND hwndDlg,
    LPWSTR lpszPathSpecClient,
    int idComboBox,
    int idStaticPath,
    UINT attrib)
{
    LPWSTR lpszPathSpec;
    PWND pwndDlg;
    TL tlpwndDlg;
    BOOL fRet;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return FALSE;

    lpszPathSpec = lpszPathSpecClient;

    ThreadLock(pwndDlg, &tlpwndDlg);
    fRet = xxxDlgDirListHelper(pwndDlg, lpszPathSpec, (LPBYTE)lpszPathSpecClient,
            idComboBox, idStaticPath, attrib, FALSE);
    ThreadUnlock(&tlpwndDlg);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\clinit.c ===
/****************************** Module Header ******************************\
* Module Name: clinit.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the init code for the USER.DLL. When the DLL is
* dynlinked its initialization procedure (UserClientDllInitialize) is called by
* the loader.
*
* History:
* 18-Sep-1990 DarrinM Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "csrhlpr.h"

/*
 * Global variables local to this module (startup).
 */
BOOL         gfFirstThread = TRUE;
PDESKTOPINFO pdiLocal;
BOOL         gbIhaveBeenInited;
static DWORD gdwLpkEntryPoints;

CONST WCHAR pwszWindowsKey[]      = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows";
CONST WCHAR szAppInit[] = L"AppInit_DLLs";

/*
 * External declared routines needed for startup.
 */
BOOL GdiProcessSetup(VOID);
NTSTATUS GdiDllInitialize(IN PVOID hmod, IN DWORD Reason, IN PCONTEXT pctx OPTIONAL);

WCHAR szWindowStationDirectory[MAX_SESSION_PATH];

extern CONST PVOID apfnDispatch[];


/***************************************************************************\
* UserClientDllInitialize
*
* When USER32.DLL is loaded by an EXE (either at EXE load or at LoadModule
* time) this routine is called by the loader. Its purpose is to initialize
* everything that will be needed for future User API calls by the app.
*
* History:
* 19-Sep-1990 DarrinM Created.
\***************************************************************************/
BOOL UserClientDllInitialize(
    IN PVOID    hmod,
    IN DWORD    Reason,
    IN PCONTEXT pctx OPTIONAL)
{
    SYSTEM_BASIC_INFORMATION SystemInformation;
    NTSTATUS Status;

#if DBG
    if (RtlGetNtGlobalFlags() & FLG_SHOW_LDR_SNAPS) {
        RIPMSG1(RIP_WARNING,
                "UserClientDllInitialize: entered for reason %x",
                Reason);
    }
#endif

    if (Reason == DLL_PROCESS_ATTACH) {
        USERCONNECT userconnect;
        ULONG       ulConnect = sizeof(USERCONNECT);
        ULONG       SessionId = NtCurrentPeb()->SessionId;
        WCHAR       szSessionDir[MAX_SESSION_PATH];

        DisableThreadLibraryCalls(hmod);

        if (gbIhaveBeenInited) {
            return TRUE;
        }

        gbIhaveBeenInited = TRUE;

        Status  = RtlInitializeCriticalSection(&gcsClipboard);
        Status |= RtlInitializeCriticalSection(&gcsLookaside);
        Status |= RtlInitializeCriticalSection(&gcsHdc);
        Status |= RtlInitializeCriticalSection(&gcsAccelCache);
        Status |= RtlInitializeCriticalSection(&gcsDDEML);
        Status |= RtlInitializeCriticalSection(&gcsUserApiHook);
#ifdef MESSAGE_PUMP_HOOK
        Status |= RtlInitializeCriticalSection(&gcsMPH);
#endif

        if (!NT_SUCCESS(Status)) {
            FRE_RIPMSG1(RIP_WARNING,
                        "Failed to create critical sections. Status 0x%x",
                        Status);
            return FALSE;
        }
#if DBG
        gpDDEMLHeap = RtlCreateHeap(HEAP_GROWABLE | HEAP_CLASS_1
                              | HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED
                              , NULL, 8 * 1024, 2 * 1024, NULL, NULL);

        if (gpDDEMLHeap == NULL) {
            gpDDEMLHeap = RtlProcessHeap();
        }
#endif

        Status = NtQuerySystemInformation(SystemBasicInformation,
                                          &SystemInformation,
                                          sizeof(SystemInformation),
                                          NULL);
        if (!NT_SUCCESS(Status)) {
            FRE_RIPMSG1(RIP_WARNING,
                        "NtQuerySystemInformation failed with Status 0x%x",
                        Status);
            return FALSE;
        }
        gHighestUserAddress = SystemInformation.MaximumUserModeAddress;

        userconnect.ulVersion = USERCURRENTVERSION;

        if (ISTS()) {

            if (SessionId == 0) {
                wcscpy(szSessionDir, WINSS_OBJECT_DIRECTORY_NAME);
            } else {
                swprintf(szSessionDir, L"%ws\\%ld%ws",
                         SESSION_ROOT,
                         SessionId,
                         WINSS_OBJECT_DIRECTORY_NAME);
            }

            Status = UserConnectToServer(szSessionDir,
                                         &userconnect,
                                         &ulConnect,
                                         (PBOOLEAN)&gfServerProcess);
        } else {
            Status = UserConnectToServer(WINSS_OBJECT_DIRECTORY_NAME,
                                         &userconnect,
                                         &ulConnect,
                                         (PBOOLEAN)&gfServerProcess);
        }

        if (!NT_SUCCESS(Status)) {
            FRE_RIPMSG1(RIP_WARNING,
                        "UserConnectToServer failed with Status 0x%x",
                        Status);
            return FALSE;
        }


        /*
         * If this is the server process, the shared info is not
         * yet valid, so don't copy out the returned info.
         */
        if (!gfServerProcess) {
            HINSTANCE hImm32 = NULL;

            gSharedInfo = userconnect.siClient;
            gpsi = gSharedInfo.psi;

            // make sure the stub (dummy) routine works
            UserAssert(sizeof(LRESULT) == sizeof(ULONG_PTR));
            UserAssert(sizeof(PVOID) == sizeof(ULONG_PTR));
            if (IS_IME_ENABLED()) {
                WCHAR wszImmFile[MAX_PATH];

                InitializeImmEntryTable();
                GetImmFileName(wszImmFile);
                hImm32 = GetModuleHandleW(wszImmFile);
            }
            if (!fpImmRegisterClient(&userconnect.siClient, hImm32)) {
                RIPMSG0(RIP_WARNING,
                        "UserClientDllInitialize: ImmRegisterClient failed");
                return FALSE;
            }
        }

        pfnFindResourceExA = (PFNFINDA)FindResourceExA;
        pfnFindResourceExW = (PFNFINDW)FindResourceExW;
        pfnLoadResource    = (PFNLOAD)LoadResource;
        pfnSizeofResource  = (PFNSIZEOF)SizeofResource;

        /*
         * Register with the base the USER hook it should call when it
         * does a WinExec() (this is soft-linked because some people still
         * use charmode nt!)
         */
        RegisterWaitForInputIdle(WaitForInputIdle);


        /*
         * Remember USER32.DLL's hmodule so we can grab resources from it later.
         */
        hmodUser = hmod;

        pUserHeap = RtlProcessHeap();

        /*
         * Initialize callback table
         */
        NtCurrentPeb()->KernelCallbackTable = apfnDispatch;
        NtCurrentPeb()->PostProcessInitRoutine = NULL;

        if (SessionId != 0) {
            swprintf(szWindowStationDirectory, L"%ws\\%ld%ws", SESSION_ROOT, SessionId, WINSTA_DIR);
            RtlInitUnicodeString(&strRootDirectory, szWindowStationDirectory);
        } else {
            RtlInitUnicodeString(&strRootDirectory, WINSTA_DIR);
        }

#ifdef _JANUS_
        gfEMIEnable = InitInstrument(&gdwEMIControl);
        if (gfServerProcess) {
            gfEMIEnable = FALSE;
        }
#endif
    } else if (Reason == DLL_PROCESS_DETACH) {
        if (ghImm32 != NULL) {
            // IMM32.DLL is loaded by USER32, so free it.
            FreeLibrary(ghImm32);
        }

        /*
         * If we loaded OLE, tell it we're done.
         */
        if (ghinstOLE != NULL) {
            /*
             * Later5.0 GerardoB. This causes check OLE32.DLL to fault
             *  because they get their DLL_PROCESS_DETACH first
             * (*(OLEUNINITIALIZEPROC)gpfnOLEOleUninitialize)();
             */
            RIPMSG0(RIP_WARNING, "OLE would fault if I call OleUninitialize now");
            FreeLibrary(ghinstOLE);
        }

#ifdef _JANUS_
        /*
         * If the user has enabled the Error Instrumentation and we've had to
         * log something (which is indicated by gEventSource being non-NULL),
         * call UnloadLogging to clean up after ourself.
         */
        if (gEventSource != NULL) {
            DeregisterEventSource(gEventSource);
        }
#endif

        RtlDeleteCriticalSection(&gcsClipboard);
        RtlDeleteCriticalSection(&gcsLookaside);
        RtlDeleteCriticalSection(&gcsHdc);
        RtlDeleteCriticalSection(&gcsAccelCache);
        RtlDeleteCriticalSection(&gcsDDEML);
        RtlDeleteCriticalSection(&gcsUserApiHook);
#ifdef MESSAGE_PUMP_HOOK
        RtlDeleteCriticalSection(&gcsMPH);
#endif

#if DBG
        if (gpDDEMLHeap != RtlProcessHeap()) {
            RtlDestroyHeap(gpDDEMLHeap);
        }
#endif

    }

    Status = GdiDllInitialize(hmod, Reason, pctx);
    if (!NT_SUCCESS(Status)) {
        FRE_RIPMSG1(RIP_WARNING,
                    "GdiDllInitialize failed with Status 0x%x",
                    Status);
    }

    return NT_SUCCESS(Status);
}

/***************************************************************************\
* LoadCursorsAndIcons
*
* This gets called from our initialization call from csr so they're around
* when window classes get registered. Window classes get registered right
* after the initial csr initialization call.
*
* Later on these default images will get overwritten by custom
* registry entries.  See UpdateCursors/IconsFromRegistry().
*
* 27-Sep-1992 ScottLu      Created.
* 14-Oct-1995 SanfordS     Rewrote.
\***************************************************************************/

BOOL LoadCursorsAndIcons(VOID)
{
    int    i;
    HANDLE h;
    BOOL   fSuccess = TRUE;

    for (i = 0; i < COIC_CONFIGURABLE; i++) {
        /*
         * load the small version of WINLOGO which will be set into
         * gpsi->hIconSmWindows on the kernel side.
         */
        if (i == OIC_WINLOGO_DEFAULT - OIC_FIRST_DEFAULT) {
            h = LoadIcoCur(NULL,
                           (LPCWSTR)UIntToPtr( (OIC_FIRST_DEFAULT + i) ),
                           RT_ICON,
                           SYSMET(CXSMICON),
                           SYSMET(CYSMICON),
                           LR_GLOBAL);

            fSuccess &= !!h;
        }
        h = LoadIcoCur(NULL,
                       (LPCWSTR)UIntToPtr( (OIC_FIRST_DEFAULT + i) ),
                       RT_ICON,
                       0,
                       0,
                       LR_SHARED | LR_GLOBAL);

        fSuccess &= !!h;
    }

    for (i = 0; i < COCR_CONFIGURABLE; i++) {
        h = LoadIcoCur(NULL,
                       (LPCWSTR)UIntToPtr( (OCR_FIRST_DEFAULT + i) ),
                       RT_CURSOR,
                       0,
                       0,
                       LR_SHARED | LR_GLOBAL | LR_DEFAULTSIZE);

        fSuccess &= !!h;
    }

    if (!fSuccess) {
        RIPMSG0(RIP_WARNING, "LoadCursorsAndIcons failed to load cursors");
    }

    /*
     * Now go to the kernel and fixup the IDs from DEFAULT values
     * to standard values.
     */
    NtUserCallNoParam(SFI__LOADCURSORSANDICONS);

    return fSuccess;
}

/***************************************************************************\
* RW_RegisterControls
*
* Register the control classes. This function must be called for each
* client process.
*
* History:
* ??-??-?? DarrinM Ported.
* ??-??-?? MikeKe Moved here from server.
\***************************************************************************/

/*
 * NOTE -- the class names must stay in the RegisterClass exactly as they are, since
 * MS-TEST assumes these names exist as strings.
 */

BOOL RW_RegisterControls(VOID)
{
    int        i;
    WNDCLASSEX wndcls;
    BOOL       fSuccess = TRUE;

    static CONST struct {
        UINT    style;
        WNDPROC lpfnWndProcW;
        int     cbWndExtra;
        LPCTSTR lpszCursor;
        HBRUSH  hbrBackground;
        LPCTSTR lpszClassName;
        WORD    fnid;
    } rc[] = {

        {CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW,
         ButtonWndProcW,
         sizeof(BUTNWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"Button",
         FNID_BUTTON
        },

        {CS_GLOBALCLASS | CS_DBLCLKS | CS_PARENTDC | CS_VREDRAW | CS_HREDRAW,
         ComboBoxWndProcW,
         sizeof(COMBOWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"ComboBox",
         FNID_COMBOBOX
        },

        {CS_GLOBALCLASS | CS_DBLCLKS | CS_SAVEBITS,
         ComboListBoxWndProcW,
         sizeof(LBWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"ComboLBox",
         FNID_COMBOLISTBOX
        },

        {CS_GLOBALCLASS | CS_DBLCLKS | CS_SAVEBITS,
         DefDlgProcW,
         DLGWINDOWEXTRA,
         IDC_ARROW,
         NULL,
         DIALOGCLASS,
         FNID_DIALOG
        },

        {CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS,
         EditWndProcW,
         max((sizeof(EDITWND) - sizeof(WND)), CBEDITEXTRA),
         IDC_IBEAM,
         NULL,
         L"Edit",
         FNID_EDIT
        },

        {CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS,
         ListBoxWndProcW,
         sizeof(LBWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"ListBox",
         FNID_LISTBOX
        },

        {CS_GLOBALCLASS,
         MDIClientWndProcW,
         sizeof(MDIWND) - sizeof(WND),
         IDC_ARROW,
         (HBRUSH)(COLOR_APPWORKSPACE + 1),
         L"MDIClient",
         FNID_MDICLIENT
        },

        {CS_GLOBALCLASS,
         ImeWndProcW,
         sizeof(IMEWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"IME",
         FNID_IME
        },

        {CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS,
         StaticWndProcW,
         sizeof(STATWND) - sizeof(WND),
         IDC_ARROW,
         NULL,
         L"Static",
         FNID_STATIC
        }
    };


    /*
     * Classes are registered via the table.
     */
    RtlZeroMemory(&wndcls, sizeof(wndcls));
    wndcls.cbSize       = sizeof(wndcls);
    wndcls.hInstance    = hmodUser;

    for (i = 0; i < (sizeof(rc)/sizeof(rc[0])); i++) {
        wndcls.style        = rc[i].style;
        wndcls.lpfnWndProc  = rc[i].lpfnWndProcW;
        wndcls.cbWndExtra   = rc[i].cbWndExtra;
        wndcls.hCursor      = LoadCursor(NULL, rc[i].lpszCursor);
        wndcls.hbrBackground= rc[i].hbrBackground;
        wndcls.lpszClassName= rc[i].lpszClassName;

        fSuccess &= !!RegisterClassExWOWW(&wndcls, NULL, rc[i].fnid, 0);
    }

    if (!fSuccess) {
        RIPMSG0(RIP_WARNING, "RW_RegisterControls failed to register classes");
    }

    return fSuccess;
}

/***************************************************************************\
* RW_RegisterDDEML
*
* Register all the DDEML classes
*
* History:
* 01-Dec-1991 Sanfords Created.
\***************************************************************************/

BOOL RW_RegisterDDEML(VOID)
{
    WNDCLASSEXA wndclsa;
    WNDCLASSEXW wndclsw;
    BOOL        fSuccess = TRUE;

    RtlZeroMemory(&wndclsw, sizeof(wndclsw));
    wndclsw.cbSize        = sizeof(wndclsw);
    wndclsw.lpfnWndProc   = DDEMLMotherWndProc;
    wndclsw.cbWndExtra    = sizeof(PCL_INSTANCE_INFO);
    wndclsw.hInstance     = hmodUser;
    wndclsw.lpszClassName = L"DDEMLMom";

    fSuccess &= !!RegisterClassExWOWW(&wndclsw, NULL, FNID_DDE_BIT, 0);

    RtlZeroMemory(&wndclsa, sizeof(wndclsa));
    wndclsa.cbSize        = sizeof(wndclsa);
    wndclsa.lpfnWndProc   = DDEMLClientWndProc;
    wndclsa.cbWndExtra    =
            sizeof(PCL_CONV_INFO) +     // GWL_PCI
            sizeof(CONVCONTEXT)   +     // GWL_CONVCONTEXT
            sizeof(LONG)          +     // GWL_CONVSTATE
            sizeof(HANDLE)        +     // GWL_CHINST
            sizeof(HANDLE);             // GWL_SHINST
    wndclsa.hInstance     = hmodUser;
    wndclsa.lpszClassName = "DDEMLAnsiClient";

    fSuccess &= !!RegisterClassExWOWA(&wndclsa, NULL, FNID_DDE_BIT, 0);

    wndclsw.cbSize        = sizeof(wndclsw);
    wndclsw.lpfnWndProc   = DDEMLClientWndProc;
    wndclsw.cbWndExtra    =
            sizeof(PCL_CONV_INFO) +     // GWL_PCI
            sizeof(CONVCONTEXT)   +     // GWL_CONVCONTEXT
            sizeof(LONG)          +     // GWL_CONVSTATE
            sizeof(HANDLE)        +     // GWL_CHINST
            sizeof(HANDLE);             // GWL_SHINST
    wndclsw.hInstance     = hmodUser;
    wndclsw.lpszClassName = L"DDEMLUnicodeClient";

    fSuccess &= !!RegisterClassExWOWW(&wndclsw, NULL, FNID_DDE_BIT, 0);

    wndclsa.cbSize        = sizeof(wndclsa);
    wndclsa.lpfnWndProc   = DDEMLServerWndProc;
    wndclsa.cbWndExtra    = sizeof(PSVR_CONV_INFO);     // GWL_PSI
    wndclsa.hInstance     = hmodUser;
    wndclsa.lpszClassName = "DDEMLAnsiServer";

    fSuccess &= !!RegisterClassExWOWA(&wndclsa, NULL, FNID_DDE_BIT, 0);

    wndclsw.cbSize        = sizeof(wndclsw);
    wndclsw.lpfnWndProc   = DDEMLServerWndProc;
    wndclsw.cbWndExtra    = sizeof(PSVR_CONV_INFO);     // GWL_PSI
    wndclsw.hInstance     = hmodUser;
    wndclsw.lpszClassName = L"DDEMLUnicodeServer";

    fSuccess &= !!RegisterClassExWOWW(&wndclsw, NULL, FNID_DDE_BIT, 0);

    if (!fSuccess) {
        RIPMSG0(RIP_WARNING, "RW_RegisterDDEML failed to register classes");
    }

    return fSuccess;
}

/***************************************************************************\
* LoadAppDlls()
*
* History:
*
* 10-Apr-1992  sanfords   Birthed.
\***************************************************************************/
VOID LoadAppDlls(VOID)
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjA;
    HKEY hKeyWindows;
    NTSTATUS Status;
    DWORD cbSize;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
        WCHAR awch[24];
    } KeyFile;
    PKEY_VALUE_PARTIAL_INFORMATION  lpKeyFile = (PKEY_VALUE_PARTIAL_INFORMATION)&KeyFile;
    DWORD cbSizeCurrent = sizeof(KeyFile);
    BOOL bAlloc = FALSE;

    if (gfLogonProcess || gfServerProcess) {

        /*
         * Don't let the logon process load appdlls because if the dll
         * sets any hooks or creates any windows, the logon process
         * will fail SetThreadDesktop().  This hack fixes that. (SAS)
         */
        return;
    }

    /*
     * If the image is an NT Native image, we are running in the
     * context of the server.
     */
    if (RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress)->
        OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_NATIVE) {
        return;
    }

    RtlInitUnicodeString(&UnicodeString, pwszWindowsKey);
    InitializeObjectAttributes(&ObjA,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);


    Status = NtOpenKey(&hKeyWindows,
                    KEY_READ,
                    &ObjA);


    if (!NT_SUCCESS(Status))
        return;

    /*
     * Read the "AppInit_Dlls" value.
     */
    RtlInitUnicodeString(&UnicodeString, szAppInit);

    while (TRUE) {
        Status = NtQueryValueKey(hKeyWindows,
            &UnicodeString,
            KeyValuePartialInformation,
            lpKeyFile,
            cbSizeCurrent,
            &cbSize);

        if (Status == STATUS_BUFFER_OVERFLOW) {
            if (bAlloc) {
                UserGlobalFree(lpKeyFile);
            }
            lpKeyFile = GlobalAlloc(LPTR, cbSize);
            if (!lpKeyFile) {
                RIPERR0(ERROR_OUTOFMEMORY,
                    RIP_WARNING,
                    "LoadAppDlls failed");
                NtClose(hKeyWindows);
                return;
            }
            bAlloc = TRUE;
            cbSizeCurrent = cbSize;
            continue;
        }
        break;
    }
    if (NT_SUCCESS(Status)) {
        LPWSTR pszSrc;
        LPWSTR pszDst;
        LPWSTR pszBase;
        WCHAR  ch;

    /*
     * Process the DLL data.
     */
        pszBase = pszDst = pszSrc = (LPWSTR)lpKeyFile->Data;
        while (*pszSrc != TEXT('\0')) {

            while (*pszSrc == TEXT(' ') || *pszSrc  == TEXT(','))
                pszSrc++;

            if (*pszSrc == TEXT('\0'))
                break;

            while (*pszSrc != TEXT(',')  &&
                   *pszSrc != TEXT('\0') &&
                   *pszSrc != TEXT(' ')) {
                *pszDst++ = *pszSrc++;
            }

            ch = *pszSrc;               // get it here cuz its being done in-place.
            *pszDst++ = TEXT('\0');     // '\0' is dll name delimiter

            LoadLibrary(pszBase);
            pszBase = pszDst;

            pszSrc++;

            if (ch == TEXT('\0'))
                break;
        }

    }


    if (bAlloc) {
        UserGlobalFree(lpKeyFile);
    }
    NtClose(hKeyWindows);
}

VOID
InitOemXlateTables()
{
    char ach[NCHARS];
    WCHAR awch[NCHARS];
    WCHAR awchCtrl[NCTRLS];
    INT i;
    INT cch;
    char OemToAnsi[NCHARS];
    char AnsiToOem[NCHARS];

    for (i = 0; i < NCHARS; i++) {
        ach[i] = (char)i;
    }

    /*
     * First generate pAnsiToOem table.
     */

    if (GetOEMCP() == GetACP()) {
        /*
         * For far east code pages using MultiByteToWideChar below
         * won't work.  Conveniently for these code pages the OEM
         * CP equals the ANSI codepage making it trivial to compute
         * pOemToAnsi and pAnsiToOem arrays
         *
         */

        RtlCopyMemory(OemToAnsi, ach, NCHARS);
        RtlCopyMemory(AnsiToOem, ach, NCHARS);

    }
    else
    {
        cch = MultiByteToWideChar(
            CP_ACP,                           // ANSI -> Unicode
            MB_PRECOMPOSED,                   // map to precomposed
            ach, NCHARS,                      // source & length
            awch, NCHARS);                    // destination & length

        UserAssert(cch == NCHARS);

        WideCharToMultiByte(
            CP_OEMCP,                         // Unicode -> OEM
            0,                                // gives best visual match
            awch, NCHARS,                     // source & length
            AnsiToOem, NCHARS,               // dest & max poss. length
            "_",                              // default char
            NULL);                            // (don't care whether defaulted)
        /*
         * Now generate pOemToAnsi table.
         */
        cch = MultiByteToWideChar(
            CP_OEMCP,                         // OEM -> Unicode
            MB_PRECOMPOSED | MB_USEGLYPHCHARS,// visual map to precomposed
            ach, NCHARS,                      // source & length
            awch, NCHARS);                    // destination

        UserAssert(cch == NCHARS);

        /*
         * Now patch special cases for Win3.1 compatibility
         *
         * 0x07 BULLET              (glyph 0x2022) must become 0x0007 BELL
         * 0x0F WHITE STAR WITH SUN (glyph 0x263C) must become 0x00A4 CURRENCY SIGN
         * 0x7F HOUSE               (glyph 0x2302) must become 0x007f DELETE
         */
        awch[0x07] = 0x0007;
        awch[0x0F] = 0x00a4;
        awch[0x7f] = 0x007f;

        WideCharToMultiByte(
            CP_ACP,                           // Unicode -> ANSI
            0,                                // gives best visual match
            awch, NCHARS,                     // source & length
            OemToAnsi, NCHARS,               // dest & max poss. length
            "_",                              // default char
            NULL);                            // (don't care whether defaulted)

        /*
         * Now for all OEM chars < 0x20 (control chars), test whether the glyph
         * we have is really in CP_ACP or not.  If not, then restore the
         * original control character. Note: 0x00 remains 0x00.
         */
        MultiByteToWideChar(CP_ACP, 0, OemToAnsi, NCTRLS, awchCtrl, NCTRLS);

        for (i = 1; i < NCTRLS; i++) {
            if (awchCtrl[i] != awch[i]) {
                OemToAnsi[i] = (char)i;
            }
        }
    }
    NtUserCallTwoParam((ULONG_PTR)OemToAnsi, (ULONG_PTR)AnsiToOem, SFI_INITANSIOEM);
}

const PFNCLIENT   pfnClientA = {
        (KPROC)ScrollBarWndProcA,
        (KPROC)DefWindowProcA,
        (KPROC)MenuWndProcA,
        (KPROC)DesktopWndProcA,
        (KPROC)DefWindowProcA,
        (KPROC)DefWindowProcA,
        (KPROC)DefWindowProcA,
        (KPROC)ButtonWndProcA,
        (KPROC)ComboBoxWndProcA,
        (KPROC)ComboListBoxWndProcA,
        (KPROC)DefDlgProcA,
        (KPROC)EditWndProcA,
        (KPROC)ListBoxWndProcA,
        (KPROC)MDIClientWndProcA,
        (KPROC)StaticWndProcA,
        (KPROC)ImeWndProcA,
        (KPROC)fnHkINLPCWPSTRUCTA,
        (KPROC)fnHkINLPCWPRETSTRUCTA,
        (KPROC)DispatchHookA,
        (KPROC)DispatchDefWindowProcA,
        (KPROC)DispatchClientMessage,
        (KPROC)MDIActivateDlgProcA};

const   PFNCLIENT   pfnClientW = {
        (KPROC)ScrollBarWndProcW,
        (KPROC)DefWindowProcW,
        (KPROC)MenuWndProcW,
        (KPROC)DesktopWndProcW,
        (KPROC)DefWindowProcW,
        (KPROC)DefWindowProcW,
        (KPROC)DefWindowProcW,
        (KPROC)ButtonWndProcW,
        (KPROC)ComboBoxWndProcW,
        (KPROC)ComboListBoxWndProcW,
        (KPROC)DefDlgProcW,
        (KPROC)EditWndProcW,
        (KPROC)ListBoxWndProcW,
        (KPROC)MDIClientWndProcW,
        (KPROC)StaticWndProcW,
        (KPROC)ImeWndProcW,
        (KPROC)fnHkINLPCWPSTRUCTW,
        (KPROC)fnHkINLPCWPRETSTRUCTW,
        (KPROC)DispatchHookW,
        (KPROC)DispatchDefWindowProcW,
        (KPROC)DispatchClientMessage,
        (KPROC)MDIActivateDlgProcW};

const PFNCLIENTWORKER   pfnClientWorker = {
        (KPROC)ButtonWndProcWorker,
        (KPROC)ComboBoxWndProcWorker,
        (KPROC)ListBoxWndProcWorker,
        (KPROC)DefDlgProcWorker,
        (KPROC)EditWndProcWorker,
        (KPROC)ListBoxWndProcWorker,
        (KPROC)MDIClientWndProcWorker,
        (KPROC)StaticWndProcWorker,
        (KPROC)ImeWndProcWorker};


/***************************************************************************\
* ClientThreadSetup
*
\***************************************************************************/
BOOL ClientThreadSetup(
    VOID)
{
    PCLIENTINFO pci;
    BOOL        fFirstThread;
    DWORD       ConnectState;

    /*
     * NT BUG 268642: Only the first thread calls GdiProcessSetup but all the
     * other threads must wait until the setup for GDI is finished.
     *
     * We can safely use gcsAccelCache critical section to protect this (even
     * though the name is not intuitive at all)
     */

    RtlEnterCriticalSection(&gcsAccelCache);

    fFirstThread = gfFirstThread;

    /*
     * Setup GDI before continuing.
     */
    if (fFirstThread) {
        gfFirstThread = FALSE;
        GdiProcessSetup();
    }

    RtlLeaveCriticalSection(&gcsAccelCache);

    /*
     * We've already checked to see if we need to connect
     * (i.e. NtCurrentTeb()->Win32ThreadInfo == NULL). This routine
     * just does the connecting. If we've already been through here
     * once, don't do it again.
     */
    pci = GetClientInfo();
    if (pci->CI_flags & CI_INITIALIZED) {
        RIPMSG0(RIP_ERROR, "Already initialized!");
        return FALSE;
    }

    /*
     * Create the queue info and thread info. Only once for this process do
     * we pass client side addresses to the server (for server callbacks).
     */
    if (gfServerProcess && fFirstThread) {
        USERCONNECT userconnect;
        NTSTATUS    Status;

        /*
         * We know that the shared info is now available in
         * the kernel. Map it into the server process.
         */
        userconnect.ulVersion = USERCURRENTVERSION;
        userconnect.dwDispatchCount = gDispatchTableValues;
        Status = NtUserProcessConnect(NtCurrentProcess(),
                                      &userconnect,
                                      sizeof(USERCONNECT));
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        gSharedInfo = userconnect.siClient;
        gpsi = gSharedInfo.psi;
        UserAssert(gpsi);

        UserAssert(pfnClientA.pfnScrollBarWndProc   == (KPROC)ScrollBarWndProcA);
        UserAssert(pfnClientA.pfnTitleWndProc       == (KPROC)DefWindowProcA);
        UserAssert(pfnClientA.pfnMenuWndProc        == (KPROC)MenuWndProcA);
        UserAssert(pfnClientA.pfnDesktopWndProc     == (KPROC)DesktopWndProcA);
        UserAssert(pfnClientA.pfnDefWindowProc      == (KPROC)DefWindowProcA);
        UserAssert(pfnClientA.pfnMessageWindowProc  == (KPROC)DefWindowProcA);
        UserAssert(pfnClientA.pfnHkINLPCWPSTRUCT    == (KPROC)fnHkINLPCWPSTRUCTA);
        UserAssert(pfnClientA.pfnHkINLPCWPRETSTRUCT == (KPROC)fnHkINLPCWPRETSTRUCTA);
        UserAssert(pfnClientA.pfnButtonWndProc      == (KPROC)ButtonWndProcA);
        UserAssert(pfnClientA.pfnComboBoxWndProc    == (KPROC)ComboBoxWndProcA);
        UserAssert(pfnClientA.pfnComboListBoxProc   == (KPROC)ComboListBoxWndProcA);
        UserAssert(pfnClientA.pfnDialogWndProc      == (KPROC)DefDlgProcA);
        UserAssert(pfnClientA.pfnEditWndProc        == (KPROC)EditWndProcA);
        UserAssert(pfnClientA.pfnListBoxWndProc     == (KPROC)ListBoxWndProcA);
        UserAssert(pfnClientA.pfnMDIActivateDlgProc == (KPROC)MDIActivateDlgProcA);
        UserAssert(pfnClientA.pfnMDIClientWndProc   == (KPROC)MDIClientWndProcA);
        UserAssert(pfnClientA.pfnStaticWndProc      == (KPROC)StaticWndProcA);
        UserAssert(pfnClientA.pfnDispatchHook       == (KPROC)DispatchHookA);
        UserAssert(pfnClientA.pfnDispatchMessage    == (KPROC)DispatchClientMessage);
        UserAssert(pfnClientA.pfnImeWndProc         == (KPROC)ImeWndProcA);

        UserAssert(pfnClientW.pfnScrollBarWndProc   == (KPROC)ScrollBarWndProcW);
        UserAssert(pfnClientW.pfnTitleWndProc       == (KPROC)DefWindowProcW);
        UserAssert(pfnClientW.pfnMenuWndProc        == (KPROC)MenuWndProcW);
        UserAssert(pfnClientW.pfnDesktopWndProc     == (KPROC)DesktopWndProcW);
        UserAssert(pfnClientW.pfnDefWindowProc      == (KPROC)DefWindowProcW);
        UserAssert(pfnClientW.pfnMessageWindowProc  == (KPROC)DefWindowProcW);
        UserAssert(pfnClientW.pfnHkINLPCWPSTRUCT    == (KPROC)fnHkINLPCWPSTRUCTW);
        UserAssert(pfnClientW.pfnHkINLPCWPRETSTRUCT == (KPROC)fnHkINLPCWPRETSTRUCTW);
        UserAssert(pfnClientW.pfnButtonWndProc      == (KPROC)ButtonWndProcW);
        UserAssert(pfnClientW.pfnComboBoxWndProc    == (KPROC)ComboBoxWndProcW);
        UserAssert(pfnClientW.pfnComboListBoxProc   == (KPROC)ComboListBoxWndProcW);
        UserAssert(pfnClientW.pfnDialogWndProc      == (KPROC)DefDlgProcW);
        UserAssert(pfnClientW.pfnEditWndProc        == (KPROC)EditWndProcW);
        UserAssert(pfnClientW.pfnListBoxWndProc     == (KPROC)ListBoxWndProcW);
        UserAssert(pfnClientW.pfnMDIActivateDlgProc == (KPROC)MDIActivateDlgProcW);
        UserAssert(pfnClientW.pfnMDIClientWndProc   == (KPROC)MDIClientWndProcW);
        UserAssert(pfnClientW.pfnStaticWndProc      == (KPROC)StaticWndProcW);
        UserAssert(pfnClientW.pfnDispatchHook       == (KPROC)DispatchHookW);
        UserAssert(pfnClientW.pfnDispatchMessage    == (KPROC)DispatchClientMessage);
        UserAssert(pfnClientW.pfnImeWndProc         == (KPROC)ImeWndProcW);

        UserAssert(pfnClientWorker.pfnButtonWndProc      == (KPROC)ButtonWndProcWorker);
        UserAssert(pfnClientWorker.pfnComboBoxWndProc    == (KPROC)ComboBoxWndProcWorker);
        UserAssert(pfnClientWorker.pfnComboListBoxProc   == (KPROC)ListBoxWndProcWorker);
        UserAssert(pfnClientWorker.pfnDialogWndProc      == (KPROC)DefDlgProcWorker);
        UserAssert(pfnClientWorker.pfnEditWndProc        == (KPROC)EditWndProcWorker);
        UserAssert(pfnClientWorker.pfnListBoxWndProc     == (KPROC)ListBoxWndProcWorker);
        UserAssert(pfnClientWorker.pfnMDIClientWndProc   == (KPROC)MDIClientWndProcWorker);
        UserAssert(pfnClientWorker.pfnStaticWndProc      == (KPROC)StaticWndProcWorker);
        UserAssert(pfnClientWorker.pfnImeWndProc         == (KPROC)ImeWndProcWorker);

#if DBG
        {
            PULONG_PTR pdw;

            /*
             * Make sure that everyone got initialized
             */
            for (pdw = (PULONG_PTR)&pfnClientA;
                 (ULONG_PTR)pdw<(ULONG_PTR)(&pfnClientA) + sizeof(pfnClientA);
                 pdw++) {
                UserAssert(*pdw);
            }

            for (pdw = (PULONG_PTR)&pfnClientW;
                 (ULONG_PTR)pdw<(ULONG_PTR)(&pfnClientW) + sizeof(pfnClientW);
                 pdw++) {
                UserAssert(*pdw);
            }
        }
#endif

#if DBG
    {
        extern CONST INT gcapfnScSendMessage;
        BOOLEAN apfnCheckMessage[64];
        int i;

        /*
         * Do some verification of the message table. Since we only have
         * 6 bits to store the function index, the function table can have
         * at most 64 entries. Also verify that none of the indexes point
         * past the end of the table and that all the function entries
         * are used.
         */
        UserAssert(gcapfnScSendMessage <= 64);
        RtlZeroMemory(apfnCheckMessage, sizeof(apfnCheckMessage));
        for (i = 0; i < WM_USER; i++) {
            UserAssert(MessageTable[i].iFunction < gcapfnScSendMessage);
            apfnCheckMessage[MessageTable[i].iFunction] = TRUE;
        }

        for (i = 0; i < gcapfnScSendMessage; i++) {
            UserAssert(apfnCheckMessage[i]);
        }
    }
#endif

    }

    /*
     * Pass the function pointer arrays to the kernel. This also establishes
     * the kernel state for the thread. If ClientThreadSetup is called from
     * CsrConnectToUser this call will raise an exception if the thread
     * cannot be converted to a gui thread. The exception is handled in
     * CsrConnectToUser.
     */
#if DBG && !defined(BUILD_WOW6432)
    /*
     * On debug systems, go to the kernel for all processes to verify we're
     * loading user32.dll at the right address.
     */
    if (fFirstThread) {
#elif defined(BUILD_WOW6432)
    /*
     * On WOW64 allways register the client fns
     */
    {
#else
    if (gfServerProcess && fFirstThread) {
#endif
        if (!NT_SUCCESS(NtUserInitializeClientPfnArrays(&pfnClientA, &pfnClientW, &pfnClientWorker, hmodUser))) {

            RIPERR0(ERROR_OUTOFMEMORY,
                    RIP_WARNING,
                    "NtUserInitializeClientPfnArrays failed");

            return FALSE;
        }
    }

    /*
     * Mark this thread as being initialized.  If the connection to
     * the server fails, NtCurrentTeb()->Win32ThreadInfo will remain
     * NULL.
     */
    pci->CI_flags |= CI_INITIALIZED;

    /*
     * Some initialization only has to occur once per process
     */
    if (fFirstThread) {

        ConnectState = (DWORD)NtUserCallNoParam(SFI_REMOTECONNECTSTATE);

        /*
         * Winstation Winlogon and CSR must do graphics initialization
         * after the connect.
         */

        if (ConnectState != CTX_W32_CONNECT_STATE_IDLE) {

            if ((ghdcBits2 = CreateCompatibleDC(NULL)) == NULL) {
                RIPERR0(ERROR_OUTOFMEMORY, RIP_WARNING, "ghdcBits2 creation failed");
                return FALSE;
            }

            /*
             * Get things we need from Gdi.
             */
            if (ghbrWhite == NULL)
                ghbrWhite = GetStockObject(WHITE_BRUSH);

            if (ghbrBlack == NULL)
                ghbrBlack = GetStockObject(BLACK_BRUSH);

            InitClientDrawing();
        }

        gfSystemInitialized = NtUserGetThreadDesktop(GetCurrentThreadId(),
                                                     NULL) != NULL;

        /*
         * If an lpk is loaded for this process notify the kernel
         */
        if (gdwLpkEntryPoints) {
            NtUserCallOneParam(gdwLpkEntryPoints, SFI_REGISTERLPK);
        }

        if (gfServerProcess || (GetClientInfo()->pDeskInfo == NULL)) {
            /*
             * Perform any server initialization.
             */
            UserAssert(gpsi);

            if (pdiLocal = LocalAlloc(LPTR, sizeof(DESKTOPINFO))) {
                GetClientInfo()->pDeskInfo = pdiLocal;
            } else {
                RIPERR0(ERROR_OUTOFMEMORY, RIP_WARNING, "pdiLocal creation failed");
                return FALSE;
            }
        }

        if (gfServerProcess) {
            /*
             * Winstation Winlogon and CSR must do graphics initialization
             * after the connect.
             */
            if (ConnectState != CTX_W32_CONNECT_STATE_IDLE) {
                if (!LoadCursorsAndIcons()) {
                    RIPERR0(ERROR_OUTOFMEMORY, RIP_WARNING, "LoadCursorsAndIcons failed");
                    return FALSE;
                }
            }

            InitOemXlateTables();
        }

        LoadAppDlls();
    } else if (gfServerProcess) {
        GetClientInfo()->pDeskInfo = pdiLocal;
    }

    /*
     * Kernel sets CI_REGISTERCLASSES when appropriate (i.e. always
     * for the first thread and for other threads if the last GUI
     * thread for a process has exited) except for the CSR proces.
     * For the CSR process, you must register the classes on the
     * first thread anyways.
     */

    if (fFirstThread || (pci->CI_flags & CI_REGISTERCLASSES)) {

        /*
         * If it's the first thread we already made it to the kernel
         * to get the ConnectState...
         */
        if (!fFirstThread) {
            ConnectState = (DWORD)NtUserCallNoParam(SFI_REMOTECONNECTSTATE);
        }

        if (ConnectState != CTX_W32_CONNECT_STATE_IDLE) {

            /*
             * Register the control classes.
             */
            RW_RegisterControls();
            RW_RegisterDDEML();
        }
    }

    return TRUE;
}

/***************************************************************************\
* Dispatch routines.
*
*
\***************************************************************************/

HLOCAL WINAPI DispatchLocalAlloc(
    UINT   uFlags,
    UINT   uBytes,
    HANDLE hInstance)
{
    UNREFERENCED_PARAMETER(hInstance);

    return LocalAlloc(uFlags, uBytes);
}

HLOCAL WINAPI DispatchLocalReAlloc(
    HLOCAL hMem,
    UINT   uBytes,
    UINT   uFlags,
    HANDLE hInstance,
    PVOID* ppv)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(ppv);

    return LocalReAlloc(hMem, uBytes, uFlags);
}

LPVOID WINAPI DispatchLocalLock(
    HLOCAL hMem,
    HANDLE hInstance)
{
    UNREFERENCED_PARAMETER(hInstance);

    return LocalLock(hMem);
}

BOOL WINAPI DispatchLocalUnlock(
    HLOCAL hMem,
    HANDLE hInstance)
{
    UNREFERENCED_PARAMETER(hInstance);

    return LocalUnlock(hMem);
}

UINT WINAPI DispatchLocalSize(
    HLOCAL hMem,
    HANDLE hInstance)
{
    UNREFERENCED_PARAMETER(hInstance);

    return (UINT)LocalSize(hMem);
}

HLOCAL WINAPI DispatchLocalFree(
    HLOCAL hMem,
    HANDLE hInstance)
{
    UNREFERENCED_PARAMETER(hInstance);

    return LocalFree(hMem);
}

/***************************************************************************\
* Allocation routines for RTL functions.
*
*
\***************************************************************************/

PVOID UserRtlAllocMem(
    ULONG uBytes)
{
    return UserLocalAlloc(HEAP_ZERO_MEMORY, uBytes);
}

VOID UserRtlFreeMem(
    PVOID pMem)
{
    UserLocalFree(pMem);
}

VOID UserRtlRaiseStatus(
    NTSTATUS Status)
{
    RtlRaiseStatus(Status);
}

/***************************************************************************\
* InitClientDrawing
*
* History:
* 20-Aug-1992 mikeke    Created
\***************************************************************************/

BOOL InitClientDrawing(VOID)
{
    static CONST WORD patGray[8] = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};
    BOOL fSuccess = TRUE;

    HBITMAP hbmGray = CreateBitmap(8, 8, 1, 1, (LPBYTE)patGray);;

    fSuccess &= !!hbmGray;

    /*
     * Create the global-objects for client drawing.
     */
    ghbrWindowText = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT));
    fSuccess &= !!ghbrWindowText;

    ghFontSys = GetStockObject(SYSTEM_FONT);
    fSuccess &= !!ghFontSys;

    ghdcGray = CreateCompatibleDC(NULL);
    fSuccess &= !!ghdcGray;

    if (!fSuccess) {
        RIPMSG0(RIP_WARNING, "InitClientDrawing failed to allocate resources");
        return FALSE;
    }

    /*
     * Setup the gray surface.
     */
    SelectObject(ghdcGray, hbmGray);
    SelectObject(ghdcGray, ghFontSys);
    SelectObject(ghdcGray, KHBRUSH_TO_HBRUSH(gpsi->hbrGray));

    /*
     * Setup the gray attributes.
     */
    SetBkMode(ghdcGray, OPAQUE);
    SetTextColor(ghdcGray, 0x00000000L);
    SetBkColor(ghdcGray, 0x00FFFFFFL);

    gcxGray = 8;
    gcyGray = 8;

    return TRUE;
}

VOID
InitializeLpkHooks(
    CONST FARPROC *lpfpLpkHooks
    )
{
    /*
     * Called from GdiInitializeLanguagePack().  Remember what entry points
     * are supported.  Pass the information to the kernel the first time
     * this process connects in ClientThreadSetup().
     */
    if (lpfpLpkHooks[LPK_TABBED_TEXT_OUT]) {
        fpLpkTabbedTextOut = (FPLPKTABBEDTEXTOUT)lpfpLpkHooks[LPK_TABBED_TEXT_OUT];
        gdwLpkEntryPoints |= (1 << LPK_TABBED_TEXT_OUT);
    }
    if (lpfpLpkHooks[LPK_PSM_TEXT_OUT]) {
        fpLpkPSMTextOut = (FPLPKPSMTEXTOUT)lpfpLpkHooks[LPK_PSM_TEXT_OUT];
        gdwLpkEntryPoints |= (1 << LPK_PSM_TEXT_OUT);
    }
    if (lpfpLpkHooks[LPK_DRAW_TEXT_EX]) {
        fpLpkDrawTextEx = (FPLPKDRAWTEXTEX)lpfpLpkHooks[LPK_DRAW_TEXT_EX];
        gdwLpkEntryPoints |= (1 << LPK_DRAW_TEXT_EX);
    }
    if (lpfpLpkHooks[LPK_EDIT_CONTROL]) {
        fpLpkEditControl = (PLPKEDITCALLOUT)lpfpLpkHooks[LPK_EDIT_CONTROL];
        gdwLpkEntryPoints |= (1 << LPK_EDIT_CONTROL);
    }
}

/***************************************************************************\
*
* CtxInitUser32
*
* Called by CreateWindowStation() and winsrv.dll DoConnect routine.
*
* Winstation Winlogon and CSR must do graphics initialization
* after the connect.  This is because no video driver is loaded
* until then.
*
* This routine must contain everything that was skipped before.
*
* History:
* Dec-11-1997 clupu    Ported from Citrix
\***************************************************************************/
BOOL CtxInitUser32(
    VOID)
{
    /*
     * Only do once.
     */
    if (ghdcBits2 != NULL || (NtCurrentPeb()->SessionId == 0)) {
        return TRUE;
    }

    ghdcBits2 = CreateCompatibleDC(NULL);
    if (ghdcBits2 == NULL) {
        RIPMSG0(RIP_WARNING, "Could not allocate ghdcBits2");
        return FALSE;
    }

    /*
     * Get things we need from Gdi.
     */
    if (ghbrWhite == NULL) {
        ghbrWhite = GetStockObject(WHITE_BRUSH);
    }

    if (ghbrBlack == NULL) {
        ghbrBlack = GetStockObject(BLACK_BRUSH);
    }

    UserAssert(ghbrWhite != NULL && ghbrBlack != NULL);

    if (!InitClientDrawing()) {
        RIPMSG0(RIP_WARNING, "InitClientDrawing failed");
        return FALSE;
    }

    if (gfServerProcess) {
        if (!LoadCursorsAndIcons()) {
            RIPMSG0(RIP_WARNING, "LoadCursorsAndIcons failed");
            return FALSE;
        }
    }

    /*
     * Register the control classes.
     */
    if (!RW_RegisterControls()) {
        return FALSE;
    }

    if (!RW_RegisterDDEML()) {
        return FALSE;
    }

    return TRUE;
}

DWORD GetRipComponent(VOID) { return RIP_USER; }

DWORD GetDbgTagFlags(int tag)
{
#if DEBUGTAGS
    return (gpsi != NULL ? gpsi->adwDBGTAGFlags[tag] : 0);
#else
    return 0;
    UNREFERENCED_PARAMETER(tag);
#endif // DEBUGTAGS
}

DWORD GetRipPID(VOID) { return (gpsi != NULL ? gpsi->wRIPPID : 0); }
DWORD GetRipFlags(VOID) { return (gpsi != NULL ? gpsi->wRIPFlags : RIPF_DEFAULT); }

VOID SetRipFlags(DWORD dwRipFlags, DWORD dwRipPID)
{
    NtUserSetRipFlags(dwRipFlags, dwRipPID);
}

VOID SetDbgTag(int tag, DWORD dwBitFlags)
{
    NtUserSetDbgTag(tag, dwBitFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\clmsg.c ===
/****************************** Module Header ******************************\
* Module Name: ClMsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Includes the mapping table for messages when calling the server.
*
* 04-11-91 ScottLu Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define fnINDESTROYCLIPBRD      fnDWORD
#define fnOUTDWORDDWORD         fnDWORD
#define fnPOWERBROADCAST        fnDWORD
#define fnLOGONNOTIFY           fnKERNELONLY
#define fnINLPKDRAWSWITCHWND    fnKERNELONLY

#define MSGFN(func) fn ## func
#define FNSCSENDMESSAGE CFNSCSENDMESSAGE

#include "messages.h"

#if DBG
BOOL gfTurboDWP = TRUE;
#endif

#define BEGIN_CALLWINPROC(fInsideHook, lRet)                            \
    PCLIENTTHREADINFO pcti = GetClientInfo()->pClientThreadInfo;        \
    BOOL fCallBack = ((pcti!=NULL) &&                                   \
             TEST_BOOL_FLAG(pcti->CTIF_flags, CTIF_INCALLBACKMESSAGE)); \
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame \
        = {                                                             \
            sizeof(ActivationFrame),                                    \
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER \
        };                                                              \
    fInsideHook = FALSE;                                                \
                                                                        \
    if (!fCallBack) {                                                   \
        RtlActivateActivationContextUnsafeFast(                         \
            &ActivationFrame,                                           \
            pActCtx);                                                   \
                                                                        \
        fInsideHook = _BeginIfHookedUserApiHook();                      \
    }                                                                   \
                                                                        \
    __try {                                                             \

#define END_CALLWINPROC(fInsideHook)                                    \
    } __finally {                                                       \
        if (!fCallBack) {                                               \
            if (fInsideHook) {                                          \
                _EndUserApiHook();                                      \
            }                                                           \
            RtlDeactivateActivationContextUnsafeFast(                   \
                &ActivationFrame);                                      \
        }                                                               \
    }


/***************************************************************************\
* UserCallWinProc
*
* Setups everything to finally call a Win32 WNDPROC
*
* History:
* 27-Apr-2000  jstall     Rewrote to support "lightweight hooks"
\***************************************************************************/

LRESULT
UserCallWinProc(
    PACTIVATION_CONTEXT pActCtx,
    WNDPROC pfn,
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fInsideHook;
    LRESULT lRet = 0;

    BEGIN_CALLWINPROC(fInsideHook, lRet)
        BOOL fOverride = fInsideHook && IsMsgOverride(msg, &guah.uoiWnd.mm);

        pfn = MapKernelClientFnToClientFn(pfn);

        if (fOverride) {
            /*
             * NOTE: It is important that the same lRet is passed to all three
             * calls, allowing the Before and After OWP's to examine the value.
             */
            PVOID pvCookie = NULL;
            if (!guah.uoiWnd.pfnBeforeOWP(hwnd, msg, wParam, lParam, &lRet, &pvCookie)) {
                lRet = InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn),
                                           hwnd,
                                           msg,
                                           wParam,
                                           lParam);
                guah.uoiWnd.pfnAfterOWP(hwnd, msg, wParam, lParam, &lRet, &pvCookie);
            }
        } else {
            lRet = InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn),
                                       hwnd,
                                       msg,
                                       wParam,
                                       lParam);
        }
    END_CALLWINPROC(fInsideHook)

    return lRet;
}


/***************************************************************************\
* UserCallWinProcCheckWow
*
* Sets up everything to finally call a Win32 or WOW WNDPROC.
*
* History:
* 27-Apr-2000  jstall     Rewrote to support "lightweight hooks"
\***************************************************************************/

LRESULT
UserCallWinProcCheckWow(
    PACTIVATION_CONTEXT pActCtx,
    WNDPROC pfn,
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    PVOID pww,
    BOOL fEnableLiteHooks)
{
    BOOL fInsideHook;
    LRESULT lRet = 0;

    BEGIN_CALLWINPROC(fInsideHook, lRet)

        BOOL fOverride = fInsideHook && fEnableLiteHooks && IsMsgOverride(msg, &guah.uoiWnd.mm);

        pfn = MapKernelClientFnToClientFn(pfn);

        if (fOverride) {
            /*
             * NOTE: It is important that the same lRet is passed to all three
             * calls, allowing the Before and After OWP's to examine the value.
             */
            void * pvCookie = NULL;
            if (guah.uoiWnd.pfnBeforeOWP(hwnd, msg, wParam, lParam, &lRet, &pvCookie)) {
                goto DoneCalls;
            }

            lRet = (IsWOWProc(pfn) ? (*pfnWowWndProcEx)(hwnd, msg, wParam, lParam, PtrToUlong(pfn), KPVOID_TO_PVOID(pww)) :
                InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn), hwnd, msg, wParam, lParam));

            if (guah.uoiWnd.pfnAfterOWP(hwnd, msg, wParam, lParam, &lRet, &pvCookie)) {
                // Fall through and exit normally
            }
DoneCalls:
            ;
        } else {
            lRet = (IsWOWProc(pfn) ? (*pfnWowWndProcEx)(hwnd, msg, wParam, lParam, PtrToUlong(pfn), KPVOID_TO_PVOID(pww)) :
                InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn), hwnd, msg, wParam, lParam));
        }
    END_CALLWINPROC(fInsideHook)

    return lRet;
#ifdef _WIN64
    UNREFERENCED_PARAMETER(pww);
#endif // _WIN64
}


/***************************************************************************\
* UserCallDlgProcCheckWow
*
* Setups everything to finally call a Win32 or WOW DLGPROC
*
* History:
* 27-Apr-2000  jstall     Rewrote to support "lightweight hooks"
\***************************************************************************/

BOOL
UserCallDlgProcCheckWow(
    PACTIVATION_CONTEXT pActCtx,
    DLGPROC pfn,
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    PVOID pww,
    INT_PTR * pret)
{
    BOOL fInsideHook;
    INT_PTR fRet = 0;
    BOOL fHandled = FALSE;

    BEGIN_CALLWINPROC(fInsideHook, fRet)

        BOOL fOverride = fInsideHook && IsMsgOverride(msg, &guah.uoiDlg.mm);

        pfn = MapKernelClientFnToClientFn(pfn);

        if (fOverride) {
            /*
             * NOTE: It is important that the same lRet is passed to all three
             * calls, allowing the Before and After OWP's to examine the value.
             */
            void * pvCookie = NULL;
            if (guah.uoiDlg.pfnBeforeOWP(hwnd, msg, wParam, lParam, (LRESULT*) &fRet, &pvCookie)) {
                fHandled = TRUE;
                goto DoneCalls;
            }

            fRet = (IsWOWProc(pfn) ? (*pfnWowDlgProcEx)(hwnd, msg, wParam, lParam, PtrToUlong(pfn), KPVOID_TO_PVOID(pww)) :
                InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn), hwnd, msg, wParam, lParam));

            if (guah.uoiDlg.pfnAfterOWP(hwnd, msg, wParam, lParam, (LRESULT*) &fRet, &pvCookie)) {
                fHandled = TRUE;
                // Fall through and exit normally
            }
DoneCalls:
            ;
        } else {
            fRet = (IsWOWProc(pfn) ? (*pfnWowDlgProcEx)(hwnd, msg, wParam, lParam, PtrToUlong(pfn), KPVOID_TO_PVOID(pww)) :
                InternalCallWinProc((WNDPROC)KPVOID_TO_PVOID(pfn), hwnd, msg, wParam, lParam));
        }

    END_CALLWINPROC(fInsideHook)

    *pret = fRet;

    return fHandled;
#ifdef _WIN64
    UNREFERENCED_PARAMETER(pww);
#endif // _WIN64
}


/***************************************************************************\
* GetMouseKeyState
*
* Returns the state of mouse and keyboard keys that are sent
* in a mouse message.
*
* History:
* 12-Nov-1998 adams     Created.
\***************************************************************************/

WORD
GetMouseKeyState(void)
{
    WORD keystate;

    /*
     * Note that it is more efficient to call GetKeyState for each
     * key than to call GetKeyboardState, since the keys we are testing
     * are cached and don't require a trip to the kernel to fetch.
     */

#define TESTANDSETKEYSTATE(x)            \
    if (GetKeyState(VK_##x) & 0x8000) {  \
        keystate |= MK_##x;              \
    }

    keystate = 0;
    TESTANDSETKEYSTATE(LBUTTON)
    TESTANDSETKEYSTATE(RBUTTON)
    TESTANDSETKEYSTATE(MBUTTON)
    TESTANDSETKEYSTATE(XBUTTON1)
    TESTANDSETKEYSTATE(XBUTTON2)
    TESTANDSETKEYSTATE(SHIFT)
    TESTANDSETKEYSTATE(CONTROL)

    return keystate;
}

/***************************************************************************\
* These are client side thunks for server side window procs. This is being
* done so that when an app gets a wndproc via GetWindowLong, GetClassLong,
* or GetClassInfo, it gets a real callable address - some apps don't call
* CallWindowProc, but call the return ed address directly.
*
* 01-13-92 ScottLu Created.
* 03-Dec-1993 mikeke  added client side handling of some messages
\***************************************************************************/

LRESULT WINAPI DesktopWndProcWorker(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    PWND pwnd;

    if (FWINDOWMSG(message, FNID_DESKTOP)) {
        return CsSendMessage(hwnd, message, wParam, lParam,
                0L, FNID_DESKTOP, fAnsi);
    }

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);

}

LRESULT WINAPI DesktopWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DesktopWndProcWorker(hwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI DesktopWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DesktopWndProcWorker(hwnd, message, wParam, lParam, FALSE);
}

/***************************************************************************\
* These are client side thunks for server side window procs. This is being
* done so that when an app gets a wndproc via GetWindowLong, GetClassLong,
* or GetClassInfo, it gets a real callable address - some apps don't call
* CallWindowProc, but call the return ed address directly.
*
* 01-13-92 ScottLu Created.
* 03-Dec-1993 mikeke  added client side handling of some messages
\***************************************************************************/

LRESULT WINAPI MenuWndProcWorker(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    PWND pwnd;

    if (FWINDOWMSG(message, FNID_MENU)) {
        return CsSendMessage(hwnd, message, wParam, lParam,
                0L, FNID_MENU, fAnsi);
    }

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    switch (message) {
    case WM_LBUTTONDBLCLK:
    case WM_NCLBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_NCRBUTTONDBLCLK:

        /*
         * Ignore double clicks on these windows.
         */
        break;

    case WM_DESTROY:
        break;

    default:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }

    return 0;
}

LRESULT WINAPI MenuWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return MenuWndProcWorker(hwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI MenuWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return MenuWndProcWorker(hwnd, message, wParam, lParam, FALSE);
}

/***************************************************************************\
\***************************************************************************/


LRESULT WINAPI ScrollBarWndProcWorker(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    PSBWND psbwnd;
    LPSCROLLINFO lpsi;
    PSBDATA pw;

    if (FWINDOWMSG(message, FNID_SCROLLBAR)) {
        return CsSendMessage(hwnd, message, wParam, lParam,
                0L, FNID_SCROLLBAR, fAnsi);
    }

    if ((psbwnd = (PSBWND)ValidateHwnd(hwnd)) == NULL)
        return 0;

    switch (message) {
    case WM_GETDLGCODE:
        return DLGC_WANTARROWS;

    case SBM_GETPOS:
        return (LONG)psbwnd->SBCalc.pos;

    case SBM_GETRANGE:
        *((LPINT)wParam) = psbwnd->SBCalc.posMin;
        *((LPINT)lParam) = psbwnd->SBCalc.posMax;
        return 0;

    case SBM_GETSCROLLINFO:
        lpsi = (LPSCROLLINFO)lParam;
        if ((lpsi->cbSize != sizeof(SCROLLINFO)) &&
            (lpsi->cbSize != sizeof(SCROLLINFO) - 4)) {
            RIPMSG0(RIP_ERROR, "SCROLLINFO: invalid cbSize");
            return FALSE;
        }

        if (lpsi->fMask & ~SIF_MASK)
        {
            RIPMSG0(RIP_ERROR, "SCROLLINFO: Invalid fMask");
            return FALSE;
        }

        pw = (PSBDATA)KPSBDATA_TO_PSBDATA(&(psbwnd->SBCalc));
        return(NtUserSBGetParms(hwnd, SB_CTL, pw, lpsi));

    case SBM_GETSCROLLBARINFO:
        return NtUserGetScrollBarInfo(hwnd, OBJID_CLIENT, (PSCROLLBARINFO)lParam);

    default:
        return DefWindowProcWorker((PWND)psbwnd, message,
                wParam, lParam, fAnsi);
    }
}


LRESULT WINAPI ScrollBarWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return ScrollBarWndProcWorker(hwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI ScrollBarWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return ScrollBarWndProcWorker(hwnd, message, wParam, lParam, FALSE);
}


/***************************************************************************\
* SendMessage
*
* Translates the message, calls SendMessage on server side.
*
* 04-11-91 ScottLu  Created.
* 04-27-92 DarrinM  Added code to support client-to-client SendMessages.
\***************************************************************************/

LRESULT SendMessageWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    HWND hwnd = HWq(pwnd);
    PCLIENTINFO pci;
    PCLS pcls;
    BOOLEAN fAnsiRecv;
    BOOLEAN fNeedTranslation = FALSE;
    BOOLEAN bDoDbcsMessaging = FALSE;
    LRESULT lRet;

    UserAssert(pwnd);

    /*
     * Pass DDE messages to the server.
     */
    if (message >= WM_DDE_FIRST && message <= WM_DDE_LAST)
        goto lbServerSendMessage;

    /*
     * Server must handle inter-thread SendMessages and SendMessages
     * to server-side procs.
     */
    if ((PtiCurrent() != GETPTI(pwnd)) || TestWF(pwnd, WFSERVERSIDEPROC))
        goto lbServerSendMessage;

    /*
     * Server must handle hooks (at least for now).
     */
    pci = GetClientInfo();
    if (IsHooked(pci, (WHF_CALLWNDPROC | WHF_CALLWNDPROCRET))) {
lbServerSendMessage:
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                FNID_SENDMESSAGE, fAnsi);
    }

    /*
     * If the sender and the receiver are both ANSI or both UNICODE
     * then no message translation is necessary.
     *
     * EditWndProc may need to go to the server for translation if we
     * are calling vanilla EditWndProc from SendMessageA and the edit
     * control is currently subclassed Ansi but the edit control is
     * stored Unicode.
     */
    fAnsiRecv = !!(TestWF(pwnd, WFANSIPROC));
    if (!fAnsi != !fAnsiRecv) {

        /*
         * Translation might be necessary between sender and receiver,
         * check to see if this is one of the messages we translate.
         */
        switch (message) {
        case WM_CHARTOITEM:
        case EM_SETPASSWORDCHAR:
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_MENUCHAR:
        case WM_IME_CHAR:
        case WM_IME_COMPOSITION:
            if (fAnsi) {
                /*
                 * Setup DBCS Messaging for WM_CHAR...
                 */
                BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_CLIENTA(message,wParam,TRUE);

                /*
                 * Convert wParam to Unicode...
                 */
                RtlMBMessageWParamCharToWCS(message, &wParam);

                /*
                 * The message has been converted to Unicode.
                 */
                fAnsi = FALSE;
            } else {
                POINT ptZero = {0,0};
                /*
                 * Convert wParam to ANSI...
                 */
                RtlWCSMessageWParamCharToMB(message, &wParam);

                /*
                 * Let's DBCS messaging for WM_CHAR....
                 */
                BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_CLIENTW(
                    hwnd,message,wParam,lParam,0,ptZero,bDoDbcsMessaging);

                /*
                 * The message has been converted to ANSI.
                 */
                fAnsi = TRUE;
            }
            break;

        case EM_SETSEL:
        case EM_GETSEL:
        case CB_GETEDITSEL:
            if (IS_DBCS_ENABLED()) {
                RIPERR1(ERROR_INVALID_PARAMETER,
                        RIP_WARNING,
                        "Invalid DBCS message (%x) to SendMessageWorker",message);
            }
            //
            // Fall down...

        default:
            if ((message < WM_USER) && MessageTable[message].bThunkMessage) {
                fNeedTranslation = TRUE;
            }
        }
    }

#ifndef LATER
    /*
     * If the window has a client side worker proc and has
     * not been subclassed, dispatch the message directly
     * to the worker proc.  Otherwise, dispatch it normally.
     */
    pcls = REBASEALWAYS(pwnd, pcls);

    if ((!IsInsideUserApiHook()) &&
        (pcls->fnid >= FNID_CONTROLSTART && pcls->fnid <= FNID_CONTROLEND) &&
        ((KERNEL_ULONG_PTR)pwnd->lpfnWndProc == FNID_TO_CLIENT_PFNW_KERNEL(pcls->fnid) ||
         (KERNEL_ULONG_PTR)pwnd->lpfnWndProc == FNID_TO_CLIENT_PFNA_KERNEL(pcls->fnid))) {
        PWNDMSG pwm = &gSharedInfo.awmControl[pcls->fnid - FNID_START];

        /*
         * If this message is not processed by the control, call
         * xxxDefWindowProc
         */
        if (pwm->abMsgs && ((message > pwm->maxMsgs) ||
                !((pwm->abMsgs)[message / 8] & (1 << (message & 7))))) {

            /*
             * Special case dialogs so that we can ignore unimportant
             * messages during dialog creation.
             */
            if (pcls->fnid == FNID_DIALOG &&
                    PDLG(pwnd) && PDLG(pwnd)->lpfnDlg != NULL) {
                /*
                 * If A/W translation are needed for Dialog,
                 * it should go to kernel side to perform proper message.
                 * DefDlgProcWorker will call aplication's DlgProc directly
                 * without A/W conversion.
                 */
                if (fNeedTranslation) {
                    goto lbServerSendMessage;
                }
                /*
                 * Call woker procudure.
                 */
            SendMessageToWorker1Again:
                lRet = ((PROC)(FNID_TO_CLIENT_PFNWORKER(pcls->fnid)))(pwnd, message, wParam, lParam, fAnsi);
                /*
                 * if we have DBCS TrailingByte that should be sent, send it here..
                 */
                DISPATCH_DBCS_MESSAGE_IF_EXIST(message,wParam,bDoDbcsMessaging,SendMessageToWorker1);

                return lRet;
            } else {
                /*
                 * Call worker procedure.
                 */
            SendMessageToDefWindowAgain:
                lRet = DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
                /*
                 * if we have DBCS TrailingByte that should be sent, send it here..
                 */
                 DISPATCH_DBCS_MESSAGE_IF_EXIST(message,wParam,bDoDbcsMessaging,SendMessageToDefWindow);

                return lRet;
            }
        } else {
            /*
             * Call woker procudure.
             */
        SendMessageToWorker2Again:
            lRet = ((PROC)(FNID_TO_CLIENT_PFNWORKER(pcls->fnid)))(pwnd, message, wParam, lParam, fAnsi);

            /*
             * if we have DBCS TrailingByte that should be sent, send it here..
             */
            DISPATCH_DBCS_MESSAGE_IF_EXIST(message,wParam,bDoDbcsMessaging,SendMessageToWorker2);

            return lRet;
        }
    }
#endif

    /*
     * If this message needs to be translated, go through the kernel.
     */
    if (fNeedTranslation) {
        goto lbServerSendMessage;
    }

    /*
     * Call Client Windows procudure.
     */
SendMessageToWndProcAgain:
    lRet = UserCallWinProcCheckWow(pwnd->pActCtx, (WNDPROC)pwnd->lpfnWndProc, hwnd, message, wParam, lParam, &(pwnd->state), TRUE);

    /*
     * if we have DBCS TrailingByte that should be sent, send it here..
     */
    DISPATCH_DBCS_MESSAGE_IF_EXIST(message,wParam,bDoDbcsMessaging,SendMessageToWndProc);

    return lRet;
}

// LATER!!! can this somehow be combined or subroutinized with SendMessageWork
// so we don't have to copies of 95% identical code.

/***************************************************************************\
* SendMessageTimeoutWorker
*
* Translates the message, calls SendMessageTimeout on server side.
*
* 07-21-92 ChrisBB  Created/modified SendMessageWorkder
\***************************************************************************/

LRESULT SendMessageTimeoutWorker(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    PULONG_PTR lpdwResult,
    BOOL fAnsi)
{
    SNDMSGTIMEOUT smto;

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (message & RESERVED_MSG_BITS) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"message\" (%ld) to SendMessageTimeoutWorker",
                message);

        return(0);
    }

    if (fuFlags & ~SMTO_VALID) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid dwFlags (%x) for SendMessageTimeout\n", fuFlags);
        return(0);
    }

    if (lpdwResult != NULL)
        *lpdwResult = 0L;

    /*
     * Always send broadcast requests straight to the server.
     * Note: the xParam is used to id if it's from timeout or
     * from an normal sendmessage.
     */
    smto.fuFlags = fuFlags;
    smto.uTimeout = uTimeout;
    smto.lSMTOReturn = 0;
    smto.lSMTOResult = 0;

    /*
     * Thunk through a special sendmessage for -1 hwnd's so that the general
     * purpose thunks don't allow -1 hwnd's.
     */
    if (hwnd == (HWND)-1 || hwnd == (HWND)0x0000FFFF) {
        /*
         * Get a real hwnd so the thunks will validation ok. Note that since
         * -1 hwnd is really rare, calling GetDesktopWindow() here is not a
         * big deal.
         */
        hwnd = GetDesktopWindow();

        CsSendMessage(hwnd, message, wParam, lParam,
                (ULONG_PTR)&smto, FNID_SENDMESSAGEFF, fAnsi);
    } else {
        CsSendMessage(hwnd, message, wParam, lParam,
                (ULONG_PTR)&smto, FNID_SENDMESSAGEEX, fAnsi);
    }

    if (lpdwResult != NULL)
         *lpdwResult = smto.lSMTOResult;

    return smto.lSMTOReturn;
}

#ifdef LAME_BUTTON

PLAMEBTNPROC gpfnCommentReport;

VOID LoadCommentReportIfNeeded(
    VOID)
{
    if (gpfnCommentReport == NULL) {
        HMODULE hmod = LoadLibrary(L"LAMEBTN.DLL");

        if (hmod != NULL) {
            gpfnCommentReport = (PLAMEBTNPROC)GetProcAddress(hmod, "CommentReport");
            if (gpfnCommentReport == NULL) {
                FreeLibrary(hmod);
            }
        }
    }
}

void CallLameButtonHandler(PWND pwnd, HWND hwnd)
{
    UserAssert(TestWF(pwnd, WEFLAMEBUTTON));

    LoadCommentReportIfNeeded();

    if (gpfnCommentReport != NULL) {
        (*gpfnCommentReport)(hwnd, pwnd->pStackTrace);
    }
}
#endif // LAME_BUTTON


void CopyMsgMask(
    MSGMASK * pDest,
    MSGMASK * pSrc,
    BYTE * rgbLocal,
    DWORD cbMax
    )
{
    if ((pSrc->rgb != NULL) && (pSrc->cb > 0)) {
        pDest->rgb = rgbLocal;
        pDest->cb  = min(cbMax, pSrc->cb);
        CopyMemory(pDest->rgb, pSrc->rgb, pDest->cb);
    } else {
        pDest->rgb = NULL;
        pDest->cb  = 0;
    }
}


/***************************************************************************\
* InitUserApiHook
*
* This function gets called when the module that contains the UserApiHook's
* gets loaded. The UserApiHook is installed by calling
* RegisterUserApiHook and is loaded on demand by xxxCreateWindowEx and/or
* xxxDefWindowProc. The loading/unloading is controlled through the library
* management routines. The function calls the initialization function in the
* module and then sets up our global variables.
*
* We keep 2 reference counts. One counts calls to LoadLibrary/FreeLibrary. When
* this goes to zero, we can stop calling out to the substitute UserApiHook's.
* The other gets incremented when we do an actual callout to the substitute
* UserApiHook and decremented on return. We can't actually unload the module
* until this count goes to zero too (i.e. we aren't in a callout).
*
* History:
* 10-Mar-2000 JerrySh   Created.
* 16-May-2000 JStall    Changed to support uninitialize callback
* 12-Feb-2001 Mohamed   Added the check for read-only on reset ptr.
\***************************************************************************/
BOOL InitUserApiHook(
    HMODULE hmod,
    ULONG_PTR offPfnInitUserApiHook)
{
    INITUSERAPIHOOK pfnInitUserApi = NULL;
    USERAPIHOOK uahTemp;

    BOOL bUpdate= FALSE;
    BOOL retval = FALSE;

    /*
     * If we're loading for the first time, call the initialization routine.
     */
    ResetUserApiHook(&uahTemp);
    pfnInitUserApi = (INITUSERAPIHOOK)((ULONG_PTR)hmod + offPfnInitUserApiHook);
    bUpdate = pfnInitUserApi(UIAH_INITIALIZE, &uahTemp);

    /*
     * Check that the value of pfnForceResetUserApiHook hasn't been changed
     * by client since this should be treated as read-only.
     */
    if ((!bUpdate) || (uahTemp.cbSize <= 0) || (uahTemp.pfnForceResetUserApiHook != ForceResetUserApiHook)) {
        return FALSE;
    }

    RtlEnterCriticalSection(&gcsUserApiHook);

    /*
     * Need to check this again inside critical section.
     */
    if (ghmodUserApiHook == NULL) {
        UserAssertMsg0(gpfnInitUserApi == NULL, "Ensure gpfnInitUserApi not set");

        /*
         * Save the global state if the init routine succeeded.
         * Copy the hooked functions
         */
        UserAssert(gcLoadUserApiHook == 0);
        gcLoadUserApiHook   = 1;
        gfUserApiHook       = TRUE;     // Turn calling the hooks on
        ghmodUserApiHook    = hmod;
        gpfnInitUserApi     = pfnInitUserApi;

        CopyMemory(&guah, &uahTemp, uahTemp.cbSize);

        /*
         * Copy the message-filter bit-mask
         */
        CopyMsgMask(&guah.mmDWP, &uahTemp.mmDWP, grgbDwpLiteHookMsg, sizeof(grgbDwpLiteHookMsg));
        CopyMsgMask(&guah.uoiWnd.mm, &uahTemp.uoiWnd.mm, grgbWndLiteHookMsg, sizeof(grgbWndLiteHookMsg));
        CopyMsgMask(&guah.uoiDlg.mm, &uahTemp.uoiDlg.mm, grgbDlgLiteHookMsg, sizeof(grgbDlgLiteHookMsg));

        retval = TRUE;
    } else if (ghmodUserApiHook == hmod) {
        /*
         * This is the UserApiHook module, so bump up the reference count.
         */
        UserAssert(gcLoadUserApiHook < MAXLONG);
        UserAssertMsg0(gpfnInitUserApi == pfnInitUserApi, "Need to match from before");
        ++gcLoadUserApiHook;
        retval = TRUE;
    }

    RtlLeaveCriticalSection(&gcsUserApiHook);

    if (!retval) {
        /*
         * Initialization failed, so ClientLoadLibrary() is going to
         * FreeLibrary().  Notify before we do this.
         */
        RIPMSG2(RIP_WARNING, "Uninit from Init Load %lx Call %lx", gcLoadUserApiHook, gcCallUserApiHook);
        pfnInitUserApi(UIAH_UNINITIALIZE, NULL);
    }

    return retval;
}

/***************************************************************************\
* ClearUserApiHook
*
* This function gets called when the module that contains the UserApiHook
* is about to get unloaded. The unload happens when UnregisterUserApiHook
* is called or the process that registered it exits. If this is the last unload,
* we'll clear the globals containing the UserApiHook function addresses so we
* don't do any more callouts. If we're not currently doing a callout, we'll
* indicate that it's OK to unload the module. Otherwise, it'll get unloaded
* when the last callout completes.
*
* History:
* 10-Mar-2000 JerrySh   Created.
* 16-May-2000 JStall    Changed to support uninitialize callback
* 03-Apr-2001 Mohamed   Added support for UIAH_UNHOOK logic.
\***************************************************************************/
BOOL ClearUserApiHook(
    HMODULE hmod)
{
    INITUSERAPIHOOK pfnInitUserApi = NULL;
    INITUSERAPIHOOK pfnSignalInitUserApi = NULL;

    /*
     * If this is the last reference to the UserApiHook module, clear the
     * global state.
     */
    RtlEnterCriticalSection(&gcsUserApiHook);
    if (ghmodUserApiHook == hmod) {
        UserAssert(gcLoadUserApiHook > 0);
        UserAssertMsg0(gpfnInitUserApi != NULL, "Ensure gpfnInitUserApi properly set");
        UserAssertMsg0(ghmodUserApiHook != NULL, "Should still have valid ghmodUserApiHook");
        pfnInitUserApi = gpfnInitUserApi;

        if (--gcLoadUserApiHook == 0) {
            /*
             * Use the internal functions, so turn calling the hooks off.  It is
             * very important to set gfUserApiHook FALSE here so that new calls
             * do not increment gcCallUserApiHook and keep the DLL from being
             * unloaded.
             */
            gfUserApiHook = FALSE;
            ResetUserApiHook(&guah);

            if (gcCallUserApiHook == 0) {
                /*
                 * We're not calling into it, we can free the module.
                 *
                 * FreeLibrary() will be called on this DLL in
                 * ClientFreeLibrary() when this function returns.
                 */
                hmod = ghmodUserApiHook;
                ghmodUserApiHook = NULL;
                gpfnInitUserApi = NULL;
            } else {
                /*
                 * We're still calling into the module, so we can't free it yet.
                 * This means we have to delay the last callback with UIAH_UNINITIALIZE
                 * until we actually free the library.  This will occur in
                 * _EndUserApiHook().  However, we set pfnSignalInitUserApi to initiate
                 * a callback with UIAH_UNHOOK to alert the module to this fact.
                 */
                hmod = NULL;
                pfnInitUserApi = NULL;
                pfnSignalInitUserApi = gpfnInitUserApi;
                ++gcLoadUserApiHook;
            }
        } else {
            /*
             * This part of code should never be executed since we guard against
             * multiple loads of same DLL in xxxLoadUserApiHook.  However, since
             * this is a load count and could conceivably be greater than 1,
             * this warning message is inserted to signal such an event.
             */
            RIPMSG1(RIP_WARNING, " gcLoadUserApiHook: %lx > 1 in Clear Load", gcLoadUserApiHook);
        }
    }

    RtlLeaveCriticalSection(&gcsUserApiHook);

    /*
     * Signal that hooks have been uninitialized but DLL can't be unloaded due to outstanding calls.
     */
    if (pfnSignalInitUserApi != NULL) {
        RIPMSG2(RIP_WARNING, "Unhook from Clear Load %lx Call %lx", gcLoadUserApiHook, gcCallUserApiHook);
        pfnSignalInitUserApi(UIAH_UNHOOK, NULL);

        /*
         * After having returned from the DLL, we revalidate the state of the hooking world again.
         * The outstanding call that we were deferring in favor of, could have completed by now
         * and finding the load count greater than zero, it ignored completing the deferred cleanup
         * which we must now do at this point.
         */
        RtlEnterCriticalSection(&gcsUserApiHook);
        UserAssert(gcLoadUserApiHook > 0);
        UserAssertMsg0(gpfnInitUserApi != NULL, "Ensure gpfnInitUserApi properly set");
        UserAssertMsg0(ghmodUserApiHook != NULL, "Should still have valid ghmodUserApiHook");
        pfnInitUserApi = gpfnInitUserApi;

        if (--gcLoadUserApiHook == 0) {
            if (gcCallUserApiHook == 0) {
                /*
                 * The outstanding call has completed while we were
                 * calling back and we can now safely clean up.
                 * FreeLibrary() will be called on this DLL in
                 * ClientFreeLibrary() when this function returns.
                 */
                hmod = ghmodUserApiHook;
                ghmodUserApiHook = NULL;
                gpfnInitUserApi = NULL;
            } else {
                /*
                 * The outstanding call into the DLL hasn't returned.  However, we are done
                 * from this point.  The DLL has been notified of UNHOOK situation and the
                 * rest of the cleanup will be done in _EndUserApiHook when the last call
                 * into the DLL returns.
                 */
                hmod = NULL;
                pfnInitUserApi = NULL;
            }
        } else {
            /*
             * This part of code should never be executed since we guard against
             * multiple loads of same DLL in xxxLoadUserApiHook.  However, since
             * this is a load count and could conceivably be greater than 1,
             * this warning message is inserted to signal such an event.
             */
            RIPMSG1(RIP_WARNING, " gcLoadUserApiHook: %lx > 1 in Clear Load", gcLoadUserApiHook);
        }
        RtlLeaveCriticalSection(&gcsUserApiHook);
    }

    /*
     * This is called in the case where the outstanding call into the DLL was completed in between
     * the two critical sections and we have completed the full cleanup at this end.
     */
    if (pfnInitUserApi != NULL) {
        RIPMSG2(RIP_WARNING, "Uninit from Clear Load %lx Call %lx", gcLoadUserApiHook, gcCallUserApiHook);
        pfnInitUserApi(UIAH_UNINITIALIZE, NULL);
    }

    return (hmod != NULL);
}


/***************************************************************************\
* DefaultOWP
*
* This function provides an empty OWP implementation that can be safely
* called while the UserApiHook DLL is being unloaded and we are resetting
* the states.
*
* History:
* 27-Apr-2000 JStall   Created.
\***************************************************************************/
BOOL CALLBACK DefaultOWP(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT * pr, void ** pvCookie)
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(pr);
    UNREFERENCED_PARAMETER(pvCookie);

    return FALSE;
}


/***************************************************************************\
* MDIRedrawFrame
*
*
* History:
* 20-Apr-2001 Mohamed Created.
\***************************************************************************/
void MDIRedrawFrame(
    HWND hwndChild,
    BOOL fAdd)
{
    BEGIN_USERAPIHOOK()
        guah.pfnMDIRedrawFrame(hwndChild, fAdd);
    END_USERAPIHOOK()
}

void RealMDIRedrawFrame(
    HWND hwndChild,
    BOOL fAdd)
{
    UNREFERENCED_PARAMETER(fAdd);
    NtUserRedrawFrame(hwndChild);
}


/***************************************************************************\
* ResetUserApiHook
*
* This function gets called to reset the UserApiHook function pointers to
* the internal (default) implementations of the functions.  This is done
* when any installed UserApiHook is being removed by calling
* UnregisterUserApiHook().
*
* History:
* 28-Mar-2000 JStall   Created.
* 28-Oct-2000 mohamed  Added GetSystemMetrics and SystemParametersInfo hooks.
\***************************************************************************/
void ResetUserApiHook(USERAPIHOOK * puah)
{
    puah->cbSize                   = sizeof(USERAPIHOOK);
    puah->pfnDefWindowProcA        = RealDefWindowProcA;
    puah->pfnDefWindowProcW        = RealDefWindowProcW;
    puah->mmDWP.rgb                = NULL;
    puah->mmDWP.cb                 = 0;
    puah->pfnGetScrollInfo         = RealGetScrollInfo;
    puah->pfnSetScrollInfo         = RealSetScrollInfo;
    puah->pfnEnableScrollBar       = RealEnableScrollBar;
    puah->pfnAdjustWindowRectEx    = RealAdjustWindowRectEx;
    puah->pfnSetWindowRgn          = RealSetWindowRgn;
    puah->uoiWnd.pfnBeforeOWP      = DefaultOWP;
    puah->uoiWnd.pfnAfterOWP       = DefaultOWP;
    puah->uoiWnd.mm.rgb            = NULL;
    puah->uoiWnd.mm.cb             = 0;
    puah->uoiDlg.pfnBeforeOWP      = DefaultOWP;
    puah->uoiDlg.pfnAfterOWP       = DefaultOWP;
    puah->uoiDlg.mm.rgb            = NULL;
    puah->uoiDlg.mm.cb             = 0;
    puah->pfnGetSystemMetrics      = RealGetSystemMetrics;
    puah->pfnSystemParametersInfoA = RealSystemParametersInfoA;
    puah->pfnSystemParametersInfoW = RealSystemParametersInfoW;
    puah->pfnForceResetUserApiHook = ForceResetUserApiHook;
    puah->pfnDrawFrameControl      = RealDrawFrameControl;
    puah->pfnDrawCaption           = RealDrawCaption;
    puah->pfnMDIRedrawFrame        = RealMDIRedrawFrame;
}


/***************************************************************************\
* ForceResetUserApiHook
*
* NOTE : This is an API function that is called by external clients.
*
* This function gets called to force a reset of the UserApiHook function
* pointers.  This is done usually by the hooked DLL in the case when it is
* about to be unloaded by anyone other than WindowManager and is done to
* prevent future calls into that DLL.  It is to be noted however, that
* WindowManger still believes that it is hooked
*
*  Note:
*        1- This function is meant to be called only by hooking dll inside
*           DllMain when recieving a DLL_PROCESS_DETACH message.  A check is
*           made on the LoaderLock to verify.
*        2- No serialization is done based on the assumption that the call
*           is made during DLL_PROCESS_DETACH and hence there is only the
*           main thread.
*
* History:
* 02-Feb-2001 mohamed  Created.
\***************************************************************************/
BOOL
ForceResetUserApiHook(
    HMODULE hmod)
{
    /*
     * Verify that the calling module is indeed the same hooking module and that
     * we are indeed being called from DllMain by verifying that we are inside
     * the loader lock.
     */

    if (ghmodUserApiHook != hmod || !_InsideLoaderLock()){
        return FALSE;
    }

    /*
     * Reset the function pointers back to Window Manager native functions and
     * reset the global dll initialization function pointer to prevent calls
     * into hooked dll with un\initialization messages.
     */

    ResetUserApiHook(&guah);
    gpfnInitUserApi = NULL;
    return TRUE;
}


/***************************************************************************\
* _EndUserApiHook
*
* This function gets called after each hooked API function call from
* END_USERAPIHOOK().  This provides a common place to clean up resources
* that were delayed because they were in use during the hooked function
* call.
*
* History:
* 28-Mar-2000 JStall    Created.
* 16-May-2000 JStall    Changed to support uninitialize callback
\***************************************************************************/
void _EndUserApiHook()
{
    UserAssert(gcCallUserApiHook > 0);
    if (InterlockedDecrement(&gcCallUserApiHook) == 0) {
        /*
         * If the load count went to zero, free the library.
         */
        if (gcLoadUserApiHook == 0) {
            HMODULE hmod = NULL;
            INITUSERAPIHOOK pfnInitUserApi = NULL;

            RtlEnterCriticalSection(&gcsUserApiHook);
            if (gcLoadUserApiHook == 0) {
                UserAssertMsg0(ghmodUserApiHook != NULL, "Should still have valid ghmodUserApiHook");
                UserAssertMsg0(gpfnInitUserApi != NULL, "Should still have valid gpfnInitUserApi");

                hmod                = ghmodUserApiHook;
                pfnInitUserApi      = gpfnInitUserApi;
                ghmodUserApiHook    = NULL;
                gpfnInitUserApi     = NULL;
            }

            RtlLeaveCriticalSection(&gcsUserApiHook);

            /*
             * Make the callback that we delayed from ClearUserApiHook()
             * because there was still an outstanding API call.
             */
            if (pfnInitUserApi != NULL) {
                RIPMSG2(RIP_WARNING, "Uninit from End Load %lx Call %lx", gcLoadUserApiHook, gcCallUserApiHook);
                pfnInitUserApi(UIAH_UNINITIALIZE, NULL);
            }

            if (hmod != NULL) {
                FreeLibrary(hmod);
            }
        }
    }
}

/***************************************************************************\
* DefWindowProcWorker
*
* Handles any messages that can be dealt with wholly on the client and
* passes the rest to the server.
*
* 03-31-92 DarrinM      Created.
\***************************************************************************/

LRESULT DefWindowProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    if (ghmodUserApiHook) {
        if (fAnsi) {
            return DefWindowProcA(HWq(pwnd), message, wParam, lParam);
        } else {
            return DefWindowProcW(HWq(pwnd), message, wParam, lParam);
        }
    }
    return RealDefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
}

LRESULT RealDefWindowProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    int icolBack;
    int icolFore;
    PWND pwndParent;
    HWND hwndDefIme;
    PWND pwndDefIme;
    PIMEUI pimeui;

#if DBG
    if (!gfTurboDWP) {
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                FNID_DEFWINDOWPROC, fAnsi);
    } else {
#endif

    if (FDEFWINDOWMSG(message, DefWindowMsgs)) {
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                FNID_DEFWINDOWPROC, fAnsi);
    } else if (!FDEFWINDOWMSG(message, DefWindowSpecMsgs)) {
        return 0;
    }

    /*
     * Important:  If you add cases to the switch statement below,
     *             add the messages to server.c's gawDefWindowSpecMsgs.
     *             Similarly if you add cases to dwp.c's DefWindowProc
     *             which can come from the client, add the messages
     *             to gawDefWindowMsgs.
     */

    switch (message) {
#ifdef LAME_BUTTON
    case WM_NCLBUTTONDOWN:
        if (wParam == HTLAMEBUTTON) {
            CallLameButtonHandler(pwnd, hwnd);
        }
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                   FNID_DEFWINDOWPROC, fAnsi);

    case WM_SYSCHAR:
        if(wParam == LAMEBUTTONHOTKEY && (HIWORD(lParam) & SYS_ALTERNATE) &&
           TestWF(pwnd, WEFLAMEBUTTON)) {
           CallLameButtonHandler(pwnd, hwnd);
        }
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                   FNID_DEFWINDOWPROC, fAnsi);

    case WM_SYSCOMMAND:
        if(wParam == SC_LAMEBUTTON) {
            CallLameButtonHandler(pwnd, hwnd);
        }
        return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                   FNID_DEFWINDOWPROC, fAnsi);
#endif // LAME_BUTTON

    case WM_HELP:
        {
        PWND  pwndDest;

        /*
         * If this window is a child window, Help message must be passed on
         * to it's parent; Else, this must be passed on to the owner window.
         */
        pwndDest = (TestwndChild(pwnd) ? pwnd->spwndParent : pwnd->spwndOwner);
        if (pwndDest) {
            pwndDest = REBASEPTR(pwnd, pwndDest);
            if (pwndDest != _GetDesktopWindow())
                return SendMessageW(HWq(pwndDest), WM_HELP, wParam, lParam);;
        }
        return(0L);
        }

    case WM_MOUSEWHEEL:
        if (TestwndChild(pwnd)) {
            pwndParent = REBASEPWND(pwnd, spwndParent);
            SendMessageW(HW(pwndParent), WM_MOUSEWHEEL, wParam, lParam);
        }
        break;

    case WM_CONTEXTMENU:
        if (TestwndChild(pwnd)) {
            pwndParent = REBASEPWND(pwnd, spwndParent);
            SendMessageW(HW(pwndParent), WM_CONTEXTMENU,
                    (WPARAM)hwnd, lParam);
        }
        break;

    /*
     * Default handling for WM_CONTEXTMENU support
     */
    case WM_RBUTTONUP:
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            lParam = MAKELONG(pwnd->rcClient.right - GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) + pwnd->rcClient.top);
        } else {
            lParam = MAKELONG(GET_X_LPARAM(lParam) + pwnd->rcClient.left, GET_Y_LPARAM(lParam) + pwnd->rcClient.top);
        }
        SendMessageWorker(pwnd, WM_CONTEXTMENU, (WPARAM)hwnd, lParam, fAnsi);
        break;

    case WM_APPCOMMAND:
        if (TestwndChild(pwnd)) {
            /*
             * Bubble the message to the parent
             */
            pwndParent = REBASEPWND(pwnd, spwndParent);
            return SendMessageW(HW(pwndParent), WM_APPCOMMAND, wParam, lParam);
        } else {
            /*
             * Call the server side to send the shell hook HSHELL_APPCOMMAND
             */
            return CsSendMessage(hwnd, WM_APPCOMMAND, wParam, lParam, 0L, FNID_DEFWINDOWPROC, fAnsi);
        }
        break;

    /*
     * Default handling for WM_APPCOMMAND support
     */
    case WM_NCXBUTTONUP:
    case WM_XBUTTONUP:
        {
            WORD cmd;
            WORD keystate;
            LPARAM lParamAppCommand;

            switch (GET_XBUTTON_WPARAM(wParam)) {
            case XBUTTON1:
                cmd = APPCOMMAND_BROWSER_BACKWARD;
                break;

            case XBUTTON2:
                cmd = APPCOMMAND_BROWSER_FORWARD;
                break;

            default:
                cmd = 0;
                break;
            }

            if (cmd == 0) {
                break;
            }

            cmd |= FAPPCOMMAND_MOUSE;
            if (message == WM_XBUTTONUP) {
                keystate = GET_KEYSTATE_WPARAM(wParam);
            } else {
                keystate = GetMouseKeyState();
            }

            lParamAppCommand = MAKELPARAM(keystate, cmd);
            SendMessageWorker(pwnd, WM_APPCOMMAND, (WPARAM)hwnd, lParamAppCommand, fAnsi);
            break;
        }

    case WM_WINDOWPOSCHANGED: {
        PWINDOWPOS ppos = (PWINDOWPOS)lParam;

        if (!(ppos->flags & SWP_NOCLIENTMOVE)) {
            POINT pt = {pwnd->rcClient.left, pwnd->rcClient.top};
            pwndParent = REBASEPWND(pwnd, spwndParent);

            if (pwndParent != _GetDesktopWindow()) {
                pt.x -= pwndParent->rcClient.left;
                pt.y -= pwndParent->rcClient.top;
            }

            SendMessageWorker(pwnd, WM_MOVE, FALSE, MAKELPARAM(pt.x, pt.y), fAnsi);
        }

        if ((ppos->flags & SWP_STATECHANGE) || !(ppos->flags & SWP_NOCLIENTSIZE)) {
            UINT cmd;
            RECT rc;

            if (TestWF(pwnd, WFMINIMIZED))
                cmd = SIZEICONIC;
            else if (TestWF(pwnd, WFMAXIMIZED))
                cmd = SIZEFULLSCREEN;
            else
                cmd = SIZENORMAL;

        /*
         *  HACK ALERT:
         *  If the window is minimized then the real client width and height are
         *  zero. But, in win3.1 they were non-zero. Under Chicago, PrintShop
         *  Deluxe ver 1.2 hits a divide by zero. To fix this we fake the width
         *  and height for old apps to be non-zero values.
         *  GetClientRect does that job for us.
         */
            _GetClientRect(pwnd, &rc);
            SendMessageWorker(pwnd, WM_SIZE, cmd,
                    MAKELONG(rc.right - rc.left,
                    rc.bottom - rc.top), fAnsi);
        }
        return 0;
        }

    case WM_MOUSEACTIVATE: {
        PWND pwndT;
        LRESULT lt;

        /*
         * GetChildParent returns either a kernel pointer or NULL.
         */
        pwndT = GetChildParent(pwnd);
        if (pwndT != NULL) {
            pwndT = REBASEPTR(pwnd, pwndT);
            lt = SendMessageWorker(pwndT, WM_MOUSEACTIVATE, wParam, lParam, fAnsi);
            if (lt != 0)
                return lt;
        }

        /*
         * Moving, sizing or minimizing? Activate AFTER we take action.
         */
        return ((LOWORD(lParam) == HTCAPTION) && (HIWORD(lParam) == WM_LBUTTONDOWN )) ?
                (LONG)MA_NOACTIVATE : (LONG)MA_ACTIVATE;
        }

    case WM_CTLCOLORSCROLLBAR:
        if ((gpsi->BitCount < 8) ||
            (SYSRGB(3DHILIGHT) != SYSRGB(SCROLLBAR)) ||
            (SYSRGB(3DHILIGHT) == SYSRGB(WINDOW)))
        {
            /*
             * Remove call to UnrealizeObject().  GDI Handles this for
             * brushes on NT.
             *
             * UnrealizeObject(ghbrGray);
             */

            SetBkColor((HDC)wParam, SYSRGB(3DHILIGHT));
            SetTextColor((HDC)wParam, SYSRGB(3DFACE));
            return((LRESULT)gpsi->hbrGray);
        }

        icolBack = COLOR_3DHILIGHT;
        icolFore = COLOR_BTNTEXT;
        goto SetColor;

    case WM_CTLCOLORBTN:
        if (pwnd == NULL)
            goto ColorDefault;

        if (TestWF(pwnd, WFWIN40COMPAT)) {
            icolBack = COLOR_3DFACE;
            icolFore = COLOR_BTNTEXT;
        } else {
            goto ColorDefault;
        }
        goto SetColor;

    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORMSGBOX:
        // We want static controls in dialogs to have the 3D
        // background color, but statics in windows to inherit
        // their parents' background.

        if (pwnd == NULL)
            goto ColorDefault;

        if (TestWF(pwnd, WFWIN40COMPAT)) {
            icolBack = COLOR_3DFACE;
            icolFore = COLOR_WINDOWTEXT;
            goto SetColor;
        }
        // ELSE FALL THRU...

    case WM_CTLCOLOR:              // here for WOW only
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLOREDIT:
      ColorDefault:
        icolBack = COLOR_WINDOW;
        icolFore = COLOR_WINDOWTEXT;

      SetColor:
      {
        SetBkColor((HDC)wParam, gpsi->argbSystem[icolBack]);
        SetTextColor((HDC)wParam, gpsi->argbSystem[icolFore]);
        return (LRESULT)(SYSHBRUSH(icolBack));
      }

    case WM_NCHITTEST:
        return FindNCHit(pwnd, (LONG)lParam);

    case WM_GETTEXT:
        if (wParam != 0) {

            LPWSTR lpszText;
            UINT   cchSrc;

            if (pwnd->strName.Length) {

                lpszText = REBASE(pwnd, strName.Buffer);
                cchSrc = (UINT)pwnd->strName.Length / sizeof(WCHAR);

                if (fAnsi) {

                    LPSTR lpName = (LPSTR)lParam;

                    /*
                     * Non-zero retval means some text to copy out.  Do not
                     * copy out more than the requested byte count
                     * 'chMaxCount'.
                     */
                    cchSrc = WCSToMB(lpszText,
                                     cchSrc,
                                     (LPSTR *)&lpName,
                                     (UINT)(wParam - 1),
                                     FALSE);

                    lpName[cchSrc] = '\0';

                } else {

                    LPWSTR lpwName = (LPWSTR)lParam;

                    cchSrc = min(cchSrc, (UINT)(wParam - 1));
                    RtlCopyMemory(lpwName, lpszText, cchSrc * sizeof(WCHAR));
                    lpwName[cchSrc] = 0;
                }

                return cchSrc;
            }

            /*
             * else Null terminate the text buffer since there is no text.
             */
            if (fAnsi) {
                ((LPSTR)lParam)[0] = 0;
            } else {
                ((LPWSTR)lParam)[0] = 0;
            }
        }

        return 0;

    case WM_GETTEXTLENGTH:
        if (pwnd->strName.Length) {
            UINT cch;
            if (fAnsi) {
                RtlUnicodeToMultiByteSize(&cch,
                                          REBASE(pwnd, strName.Buffer),
                                          pwnd->strName.Length);
            } else {
                cch = pwnd->strName.Length / sizeof(WCHAR);
            }
            return cch;
        }
        return 0L;

    case WM_QUERYDRAGICON:
        /*
         * If the window is WIN40COMPAT or has a kernel side procedure
         * do not attempt to look into the instance module
         */
        if (TestWF(pwnd, WFWIN40COMPAT) || TestWF(pwnd, WFSERVERSIDEPROC)) {
            return 0;
        }
        /*
         * For old apps, like the VB3 ones, try to load the icon from resources
         * This is how Win95 does.
         */
        return (LRESULT)LoadIconW(KHANDLE_TO_HANDLE(pwnd->hModule), MAKEINTRESOURCE(1));

    case WM_QUERYOPEN:
    case WM_QUERYENDSESSION:
    case WM_DEVICECHANGE:
    case WM_POWERBROADCAST:
        return TRUE;

    case WM_KEYDOWN:
        if (wParam == VK_F10) {
            return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                    FNID_DEFWINDOWPROC, fAnsi);
        }
        break;

    case WM_SYSKEYDOWN:
        if ((HIWORD(lParam) & SYS_ALTERNATE) || (wParam == VK_F10) ||
                (wParam == VK_ESCAPE))
            return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                    FNID_DEFWINDOWPROC, fAnsi);
        break;

    case WM_UNICHAR:
        if (wParam == UNICODE_NOCHAR) {
            return FALSE;
        }
        break;

    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        /*
         * Do default processing for keystrokes into owner draw listboxes.
         */
        return -1;

    case WM_ACTIVATE:
        if (LOWORD(wParam))
            return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                    FNID_DEFWINDOWPROC, fAnsi);
        break;

    case WM_SHOWWINDOW:
        if (lParam != 0)
            return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                    FNID_DEFWINDOWPROC, fAnsi);
        break;

    case WM_DROPOBJECT:
       return DO_DROPFILE;

    case WM_WINDOWPOSCHANGING:
        /*
         * If the window's size is changing, adjust the passed-in size
         */
        #define ppos ((WINDOWPOS *)lParam)
        if (!(ppos->flags & SWP_NOSIZE))
            return CsSendMessage(hwnd, message, wParam, lParam, 0L,
                    FNID_DEFWINDOWPROC, fAnsi);
        #undef ppos
        break;

    case WM_KLUDGEMINRECT:
        {
        SHELLHOOKINFO shi;
        LPRECT lprc = (LPRECT)lParam;

        shi.hwnd = (HWND)wParam;
        shi.rc.left = MAKELONG(lprc->left, lprc->top);
        shi.rc.top = MAKELONG(lprc->right, lprc->bottom);

        if (gpsi->uiShellMsg == 0)
            SetTaskmanWindow(NULL);
        if (SendMessageWorker(pwnd, gpsi->uiShellMsg, HSHELL_GETMINRECT,
                (LPARAM)&shi, fAnsi)) {
            //
            // Now convert the RECT back from two POINTS structures into two POINT
            // structures.
            //
            lprc->left   = (SHORT)LOWORD(shi.rc.left);  // Sign extend
            lprc->top    = (SHORT)HIWORD(shi.rc.left);  // Sign extend
            lprc->right  = (SHORT)LOWORD(shi.rc.top);   // Sign extend
            lprc->bottom = (SHORT)HIWORD(shi.rc.top);   // Sign extend
        }
        break;
        }

    case WM_NOTIFYFORMAT:
        if (lParam == NF_QUERY)
            return(TestWF(pwnd, WFANSICREATOR) ? NFR_ANSI : NFR_UNICODE);
        break;

    case WM_IME_KEYDOWN:
        if (fAnsi)
            PostMessageA(hwnd, WM_KEYDOWN, wParam, lParam);
        else
            PostMessageW(hwnd, WM_KEYDOWN, wParam, lParam);
        break;

    case WM_IME_KEYUP:
        if (fAnsi)
            PostMessageA(hwnd, WM_KEYUP, wParam, lParam);
        else
            PostMessageW(hwnd, WM_KEYUP, wParam, lParam);
        break;

    case WM_IME_CHAR:
        //if (TestCF(pwnd, CFIME))
        //    break;

        if ( fAnsi ) {
            if( IsDBCSLeadByteEx(THREAD_CODEPAGE(),(BYTE)(wParam >> 8)) ) {
                PostMessageA(hwnd,
                             WM_CHAR,
                             (WPARAM)((BYTE)(wParam >> 8)),   // leading byte
                             1L);
                PostMessageA(hwnd,
                             WM_CHAR,
                             (WPARAM)((BYTE)wParam),         // trailing byte
                             1L);
            }
            else
                PostMessageA(hwnd,
                             WM_CHAR,
                             (WPARAM)(wParam),
                             1L);
        } else {
            PostMessageW(hwnd, WM_CHAR, wParam, 1L);
        }
        break;

    case WM_IME_COMPOSITION:
        //if (TestCF(pwnd, CFIME))
        //    break;

        if (lParam & GCS_RESULTSTR) {
            HIMC  hImc;
            DWORD cbLen;

            if ((hImc = fpImmGetContext(hwnd)) == NULL_HIMC)
                goto dwpime_ToIMEWnd_withchk;

            if (fAnsi) {
                LPSTR pszBuffer, psz;

                /*
                 * ImmGetComposition returns the size of buffer needed in byte.
                 */
                if (!(cbLen = fpImmGetCompositionStringA(hImc, GCS_RESULTSTR, NULL, 0))) {
                    fpImmReleaseContext(hwnd, hImc);
                    goto dwpime_ToIMEWnd_withchk;
                }

                pszBuffer = psz = (LPSTR)UserLocalAlloc(HEAP_ZERO_MEMORY,
                                                        cbLen + sizeof(CHAR));

                if (pszBuffer == NULL) {
                    fpImmReleaseContext(hwnd, hImc);
                    goto dwpime_ToIMEWnd_withchk;
                }

                fpImmGetCompositionStringA(hImc, GCS_RESULTSTR, psz, cbLen);

                while (*psz) {
                    if (IsDBCSLeadByteEx(THREAD_CODEPAGE(),*psz)) {
                        if (*(psz+1)) {
                            SendMessageA( hwnd,
                                          WM_IME_CHAR,
                                          MAKEWPARAM(MAKEWORD(*(psz+1), *psz), 0),
                                          1L );
                            psz++;
                        }
                        psz++;
                    }
                    else
                        SendMessageA( hwnd,
                                      WM_IME_CHAR,
                                      MAKEWPARAM(MAKEWORD(*(psz++), 0), 0),
                                      1L );
                }

                UserLocalFree(pszBuffer);

                fpImmReleaseContext(hwnd, hImc);
            }
            else {
                LPWSTR pwszBuffer, pwsz;

                /*
                 * ImmGetComposition returns the size of buffer needed in byte
                 */
                if (!(cbLen = fpImmGetCompositionStringW(hImc, GCS_RESULTSTR, NULL, 0))) {
                    fpImmReleaseContext(hwnd, hImc);
                    goto dwpime_ToIMEWnd_withchk;
                }

                pwszBuffer = pwsz = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY,
                                                           cbLen + sizeof(WCHAR));

                if (pwszBuffer == NULL) {
                    fpImmReleaseContext(hwnd, hImc);
                    goto dwpime_ToIMEWnd_withchk;
                }

                fpImmGetCompositionStringW(hImc, GCS_RESULTSTR, pwsz, cbLen);

                while (*pwsz)
                    SendMessageW(hwnd, WM_IME_CHAR, MAKEWPARAM(*pwsz++, 0), 1L);

                UserLocalFree(pwszBuffer);

                fpImmReleaseContext(hwnd, hImc);
            }
        }

        /*
         * Fall through to send to Default IME Window with checking
         * activated hIMC.
         */

    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
dwpime_ToIMEWnd_withchk:
        //if (TestCF(pwnd, CFIME))
        //    break;

        if (GetClientInfo()->dwTIFlags & TIF_DISABLEIME) {
            break;
        }
        /*
         * We assume this Wnd uses DefaultIMEWindow.
         * If this window has its own IME window, it have to call
         * ImmIsUIMessage()....
         */
        hwndDefIme = fpImmGetDefaultIMEWnd(hwnd);

        if (hwndDefIme == hwnd) {
            /*
             * VC++ 1.51 TLW0NCL.DLL subclass IME class window
             * and pass IME messages to DefWindowProc().
             */
            RIPMSG1(RIP_WARNING,
                "IME Class window is hooked and IME message [%X] are sent to DefWindowProc",
                message);
            ImeWndProcWorker(pwnd, message, wParam, lParam, fAnsi);
            break;
        }

        if ((pwndDefIme = ValidateHwndNoRip(hwndDefIme)) != NULL) {
            /*
             * If hImc of this window is not activated for IME window,
             * we don't send WM_IME_NOTIFY.
             */
            pimeui = ((PIMEWND)pwndDefIme)->pimeui;
            if (pimeui->hIMC == fpImmGetContext(hwnd))
                return SendMessageWorker(pwndDefIme, message, wParam, lParam, fAnsi);
            else
                RIPMSG1(RIP_WARNING,
                    "DefWindowProc can not send WM_IME_message [%X] now",
                    message);
        }
        break;

dwpime_ToTopLevel_withchk:
        //if (TestCF(pwnd, CFIME))
        //    break;

        /*
         * We assume this Wnd uses DefaultIMEWindow.
         * If this window has its own IME window, it have to call
         * ImmIsUIMessage()....
         */
        hwndDefIme = fpImmGetDefaultIMEWnd(hwnd);

        if (hwndDefIme == hwnd) {
            /*
             * VC++ 1.51 TLW0NCL.DLL subclass IME class window
             * and pass IME messages to DefWindowProc().
             */
            RIPMSG1(RIP_WARNING,
                "IME Class window is hooked and IME message [%X] are sent to DefWindowProc",
                message);
            ImeWndProcWorker(pwnd, message, wParam, lParam, fAnsi);
            break;
        }

        pwndDefIme = ValidateHwndNoRip(hwndDefIme);

        if ((pwndDefIme = ValidateHwndNoRip(hwndDefIme)) != NULL) {
            PWND pwndT, pwndParent;

            pwndT = pwnd;

            while (TestwndChild(pwndT)) {
                pwndParent = REBASEPWND(pwndT, spwndParent);
                if (GETPTI(pwndParent) != GETPTI(pwnd))
                    break;
                pwndT = pwndParent;
            }

            /*
             * If hImc of this window is not activated for IME window,
             * we don't send WM_IME_NOTIFY.
             */
            if (pwndT != pwnd) {
                pimeui = ((PIMEWND)pwndDefIme)->pimeui;
                if (pimeui->hIMC == fpImmGetContext(hwnd))
                    return SendMessageWorker(pwndT, message, wParam, lParam, fAnsi);
                else
                    RIPMSG1(RIP_WARNING,
                        "DefWindowProc can not send WM_IME_message [%X] now",
                        message);
            }
            else {
                /*
                 * Review !!
                 * If this is the toplevel window, we pass messages to
                 * the default IME window...
                 */
                return SendMessageWorker(pwndDefIme, message, wParam, lParam, fAnsi);
            }
        }
        break;

    case WM_IME_NOTIFY:
        switch (wParam) {
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
#ifndef WKWOK_DEBUG
            goto dwpime_ToIMEWnd_withchk;
#endif
            goto dwpime_ToTopLevel_withchk;

        default:
            goto dwpime_ToIMEWnd_withchk;
        }
        break;

    case WM_IME_REQUEST:
        switch (wParam) {
        case IMR_QUERYCHARPOSITION:
            goto dwpime_ToIMEWnd_withchk;
        default:
            break;
        }
        break;

    case WM_IME_SYSTEM:
        if (wParam == IMS_SETACTIVECONTEXT) {
            RIPMSG0(RIP_WARNING, "DefWindowProc received unexpected WM_IME_SYSTEM");
            break;
        }

        /*
         * IMS_SETOPENSTATUS is depended on the activated input context.
         * It needs to be sent to only the activated system window.
         */
        if (wParam == IMS_SETOPENSTATUS)
            goto dwpime_ToIMEWnd_withchk;

        /*
         * Fall through to send to Default IME Window.
         */

    case WM_IME_SETCONTEXT:
        //if (TestCF(pwnd, CFIME))
        //    break;

        hwndDefIme = fpImmGetDefaultIMEWnd(hwnd);

        if (hwndDefIme == hwnd) {
            /*
             * VC++ 1.51 TLW0NCL.DLL subclass IME class window
             * and pass IME messages to DefWindowProc().
             */
            RIPMSG1(RIP_WARNING,
                "IME Class window is hooked and IME message [%X] are sent to DefWindowProc",
                message);
            ImeWndProcWorker(pwnd, message, wParam, lParam, fAnsi);
            break;
        }

        if ((pwndDefIme = ValidateHwndNoRip(hwndDefIme)) != NULL)
            return SendMessageWorker(pwndDefIme, message, wParam, lParam, fAnsi);

        break;

    case WM_IME_SELECT:
        RIPMSG0(RIP_WARNING, "DefWindowProc should not receive WM_IME_SELECT");
        break;

    case WM_IME_COMPOSITIONFULL:
        //if (TestCF(pwnd, CFIME))
        //    break;

        if (GETAPPVER() < VER40) {
            /*
             * This is a temporary solution for win31app.
             * FEREVIEW: For M5 this will call WINNLS message mapping logic
             *           -yutakan
             */
            return SendMessageWorker(pwnd, WM_IME_REPORT,
                             IR_FULLCONVERT, (LPARAM)0L, fAnsi);
        }
        break;

    case WM_CHANGEUISTATE:
        {
            WORD wAction = LOWORD(wParam);
            WORD wFlags = HIWORD(wParam);
            BOOL bRealChange = FALSE;

            /*
             * Validate parameters and determine the flags that should actually be changed.
             */
            if ((wFlags & ~UISF_VALID) || (wAction > UIS_LASTVALID) || lParam) {
                return 0;
            }

            if (wAction == UIS_INITIALIZE) {
                wFlags = 0;
                if (TEST_KbdCuesPUSIF) {
                    if (gpsi->bLastRITWasKeyboard) {
                        wAction = UIS_CLEAR;
                    } else {
                        wAction = UIS_SET;
                    }
                    wFlags = UISF_HIDEFOCUS | UISF_HIDEACCEL;
                    wParam = MAKEWPARAM(wAction, wFlags);
                }
            } else if (!TEST_KbdCuesPUSIF) {
                wFlags &= ~(UISF_HIDEFOCUS | UISF_HIDEACCEL);
            }

            if (wFlags == 0) {
                return 0;
            }

            UserAssert(wAction == UIS_SET || wAction == UIS_CLEAR);
            /*
             * If the state is not going to change, there's nothing to do here
             */
            if (wFlags & UISF_HIDEFOCUS) {
                bRealChange = (!!TestWF(pwnd, WEFPUIFOCUSHIDDEN)) ^ (wAction == UIS_SET);
            }
            if (wFlags & UISF_HIDEACCEL) {
                bRealChange |= (!!TestWF(pwnd, WEFPUIACCELHIDDEN)) ^ (wAction == UIS_SET);
            }
            if (wFlags & UISF_ACTIVE) {
                bRealChange |= (!!TestWF(pwnd, WEFPUIACTIVE)) ^ (wAction == UIS_SET);
            }

            if (!bRealChange) {
                break;
            }
            /*
             * Children pass this message up
             * Top level windows update send down to themselves WM_UPDATEUISTATE.
             * WM_UPDATEUISTATE will change the state bits and broadcast down the message
             */
            if (TestwndChild(pwnd)) {

                return SendMessageWorker(REBASEPWND(pwnd, spwndParent), WM_CHANGEUISTATE,
                              wParam, lParam, fAnsi);
            } else {
                return SendMessageWorker(pwnd, WM_UPDATEUISTATE, wParam, lParam, fAnsi);
            }

        }
        break;

    case WM_QUERYUISTATE:
        return (TestWF(pwnd, WEFPUIFOCUSHIDDEN) ? UISF_HIDEFOCUS : 0) |
               (TestWF(pwnd, WEFPUIACCELHIDDEN) ? UISF_HIDEACCEL : 0) |
               (TestWF(pwnd, WEFPUIACTIVE) ? UISF_ACTIVE : 0);
        break;
    }

    return 0;

#if DBG
    } // gfTurboDWP
#endif
}


/***************************************************************************\
* CallWindowProc
*
* Calls pfn with the passed message parameters. If pfn is a server-side
* window proc the server is called to deliver the message to the window.
* Currently we have the following restrictions:
*
* 04-17-91 DarrinM Created.
\***************************************************************************/

LRESULT WINAPI CallWindowProcAorW(
    WNDPROC pfn,
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL bAnsi)             // Denotes if input is Ansi or Unicode
{
    PCALLPROCDATA pCPD;
    PWND pwnd;

    /*
     * Raid# 78954: SPY++
     *
     * Under FE NT4.0 or NT5.0, the sytem sends WM_GETTEXTLENGTH
     * corresponding to WM_xxxGETTEXT to optimize buffer allocation.
     * This is really needed to avoid the buffer size inflation.
     * For some reasons, Spy++ passes NULL as pfn to CallWindowProc
     *
     */
    if (pfn == NULL) {
        RIPMSG0(RIP_WARNING, "CallWidowProcAorW(): pfn == NULL!");
        return 0L;
    }

// OPT!! check an ANSI\UNICODE table rather than fnDWORD
// OPT!! convert WM_CHAR family messages in line

    /*
     * Check if pfn is really a CallProcData Handle
     * if it is and there is no ANSI data then convert the handle
     * into an address; otherwise call the server for translation
     */
    if (ISCPDTAG(pfn)) {
        if (pCPD = HMValidateHandleNoRip((HANDLE)pfn, TYPE_CALLPROC)) {
            if ((message >= WM_USER) || !MessageTable[message].bThunkMessage) {
                pfn = (WNDPROC)pCPD->pfnClientPrevious;
            } else {
                return CsSendMessage(hwnd, message, wParam, lParam, (ULONG_PTR)pfn,
                        FNID_CALLWINDOWPROC, bAnsi);
            }
        } else {
            RIPMSG1(RIP_WARNING, "CallWindowProc tried using a deleted CPD %#p\n", pfn);
            return 0;
        }
    }

    pwnd = ValidateHwnd(hwnd);
    return UserCallWinProcCheckWow(PACTCTXT(pwnd), pfn, hwnd, message, wParam, lParam, NULL, FALSE);
}


FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, CallWindowProcA, WNDPROC, pfn, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI CallWindowProcA(
    WNDPROC pfn,
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return CallWindowProcAorW(pfn, hwnd, message, wParam, lParam, TRUE);
}

FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, CallWindowProcW, WNDPROC, pfn, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI CallWindowProcW(
    WNDPROC pfn,
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return CallWindowProcAorW(pfn, hwnd, message, wParam, lParam, FALSE);
}

/***************************************************************************\
* MenuWindowProc
*
* Calls the sever-side function xxxMenuWindowProc
*
* 07-27-92 Mikehar Created.
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, MenuWindowProcW, HWND, hwnd, HWND, hwndMDIClient, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI MenuWindowProcW(
    HWND hwnd,
    HWND hwndMDIClient,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return CsSendMessage(hwnd, message, wParam, lParam,
        (ULONG_PTR)hwndMDIClient, FNID_MENU, FALSE);
}


FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, MenuWindowProcA, HWND, hwnd, HWND, hwndMDIClient, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI MenuWindowProcA(
    HWND hwnd,
    HWND hwndMDIClient,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return CsSendMessage(hwnd, message, wParam, lParam,
        (ULONG_PTR)hwndMDIClient, FNID_MENU, TRUE);
}

/***************************************************************************\
* _ClientGetListboxString
*
* This special function exists because LB_GETTEXT and CB_GETLBTEXT don't have
* buffer counts in them anywhere. Because there is no buffer count we have
* no idea how much room to reserved in the shared memory stack for this
* string to be copied into. The solution is to get the string length ahead
* of time, and send the message with this buffer length. Since this buffer
* length isn't a part of the original message, this routine is used for
* just this purpose.
*
* This routine gets called from the server.
*
* 04-13-91 ScottLu Created.
\***************************************************************************/

DWORD WINAPI _ClientGetListboxString(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPSTR lParam, // May be a unicode or ANSI string
    ULONG_PTR xParam,
    PROC xpfn)
{
    return ((DWORD)((GENERICPROC)xpfn)(pwnd, msg, wParam, (LPARAM)lParam, xParam));
}

/***************************************************************************\
* DispatchMessageWorker
*
* Handles any messages that can be dealt with wholly on the client and
* passes the rest to the server.
*
* 04-24-92 DarrinM      Created.
\***************************************************************************/
LRESULT DispatchMessageWorker(
    MSG *pmsg,
    BOOL fAnsi)
{
    PWND pwnd;
    WPARAM wParamSaved;
    LRESULT lRet;
    BOOL bDoDbcsMessaging = FALSE;

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (pmsg->message & RESERVED_MSG_BITS) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"pmsg->message\" (%ld) to DispatchMessageWorker",
                pmsg->message);

        return 0;
    }

    if (pmsg->hwnd != NULL) {
        pwnd = ValidateHwnd(pmsg->hwnd);
        if (pwnd == NULL) {
            return 0;
        }
        pmsg->hwnd = HWq(pwnd); // get full 32-bit HWND in case this came from WoW
    } else {
        pwnd = NULL;
    }

    /*
     * If this is a synchronous-only message (takes a pointer in wParam or
     * lParam), then don't allow this message to go through since those
     * parameters have not been thunked, and are pointing into outer-space
     * (which would case exceptions to occur).
     *
     * (This api is only called in the context of a message loop, and you
     * don't get synchronous-only messages in a message loop).
     */
    if (TESTSYNCONLYMESSAGE(pmsg->message, pmsg->wParam)) {
        /*
         * Fail if 32 bit app is calling.
         */
        if (!(GetClientInfo()->dwTIFlags & TIF_16BIT)) {
            RIPERR0(ERROR_MESSAGE_SYNC_ONLY, RIP_WARNING, "DispatchMessageWorker: must be sync only");
            return FALSE;
        }

        /*
         * For wow apps, allow it to go through (for compatibility). Change
         * the message id so our code doesn't understand the message - wow
         * will get the message and strip out this bit before dispatching
         * the message to the application.
         */
        pmsg->message |= MSGFLAG_WOW_RESERVED;
    }

    /*
     * Timer callbacks that don't go through window procs are sent with
     * the callback address in lParam.  Identify and dispatch those timers.
     */
    if ((pmsg->message == WM_TIMER) || (pmsg->message == WM_SYSTIMER)) {
        /*
         * Console windows use WM_TIMER for the caret. However, they don't
         * use a timer callback, so if this is CSRSS and there's a WM_TIMER
         * for us, the only way lParam would be non-zero is if someone's trying
         * to make us fault. No, this isn't a nice thing to do, but there
         * are bad, bad people out there. Windows Bug #361246.
         */
        if (pmsg->lParam != 0) {
            /*
             * System timers must be executed on the server's context.
             */
            if (pmsg->message == WM_SYSTIMER) {
                return NtUserDispatchMessage(pmsg);
            } else if (!gfServerProcess) {
                /*
                 * WM_TIMER with lParam could be an attack from
                 * malicious apps.  To make sure the call is legitimate,
                 * let the kernel side validates it.
                 */
                if (!NtUserValidateTimerCallback(pmsg->hwnd, pmsg->wParam, pmsg->lParam)) {
                    RIPMSG3(RIP_WARNING, "DispatchMessageWorker: invalid timer: hwnd=%p, wParam=%p, lParam=%p", pmsg->hwnd, pmsg->wParam, pmsg->lParam);
                    return 0;
                }

               /*
                * We can't really trust what's in lParam, so make sure we
                * handle any exceptions that occur during this call.
                */
               try {
                   /*
                    * Windows NT Bug #234292.
                    * Since the called window/dialog proc may have a different
                    * calling convention, we must wrap the call and, check esp
                    * and replace with a good esp when the call returns. This
                    * is what UserCallWinProc* does.
                    */
                   lRet = UserCallWinProc(PACTCTXT(pwnd),
                                          (WNDPROC)pmsg->lParam,
                                          pmsg->hwnd,
                                          pmsg->message,
                                          pmsg->wParam,
                                          NtGetTickCount());
               } except ((GetAppCompatFlags2(VER40) & GACF2_NO_TRYEXCEPT_CALLWNDPROC) ?
                         EXCEPTION_CONTINUE_SEARCH : W32ExceptionHandler(FALSE, RIP_WARNING)) {
                     /*
                      * Windows NT Bug #359866.
                      * Some applications like Hagaki Studio 2000 need to handle
                      * the exception in WndProc in their handler, even though it
                      * skips the API calls. For those apps, we have to honor the
                      * behavior of NT4, with no protection.
                      */
                   lRet = 0;
               }
               return lRet;
            }
        }
    }

    if (pwnd == NULL) {
        return 0;
    }

    /*
     * To be safe (in case some bizarre app wants to look at the message
     * again after dispatching it) save wParam so it can be restored after
     * RtlMBMessageWParamCharToWCS() or RtlWCSMessageToMB() mangle it.
     */
    wParamSaved = pmsg->wParam;

    /*
     * Pass messages intended for server-side windows over to the server.
     * WM_PAINTs are passed over so the WFPAINTNOTPROCESSED code can be
     * executed.
     */
    if (TestWF(pwnd, WFSERVERSIDEPROC) || (pmsg->message == WM_PAINT)) {
        if (fAnsi) {
            /*
             * Setup DBCS Messaging for WM_CHAR...
             */
            BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(pmsg->message,pmsg->wParam,TRUE);

            /*
             * Convert wParam to Unicode, if nessesary.
             */
            RtlMBMessageWParamCharToWCS(pmsg->message, &pmsg->wParam);
        }
        lRet = NtUserDispatchMessage(pmsg);
        pmsg->wParam = wParamSaved;
        return lRet;
    }

    /*
     * If the dispatcher and the receiver are both ANSI or both UNICODE
     * then no message translation is necessary.  NOTE: this test
     * assumes that fAnsi is FALSE or TRUE, not just zero or non-zero.
     */
    if (!fAnsi != !TestWF(pwnd, WFANSIPROC)) {
        // before: if (fAnsi != ((TestWF(pwnd, WFANSIPROC)) ? TRUE : FALSE)) {

        if (PtiCurrent() != GETPTI(pwnd)) {
            RIPMSG0(RIP_WARNING, "message belongs to a different Q");
            return 0;
        }

        if (fAnsi) {
            /*
             * Setup DBCS Messaging for WM_CHAR...
             */
            BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_CLIENTA(pmsg->message,pmsg->wParam,TRUE);

            /*
             * Convert wParam to Unicode, if nessesary.
             */
            RtlMBMessageWParamCharToWCS(pmsg->message, &pmsg->wParam);
        } else {
            /*
             * Convert wParam to ANSI...
             */
            RtlWCSMessageWParamCharToMB(pmsg->message, &pmsg->wParam);

            /*
             * Let's DBCS messaging for WM_CHAR....
             */
            BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_CLIENTW(
                pmsg->hwnd,pmsg->message,pmsg->wParam,pmsg->lParam,
                pmsg->time,pmsg->pt,bDoDbcsMessaging);
        }
    }

DispatchMessageAgain:
    lRet = UserCallWinProcCheckWow(pwnd->pActCtx, (WNDPROC)pwnd->lpfnWndProc, pmsg->hwnd, pmsg->message,
            pmsg->wParam, pmsg->lParam, &(pwnd->state), TRUE);

    /*
     * if we have DBCS TrailingByte that should be sent, send it here..
     */
    DISPATCH_DBCS_MESSAGE_IF_EXIST(pmsg->message,pmsg->wParam,bDoDbcsMessaging,DispatchMessage);

    pmsg->wParam = wParamSaved;
    return lRet;
}

/***************************************************************************\
* GetMessageTime (API)
*
* This API returns the time when the last message was read from
* the current message queue.
*
* History:
* 11-19-90 DavidPe      Created.
\***************************************************************************/

LONG GetMessageTime(VOID)
{
    return (LONG)NtUserGetThreadState(UserThreadStateMessageTime);
}

/***************************************************************************\
* GetMessageExtraInfo (API)
*
* History:
* 28-May-1991 mikeke
\***************************************************************************/

LPARAM GetMessageExtraInfo(VOID)
{
    return (LPARAM)NtUserGetThreadState(UserThreadStateExtraInfo);
}


FUNCLOG1(LOG_GENERAL, LPARAM, DUMMYCALLINGTYPE, SetMessageExtraInfo, LPARAM, lParam)
LPARAM SetMessageExtraInfo(LPARAM lParam)
{
    return (LPARAM)NtUserCallOneParam(lParam, SFI__SETMESSAGEEXTRAINFO);
}



/***********************************************************************\
* InSendMessage (API)
*
* This function determines if the current thread is preocessing a message
* from another application.
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

BOOL InSendMessage(VOID)
{
    PCLIENTTHREADINFO pcti = GetClientInfo()->pClientThreadInfo;

    if (pcti) {
        return TEST_BOOL_FLAG(pcti->CTIF_flags, CTIF_INSENDMESSAGE);
    }
    return NtUserGetThreadState(UserThreadStateInSendMessage) != ISMEX_NOSEND;
}
/***********************************************************************\
* InSendMessageEx (API)
*
* This function tells you what type of send message is being processed
*  by the application, if any
*
* History:
* 01/22/97 GerardoB Created
\***********************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, InSendMessageEx, LPVOID, lpReserved)
DWORD InSendMessageEx(LPVOID lpReserved)
{
    PCLIENTTHREADINFO pcti = GetClientInfo()->pClientThreadInfo;
    UNREFERENCED_PARAMETER(lpReserved);

    if (pcti && !TEST_FLAG(pcti->CTIF_flags, CTIF_INSENDMESSAGE)) {
        return ISMEX_NOSEND;
    }
    return (DWORD)NtUserGetThreadState(UserThreadStateInSendMessage);
}

/***********************************************************************\
* GetCPD
*
* This function calls the server to allocate a CPD structure.
*
* History:
* 11-15-94 JimA         Created.
\***********************************************************************/

ULONG_PTR GetCPD(
    KERNEL_PVOID pWndOrCls,
    DWORD options,
    ULONG_PTR dwData)
{
    return NtUserGetCPD(HW(pWndOrCls), options, dwData);
}

#ifdef BUILD_WOW6432
/***********************************************************************\
* MapKernelClientFnToClientFn
*
* Maps a function pointer from what the kernel expects to what the
* client(user-mode) expects.
*
* History:
* 11-15-98 PeterHal         Created.
\***********************************************************************/
WNDPROC_PWND
MapKernelClientFnToClientFn(
    WNDPROC_PWND lpfnWndProc
    )
{
    KPKERNEL_ULONG_PTR pp;

    for (pp = (KPKERNEL_ULONG_PTR)&gpsi->apfnClientA; pp < (KPKERNEL_ULONG_PTR) (&gpsi->apfnClientA+1); pp ++) {
        if ((KERNEL_ULONG_PTR)lpfnWndProc == *pp) {
            return (WNDPROC_PWND)((KERNEL_ULONG_PTR*) &pfnClientA) [ (pp - (KPKERNEL_ULONG_PTR)&gpsi->apfnClientA) ];
        }
    }

    for (pp = (KPKERNEL_ULONG_PTR)&gpsi->apfnClientW; pp < (KPKERNEL_ULONG_PTR) (&gpsi->apfnClientW+1); pp ++) {
        if ((KERNEL_ULONG_PTR)lpfnWndProc == *pp) {
            return (WNDPROC_PWND)((KERNEL_ULONG_PTR*) &pfnClientW) [ (pp - (KPKERNEL_ULONG_PTR)&gpsi->apfnClientW) ];
        }
    }

    return lpfnWndProc;
}
#endif

#ifdef GENERIC_INPUT
LRESULT
APIENTRY
DefRawInputProc(
    PRAWINPUT* paRawInput,
    INT nInput,
    UINT cbSizeHeader)
{
    UNREFERENCED_PARAMETER(paRawInput);
    UNREFERENCED_PARAMETER(nInput);

    if (cbSizeHeader != sizeof(RAWINPUTHEADER)) {
        return (LRESULT)-1;
    }

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\csenda.c ===
/**************************************************************************\
* Module Name: csenda.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client side sending stubs for ANSI text
*
* History:
* 06-Jan-1992 IanJa
\**************************************************************************/

#define CLIENTSIDE 1

#undef UNICODE

#define NONTOSPINTERLOCK
#include <ntosp.h>

#include <ntrtl.h>
#include <nturtl.h>
#include "ntcsrdll.h"
#include "usercli.h"
#include <stdlib.h>

/**************************************************************************\
*
* include the stub definition file
*
\**************************************************************************/

#include "ntcftxt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\crecv.c ===
/****************************** Module Header ******************************\
* Module Name: crecv.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Client side receiving stubs
*
* 07-06-91 ScottLu Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <dbt.h>

#define CALLBACKPROC 1
#define CLIENTSIDE 1

#include "callback.h"

/*
 * Receive setup and control macros
 */
#define RECVSIDE 1

#define RECVCALL(lower, upper) \
    DWORD __ ## lower (upper *pmsg)

#define BEGINRECV(err, p, cb) \
    CALLBACKSTATUS CallbackStatus;      \
    NTSTATUS Status = STATUS_SUCCESS;   \
    ULONG_PTR retval = (ULONG_PTR)err;    \
    CallbackStatus.cbOutput = cb;       \
    CallbackStatus.pOutput = p;

#define FIXUPPOINTERS() \
    if (pmsg->CaptureBuf.cCapturedPointers &&           \
            pmsg->CaptureBuf.pvVirtualAddress == NULL)  \
        FixupCallbackPointers(&pmsg->CaptureBuf);

#if defined(_X86_) && !defined(BUILD_WOW6432)

NTSTATUS
FASTCALL
XyCallbackReturn(
    IN PVOID Buffer,
    IN ULONG Length,
    IN NTSTATUS Status
    );

#define ENDRECV() \
    goto errorexit;                                                     \
errorexit:                                                              \
    CallbackStatus.retval = retval;                                     \
    return XyCallbackReturn(&CallbackStatus, sizeof(CallbackStatus),    \
            Status)

#else

#define ENDRECV() \
    goto errorexit;                                                     \
errorexit:                                                              \
    CallbackStatus.retval = retval;                                     \
    return NtCallbackReturn(&CallbackStatus, sizeof(CallbackStatus),    \
            Status)

#endif

#define MSGERROR() \
    goto errorexit

#define MSGERRORCODE(code) { \
    RIPERR0(code, RIP_WARNING, "Unspecified error"); \
    goto errorexit; }

#define MSGNTERRORCODE(code) { \
    RIPNTERR0(code, RIP_WARNING, "Unspecified error"); \
    goto errorexit; }

/*
 * Callback parameter fixup macros
 */
//#undef CALLPROC
//#define CALLPROC(p) FNID(p)

#define CALLDATA(x) (pmsg->x)
#define PCALLDATA(x) (&(pmsg->x))
#define PCALLDATAOPT(x) (pmsg->p ## x ? (PVOID)&(pmsg->x) : NULL)
#define FIRSTFIXUP(x) (pmsg->x)
#define FIXUPOPT(x) (pmsg->x)
#define FIRSTFIXUPOPT(x) FIXUPOPT(x)
#define FIXUP(x) (pmsg->x)
#define FIXUPID(x) (pmsg->x)
#define FIXUPIDOPT(x) (pmsg->x)
#define FIXUPSTRING(x) (pmsg->x.Buffer)
#define FIXUPSTRINGID(x) (pmsg->x.Buffer)
#define FIXUPSTRINGIDOPT(x) (pmsg->x.Buffer)

/***************************************************************************\
* FixupCallbackPointers
*
* Fixes up captured callback pointers.
*
* 03-13-95 JimA             Created.
\***************************************************************************/

VOID FixupCallbackPointers(
    PCAPTUREBUF pcb)
{
    DWORD i;
    LPDWORD lpdwOffset;
    PVOID *ppFixup;

    lpdwOffset = (LPDWORD)((PBYTE)pcb + pcb->offPointers);
    for (i = 0; i < pcb->cCapturedPointers; ++i, ++lpdwOffset) {
        ppFixup = (PVOID *)((PBYTE)pcb + *lpdwOffset);
        *ppFixup = (PBYTE)pcb + (LONG_PTR)*ppFixup;
    }
}

/**************************************************************************\
*
* include the stub definition file
*
\**************************************************************************/

#include "ntcb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\connect.c ===
/****************************** Module Header ******************************\
* Module Name: connect.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager conversation connection functions
*
* Created: 11/3/91 Sanford Staab
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "nddeagnt.h"

//#define TESTING
#ifdef TESTING
ULONG
DbgPrint(
    PCH Format,
    ...
    );
VOID
DbgUserBreakPoint(
    VOID
    );

BOOL ValidateConvList(
HCONVLIST hConvList)
{
    PCONVLIST pcl;
    PCL_CONV_INFO pci;
    PXACT_INFO pxi;
    int i;
    BOOL fMatch;

    if (hConvList == 0) {
        return(TRUE);
    }
    pcl = (PCONVLIST)ValidateCHandle((HANDLE)hConvList,
                                     HTYPE_CONVERSATION_LIST,
                                     HINST_ANY);
    for (i = 0; i < pcl->chwnd; i++) {
        /*
         * all windows in the list are valid
         */
        if (!IsWindow(pcl->ahwnd[i])) {
            DebugBreak();
        }
        pci = (PCL_CONV_INFO)GetWindowLongPtr(pcl->ahwnd[i], GWLP_PCI);
       /*
        * All windows have at least one convinfo associated with them.
        */
        if (pci == NULL) {
            DebugBreak();
        }
        fMatch = FALSE;
        while (pci != NULL) {
            /*
             * All non-zombie conversations have hConvList set correctly.
             */
            if (pci->hConvList != hConvList &&
                    TypeFromHandle(pci->ci.hConv) != HTYPE_ZOMBIE_CONVERSATION) {
                DebugBreak();
            }
            /*
             * All conversations have hConvList clear or set correctly.
             */
            if (pci->hConvList != 0 && pci->hConvList != hConvList) {
                DebugBreak();
            }
            /*
             * At least 1 of the conversations references the list
             */
            if (pci->hConvList == hConvList) {
                fMatch = TRUE;
            }
            for (pxi = pci->ci.pxiOut; pxi; pxi = pxi->next) {
                if ((PCL_CONV_INFO)pxi->pcoi != pci) {
                    DebugBreak();
                }
            }
            pci = (PCL_CONV_INFO)pci->ci.next;
        }
        if (!fMatch) {
            /*
             * At least 1 of the conversations references the list
             */
            DebugBreak;
        }
    }
    return(TRUE);
}

VOID ValidateAllConvLists()
{
    ApplyFunctionToObjects(HTYPE_CONVERSATION_LIST, HINST_ANY,
            (PFNHANDLEAPPLY)ValidateConvList);
}

#else // TESTING
#define ValidateConvList(h)
#define ValidateAllConvLists()
#endif // TESTING

CONVCONTEXT TempConvContext;
CONVCONTEXT DefConvContext = {
    sizeof(CONVCONTEXT),
    0,
    0,
    CP_WINANSI,
    0L,
    0L,
    {
        sizeof(SECURITY_QUALITY_OF_SERVICE),
        SecurityImpersonation,
        SECURITY_STATIC_TRACKING,
        TRUE
    }
};

typedef struct tagINIT_ENUM {
    HWND hwndClient;
    HWND hwndSkip;
    LONG lParam;
    LATOM laServiceRequested;
    LATOM laTopic;
    HCONVLIST hConvList;
    DWORD clst;
} INIT_ENUM, *PINIT_ENUM;


BOOL InitiateEnumerationProc(HWND hwndTarget, PINIT_ENUM pie);
VOID DisconnectConv(PCONV_INFO pcoi);


/***************************************************************************\
* DdeConnect (DDEML API)
*
* Description:
* Initiates a DDE conversation.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, HCONV, DUMMYCALLINGTYPE, DdeConnect, DWORD, idInst, HSZ, hszService, HSZ, hszTopic, PCONVCONTEXT, pCC)
HCONV DdeConnect(
    DWORD idInst,
    HSZ hszService,
    HSZ hszTopic,
    PCONVCONTEXT pCC)
{
    PCL_INSTANCE_INFO pcii;
    PCL_CONV_INFO pci;
    HCONV hConvRet = 0;
    HWND hwndTarget = 0;
    LATOM aNormalSvcName = 0;

    EnterDDECrit;

    if (!ValidateConnectParameters((HANDLE)LongToHandle( idInst ), &pcii, &hszService, hszTopic,
            &aNormalSvcName, &pCC, &hwndTarget, 0)) {
        goto Exit;
    }
    pci = ConnectConv(pcii, LATOM_FROM_HSZ(hszService), LATOM_FROM_HSZ(hszTopic),
            hwndTarget,
            (pcii->afCmd & CBF_FAIL_SELFCONNECTIONS) ? pcii->hwndMother : 0,
            pCC, 0, CLST_SINGLE_INITIALIZING);
    if (pci == NULL) {
        SetLastDDEMLError(pcii, DMLERR_NO_CONV_ESTABLISHED);
        goto Exit;
    } else {
        hConvRet = pci->ci.hConv;
    }

Exit:
    if (aNormalSvcName) {
        GlobalDeleteAtom(aNormalSvcName);
    }
    LeaveDDECrit;
    return (hConvRet);
}



/***************************************************************************\
* DdeConnectList (DDEML API)
*
* Description:
* Initiates DDE conversations with multiple servers or adds unique servers
* to an existing conversation list.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG5(LOG_GENERAL, HCONVLIST, DUMMYCALLINGTYPE, DdeConnectList, DWORD, idInst, HSZ, hszService, HSZ, hszTopic, HCONVLIST, hConvList, PCONVCONTEXT, pCC)
HCONVLIST DdeConnectList(
    DWORD idInst,
    HSZ hszService,
    HSZ hszTopic,
    HCONVLIST hConvList,
    PCONVCONTEXT pCC)
{
    PCL_INSTANCE_INFO pcii;
    PCONV_INFO pcoi, pcoiNew, pcoiExisting, pcoiNext;
    HCONVLIST hConvListRet = 0;
    HWND hwndTarget = 0;
    LATOM aNormalSvcName = 0;
    PCONVLIST pcl = NULL;
    HCONVLIST hConvListOld;
    int i;

    CheckDDECritOut;

    EnterDDECrit;

    if (!ValidateConnectParameters((HANDLE)LongToHandle( idInst ), &pcii, &hszService, hszTopic,
            &aNormalSvcName, &pCC, &hwndTarget, hConvList)) {
        goto Exit;
    }

    ValidateConvList(hConvList);

    hConvListOld = hConvList;
    pcoi = (PCONV_INFO)ConnectConv(pcii,
            LATOM_FROM_HSZ(hszService),
            LATOM_FROM_HSZ(hszTopic),
            hwndTarget,
            (pcii->afCmd & (CBF_FAIL_SELFCONNECTIONS | CBF_FAIL_CONNECTIONS)) ?
                pcii->hwndMother : 0,
            pCC,
            hConvListOld,
            CLST_MULT_INITIALIZING);

    if (pcoi == NULL) {
        /*
         * no new connections made
         */
        SetLastDDEMLError(pcii, DMLERR_NO_CONV_ESTABLISHED);
        hConvListRet = hConvListOld;
        goto Exit;
    }

    /*
     * allocate or reallocate the hConvList hwnd list for later addition
     * If we already have a valid list, reuse the handle so we don't have
     * to alter the preexisting pcoi->hConvList values.
     */
    if (hConvListOld == 0) {
        pcl = (PCONVLIST)DDEMLAlloc(sizeof(CONVLIST));
        if (pcl == NULL) {
            SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
            DisconnectConv(pcoi);
            goto Exit;
        }
        // pcl->chwnd = 0; LPTR zero inits.

        hConvList = (HCONVLIST)CreateHandle((ULONG_PTR)pcl,
                HTYPE_CONVERSATION_LIST, InstFromHandle(pcii->hInstClient));
        if (hConvList == 0) {
            DDEMLFree(pcl);
            SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
            DisconnectConv(pcoi);
            goto Exit;
        }
    } else {
        pcl = (PCONVLIST)GetHandleData((HANDLE)hConvList);
        pcl = DDEMLReAlloc(pcl, sizeof(CONVLIST) + sizeof(HWND) * pcl->chwnd);
        if (pcl == NULL) {
            SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
            hConvListRet = hConvListOld;
            DisconnectConv(pcoi);
            goto Exit;
        }
        SetHandleData((HANDLE)hConvList, (ULONG_PTR)pcl);
    }

    ValidateConvList(hConvListOld);

    if (hConvListOld) {
        /*
         * remove duplicates from new conversations
         *
         * Although we tried to prevent duplicates from happening
         * within the initiate enumeration code, wild initiates or
         * servers responding with different service names than
         * requested could cause duplicates.
         */

        /* For each client window... */

        for (i = 0; i < pcl->chwnd; i++) {

        /* For each existing conversation in that window... */

            for (pcoiExisting = (PCONV_INFO)
                        GetWindowLongPtr(pcl->ahwnd[i], GWLP_PCI);
                    pcoi != NULL && pcoiExisting != NULL;
                    pcoiExisting = pcoiExisting->next) {

                if (!(pcoiExisting->state & ST_CONNECTED))
                    continue;

        /* For each new conversation... */

                for (pcoiNew = pcoi; pcoiNew != NULL; pcoiNew = pcoiNext) {

                    pcoiNext = pcoiNew->next;

        /* see if the new conversation duplicates the existing one */

                    if (!(pcoiNew->state & ST_CONNECTED))
                        continue;

                    UserAssert(((PCL_CONV_INFO)pcoiExisting)->hwndReconnect);
                    UserAssert(((PCL_CONV_INFO)pcoiNew)->hwndReconnect);

                    if (((PCL_CONV_INFO)pcoiExisting)->hwndReconnect ==
                                ((PCL_CONV_INFO)pcoiNew)->hwndReconnect &&
                            pcoiExisting->laTopic == pcoiNew->laTopic &&
                            pcoiExisting->laService == pcoiNew->laService) {
                        /*
                         * duplicate conversation - disconnection causes an unlink
                         */
                        if (pcoiNew == pcoi) {
                            /*
                             * We are freeing up the head of the list,
                             * Reset the head to the next guy.
                             */
                            pcoi = pcoiNext;
                        }
                        ValidateConvList(hConvList);
                        ShutdownConversation(pcoiNew, FALSE);
                        ValidateConvList(hConvList);
                        break;
                    }
                }
            }
        }

        for (pcoiExisting = pcoi; pcoiExisting != NULL; pcoiExisting = pcoiExisting->next) {
            /*
             * if these are all zombies - we DONT want to link it in!
             * This is possible because ShutdownConversation() leaves the critical section
             * and could allow responding terminates to come through.
             */
            if (pcoiExisting->state & ST_CONNECTED) {
                goto FoundOne;
            }
        }
        pcoi = NULL;    // abandon this guy - he will clean up in time.
FoundOne:
        /*
         * add new pcoi (if any are left) hwnd to ConvList hwnd list.
         */
        if (pcoi != NULL) {
            UserAssert(pcoi->hwndConv);
            pcl->ahwnd[pcl->chwnd] = pcoi->hwndConv;
            pcl->chwnd++;
            hConvListRet = hConvList;
        } else {
            hConvListRet = hConvListOld;
            if (!hConvListOld) {
                DestroyHandle((HANDLE)hConvList);
            }
        }


    } else {    // no hConvListOld

        UserAssert(pcoi->hwndConv);
        pcl->ahwnd[0] = pcoi->hwndConv;
        pcl->chwnd = 1;
        hConvListRet = hConvList;
    }

    if (pcoi != NULL) {
        /*
         * set hConvList field for all remaining new conversations.
         */
        UserAssert(hConvListRet);
        for (pcoiNew = pcoi; pcoiNew != NULL; pcoiNew = pcoiNew->next) {
            if (pcoiNew->state & ST_CONNECTED) {
                ((PCL_CONV_INFO)pcoiNew)->hConvList = hConvListRet;
            }
        }
    }

Exit:
    if (aNormalSvcName) {
        DeleteAtom(aNormalSvcName);
    }
    ValidateConvList(hConvListRet);
    LeaveDDECrit;
    return (hConvListRet);
}




/***************************************************************************\
* DdeReconnect (DDEML API)
*
* Description:
* Attempts to reconnect an externally (from the server) terminated
* client side conversation.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, HCONV, DUMMYCALLINGTYPE, DdeReconnect, HCONV, hConv)
HCONV DdeReconnect(
    HCONV hConv)
{
    PCL_INSTANCE_INFO pcii;
    PCL_CONV_INFO pci, pciNew;
    HCONV hConvRet = 0;
    CONVCONTEXT cc;

    EnterDDECrit;

    pcii = PciiFromHandle((HANDLE)hConv);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    pci = (PCL_CONV_INFO)ValidateCHandle((HANDLE)hConv,
            HTYPE_CLIENT_CONVERSATION, HINST_ANY);
    if (pci == NULL) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (pci->ci.state & ST_CONNECTED) {
        goto Exit;
    }

    GetConvContext(pci->ci.hwndConv, (LONG *)&cc);
    pciNew = ConnectConv(pcii, pci->ci.laService, pci->ci.laTopic,
            pci->hwndReconnect, 0, &cc, 0, CLST_SINGLE_INITIALIZING);
    if (pciNew == NULL) {
        SetLastDDEMLError(pcii, DMLERR_NO_CONV_ESTABLISHED);
        goto Exit;
    } else {
        hConvRet = pciNew->ci.hConv;
        if (pci->ci.cLinks) {
            PXACT_INFO pxi;
            int iLink;
            PADVISE_LINK paLink;

            /*
             * reestablish advise links
             */

            for (paLink = pci->ci.aLinks, iLink = pci->ci.cLinks;
                    iLink; paLink++, iLink--) {

                pxi = (PXACT_INFO)DDEMLAlloc(sizeof(XACT_INFO));
                if (pxi == NULL) {
                    break;              // abort relinking
                }
                pxi->pcoi = (PCONV_INFO)pciNew;
                pxi->gaItem = LocalToGlobalAtom(paLink->laItem); // pxi copy
                pxi->wFmt = paLink->wFmt;
                pxi->wType = (WORD)((paLink->wType >> 12) | XTYP_ADVSTART);
                if (ClStartAdvise(pxi)) {
                    pxi->flags |= XIF_ABANDONED;
                } else {
                    GlobalDeleteAtom(pxi->gaItem);
                    DDEMLFree(pxi);
                }
            }
        }
    }

Exit:
    LeaveDDECrit;
    return (hConvRet);
}


/***************************************************************************\
* ValidateConnectParameters
*
* Description:
* worker function to handle common validation code.
*
* Note that paNormalSvcName is set to the atom value created upon extracting
* a normal HSZ from an InstanceSpecific HSZ.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL ValidateConnectParameters(
    HANDLE hInst,
    PCL_INSTANCE_INFO *ppcii, // set if valid hInst
    HSZ *phszService, // altered if InstSpecific HSZ
    HSZ hszTopic,
    LATOM *plaNormalSvcName, // set to atom that needs freeing when done
    PCONVCONTEXT *ppCC, // set to point to DefConvContext if NULL
    HWND *phwndTarget, // set if hszService is InstSpecific
    HCONVLIST hConvList)
{
    DWORD hszType;
    BOOL fError = FALSE;

    *ppcii = ValidateInstance(hInst);
    if (*ppcii == NULL) {
        return (FALSE);
    }
    hszType = ValidateHSZ(*phszService);
    if (hszType == HSZT_INVALID || ValidateHSZ(hszTopic) == HSZT_INVALID) {
        SetLastDDEMLError(*ppcii, DMLERR_INVALIDPARAMETER);
        return (FALSE);
    }
    if (hszType == HSZT_INST_SPECIFIC) {
        *phwndTarget = ParseInstSpecificAtom(LATOM_FROM_HSZ(*phszService),
            plaNormalSvcName);
        if (*plaNormalSvcName == 0) {
            SetLastDDEMLError(*ppcii, DMLERR_SYS_ERROR);
            return (FALSE);
        }
        *phszService = NORMAL_HSZ_FROM_LATOM(*plaNormalSvcName);
    }
    if (*ppCC == NULL) {
        *ppCC = &DefConvContext;
        if ((*ppcii)->flags & IIF_UNICODE) {
            (*ppCC)->iCodePage = CP_WINUNICODE;
        } else {
            (*ppCC)->iCodePage = CP_WINANSI;
        }
    } else try {
        if ((*ppCC)->cb > sizeof(CONVCONTEXT)) {
            SetLastDDEMLError(*ppcii, DMLERR_INVALIDPARAMETER);
            fError = TRUE;
        } else if ((*ppCC)->cb < sizeof(CONVCONTEXT)) {
            TempConvContext = DefConvContext;
            /*
             * we can use this static temp because we are synchronized.
             */
            RtlCopyMemory(&TempConvContext, *ppCC, (*ppCC)->cb);
            *ppCC = &TempConvContext;
        }
    } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
        SetLastDDEMLError(*ppcii, DMLERR_INVALIDPARAMETER);
        fError = TRUE;
    }
    if (fError) {
        return(FALSE);
    }
    if (hConvList != 0 &&
            !ValidateCHandle((HANDLE)hConvList, HTYPE_CONVERSATION_LIST,
            (DWORD)InstFromHandle((*ppcii)->hInstClient))) {
        return (FALSE);
    }
    return (TRUE);
}



/***************************************************************************\
* ConnectConv
*
* Description:
* Work function for all Connect cases.
*
* Method:
*
* To reduce the number of windows we use and to simplify how client
* windows handle multiple WM_DDE_ACK messages during initiation, a
* single client window can handle many conversations, each with
* a different server window.
*
* The client window is created and set to a initiation state via the
* GWL_CONVSTATE window word. Initiates are then sent to enumerated server
* window candidates.
* The GWL_CONVSTATE value is used by the DDEML mother windows
* to determine if only one or several ACKs are desired to minimize
* unnessary message traffic.
*
* The client window GWL_CONVCONTEXT? window words are also used by
* Event Windows to pass context information.
*
* Note that all client and server windows are children of the mother
* window. This reduces the number of top level windows that
* WM_DDE_INITIATES need to hit.
*
* Each WM_DDE_ACK that is received by a client window while in the
* initiation state causes it to create a CL_CONV_INFO structure,
* partially initialize it, and link it into its list of CL_CONV_INFO
* structures. The head of the list is pointed to by the GWLP_PCI
* client window word.
*
* After each WM_DDE_INITIALIZE is sent, the GWLP_PCI value is checked
* to see if it exists and needs initialization to be completed. If
* this is the case the init code knows that at least one ACK was
* received in response to the WM_DDE_INITIALIZE send. The
* initialization of each CL_CONV_INFO struct that needs it is then completed.
*
* Once the broadcasting of WM_DDE_INITIALIZE is done, the init code
* then sets the GWL_CONVSTATE value in the client window to indicate that
* initialization is complete.
*
* Returns:
* The head pci to the client window or NULL if no connections made it.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
PCL_CONV_INFO ConnectConv(
    PCL_INSTANCE_INFO pcii,
    LATOM laService,
    LATOM laTopic,
    HWND hwndTarget, // 0 implies broadcast
    HWND hwndSkip, // 0 implies no skips - avoids self-connections.
    PCONVCONTEXT pCC,
    HCONVLIST hConvList,
    DWORD clst)
{
    INIT_ENUM ie;
    PCL_CONV_INFO pci;
    PCONV_INFO pcoi;
    GATOM gaService, gaTopic;

    CheckDDECritIn;

    if (hwndTarget && hwndTarget == hwndSkip) {
        return(NULL);
    }

    LeaveDDECrit;
    CheckDDECritOut;

    if (pcii->flags & IIF_UNICODE) {
        ie.hwndClient = CreateWindowW((LPWSTR)(gpsi->atomSysClass[ICLS_DDEMLCLIENTW]),
                                     L"",
                                     WS_CHILD,
                                     0, 0, 0, 0,
                                     pcii->hwndMother,
                                     (HMENU)0,
                                     (HANDLE)0,
                                     (LPVOID)NULL);
    } else {
        ie.hwndClient = CreateWindowA((LPSTR)(gpsi->atomSysClass[ICLS_DDEMLCLIENTA]),
                                     "",
                                     WS_CHILD,
                                     0, 0, 0, 0,
                                     pcii->hwndMother,
                                     (HMENU)0,
                                     (HANDLE)0,
                                     (LPVOID)NULL);
    }

    EnterDDECrit;

    if (ie.hwndClient == 0) {
        return (NULL);
    }

    if (pCC != NULL) {
        if (!NtUserDdeSetQualityOfService(ie.hwndClient, &(pCC->qos), NULL)) {
            SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
            goto Error;
        }
    }
    /*
     * Note that a pci will be created and allocated for each ACK recieved.
     */
    SetConvContext(ie.hwndClient, (LONG *)pCC);
    SetWindowLong(ie.hwndClient, GWL_CONVSTATE, clst);
    SetWindowLongPtr(ie.hwndClient, GWLP_SHINST, (LONG_PTR)pcii->hInstServer);
    SetWindowLongPtr(ie.hwndClient, GWLP_CHINST, (LONG_PTR)pcii->hInstClient);

    gaService = LocalToGlobalAtom(laService);
    gaTopic = LocalToGlobalAtom(laTopic);
    ie.lParam = MAKELONG(gaService, gaTopic);
    if (!hwndTarget) {
        ie.hwndSkip = hwndSkip;
        ie.laServiceRequested = laService;
        ie.laTopic = laTopic;
        ie.hConvList = hConvList;
        ie.clst = clst;
    }

    LeaveDDECrit;

    if (hwndTarget) {
        SendMessage(hwndTarget, WM_DDE_INITIATE, (WPARAM)ie.hwndClient,
                ie.lParam);
    } else {
        /*
         * Send this message to the nddeagnt app first so it can start
         * the netdde services BEFORE we do an enumeration of windows.
         * This lets things work the first time.  NetDDEAgent caches
         * service status so this is the fastest way to do this.
         */
        HWND hwndAgent = FindWindowW(SZ_NDDEAGNT_CLASS, SZ_NDDEAGNT_TITLE);
        if (hwndAgent) {
            SendMessage(hwndAgent,
                WM_DDE_INITIATE, (WPARAM)ie.hwndClient, ie.lParam);
        }
        EnumWindows((WNDENUMPROC)InitiateEnumerationProc, (LPARAM)&ie);
    }

    EnterDDECrit;
    /*
     * hConvList may have been destroyed during the enumeration but we are
     * done with it now so no need to revalidate.
     */

#if DBG
    {
        WCHAR sz[10];

        if (gaService && GlobalGetAtomName(gaService, sz, 10) == 0) {
            RIPMSG1(RIP_ERROR, "Bad Service Atom after Initiate phase: %lX", (DWORD)gaService);
        }
        if (gaTopic && GlobalGetAtomName(gaTopic, sz, 10) == 0) {
            RIPMSG1(RIP_ERROR, "Bad Topic Atom after Initiate phase: %lX", (DWORD)gaTopic);
        }
    }
#endif // DBG

    GlobalDeleteAtom(gaService);
    GlobalDeleteAtom(gaTopic);

    //
    // Get the first pci allocated when a WM_DDE_ACK was recieved.
    //
    pci = (PCL_CONV_INFO)GetWindowLongPtr(ie.hwndClient, GWLP_PCI);
    if (pci == NULL) {
Error:
        LeaveDDECrit;
        NtUserDestroyWindow(ie.hwndClient);
        EnterDDECrit;
        return (NULL);
    }

    SetWindowLong(ie.hwndClient, GWL_CONVSTATE, CLST_CONNECTED);
    if (hwndTarget) {
        /*
         * If hwndTarget was NULL, the enumeration proc took care of this.
         */
        pci->hwndReconnect = hwndTarget;
        UserAssert(pci->ci.next == NULL);
        pci->ci.laServiceRequested = laService;
        IncLocalAtomCount(laService); // pci copy
    }

    if (pcii->MonitorFlags & MF_CONV) {
        for (pcoi = (PCONV_INFO)pci; pcoi; pcoi = pcoi->next) {
            MONCONV(pcoi, TRUE);
        }
    }
    return (pci);
}


/*
 * Undoes the work of ConnectConv()
 */
VOID DisconnectConv(
PCONV_INFO pcoi)
{
    PCONV_INFO pcoiNext;

    for (; pcoi; pcoi = pcoiNext) {
        pcoiNext = pcoi->next;
        ShutdownConversation(pcoi, FALSE);
    }
}


/***************************************************************************\
* InitiateEnumerationProc (FILE LOCAL)
*
* Description:
* Function used via EnumWindows to enumerate all server window candidates
* during DDE initiation. The enumeration allows DDEML to know what
* window WM_DDE_INITIATE was sent to so that it can be remembered for
* possible reconnection later. (The window that receives the WM_DDE_INITIATE
* message is not necessarily going to be the server window.)
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
BOOL InitiateEnumerationProc(
    HWND hwndTarget,
    PINIT_ENUM pie)
{
    PCL_CONV_INFO pci;

    CheckDDECritOut;

    if (hwndTarget == pie->hwndSkip) {
        return (TRUE);
    }

    if (pie->hConvList && pie->laTopic && pie->laServiceRequested) {
        /*
         * Head off duplicates BEFORE we send the WM_DDE_INITIATE messages!
         */
        PCONVLIST pcl;
        PCONV_INFO pcoiExisting;
        int i;

        EnterDDECrit;
        /*
         * We revalidate hConvList here because we left the critical section.
         */
        pcl = (PCONVLIST)ValidateCHandle((HANDLE)pie->hConvList,
                HTYPE_CONVERSATION_LIST, HINST_ANY);
        if (pcl != NULL) {
            for (i = 0; i < pcl->chwnd; i++) {
                for (pcoiExisting = (PCONV_INFO)GetWindowLongPtr(pcl->ahwnd[i], GWLP_PCI);
                        pcoiExisting != NULL;
                        pcoiExisting = pcoiExisting->next) {
                    if (pcoiExisting->state & ST_CONNECTED &&
                            ((PCL_CONV_INFO)pcoiExisting)->hwndReconnect == hwndTarget &&
                            pcoiExisting->laTopic == pie->laTopic &&
                            pcoiExisting->laService == pie->laServiceRequested) {
                        LeaveDDECrit;
                        return(TRUE);
                    }
                }
            }
        }
        LeaveDDECrit;
    }

    CheckDDECritOut;

    SendMessage(hwndTarget, WM_DDE_INITIATE, (WPARAM)pie->hwndClient,
            pie->lParam);

    EnterDDECrit;

    //
    // During the initiate process, any acks received cause more pci's
    // to become linked together under the same hwndClient. Once
    // the SendMessage() returns, we set the parts of the new pci's
    // that hold initiate context information.
    //
    pci = (PCL_CONV_INFO)GetWindowLongPtr(pie->hwndClient, GWLP_PCI);
    if (pci == NULL) {
        LeaveDDECrit;
        return (TRUE);
    }

    while (pci != NULL) {
        if (pci->hwndReconnect == 0) {  // this one needs updating
            pci->hwndReconnect = hwndTarget;
            if (pie->laServiceRequested) {
                pci->ci.laServiceRequested = pie->laServiceRequested;
                IncLocalAtomCount(pie->laServiceRequested); // pci copy
            }
        }
        if (pie->clst == CLST_SINGLE_INITIALIZING) {
            break;
        }
        pci = (PCL_CONV_INFO)pci->ci.next;
    }
    LeaveDDECrit;
    return (pie->clst == CLST_MULT_INITIALIZING);
}




/***************************************************************************\
* SetCommonStateFlags()
*
* Description:
*   Common client/server worker function
*
* History:
* 05-12-91 sanfords Created.
\***************************************************************************/
VOID SetCommonStateFlags(
HWND hwndUs,
HWND hwndThem,
PWORD pwFlags)
{
    DWORD pidUs, pidThem;

    GetWindowThreadProcessId(hwndUs, &pidUs);
    GetWindowThreadProcessId(hwndThem, &pidThem);
    if (pidUs == pidThem) {
        *pwFlags |= ST_INTRA_PROCESS;
    }

    if (IsWindowUnicode(hwndUs) && IsWindowUnicode(hwndThem)) {
        *pwFlags |= ST_UNICODE_EXECUTE;
    }
}




/***************************************************************************\
* DdeQueryNextServer (DDEML API)
*
* Description:
* Enumerates conversations within a list.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, HCONV, DUMMYCALLINGTYPE, DdeQueryNextServer, HCONVLIST, hConvList, HCONV, hConvPrev)
HCONV DdeQueryNextServer(
    HCONVLIST hConvList,
    HCONV hConvPrev)
{
    HCONV hConvRet = 0;
    PCONVLIST pcl;
    HWND *phwnd;
    int i;
    PCL_CONV_INFO pci;
    PCL_INSTANCE_INFO pcii;

    EnterDDECrit;

    pcl = (PCONVLIST)ValidateCHandle((HANDLE)hConvList,
            HTYPE_CONVERSATION_LIST, HINST_ANY);
    if (pcl == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (!pcl->chwnd) {      // empty list
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hConvList);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    pcii->LastError = DMLERR_NO_ERROR;

    do {

        hConvRet = 0;

        if (hConvPrev == 0) {
            pci = (PCL_CONV_INFO)GetWindowLongPtr(pcl->ahwnd[0], GWLP_PCI);
            if (pci == NULL) {
                goto Exit;  // Must have all conversations zombied.
            }
            hConvPrev = hConvRet = pci->ci.hConv;
            continue;
        }

        pci = (PCL_CONV_INFO)ValidateCHandle((HANDLE)hConvPrev,
                HTYPE_CLIENT_CONVERSATION, InstFromHandle(hConvList));
        if (pci == NULL) {
            pci = (PCL_CONV_INFO)ValidateCHandle((HANDLE)hConvPrev,
                    HTYPE_ZOMBIE_CONVERSATION, InstFromHandle(hConvList));
            if (pci == NULL) {
                SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
                break;
            } else {
                goto ZombieSkip;
            }
        }

        if (pci->hConvList != hConvList) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            break;
        }

ZombieSkip:

        if (pci->ci.next == NULL) {

            /*
             * end of list for this window, go to next window
             */
            for (phwnd = pcl->ahwnd, i = 0; (i + 1) < pcl->chwnd; i++) {
                if (phwnd[i] == pci->ci.hwndConv) {
                    pci = (PCL_CONV_INFO)GetWindowLongPtr(phwnd[i + 1], GWLP_PCI);
                    if (pci == NULL) {
                        break;
                    }
                    hConvPrev = hConvRet = pci->ci.hConv;
                    break;
                }
            }
        } else {

            hConvPrev = hConvRet = pci->ci.next->hConv; // next conv for this window.
        }

    } while (hConvRet && TypeFromHandle(hConvRet) == HTYPE_ZOMBIE_CONVERSATION);
Exit:
    LeaveDDECrit;
    return (hConvRet);
}





/***************************************************************************\
* DdeDisconnect (DDEML API)
*
* Description:
* Terminates a conversation.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeDisconnect, HCONV, hConv)
BOOL DdeDisconnect(
    HCONV hConv)
{
    BOOL fRet = FALSE;
    PCONV_INFO pcoi;
    PCL_INSTANCE_INFO pcii;

    CheckDDECritOut;
    EnterDDECrit;

    pcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
            HTYPE_CLIENT_CONVERSATION, HINST_ANY);
    if (pcoi == NULL) {
        pcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
                HTYPE_SERVER_CONVERSATION, HINST_ANY);
    }
    if (pcoi == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hConv);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (pcoi->state & ST_CONNECTED) {
        ShutdownConversation(pcoi, FALSE);
    }
    fRet = TRUE;

Exit:
    LeaveDDECrit;
    return (fRet);
}


/***************************************************************************\
* DdeDisconnectList (DDEML API)
*
* Description:
* Terminates all conversations in a conversation list and frees the list.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeDisconnectList, HCONVLIST, hConvList)
BOOL DdeDisconnectList(
    HCONVLIST hConvList)
{
    BOOL fRet = FALSE;
    PCL_INSTANCE_INFO pcii;
    PCONVLIST pcl;
    PCONV_INFO pcoi, pcoiNext;
    int i;

    CheckDDECritOut;
    EnterDDECrit;

    pcl = (PCONVLIST)ValidateCHandle((HANDLE)hConvList,
            HTYPE_CONVERSATION_LIST, HINST_ANY);
    if (pcl == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    ValidateConvList(hConvList);
    pcii = PciiFromHandle((HANDLE)hConvList);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    for(i = pcl->chwnd - 1; i >= 0; i--) {
        pcoi = (PCONV_INFO)GetWindowLongPtr(pcl->ahwnd[i], GWLP_PCI);
        while (pcoi != NULL && pcoi->state & ST_CONNECTED) {
            pcoiNext = pcoi->next;
            ShutdownConversation(pcoi, FALSE);  // may unlink pcoi!
            pcoi = pcoiNext;
        }
    }

    DestroyHandle((HANDLE)hConvList);
    DDEMLFree(pcl);
    fRet = TRUE;

Exit:
    LeaveDDECrit;
    return (fRet);
}




/***************************************************************************\
* ShutdownConversation
*
* Description:
* This function causes an imediate termination of the given conversation
* and generates apropriate callbacks to notify the application.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID ShutdownConversation(
    PCONV_INFO pcoi,
    BOOL fMakeCallback)
{
    CheckDDECritIn;

    if (pcoi->state & ST_CONNECTED) {
        pcoi->state &= ~ST_CONNECTED;

        if (IsWindow(pcoi->hwndPartner)) {
            PostMessage(pcoi->hwndPartner, WM_DDE_TERMINATE,
                    (WPARAM)pcoi->hwndConv, 0);
        }
        if (fMakeCallback && !(pcoi->pcii->afCmd & CBF_SKIP_DISCONNECTS)) {
            DoCallback(pcoi->pcii, (WORD)XTYP_DISCONNECT, 0, pcoi->hConv,
                    0, 0, 0, 0, (pcoi->state & ST_ISSELF) ? 1L : 0L);
        }
        MONCONV(pcoi, FALSE);
    }

    FreeConversationResources(pcoi);
}



/***************************************************************************\
* UnlinkConvFromOthers
*
* Description:
*
* Helper function to handle ugly cross dependency removal.  If we are
* unlinking a conversation that is going zombie, fGoingZombie is TRUE;
*
* Conversations that are going zombie are in phase 1 of a 2 phase unlink.
* Phase 1 unlinks do not remove the pcoi from its hwnd's list.
* All unlinks should result in:
*   pcoi->hConvList = 0;
*   hConvList/aServerLookup no longer refrences pcoi->hwndConv unless
*       one of the pcoi's related to hwndConv is still active.
*
*
* History:
*  3-2-92 sanfords Created.
\***************************************************************************/
VOID UnlinkConvFromOthers(
PCONV_INFO pcoi,
BOOL gGoingZombie)
{
    PCONV_INFO pcoiPrev, pcoiFirst, pcoiNow;
    PCONVLIST pcl;
    int i, cActiveInList = 0;
#ifdef TESTING
    DWORD path = 0;
#define ORPATH(x) path |= x;
#else
#define ORPATH(x)
#endif // TESTING

    CheckDDECritIn;

    /*
     * Scan pcoi linked list to get key pointers.
     */
    pcoiPrev = NULL;
    pcoiFirst = pcoiNow = (PCONV_INFO)GetWindowLongPtr(pcoi->hwndConv, GWLP_PCI);

#ifdef TESTING
    /*
     * verify that pcoi is in the conv list for this window.
     */
    while (pcoiNow != NULL) {
        if (pcoiNow == pcoi) {
            goto FoundIt;
        }
        pcoiNow = pcoiNow->next;
    }
    DebugBreak();
FoundIt:
    pcoiNow = pcoiFirst;
#endif // TESTING

    UserAssert(pcoiFirst);
    while (pcoiNow != NULL) {
        if (TypeFromHandle(pcoiNow->hConv) != HTYPE_ZOMBIE_CONVERSATION) {
            ORPATH(1);
            cActiveInList++;
        }
        if (pcoiNow->next == pcoi) {
            pcoiPrev = pcoiNow;
        }
        pcoiNow = pcoiNow->next;
    }

    ValidateAllConvLists();

    /*
     * Unlink conversation unless its going Zombie.
     */
    if (!gGoingZombie) {
        ORPATH(2);
        if (TypeFromHandle(pcoi->hConv) != HTYPE_ZOMBIE_CONVERSATION) {
            ORPATH(4);
            cActiveInList--;
        }

        if (pcoiPrev == NULL) {
            ORPATH(8);
            pcoiFirst = pcoi->next;
            SetWindowLongPtr(pcoi->hwndConv, GWLP_PCI, (LONG_PTR)pcoiFirst);
        } else {
            pcoiPrev->next = pcoi->next;
        }
    }

    UserAssert(pcoiFirst != NULL || !cActiveInList);

    if (cActiveInList == 0) {
        ORPATH(0x10);
        if (pcoi->state & ST_CLIENT) {
            ORPATH(0x20);
            if (((PCL_CONV_INFO)pcoi)->hConvList) {
                /*
                 * Remove pcoi's hwnd from its hConvList.
                 */
                pcl = (PCONVLIST)GetHandleData((HANDLE)((PCL_CONV_INFO)pcoi)->hConvList);
                for (i = 0; i < pcl->chwnd; i++) {
                    if (pcl->ahwnd[i] == pcoi->hwndConv) {
                        ORPATH(0x40);
                        pcl->chwnd--;
                        UserAssert(pcl->ahwnd[pcl->chwnd]);
                        pcl->ahwnd[i] = pcl->ahwnd[pcl->chwnd];
                        ValidateConvList(((PCL_CONV_INFO)pcoi)->hConvList);
                        break;
                    }
                }
                ORPATH(0x80);
            }
        } else {  // SERVER
            /*
             * remove server window from the service/topic lookup table.
             */
            ORPATH(0x100);
            for (i = 0; i < pcoi->pcii->cServerLookupAlloc; i++) {
                if (pcoi->pcii->aServerLookup[i].hwndServer == pcoi->hwndConv) {
                    ORPATH(0x200);
                    
                    /*
                     * Check for appcompat hack
                     */
                    if (GetAppCompatFlags2(VERMAX) & GACF2_DDE) {
                        DeleteAtom(pcoi->pcii->aServerLookup[i].laService); // delete laService
                        DeleteAtom(pcoi->pcii->aServerLookup[i].laTopic);   // delete laTopic
                    }
                    
                    if (--(pcoi->pcii->cServerLookupAlloc)) {
                        ORPATH(0x400);
                        pcoi->pcii->aServerLookup[i] =
                                pcoi->pcii->aServerLookup[pcoi->pcii->cServerLookupAlloc];
                    } else {
                        DDEMLFree(pcoi->pcii->aServerLookup);
                        pcoi->pcii->aServerLookup = NULL;
                    }
                    break;
                }
            }
        }
    }
#ifdef TESTING
      else {
        /*
         * make sure at this point we have at least one non-zombie
         */
        pcoiNow = pcoiFirst;
        while (pcoiNow != NULL) {
            if (TypeFromHandle(pcoiNow->hConv) != HTYPE_ZOMBIE_CONVERSATION) {
                goto Out;
            }
            pcoiNow = pcoiNow->next;
        }
        DebugBreak();
Out:
        ;
    }
#endif // TESTING

    ValidateAllConvLists();
    ORPATH(0x800);

    /*
     * In any case remove hConvList references from client conversation.
     */
    if (pcoi->state & ST_CLIENT) {
#ifdef TESTING
        /*
         * Verify that the hConvList that is being removed, doesn't reference
         * this window.
         */
        if (((PCL_CONV_INFO)pcoi)->hConvList && !cActiveInList) {
            BOOL fFound = FALSE;

            pcl = (PCONVLIST)GetHandleData((HANDLE)((PCL_CONV_INFO)pcoi)->hConvList);
            for (i = 0; i < pcl->chwnd; i++) {
                if (pcl->ahwnd[i] == pcoi->hwndConv) {
                    fFound = TRUE;
                    break;
                }
            }
            UserAssert(!fFound);
        }
#endif // TESTING
        ((PCL_CONV_INFO)pcoi)->hConvList = 0;
        pcoi->state &= ~ST_INLIST;
    }

    /*
     * last one out turns out the lights.
     */
    if (pcoiFirst == NULL) {
        /*
         * If the pcoi list is empty, this window can go away.
         */
        LeaveDDECrit;
        NtUserDestroyWindow(pcoi->hwndConv);
        EnterDDECrit;
    }
}





/***************************************************************************\
* FreeConversationResources
*
* Description:
* Used when: Client window is disconnected by app, Server window is
* disconnected by either side, or when a conversation is disconnected
* at Uninitialize time.
*
* This function releases all resources held by the pcoi and unlinks it
* from its host window pcoi chian. pcoi is freed once this return s.
*
* History:
* 12-21-91 sanfords Created.
\***************************************************************************/
VOID FreeConversationResources(
    PCONV_INFO pcoi)
{
    PADVISE_LINK paLink;
    PDDE_MESSAGE_QUEUE pdmq;
    PXACT_INFO pxi;

    CheckDDECritIn;

    /*
     * Don't free resources on locked conversations.
     */
    if (pcoi->cLocks > 0) {
        pcoi->state |= ST_FREE_CONV_RES_NOW;
        return;
    }

    /*
     * Don't free resources if a synchronous transaction is in effect!
     */
    pxi = pcoi->pxiOut;
    while (pxi != NULL) {
        if (pxi->flags & XIF_SYNCHRONOUS) {
            /*
             * This conversation is in a synchronous transaction.
             * Shutdown the modal loop FIRST, then call this when
             * the loop exits.
             */
            PostMessage(pcoi->hwndConv, WM_TIMER, TID_TIMEOUT, 0);
            pcoi->state |= ST_FREE_CONV_RES_NOW;
            return;
        }
        pxi = pxi->next;
    }

    /*
     * If this is an Intra-Process conversation that hasn't yet received
     * a terminate message, make it a zombie.  We will call this routine
     * again once the terminate arrives or when WaitForZombieTerminate() has
     * timed out waiting.
     */
    if (pcoi->state & ST_INTRA_PROCESS && !(pcoi->state & ST_TERMINATE_RECEIVED)) {
        DestroyHandle((HANDLE)pcoi->hConv);
        pcoi->hConv = (HCONV)CreateHandle((ULONG_PTR)pcoi, HTYPE_ZOMBIE_CONVERSATION,
                InstFromHandle(pcoi->hConv));
        UnlinkConvFromOthers(pcoi, TRUE);
        return;
    }

    /*
     * remove any transactions left in progress
     */
    while (pcoi->pxiOut != NULL) {
        (pcoi->pxiOut->pfnResponse)(pcoi->pxiOut, 0, 0);
    }

    /*
     * Throw away any incoming queued DDE messages.
     */
    while (pcoi->dmqOut != NULL) {

        pdmq = pcoi->dmqOut;
        DumpDDEMessage(!(pcoi->state & ST_INTRA_PROCESS), pdmq->msg, pdmq->lParam);
        pcoi->dmqOut = pcoi->dmqOut->next;
        if (pcoi->dmqOut == NULL) {
            pcoi->dmqIn = NULL;
        }
        DDEMLFree(pdmq);
    }

    //
    // Remove all link info
    //
    paLink = pcoi->aLinks;
    while (pcoi->cLinks) {
        if (pcoi->state & ST_CLIENT) {
            MONLINK(pcoi->pcii, FALSE, paLink->wType & XTYPF_NODATA,
                    pcoi->laService, pcoi->laTopic,
                    LocalToGlobalAtom(paLink->laItem),
                    paLink->wFmt, FALSE,
                    (HCONV)pcoi->hwndPartner, (HCONV)pcoi->hwndConv);
        } else {
            MONLINK(pcoi->pcii, FALSE, paLink->wType & XTYPF_NODATA,
                    pcoi->laService, pcoi->laTopic,
                    LocalToGlobalAtom(paLink->laItem),
                    paLink->wFmt, TRUE,
                    (HCONV)pcoi->hwndConv, (HCONV)pcoi->hwndPartner);
        }
        if (!(pcoi->state & ST_CLIENT)) {
            DeleteLinkCount(pcoi->pcii, paLink->pLinkCount);
        }
        DeleteAtom(paLink->laItem); // link structure copy
        paLink++;
        pcoi->cLinks--;
    }
    if (pcoi->aLinks) {
        DDEMLFree(pcoi->aLinks);
    }

    //
    // free atoms associated with this conv
    //
    DeleteAtom(pcoi->laService);
    DeleteAtom(pcoi->laTopic);
    if (pcoi->laServiceRequested) {
        DeleteAtom(pcoi->laServiceRequested);
    }

    UnlinkConvFromOthers(pcoi, FALSE);

    /*
     * invalidate app's conversation handle
     */
    DestroyHandle((HANDLE)pcoi->hConv);

    DDEMLFree(pcoi);
}



BOOL WaitForZombieTerminate(
HANDLE hData)
{
    PCONV_INFO pcoi;
    MSG msg;
    HWND hwnd;
    BOOL fTerminated;
    DWORD fRet = 0;

    CheckDDECritOut;
    EnterDDECrit;

    fTerminated = FALSE;
    while ((pcoi = (PCONV_INFO)ValidateCHandle(hData,
            HTYPE_ZOMBIE_CONVERSATION, InstFromHandle(hData))) != NULL &&
            !(pcoi->state & ST_TERMINATE_RECEIVED)) {
        hwnd = pcoi->hwndConv;
        LeaveDDECrit;
        while (PeekMessage(&msg, hwnd, WM_DDE_FIRST, WM_DDE_LAST, PM_REMOVE)) {
            DispatchMessage(&msg);
            if (msg.message == WM_DDE_TERMINATE) {
                fTerminated = TRUE;
            }
        }
        if (!fTerminated) {
            fRet = MsgWaitForMultipleObjectsEx(0, NULL, 100, QS_POSTMESSAGE, 0);
            if (fRet == 0xFFFFFFFF) {
                RIPMSG0(RIP_WARNING, "WaitForZombieTerminate: I give up - faking terminate.");
                ProcessTerminateMsg(pcoi, pcoi->hwndPartner);
                EnterDDECrit;
                return(FALSE);
            }
        }
        EnterDDECrit;
    }
    LeaveDDECrit;
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\comboini.c ===
/**************************** Module Header ********************************\
* Module Name: comboini.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* All the (one time) initialization/destruction code used for combo boxes
*
* History:
* 12-05-90 IanJa        Ported
* 01-Feb-1991 mikeke    Added Revalidation code
* 20-Jan-1992 IanJa     ANSI/UNIOCDE netralization
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern LOOKASIDE ComboboxLookaside;

#define RECALC_CYDROP   -1

void xxxCBSetDroppedSize(PCBOX pcbox, LPRECT lprc);

/***************************************************************************\
* CBNcCreateHandler
*
* Allocates space for the CBOX structure and sets the window to point to it.
*
* History:
\***************************************************************************/

LONG CBNcCreateHandler(
    PCBOX pcbox,
    PWND pwnd)
{
    /*
     * Save the style bits so that we have them when we create the client area
     * of the combo box window.
     */
    pcbox->styleSave = pwnd->style & (WS_VSCROLL | WS_HSCROLL);

    if (!TestWF(pwnd, CBFOWNERDRAW))
        // Add in CBS_HASSTRINGS if the style is implied...
        SetWindowState(pwnd, CBFHASSTRINGS);

    UserAssert(HIBYTE(WFVSCROLL) == HIBYTE(WFHSCROLL));
    UserAssert(HIBYTE(WFHSCROLL) == HIBYTE(WFBORDER));
    ClearWindowState(pwnd, WFVSCROLL | WFHSCROLL | WFBORDER);

    //
    // If the window is 4.0 compatible or has a CLIENTEDGE, draw the combo
    // in 3D.  Otherwise, use a flat border.
    //
    if (TestWF(pwnd, WFWIN40COMPAT) || TestWF(pwnd, WEFCLIENTEDGE))
        pcbox->f3DCombo = TRUE;

    ClearWindowState(pwnd, WEFEDGEMASK);

    return (LONG)TRUE;
}

/***************************************************************************\
* xxxCBCreateHandler
*
* Creates all the child controls within the combo box
* Returns -1 if error
*
* History:
\***************************************************************************/

LRESULT xxxCBCreateHandler(
    PCBOX pcbox,
    PWND pwnd)
{
    LONG lStyleT;
    RECT rcList;
    HWND hwndList;
    HWND hwndEdit;
    DWORD lExStyle;

    CheckLock(pwnd);

    /*
     * Don't lock the combobox window: this would prevent WM_FINALDESTROY
     * being sent to it, so pwnd and pcbox wouldn't get freed (zombies)
     * until thread cleanup. (IanJa)  LATER: change name from spwnd to pwnd.
     * Lock(&pcbox->spwnd, pwnd); - caused a 'catch-22'
     */
    Lock(&(pcbox->spwndParent), REBASEPWND(pwnd, spwndParent));

    /*
     * Break out the style bits so that we will be able to create the listbox
     * and editcontrol windows.
     */

    if (TestWF(pwnd, CBFDROPDOWNLIST) == LOBYTE(CBFDROPDOWNLIST)) {
        pcbox->CBoxStyle = SDROPDOWNLIST;
        pcbox->fNoEdit = TRUE;
    } else if (TestWF(pwnd, CBFDROPDOWN))
        pcbox->CBoxStyle = SDROPDOWN;
    else
        pcbox->CBoxStyle = SSIMPLE;

    pcbox->fRtoLReading = (TestWF(pwnd, WEFRTLREADING) != 0);
    pcbox->fRightAlign  = (TestWF(pwnd, WEFRIGHT) != 0);

    if (TestWF(pwnd, CBFUPPERCASE))
        pcbox->fCase = UPPERCASE;
    else if (TestWF(pwnd, CBFLOWERCASE))
        pcbox->fCase = LOWERCASE;
    else
        pcbox->fCase = 0;

    // Listbox item flags.
    if (TestWF(pwnd, CBFOWNERDRAWVAR))
        pcbox->OwnerDraw = OWNERDRAWVAR;
    if (TestWF(pwnd, CBFOWNERDRAWFIXED)) {
        pcbox->OwnerDraw = OWNERDRAWFIXED;
    }

    /*
     * Get the size of the combo box rectangle.
     */
    // Get control sizes.
    pcbox->cxCombo = pwnd->rcWindow.right - pwnd->rcWindow.left;
    pcbox->cyDrop  = RECALC_CYDROP;
    pcbox->cxDrop  = 0;
    xxxCBCalcControlRects(pcbox, &rcList);

    //
    // We need to do this because listboxes, as of VER40, have stopped
    // reinflating themselves by CXBORDER and CYBORDER.
    //
    if (!TestWF(pwnd, WFWIN40COMPAT))
        InflateRect(&rcList, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

    /*
     * Note that we have to create the listbox before the editcontrol since the
     * editcontrol code looks for and saves away the listbox pwnd and the
     * listbox pwnd will be NULL if we don't create it first.  Also, hack in
     * some special +/- values for the listbox size due to the way we create
     * listboxes with borders.
     */
    lStyleT = pcbox->styleSave;

    lStyleT |= WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_COMBOBOX | WS_CLIPSIBLINGS;

    if (TestWF(pwnd, WFDISABLED))
        lStyleT |= WS_DISABLED;
    if (TestWF(pwnd, CBFNOINTEGRALHEIGHT))
        lStyleT |= LBS_NOINTEGRALHEIGHT;
    if (TestWF(pwnd, CBFSORT))
        lStyleT |= LBS_SORT;
    if (TestWF(pwnd, CBFHASSTRINGS))
        lStyleT |= LBS_HASSTRINGS;
    if (TestWF(pwnd, CBFDISABLENOSCROLL))
        lStyleT |= LBS_DISABLENOSCROLL;

    if (pcbox->OwnerDraw == OWNERDRAWVAR)
        lStyleT |= LBS_OWNERDRAWVARIABLE;
    else if (pcbox->OwnerDraw == OWNERDRAWFIXED)
        lStyleT |= LBS_OWNERDRAWFIXED;

    if (pcbox->CBoxStyle & SDROPPABLE)
        lStyleT |= WS_BORDER;

    lExStyle = pwnd->ExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);
    hwndList = _CreateWindowEx(lExStyle |
            ((pcbox->CBoxStyle & SDROPPABLE) ? WS_EX_TOOLWINDOW : WS_EX_CLIENTEDGE),
            MAKEINTRESOURCE(gpsi->atomSysClass[ICLS_COMBOLISTBOX]), NULL, lStyleT,
            rcList.left, rcList.top, rcList.right - rcList.left,
            rcList.bottom - rcList.top,
            HW(pwnd), (HMENU)CBLISTBOXID, KHANDLE_TO_HANDLE(pcbox->spwnd->hModule), NULL,
            0);
    Lock(&(pcbox->spwndList), ValidateHwnd(hwndList));

    if (!pcbox->spwndList) {
        return -1;
    }

    /*
     * Create either the edit control or the static text rectangle.
     */
    if (pcbox->fNoEdit) {

        /*
         * No editcontrol so we will draw text directly into the combo box
         * window.
         */
        /*
         * Don't lock the combobox window: this would prevent WM_FINALDESTROY
         * being sent to it, so pwnd and pcbox wouldn't get freed (zombies)
         * until thread cleanup. (IanJa)  LATER: change name from spwnd to pwnd.
         * Lock(&(pcbox->spwndEdit), pcbox->spwnd); - caused a 'catch-22'
         */
        pcbox->spwndEdit = pcbox->spwnd;
    } else {
        DWORD dwCsFlags;

        lStyleT = WS_CHILD | WS_VISIBLE | ES_COMBOBOX | ES_NOHIDESEL;
        if (TestWF(pwnd, WFDISABLED))
            lStyleT |= WS_DISABLED;
        if (TestWF(pwnd, CBFAUTOHSCROLL))
            lStyleT |= ES_AUTOHSCROLL;
        if (TestWF(pwnd, CBFOEMCONVERT))
            lStyleT |= ES_OEMCONVERT;
        if (pcbox->fCase)
            lStyleT |= (pcbox->fCase & UPPERCASE) ? ES_UPPERCASE : ES_LOWERCASE;

        /*
         * Edit control need to know whether original CreateWindow*() call
         * was ANSI or Unicode.
         */
        dwCsFlags = TestWF(pcbox->spwnd, WFANSICREATOR) ? CW_FLAGS_ANSI : 0L;
        if (lExStyle & WS_EX_RIGHT)
            lStyleT |= ES_RIGHT;

        hwndEdit = _CreateWindowEx(lExStyle,
            MAKEINTRESOURCE(gpsi->atomSysClass[ICLS_EDIT]), NULL, lStyleT,
            pcbox->editrc.left, pcbox->editrc.top,
            pcbox->editrc.right - pcbox->editrc.left, pcbox->editrc.bottom -
            pcbox->editrc.top, HW(pwnd), (HMENU)CBEDITID,
            KHANDLE_TO_HANDLE(pcbox->spwnd->hModule), NULL,
            dwCsFlags);
        Lock(&(pcbox->spwndEdit), ValidateHwnd(hwndEdit));
    }
    if (!pcbox->spwndEdit)
        return -1L;

    if (pcbox->CBoxStyle & SDROPPABLE) {

        NtUserShowWindow(hwndList, SW_HIDE);
        NtUserSetParent(hwndList, NULL);

        // We need to do this so dropped size works right
        if (!TestWF(pwnd, WFWIN40COMPAT))
            InflateRect(&rcList, SYSMET(CXBORDER), SYSMET(CYBORDER));

        xxxCBSetDroppedSize(pcbox, &rcList);
    }

    /*
     * return anything as long as it's not -1L (-1L == error)
     */
    return (LRESULT)pwnd;
}

/***************************************************************************\
* xxxCBCalcControlRects
*
* History:
\***************************************************************************/

void xxxCBCalcControlRects(PCBOX pcbox, LPRECT lprcList)
{
    HDC hdc;
    HANDLE hOldFont = NULL;
    int             dyEdit, dxEdit;
    MEASUREITEMSTRUCT mis;
    SIZE size;
    HWND hwnd = HWq(pcbox->spwnd);
    TL tlpwndParent;

    CheckLock(pcbox->spwnd);

    /*
     * Determine height of the edit control.  We can use this info to center
     * the button with recpect to the edit/static text window.  For example
     * this will be useful if owner draw and this window is tall.
     */
    hdc = NtUserGetDC(hwnd);
    if (pcbox->hFont) {
        hOldFont = SelectObject(hdc, pcbox->hFont);
    }

    // Add on CYEDGE just for some extra space in the edit field/static item.
    // It's really only for static text items, but we want static & editable
    // controls to be the same height.
    GetTextExtentPoint(hdc, szOneChar, 1, &size);
    dyEdit = size.cy + SYSMET(CYEDGE);

    if (hOldFont) {
        SelectObject(hdc, hOldFont);
    }

    /*
     * IanJa: was ReleaseDC(pcbox->hwnd, hdc);
     */
    NtUserReleaseDC(hwnd, hdc);

    if (pcbox->OwnerDraw) {
        // This is an ownerdraw combo.  Have the owner tell us how tall this
        // item is.
        int iOwnerDrawHeight;

        if (iOwnerDrawHeight = pcbox->editrc.bottom - pcbox->editrc.top) {
            dyEdit = iOwnerDrawHeight;
        } else {
            /*
             * No height has been defined yet for the static text window.  Send
             * a measure item message to the parent
             */
            mis.CtlType = ODT_COMBOBOX;
            mis.CtlID = PtrToUlong(pcbox->spwnd->spmenu);
            mis.itemID = (UINT)-1;
            mis.itemHeight = dyEdit;
            mis.itemData = 0;

            ThreadLock(pcbox->spwndParent, &tlpwndParent);
            SendMessage(HW(pcbox->spwndParent), WM_MEASUREITEM, mis.CtlID, (LPARAM)&mis);
            ThreadUnlock(&tlpwndParent);

            dyEdit = mis.itemHeight;
        }
    }
    /*
     * Set the initial width to be the combo box rect.  Later we will shorten it
     * if there is a dropdown button.
     */
    pcbox->cyCombo = 2*SYSMET(CYFIXEDFRAME) + dyEdit;
    dxEdit = pcbox->cxCombo - (2 * SYSMET(CXFIXEDFRAME));

    if (pcbox->cyDrop == RECALC_CYDROP)
    {
        // recompute the max height of the dropdown listbox -- full window
        // size MINUS edit/static height
        pcbox->cyDrop = max((pcbox->spwnd->rcWindow.bottom - pcbox->spwnd->rcWindow.top) - pcbox->cyCombo, 0);

        if (!TestWF(pcbox->spwnd, WFWIN40COMPAT) && (pcbox->cyDrop == 23))
            // This is VC++ 2.1's debug/release dropdown that they made super
            // small -- let's make 'em a wee bit bigger so the world can
            // continue to spin -- jeffbog -- 4/19/95 -- B#10029
            pcbox->cyDrop = 28;
    }

    /*
     * Determine the rectangles for each of the windows...  1.  Pop down button 2.
     * Edit control or generic window for static text or ownerdraw...  3.  List
     * box
     */

    // Is there a button?
    if (pcbox->CBoxStyle & SDROPPABLE) {
        // Determine button's rectangle.
        pcbox->buttonrc.top = SYSMET(CYEDGE);
        pcbox->buttonrc.bottom = pcbox->cyCombo - SYSMET(CYEDGE);
        if (pcbox->fRightAlign) {
            pcbox->buttonrc.left  = SYSMET(CXFIXEDFRAME);
            pcbox->buttonrc.right = pcbox->buttonrc.left + SYSMET(CXVSCROLL);
        } else {
            pcbox->buttonrc.right = pcbox->cxCombo - SYSMET(CXEDGE);
            pcbox->buttonrc.left  = pcbox->buttonrc.right - SYSMET(CXVSCROLL);
        }

        // Reduce the width of the edittext window to make room for the button.
        dxEdit = max(dxEdit - SYSMET(CXVSCROLL), 0);

    } else {

        /*
         * No button so make the rectangle 0 so that a point in rect will always
         * return false.
         */
        SetRectEmpty(KPRECT_TO_PRECT(&pcbox->buttonrc));
    }

    /*
     * So now, the edit rect is really the item area.
     */
    pcbox->editrc.left      = SYSMET(CXFIXEDFRAME);
    pcbox->editrc.right     = pcbox->editrc.left + dxEdit;
    pcbox->editrc.top       = SYSMET(CYFIXEDFRAME);
    pcbox->editrc.bottom    = pcbox->editrc.top + dyEdit;

    // Is there a right-aligned button?
    if ((pcbox->CBoxStyle & SDROPPABLE) && (pcbox->fRightAlign)) {
        pcbox->editrc.right   = pcbox->cxCombo - SYSMET(CXEDGE);
        pcbox->editrc.left    = pcbox->editrc.right - dxEdit;
    }

    lprcList->left          = 0;
    lprcList->top           = pcbox->cyCombo;
    lprcList->right         = max(pcbox->cxDrop, pcbox->cxCombo);
    lprcList->bottom        = pcbox->cyCombo + pcbox->cyDrop;
}

/***************************************************************************\
* xxxCBNcDestroyHandler
*
* Destroys the combobox and frees up all memory used by it
*
* History:
\***************************************************************************/

void xxxCBNcDestroyHandler(
    PWND pwnd,
    PCBOX pcbox)
{
    CheckLock(pwnd);

    /*
     * If there is no pcbox, there is nothing to clean up.
     */
    if (pcbox != NULL) {

        /*
         * [msadek, 02/04/2001] fInDestroy is used to prevent oing through destruction code twice.
         * This code happen when apps like Delphi 5 tries to destroy the combobox again during processing of 
         * WM_PARENTNOTIFY in the NtUserDestroyWindow call (below). Thus, we end up freeing the same lookaside entry twice.
         * Windows Bugs bug# 266084
         */ 
        if (!pcbox->fInDestroy) {    
            pcbox->fInDestroy = TRUE;
            /*
             * Destroy the list box here so that it'll send WM_DELETEITEM messages
             * before the combo box turns into a zombie.
             */
            if (pcbox->spwndList != NULL) {
                NtUserDestroyWindow(HWq(pcbox->spwndList));
                Unlock(&pcbox->spwndList);
            }

            pcbox->spwnd = NULL;
            Unlock(&pcbox->spwndParent);

            /*
             * If there is no editcontrol, spwndEdit is the combobox window which
             * isn't locked (that would have caused a 'catch-22').
             */
            if (pwnd != pcbox->spwndEdit) {
                Unlock(&pcbox->spwndEdit);
            }

            /*
             * Since a pointer and a handle to a fixed local object are the same.
             */
            FreeLookasideEntry(&ComboboxLookaside, KPVOID_TO_PVOID(pcbox));
        }
        else {
            RIPMSG1(RIP_WARNING, "Trying to destroy the same combobox %x twice. Ignoring", pcbox);
        }
    }

    /*
     * Set the window's fnid status so that we can ignore rogue messages
     */
    NtUserSetWindowFNID(HWq(pwnd), FNID_CLEANEDUP_BIT);
}

/***************************************************************************\
* xxxCBSetFontHandler
*
* History:
\***************************************************************************/

void xxxCBSetFontHandler(
    PCBOX pcbox,
    HANDLE hFont,
    BOOL fRedraw)
{
    TL tlpwndEdit;
    TL tlpwndList;

    CheckLock(pcbox->spwnd);

    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
    ThreadLock(pcbox->spwndList, &tlpwndList);

    pcbox->hFont = hFont;

    if (!pcbox->fNoEdit && pcbox->spwndEdit) {
        SendMessageWorker(pcbox->spwndEdit, WM_SETFONT, (WPARAM)hFont, FALSE, FALSE);
    }

    SendMessageWorker(pcbox->spwndList, WM_SETFONT, (WPARAM)hFont, FALSE, FALSE);

    // Recalculate the layout of controls.  This will hide the listbox also.
    xxxCBPosition(pcbox);

    if (fRedraw) {
        NtUserInvalidateRect(HWq(pcbox->spwnd), NULL, TRUE);
// LATER UpdateWindow(HW(pcbox->spwnd));
    }

    ThreadUnlock(&tlpwndList);
    ThreadUnlock(&tlpwndEdit);
}

/***************************************************************************\
* xxxCBSetEditItemHeight
*
* Sets the height of the edit/static item of a combo box.
*
* History:
* 06-27-91 DarrinM      Ported from Win 3.1.
\***************************************************************************/

LONG xxxCBSetEditItemHeight(
    PCBOX pcbox,
    int dyEdit)
{
    TL tlpwndEdit;
    TL tlpwndList;

    CheckLock(pcbox->spwnd);

    if (dyEdit > 255) {
        RIPERR0(ERROR_INVALID_EDIT_HEIGHT, RIP_VERBOSE, "");
        return CB_ERR;
    }

    pcbox->editrc.bottom = pcbox->editrc.top + dyEdit;
    pcbox->cyCombo = pcbox->editrc.bottom + SYSMET(CYFIXEDFRAME);

    if (pcbox->CBoxStyle & SDROPPABLE) {
        pcbox->buttonrc.bottom = pcbox->cyCombo - SYSMET(CYEDGE);
    }

    ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
    ThreadLock(pcbox->spwndList, &tlpwndList);


    /*
     * Reposition the editfield.
     * Don't let spwndEdit or List of NULL go through; if someone adjusts
     * the height on a NCCREATE; same as not having
     * HW instead of HWq but we don't go to the kernel.
     */
    if (!pcbox->fNoEdit && pcbox->spwndEdit) {
        NtUserMoveWindow(HWq(pcbox->spwndEdit), pcbox->editrc.left, pcbox->editrc.top,
            pcbox->editrc.right-pcbox->editrc.left, dyEdit, TRUE);
    }

    /*
     * Reposition the list and combobox windows.
     */
    if (pcbox->CBoxStyle == SSIMPLE) {
        if (pcbox->spwndList != 0) {
            NtUserMoveWindow(HWq(pcbox->spwndList), 0, pcbox->cyCombo, pcbox->cxCombo,
                pcbox->cyDrop, FALSE);

            NtUserSetWindowPos(HWq(pcbox->spwnd), HWND_TOP, 0, 0,
                pcbox->cxCombo, pcbox->cyCombo +
                pcbox->spwndList->rcWindow.bottom - pcbox->spwndList->rcWindow.top,
                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
    } else {
        if (pcbox->spwndList != NULL) {
            NtUserMoveWindow(HWq(pcbox->spwndList), pcbox->spwnd->rcWindow.left,
                pcbox->spwnd->rcWindow.top + pcbox->cyCombo,
                max(pcbox->cxDrop, pcbox->cxCombo), pcbox->cyDrop, FALSE);
        }

        NtUserSetWindowPos(HWq(pcbox->spwnd), HWND_TOP, 0, 0,
            pcbox->cxCombo, pcbox->cyCombo,
            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    ThreadUnlock(&tlpwndList);
    ThreadUnlock(&tlpwndEdit);

    return CB_OKAY;
}


/***************************************************************************\
* xxxCBSizeHandler
*
* Recalculates the sizes of the internal controls in response to a
* resizing of the combo box window.  The app must size the combo box to its
* maximum open/dropped down size.
*
* History:
\***************************************************************************/

void xxxCBSizeHandler(
    PCBOX pcbox)
{
    CheckLock(pcbox->spwnd);

    /*
     * Assume listbox is visible since the app should size it to its maximum
     * visible size.
     */
    pcbox->cxCombo = pcbox->spwnd->rcWindow.right - pcbox->spwnd->rcWindow.left;
    // only recalc cyDrop if the drop down is not TOTALLY nuked by the sizing
    // -- Visio 1.0 -- B#13112
    if (((pcbox->spwnd->rcWindow.bottom - pcbox->spwnd->rcWindow.top) - pcbox->cyCombo) > 0)
        pcbox->cyDrop = RECALC_CYDROP;

    // Reposition everything.
    xxxCBPosition(pcbox);
}

/***************************************************************************\
*
*  CBPosition()
*
*  Repositions components of edit control.
*
\***************************************************************************/
void xxxCBPosition(PCBOX pcbox)
{
    RECT rcList;

    // Calculate placement of components--button, item, list
    xxxCBCalcControlRects(pcbox, &rcList);

    if (!pcbox->fNoEdit && pcbox->spwndEdit) {
        TL tlpwndEdit;

        ThreadLock(pcbox->spwndEdit, &tlpwndEdit);
        NtUserMoveWindow(HWq(pcbox->spwndEdit), pcbox->editrc.left, pcbox->editrc.top,
            pcbox->editrc.right - pcbox->editrc.left,
            pcbox->editrc.bottom - pcbox->editrc.top, TRUE);
        ThreadUnlock(&tlpwndEdit);
    }

    // Recalculate drop height & width
    xxxCBSetDroppedSize(pcbox, &rcList);
}

/***************************************************************************\
*
*  CBSetDroppedSize()
*
*  Compute the drop down window's width and max height
*
\***************************************************************************/
void xxxCBSetDroppedSize(PCBOX pcbox, LPRECT lprc)
{
    TL tlpwndList;

    pcbox->fLBoxVisible = TRUE;
    xxxCBHideListBoxWindow(pcbox, FALSE, FALSE);

    ThreadLock(pcbox->spwndList, &tlpwndList);
    NtUserMoveWindow(HWq(pcbox->spwndList), lprc->left, lprc->top,
        lprc->right - lprc->left, lprc->bottom - lprc->top, FALSE);
    ThreadUnlock(&tlpwndList);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\csendw.c ===
/**************************************************************************\
* Module Name: csendw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client side sending stubs for UNICODE text
*
* History:
* 06-Jan-1992 IanJa
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CLIENTSIDE 1

#ifndef UNICODE
#define UNICODE
#endif

/**************************************************************************\
*
* include the stub definition file
*
\**************************************************************************/

#include "ntcftxt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\ctxapi.c ===
/****************************** Module Header ******************************\
* Module Name: ctxapi.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/**************************************************************
* CtxUserGetWinstationInfo
*
* This functin is called to get the winstation information such as Protocol name,
* Audio driver name etc. .All these information are passed in by client at
* connection time.
*
*
****************************************************************/

BOOL
CtxUserGetWinstationInfo(PWINSTATIONINFO pInfo)
{
   NTSTATUS status;

   status = NtUserRemoteGetWinstationInfo((PWSXINFO)pInfo);

   if (NT_SUCCESS(status)) {
      return TRUE;
   }
   else {
      return FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\ddemlcli.c ===
/****************************** Module Header ******************************\
* Module Name: ddemlcli.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager main client side module
*
* Created: 10/3/91 Sanford Staab
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

// DDEML globals

PCL_INSTANCE_INFO pciiList = NULL;
RTL_CRITICAL_SECTION gcsDDEML;
#if DBG
PVOID gpDDEMLHeap;
#endif

/***************************************************************************\
* DdeInitialize (DDEML API)
*
* Description:
* Used two different ways:
* 1) First time call (*pidInst == 0) - causes a DDEML instance to be
* created for the calling process/thread. Creates a server side
* event window, server side instance structure, DDE Access Object,
* and client side instance structure. The callback function address
* and filter flags (afCmd) are placed into these structures.
* 2) Subsequent call (*pidInst == hInst) - updates filter flags in
* client and server side structures.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, DdeInitializeA, LPDWORD, pidInst, PFNCALLBACK, pfnCallback, DWORD, afCmd, DWORD, ulRes)
UINT DdeInitializeA(
LPDWORD pidInst,
PFNCALLBACK pfnCallback,
DWORD afCmd,
DWORD ulRes)
{
    if (ulRes != 0) {
        return (DMLERR_INVALIDPARAMETER);
    }
    return (InternalDdeInitialize(pidInst, pfnCallback, afCmd, 0));
}



FUNCLOG4(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, DdeInitializeW, LPDWORD, pidInst, PFNCALLBACK, pfnCallback, DWORD, afCmd, DWORD, ulRes)
UINT DdeInitializeW(
LPDWORD pidInst,
PFNCALLBACK pfnCallback,
DWORD afCmd,
DWORD ulRes)
{
    if (ulRes != 0) {
        return (DMLERR_INVALIDPARAMETER);
    }
    return (InternalDdeInitialize(pidInst, pfnCallback, afCmd, 1));
}


UINT InternalDdeInitialize(
LPDWORD pidInst,
PFNCALLBACK pfnCallback,
DWORD afCmd,
BOOL fUnicode)
{
    UINT uiRet = DMLERR_MEMORY_ERROR;
    register PCL_INSTANCE_INFO pcii;

    if (afCmd & APPCLASS_MONITOR) {
        afCmd |= CBF_MONMASK;
    }

    if (afCmd & APPCMD_CLIENTONLY) {
        afCmd |= CBF_FAIL_CONNECTIONS;
    }

    EnterDDECrit;

    if (*pidInst != 0) {
        pcii = ValidateInstance((HANDLE)LongToHandle( *pidInst ));
        if (pcii == NULL) {
            uiRet = DMLERR_INVALIDPARAMETER;
            goto Exit;
        }

        // only allow certain bits to be changed on reinitialize call

        pcii->afCmd = (pcii->afCmd & ~(CBF_MASK | MF_MASK)) |
                (afCmd & (CBF_MASK | MF_MASK));

        LeaveDDECrit;
        NtUserUpdateInstance(pcii->hInstServer, &pcii->MonitorFlags, afCmd);
        return (DMLERR_NO_ERROR);
    }

    pcii = (PCL_INSTANCE_INFO)DDEMLAlloc(sizeof(CL_INSTANCE_INFO));
    if (pcii == NULL) {
        uiRet = DMLERR_MEMORY_ERROR;
        goto Exit;
    }

    pcii->plaNameService = (LATOM *)DDEMLAlloc(sizeof(LATOM));
    if (pcii->plaNameService == NULL) {
        uiRet = DMLERR_MEMORY_ERROR;
        goto Backout3;
    }
    // *pcii->plaNameService = 0; // zero init takes care of this
    pcii->cNameServiceAlloc = 1;


    /*
     * Flag this window as being create from a diff hmod as the app so
     * hotkeys don't take it as the first window created in the app and
     * assign it as the hotkey.
     */
    pcii->hwndMother =  _CreateWindowEx(0, (LPTSTR)(gpsi->atomSysClass[ICLS_DDEMLMOTHER]), L"",
            WS_POPUP, 0, 0, 0, 0, (HWND)0,
            (HMENU)0, 0, (LPVOID)NULL, CW_FLAGS_DIFFHMOD);

    if (pcii->hwndMother == 0) {
        uiRet = DMLERR_SYS_ERROR;
        goto Backout2;
    }
    SetWindowLongPtr(pcii->hwndMother, GWLP_INSTANCE_INFO, (LONG_PTR)pcii);

    pcii->afCmd = afCmd | APPCMD_FILTERINITS;
    pcii->pfnCallback = pfnCallback;
    // pcii->LastError = DMLERR_NO_ERROR; // zero init
    pcii->tid = GetCurrentThreadId();
    // pcii->aServerLookup = NULL;          // zero init
    // pcii->cServerLookupAlloc = 0;        // zero init
    // pcii->ConvStartupState = 0;          // zero init - Not blocked.
    // pcii->flags = 0;                     // zero init
    // pcii->cInDDEMLCallback = 0;          // zero init
    // pcii->pLinkCounts = NULL;            // zero init

    // Do this last when the client side is ready for whatever events
    // flying around may come charging in.

    LeaveDDECrit;
    uiRet = NtUserDdeInitialize(&pcii->hInstServer,
                            &pcii->hwndEvent,
                            &pcii->MonitorFlags,
                            pcii->afCmd,
                            pcii);
    EnterDDECrit;

    if (uiRet != DMLERR_NO_ERROR) {
Backout:
        NtUserDestroyWindow(pcii->hwndMother);
Backout2:
        DDEMLFree(pcii->plaNameService);
Backout3:
        DDEMLFree(pcii);
        goto Exit;
    }
    pcii->hInstClient = AddInstance(pcii->hInstServer);
    *pidInst = HandleToUlong(pcii->hInstClient);
    if (pcii->hInstClient == 0) {
        LeaveDDECrit;
        NtUserCallOneParam((ULONG_PTR)pcii->hInstServer, SFI__CSDDEUNINITIALIZE);
        EnterDDECrit;
        uiRet = DMLERR_MEMORY_ERROR;
        goto Backout;
    }
    SetHandleData(pcii->hInstClient, (ULONG_PTR)pcii);

    pcii->next = pciiList;
    pciiList = pcii;
    if (fUnicode) {
        pcii->flags |= IIF_UNICODE;
    }
    uiRet = DMLERR_NO_ERROR;

Exit:
    LeaveDDECrit;
    return (uiRet);
}



/***************************************************************************\
* DdeUninitialize (DDEML API)
*
* Description:
* Shuts down a DDEML instance and frees all associated resources.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeUninitialize, DWORD, idInst)
BOOL DdeUninitialize(
DWORD idInst)
{
    PCL_INSTANCE_INFO pcii, pciiPrev;
    BOOL fRet = FALSE;

    CheckDDECritOut;
    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    /*
     * If this thread is in the middle of a synchronous transaction or
     * a callback, we need to back out of those first.
     */
    if ((pcii->flags & IIF_IN_SYNC_XACT) || pcii->cInDDEMLCallback) {
        pcii->afCmd |= APPCMD_UNINIT_ASAP;
        fRet = TRUE;
        goto Exit;
    }

    ApplyFunctionToObjects(HTYPE_CONVERSATION_LIST, InstFromHandle(pcii->hInstClient),
            (PFNHANDLEAPPLY)DdeDisconnectList);
    ApplyFunctionToObjects(HTYPE_CLIENT_CONVERSATION, InstFromHandle(pcii->hInstClient),
            (PFNHANDLEAPPLY)DdeDisconnect);
    ApplyFunctionToObjects(HTYPE_SERVER_CONVERSATION, InstFromHandle(pcii->hInstClient),
            (PFNHANDLEAPPLY)DdeDisconnect);
    ApplyFunctionToObjects(HTYPE_ZOMBIE_CONVERSATION, InstFromHandle(pcii->hInstClient),
            (PFNHANDLEAPPLY)WaitForZombieTerminate);
    ApplyFunctionToObjects(HTYPE_DATA_HANDLE, InstFromHandle(pcii->hInstClient),
            (PFNHANDLEAPPLY)ApplyFreeDataHandle);

    LeaveDDECrit;
    NtUserCallOneParam((ULONG_PTR)pcii->hInstServer, SFI__CSDDEUNINITIALIZE);
    NtUserDestroyWindow(pcii->hwndMother);
    EnterDDECrit;

    DDEMLFree(pcii->plaNameService);
    DestroyInstance(pcii->hInstClient);

    // unlink pcii from pciiList

    if (pciiList == pcii) {
        pciiList = pciiList->next;
    } else {
        for (pciiPrev = pciiList; pciiPrev != NULL && pciiPrev->next != pcii;
                pciiPrev = pciiPrev->next) {
            ;
        }
        if (pciiPrev != NULL) {
            pciiPrev->next = pcii->next;
        }
    }
    DDEMLFree(pcii);
    fRet = TRUE;

Exit:
    LeaveDDECrit;
    return (fRet);
}



/***************************************************************************\
* DdeNameService (DDEML API)
*
* Description:
* Registers, and Unregisters service names and sets the Initiate filter
* state for an instance.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
HDDEDATA DdeNameService(
DWORD idInst,
HSZ hsz1, // service name
HSZ hsz2, // reserved for future enhancements
UINT afCmd) // DNS_ flags.
{
    BOOL fRet = TRUE;
    LATOM *plaNameService;
    PCL_INSTANCE_INFO pcii;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        fRet = FALSE;
        goto Exit;
    }

    if ((hsz1 && ValidateHSZ(hsz1) == HSZT_INVALID) || hsz2 != 0) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        fRet = FALSE;
        goto Exit;
    }

    if (afCmd & DNS_FILTERON && !(pcii->afCmd & APPCMD_FILTERINITS)) {
        pcii->afCmd |= APPCMD_FILTERINITS;
        NtUserUpdateInstance(pcii->hInstServer, &pcii->MonitorFlags, pcii->afCmd);
    }
    if (afCmd & DNS_FILTEROFF && (pcii->afCmd & APPCMD_FILTERINITS)) {
        pcii->afCmd &= ~APPCMD_FILTERINITS;
        NtUserUpdateInstance(pcii->hInstServer, &pcii->MonitorFlags, pcii->afCmd);
    }

    if (afCmd & (DNS_REGISTER | DNS_UNREGISTER)) {
        GATOM ga;

        if (pcii->afCmd & APPCMD_CLIENTONLY) {
            SetLastDDEMLError(pcii, DMLERR_DLL_USAGE);
            fRet = FALSE;
            goto Exit;
        }

        if (hsz1 == 0) {
            if (afCmd & DNS_REGISTER) {

                /*
                 * registering NULL is not allowed!
                 */
                SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
                fRet = FALSE;
                goto Exit;
            }

            /*
             * unregistering NULL is just like unregistering each
             * registered name.
             *
             * 10/19/90 - made this a synchronous event so that hsz
             * can be freed by calling app after this call completes
             * without us having to keep a copy around forever.
             */
            plaNameService = pcii->plaNameService;
            while (*plaNameService != 0) {
                ga = LocalToGlobalAtom(*plaNameService);
                DeleteAtom(*plaNameService);
                LeaveDDECrit;
                RegisterService(FALSE, ga, pcii->hwndMother);
                EnterDDECrit;
                GlobalDeleteAtom(ga);
                plaNameService++;
            }
            pcii->cNameServiceAlloc = 1;
            *pcii->plaNameService = 0;
            goto Exit;
        }

        if (afCmd & DNS_REGISTER) {
            plaNameService = (LATOM *)DDEMLReAlloc(pcii->plaNameService,
                    sizeof(LATOM) * ++pcii->cNameServiceAlloc);
            if (plaNameService == NULL) {
                SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
                pcii->cNameServiceAlloc--;
                fRet = FALSE;
                goto Exit;
            } else {
                pcii->plaNameService = plaNameService;
            }
            IncLocalAtomCount(LATOM_FROM_HSZ(hsz1)); // NameService copy
            plaNameService[pcii->cNameServiceAlloc - 2] = LATOM_FROM_HSZ(hsz1);
            plaNameService[pcii->cNameServiceAlloc - 1] = 0;

        } else { // DNS_UNREGISTER
            plaNameService = pcii->plaNameService;
            while (*plaNameService != 0 && *plaNameService != LATOM_FROM_HSZ(hsz1)) {
                plaNameService++;
            }
            if (*plaNameService == 0) {
                goto Exit; // not found just exit
            }
            //
            // fill empty slot with last entry and fill last entry with 0
            //
            pcii->cNameServiceAlloc--;
            *plaNameService = pcii->plaNameService[pcii->cNameServiceAlloc - 1];
            pcii->plaNameService[pcii->cNameServiceAlloc - 1] = 0;
        }

        ga = LocalToGlobalAtom(LATOM_FROM_HSZ(hsz1));
        LeaveDDECrit;
        RegisterService((afCmd & DNS_REGISTER) ? TRUE : FALSE, ga,
            pcii->hwndMother);
        EnterDDECrit;
        GlobalDeleteAtom(ga);
    }

Exit:
    LeaveDDECrit;
    return ((HDDEDATA)IntToPtr( fRet ));
}



/***************************************************************************\
* DdeGetLastError (DDEML API)
*
* Description:
* Returns last error code set for the instance given.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, DdeGetLastError, DWORD, idInst)
UINT DdeGetLastError(
DWORD idInst)
{
    UINT uiRet = 0;
    PCL_INSTANCE_INFO pcii;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        uiRet = DMLERR_INVALIDPARAMETER;
        goto Exit;
    }
    uiRet = pcii->LastError;
    pcii->LastError = DMLERR_NO_ERROR;

Exit:
    LeaveDDECrit;
    return (uiRet);
}



/***************************************************************************\
* DdeImpersonateClient()
*
* Description:
*   Does security impersonation for DDEML server apps.
*   This API should only be called with server side hConvs;
*
* History:
* 5-4-92 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeImpersonateClient, HCONV, hConv)
BOOL DdeImpersonateClient(
HCONV hConv)
{
    PCONV_INFO pcoi;
    PCL_INSTANCE_INFO pcii;
    BOOL fRet = FALSE;

    EnterDDECrit;

    pcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
            HTYPE_SERVER_CONVERSATION, HINST_ANY);
    if (pcoi == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hConv);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    fRet = NtUserImpersonateDdeClientWindow(pcoi->hwndPartner, pcoi->hwndConv);
Exit:
    LeaveDDECrit;
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\csrstubs.c ===
/***************************** Module Header ******************************\
* Module Name: csrstubs.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Routines to call CSR
*
* 02-27-95 JimA             Created.
*
* Note: This file has been partitioned with #if defines so that the LPC
* marshalling code can be inside 64bit code when running under wow64 (32bit on
* 64bit NT). In wow64, the system DLLs for 32bit processes are 32bit.
*
* The marshalling code can only be depedent on functions in NTDLL.
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "csrmsg.h"
#include "csrhlpr.h"
#include "strid.h"
#include <dbt.h>
#include <regstr.h>
#include <winsta.h>     // for WinStationGetTermSrvCountersValue
#include <allproc.h>    // for TS_COUNTER

CONST WCHAR gszReliabilityKey[] = L"\\Registry\\Machine\\" REGSTR_PATH_RELIABILITY;

#if defined(BUILD_CSRWOW64)

#undef RIPERR0
#undef RIPNTERR0
#undef RIPMSG0

#define RIPNTERR0(status, flags, szFmt) {if (NtCurrentTeb()) NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError(status);}
#define RIPERR0(idErr, flags, szFmt) {if (NtCurrentTeb()) NtCurrentTeb()->LastErrorValue = (idErr);}
#define RIPMSG0(flags, szFmt)

#endif

#define SET_LAST_ERROR_RETURNED()   if (a->dwLastError) RIPERR0(a->dwLastError, RIP_VERBOSE, "")

#if !defined(BUILD_WOW6432)

NTSTATUS
APIENTRY
CallUserpExitWindowsEx(
    IN UINT uFlags,
    OUT PBOOL pfSuccess)
{

    USER_API_MSG m;
    PEXITWINDOWSEXMSG a = &m.u.ExitWindowsEx;

    a->uFlags = uFlags;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                              UserpExitWindowsEx
                                            ),
                         sizeof( *a )
                       );

    if (NT_SUCCESS( m.ReturnValue ) || m.ReturnValue == STATUS_CANT_WAIT) {
        SET_LAST_ERROR_RETURNED();
        *pfSuccess = a->fSuccess;
    } else {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "");
        *pfSuccess = FALSE;
    }

    return m.ReturnValue;

}

#endif

#if !defined(BUILD_CSRWOW64)

typedef struct _EXITWINDOWSDATA {
    UINT uFlags;
} EXITWINDOWSDATA, *PEXITWINDOWSDATA;

__inline void GetShutdownType(LPWSTR pszBuff, int cch, DWORD dwFlags)
{
    if ((dwFlags & (EWX_POWEROFF | EWX_WINLOGON_OLD_POWEROFF)) != 0) {
        LoadString(hmodUser, STR_SHUTDOWN_POWEROFF, pszBuff, cch);
    } else if ((dwFlags & (EWX_REBOOT | EWX_WINLOGON_OLD_REBOOT)) != 0) {
        LoadString(hmodUser, STR_SHUTDOWN_REBOOT, pszBuff, cch);
    } else if ((dwFlags & (EWX_SHUTDOWN | EWX_WINLOGON_OLD_SHUTDOWN)) != 0) {
        LoadString(hmodUser, STR_SHUTDOWN_SHUTDOWN, pszBuff, cch);
    } else {
        LoadString(hmodUser, STR_UNKNOWN, pszBuff, cch);
    }
}

#define MAX_SNAPSHOT_SIZE   2048
typedef ULONG (*SNAPSHOTFUNC)(DWORD Flags, LPCTSTR *lpStrings, PLONG MaxBuffSize, LPTSTR SnapShotBuff);

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, RecordShutdownReason, PSHUTDOWN_REASON, psr)
BOOL RecordShutdownReason(
    PSHUTDOWN_REASON psr)
{
    HANDLE hEventLog;
    PSID pUserSid = NULL;
    PTOKEN_USER pTokenUser = NULL;
    DWORD dwSidSize = sizeof(SID), dwEventID;
    WCHAR szProcessName[MAX_PATH + 1], szReason[128];
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwComputerNameLen = ARRAY_SIZE(szComputerName);
    LPWSTR lpStrings[7];
    WORD wEventType, wStringCnt;
    WCHAR szShutdownType[32], szMinorReason[32];
    BOOL bRet = FALSE;
    HMODULE hSnapShot;
    SNAPSHOTFUNC pSnapShotProc;
    struct {
        DWORD Reason;
        PWCHAR SnapShotBuf;
    } SnapShot;
    LONG SnapShotSize = 0;
    LONG ResultLength = 0;       // Assume no snapshot
    DWORD DoSnapShotValue = 0;   // Prepare for the reg. key not exisiting
    NTSTATUS Status;
    UNICODE_STRING KeyString, ValueString;
    OBJECT_ATTRIBUTES ObjA;
    HKEY hKey = NULL;
    struct {
        ULONG TitleIndex;
        ULONG Type;
        ULONG DataLength;
        DWORD dwValue;
    } PartialInfoBuffer;

    // Validate the structure
    if (psr == NULL || psr->cbSize != sizeof(SHUTDOWN_REASON)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Bad psr %p in RecordShutdownReason", psr);
        return FALSE;
    }

    if ((hEventLog = RegisterEventSourceW(NULL, L"USER32")) == NULL) {
        // RegisterEventSourceW should have set the last error, so just return
        // FALSE.
        return FALSE;
    }

    GetComputerNameW(szComputerName, &dwComputerNameLen);
    GetShutdownType(szShutdownType, ARRAY_SIZE(szShutdownType), psr->uFlags);

    // Get the user's SID so we can output their account name to the event log.
    if (GetUserSid(&pTokenUser)) {
        pUserSid = pTokenUser->User.Sid;
    }

    //
    // Reason is first in data for compatability.
    //
    SnapShot.Reason = psr->dwReasonCode;
    SnapShot.SnapShotBuf = NULL;

    switch (psr->dwEventType) {
    case SR_EVENT_EXITWINDOWS:
        if (psr->fShutdownCancelled) {
            wEventType = EVENTLOG_WARNING_TYPE;
            dwEventID = WARNING_EW_SHUTDOWN_CANCELLED;
            wStringCnt = 2;
            lpStrings[0] = szShutdownType;
            lpStrings[1] = szComputerName;
        } else {
            if (!GetReasonTitleFromReasonCode(psr->dwReasonCode, szReason, ARRAY_SIZE(szReason))) {
                goto Cleanup;
            }
            GetCurrentProcessName(szProcessName, ARRAY_SIZE(szProcessName));
            // The minor reason is the low-order word of the reason code.
            wsprintf(szMinorReason, L"0x%x", LOWORD(psr->dwReasonCode));
            wEventType = EVENTLOG_INFORMATION_TYPE;
            dwEventID = STATUS_SHUTDOWN_CLEAN;
            wStringCnt = 6;
            lpStrings[0] = szProcessName;
            lpStrings[1] = szComputerName;
            lpStrings[2] = szReason;
            lpStrings[3] = szMinorReason;
            lpStrings[4] = szShutdownType;
            lpStrings[5] = psr->lpszComment;
        }
        break;
    case SR_EVENT_INITIATE_CLEAN:
        if (!GetReasonTitleFromReasonCode(psr->dwReasonCode, szReason, ARRAY_SIZE(szReason))) {
            goto Cleanup;
        }
        GetCurrentProcessName(szProcessName, ARRAY_SIZE(szProcessName));
        // The minor reason is the low-order word of the reason code.
        wsprintf(szMinorReason, L"0x%x", LOWORD(psr->dwReasonCode));
        wEventType = EVENTLOG_INFORMATION_TYPE;
        dwEventID = STATUS_SHUTDOWN_CLEAN;
        wStringCnt = 6;
        lpStrings[0] = szProcessName;
        lpStrings[1] = szComputerName;
        lpStrings[2] = szReason;
        lpStrings[3] = szMinorReason;
        lpStrings[4] = szShutdownType;
        lpStrings[5] = psr->lpszComment;

        //
        // Take a snapshot if shutdown is unplanned.
        //
        PartialInfoBuffer.dwValue = 0 ;
        RtlInitUnicodeString(&KeyString, gszReliabilityKey);
        InitializeObjectAttributes(&ObjA,
                                   &KeyString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
        Status = NtOpenKey(&hKey,
                           KEY_ALL_ACCESS,
                           &ObjA);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&ValueString, REGSTR_VAL_SHUTDOWN_DO_STATE_SNAPSHOT);
            Status = NtQueryValueKey(hKey,
                                     &ValueString,
                                     KeyValuePartialInformation,
                                     &PartialInfoBuffer,
                                     sizeof(PartialInfoBuffer),
                                     &ResultLength);
        }

        DoSnapShotValue = PartialInfoBuffer.dwValue ;

        if ((DoSnapShotValue & DO_SNAPSHOT_NEVER) != DO_SNAPSHOT_NEVER) {
            if (((DoSnapShotValue & DO_SNAPSHOT_ALWAYS) == DO_SNAPSHOT_ALWAYS) ||
                !(psr->dwReasonCode & SHTDN_REASON_FLAG_PLANNED)) {
                UINT cbLength;
                SnapShotSize = MAX_SNAPSHOT_SIZE;
                SnapShot.SnapShotBuf = LocalAlloc(LPTR, SnapShotSize);
                if (SnapShot.SnapShotBuf == NULL) {
                    if (hKey != NULL) {
                        NtClose(hKey);
                    }
                    goto Cleanup;
                }

                cbLength = GetSystemDirectoryW(SnapShot.SnapShotBuf,
                                               SnapShotSize - 1);
                wcsncat(SnapShot.SnapShotBuf, L"\\snapshot.dll",
                        ARRAY_SIZE(SnapShot.SnapShotBuf) - cbLength);
                hSnapShot = LoadLibrary(SnapShot.SnapShotBuf);
                if (hSnapShot) {
                    pSnapShotProc = (SNAPSHOTFUNC)GetProcAddress(hSnapShot, "LogSystemSnapshot");
                    if (pSnapShotProc) {
                        __try { // Assume the worst about the snapshot DLL!

                            (*pSnapShotProc)(DoSnapShotValue, lpStrings, &SnapShotSize, SnapShot.SnapShotBuf);

                        } __except(EXCEPTION_EXECUTE_HANDLER) {
                            wsprintf(SnapShot.SnapShotBuf, L"State Snapshot took an exception\n");
                        }
                        SnapShotSize = wcslen(SnapShot.SnapShotBuf);
                    }
                    FreeLibrary(hSnapShot);
                }

                if (SnapShotSize > 0 ) {
                    if (hKey != NULL) {
                        RtlInitUnicodeString(&ValueString, REGSTR_VAL_SHUTDOWN_STATE_SNAPSHOT);
                        Status = NtSetValueKey(hKey,
                                               &ValueString,
                                               0,
                                               REG_SZ,
                                               SnapShot.SnapShotBuf,
                                               SnapShotSize * sizeof(WCHAR));
                       //Ignore failure here
 
                    }
                }
            }
        }
        if (hKey != NULL) {
            NtClose(hKey);
        }
        break;
    case SR_EVENT_INITIATE_CLEAN_ABORT:
        wEventType = EVENTLOG_WARNING_TYPE;
        dwEventID = WARNING_ISSE_SHUTDOWN_CANCELLED;
        wStringCnt = 1;
        lpStrings[0] = szComputerName;
        break;
    case SR_EVENT_DIRTY:
        if (!GetReasonTitleFromReasonCode(psr->dwReasonCode, szReason, ARRAY_SIZE(szReason))) {
            goto Cleanup;
        }
        // The minor reason is the low-order word of the reason code.
        wsprintf(szMinorReason, L"0x%x", LOWORD(psr->dwReasonCode));
        wEventType = EVENTLOG_WARNING_TYPE;
        dwEventID = WARNING_DIRTY_REBOOT;
        wStringCnt = 3;
        lpStrings[0] = szReason;
        lpStrings[1] = szMinorReason;
        lpStrings[2] = psr->lpszComment;
        break;
    default:
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Unknown psr->dwEventType 0x%x", psr->dwEventType);
        goto Cleanup;
    }

    bRet = ReportEventW(hEventLog, wEventType, 0, dwEventID, pUserSid,
                        wStringCnt, sizeof(DWORD),
                        lpStrings, &SnapShot);

Cleanup:
    if (SnapShot.SnapShotBuf != NULL) {
        LocalFree(SnapShot.SnapShotBuf);
    }

    if (pTokenUser != NULL) {
        LocalFree(pTokenUser);
    }

    DeregisterEventSource(hEventLog);
    return bRet;
}

BOOL CheckShutdownLogging(
    VOID)
{
    NTSTATUS Status;
    UNICODE_STRING KeyString, ValueString;
    OBJECT_ATTRIBUTES ObjA;
    HKEY hKey;
    struct {
        ULONG TitleIndex;
        ULONG Type;
        ULONG DataLength;
        DWORD dwValue;
    } PartialInfoBuffer;

    RtlInitUnicodeString(&KeyString, gszReliabilityKey);
    InitializeObjectAttributes(&ObjA,
                               &KeyString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&hKey,
                       KEY_READ,
                       &ObjA);

    PartialInfoBuffer.dwValue = 0;
    if (NT_SUCCESS(Status)) {
        ULONG ResultLength;

        RtlInitUnicodeString(&ValueString, REGSTR_VAL_SHOWREASONUI);
        Status = NtQueryValueKey(hKey,
                                 &ValueString,
                                 KeyValuePartialInformation,
                                 &PartialInfoBuffer,
                                 sizeof(PartialInfoBuffer),
                                 &ResultLength );
        UserAssert(!NT_SUCCESS(Status) || ResultLength == sizeof(PartialInfoBuffer));
        NtClose(hKey);
    }

    return (PartialInfoBuffer.dwValue != 0);
}

UINT GetLoggedOnUserCount(
    VOID)
{
    int iCount = 0;
    BOOLEAN bSuccess;

    TS_COUNTER TSCountersDyn[2];

    TSCountersDyn[0].counterHead.dwCounterID = TERMSRV_CURRENT_DISC_SESSIONS;
    TSCountersDyn[1].counterHead.dwCounterID = TERMSRV_CURRENT_ACTIVE_SESSIONS;

    // access the termsrv counters to find out how many users are logged onto the system
    bSuccess = WinStationGetTermSrvCountersValue(SERVERNAME_CURRENT, 2, TSCountersDyn);

    if (bSuccess) {
        if (TSCountersDyn[0].counterHead.bResult)
            iCount += TSCountersDyn[0].dwValue;

        if (TSCountersDyn[1].counterHead.bResult)
            iCount += TSCountersDyn[1].dwValue;
    }

    return iCount;
}

BOOL IsSeShutdownNameEnabled()
{
    BOOL bRet = FALSE;  // assume the privilege is not held
    NTSTATUS Status;
    HANDLE hToken;

    // try to get the thread token
    Status = NtOpenThreadToken(GetCurrentThread(),
                               TOKEN_QUERY,
                               FALSE,
                               &hToken);
    if (!NT_SUCCESS(Status)) {
        // try the process token if we failed to get the thread token
        Status = NtOpenProcessToken(GetCurrentProcess(),
                                    TOKEN_QUERY,
                                    &hToken);
    }

    if (NT_SUCCESS(Status)) {
        DWORD cbSize = 0;
        TOKEN_PRIVILEGES* ptp;

        NtQueryInformationToken(hToken,
                                TokenPrivileges,
                                NULL,
                                0,
                                &cbSize);
        if (cbSize) {
            ptp = (TOKEN_PRIVILEGES*)LocalAlloc(LPTR, cbSize);
        } else {
            ptp = NULL;
        }

        if (ptp) {
            Status = NtQueryInformationToken(hToken,
                                             TokenPrivileges,
                                             ptp,
                                             cbSize,
                                             &cbSize);
            if (NT_SUCCESS(Status)) {
                DWORD i;
                for (i = 0; i < ptp->PrivilegeCount; i++) {
                    if (((ptp->Privileges[i].Luid.HighPart == 0) && (ptp->Privileges[i].Luid.LowPart == SE_SHUTDOWN_PRIVILEGE)) &&
                        (ptp->Privileges[i].Attributes & (SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED))) {
                        // found the privilege and it is enabled
                        bRet = TRUE;
                        break;
                    }
                }
            }

            LocalFree(ptp);
        }

        NtClose(hToken);
    }

    return bRet;
}

BOOL NeedsDisplayWarning (UINT uNumUsers, UINT uExitWindowsFlags)
{

    //  If EWX_SYSTEM_CALLER then there's nobody on this session.
    //  Add one from the number of users.

    if ((uExitWindowsFlags & EWX_SYSTEM_CALLER) && (uNumUsers > 0))
    {
        ++uNumUsers;
    }

    //  If number of users > 1 or EWX_WINLOGON_CALLER display warning.

    return (uNumUsers > 1) || (uExitWindowsFlags & EWX_WINLOGON_CALLER);
}

FUNCLOG1(LOG_GENERAL, BOOL, APIENTRY, DisplayExitWindowsWarnings, UINT, uExitWindowsFlags)
BOOL APIENTRY DisplayExitWindowsWarnings(UINT uExitWindowsFlags)
{
    BOOL bContinue = TRUE;
    BOOL fIsRemote = ISREMOTESESSION();
    UINT uNumUsers = GetLoggedOnUserCount();
    UINT uID = 0;

    // it would be nice to check the HKCU\ControlPanel\Desktop\AutoEndTask value and not display any UI if it is set,
    // but since we are called from services it is probably better to not go mucking about in the per-user hive

    if (uExitWindowsFlags & (EWX_POWEROFF | EWX_WINLOGON_OLD_POWEROFF | EWX_SHUTDOWN | EWX_WINLOGON_OLD_SHUTDOWN))
    {
        if (fIsRemote)
        {
            if (NeedsDisplayWarning(uNumUsers, uExitWindowsFlags))
            {
                // Warn the user if remote shut down w/ active users
                uID = IDS_SHUTDOWN_REMOTE_OTHERUSERS;
            }
            else
            {
                // Warn the user of remote shut down (cut our own legs off!)
                uID = IDS_SHUTDOWN_REMOTE;
            }
        }
        else
        {
            if (NeedsDisplayWarning(uNumUsers, uExitWindowsFlags))
            {
                //  Warn the user if more than one user session active
                uID = IDS_SHUTDOWN_OTHERUSERS;
            }
        }
    }
    else if (uExitWindowsFlags & (EWX_REBOOT | EWX_WINLOGON_OLD_REBOOT))
    {
        //  Warn the user if more than one user session active.
        if (NeedsDisplayWarning(uNumUsers, uExitWindowsFlags))
        {
            uID = IDS_RESTART_OTHERUSERS;
        }
    }

    if (uID != 0)
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szMessage[MAX_PATH];

        LoadString(hmodUser, IDS_EXITWINDOWS_TITLE, szTitle, sizeof(szTitle)/sizeof(szTitle[0]));
        LoadString(hmodUser, uID, szMessage, sizeof(szMessage)/sizeof(szMessage[0]));

        // We want to display the message box to be displayed to the user, and since this can be called from winlogon/services
        // we need to pass the MB_SERVICE_NOTIFICATION flag.
        if (MessageBox(NULL,
                       szMessage,
                       szTitle,
                       MB_ICONEXCLAMATION | MB_YESNO | MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_SETFOREGROUND) == IDNO)
        {
            bContinue = FALSE;
        }
    }

    return bContinue;
}

DWORD ExitWindowsThread(PVOID pvParam);

BOOL WINAPI ExitWindowsWorker(
    UINT uFlags,
    BOOL fSecondThread)
{
    EXITWINDOWSDATA ewd;
    HANDLE hThread;
    DWORD dwThreadId;
    DWORD dwExitCode;
    DWORD idWait;
    MSG msg;
    BOOL fSuccess;
    NTSTATUS Status;

    /*
     * Force a connection so apps will have a windowstation
     * to log off of.
     */
    if (PtiCurrent() == NULL) {
        return FALSE;
    }

    /*
     * Check for UI restrictions
     */
    if (!NtUserCallOneParam((ULONG_PTR)uFlags, SFI_PREPAREFORLOGOFF)) {
        RIPMSG0(RIP_WARNING, "ExitWindows called by a restricted thread\n");
        return FALSE;
    }

    Status = CallUserpExitWindowsEx(uFlags, &fSuccess);

    if (NT_SUCCESS( Status )) {
        return fSuccess;
    } else if (Status == STATUS_CANT_WAIT && !fSecondThread) {
        ewd.uFlags = uFlags;
        hThread = CreateThread(NULL, 0, ExitWindowsThread, &ewd,
                0, &dwThreadId);
        if (hThread == NULL) {
            return FALSE;
        }

        while (1) {
            idWait = MsgWaitForMultipleObjectsEx(1, &hThread,
                    INFINITE, QS_ALLINPUT, 0);

            /*
             * If the thread was signaled, we're done.
             */
            if (idWait == WAIT_OBJECT_0) {
                break;
            }

            /*
             * Process any waiting messages
             */
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                DispatchMessage(&msg);
            }
        }
        GetExitCodeThread(hThread, &dwExitCode);
        NtClose(hThread);
        if (dwExitCode == ERROR_SUCCESS) {
            return TRUE;
        } else {
            RIPERR0(dwExitCode, RIP_VERBOSE, "");
            return FALSE;
        }
    } else {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return FALSE;
    }
}

DWORD ExitWindowsThread(
    PVOID pvParam)
{
    PEXITWINDOWSDATA pewd = pvParam;
    DWORD dwExitCode;

    if (ExitWindowsWorker(pewd->uFlags, TRUE)) {
        dwExitCode = 0;
    } else {
        dwExitCode = GetLastError();
    }

    ExitThread(dwExitCode);
    return 0;
}

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, ExitWindowsEx, UINT, uFlags, DWORD, dwReasonCode)
BOOL WINAPI ExitWindowsEx(
    UINT uFlags,
    DWORD dwReasonCode)
{
    BOOL bSuccess;
    BOOL bShutdown = (uFlags & SHUTDOWN_FLAGS) != 0;
    SHUTDOWN_REASON sr;

    /*
     * Check to see if we should bring up UI warning that there are other
     * Terminal Server users connected to this machine. We only do this if the
     * caller has not specified the EWX_FORCE option.
     */
    if (bShutdown && !(uFlags & EWX_FORCE)) {
        /*
         * We don't want to display the warning dialog twice! (this function
         * can be called by an application and again by winlogon in response to
         * the first call)
         */
        if (!gfLogonProcess || (uFlags & EWX_WINLOGON_INITIATED)) {
            /*
             * Don't put up UI if termsrv is our caller. Termsrv uses this api to shutdown winlogon
             * on session 0 when a shutdown was initiated from a different session.
             */
            if (!(uFlags & EWX_TERMSRV_INITIATED)) {
                /*
                 * There are a bunch of lame apps (including InstallShield v5.1) that call ExitWindowsEx and then when it fails
                 * they go and enable the SE_SHUTDOWN_NAME privilege and then us call again. The problem is that we end up prompting the
                 * user twice in these cases. So before we put up any UI we check for the SE_SHUTDOWN_NAME privilege.
                 */
                if (IsSeShutdownNameEnabled()) {
                    if (!DisplayExitWindowsWarnings(uFlags & ~(EWX_WINLOGON_CALLER | EWX_SYSTEM_CALLER))) {
                        /*
                         * We only want to return the real error code if our caller was winlogon. We lie
                         * to everyone else and tell them that everything succeeded. If we return failure
                         * when the user cancel's the operation, a some of apps just call ExitWindowsEx
                         * again, causing another dialog.
                         */
                        if (uFlags & EWX_WINLOGON_INITIATED) {
                            SetLastError(ERROR_CANCELLED);
                            return FALSE;
                        } else {
                            return TRUE;
                        }
                    }
                }
            }
        }
    }

    sr.cbSize = sizeof(SHUTDOWN_REASON);
    sr.uFlags = uFlags;
    sr.dwReasonCode = dwReasonCode;
    sr.fShutdownCancelled = FALSE;
    sr.dwEventType = SR_EVENT_EXITWINDOWS;
    sr.lpszComment = NULL;

    /*
     * If this is winlogon initiating the shutdown, we need to log before
     * calling ExitWindowsWorker. Otherwise, if the user or an app cancels the
     * shutdown, the cancel event will be logged before the initial shutdown
     * event.
     */
    if (gfLogonProcess && bShutdown && (uFlags & EWX_WINLOGON_INITIATED) != 0) {
        if (CheckShutdownLogging()) {
            RecordShutdownReason(&sr);
        }
    }

    bSuccess = ExitWindowsWorker(uFlags, FALSE);

    /*
     * Log this shutdown if:
     * 1) We're not winlogon (if we are, we might have logged above).
     * 2) The shutdown (inititally, at least) succeeded.
     * 3) We're actually shutting down (i.e., not logging off).
     * 4) The registry key telling us to log is set.
     */
    if (!gfLogonProcess && bSuccess && bShutdown && CheckShutdownLogging()) {
        RecordShutdownReason(&sr);
    }

    return bSuccess;
}

#endif

#if !defined(BUILD_WOW6432)

BOOL WINAPI EndTask(
    HWND hwnd,
    BOOL fShutdown,
    BOOL fForce)
{
    USER_API_MSG m;
    PENDTASKMSG a = &m.u.EndTask;

    UNREFERENCED_PARAMETER(fShutdown);
    a->hwnd = hwnd;
    a->fForce = fForce;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                              UserpEndTask
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        SET_LAST_ERROR_RETURNED();
        return a->fSuccess;
    } else {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "");
        return FALSE;
    }
}

VOID
APIENTRY
Logon(
    BOOL fLogon)
{
    USER_API_MSG m;
    PLOGONMSG a = &m.u.Logon;

    a->fLogon = fLogon;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                              UserpLogon
                                            ),
                         sizeof(*a)
                       );
}

NTSTATUS
APIENTRY
CallUserpRegisterLogonProcess(
    IN DWORD dwProcessId)
{

    USER_API_MSG m;
    PLOGONMSG a = &m.u.Logon;
    NTSTATUS Status;

    m.u.IdLogon = dwProcessId;
    Status = CsrClientCallServer( (PCSR_API_MSG)&m,
                                  NULL,
                                  CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                                       UserpRegisterLogonProcess),
                                  sizeof(*a));

    return Status;
}

#endif

#if !defined(BUILD_CSRWOW64)

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, RegisterLogonProcess, DWORD, dwProcessId, BOOL, fSecure)
BOOL RegisterLogonProcess(
    DWORD dwProcessId,
    BOOL fSecure)
{
    gfLogonProcess = (BOOL)NtUserCallTwoParam(dwProcessId, fSecure,
            SFI__REGISTERLOGONPROCESS);

    /*
     * Now, register the logon process into winsrv.
     */
    if (gfLogonProcess) {
        CallUserpRegisterLogonProcess(dwProcessId);
    }

    return gfLogonProcess;
}

#endif

#if !defined(BUILD_WOW6432)

BOOL
WINAPI
RegisterServicesProcess(
    DWORD dwProcessId)
{
    USER_API_MSG m;
    PREGISTERSERVICESPROCESSMSG a = &m.u.RegisterServicesProcess;

    a->dwProcessId = dwProcessId;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                              UserpRegisterServicesProcess
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        SET_LAST_ERROR_RETURNED();
        return a->fSuccess;
    } else {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "");
        return FALSE;
    }
}

HDESK WINAPI GetThreadDesktop(
    DWORD dwThreadId)
{
    USER_API_MSG m;
    PGETTHREADCONSOLEDESKTOPMSG a = &m.u.GetThreadConsoleDesktop;

    a->dwThreadId = dwThreadId;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                              UserpGetThreadConsoleDesktop
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return NtUserGetThreadDesktop(dwThreadId, a->hdeskConsole);
    } else {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "");
        return NULL;
    }
}


/**************************************************************************\
* DeviceEventWorker
*
* This is a private (not publicly exported) interface that the user-mode
* pnp manager calls when it needs to send a WM_DEVICECHANGE message to a
* specific window handle. The user-mode pnp manager is a service within
* services.exe and as such is not on the interactive window station and
* active desktop, so it can't directly call SendMessage. For broadcasted
* messages (messages that go to all top-level windows), the user-mode pnp
* manager calls BroadcastSystemMessage directly.
*
* PaulaT 06/04/97
*
\**************************************************************************/
ULONG
WINAPI
DeviceEventWorker(
    IN HWND    hWnd,
    IN WPARAM  wParam,
    IN LPARAM  lParam,
    IN DWORD   dwFlags,
    OUT PDWORD pdwResult)
{
    USER_API_MSG m;
    PDEVICEEVENTMSG a = &m.u.DeviceEvent;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
    int cb = 0;

    a->hWnd     = hWnd;
    a->wParam   = wParam;
    a->lParam   = lParam;
    a->dwFlags  = dwFlags;
    a->dwResult = 0;

    //
    // If lParam is specified, it must be marshalled (see the defines
    // for this structure in dbt.h - the structure always starts with
    // DEV_BROADCAST_HDR structure).
    //

    if (lParam) {

        cb = ((PDEV_BROADCAST_HDR)lParam)->dbch_size;

        CaptureBuffer = CsrAllocateCaptureBuffer(1, cb);
        if (CaptureBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }

        CsrCaptureMessageBuffer(CaptureBuffer,
                                (PCHAR)lParam,
                                cb,
                                (PVOID *)&a->lParam);

        //
        // This ends up calling SrvDeviceEvent routine in the server.
        //

        CsrClientCallServer((PCSR_API_MSG)&m,
                            CaptureBuffer,
                            CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX,
                                                UserpDeviceEvent),
                            sizeof(*a));

        CsrFreeCaptureBuffer(CaptureBuffer);

    } else {

        //
        // This ends up calling SrvDeviceEvent routine in the server.
        //

        CsrClientCallServer((PCSR_API_MSG)&m,
                            NULL,
                            CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX,
                                                UserpDeviceEvent),
                            sizeof(*a));
    }


    if (NT_SUCCESS(m.ReturnValue)) {
        *pdwResult = (DWORD)a->dwResult;
    } else {
        RIPMSG0(RIP_WARNING, "DeviceEventWorker failed.");
    }

    return m.ReturnValue;
}


#if DBG

VOID
APIENTRY
CsrWin32HeapFail(
    IN DWORD dwFlags,
    IN BOOL  bFail)
{
    USER_API_MSG m;
    PWIN32HEAPFAILMSG a = &m.u.Win32HeapFail;

    a->dwFlags = dwFlags;
    a->bFail = bFail;

    CsrClientCallServer((PCSR_API_MSG)&m,
                        NULL,
                        CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX,
                                            UserpWin32HeapFail),
                        sizeof(*a));

    if (!NT_SUCCESS(m.ReturnValue)) {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "UserpWin32HeapFail failed");
    }
}

UINT
APIENTRY
CsrWin32HeapStat(
    PDBGHEAPSTAT    phs,
    DWORD   dwLen)
{
    USER_API_MSG m;
    PWIN32HEAPSTATMSG a = &m.u.Win32HeapStat;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

    a->dwLen = dwLen;

    CaptureBuffer = CsrAllocateCaptureBuffer(1, dwLen);
    if (CaptureBuffer == NULL) {
        return 0;
    }

    CsrCaptureMessageBuffer(CaptureBuffer,
                            (PCHAR)phs,
                            dwLen,
                            (PVOID *)&a->phs);

    CsrClientCallServer((PCSR_API_MSG)&m,
                        CaptureBuffer,
                        CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX,
                                            UserpWin32HeapStat),
                        sizeof(*a));

    if (!NT_SUCCESS(m.ReturnValue)) {
        RIPNTERR0(m.ReturnValue, RIP_VERBOSE, "UserpWin32HeapStat failed");
        a->dwMaxTag = 0;
        goto ErrExit;
    }
    RtlMoveMemory(phs, a->phs, dwLen);

ErrExit:
    CsrFreeCaptureBuffer(CaptureBuffer);

    return a->dwMaxTag;
}

#endif // DBG


#endif

#if !defined(BUILD_CSRWOW64)

/******************************************************************************\
* CsrBroadcastSystemMessageExW
*
* Routine Description:
*
*   This function is a private API used by the csrss server
*
*   This function converts the csrss server thread into a GUI thread, then
*   performs a BroadcastSystemMessageExW(), and finally restore the thread's
*   desktop.
*
* Arguments:
*
*   dwFlags - Broadcast System message flags
*
*   lpdwRecipients - Intended recipients of the message
*
*   uiMessage - Message type
*
*   wParam - first message parameter
*
*   lParam - second message parameter
*
*   pBSMInfo - BroadcastSystemMessage information
*
* Return Value:
*
*   Appropriate NTSTATUS code
*
\******************************************************************************/
FUNCLOG6(LOG_GENERAL, NTSTATUS, APIENTRY, CsrBroadcastSystemMessageExW, DWORD, dwFlags, LPDWORD, lpdwRecipients, UINT, uiMessage, WPARAM, wParam, LPARAM, lParam, PBSMINFO, pBSMInfo)
NTSTATUS
APIENTRY
CsrBroadcastSystemMessageExW(
    DWORD dwFlags,
    LPDWORD lpdwRecipients,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pBSMInfo
    )
{
    USERTHREAD_USEDESKTOPINFO utudi;
    long result;
    NTSTATUS Status;

    /*
     * Caller must be from the csrss server
     */
    if( !gfServerProcess ) {
        return( STATUS_ACCESS_DENIED );
    }

    /*
     * Since this thread is a csrss thread, the thread is not a
     * GUI thread and does not have a desktop associated with it.
     * Must set the thread's desktop to the active desktop in
     * order to call BroadcastSystemMessageExW
     */

    utudi.hThread = NULL;
    utudi.drdRestore.pdeskRestore = NULL;

    Status = NtUserSetInformationThread( NtCurrentThread(),
                                         UserThreadUseActiveDesktop,
                                         &utudi,
                                         sizeof(utudi) );

    if( NT_SUCCESS( Status ) ) {
        result = BroadcastSystemMessageExW(
                        dwFlags,
                        lpdwRecipients,
                        uiMessage,
                        wParam,
                        lParam,
                        pBSMInfo );

        /*
         * Restore the previous desktop of the thread
         */
        Status = NtUserSetInformationThread( NtCurrentThread(),
                                             UserThreadUseDesktop,
                                             &utudi,
                                             sizeof(utudi) );

        if( NT_SUCCESS( Status ) && ( result <= 0 ) ) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    return( Status );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\ddemlwp.c ===
/****************************** Module Header ******************************\
* Module Name: ddemlwp.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager client side window procedures
*
* Created: 11/3/91 Sanford Staab
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

VOID ProcessDDEMLInitiate(PCL_INSTANCE_INFO pcii, HWND hwndClient,
        GATOM aServer, GATOM aTopic);

/***************************************************************************\
* DDEMLMotherWndProc
*
* Description:
* Handles WM_DDE_INITIATE messages for DDEML and holds all the other windows
* for a DDEML instance.
*
* History:
* 12-29-92 sanfords Created.
\***************************************************************************/
LRESULT DDEMLMotherWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message) {
    case UM_REGISTER:
    case UM_UNREGISTER:
        return(ProcessRegistrationMessage(hwnd, message, wParam, lParam));

    case WM_DDE_INITIATE:
        ProcessDDEMLInitiate((PCL_INSTANCE_INFO)GetWindowLongPtr(hwnd, GWLP_PCI),
                (HWND)wParam, (ATOM)LOWORD(lParam), (ATOM)HIWORD(lParam));
        return(0);

    }
    return(DefWindowProc(hwnd, message, wParam, lParam));
}



/***************************************************************************\
* ProcessDDEMLInitiate
*
* Description:
*
*   WM_DDE_INITIATE messages are processed here.
*
* History:
* 12-29-92   sanfords    Created.
\***************************************************************************/
VOID ProcessDDEMLInitiate(
PCL_INSTANCE_INFO pcii,
HWND hwndClient,
GATOM aServer,
GATOM aTopic)
{
    CONVCONTEXT cc = {
        sizeof(CONVCONTEXT),
        0,
        0,
        CP_WINANSI,
        0L,
        0L,
        {
            sizeof(SECURITY_QUALITY_OF_SERVICE),
            SecurityImpersonation,
            SECURITY_STATIC_TRACKING,
            TRUE
        }
    };
    BOOL flags = ST_INLIST;
    BOOL fWild;
    HDDEDATA hData;
    HWND hwndServer;
    PSERVER_LOOKUP psl;
    PHSZPAIR php;
    HSZPAIR hp[2];
    LATOM laService, laFree1 = 0;
    LATOM laTopic, laFree2 = 0;
    PSVR_CONV_INFO psi;
    LATOM *plaNameService;
    PWND pwndClient;
    PCLS pcls;

    if (pcii == NULL) {
        return;     // we aren't done being initiated yet.
    }

    EnterDDECrit;

    if (pcii->afCmd & CBF_FAIL_CONNECTIONS || !IsWindow(hwndClient)) {
        goto Exit;
    }

    pwndClient = ValidateHwnd(hwndClient);
    if (pwndClient == NULL) goto Exit;

    pcls = (PCLS)REBASEALWAYS(pwndClient, pcls);
    if (!TestWF(pwndClient, WFANSIPROC)) {
        if (pcls->atomClassName == gpsi->atomSysClass[ICLS_DDEMLCLIENTW]) {
            flags |= ST_ISLOCAL;
        }
    } else {
        if (pcls->atomClassName == gpsi->atomSysClass[ICLS_DDEMLCLIENTA]) {
            flags |= ST_ISLOCAL;
        }
    }

    if (flags & ST_ISLOCAL) {
        /*
         * Make sure other guy allows self-connections if that's what this is.
         */
        if (pcii->hInstServer == (HANDLE)GetWindowLongPtr(hwndClient, GWLP_SHINST)) {
            if (pcii->afCmd & CBF_FAIL_SELFCONNECTIONS) {
                goto Exit;
            }
            flags |= ST_ISSELF;
        }

        GetConvContext(hwndClient, (LONG *)&cc);
        if (GetWindowLong(hwndClient, GWL_CONVSTATE) & CLST_SINGLE_INITIALIZING) {
            flags &= ~ST_INLIST;
        }
    } else {
        NtUserDdeGetQualityOfService(hwndClient, NULL, &cc.qos);
    }

/***************************************************************************\
*
* Server window creation is minimized by only creating one window per
* Instance/Service/Topic set. This should be all that is needed and
* duplicate connections (ie where the server/client window pair is identical
* to another conversation) should not happen. However, if some dumb
* server app attempts to create a duplicate conversation by having
* duplicate service/topic pairs passed back from a XTYP_WILD_CONNECT
* callback we will not honor the request.
*
* The INSTANCE_INFO structure holds a pointer to an array of SERVERLOOKUP
* structures each entry of which references the hwndServer that supports
* all conversations on that service/topic pair. The hwndServer windows
* in turn have window words that reference the first member in a linked
* list of SVR_CONV_INFO structures, one for each conversation on that
* service/topic pair.
*
\***************************************************************************/

    laFree1 = laService = GlobalToLocalAtom(aServer);
    laFree2 = laTopic = GlobalToLocalAtom(aTopic);

    plaNameService = pcii->plaNameService;
    if (!laService && pcii->afCmd & APPCMD_FILTERINITS && *plaNameService == 0) {
        /*
         * no WILDCONNECTS to servers with no registered names while filtering.
         */
        goto Exit;
    }
    if ((pcii->afCmd & APPCMD_FILTERINITS) && laService) {
        /*
         * if we can't find the aServer in this instance's service name
         * list, don't bother the server.
         */
        while (*plaNameService != 0 && *plaNameService != laService) {
            plaNameService++;
        }
        if (*plaNameService == 0) {
            goto Exit;
        }
    }
    hp[0].hszSvc = NORMAL_HSZ_FROM_LATOM(laService);
    hp[0].hszTopic = NORMAL_HSZ_FROM_LATOM(laTopic);
    hp[1].hszSvc = 0;
    hp[1].hszTopic = 0;
    fWild = !laService || !laTopic;

    hData = DoCallback(pcii,
        (WORD)(fWild ? XTYP_WILDCONNECT : XTYP_CONNECT),
        0,
        (HCONV)0,
        hp[0].hszTopic,
        hp[0].hszSvc,
        (HDDEDATA)0,
        flags & ST_ISLOCAL ? (ULONG_PTR)&cc : 0,
        (DWORD)(flags & ST_ISSELF) ? 1 : 0);

    if (!hData) {
        goto Exit;
    }

    if (fWild) {
        php = (PHSZPAIR)DdeAccessData(hData, NULL);
        if (php == NULL) {
            goto Exit;
        }
    } else {
        php = hp;
    }

    while (php->hszSvc && php->hszTopic) {

        psi = (PSVR_CONV_INFO)DDEMLAlloc(sizeof(SVR_CONV_INFO));
        if (psi == NULL) {
            break;
        }

        laService = LATOM_FROM_HSZ(php->hszSvc);
        laTopic = LATOM_FROM_HSZ(php->hszTopic);

        hwndServer = 0;
        if (pcii->cServerLookupAlloc) {
            int i;
            /*
             * See if there already exists a server window for this
             * aServer/aTopic pair
             */
            for (i = pcii->cServerLookupAlloc; i; i--) {
                if (pcii->aServerLookup[i - 1].laService == laService &&
                        pcii->aServerLookup[i - 1].laTopic == laTopic) {
                    PSVR_CONV_INFO psiT;
                    PCONV_INFO pcoi;

                    hwndServer = pcii->aServerLookup[i - 1].hwndServer;
                    /*
                     * Now make sure this window isn't someone
                     * trying to create a second conversation from the
                     * same client window that is already talking to
                     * our existing server window.
                     */
                    psiT = (PSVR_CONV_INFO)GetWindowLongPtr(hwndServer, GWLP_PSI);
                    for (pcoi = &psiT->ci; pcoi != NULL; pcoi = pcoi->next) {
                        if (pcoi->hwndPartner == hwndClient) {
                            hwndServer = NULL;
                            break;
                        }
                    }
                    break;
                }
            }
        }

        if (hwndServer == 0) {

            // no server window exists - make one.

            LeaveDDECrit;
            if (pcii->flags & IIF_UNICODE) {
                hwndServer = CreateWindowW((LPWSTR)(gpsi->atomSysClass[ICLS_DDEMLSERVERW]),
                                          L"",
                                          WS_CHILD,
                                          0, 0, 0, 0,
                                          pcii->hwndMother,
                                          (HMENU)0,
                                          0,
                                          (LPVOID)NULL);
            } else {
                hwndServer = CreateWindowA((LPSTR)(gpsi->atomSysClass[ICLS_DDEMLSERVERA]),
                                          "",
                                          WS_CHILD,
                                          0, 0, 0, 0,
                                          pcii->hwndMother,
                                          (HMENU)0,
                                          0,
                                          (LPVOID)NULL);
            }
            EnterDDECrit;

            if (hwndServer == 0) {
                DDEMLFree(psi);
                break;
            }
            // SetWindowLongPtr(hwndServer, GWLP_PSI, (LONG)NULL); // Zero init.

            // put the window into the lookup list

            if (pcii->aServerLookup == NULL) {
                psl = (PSERVER_LOOKUP)DDEMLAlloc(sizeof(SERVER_LOOKUP));
            } else {
                psl = (PSERVER_LOOKUP)DDEMLReAlloc(pcii->aServerLookup,
                        sizeof(SERVER_LOOKUP) * (pcii->cServerLookupAlloc + 1));
            }
            if (psl == NULL) {
                RIPMSG1(RIP_WARNING, "ProcessDDEMLInitiate:hwndServer (%x) destroyed due to low memory.", hwndServer);
                NtUserDestroyWindow(hwndServer);
                DDEMLFree(psi);
                break;
            }

            IncLocalAtomCount(laService); // for SERVER_LOOKUP
            psl[pcii->cServerLookupAlloc].laService = laService;
            IncLocalAtomCount(laTopic); // for SERVER_LOOKUP
            psl[pcii->cServerLookupAlloc].laTopic = laTopic;
            psl[pcii->cServerLookupAlloc].hwndServer = hwndServer;
            pcii->aServerLookup = psl;
            pcii->cServerLookupAlloc++;
            // DumpServerLookupTable("After addition:", hwndServer, psl, pcii->cServerLookupAlloc);
        }

        psi->ci.next = (PCONV_INFO)GetWindowLongPtr(hwndServer, GWLP_PSI);
        SetWindowLongPtr(hwndServer, GWLP_PSI, (LONG_PTR)psi);
        psi->ci.pcii = pcii;
        // psi->ci.hUser = 0;
        psi->ci.hConv = (HCONV)CreateHandle((ULONG_PTR)psi,
                HTYPE_SERVER_CONVERSATION, InstFromHandle(pcii->hInstClient));
        psi->ci.laService = laService;
        IncLocalAtomCount(laService); // for server window
        psi->ci.laTopic = laTopic;
        IncLocalAtomCount(laTopic); // for server window
        psi->ci.hwndPartner = hwndClient;
        psi->ci.hwndConv = hwndServer;
        psi->ci.state = (WORD)(flags | ST_CONNECTED | pcii->ConvStartupState);
        SetCommonStateFlags(hwndClient, hwndServer, &psi->ci.state);
        psi->ci.laServiceRequested = laFree1;
        IncLocalAtomCount(psi->ci.laServiceRequested); // for server window
        // psi->ci.pxiIn = NULL;
        // psi->ci.pxiOut = NULL;
        // psi->ci.dmqIn = NULL;
        // psi->ci.dmqOut = NULL;
        // psi->ci.aLinks = NULL;
        // psi->ci.cLinks = 0;
        // psi->ci.cLocks = 0;

        LeaveDDECrit;
        CheckDDECritOut;
        SendMessage(hwndClient, WM_DDE_ACK, (WPARAM)hwndServer,
                MAKELONG(LocalToGlobalAtom(laService), LocalToGlobalAtom(laTopic)));
        EnterDDECrit;

        if (!(pcii->afCmd & CBF_SKIP_CONNECT_CONFIRMS)) {
            DoCallback(pcii,
                    (WORD)XTYP_CONNECT_CONFIRM,
                    0,
                    psi->ci.hConv,
                    (HSZ)laTopic,
                    (HSZ)laService,
                    (HDDEDATA)0,
                    0,
                    (flags & ST_ISSELF) ? 1L : 0L);
        }

        MONCONV((PCONV_INFO)psi, TRUE);

        if (!(flags & ST_INLIST)) {
            break;      // our partner's only gonna take the first one anyway.
        }
        php++;
    }

    if (fWild) {
        DdeUnaccessData(hData);
        InternalFreeDataHandle(hData, FALSE);
    }

Exit:
    DeleteAtom(laFree1);
    DeleteAtom(laFree2);
    LeaveDDECrit;
    return;
}

/***************************************************************************\
* DDEMLClientWndProc
*
* Description:
* Handles DDE client messages for DDEML.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
LRESULT DDEMLClientWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCL_CONV_INFO pci, pciNew;
    LONG lState;
    LRESULT lRet = 0;
    PWND pwnd;
    PCLS pcls;

    EnterDDECrit;

    pci = (PCL_CONV_INFO)GetWindowLongPtr(hwnd, GWLP_PCI);
    UserAssert(pci == NULL || pci->ci.hwndConv == hwnd);

    switch (message) {
    case WM_DDE_ACK:
        lState = GetWindowLong(hwnd, GWL_CONVSTATE);
        if (lState != CLST_CONNECTED) {

            // Initiation mode

            pciNew = (PCL_CONV_INFO)DDEMLAlloc(sizeof(CL_CONV_INFO));
            if (pciNew == NULL ||
                    (pci != NULL && lState == CLST_SINGLE_INITIALIZING)) {
                PostMessage((HWND)wParam, WM_DDE_TERMINATE, (WPARAM)hwnd, 0);
                goto Exit;
            }

            // PCL_CONV_INFO initialization

            pciNew->ci.pcii = ValidateInstance((HANDLE)GetWindowLongPtr(hwnd, GWLP_CHINST));

            if (pciNew->ci.pcii == NULL) {
                DDEMLFree(pciNew);
                goto Exit;
            }

            pciNew->ci.next = (PCONV_INFO)pci; // pci may be NULL
            //
            // Seting GWLP_PCI gives feedback to ConnectConv() which issued
            // the WM_DDE_INITIATE message.
            //
            SetWindowLongPtr(hwnd, GWLP_PCI, (LONG_PTR)pciNew);
            // pciNew->hUser = 0; // Zero init.

            // BUG: If this fails we can have some nasty problems
            pciNew->ci.hConv = (HCONV)CreateHandle((ULONG_PTR)pciNew,
                    HTYPE_CLIENT_CONVERSATION, InstFromHandle(pciNew->ci.pcii->hInstClient));

            pciNew->ci.laService = GlobalToLocalAtom(LOWORD(lParam)); // pci copy
            GlobalDeleteAtom(LOWORD(lParam));
            pciNew->ci.laTopic = GlobalToLocalAtom(HIWORD(lParam)); // pci copy
            GlobalDeleteAtom(HIWORD(lParam));
            pciNew->ci.hwndPartner = (HWND)wParam;
            pciNew->ci.hwndConv = hwnd;
            pciNew->ci.state = (WORD)(ST_CONNECTED | ST_CLIENT |
                    pciNew->ci.pcii->ConvStartupState);
            SetCommonStateFlags(hwnd, (HWND)wParam, &pciNew->ci.state);

            pwnd = ValidateHwnd((HWND)wParam);

            if (pwnd == NULL) goto Exit;
            pcls = (PCLS)REBASEALWAYS(pwnd, pcls);

            if (!TestWF(pwnd, WFANSIPROC)) {
                if (pcls->atomClassName == gpsi->atomSysClass[ICLS_DDEMLSERVERW]) {
                    pciNew->ci.state |= ST_ISLOCAL;
                }
            } else {
                if (pcls->atomClassName == gpsi->atomSysClass[ICLS_DDEMLSERVERA]) {
                    pciNew->ci.state |= ST_ISLOCAL;
                }
            }

            // pciNew->ci.laServiceRequested = 0; // Set by InitiateEnumerationProc()
            // pciNew->ci.pxiIn = 0;
            // pciNew->ci.pxiOut = 0;
            // pciNew->ci.dmqIn = 0;
            // pciNew->ci.dmqOut = 0;
            // pciNew->ci.aLinks = NULL;
            // pciNew->ci.cLinks = 0;
            // pciNew->ci.cLocks = 0;
            goto Exit;
        }
        // fall through to handle posted messages here.

    case WM_DDE_DATA:
        ProcessAsyncDDEMsg((PCONV_INFO)pci, message, (HWND)wParam, lParam);
        goto Exit;

    case WM_DDE_TERMINATE:
    case WM_DESTROY:
        {
            ProcessTerminateMsg((PCONV_INFO)pci, (HWND)wParam);
            break;
        }
    }

    lRet = DefWindowProc(hwnd, message, wParam, lParam);

Exit:
    LeaveDDECrit;
    return (lRet);
}




/***************************************************************************\
* DDEMLServerWndProc
*
* Description:
* Handles DDE server messages.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
LRESULT DDEMLServerWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PSVR_CONV_INFO psi;
    LRESULT lRet = 0;

    EnterDDECrit;

    psi = (PSVR_CONV_INFO)GetWindowLongPtr(hwnd, GWLP_PSI);
    UserAssert(psi == NULL || psi->ci.hwndConv == hwnd);

    switch (message) {
    case WM_DDE_REQUEST:
    case WM_DDE_POKE:
    case WM_DDE_ADVISE:
    case WM_DDE_EXECUTE:
    case WM_DDE_ACK:
    case WM_DDE_UNADVISE:
        ProcessAsyncDDEMsg((PCONV_INFO)psi, message, (HWND)wParam, lParam);
        goto Exit;

    case WM_DDE_TERMINATE:
    case WM_DESTROY:
        ProcessTerminateMsg((PCONV_INFO)psi, (HWND)wParam);
        break;
    }
    lRet = DefWindowProc(hwnd, message, wParam, lParam);
Exit:
    LeaveDDECrit;
    return (lRet);
}




/***************************************************************************\
* ProcessTerminateMsg
*
* Description:
* Handles WM_DDE_TERMINATE messages for both sides.
*
* History:
* 11-26-91 sanfords Created.
\***************************************************************************/
PCONV_INFO ProcessTerminateMsg(
PCONV_INFO pcoi,
HWND hwndFrom)
{
    while (pcoi != NULL && pcoi->hwndPartner != hwndFrom) {
        pcoi = pcoi->next;
    }
    if (pcoi != NULL) {
        pcoi->state |= ST_TERMINATE_RECEIVED;
        ShutdownConversation(pcoi, TRUE);
    }
    return (pcoi);
}



/***************************************************************************\
* ProcessAsyncDDEMsg
*
* Description:
* Handles incoming DDE messages by either calling ProcessSyncDDEMessage()
* if the conversation is able to handle callbacks, or by queuing the
* incoming message into the conversations message queue. Doing this
* allows simpler code in that no message is processed unless the code
* can perform synchronous callbacks.
*
* History:
* 11-26-91 sanfords Created.
\***************************************************************************/
VOID ProcessAsyncDDEMsg(
PCONV_INFO pcoi,
UINT msg,
HWND hwndFrom,
LPARAM lParam)
{
    PDDE_MESSAGE_QUEUE pdmq;
#if DBG
    HWND hwndT = pcoi->hwndConv;
#endif // DBG

    while (pcoi != NULL && pcoi->hwndPartner != hwndFrom) {
        pcoi = pcoi->next;
    }
    if (pcoi == NULL) {
        RIPMSG3(RIP_WARNING,
                "Bogus DDE message %x received from %x by %x. Dumping.",
                msg, hwndFrom, hwndT);
        DumpDDEMessage(FALSE, msg, lParam);
        return ;
    }
    if (pcoi->state & ST_CONNECTED) {

        if (pcoi->dmqOut == NULL &&
                !(pcoi->state & ST_BLOCKED)
//                && !PctiCurrent()->cInDDEMLCallback
                ) {

            if (ProcessSyncDDEMessage(pcoi, msg, lParam)) {
                return; // not blocked, ok to return.
            }
        }

        // enter into queue

        pdmq = DDEMLAlloc(sizeof(DDE_MESSAGE_QUEUE));
        if (pdmq == NULL) {

            // insufficient memory - we can't process this msg - we MUST
            // terminate.

            if (pcoi->state & ST_CONNECTED) {
                PostMessage(pcoi->hwndPartner, WM_DDE_TERMINATE,
                        (WPARAM)pcoi->hwndConv, 0);
                pcoi->state &= ~ST_CONNECTED;
            }
            DumpDDEMessage(!(pcoi->state & ST_INTRA_PROCESS), msg, lParam);
            return ;
        }
        pdmq->pcoi = pcoi;
        pdmq->msg = msg;
        pdmq->lParam = lParam;
        pdmq->next = NULL;

        // dmqOut->next->next->next->dmqIn->NULL

        if (pcoi->dmqIn != NULL) {
            pcoi->dmqIn->next = pdmq;
        }
        pcoi->dmqIn = pdmq;
        if (pcoi->dmqOut == NULL) {
            pcoi->dmqOut = pcoi->dmqIn;
        }
        pcoi->cLocks++;
        CheckForQueuedMessages(pcoi);
        pcoi->cLocks--;
        if (pcoi->cLocks == 0 && pcoi->state & ST_FREE_CONV_RES_NOW) {
            FreeConversationResources(pcoi);
        }
    } else {
        DumpDDEMessage(!(pcoi->state & ST_INTRA_PROCESS), msg, lParam);
    }
}







/***************************************************************************\
* CheckForQueuedMessages
*
* Description:
* Handles processing of DDE messages held in the given conversaion's
* DDE message queue.
*
* Returns: fProcessed.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL CheckForQueuedMessages(
PCONV_INFO pcoi)
{
    PDDE_MESSAGE_QUEUE pdmq;
    BOOL fRet = FALSE;
    PCLIENTINFO pci;

    CheckDDECritIn;

    if (pcoi->state & ST_PROCESSING) {      // recursion prevention
        return(FALSE);
    }

    UserAssert(pcoi->cLocks);

    pci = GetClientInfo();

    pcoi->state |= ST_PROCESSING;
    while (!(pcoi->state & ST_BLOCKED) &&
                pcoi->dmqOut != NULL &&
                !pci->cInDDEMLCallback) {
        pci->CI_flags |= CI_PROCESSING_QUEUE;
        if (ProcessSyncDDEMessage(pcoi, pcoi->dmqOut->msg, pcoi->dmqOut->lParam)) {
            fRet = TRUE;
            pdmq = pcoi->dmqOut;
            pcoi->dmqOut = pcoi->dmqOut->next;
            if (pcoi->dmqOut == NULL) {
                pcoi->dmqIn = NULL;
            }
            DDEMLFree(pdmq);
        }
        pci->CI_flags &= ~CI_PROCESSING_QUEUE;
    }
    pcoi->state &= ~ST_PROCESSING;
    return(fRet);
}




/***************************************************************************\
* DumpDDEMessage
*
* Description:
* Used to clean up resources referenced by DDE messages that for some
* reason could not be processed.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID DumpDDEMessage(
BOOL fFreeData,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;

    RIPMSG2(RIP_WARNING, "Dump DDE msg %x lParam %x", msg, lParam);

    switch (msg) {
    case WM_DDE_ACK:
    case WM_DDE_DATA:
    case WM_DDE_POKE:
    case WM_DDE_ADVISE:
        UnpackDDElParam(msg, lParam, &uiLo, &uiHi);
        switch (msg) {
        case WM_DDE_DATA:
        case WM_DDE_POKE:
            if (uiLo) {
                if (fFreeData) {
                    FreeDDEData((HANDLE)uiLo, FALSE, TRUE);
                }
                GlobalDeleteAtom((ATOM)uiHi);
            }
            break;

        case WM_DDE_ADVISE:
            if (uiLo) {
                if (fFreeData) {
                    FreeDDEData((HANDLE)uiLo, FALSE, TRUE);
                }
                GlobalDeleteAtom((ATOM)uiHi);
            }
            break;

        case WM_DDE_ACK:
            // could be EXEC Ack - cant know what to do exactly.
            break;
        }
        FreeDDElParam(msg, lParam);
        break;

    case WM_DDE_EXECUTE:
        if (fFreeData) {
            WOWGLOBALFREE((HANDLE)lParam);
        }
        break;

    case WM_DDE_REQUEST:
    case WM_DDE_UNADVISE:
        GlobalDeleteAtom((ATOM)HIWORD(lParam));
        break;
    }
}




/***************************************************************************\
* ProcessSyncDDEMessage
*
* Description:
* Handles processing of a received DDE message. TRUE is returned if
* the message was handled. FALSE implies CBR_BLOCK.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ProcessSyncDDEMessage(
PCONV_INFO pcoi,
UINT msg,
LPARAM lParam)
{
    BOOL fNotBlocked = TRUE;
    PCL_INSTANCE_INFO pcii;
    ENABLE_ENUM_STRUCT ees;
    BOOL fRet;

    CheckDDECritIn;

    /*
     * lock the conversation so its resources don't go away till we are
     * done with them.  This function could generate a callback which could
     * disconnect the conversation.
     */
    pcoi->cLocks++;

    if (pcoi->state & ST_BLOCKNEXT) {
        pcoi->state ^= ST_BLOCKNEXT | ST_BLOCKED;
    }
    if (pcoi->state & ST_BLOCKALLNEXT) {
        ees.pfRet = &fRet;
        ees.wCmd = EC_DISABLE;
        ees.wCmd2 = 0;
        EnumChildWindows(pcoi->pcii->hwndMother, (WNDENUMPROC)EnableEnumProc,
                (LPARAM)&ees);
    }

    if (pcoi->state & ST_CONNECTED) {
        if (pcoi->pxiOut == NULL) {
            if (pcoi->state & ST_CLIENT) {
                fNotBlocked = SpontaneousClientMessage((PCL_CONV_INFO)pcoi, msg, lParam);
            } else {
                fNotBlocked = SpontaneousServerMessage((PSVR_CONV_INFO)pcoi, msg, lParam);
            }
        } else {
            UserAssert(pcoi->pxiOut->hXact == (HANDLE)0 ||
                    ValidateCHandle(pcoi->pxiOut->hXact, HTYPE_TRANSACTION,
                    HINST_ANY)
                    == (ULONG_PTR)pcoi->pxiOut);
            fNotBlocked = (pcoi->pxiOut->pfnResponse)(pcoi->pxiOut, msg, lParam);
        }
    } else {
        DumpDDEMessage(!(pcoi->state & ST_INTRA_PROCESS), msg, lParam);
    }
    if (!fNotBlocked) {
        pcoi->state |= ST_BLOCKED;
        pcoi->state &= ~ST_BLOCKNEXT;
    }

    pcii = pcoi->pcii;  // save this incase unlocking makes pcoi go away.

    pcoi->cLocks--;
    if (pcoi->cLocks == 0 && pcoi->state & ST_FREE_CONV_RES_NOW) {
        FreeConversationResources(pcoi);
    }

    /*
     * Because callbacks are capable of blocking DdeUninitialize(), we check
     * before exit to see if it needs to be called.
     */
    if (pcii->afCmd & APPCMD_UNINIT_ASAP &&
            !(pcii->flags & IIF_IN_SYNC_XACT) &&
            !pcii->cInDDEMLCallback) {
        DdeUninitialize(HandleToUlong(pcii->hInstClient));
        return(FALSE);
    }
    return (fNotBlocked);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\ddetrack.c ===
/****************************** Module Header ******************************\
* Module Name: ddetrack.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client sied DDE tracking routines
*
* 10-22-91 sanfords created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#if defined(BUILD_WOW6432)
#define DDEDATA_WITH_HANDLE_SIZE  (sizeof (DDEDATA_WOW6432))
#else
#define DDEDATA_WITH_HANDLE_SIZE  (sizeof (DDE_DATA))
#endif


DWORD _ClientCopyDDEIn1(
    HANDLE hClient, // client handle to dde data or ddepack data
    PINTDDEINFO pi) // info for transfer
{
    PBYTE pData;
    DWORD flags;

    //
    // zero out everything but the flags
    //
    flags = pi->flags;
    RtlZeroMemory(pi, sizeof(INTDDEINFO));
    pi->flags = flags;
    USERGLOBALLOCK(hClient, pData);

    if (pData == NULL) {                            // bad hClient
        RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:GlobalLock failed.");
        return (FAIL_POST);
    }

    if (flags & XS_PACKED) {

        if (UserGlobalSize(hClient) < sizeof(DDEPACK)) {
            /*
             * must be a low memory condition. fail.
             */
            return(FAIL_POST);
        }

        pi->DdePack = *(PDDEPACK)pData;
        USERGLOBALUNLOCK(hClient);
        UserGlobalFree(hClient);    // packed data handles are not WOW matched.
        hClient = NULL;

        if (!(flags & (XS_LOHANDLE | XS_HIHANDLE))) {
            if (flags & XS_EXECUTE && flags & XS_FREESRC) {
                /*
                 * free execute ACK data
                 */
                WOWGLOBALFREE((HANDLE)pi->DdePack.uiHi);
            }
            return (DO_POST); // no direct data
        }

        if (flags & XS_LOHANDLE) {
            pi->hDirect = (HANDLE)pi->DdePack.uiLo;
        } else {
            pi->hDirect = (HANDLE)pi->DdePack.uiHi;
        }

        if (pi->hDirect == 0) {
            return (DO_POST); // must be warm link
        }

        USERGLOBALLOCK(pi->hDirect, pi->pDirect);
        if (pi->pDirect == NULL) {
            RIPMSG1(RIP_ERROR, "_ClientCopyDDEIn1:GlobalLock failed for hDirect %p.",pi->hDirect);
            return FAILNOFREE_POST;
        }
        pData = pi->pDirect;
        pi->cbDirect = (UINT)UserGlobalSize(pi->hDirect);

    } else {    // not packed - must be execute data or we wouldn't be called

        UserAssert(flags & XS_EXECUTE);

        pi->cbDirect = (UINT)UserGlobalSize(hClient);
        pi->hDirect = hClient;
        pi->pDirect = pData;
        hClient = NULL;
    }

    if (flags & XS_DATA) {
        PDDE_DATA pDdeData = (PDDE_DATA)pData;

        /*
         * Assert that the hClient has been freed. If not this code will return
         * the wrong thing on failure
         */
        UserAssert(flags & XS_PACKED);

        //
        // check here for indirect data
        //

        switch (pDdeData->wFmt) {
        case CF_BITMAP:
        case CF_DSPBITMAP:
            //
            // Imediately following the dde data header is a bitmap handle.
            //
            UserAssert(pi->cbDirect >= DDEDATA_WITH_HANDLE_SIZE);
            pi->hIndirect = (HANDLE)pDdeData->Data;
            if (pi->hIndirect == 0) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:GdiConvertBitmap failed");
                return(FAILNOFREE_POST);
            }
            // pi->cbIndirect = 0; // zero init.
            // pi->pIndirect = NULL; // zero init.
            pi->flags |= XS_BITMAP;
            break;

        case CF_DIB:
            //
            // Imediately following the dde data header is a global data handle
            // to the DIB bits.
            //
            UserAssert(pi->cbDirect >= DDEDATA_WITH_HANDLE_SIZE);
            pi->flags |= XS_DIB;
            pi->hIndirect = (HANDLE)pDdeData->Data;
            USERGLOBALLOCK(pi->hIndirect, pi->pIndirect);
            if (pi->pIndirect == NULL) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:CF_DIB GlobalLock failed.");
                return (FAILNOFREE_POST);
            }
            pi->cbIndirect = (UINT)UserGlobalSize(pi->hIndirect);
            break;

        case CF_PALETTE:
            UserAssert(pi->cbDirect >= DDEDATA_WITH_HANDLE_SIZE);
            pi->hIndirect = (HANDLE) pDdeData->Data;
            if (pi->hIndirect == 0) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:GdiConvertPalette failed.");
                return(FAILNOFREE_POST);
            }
            // pi->cbIndirect = 0; // zero init.
            // pi->pIndirect = NULL; // zero init.
            pi->flags |= XS_PALETTE;
            break;

        case CF_DSPMETAFILEPICT:
        case CF_METAFILEPICT:
            //
            // This format holds a global data handle which contains
            // a METAFILEPICT structure that in turn contains
            // a GDI metafile.
            //
            UserAssert(pi->cbDirect >= DDEDATA_WITH_HANDLE_SIZE);
            pi->hIndirect = GdiConvertMetaFilePict((HANDLE)pDdeData->Data);
            if (pi->hIndirect == 0) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:GdiConvertMetaFilePict failed");
                return(FAILNOFREE_POST);
            }
            // pi->cbIndirect = 0; // zero init.
            // pi->pIndirect = NULL; // zero init.
            pi->flags |= XS_METAFILEPICT;
            break;

        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
            UserAssert(pi->cbDirect >= DDEDATA_WITH_HANDLE_SIZE);
            pi->hIndirect = GdiConvertEnhMetaFile((HENHMETAFILE)pDdeData->Data);
            if (pi->hIndirect == 0) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEIn1:GdiConvertEnhMetaFile failed");
                return(FAILNOFREE_POST);
            }
            // pi->cbIndirect = 0; // zero init.
            // pi->pIndirect = NULL; // zero init.
            pi->flags |= XS_ENHMETAFILE;
            break;
        }
    }

    return (DO_POST);
}


/*
 * unlocks and frees DDE data pointers as appropriate
 */
VOID _ClientCopyDDEIn2(
    PINTDDEINFO pi)
{
    if (pi->cbDirect) {
        USERGLOBALUNLOCK(pi->hDirect);
        if (pi->flags & XS_FREESRC) {
            WOWGLOBALFREE(pi->hDirect);
        }
    }

    if (pi->cbIndirect) {
        USERGLOBALUNLOCK(pi->hIndirect);
        if (pi->flags & XS_FREESRC) {
            WOWGLOBALFREE(pi->hIndirect);
        }
    }
}



/*
 * returns fHandleValueChanged.
 */
BOOL FixupDdeExecuteIfNecessary(
HGLOBAL *phCommands,
BOOL fNeedUnicode)
{
    UINT cbLen;
    UINT cbSrc = (UINT)GlobalSize(*phCommands);
    LPVOID pstr;
    HGLOBAL hTemp;
    BOOL fHandleValueChanged = FALSE;

    USERGLOBALLOCK(*phCommands, pstr);

    if (cbSrc && pstr != NULL) {
        BOOL fIsUnicodeText;
#ifdef ISTEXTUNICODE_WORKS
        int flags;

        flags = (IS_TEXT_UNICODE_UNICODE_MASK |
                IS_TEXT_UNICODE_REVERSE_MASK |
                (IS_TEXT_UNICODE_NOT_UNICODE_MASK &
                (~IS_TEXT_UNICODE_ILLEGAL_CHARS)) |
                IS_TEXT_UNICODE_NOT_ASCII_MASK);
        fIsUnicodeText = RtlIsTextUnicode(pstr, cbSrc - 2, &flags);
#else
        fIsUnicodeText = ((cbSrc >= sizeof(WCHAR)) && (((LPSTR)pstr)[1] == '\0'));
#endif
        if (!fIsUnicodeText && fNeedUnicode) {
            LPWSTR pwsz;
            /*
             * Contents needs to be UNICODE.
             */
            cbLen = strlen(pstr) + 1;
            cbSrc = min(cbSrc, cbLen);
            pwsz = UserLocalAlloc(HEAP_ZERO_MEMORY, cbSrc * sizeof(WCHAR));
            if (pwsz != NULL) {
                if (NT_SUCCESS(RtlMultiByteToUnicodeN(
                        pwsz,
                        cbSrc * sizeof(WCHAR),
                        NULL,
                        (PCHAR)pstr,
                        cbSrc))) {
                    USERGLOBALUNLOCK(*phCommands);
                    if ((hTemp = GlobalReAlloc(
                            *phCommands,
                            cbSrc * sizeof(WCHAR),
                            GMEM_MOVEABLE)) != NULL) {
                        fHandleValueChanged = (hTemp != *phCommands);
                        *phCommands = hTemp;
                        USERGLOBALLOCK(*phCommands, pstr);
                        pwsz[cbSrc - 1] = L'\0';
                        wcscpy(pstr, pwsz);
                    }
                }
                UserLocalFree(pwsz);
            }
        } else if (fIsUnicodeText && !fNeedUnicode) {
            LPSTR psz;
            /*
             * Contents needs to be ANSI.
             */
            cbLen = (wcslen(pstr) + 1) * sizeof(WCHAR);
            cbSrc = min(cbSrc, cbLen);
            psz = UserLocalAlloc(HEAP_ZERO_MEMORY, cbSrc);
            if (psz != NULL) {
                if (NT_SUCCESS(RtlUnicodeToMultiByteN(
                        psz,
                        cbSrc,
                        NULL,
                        (PWSTR)pstr,
                        cbSrc))) {
                    USERGLOBALUNLOCK(*phCommands);
                    if ((hTemp = GlobalReAlloc(
                            *phCommands,
                            cbSrc / sizeof(WCHAR),
                            GMEM_MOVEABLE)) != NULL) {
                        fHandleValueChanged = (hTemp != *phCommands);
                        *phCommands = hTemp;
                        USERGLOBALLOCK(*phCommands, pstr);
                        UserAssert(pstr);
                        psz[cbSrc - 1] = '\0';
                        strcpy(pstr, psz);
                    }
                }
                UserLocalFree(psz);
            }
        }
        USERGLOBALUNLOCK(*phCommands);
    }
    return(fHandleValueChanged);
}



/*
 * Allocates and locks global handles as appropriate in preperation
 * for thunk copying.
 */
HANDLE _ClientCopyDDEOut1(
    PINTDDEINFO pi)
{
    HANDLE hDdePack = NULL;
    PDDEPACK pDdePack = NULL;

    if (pi->flags & XS_PACKED) {
        /*
         * make a wrapper for the data
         */
        hDdePack = UserGlobalAlloc(GMEM_DDESHARE | GMEM_FIXED,
                sizeof(DDEPACK));
        pDdePack = (PDDEPACK)hDdePack;
        if (pDdePack == NULL) {
            RIPMSG0(RIP_WARNING, "_ClientCopyDDEOut1:Couldn't allocate DDEPACK");
            return (NULL);
        }
        *pDdePack = pi->DdePack;
    }

    if (pi->cbDirect) {
        pi->hDirect = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, pi->cbDirect);
        if (pi->hDirect == NULL) {
            RIPMSG0(RIP_WARNING, "_ClientCopyDDEOut1:Couldn't allocate hDirect");
            if (hDdePack) {
                UserGlobalFree(hDdePack);
            }
            return (NULL);
        }

        USERGLOBALLOCK(pi->hDirect, pi->pDirect);
        UserAssert(pi->pDirect);

        // fixup packed data reference to direct data

        if (pDdePack != NULL) {
            if (pi->flags & XS_LOHANDLE) {
                pDdePack->uiLo = (UINT_PTR)pi->hDirect;
                UserAssert((ULONG_PTR)pDdePack->uiLo == (ULONG_PTR)pi->hDirect);
            } else if (pi->flags & XS_HIHANDLE) {
                pDdePack->uiHi = (UINT_PTR)pi->hDirect;
                UserAssert((ULONG_PTR)pDdePack->uiHi == (ULONG_PTR)pi->hDirect);
            }
        }

        if (pi->cbIndirect) {
            pi->hIndirect = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE,
                    pi->cbIndirect);
            if (pi->hIndirect == NULL) {
                RIPMSG0(RIP_WARNING, "_ClientCopyDDEOut1:Couldn't allocate hIndirect");
                USERGLOBALUNLOCK(pi->hDirect);
                UserGlobalFree(pi->hDirect);
                if (hDdePack) {
                    UserGlobalFree(hDdePack);
                }
                return (NULL);
            }
            USERGLOBALLOCK(pi->hIndirect, pi->pIndirect);
            UserAssert(pi->pIndirect);
        }
    }

    if (hDdePack) {
        return (hDdePack);
    } else {
        return (pi->hDirect);
    }
}



/*
 * Fixes up internal poniters after thunk copy and unlocks handles.
 */
BOOL _ClientCopyDDEOut2(
    PINTDDEINFO pi)
{
    BOOL fSuccess = TRUE;
    /*
     * done with copies - now fixup indirect references
     */
    if (pi->hIndirect) {
        PDDE_DATA pDdeData = (PDDE_DATA)pi->pDirect;

        switch (pDdeData->wFmt) {
        case CF_BITMAP:
        case CF_DSPBITMAP:
        case CF_PALETTE:
            pDdeData->Data = (KERNEL_PVOID)pi->hIndirect;
            fSuccess = (pDdeData->Data != NULL);
            break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
            pDdeData->Data = (KERNEL_PVOID)GdiCreateLocalMetaFilePict(pi->hIndirect);
            fSuccess = (pDdeData->Data != NULL);
            break;

        case CF_DIB:
            pDdeData->Data = (KERNEL_PVOID)pi->hIndirect;
            fSuccess = (pDdeData->Data != NULL);
            USERGLOBALUNLOCK(pi->hIndirect);
            break;

        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
            pDdeData->Data = (KERNEL_PVOID)GdiCreateLocalEnhMetaFile(pi->hIndirect);
            fSuccess = (pDdeData->Data != NULL);
            break;

        default:
            RIPMSG0(RIP_WARNING, "_ClientCopyDDEOut2:Unknown format w/indirect data.");
            fSuccess = FALSE;
            USERGLOBALUNLOCK(pi->hIndirect);
        }
    }

    UserAssert(pi->hDirect); // if its null, we didn't need to call this function.
    USERGLOBALUNLOCK(pi->hDirect);
    if (pi->flags & XS_EXECUTE) {
        /*
         * Its possible that in RAW DDE cases where the app allocated the
         * execute data as non-moveable, we have a different hDirect
         * than we started with.  This needs to be noted and passed
         * back to the server. (Very RARE case)
         */
        FixupDdeExecuteIfNecessary(&pi->hDirect,
                pi->flags & XS_UNICODE);
    }
    return fSuccess;
}



/*
 * This routine is called by the tracking layer when it frees DDE objects
 * on behalf of a client.   This cleans up the LOCAL objects associated
 * with the DDE objects.  It should NOT remove truely global objects such
 * as bitmaps or palettes except in the XS_DUMPMSG case which is for
 * faked Posts.
 */

#if DBG
    /*
     * Help track down a bug where I suspect the xxxFreeListFree is
     * freeing a handle already freed by some other means which has
     * since been reallocated and is trashing the client heap. (SAS)
     */
    HANDLE DDEHandleLastFreed = 0;
#endif

BOOL _ClientFreeDDEHandle(
HANDLE hDDE,
DWORD flags)
{
    PDDEPACK pDdePack;
    HANDLE hNew;

    if (flags & XS_PACKED) {
        pDdePack = (PDDEPACK)hDDE;
        if (pDdePack == NULL) {
            return (FALSE);
        }
        if (flags & XS_LOHANDLE) {
            hNew = (HANDLE)pDdePack->uiLo;
        } else {
            hNew = (HANDLE)pDdePack->uiHi;

        }
        WOWGLOBALFREE(hDDE);
        hDDE = hNew;

    }

   /*
    * Do a range check and call GlobalFlags to validate, just to prevent heap checking
    * from complaining during the GlobalSize call.
    * Is this leaking atoms??
    */
    if ((hDDE <= (HANDLE)0xFFFF)
        || (GlobalFlags(hDDE) == GMEM_INVALID_HANDLE)
        || !GlobalSize(hDDE)) {
            /*
             * There may be cases where apps improperly freed stuff
             * when they shouldn't have so make sure this handle
             * is valid by the time it gets here.
             *
             * See SvSpontAdvise; it posts a message with an atom in uiHi. Then from _PostMessage
             *  in the kernel side, we might end up here. So it's not only for apps...
             */
            return(FALSE);
    }

    if (flags & XS_DUMPMSG) {
        if (flags & XS_PACKED) {
            if (!IS_PTR(hNew)) {
                GlobalDeleteAtom(LOWORD((ULONG_PTR)hNew));
                if (!(flags & XS_DATA)) {
                    return(TRUE);     // ACK
                }
            }
        } else {
            if (!(flags & XS_EXECUTE)) {
                GlobalDeleteAtom(LOWORD((ULONG_PTR)hDDE));   // REQUEST, UNADVISE
                return(TRUE);
            }
        }
    }
    if (flags & XS_DATA) {
        // POKE, DATA
#if DBG
        DDEHandleLastFreed = hDDE;
#endif
        FreeDDEData(hDDE,
                (flags & XS_DUMPMSG) ? FALSE : TRUE,    // fIgnorefRelease
                (flags & XS_DUMPMSG) ? TRUE : FALSE);    // fDestroyTruelyGlobalObjects
    } else {
        // ADVISE, EXECUTE
#if DBG
        DDEHandleLastFreed = hDDE;
#endif
        WOWGLOBALFREE(hDDE);   // covers ADVISE case (fmt but no data)
    }
    return (TRUE);
}


DWORD _ClientGetDDEFlags(
HANDLE hDDE,
DWORD flags)
{
    PDDEPACK pDdePack;
    PWORD pw;
    HANDLE hData;
    DWORD retval = 0;

    pDdePack = (PDDEPACK)hDDE;
    if (pDdePack == NULL) {
        return (0);
    }

    if (flags & XS_DATA) {
        if (pDdePack->uiLo) {
            hData = (HANDLE)pDdePack->uiLo;
            USERGLOBALLOCK(hData, pw);
            if (pw != NULL) {
                retval = (DWORD)*pw; // first word is hData is wStatus
                USERGLOBALUNLOCK(hData);
            }
        }
    } else {
        retval = (DWORD)pDdePack->uiLo;
    }

    return (retval);
}



FUNCLOG3(LOG_GENERAL, LPARAM, APIENTRY, PackDDElParam, UINT, msg, UINT_PTR, uiLo, UINT_PTR, uiHi)
LPARAM APIENTRY PackDDElParam(
UINT msg,
UINT_PTR uiLo,
UINT_PTR uiHi)
{
    PDDEPACK pDdePack;
    HANDLE h;

    switch (msg) {
    case WM_DDE_EXECUTE:
        return((LPARAM)uiHi);

    case WM_DDE_ACK:
    case WM_DDE_ADVISE:
    case WM_DDE_DATA:
    case WM_DDE_POKE:
        h = UserGlobalAlloc(GMEM_DDESHARE | GMEM_FIXED, sizeof(DDEPACK));
        pDdePack = (PDDEPACK)h;
        if (pDdePack == NULL) {
            return(0);
        }
        pDdePack->uiLo = uiLo;
        pDdePack->uiHi = uiHi;
        return((LPARAM)h);

    default:
        return(MAKELONG((WORD)uiLo, (WORD)uiHi));
    }
}




FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, UnpackDDElParam, UINT, msg, LPARAM, lParam, PUINT_PTR, puiLo, PUINT_PTR, puiHi)
BOOL APIENTRY UnpackDDElParam(
UINT msg,
LPARAM lParam,
PUINT_PTR puiLo,
PUINT_PTR puiHi)
{
    PDDEPACK pDdePack;

    switch (msg) {
    case WM_DDE_EXECUTE:
        if (puiLo != NULL) {
            *puiLo = 0L;
        }
        if (puiHi != NULL) {
            *puiHi = (UINT_PTR)lParam;
        }
        return(TRUE);

    case WM_DDE_ACK:
    case WM_DDE_ADVISE:
    case WM_DDE_DATA:
    case WM_DDE_POKE:
        pDdePack = (PDDEPACK)lParam;
        if (pDdePack == NULL || !GlobalHandle(pDdePack)) {
            if (puiLo != NULL) {
                *puiLo = 0L;
            }
            if (puiHi != NULL) {
                *puiHi = 0L;
            }
            return(FALSE);
        }
        if (puiLo != NULL) {
            *puiLo = pDdePack->uiLo;
        }
        if (puiHi != NULL) {
            *puiHi = pDdePack->uiHi;
        }
        return(TRUE);

    default:
        if (puiLo != NULL) {
            *puiLo = (UINT)LOWORD(lParam);
        }
        if (puiHi != NULL) {
            *puiHi = (UINT)HIWORD(lParam);
        }
        return(TRUE);
    }
}




FUNCLOG2(LOG_GENERAL, BOOL, APIENTRY, FreeDDElParam, UINT, msg, LPARAM, lParam)
BOOL APIENTRY FreeDDElParam(
UINT msg,
LPARAM lParam)
{
    switch (msg) {
    case WM_DDE_ACK:
    case WM_DDE_ADVISE:
    case WM_DDE_DATA:
    case WM_DDE_POKE:
        /*
         * Do a range check and call GlobalFlags to validate,
         * just to prevent heap checking from complaining
         */
        if ((lParam > (LPARAM)0xFFFF) && GlobalFlags((HANDLE)lParam) != GMEM_INVALID_HANDLE) {
            if (GlobalHandle((HANDLE)lParam))
                return(UserGlobalFree((HANDLE)lParam) == NULL);
        }

    default:
        return(TRUE);
    }
}



FUNCLOG5(LOG_GENERAL, LPARAM, APIENTRY, ReuseDDElParam, LPARAM, lParam, UINT, msgIn, UINT, msgOut, UINT_PTR, uiLo, UINT_PTR, uiHi)
LPARAM APIENTRY ReuseDDElParam(
LPARAM lParam,
UINT msgIn,
UINT msgOut,
UINT_PTR uiLo,
UINT_PTR uiHi)
{
    PDDEPACK pDdePack;

    switch (msgIn) {
    case WM_DDE_ACK:
    case WM_DDE_DATA:
    case WM_DDE_POKE:
    case WM_DDE_ADVISE:
        //
        // Incoming message was packed...
        //
        switch (msgOut) {
        case WM_DDE_EXECUTE:
            FreeDDElParam(msgIn, lParam);
            return((LPARAM)uiHi);

        case WM_DDE_ACK:
        case WM_DDE_ADVISE:
        case WM_DDE_DATA:
        case WM_DDE_POKE:
            /*
             * This must be a valid handle
             */
            UserAssert(GlobalFlags((HANDLE)lParam) != GMEM_INVALID_HANDLE);
            UserAssert(GlobalSize((HANDLE)lParam) == sizeof(DDEPACK));
            //
            // Actual cases where lParam can be reused.
            //
            pDdePack = (PDDEPACK)lParam;
            if (pDdePack == NULL) {
                return(0);          // the only error case
            }
            pDdePack->uiLo = uiLo;
            pDdePack->uiHi = uiHi;
            return(lParam);


        default:
            FreeDDElParam(msgIn, lParam);
            return(MAKELONG((WORD)uiLo, (WORD)uiHi));
        }

    default:
        //
        // Incoming message was not packed ==> PackDDElParam()
        //
        return(PackDDElParam(msgOut, uiLo, uiHi));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\dlgend.c ===
/***************************************************************************\
*
*  DLGEND.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Dialog Destruction Routines
*
* ??-???-???? mikeke    Ported from Win 3.0 sources
* 12-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* EndDialog
*
* History:
* 11-Dec-1990 mikeke  ported from win30
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EndDialog, HWND, hwnd, INT_PTR, result)
BOOL EndDialog(
    HWND hwnd,
    INT_PTR result)
{
    PWND pwnd;
    PWND pwndOwner;
    HWND hwndOwner;
    BOOL fWasActive = FALSE;
#ifdef SYSMODALWINDOWS
    HWND hwndOldSysModal;
#endif

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    CheckLock(pwnd);

    /*
     * Must do special validation here to make sure pwnd is a dialog window.
     */
    if (!ValidateDialogPwnd(pwnd))
        return 0;

    if (SAMEWOWHANDLE(hwnd, GetActiveWindow())) {
        fWasActive = TRUE;
    }

    /*
     * GetWindowCreator returns either a kernel address or NULL.
     */
    pwndOwner = GetWindowCreator(pwnd);

    if (pwndOwner != NULL) {

        /*
         * Hide the window.
         */
        pwndOwner = REBASEPTR(pwnd, pwndOwner);
        hwndOwner = HWq(pwndOwner);
        if (!PDLG(pwnd)->fDisabled) {
            NtUserEnableWindow(hwndOwner, TRUE);
        }
    } else {
        hwndOwner = NULL;
    }

    /*
     * Terminate Mode Loop.
     */
    PDLG(pwnd)->fEnd = TRUE;
    PDLG(pwnd)->result = result;

    if (fWasActive && IsChild(hwnd, GetFocus())) {

        /*
         * Set focus to the dialog box so that any control which has the focus
         * can do an kill focus processing.  Most useful for combo boxes so that
         * they can popup their dropdowns before destroying/hiding the dialog
         * box window.  Note that we only do this if the focus is currently at a
         * child of this dialog box.  We also need to make sure we are the active
         * window because this may be happening while we are in a funny state.
         * ie.  the activation is in the middle of changing but the focus hasn't
         * changed yet.  This happens with TaskMan (or maybe with other apps that
         * change the focus/activation at funny times).
         */
        NtUserSetFocus(hwnd);
    }

    NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                       SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOMOVE |
                       SWP_NOSIZE | SWP_NOZORDER);

#ifdef SYSMODALWINDOWS

    /*
     * If this guy was sysmodal, set the sysmodal flag to previous guy so we
     * won't have a hidden sysmodal window that will mess things
     * up royally...
     */
    if (pwnd == gspwndSysModal) {
        hwndOldSysModal = PDLG(pwnd)->hwndSysModalSave;
        if (hwndOldSysModal && !IsWindow(hwndOldSysModal))
            hwndOldSysModal = NULL;

        SetSysModalWindow(hwndOldSysModal);

        // If there was a previous system modal window, we want to
        // activate it instead of this window's owner.
        //
        if (hwndOldSysModal)
            hwndOwner = hwndOldSysModal;
    }
#endif

    /*
     * Don't do any activation unless we were previously active.
     */
    if (fWasActive && hwndOwner) {
        NtUserSetActiveWindow(hwndOwner);
    } else {

        /*
         * If at this point we are still the active window it means that
         * we have fallen into the black hole of being the only visible
         * window in the system when we hid ourselves.  This is a bug and
         * needs to be fixed better later on.  For now, though, just
         * set the active and focus window to NULL.
         */
        if (SAMEWOWHANDLE(hwnd, GetActiveWindow())) {
//     The next two lines are *not* the equivalent of the two Unlock
//      statements that were in Daytona server-side dlgend.c.  So, we
//      need to go over to server/kernel and do it right.  This fixes
//      a problem in Visual Slick, which had the MDI window lose focus
//      when a message box was dismissed.  FritzS
//            SetActiveWindow(NULL);
//            SetFocus(NULL);
            NtUserCallNoParam(SFI_ZAPACTIVEANDFOCUS);
        }
    }

#ifdef SYSMODALWINDOWS

    /*
     * If this guy was sysmodal, set the sysmodal flag to previous guy so we
     * won't have a hidden sysmodal window that will mess things
     * up
     * See comments for Bug #134; SANKAR -- 08-25-89 --;
     */
    if (pwnd == gspwndSysModal) {

        /*
         * Check if the previous Sysmodal guy is still valid?
         */
        hwndOldSysModal = PDLG(pwnd)->hwndSysModalSave;
        if (hwndOldSysModal && !IsWindow(hwndOldSysModal))
            hwndOldSysModal = NULL;
        SetSysModalWindow(hwndOldSysModal);
    }
#endif

    /*
     * Make sure the dialog loop will wake and destroy the window.
     * The dialog loop is waiting on posted events (WaitMessage). If
     * EndDialog is called due to a sent message from another thread the
     * dialog loop will keep waiting for posted events and not destroy
     * the window. This happens when the dialog is obscured.
     * This is a problem with winfile and its copy/move dialog.
     */
    PostMessage(hwnd, WM_NULL, 0, 0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\ddemlcli.h ===
/****************************** Module Header ******************************\
* Module Name: ddemlcli.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains stuff used by client side ddeml code.
*
* History:
* 10-28-91 Sanfords     Created
\***************************************************************************/
#if DBG
#define DDEMLAlloc(cb)          RtlAllocateHeap(gpDDEMLHeap, HEAP_ZERO_MEMORY, (cb))
#define DDEMLReAlloc(p, cb)     RtlReAllocateHeap(gpDDEMLHeap, HEAP_ZERO_MEMORY, (p), (cb))
#define DDEMLFree(p)            RtlFreeHeap(gpDDEMLHeap, 0, (p))
#else
#define DDEMLAlloc(cb)          LocalAlloc(LPTR, cb)
#define DDEMLReAlloc(p, cb)     LocalReAlloc(p, cb, LHND)
#define DDEMLFree(p)            LocalFree(p);
#endif


// general typedefs

typedef    ATOM    LATOM;
typedef    ATOM    GATOM;

// monitor stuff ------------------------------------------

#define MONHSZ(pcii, hsz, type)     if ((pcii->MonitorFlags & MF_HSZ_INFO) && hsz) \
                                        MonitorStringHandle(pcii, hsz, type)
#define MONLINK(pcii, fEst, fNoD, aS, aT, aI, wFmt, fSvr, hConvS, hConvC) \
        if (pcii->MonitorFlags & MF_LINKS) \
            MonitorLink(pcii, fEst, fNoD, aS, aT, aI, \
            wFmt, fSvr, hConvS, hConvC)

#define MONCONV(pcoi, fConn) \
        if (((pcoi)->pcii->MonitorFlags & MF_CONV) && \
                ((((pcoi)->state & ST_ISLOCAL) && (pcoi)->state & ST_CLIENT) || \
                !((pcoi)->state & ST_ISLOCAL))) \
            MonitorConv(pcoi, fConn);

// critical section stuff ---------------------------------

extern RTL_CRITICAL_SECTION gcsDDEML;
#if DBG
extern PVOID gpDDEMLHeap;
#endif
#define EnterDDECrit       RtlEnterCriticalSection(&gcsDDEML);
#define LeaveDDECrit       RtlLeaveCriticalSection(&gcsDDEML);
#if DBG
#define CheckDDECritIn     if (GetCurrentThreadId() != HandleToUlong(gcsDDEML.OwningThread)) { \
                               RIPMSG0(RIP_ERROR, "CheckDDECritIn failed"); \
                           }
#define CheckDDECritOut    if (GetCurrentThreadId() == HandleToUlong(gcsDDEML.OwningThread)) { \
                               RIPMSG0(RIP_ERROR, "CheckDDECritoUT failed"); \
                           }
#else
#define CheckDDECritIn     ;
#define CheckDDECritOut    ;
#endif

// String handle stuff -------------------------------------

// return values for ValidateHSZ macro
#define HSZT_INVALID        0
#define HSZT_NORMAL         1
#define HSZT_INST_SPECIFIC  2

#define LATOM_FROM_HSZ(hsz)             (LATOM)(ULONG_PTR)(hsz)
#define NORMAL_HSZ_FROM_LATOM(a)        (HSZ)(ULONG_PTR)(a)
#define INST_SPECIFIC_HSZ_FROM_LATOM(a) (HSZ)LongToHandle( MAKELONG(a, 1) )

// Handle manager stuff ------------------------------------------

typedef struct tagCHANDLEENTRY {
   HANDLE handle;
   ULONG_PTR dwData;
} CHANDLEENTRY, *PCHANDLEENTRY;

typedef BOOL (*PFNHANDLEAPPLY)(HANDLE);

#define MASK_ID      0xFF000000     // 256 uniqueness
#define SHIFT_ID     24
#define MASK_INDEX   0x00FFFC00     // 16K handles per process max
#define SHIFT_INDEX  10
#define MASK_TYPE    0x00000380     // 8 types max
#define SHIFT_TYPE   7
#define MASK_INST    0x0000007F     // 128 instances per process max
#define SHIFT_INST   0
#define MAX_INST     MASK_INST

#define IdFromHandle(h)    (DWORD)(((ULONG_PTR)(h) & MASK_ID)     >> SHIFT_ID)
#define IndexFromHandle(h) (DWORD)(((ULONG_PTR)(h) & MASK_INDEX)  >> SHIFT_INDEX)
#define TypeFromHandle(h)  (DWORD)(((ULONG_PTR)(h) & MASK_TYPE)   >> SHIFT_TYPE)
#define InstFromHandle(h)  (DWORD)(((ULONG_PTR)(h) & MASK_INST)   >> SHIFT_INST)

#define HandleFromId(h)    (((DWORD)(h)) << SHIFT_ID)
#define HandleFromIndex(h) (((DWORD)(h)) << SHIFT_INDEX)
#define HandleFromType(h)  (((DWORD)(h)) << SHIFT_TYPE)
#define HandleFromInst(h)  (((DWORD)(h)) << SHIFT_INST)

#define HTYPE_EMPTY                    0
#define HTYPE_INSTANCE                 1
#define HTYPE_SERVER_CONVERSATION      2
#define HTYPE_CLIENT_CONVERSATION      3
#define HTYPE_CONVERSATION_LIST        4
#define HTYPE_TRANSACTION              5
#define HTYPE_DATA_HANDLE              6
#define HTYPE_ZOMBIE_CONVERSATION      7

#define HTYPE_ANY                      (DWORD)(-1)
#define HINST_ANY                      (DWORD)(-1)

// transaction stuff -------------------------------------------

typedef struct tagXACT_INFO *PXACT_INFO;

typedef BOOL (* FNRESPONSE)(PXACT_INFO, UINT, LPARAM);

typedef struct tagXACT_INFO {
    struct tagXACT_INFO *next;
    struct tagCONV_INFO *pcoi;
    DWORD_PTR           hUser;
    HANDLE              hXact;
    FNRESPONSE          pfnResponse;
    GATOM               gaItem;
    WORD                wFmt;
    WORD                wType;                // for DdeQueryConvInfo only
    WORD                wStatus;              // see DDE_F flags
    WORD                flags;                // see XIF_ flags
    WORD                state;                // see XST_ state values (ddeml.h)
    HANDLE              hDDESent;             // in case NACK is returned.
    HANDLE              hDDEResult;
} XACT_INFO;

#define     XIF_SYNCHRONOUS         0x1
#define     XIF_COMPLETE            0x2
#define     XIF_ABANDONED           0x4

#define     TID_TIMEOUT             1

// Advise link tracking stuff -----------------------------------

typedef struct tagLINK_COUNT *PLINK_COUNT;
typedef struct tagADVISE_LINK {
    struct tagLINK_COUNT *pLinkCount;
    LATOM   laItem;
    WORD    wFmt;
    WORD    wType;          // XTYP_ and XTYPF_ constants
    WORD    state;          // ADVST_ constant
} ADVISE_LINK, *PADVISE_LINK;

#define ADVST_WAITING   0x0080
#define ADVST_CHANGED   0x0040

// DDE message handling stuff -----------------------------------

typedef struct tagDDE_MESSAGE_QUEUE {
    struct tagDDE_MESSAGE_QUEUE    *next;
    struct tagCONV_INFO            *pcoi;
    UINT                            msg;
    LPARAM                          lParam;
} DDE_MESSAGE_QUEUE, *PDDE_MESSAGE_QUEUE;

// instance info stuff -------------------------------------------

typedef struct tagSERVER_LOOKUP {
    LATOM           laService;
    LATOM           laTopic;
    HWND            hwndServer;
} SERVER_LOOKUP, *PSERVER_LOOKUP;

typedef struct tagLINK_COUNT {
    struct tagLINK_COUNT *next;
    LATOM laTopic;
    GATOM gaItem;
    LATOM laItem;
    WORD  wFmt;
    short Total;
    short Count;
} LINK_COUNT;

typedef struct tagCL_INSTANCE_INFO {
    struct tagCL_INSTANCE_INFO *next;
    HANDLE                      hInstServer;
    HANDLE                      hInstClient;
    DWORD                       MonitorFlags;
    HWND                        hwndMother;
    HWND                        hwndEvent;
    HWND                        hwndTimeout;
    DWORD                       afCmd;
    PFNCALLBACK                 pfnCallback;
    DWORD                       LastError;
    DWORD                       tid;
    LATOM                      *plaNameService;
    WORD                        cNameServiceAlloc;
    PSERVER_LOOKUP              aServerLookup;
    short                       cServerLookupAlloc;
    WORD                        ConvStartupState;
    WORD                        flags;              // IIF_ flags
    short                       cInDDEMLCallback;
    PLINK_COUNT                 pLinkCount;
} CL_INSTANCE_INFO, *PCL_INSTANCE_INFO;

#define IIF_IN_SYNC_XACT    0x0001
#define IIF_UNICODE         0x8000

// conversation stuff ---------------------------------------------

typedef struct tagCONV_INFO {
    struct tagCONV_INFO    *next;
    PCL_INSTANCE_INFO       pcii;
    DWORD_PTR               hUser;
    HCONV                   hConv;
    LATOM                   laService;
    LATOM                   laTopic;
    HWND                    hwndPartner;
    HWND                    hwndConv;
    WORD                    state;                 // ST_ flags
    LATOM                   laServiceRequested;
    PXACT_INFO              pxiIn;
    PXACT_INFO              pxiOut;
    PDDE_MESSAGE_QUEUE      dmqIn;
    PDDE_MESSAGE_QUEUE      dmqOut;
    PADVISE_LINK            aLinks;
    int                     cLinks;
    int                     cLocks;
} CONV_INFO, *PCONV_INFO;

typedef struct tagCL_CONV_INFO {
    CONV_INFO               ci;
    HWND                    hwndReconnect;
    HCONVLIST               hConvList;
} CL_CONV_INFO, *PCL_CONV_INFO;

typedef struct tagSVR_CONV_INFO {
    CONV_INFO               ci;
} SVR_CONV_INFO, *PSVR_CONV_INFO;

typedef struct tagCONVLIST {
    int                     chwnd;      // number of client windows in this list
    HWND                    ahwnd[1];   // windows in list.
} CONVLIST, *PCONVLIST;

extern CONVCONTEXT DefConvContext;  // global from connect.c

typedef struct tagENABLE_ENUM_STRUCT{
    BOOL                   *pfRet;
    WORD                    wCmd;
    WORD                    wCmd2;
} ENABLE_ENUM_STRUCT, *PENABLE_ENUM_STRUCT;

// memory management stuff -------------------------------------

typedef struct tagDDEMLDATA {
    HANDLE  hDDE;                // Global data handle or data token
    DWORD   flags;               // See HDATA_ constants
} DDEMLDATA, *PDDEMLDATA;

// DDEML client side Globals -----------------------------------

extern PHANDLE aInstance;
extern DWORD gWM_REGISTERCALLBACK;

// prototypes --------------------------------------------------

// handles.c

HANDLE CreateHandle(ULONG_PTR dwData, DWORD type, DWORD  inst);
ULONG_PTR DestroyHandle(HANDLE h);
ULONG_PTR GetHandleData(HANDLE h);
VOID SetHandleData(HANDLE h, ULONG_PTR dwData);
ULONG_PTR ValidateCHandle(HANDLE h, DWORD ExpectedType, DWORD ExpectedInstance);
PCL_INSTANCE_INFO PciiFromHandle(HANDLE h);
HANDLE FindIstanceHandleFromHandle(HANDLE h);
VOID ApplyFunctionToObjects(DWORD ExpectedType, DWORD ExpectedInstance,
    PFNHANDLEAPPLY pfn);
VOID BestSetLastDDEMLError(DWORD error);

// clinit.c

BOOL RW_RegisterDDEML(void);

// ddemlcli.c

UINT InternalDdeInitialize(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd,
    BOOL fUnicode);
// DDEML API DdeInitializeA
// DDEML API DdeInitializeW
// DDEML API DdeUninitialize
// DDEML API DdeNameService
// DDEML API DdeGetLastError

// instance.c

HANDLE AddInstance(HANDLE hInst);
HANDLE DestroyInstance(HANDLE hInst);
PCL_INSTANCE_INFO ValidateInstance(HANDLE hInst);
BOOL CsClearSecurityForAck(HANDLE hInst, HWND hwndServer, HWND hwndClient);
VOID SetLastDDEMLError(PCL_INSTANCE_INFO pcii, DWORD error);

// hsz.c

HSZ InternalDdeCreateStringHandle(DWORD idInst, PVOID psz, int iCodePage);
// DDEML API DdeCreateStringHandleA
// DDEML API DdeCreateStringHandleW
DWORD InternalDdeQueryString(DWORD idInst, HSZ hsz, PVOID psz, DWORD cchMax,
    INT iCodePage);
// DDEML API DdeQueryStringA
// DDEML API DdeQueryStringW
// DDEML API DdeFreeStringHandle
// DDEML API DdeKeepStringHandle
// DDEML API DdeCmpStringHandles

DWORD ValidateHSZ(HSZ hsz);
LATOM MakeInstSpecificAtom(LATOM la, HWND hwnd);
HWND ParseInstSpecificAtom(LATOM la, LATOM *plaNormal);
GATOM LocalToGlobalAtom(LATOM la);
LATOM GlobalToLocalAtom(GATOM ga);
GATOM IncGlobalAtomCount(GATOM la);
LATOM IncLocalAtomCount(LATOM la);

// connect.c

// DDEML API DdeConnect
// DDEML API DdeConnectList
// DDEML API DdeReconnect
BOOL ValidateConnectParameters(HANDLE hInst, PCL_INSTANCE_INFO *ppcii,
    HSZ *phszService, HSZ hszTopic, LATOM *plaNormalSvcName,
    PCONVCONTEXT *ppCC, HWND *phwndTarget, HCONVLIST hConvList);
PCL_CONV_INFO ConnectConv(PCL_INSTANCE_INFO pcii, LATOM laService,
    LATOM laTopic, HWND hwndTarget, HWND hwndSkip,
    PCONVCONTEXT pCC, HCONVLIST hConvList, DWORD clst);
VOID SetCommonStateFlags(HWND hwndUs, HWND hwndThem, PWORD pwFlags);
// DDEML API DdeQueryNextServer
// DDEML API DdeDisconnect
// DDEML API DdeDisconnectList
VOID ShutdownConversation(PCONV_INFO pcoi, BOOL fMakeCallback);
VOID FreeConversationResources(PCONV_INFO pcoi);
BOOL WaitForZombieTerminate(HANDLE hData);

// xact.c

VOID GetConvContext(HWND hwnd, LONG *pl);
VOID SetConvContext(HWND hwnd, LONG *pl);
// DDEML API DdeClientTransaction
// DDEML API DdeQueryConvInfo
// DDEML API DdeSetUserHandle
// DDEML API DdeAbandonTransaction
BOOL
UpdateLinkIfChanged(
    PADVISE_LINK paLink,
    PXACT_INFO pxi,
    PCONV_INFO pcoi,
    PADVISE_LINK paLinkLast,
    PBOOL pfSwapped,
    DWORD cLinksToGo);

// DDEML API DdePostAdvise
VOID LinkTransaction(PXACT_INFO pxi);
VOID UnlinkTransaction(PXACT_INFO pxi);
BOOL ValidateTransaction(HCONV hConv, HANDLE hXact, PCONV_INFO *ppcoi,
    PXACT_INFO *ppxi);


// hdata.c

// DDEML API DdeCreateDataHandle
HDDEDATA InternalCreateDataHandle(PCL_INSTANCE_INFO pcii, LPBYTE pSrc, DWORD cb,
    DWORD cbOff, DWORD flags, WORD wStatus, WORD wFmt);
// DDEML API DdeAddData
// DDEML API DdeGetData
// DDEML API DdeAccessData
// DDEML API DdeUnaccessData
// DDEML API DdeFreeDataHandle
BOOL ApplyFreeDataHandle(HANDLE hData);
BOOL InternalFreeDataHandle(HDDEDATA hData, BOOL fIgnorefRelease);
VOID FreeDDEData(HANDLE hDDE, BOOL fIgnorefRelease, BOOL fFreeTruelyGlobalObjects);
HANDLE CopyDDEData(HANDLE hDDE, BOOL fExec);

// callback.c

HDDEDATA DoCallback(PCL_INSTANCE_INFO pcii, WORD wType, WORD wFmt, HCONV hConv,
    HSZ hsz1, HSZ hsz2, HDDEDATA hData, ULONG_PTR dw1, ULONG_PTR dw2);
DWORD _ClientEventCallback(PCL_INSTANCE_INFO pcii, PEVENT_PACKET pep);
// DDEML API DdeEnableCallback
BOOL SetEnableState(PCONV_INFO pcoi, UINT wCmd);
DWORD _ClientGetDDEHookData(UINT message, LPARAM lParam,
        PDDEML_MSG_HOOK_DATA pdmhd);
DWORD _ClientGetDDEFlags(HANDLE hClient, DWORD flags);
BOOL EnableEnumProc(HWND hwnd, PENABLE_ENUM_STRUCT pees);

// ddemlwp.c

LRESULT DDEMLMotherWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT DDEMLClientWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT DDEMLServerWndProc(HWND, UINT, WPARAM, LPARAM);
PCONV_INFO ProcessTerminateMsg(PCONV_INFO pcoi, HWND hwndFrom);
VOID ProcessAsyncDDEMsg(PCONV_INFO pcoi, UINT msg, HWND hwndFrom, LPARAM lParam);
BOOL CheckForQueuedMessages(PCONV_INFO pcoi);
VOID DumpDDEMessage(BOOL fFreeData, UINT msg, LPARAM lParam);
BOOL ProcessSyncDDEMessage(PCONV_INFO pcoi, UINT msg, LPARAM lParam);

// stdptcl.c

BOOL ClStartAdvise(PXACT_INFO pxi);
BOOL SvSpontAdvise(PSVR_CONV_INFO psi, LPARAM lParam);
BOOL ClRespAdviseAck(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL SvStartAdviseUpdate(PXACT_INFO pxi, DWORD cLinksToGo);
BOOL ClSpontAdviseData(PCL_CONV_INFO pci, LPARAM lParam);
BOOL SvRespAdviseDataAck(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL ClStartUnadvise(PXACT_INFO pxi);
BOOL SvSpontUnadvise(PSVR_CONV_INFO psi, LPARAM lParam);
BOOL ClRespUnadviseAck(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL ClStartExecute(PXACT_INFO pxi);
BOOL ClRespExecuteAck(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL ClStartPoke(PXACT_INFO pxi);
BOOL SvSpontPoke(PSVR_CONV_INFO psi, LPARAM lParam);
BOOL ClRespPokeAck(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL ClStartRequest(PXACT_INFO pxi);
BOOL SvSpontRequest(PSVR_CONV_INFO psi, LPARAM lParam);
BOOL ClRespRequestData(PXACT_INFO pxi, UINT msg, LPARAM lParam);
BOOL SpontaneousClientMessage(PCL_CONV_INFO pci, UINT msg, LPARAM lParam);
BOOL SpontaneousServerMessage(PSVR_CONV_INFO psi, UINT msg, LPARAM lParam);
HANDLE AllocAndSetDDEData(LPBYTE pSrc, DWORD cb, WORD wStatus, WORD wFmt);
DWORD PackAndPostMessage(HWND hwndTo, UINT msgIn, UINT msgOut, HWND hwndFrom,
    LPARAM lParam, UINT_PTR uiLo, UINT_PTR uiHi);
BOOL ExtractDDEDataInfo(HANDLE hDDE, LPWORD pwStatus, LPWORD pwFmt);
BOOL TransactionComplete(PXACT_INFO pxi, HDDEDATA hData);
HANDLE UnpackAndFreeDDEMLDataHandle(HDDEDATA hData, BOOL fExec);

// util.c

BOOL AddLink(PCONV_INFO pcoi, GATOM gaItem, WORD wFmt, WORD wType);
VOID DeleteLinkCount(PCL_INSTANCE_INFO pcii, PLINK_COUNT pLinkCountDelete);

// monitor.c

VOID MonitorStringHandle(PCL_INSTANCE_INFO pcii, HSZ hsz, DWORD fsAction);
VOID MonitorLink(PCL_INSTANCE_INFO pcii, BOOL fEstablished, BOOL fNoData,
        LATOM laSvc, LATOM laTopic, GATOM gaItem, WORD wFmt, BOOL fServer,
        HCONV hConvServer, HCONV hConvClient);
VOID MonitorConv(PCONV_INFO pcoi, BOOL fConnect);

// register.c

VOID RegisterService(BOOL fRegister, GATOM gaApp, HWND hwndListen);
LRESULT ProcessRegistrationMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\dlgmgr.c ===
/***************************************************************************\
*
*  DLGMGR.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Dialog Box Manager Routines
*
* ??-???-???? mikeke    Ported from Win 3.0 sources
* 12-Feb-1991 mikeke    Added Revalidation code
* 19-Feb-1991 JimA      Added access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define UNICODE_MINUS_SIGN 0x2212


LOOKASIDE DialogLookaside;

BOOL ValidateCallback(HANDLE h);

#define IsInForegroundQueue(hwnd) \
    (NtUserQueryWindow(hwnd, WindowIsForegroundThread) != NULL)
#define IsCurrentThreadForeground() \
    ((BOOL)NtUserGetThreadState(UserThreadStateIsForeground))

/***************************************************************************\
*
* GetParentDialog()
*
* Gets top level window, not a control parent.  If not a dialog, then use
* "highest" control parent guy.
*
* BOGUS
* Need a way to mark a window as a dialog.  If it ever comes into
* DefDlgProc(), set an internal flag.  Will be used by thunking and
* CallDlgProc() optimizations also!
*
\***************************************************************************/

PWND GetParentDialog(PWND pwndDialog)
{
    PWND    pwndParent;

    pwndParent = pwndDialog;

    //
    // Walk up the parent chain.  We're looking for the top-most dialog
    // window.  Most cases, the window is a top level one.  But in case of
    // backup app, the window will be a child of some other window.
    //
    for (; pwndDialog; pwndDialog = REBASEPWND(pwndDialog, spwndParent))
    {
        if (TestWF(pwndDialog, WFDIALOGWINDOW))
        {
            //
            // For old guys:  If not DS_RECURSE, then stop here.
            // that way old apps which try to do the nested dialog
            // stuff in their old limited way don't die.
            //
            if (TestWF(pwndDialog, WEFCONTROLPARENT))
                pwndParent = pwndDialog;
            else if (!TestWF(pwndDialog, DFCONTROL))
                break;
        }

        if (!TestWF(pwndDialog, WFCHILD))
            break;
    }

    return(pwndParent);
}

/***************************************************************************\
* xxxSaveDlgFocus
*
* History:
* 02-18-92 JimA             Ported from Win31 sources
\***************************************************************************/

BOOL xxxSaveDlgFocus(
    PWND pwnd)
{
    HWND hwndFocus = GetFocus();

    CheckLock(pwnd);

    if (hwndFocus != NULL && IsChild(HWq(pwnd), hwndFocus) &&
            PDLG(pwnd)->hwndFocusSave == NULL) {
        PDLG(pwnd)->hwndFocusSave = hwndFocus;
        xxxRemoveDefaultButton(pwnd, ValidateHwnd(hwndFocus));
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
* xxxRestoreDlgFocus
*
* History:
* 02-18-92 JimA             Ported from Win31 sources
* 01-01-2001 Mohamed        Need to re-validate the window before cleanup.
\***************************************************************************/

// LATER
// 21-Mar-1992 mikeke
// does pwndFocusSave need to be unlocked when the dialog is destroyed?

BOOL xxxRestoreDlgFocus(
    PWND pwnd)
{
    HWND hwndFocus;
    HWND hwndFocusSave;
    BOOL fRestored = FALSE;

    CheckLock(pwnd);
    

    if (PDLG(pwnd)->hwndFocusSave && !TestWF(pwnd, WFMINIMIZED)) {

        hwndFocus = GetFocus();
        hwndFocusSave = KHWND_TO_HWND(PDLG(pwnd)->hwndFocusSave);

        if (IsWindow(hwndFocusSave)) {
            xxxCheckDefPushButton(pwnd, hwndFocus, hwndFocusSave);
            fRestored = (NtUserSetFocus(hwndFocusSave) != NULL);
        }
            //
            // After calling SetFocus(), we need to re-validate
            // the window. PDLG(pwnd) might be NULL.
            //

        if (ValidateDialogPwnd(pwnd)) {
            PDLG(pwnd)->hwndFocusSave = NULL;
        }
    }

    return fRestored;
}


/***************************************************************************\
* DlgSetFocus
*
* History:
\***************************************************************************/

void DlgSetFocus(
    HWND hwnd)
{
    if (((UINT)SendMessage(hwnd, WM_GETDLGCODE, 0, 0)) & DLGC_HASSETSEL) {
        SendMessage(hwnd, EM_SETSEL, 0, MAXLONG);
    }

    NtUserSetFocus(hwnd);
}



FUNCLOG1(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetDlgCtrlID, HWND, hwnd)
int GetDlgCtrlID(
    HWND hwnd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL)
        return 0;

    return PtrToLong(pwnd->spmenu);
}



/***************************************************************************\
* ValidateDialogPwnd
*
* Under Win3, DLGWINDOWEXTRA is 30 bytes. We cannot change that for 16 bit
* compatibility reasons. Problem is there is no way to tell if a given
* 16 bit window depends on byte count. If there was, this would be easy.
* The only way to tell is when a window is about to be used as a dialog
* window. This window may be of the class DIALOGCLASS, but again it may
* not!! So we keep dialog window words at 30 bytes, and allocate another
* structure for the real dialog structure fields. Problem is that this
* structure has to be created lazily! And that's what we're doing here.
*
* 05-21-91 ScottLu      Created.
\***************************************************************************/

BOOL ValidateDialogPwnd(
    PWND pwnd)
{
    static BOOL sfInit = TRUE;
    PDLG pdlg;

    /*
     * This bit is set if we've already run through this initialization and
     * have identified this window as a dialog window (able to withstand
     * peeks into window words at random moments in time).
     */
    if (TestWF(pwnd, WFDIALOGWINDOW))
        return TRUE;

    if (pwnd->cbwndExtra < DLGWINDOWEXTRA) {
        RIPERR0(ERROR_WINDOW_NOT_DIALOG, RIP_VERBOSE, "");
        return FALSE;
    }

    /*
     * See if the pdlg was destroyed and this is a rogue message to be ignored
     */
    if (pwnd->fnid & FNID_STATUS_BITS) {
        return FALSE;
    }

    /*
     * If the lookaside buffer has not been initialized, do it now.
     */
    if (sfInit) {
        if (!NT_SUCCESS(InitLookaside(&DialogLookaside, sizeof(DLG), 2))) {
            return FALSE;
        }
        sfInit = FALSE;
    }

    if ((pdlg = (PDLG)AllocLookasideEntry(&DialogLookaside)) == NULL) {
        return FALSE;
    }

    NtUserCallHwndParam(HWq(pwnd), (ULONG_PTR)pdlg, SFI_SETDIALOGPOINTER);

    return TRUE;
}


/***************************************************************************\
* CvtDec
*
* LATER!!! convert to itoa?
*
* History:
\***************************************************************************/

void CvtDec(
    int u,
    LPWSTR *lplpch)
{
    if (u >= 10) {
        CvtDec(u / 10, lplpch);
        u %= 10;
    }

    *(*lplpch)++ = (WCHAR)(u + '0');
}


/***************************************************************************\
* SetDlgItemInt
*
* History:
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetDlgItemInt, HWND, hwnd, int, item, UINT, u, BOOL, fSigned)
BOOL SetDlgItemInt(
    HWND hwnd,
    int item,
    UINT u,
    BOOL fSigned)
{
    LPWSTR lpch;
    WCHAR rgch[16];

    lpch = rgch;
    if (fSigned) {
        if ((int)u < 0) {
            *lpch++ = TEXT('-');
            u = (UINT)(-(int)u);
        }
    } else {
        if (u & 0x80000000) {
            CvtDec(u / 10, (LPWSTR FAR *)&lpch);
            u = u % 10;
        }
    }

    CvtDec(u, (LPWSTR FAR *)&lpch);
    *lpch = 0;

    return SetDlgItemTextW(hwnd, item, rgch);
}


/***************************************************************************\
* CheckDlgButton
*
* History:
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CheckDlgButton, HWND, hwnd, int, id, UINT, cmdCheck)
BOOL CheckDlgButton(
    HWND hwnd,
    int id,
    UINT cmdCheck)
{
    if ((hwnd = GetDlgItem(hwnd, id)) == NULL) {
        return FALSE;
    }

    SendMessage(hwnd, BM_SETCHECK, cmdCheck, 0);

    return TRUE;
}

/***************************************************************************\
* GetDlgItemInt
*
* History:
\***************************************************************************/

UINT GetDlgItemInt(
    HWND hwnd,
    int item,
    BOOL FAR *lpfValOK,
    BOOL fSigned)
{
    int i, digit, ch;
    int maxTens, maxUnits;
    BOOL fOk, fNeg;
    LPWSTR lpch;
    WCHAR rgch[48];
    WCHAR rgchDigits[48];

    fOk = FALSE;
    if (lpfValOK != NULL)
        *lpfValOK = FALSE;

    if (!GetDlgItemTextW(hwnd, item, rgch, sizeof(rgch)/sizeof(WCHAR) - 1))
        return 0;

    lpch = rgch;

    /*
     * Skip leading white space.
     */
    while (*lpch == TEXT(' '))
        lpch++;

    fNeg = FALSE;
    while (fSigned && ((*lpch == L'-') || (*lpch == UNICODE_MINUS_SIGN))) {
        lpch++;
        fNeg ^= TRUE;
    }

    if (fSigned) {
        maxTens = INT_MAX/10;
        maxUnits = INT_MAX%10;
    } else {
        maxTens = UINT_MAX/10;
        maxUnits = UINT_MAX%10;
    }
    /*
     * Convert all decimal digits to ASCII Unicode digits 0x0030 - 0x0039
     */
    FoldStringW(MAP_FOLDDIGITS, lpch, -1, rgchDigits,
            sizeof(rgchDigits)/sizeof(rgchDigits[0]));
    lpch = rgchDigits;

    i = 0;
    while (ch = *lpch++) {
        digit = ch - TEXT('0');
        if (digit < 0 || digit > 9) {
            break;
        }
        if ((UINT)i >= (UINT)maxTens) {
            /*
             * We need to special case INT_MIN as the i = -i
             * would damage it
             */
            if (i == maxTens) {
                if (digit == maxUnits+1 && fNeg && (*lpch) == 0) {
                    i = INT_MIN;
                    goto HaveResult;
                } else if (digit > maxUnits) {
                    return 0;
                }
            } else {
                return 0;
            }
        }
        fOk = TRUE;
        i = ((UINT)i * 10) + digit;
    }

    if (fNeg)
        i = -i;
HaveResult:
    if (lpfValOK != NULL)
        *lpfValOK = ((ch == 0) && fOk);

    return (UINT)i;
}

/***************************************************************************\
* CheckRadioButton
*
* History:
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CheckRadioButton, HWND, hwnd, int, idFirst, int, idLast, int, id)
BOOL CheckRadioButton(
    HWND hwnd,
    int idFirst,
    int idLast,
    int id)
{
    PWND pwnd, pwndDialog;
    BOOL    fCheckOn;

    pwndDialog = ValidateHwnd(hwnd);
    if (pwndDialog == NULL)
        return 0;

    for (pwnd = REBASE(pwndDialog, spwndChild); pwnd; pwnd = REBASE(pwnd, spwndNext)) {

        if ((PtrToLong(pwnd->spmenu) >= idFirst) &&
            (PtrToLong(pwnd->spmenu) <= idLast)) {

            fCheckOn = (PtrToLong(pwnd->spmenu) == id);
            SendMessage(PtoHq(pwnd), BM_SETCHECK, fCheckOn, 0L);
        }
    }

    return TRUE;
}


/***************************************************************************\
* IsDlgButtonChecked
*
* History:
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, IsDlgButtonChecked, HWND, hwnd, int, id)
UINT IsDlgButtonChecked(
    HWND hwnd,
    int id)
{
    if ((hwnd = GetDlgItem(hwnd, id)) != NULL) {
        return (UINT)SendMessage(hwnd, BM_GETCHECK, 0, 0);
    }

    return FALSE;
}


/***************************************************************************\
* DefDlgProc
*
* History:
\***************************************************************************/

LRESULT DefDlgProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    TL tlpwndT1, tlpwndT2, tlpwndT3, tlpwndTop;
    PWND pwndT;
    PWND pwndT1, pwndT2, pwndT3, pwndTop;
    HWND hwndT1;
    LRESULT result;
    BOOL fSetBit;
    DLGPROC pfn;

    CheckLock(pwnd);

    /*
     * use the Win 3.1 documented size
     */
    VALIDATECLASSANDSIZE(pwnd, FNID_DIALOG);

    /*
     * Must do special validation here to make sure pwnd is a dialog window.
     */
    if (!ValidateDialogPwnd(pwnd))
        return 0;

    if (((PDIALOG)pwnd)->resultWP != 0)
        NtUserSetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0, FALSE);
    result = 0;   // no dialog proc

    if (message == WM_FINALDESTROY) {
        goto DoCleanup;
    }

    if ((pfn = PDLG(pwnd)->lpfnDlg) != NULL) {
        /* Bug 234292 - joejo
         * Since the called window/dialog proc may have a different calling
         * convention, we must wrap the call and, check esp and replace with
         * a good esp when the call returns. This is what UserCallWinProc* does.
        */
        if (UserCallDlgProcCheckWow(pwnd->pActCtx, pfn, hwnd, message, wParam, lParam, &(pwnd->state), &result)) {
            return result;
        }

        /*
         * Get out if the window was destroyed in the dialog proc.
         */
        if ((RevalidateHwnd(hwnd)==NULL) || (pwnd->fnid & FNID_STATUS_BITS))
            return result;
    }

    /*
     * SPECIAL CASED ... and DOCUMENTED that way !!!
     * These 6, and ONLY these 6, should be hacked in this fashion.
     * Anybody who needs the REAL return value to a message should
     * use SetDlgMsgResult in WINDOWSX.H
     */

    switch (message)
    {
        case WM_COMPAREITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_INITDIALOG:
        case WM_QUERYDRAGICON:
            return ((LRESULT)(DWORD)result);

        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
            // QuarkXPress doesn't like finding the WM_CTLCOLOR result in
            // resultWP -- we should never be setting resultWP -- that's meant
            // as a pass-thru return value -- so let's go back to doing it the
            // old way -- Win95B B#21269 -- 03/13/95 -- tracysh (cr: jeffbog)
            if (result)
                return result;
            break;
    }

    if (!result) {

        /*
         * Save the result value in case our private memory is freed
         * before we return
         */
//        result = PDLG(pwnd)->resultWP;

        switch (message) {
        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        {
            //
            // HACK OF DEATH:
            // To get 3D colors for non 4.0 apps who use 3DLOOK,
            // we temporarily add on the 4.0 compat bit, pass this
            // down to DWP, and clear it.
            //
            // Use "result" var for bool saying we have to add/clear 4.0
            // compat bit.

            fSetBit = (TestWF(pwnd, DF3DLOOK)!= 0) &&
                     (TestWF(pwnd, WFWIN40COMPAT) == 0);

            if (fSetBit)
                SetWindowState(pwnd, WFWIN40COMPAT);

            result = DefWindowProcWorker(pwnd, message,
                    wParam, lParam, fAnsi);

            if (fSetBit)
                ClearWindowState(pwnd, WFWIN40COMPAT);
            return result;
        }

        case WM_ERASEBKGND:
            FillWindow(hwnd, hwnd, (HDC)wParam, (HBRUSH)CTLCOLOR_DLG);
            return TRUE;

        case WM_SHOWWINDOW:

            /*
             * If hiding the window, save the focus.  If showing the window
             * by means of a SW_* command and the fEnd bit is set, do not
             * pass to DWP so it won't get shown.
             */
            if (GetParentDialog(pwnd) == pwnd) {
                if (!wParam) {
                    xxxSaveDlgFocus(pwnd);
                } else {

                    if (LOWORD(lParam) != 0 && PDLG(pwnd)->fEnd)
                        break;

                    /*
                     * Snap the cursor to the center of the default button.
                     * Only do this if the current thread is in the foreground.
                     * The _ShowCursor() code is added to work around a
                     * problem with hardware cursors.  If change is done
                     * in the same refresh cycle, the display of the cursor
                     * would not reflect the new position.
                     */
                    if (TEST_PUSIF(PUSIF_SNAPTO) &&
                            IsInForegroundQueue(hwnd)) {
                        hwndT1 = GetDlgItem(hwnd, (int)PDLG(pwnd)->result);
                        if (hwndT1) {
                            RECT rc;

                            NtUserShowCursor(FALSE);

                            GetWindowRect(hwndT1, &rc);
                            NtUserSetCursorPos(rc.left + ((rc.right - rc.left)/2),
                                         rc.top + ((rc.bottom - rc.top)/2));

                            NtUserShowCursor(TRUE);
                        }
                    }
                }
            }
            goto CallDWP;

        case WM_SYSCOMMAND:
            if (GetParentDialog(pwnd) == pwnd) {
                /*
                 * If hiding the window, save the focus.  If showing the window
                 * by means of a SW_* command and the fEnd bit is set, do not
                 * pass to DWP so it won't get shown.
                 */
                if ((int)wParam == SC_MINIMIZE)
                    xxxSaveDlgFocus(pwnd);
            }
            goto CallDWP;

        case WM_ACTIVATE:
            pwndT1 = GetParentDialog(pwnd);
            if ( pwndT1 != pwnd) {

                /*
                 * This random bit is used during key processing - bit
                 * 08000000 of WM_CHAR messages is set if a dialog is currently
                 * active.
                 */
                NtUserSetThreadState(wParam ? QF_DIALOGACTIVE : 0, QF_DIALOGACTIVE);
            }

            ThreadLock(pwndT1, &tlpwndT1);
            if (wParam != 0)
                xxxRestoreDlgFocus(pwndT1);
            else
                xxxSaveDlgFocus(pwndT1);

            ThreadUnlock(&tlpwndT1);
            break;

        case WM_SETFOCUS:
            pwndT1 = GetParentDialog(pwnd);
            if (!PDLG(pwndT1)->fEnd && !xxxRestoreDlgFocus(pwndT1)) {

                pwndT = _GetNextDlgTabItem(pwndT1, NULL, FALSE);
                DlgSetFocus(HW(pwndT));
            }
            break;

        case WM_CLOSE:
            /*
             * Make sure cancel button is not disabled before sending the
             * IDCANCEL.  Note that we need to do this as a message instead
             * of directly calling the dlg proc so that any dialog box
             * filters get this.
             */
            pwndT1 = _GetDlgItem(pwnd, IDCANCEL);
            if (pwndT1 && TestWF(pwndT1, WFDISABLED))
                NtUserMessageBeep(0);
            else
                PostMessage(hwnd, WM_COMMAND, MAKELONG(IDCANCEL, BN_CLICKED),
                        (LPARAM)HW(pwndT1));
            break;

        case WM_NCDESTROY:
        case WM_FINALDESTROY:
DoCleanup:
            NtUserSetThreadState(0, QF_DIALOGACTIVE);
            if (!(pwnd->style & DS_LOCALEDIT)) {
                if (PDLG(pwnd)->hData) {
                    ReleaseEditDS(KHANDLE_TO_HANDLE(PDLG(pwnd)->hData));
                    PDLG(pwnd)->hData = NULL;
                }
            }

            /*
             * Delete the user defined font if any
             */
            if (PDLG(pwnd)->hUserFont) {
                DeleteObject(KHFONT_TO_HFONT(PDLG(pwnd)->hUserFont));
                PDLG(pwnd)->hUserFont = NULL;
            }

            /*
             * Free the dialog memory and mark this as a non-dialog window
             */
            FreeLookasideEntry(&DialogLookaside, KPVOID_TO_PVOID(PDLG(pwnd)));
            NtUserCallHwndParam(hwnd, 0, SFI_SETDIALOGPOINTER);
            break;

        case DM_REPOSITION:
            {
                RECT        rc;
                PMONITOR    pMonitor;

                // DAT recorder APP sends it's own private message 0x402
                // through and we mistake it to be DM_REPOSITION. To avoid
                // this confusion, we do the following check.
                // Fix for Bug#25747 -- 9/29/94 --
                if (!TestWF(pwnd, WEFCONTROLPARENT) ||
                    (GETFNID(pwnd) != FNID_DESKTOP &&
                     GETFNID(REBASEPWND(pwnd, spwndParent)) != FNID_DESKTOP)) {

                    goto CallDWP;
                }

                CopyRect(&rc, KPRECT_TO_PRECT(&pwnd->rcWindow));
                pMonitor = _MonitorFromRect(&rc, MONITOR_DEFAULTTOPRIMARY);
                RepositionRect(pMonitor, &rc, pwnd->style, pwnd->ExStyle);
                NtUserSetWindowPos(hwnd, HWND_TOP, rc.left, rc.top,
                             rc.right-rc.left, rc.bottom-rc.top,
                             SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
            }
            break;

        case DM_SETDEFID:
            pwndT1 = GetParentDialog(pwnd);
            ThreadLock(pwndT1, &tlpwndT1);

            if (!(PDLG(pwndT1)->fEnd)) {

                pwndT2 = NULL;
                if (PDLG(pwndT1)->result != 0)
                    pwndT2 = _FindDlgItem(pwndT1, (int)PDLG(pwndT1)->result);

                pwndT3 = NULL;
                if (wParam != 0) {
                    pwndT3 = _GetDlgItem(pwnd, (UINT)wParam);
                }

                ThreadLock(pwndT2, &tlpwndT2);
                ThreadLock(pwndT3, &tlpwndT3);

                xxxCheckDefPushButton(pwndT1, HW(pwndT2), HW(pwndT3));

                ThreadUnlock(&tlpwndT3);
                ThreadUnlock(&tlpwndT2);

                PDLG(pwndT1)->result = (UINT)wParam;
//                if (PDLG(pwnd)->spwndFocusSave) {
//                    Lock(&(PDLG(pwnd)->spwndFocusSave), pwndT2);
//                }

                NotifyWinEvent(EVENT_OBJECT_DEFACTIONCHANGE, HW(pwndT1), OBJID_CLIENT, INDEXID_CONTAINER);
            }
            ThreadUnlock(&tlpwndT1);
            return TRUE;

        case DM_GETDEFID:
            pwndT1 = GetParentDialog(pwnd);

            if (!PDLG(pwndT1)->fEnd && PDLG(pwndT1)->result)
                return(MAKELONG(PDLG(pwndT1)->result, DC_HASDEFID));
            else
                return 0;
            break;

        /*
         * This message was added so that user defined controls that want
         * tab keys can pass the tab off to the next/previous control in the
         * dialog box.  Without this, all they could do was set the focus
         * which didn't do the default button stuff.
         */
        case WM_NEXTDLGCTL:
            pwndTop = GetParentDialog(pwnd);
            ThreadLock(pwndTop, &tlpwndTop);

            hwndT1 = GetFocus();
            pwndT2 = ValidateHwndNoRip(hwndT1);
            if (LOWORD(lParam)) {
                if (pwndT2 == NULL)
                    pwndT2 = pwndTop;

                /*
                 * wParam contains the pwnd of the ctl to set focus to.
                 */
                if ((pwndT1 = ValidateHwnd((HWND)wParam)) == NULL) {
                    ThreadUnlock(&tlpwndTop);
                    return TRUE;
                }
            } else {
                if (pwndT2 == NULL) {

                    /*
                     * Set focus to the first tab item.
                     */
                    pwndT1 = _GetNextDlgTabItem(pwndTop, NULL, FALSE);
                    pwndT2 = pwndTop;
                } else {

                    /*
                     * If window with focus not a dlg ctl, ignore message.
                     */
                    if (!_IsChild(pwndTop, pwndT2)) {
                        ThreadUnlock(&tlpwndTop);
                        return TRUE;
                    }
                    /*
                     * wParam = TRUE for previous, FALSE for next
                     */
                    pwndT1 = _GetNextDlgTabItem(pwndTop, pwndT2, (wParam != 0));

                    /*
                     * If there is no next item, ignore the message.
                     */
                    if (pwndT1 == NULL) {
                        ThreadUnlock(&tlpwndTop);
                        return TRUE;
                    }
                }
            }

            ThreadLock(pwndT1, &tlpwndT1);
            ThreadLock(pwndT2, &tlpwndT2);

            DlgSetFocus(HW(pwndT1));
            xxxCheckDefPushButton(pwndTop, HW(pwndT2), HW(pwndT1));

            ThreadUnlock(&tlpwndT2);
            ThreadUnlock(&tlpwndT1);
            ThreadUnlock(&tlpwndTop);

            return TRUE;

        case WM_ENTERMENULOOP:

            /*
             * We need to pop up the combo box window if the user brings
             * down a menu.
             *
             * ...  FALL THROUGH...
             */

        case WM_LBUTTONDOWN:
        case WM_NCLBUTTONDOWN:
            hwndT1 = GetFocus();
            if (hwndT1 != NULL) {
                pwndT1 = ValidateHwndNoRip(hwndT1);

                if (GETFNID(pwndT1) == FNID_COMBOBOX) {

                    /*
                     * If user clicks anywhere in dialog box and a combo box (or
                     * the editcontrol of a combo box) has the focus, then hide
                     * it's listbox.
                     */
                    ThreadLockAlways(pwndT1, &tlpwndT1);
                    SendMessage(HWq(pwndT1), CB_SHOWDROPDOWN, FALSE, 0);
                    ThreadUnlock(&tlpwndT1);

                } else {
                    PWND pwndParent;

                    /*
                     * It's a subclassed combo box.  See if the listbox and edit
                     * boxes exist (this is a very cheezy evaluation - what if
                     * these controls are subclassed too? NOTE: Not checking
                     * for EditWndProc: it's a client proc address.
                     */
                    pwndParent = REBASEPWND(pwndT1, spwndParent);
                    if (GETFNID(pwndParent) == FNID_COMBOBOX) {
                        pwndT1 = pwndParent;
                        ThreadLock(pwndT1, &tlpwndT1);
                        SendMessage(HWq(pwndT1), CB_SHOWDROPDOWN, FALSE, 0);
                        ThreadUnlock(&tlpwndT1);
                    }
                }
            }

            /*
             * Always send the message off to DefWndProc
             */
            goto CallDWP;

        case WM_GETFONT:
            return (LRESULT)PDLG(pwnd)->hUserFont;

        case WM_VKEYTOITEM:
        case WM_COMPAREITEM:
        case WM_CHARTOITEM:
        case WM_INITDIALOG:

            /*
             * We need to return the 0 the app may have returned for these
             * items instead of calling defwindow proc.
             */
            return result;

        case WM_NOTIFYFORMAT:
            if (lParam == NF_QUERY)
                return((PDLG(pwnd)->flags & DLGF_ANSI ) ? NFR_ANSI : NFR_UNICODE);
            return result;

        case WM_INPUTLANGCHANGEREQUEST:
            if (IS_IME_ENABLED()) {
                /*
                 * #115190
                 * For dialogbox itself, buttons/static controls on top of
                 * dialogbox, we'll simply discard this message. B#3843-win95c
                 */
                break;
            }
            if (PDLG(pwnd)->lpfnDlg == MB_DlgProc) {
                break;
            }
            goto CallDWP;

        default:
CallDWP:
            return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
        }
    } else if ((message == WM_SHOWWINDOW) && result) {

        /*
         * For a visible-case we want to snap the cursor regardless of
         * what was returned from the dialog-handler on the client.  If
         * we're going visible, snap the cursor to the dialog-button.
         */
        if (GetParentDialog(pwnd) == pwnd) {

            if (wParam && ((LOWORD(lParam) == 0) || !PDLG(pwnd)->fEnd)) {

                /*
                 * Snap the cursor to the center of the default button.
                 * Only do this if the current thread is in the foreground.
                 * The _ShowCursor() code is added to work around a
                 * problem with hardware cursors.  If change is done
                 * in the same refresh cycle, the display of the cursor
                 * would not reflect the new position.
                 */
                if (TEST_PUSIF(PUSIF_SNAPTO) &&
                        IsInForegroundQueue(hwnd)) {
                    hwndT1 = GetDlgItem(hwnd, (int)PDLG(pwnd)->result);
                    if (hwndT1) {
                        RECT rc;

                        NtUserShowCursor(FALSE);

                        GetWindowRect(hwndT1, &rc);
                        NtUserSetCursorPos(rc.left + ((rc.right - rc.left)/2),
                                     rc.top + ((rc.bottom - rc.top)/2));

                        NtUserShowCursor(TRUE);
                    }
                }
            }
        }
    }


    /*
     * If this is still marked as a dialog window then return the real
     * result. Otherwise, we've already processed the WM_NCDESTROY message
     * and freed our private memory so return the stored value.
     */
    if (TestWF(pwnd, WFDIALOGWINDOW))
        return KERNEL_LRESULT_TO_LRESULT(((PDIALOG)pwnd)->resultWP);
    else
        return result;
}


/***************************************************************************\
* DefDlgProc
*
* Translates the message, calls DefDlgProc on server side.  DefDlgProc
* is the default WindowProc for dialogs (NOT the dialog's dialog proc)
*
* 04-11-91 ScottLu Created.
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, LRESULT, WINAPI, DefDlgProcW, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefDlgProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    return DefDlgProcWorker(pwnd, message, wParam, lParam, FALSE);
}


FUNCLOG4(LOG_GENERAL, LRESULT, WINAPI, DefDlgProcA, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefDlgProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    return DefDlgProcWorker(pwnd, message, wParam, lParam, TRUE);
}


/***************************************************************************\
* DialogBox2
*
* History:
\***************************************************************************/

INT_PTR DialogBox2(
    HWND hwnd,
    HWND hwndOwner,
    BOOL fDisabled,
    BOOL fOwnerIsActiveWindow)
{
    MSG msg;
    INT_PTR result;
    BOOL fShown;
    BOOL fWantIdleMsgs;
    BOOL fSentIdleMessage = FALSE;
    HWND hwndCapture;
    PWND pwnd;

    if (hwnd) {
        pwnd = ValidateHwnd(hwnd);
    } else {
        pwnd = NULL;
    }

    CheckLock(pwnd);

    if (pwnd == NULL) {
        if ((hwndOwner != NULL) && !fDisabled && IsWindow(hwndOwner)) {
            NtUserEnableWindow(hwndOwner, TRUE);
            if (fOwnerIsActiveWindow) {

                /*
                 * The dialog box failed but we disabled the owner in
                 * xxxDialogBoxIndirectParam and if it had the focus, the
                 * focus was set to NULL.  Now, when we enable the window, it
                 * doesn't get the focus back if it had it previously so we
                 * need to correct this.
                 */
                NtUserSetFocus(hwndOwner);
            }
        }
        return -1;
    }

    hwndCapture = GetCapture();
    if (hwndCapture != NULL) {
        SendMessage(hwndCapture, WM_CANCELMODE, 0, 0);
    }

    /*
     * Set the 'parent disabled' flag for EndDialog().
     * convert BOOL to definite bit 0 or 1
     */
    PDLG(pwnd)->fDisabled = !!fDisabled;

    fShown = TestWF(pwnd, WFVISIBLE);

    /*
     * Should the WM_ENTERIDLE messages be sent?
     */
    fWantIdleMsgs = !(pwnd->style & DS_NOIDLEMSG);

    if ((SYSMET(SLOWMACHINE) & 1) && !fShown && !PDLG(pwnd)->fEnd)
        goto ShowIt;

    while (PDLG(pwnd) && (!PDLG(pwnd)->fEnd)) {
        if (!PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
ShowIt:
            if (!fShown) {
                fShown = TRUE;

#ifdef SYSMODALWINDOWS
                if (pwnd == gspwndSysModal) {
                    /*
                     * Make this a topmost window
                     */
                    NtUserSetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0,
                               SWP_NOSIZE | SWP_NOMOVE |
                               SWP_NOREDRAW | SWP_NOACTIVATE);
                }
#endif

                NtUserShowWindow(hwnd, SHOW_OPENWINDOW);
                UpdateWindow(hwnd);

                NotifyWinEvent(EVENT_SYSTEM_DIALOGSTART, hwnd, OBJID_WINDOW, INDEXID_CONTAINER);
            } else {
                /*
                 * Make sure window still exists
                 */
                if (hwndOwner && !IsWindow(hwndOwner))
                    hwndOwner = NULL;

                if (hwndOwner && fWantIdleMsgs && !fSentIdleMessage) {
                    fSentIdleMessage = TRUE;

                    SendMessage(hwndOwner, WM_ENTERIDLE, MSGF_DIALOGBOX, (LPARAM)hwnd);
                } else {
                    if ((RevalidateHwnd(hwnd)==NULL) || (pwnd->fnid & FNID_STATUS_BITS))
                        break;

                    NtUserWaitMessage();
                }
            }

        } else {
            /*
             * We got a real message.  Reset fSentIdleMessage so that we send
             * one next time things are calm.
             */
            fSentIdleMessage = FALSE;

            if (msg.message == WM_QUIT) {
                PostQuitMessage((int)msg.wParam);
                break;
            }

            /*
             * If pwnd is a message box, allow Ctrl-C and Ctrl-Ins
             * to copy its content to the clipboard.
             * Fall through in case hooking apps look for these keys.
             */
            if (TestWF(pwnd, WFMSGBOX)) {
                if ( (msg.message == WM_CHAR && LOBYTE(msg.wParam) == 3) ||
                     (msg.message == WM_KEYDOWN && LOBYTE(msg.wParam) == VK_INSERT && GetKeyState(VK_CONTROL) < 0)) {
                        /*
                         * Send the WM_COPY message and let the original message fall through
                         * as some apps might want it
                         */
                        SendMessage(hwnd, WM_COPY, 0, 0);
                }
            }

            /*
             * Moved the msg filter hook call to IsDialogMessage to allow
             * messages to be hooked for both modal and modeless dialog
             * boxes.
             */
            if (!IsDialogMessage(hwnd, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            /*
             * If we get a timer message, go ahead and show the window.
             * We may continuously get timer msgs if there are zillions of
             * apps running.
             *
             * If we get a syskeydown message, show the dialog box because
             * the user may be bringing down a menu and we want the dialog
             * box to become visible.
             */
            if (!fShown && (msg.message == WM_TIMER ||
                    msg.message == WM_SYSTIMER || msg.message == WM_SYSKEYDOWN))
                goto ShowIt;
        }

        if (!RevalidateHwnd(hwnd)) {
            /*
             * Bogus case - we've already been destroyed somehow (by app,
             * GP, etc.)
             */
            RIPMSG0(RIP_WARNING,
               "Dialog should be dismissed with EndDialog, not DestroyWindow");
            break;
        }
    }

    NotifyWinEvent(EVENT_SYSTEM_DIALOGEND, hwnd, OBJID_WINDOW, INDEXID_CONTAINER);

    /*
     * Make sure the window still exists
     */
    if (!RevalidateHwnd(hwnd)) {
        return 0;
    }

    if (PDLG(pwnd))
        result = KERNEL_INT_PTR_TO_INT_PTR(PDLG(pwnd)->result);
    else
        result = 0;

    NtUserDestroyWindow(hwnd);

    /*
     * If the owner window belongs to another thread, the reactivation
     * of the owner may have failed within DestroyWindow().  Therefore,
     * if the current thread is in the foreground and the owner is not
     * in the foreground we can safely set the foreground back
     * to the owner.
     */
    if (hwndOwner != NULL) {
        if (IsCurrentThreadForeground() &&
            !IsInForegroundQueue(hwndOwner)) {
            NtUserSetForegroundWindow(hwndOwner);
        }
    }

    return result;
}


/***************************************************************************\
* InternalDialogBox
*
* Server portion of DialogBoxIndirectParam.
*
* 04-05-91 ScottLu      Created.
\***************************************************************************/

INT_PTR InternalDialogBox(
    HANDLE hModule,
    LPDLGTEMPLATE lpdt,
    HWND hwndOwner,
    DLGPROC pfnDialog,
    LPARAM lParam,
    UINT fSCDLGFlags)
{
    INT_PTR i;
    BOOL fDisabled = FALSE;
    HWND hwnd;
    PWND pwndOwner;
    BOOL fOwnerIsActiveWindow = FALSE;
    TL tlpwndOwner;
    BOOL fUnlockOwner;

    UserAssert(!(fSCDLGFlags & ~(SCDLG_CLIENT|SCDLG_ANSI|SCDLG_16BIT)));    // These are the only valid flags

    /*
     * If hwndOwner == HWNDESKTOP, change it to NULL.  This way the desktop
     * (and all its children) won't be disabled if the dialog is modal.
     */
    if (hwndOwner && SAMEWOWHANDLE(hwndOwner, GetDesktopWindow()))
        hwndOwner = NULL;

    /*
     * We return 0 if the ValidateHwnd fails in order to match Win 3.1
     * validation layer which always returns 0 for invalid hwnds even
     * if the function is spec'ed to return -1.  Autocad setup bug #3615
     */
    if (hwndOwner) {
        if ((pwndOwner = ValidateHwnd(hwndOwner)) == NULL) {
            return (0L);
        }
    } else {
        pwndOwner = NULL;
    }

    CheckLock(pwndOwner);

    fUnlockOwner = FALSE;
    if (pwndOwner != NULL) {

        /* The following fixes an AV in Corel Photo-Paint 6.0.  It passes a
         * 16-bit HWND in, and croaks at some point when it gets 16-bit hwnds
         * back in send messages. FritzS -- fixing bug 12531
         */
        hwndOwner = PtoHq(pwndOwner);

        /*
         * Make sure the owner is a top level window.
         */
        if (TestwndChild(pwndOwner)) {
            pwndOwner = GetTopLevelWindow(pwndOwner);
            hwndOwner = HWq(pwndOwner);
            ThreadLock(pwndOwner, &tlpwndOwner);
            fUnlockOwner = TRUE;
        }

        /*
         * Remember if window was originally disabled (so we can set
         * the correct state when the dialog goes away.
         */
        fDisabled = TestWF(pwndOwner, WFDISABLED);
        fOwnerIsActiveWindow = (SAMEWOWHANDLE(hwndOwner, GetActiveWindow()));

        /*
         * Disable the window.
         */
        NtUserEnableWindow(hwndOwner, FALSE);
    }

    /*
     * Don't show cursors on a mouseless system. Put up an hour glass while
     * the dialog comes up.
     */
    if (SYSMET(MOUSEPRESENT)) {
        NtUserSetCursor(LoadCursor(NULL, IDC_WAIT));
    }

    /*
     * Creates the dialog.  Frees the menu if this routine fails.
     */
    hwnd = InternalCreateDialog(hModule, lpdt, 0, hwndOwner,
            pfnDialog, lParam, fSCDLGFlags);

    if (hwnd == NULL) {

        /*
         * The dialog creation failed.  Re-enable the window, destroy the
         * menu, ie., fail gracefully.
         */
        if (!fDisabled && hwndOwner != NULL)
            NtUserEnableWindow(hwndOwner, TRUE);

        if (fUnlockOwner)
            ThreadUnlock(&tlpwndOwner);
        return -1;
    }

    i = DialogBox2(hwnd, hwndOwner, fDisabled, fOwnerIsActiveWindow);

    if (fUnlockOwner)
        ThreadUnlock(&tlpwndOwner);
    return i;
}

/***************************************************************************\
**
**  RepositionRect()
**
**  Used to ensure that toplevel dialogs are still visible within the
**  desktop area after they've resized.
**
\***************************************************************************/

void
RepositionRect(
        PMONITOR    pMonitor,
        LPRECT      lprc,
        DWORD       dwStyle,
        DWORD       dwExStyle)
{
    LPRECT      lprcClip;
    int         y;

    UserAssert(lprc);
    UserAssert(pMonitor);

    if (dwStyle & WS_CHILD) {
        if (dwExStyle & WS_EX_CONTROLPARENT)
            return;

        /*
         * Old style 3.1 child dialogs--do this nonsense anyway.  Keeps
         * FedEx happy.
         */
        pMonitor = GetPrimaryMonitor();
        lprcClip = KPRECT_TO_PRECT(&pMonitor->rcMonitor);
    } else if (dwExStyle & WS_EX_TOOLWINDOW) {
        lprcClip = KPRECT_TO_PRECT(&pMonitor->rcMonitor);
    } else {
        lprcClip = KPRECT_TO_PRECT(&pMonitor->rcWork);
    }

    UserAssert(lprc);

    y = lprcClip->bottom - (SYSMET(CYEDGE) * 2 + SYSMET(CYKANJIWINDOW));

    if (lprc->bottom > y) {
        OffsetRect(lprc, 0, y - lprc->bottom);
    }

    if (lprc->top < lprcClip->top) {
        OffsetRect(lprc, 0, lprcClip->top - lprc->top);
    }

    if (lprc->right > lprcClip->right) {
        OffsetRect(lprc, lprcClip->right - lprc->right, 0);
    }

    if (lprc->left < lprcClip->left) {
        OffsetRect(lprc, lprcClip->left - lprc->left, 0);
    }
}

/***************************************************************************\
* MapDialogRect
*
* History:
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, MapDialogRect, HWND, hwnd, LPRECT, lprc)
BOOL MapDialogRect(
    HWND hwnd,
    LPRECT lprc)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return FALSE;
    }

    /*
     * Must do special validation here to make sure pwnd is a dialog window.
     */
    if (!ValidateDialogPwnd(pwnd))
        return FALSE;

    lprc->left = XPixFromXDU(lprc->left, PDLG(pwnd)->cxChar);
    lprc->right = XPixFromXDU(lprc->right, PDLG(pwnd)->cxChar);
    lprc->top = YPixFromYDU(lprc->top, PDLG(pwnd)->cyChar);
    lprc->bottom = YPixFromYDU(lprc->bottom, PDLG(pwnd)->cyChar);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\dlgbegin.c ===
/***************************************************************************\
*
*  DLGBEGIN.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Dialog Initialization Routines
*
* ??-???-???? mikeke    Ported from Win 3.0 sources
* 12-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL ValidateCallback(HANDLE h);

CONST WCHAR szEDITCLASS[] = TEXT("Edit");

/*
 * Fixed, hard coded literal for Dialog hacks
 */
const WCHAR gwszShellFont[]  = L"MS Shell Dlg";
const WCHAR gwszShellFont2[] = L"MS Shell Dlg 2";


/***************************************************************************\
* DefShortToInt
*
* Avoid sign extending 16 bit CW2_USEDEFAULT. We need this because the
*  dialog resource template uses SHORT fields to store the coordinates
*  but CreateWindow wants INT values.
*
* History:
* 12/04/96 GerardoB Created
\***************************************************************************/
__inline int DefShortToInt (short s)
{
    if (s == (short)CW2_USEDEFAULT) {
        return (int)(DWORD)(WORD)CW2_USEDEFAULT;
    } else {
        return (int)s;
    }
}
/***************************************************************************\
* BYTE FAR *SkipSz(lpsz)
*
* History:
\***************************************************************************/

PBYTE SkipSz(
    UTCHAR *lpsz)
{
    if (*lpsz == 0xFF)
        return (PBYTE)lpsz + 4;

    while (*lpsz++ != 0) ;

    return (PBYTE)lpsz;
}

PBYTE WordSkipSz(
    UTCHAR *lpsz)
{
    PBYTE pb = SkipSz(lpsz);
    return NextWordBoundary(pb);
}

PBYTE DWordSkipSz(
    UTCHAR *lpsz)
{
    PBYTE pb = SkipSz(lpsz);
    return NextDWordBoundary(pb);
}


/***************************************************************************\
*
* IsFontNotGood()
*
* If this is a low res device, we need to check if the
* font we're creating is smaller than the system font.
*
\***************************************************************************/
__inline BOOLEAN IsFontNotGood(LPWSTR szTempBuffer, LPCWSTR lpStrSubst, TEXTMETRIC* ptm)
{
    //
    // For FarEast version, we will allow the font smaller than system font.
    //
    return _wcsicmp(szTempBuffer, lpStrSubst) ||
                (!IS_ANY_DBCS_CHARSET(ptm->tmCharSet) &&
                    (SYSMET(CXICON) < 32 || SYSMET(CYICON) < 32) &&
                    ptm->tmHeight < gpsi->cySysFontChar);
}

// --------------------------------------------------------------------------
//  GetCharsetEnumProc()
//
//  This gets the best asian font for a dialog box.
//
//  1996-Sep-11 hideyukn     Port from Win95-FE
// --------------------------------------------------------------------------
int CALLBACK GetCharsetEnumProc(
    LPLOGFONT     lpLogFont,
    LPTEXTMETRIC  lptm,
    DWORD         nType,
    LPARAM        lpData)
{
    UNREFERENCED_PARAMETER(lptm);
    UNREFERENCED_PARAMETER(nType);

    //
    // Use other than FIXED pitch sysfont when the face name isn't specified.
    //
    if ((lpLogFont->lfPitchAndFamily & 3) == FIXED_PITCH)
    {
        if (!lstrcmpi(lpLogFont->lfFaceName,L"System") ||
            !lstrcmpi(lpLogFont->lfFaceName,L"@System"))
            return TRUE; // try to get another system font metric
    }

    ((LPLOGFONT)lpData)->lfCharSet = lpLogFont->lfCharSet;
    ((LPLOGFONT)lpData)->lfPitchAndFamily = lpLogFont->lfPitchAndFamily;
    return FALSE;
}

/*
 * Get a character set based on System's ANSI CODEPAGE
 */
UINT GetACPCharSet()
{
    static UINT charset = (UINT)~0;
    CHARSETINFO csInfo;

    if (charset != (UINT)~0) {
        return charset;
    }

    // Sundown: In the TCI_SRCCODEPAGE case, the GetACP() return value is zero-extended.
    if (!TranslateCharsetInfo((DWORD*)UIntToPtr( GetACP() ), &csInfo, TCI_SRCCODEPAGE)) {
        return DEFAULT_CHARSET;
    }
    charset = csInfo.ciCharset;
    UserAssert(charset != (UINT)~0);
    return csInfo.ciCharset;
}

#if 0
BYTE GetCharsetFromResourceLang(LCID lcid)
{
    CHARSETINFO csInfo;

    if (!TranslateCharsetInfo((DWORD *)lcid, &csInfo, TCI_SRCLOCALE))
        return DEFAULT_CHARSET;
    return csInfo.ciCharset;
}
#endif

/***************************************************************************\
*
* CreateDlgFont()
*
* Create the dialog font described at the given location in a resource
*
\***************************************************************************/

#define GET_DESKTOP_CHARSET()   (GetTextCharset(hdcDlg))

//
// Reserved Dlg resource version number
//
#define DLGRSC_VER_NT5COMPAT_RESERVE    10

BOOL FixupDlgLogFont(
        HDC hdcDlg,
        LPLOGFONT lpLogFont,
        LPDLGTEMPLATE2 lpdt,
        BOOLEAN fUseShellFont2,
        BOOLEAN* pfWillTryDefaultCharset)
{
    switch (lpdt->wDlgVer) {
    case 0:
        // DIALOG statement, which only has a facename.
        // The new applications are not supposed to use DIALOG statement,
        // they should use DIALOGEX instead.
        lpLogFont->lfWeight  = FW_BOLD;
        if (!fUseShellFont2) {
            lpLogFont->lfCharSet = (BYTE)GET_DESKTOP_CHARSET();
            *pfWillTryDefaultCharset = TRUE;
        }
        break;
    case 1:
        //
        // Win4 compatible DLG template
        //
        if (!fUseShellFont2) {
            if (IS_DBCS_ENABLED()) {
                if (lpLogFont->lfCharSet == ANSI_CHARSET) {
                    //
                    // When resource compiler generates dialog resource data
                    // from DIALOGEX template, it can specify 'charset'. but
                    // optional, if it is not specified, it will be filled
                    // with 0 (ANSI charset). But, on localized version,
                    // User might guess the default will be localized-charset
                    //
                    // [Dialog Resource File]
                    //
                    // DIALOGEX ...
                    // ...
                    // FONT pointsize, typeface, [weight], [italic], [charset]
                    //
                    // #100182
                    // Bogus hack:
                    // Some FE fonts started to have ANSI_CHARSET so the first attept would succeed.
                    // We should enumerate the charset from the beginning.
                    lpLogFont->lfCharSet = DEFAULT_CHARSET;
                    RIPMSG0(RIP_VERBOSE, "No proper CharSet information in DIALOGEX");
                }
            }
            /*
             * Note: Dialog resource version 2.0 or later has not been supported on
             * Windows 95 and 98. As of Apr/98 we decided not to deploy this new feature
             * in the standard tools. Still, NT 5 supports this new feature, preparing
             * the future transition to do the right thing.
             */
            else if (lpLogFont->lfCharSet == ANSI_CHARSET) {
                // If the first attempt fail, we'll enumerate the charset for the given facename
                *pfWillTryDefaultCharset = TRUE;
            }
            else if (lpLogFont->lfCharSet == DEFAULT_CHARSET) {
                lpLogFont->lfCharSet = (BYTE)GET_DESKTOP_CHARSET();
            }
        }
        break;
    default:
        if (lpdt->wDlgVer <= DLGRSC_VER_NT5COMPAT_RESERVE) {
            // we do nothing for the new resource compiler (>= 2.0),
            // since this version of dialogs are guarunteed to have
            // the proper character set for the dialog font.
        }
        else {
            RIPMSG1(RIP_WARNING, "Version %d resource is not supported.", lpdt->wDlgVer);
            return FALSE;
        }
        break;
    }

    return TRUE;
}

VOID FixupDlgFaceName(
        LPLOGFONT lpLogFont,
        BOOLEAN fUseShellFont,
        BOOLEAN fUseShellFont2,
        LPCWSTR lpStrSubst)
{
    if (fUseShellFont2) {
        //
        // OK, we use "MS Shell Dlg 2" as a face name.
        //
        wcsncpycch(lpLogFont->lfFaceName, gwszShellFont2, ARRAY_SIZE(gwszShellFont2));
    }
    else {
        //
        // Otherwise, get the face name from the dialog template.
        //
        wcsncpycch(lpLogFont->lfFaceName, lpStrSubst, sizeof(lpLogFont->lfFaceName) / sizeof(WCHAR));
    }

    //
    // "MS Shell Dlg" and "MS Shell Dlg2" should have native character set ---
    //
    if (fUseShellFont || fUseShellFont2) {
        lpLogFont->lfCharSet = (BYTE)GetACPCharSet();
    }
}


HFONT CreateDlgFont(HDC hdcDlg, LPWORD FAR *lplpstr, LPDLGTEMPLATE2 lpdt, DWORD dwExpWinVer, UINT fSCDLGFlags)
{
    LOGFONT     LogFont;
    int         fontheight, fheight;
    HFONT       hOldFont, hFont;
    WCHAR       szTempBuffer[LF_FACESIZE];
    LPCWSTR     lpStrSubst;
    TEXTMETRIC  tm;
    // Font hacks
    BOOLEAN     fDeleteFont;
    BOOLEAN     fWillTryDefaultCharset = FALSE;
    BOOLEAN     fUseShellFont, fUseShellFont2;

    UNREFERENCED_PARAMETER(dwExpWinVer);
    UNREFERENCED_PARAMETER(fSCDLGFlags);

    fheight = fontheight = (SHORT)(*((WORD *) *lplpstr)++);

    if (fontheight == 0x7FFF) {
        // a 0x7FFF height is our special code meaning use the message box font
        GetObject(KHFONT_TO_HFONT(gpsi->hMsgFont), sizeof(LOGFONT), &LogFont);
        return CreateFontIndirect(&LogFont);
    }

    //
    // The dialog template contains a font description! Use it.
    //

    // Fill the LogFont with default values
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));

    fontheight = -MultDiv(fontheight, gpsi->dmLogPixels, 72);
    LogFont.lfHeight = fontheight;

    if (lpdt->wDlgVer) {
        //
        // If it's DIALOGEX, additional info should be read from
        // the template.
        //
        LogFont.lfWeight  = *((WORD FAR *) *lplpstr)++;
        LogFont.lfItalic  = *((BYTE FAR *) *lplpstr)++;
        LogFont.lfCharSet = *((BYTE FAR *) *lplpstr)++;
    }

    //
    // Per shell team request, the dialog who has DS_SETFONT
    // *and* DS_FIXEDSYS (=> DS_SHELLFONT2) should have a font
    // "MS Shell Dlg 2".
    //
    lpStrSubst = *lplpstr;

    //
    // Set the pointer to the next item.
    //
    *lplpstr = (WORD*)DWordSkipSz(*lplpstr);

    fUseShellFont = _wcsicmp(lpStrSubst, gwszShellFont) == 0;

    //
    // Later shell team request again, to use "Dlg 2" font only
    // when facename in the dialog template is "MS Shell Dlg".
    //
    fUseShellFont2 = fUseShellFont &&
        (lpdt->style & DS_SHELLFONT) == DS_SHELLFONT && Is400Compat(dwExpWinVer) && lpdt->wDlgVer != 0;

    if (fUseShellFont2) {
        TAGMSG0(DBGTAG_IMM, "CreateDlgFont: fUseShellFont2=TRUE");
    }

    //
    // Prepare the font character set.
    //
    if (!FixupDlgLogFont(hdcDlg, &LogFont, lpdt, fUseShellFont2, &fWillTryDefaultCharset)) {
        return NULL;
    }

    //
    // Prepare the font facename.
    //
    FixupDlgFaceName(&LogFont, fUseShellFont, fUseShellFont2, lpStrSubst);

    if (lpdt->wDlgVer < 2 && lpdt->style & DS_3DLOOK)
        LogFont.lfWeight = FW_NORMAL;

TryDefaultCharset:
    if (LogFont.lfCharSet == DEFAULT_CHARSET) {
        //
        // Get character set for given facename.
        //
        EnumFonts(hdcDlg, LogFont.lfFaceName,
                  (FONTENUMPROC)GetCharsetEnumProc, (LPARAM)(&LogFont));
        //
        // We already tried default charset.
        //
        fWillTryDefaultCharset = FALSE;
    }

    //
    // [Windows 3.1 FarEast version did this...]
    //
    // Use FW_NORMAL as default for DIALOG template. For DIALOGEX
    // template, we need to respect the value in the template.
    //
    if ((!(lpdt->wDlgVer)) && // not DIALOGEX template ?
        (IS_ANY_DBCS_CHARSET(LogFont.lfCharSet)) && // any FarEast font ?
        (LogFont.lfWeight != FW_NORMAL)) { // already FW_NORMAL ?

        //
        // Set weight to FW_NORMAL.
        //
        LogFont.lfWeight = FW_NORMAL;
    }

    if (!(hFont = CreateFontIndirect((LPLOGFONT) &LogFont)))
        return(NULL);

    fDeleteFont = FALSE;

    if ((hOldFont = SelectFont(hdcDlg, hFont)) == NULL) {
        fDeleteFont = TRUE;
    }
    else {
        //
        // If this dialog has DS_SHELLFONT style, or the font is
        // "MS Shell Dlg", we don't judge the font integrity,
        // for they have been given the ACP based character set.
        //
        if (!fUseShellFont) {
            if (!GetTextMetrics(hdcDlg, &tm)) {
                RIPMSG0(RIP_WARNING, "CreateDlgFont: GetTextMetrics failed");
                fDeleteFont = TRUE;
            }
            else {
                GetTextFaceAliasW(hdcDlg, sizeof(szTempBuffer)/sizeof(WCHAR), szTempBuffer);

                //
                // If this is a low res device, we need to check if the
                // font we're creating is smaller than the system font.
                // If so, just use the system font.
                //
                if (IsFontNotGood(szTempBuffer, lpStrSubst, &tm)) {
                    //
                    // Couldn't find a font with the height or facename
                    // the app wanted so use the system font instead. Note
                    // that we need to make sure the app knows it is
                    // getting the system font via the WM_SETFONT message
                    // so we still need to act as if a new font is being
                    // sent to the dialog box.
                    //
                    fDeleteFont = TRUE;
                }
            }
        }

        UserAssert(hOldFont != NULL);
        SelectFont(hdcDlg, hOldFont);
    }

    if (fDeleteFont) {
        DeleteFont(hFont);
        //
        // Font is deleted, Prepare for reTry...
        //
        hFont = NULL;
    }

    // Font hack:
    //
    // 1. We fail to create font.
    // 2. We did *NOT* try to enumerate charset, yet.
    // 3. We want to try to enumerate charset
    //
    // if all of answer is 'Yes', we will try...
    //
    if (hFont == NULL && fWillTryDefaultCharset) {
        //
        // Try DEFAULT_CHARSET.
        //
        LogFont.lfCharSet = DEFAULT_CHARSET;
        goto TryDefaultCharset;
    }

    return hFont;
}

#undef GET_DESKTOP_CHARSET

#define CD_VISIBLE          0x01
#define CD_GLOBALEDIT       0x02
#define CD_USERFONT         0x04
#define CD_SETFOREGROUND    0x08
#define CD_USEDEFAULTX      0x10
#define CD_USEDEFAULTCX     0x20


/***************************************************************************\
* GetDialogMonitor
*
* Gets the monitor a dialog should be created on.
*
* Params:
*     hwndOwner - the owner of the dialog. May be NULL.
*
* History:
* 10-Oct-1996 adams     Created.
\***************************************************************************/

PMONITOR
GetDialogMonitor(HWND hwndOwner, DWORD dwFlags)
{
    PMONITOR    pMonitor;
    PWND        pwnd;
    HWND        hwndForeground;
    DWORD       pid;

    UserAssert(dwFlags == MONITOR_DEFAULTTONULL ||
               dwFlags == MONITOR_DEFAULTTOPRIMARY);

    pMonitor = NULL;
    if (hwndOwner) {
        pwnd = ValidateHwnd(hwndOwner);
        if (pwnd && GETFNID(pwnd) != FNID_DESKTOP) {
            pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
        }
    } else {
        /*
         * HACK!  They passed in no owner and are creating a top level
         * dialog window.  Does this process own the foreground window?
         * If so, pin to that window's monitor.  That way 16-bit apps
         * will work mostly as expected, and old multithreaded dudes just
         * might too.  Especially the shell, for whom many system UI pieces
         * pop up random dialogs inside of API calls.
         */

        hwndForeground = NtUserGetForegroundWindow();
        if (hwndForeground) {
            GetWindowThreadProcessId(hwndForeground, &pid);
            if (pid == HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) {
                pwnd = ValidateHwnd(hwndForeground);
                if (pwnd) {
                    pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
                }
            }
        }
    }

    if (!pMonitor && dwFlags == MONITOR_DEFAULTTOPRIMARY) {
        pMonitor = GetPrimaryMonitor();
    }

    return pMonitor;
}


/***************************************************************************\
* InternalCreateDialog
*
* Creates a dialog from a template. Uses passed in menu if there is one,
* destroys menu if creation failed. Server portion of
* CreateDialogIndirectParam.
*
* WARNING: This function cannot create any windows before creating the dialog
*           window. Otherwise, MFC apps will break because their hook assumes
*           the dialog is the first window to be created.
*
* History:
* 04-10-91 ScottLu
* 04-17-91 Mikehar Win31 Merge
\***************************************************************************/


HWND InternalCreateDialog(
    HANDLE hmod,
    LPDLGTEMPLATE lpdt,
    DWORD cb,
    HWND hwndOwner,
    DLGPROC lpfnDialog,
    LPARAM lParam,
    UINT fSCDLGFlags)
{
    HWND                hwnd;
    HWND                hwnd2;
    PWND                pwnd;
    HWND                hwndNewFocus;
    HWND                hwndEditFirst = NULL;
    RECT                rc;
    WORD                w;
    UTCHAR              *lpszMenu,
                        *lpszClass,
                        *lpszText,
                        *lpCreateParams,
                        *lpStr;
    int                 cxChar,
                        cyChar;
    BOOL                f40Compat;
    HFONT               hNewFont = NULL;
    HFONT               hOldFont;
    LPDLGITEMTEMPLATE   lpdit;
    HMENU               hMenu;
    BOOL                fSuccess;
    BOOL                fWowWindow;
    HANDLE              hmodCreate;
    LPBYTE              lpCreateParamsData;
    DLGTEMPLATE2        dt;
    DLGITEMTEMPLATE2    dit;
    DWORD               dwExpWinVer;
    DWORD               dsStyleOld;
    DWORD               bFlags = 0;
    HDC                 hdcDlg;
    LARGE_STRING        strClassName;
    PLARGE_STRING       pstrClassName;
    LARGE_STRING        strWindowName;
    PMONITOR            pMonitor;

    UNREFERENCED_PARAMETER(cb);

    ConnectIfNecessary(0);

    UserAssert(!(fSCDLGFlags & ~(SCDLG_CLIENT|SCDLG_ANSI|SCDLG_NOREVALIDATE|SCDLG_16BIT)));    // These are the only valid flags

    /*
     * Is this a Win4 extended dialog?
     */
    if (((LPDLGTEMPLATE2)lpdt)->wSignature == 0xffff) {

        UserAssert(((LPDLGTEMPLATE2)lpdt)->wDlgVer <= DLGRSC_VER_NT5COMPAT_RESERVE);
        RtlCopyMemory(&dt, lpdt, sizeof dt);
    } else {
        dt.wDlgVer = 0;
        dt.wSignature = 0;
        dt.dwHelpID = 0;
        dt.dwExStyle = lpdt->dwExtendedStyle;
        dt.style = lpdt->style;
        dt.cDlgItems = lpdt->cdit;
        dt.x = lpdt->x;
        dt.y = lpdt->y;
        dt.cx = lpdt->cx;
        dt.cy = lpdt->cy;
    }

    /*
     * If this is called from wow code, then the loword of hmod != 0.
     * In this case, allow any DS_ style bits that were passed in win3.1
     * to be legal in win32. Case in point: 16 bit quark xpress passes the
     * same bit as the win32 style DS_SETFOREGROUND. Also, VC++ sample
     * "scribble" does the same thing.
     *
     * For win32 apps test the DS_SETFOREGROUND bit; wow apps are not set
     * foreground (this is the new NT semantics)
     * We have to let no "valid" bits through because apps depend on them
     * bug 5232.
     */
    dsStyleOld = LOWORD(dt.style);

    /*
     * If the app is Win4 or greater, require correct dialog style bits.
     * Prevents conflicts with new bits introduced in Chicago
     */
    dwExpWinVer = GETEXPWINVER(hmod) | CW_FLAGS_VERSIONCLASS;

    if ( f40Compat = Is400Compat(dwExpWinVer) ) {
        dt.style &= (DS_VALID40 | 0xffff0000);

        //
        // For old applications:
        //      If DS_COMMONDIALOG isn't set, don't touch DS_3DLOOK style
        // bit.  If it's there, it stays there.  If not, not.  That way old
        // apps which pass in their own templates, not commdlg's, don't get
        // forced 3D.
        //      If DS_COMMONDIALOG is there, remove DS_3DLOOK.
        //
        // For new applications:
        //      Force 3D always.
        //
        if (GETAPPVER() < VER40) {
            if (dt.style & DS_COMMONDIALOG) {
                dt.style &= ~DS_3DLOOK;
                dsStyleOld &= ~DS_3DLOOK;
            }
        } else {
            dt.style |= DS_3DLOOK;
            dsStyleOld |= DS_3DLOOK;
        }
    } else {
#if DBG
        if (dt.style != (dt.style & (DS_VALID31 | DS_3DLOOK | 0xffff0000))) {
            RIPMSG1(RIP_WARNING, "CreateDialog: stripping invalid bits %lX", dt.style);
        }
#endif // DBG


        /*
         * Don't strip off bits for old apps, they depend on this.  Especially 16 bit MFC apps!
         *
         * dt.dwStyle &= (DS_VALID31 | 0xffff0000);
         */
    }

    if (LOWORD((ULONG_PTR)hmod) == 0) {
        if (dt.style & DS_SETFOREGROUND)
            bFlags |= CD_SETFOREGROUND;
    }

    if (dsStyleOld != LOWORD(dt.style))
    {

        RIPMSG1(f40Compat ? RIP_ERROR : RIP_WARNING,
                "Bad dialog style bits (%x) - please remove.",
                LOWORD(dt.style));
        // Fail new apps that pass in bogus bits!

        if (f40Compat) {
            return NULL;
        }
    }

    if ( dt.style & DS_MODALFRAME) {
        dt.dwExStyle |= WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE;
    }

    if (( dt.style & DS_CONTEXTHELP) && f40Compat) {
        dt.dwExStyle |= WS_EX_CONTEXTHELP;
    }

    if (dt.style & DS_CONTROL) {
        // Captions and system menus aren't allowed on "control" dialogs.
        // And strip DS_SYSMODAL.
        dt.style &= ~(WS_CAPTION | WS_SYSMENU | DS_SYSMODAL);
    } else if (dt.style & WS_DLGFRAME) {
        // Add on window edge same way that CreateWindowEx() will
        dt.dwExStyle |= WS_EX_WINDOWEDGE;
    }

    if (dt.style & DS_SYSMODAL) {
        dt.dwExStyle |= WS_EX_TOPMOST;
    }

    if (!(dt.style & WS_CHILD) || (dt.style & DS_CONTROL)) {
        // only a control parent if it's not a child dialog or if it's
        // explicitly marked as a recursive dialog
        dt.dwExStyle |= WS_EX_CONTROLPARENT;
    }

    if (dt.x == (short)CW2_USEDEFAULT) {
        bFlags |= CD_USEDEFAULTX;
        dt.x = 0;
    }

    if (dt.cx == (short)CW2_USEDEFAULT) {
        bFlags |= CD_USEDEFAULTCX;
        dt.cx = 0;
    } else if (dt.cx < 0) {
        dt.cx = 0;
    }

    if (dt.cy < 0) {
        dt.cy = 0;
    }


    // If there's a menu name string, load it.
    lpszMenu = (LPWSTR)(((PBYTE)(lpdt)) + (dt.wDlgVer ? sizeof(DLGTEMPLATE2):sizeof(DLGTEMPLATE)));

    /*
     * If the menu id is expressed as an ordinal and not a string,
     * skip all 4 bytes to get to the class string.
     */
    w = *(LPWORD)lpszMenu;

    /*
     * If there's a menu name string, load it.
     */
    if (w != 0) {
        if ((hMenu = LoadMenu(hmod, (w == 0xFFFF) ?
                MAKEINTRESOURCE(*(WORD *)((PBYTE)lpszMenu + 2)) : lpszMenu)) == NULL) {
            RIPMSG0(RIP_WARNING, "ServerCreateDialog() failed: couldn't load menu");
            goto DeleteFontAndMenuAndFail;
        }
    } else {
        hMenu = NULL;
    }

    if (w == 0xFFFF) {
        lpszClass = (LPWSTR)((LPBYTE)lpszMenu + 4);
    } else {
        lpszClass = (UTCHAR *)WordSkipSz(lpszMenu);
    }

    lpszText = (UTCHAR *)WordSkipSz(lpszClass);

    lpStr = (UTCHAR *)WordSkipSz(lpszText);

    hdcDlg = CreateCompatibleDC(NULL);
    if (hdcDlg == NULL)
        goto DeleteFontAndMenuAndFail;

    if (dt.style & DS_SETFONT) {
        hNewFont = CreateDlgFont(hdcDlg, &lpStr, &dt, dwExpWinVer, fSCDLGFlags);
        bFlags |= CD_USERFONT;
        lpdit = (LPDLGITEMTEMPLATE) NextDWordBoundary(lpStr);
    } else if (Is400Compat(dwExpWinVer) && (dt.style & DS_FIXEDSYS)) {

        //
        // B#2078 -- WISH for fixed width system font in dialog.  We need
        // to tell the dialog that it's using a font different from the
        // standard system font, so set CD_USERFONT bit.
        //
        // We need the 400 compat. check for CorelDraw, since they use
        // this style bit for their own purposes.
        //
        hNewFont = GetStockObject(SYSTEM_FIXED_FONT);
        bFlags |= CD_USERFONT;
        lpdit = (LPDLGITEMTEMPLATE)NextDWordBoundary(lpStr);
    } else {
        lpdit = (LPDLGITEMTEMPLATE)NextDWordBoundary(lpStr);
    }

    /*
     * If the application requested a particular font and for some
     * reason we couldn't find it, we just use the system font.  BUT we
     * need to make sure we tell him he gets the system font.  Dialogs
     * which never request a particular font get the system font and we
     * don't bother telling them this (via the WM_SETFONT message).
     */

    // Is it anything other than the default system font?  If we can't get
    // enough memory to select in the new font specified, just use the system
    // font.
    if (hNewFont && (hOldFont = SelectFont(hdcDlg, hNewFont))) {
        // Get the ave character width and height to be used
        cxChar = GdiGetCharDimensions(hdcDlg, NULL, &cyChar);

        SelectFont(hdcDlg, hOldFont);
        if (cxChar == 0) {
            RIPMSG0(RIP_WARNING, "InternalCreateDialog: GdiGetCharDimensions failed");
            goto UseSysFontMetrics;
        }
    }
    else
    {
        if (hNewFont || (bFlags & CD_USERFONT))
            hNewFont = ghFontSys;

UseSysFontMetrics:
        cxChar = gpsi->cxSysFontChar;
        cyChar = gpsi->cySysFontChar;
    }
    DeleteDC(hdcDlg);

    if (dt.style & WS_VISIBLE) {
        bFlags |= CD_VISIBLE;
        dt.style &= ~WS_VISIBLE;
    }

    if (!(dt.style & DS_LOCALEDIT)) {
        bFlags |= CD_GLOBALEDIT;
    }

    /* Figure out dimensions of real window
     *
     * NOTE: We need to call the _Real_ AdjustWindowRectEx() function and not
     * the hooked one because Themes uses the initial size that the dialog comes
     * up to determine how much to enlarge it by.
     */
    rc.left = rc.top = 0;
    rc.right = XPixFromXDU(dt.cx, cxChar);
    rc.bottom = YPixFromYDU(dt.cy, cyChar);

    RealAdjustWindowRectEx(&rc, dt.style, w, dt.dwExStyle);

    dt.cx = (SHORT)(rc.right - rc.left);
    dt.cy = (SHORT)(rc.bottom - rc.top);

    if ((dt.style & DS_CENTERMOUSE) && SYSMET(MOUSEPRESENT) && f40Compat) {
        pMonitor = _MonitorFromPoint(gpsi->ptCursor, MONITOR_DEFAULTTONULL);
        UserAssert(pMonitor);
        *((LPPOINT)&rc.left) = gpsi->ptCursor;
        rc.left -= (dt.cx / 2);
        rc.top  -= (dt.cy / 2);
    } else {
        BOOL fNoDialogMonitor;

        pMonitor = GetDialogMonitor(hwndOwner, MONITOR_DEFAULTTONULL);
        fNoDialogMonitor = pMonitor ? FALSE : TRUE;
        if (!pMonitor) {
            pMonitor = GetPrimaryMonitor();
        }

        if ((dt.style & (DS_CENTER | DS_CENTERMOUSE)) && f40Compat) {
            /*
             * Center to the work area of the owner monitor.
             */
            rc.left = (pMonitor->rcWork.left + pMonitor->rcWork.right - dt.cx) / 2;
            rc.top  = (pMonitor->rcWork.top + pMonitor->rcWork.bottom - dt.cy) / 2;
        } else {
            rc.left = XPixFromXDU(dt.x, cxChar);
            rc.top = YPixFromYDU(dt.y, cyChar);

            if (!(dt.style & DS_ABSALIGN) && hwndOwner) {
                /*
                 * Offset relative coordinates to the owner window. If it is
                 * a child window, there is nothing to do.
                 */
                if ((HIWORD(dt.style) & MaskWF(WFTYPEMASK)) != MaskWF(WFCHILD)) {
                    //This is will considre rc.left form the right hand side of the owner window if it a mirrored one.
                    ClientToScreen(hwndOwner, (LPPOINT)&rc.left);

                    //It is not chiled then do Visual ClientToScreen
                    //i.e. rc.left it is form the left hand side of the owner window
                    if (MIRRORED_HWND(hwndOwner)) {
                        rc.left -= dt.cx;
                    }
                }
            } else {
                /*
                 * Position the dialog in screen coordinates. If the dialog's
                 * owner is on a different monitor than specified in the
                 * template, move the dialog to the owner window. If the owner
                 * doesn't exist, then use the monitor from the dialog's
                 * template.
                 */

                PMONITOR    pMonitorTemplate;
                RECT        rcTemplate;

                rcTemplate.left  = rc.left;
                rcTemplate.top   = rc.top;
                rcTemplate.right  = rc.left + dt.cx;
                rcTemplate.bottom = rc.top + dt.cy;

                pMonitorTemplate = _MonitorFromRect(&rcTemplate, MONITOR_DEFAULTTOPRIMARY);
                if (fNoDialogMonitor) {
                    pMonitor = pMonitorTemplate;
                } else if (pMonitorTemplate != pMonitor) {
                    rc.left += pMonitor->rcMonitor.left - pMonitorTemplate->rcMonitor.left;
                    rc.top  += pMonitor->rcMonitor.top  - pMonitorTemplate->rcMonitor.top;
                }
            }
        }
    }

    rc.right  = rc.left + dt.cx;
    rc.bottom = rc.top  + dt.cy;

    // If the right or bottom coordinate has overflowed, then pin it back to
    // a valid rectangle.  Likely to happen if a minimized window is the owner of
    // the dialog.
    if (rc.left > rc.right || rc.top > rc.bottom) {
        OffsetRect(&rc, -dt.cx, -dt.cy);
    }

   //
    // Need to do this for ALL dialogs, not just top-level, since we used
    // to in 3.1.
    //

    // Clip top level dialogs within working area
    // Start child dialogs at least at (0, 0)
    RepositionRect(pMonitor, &rc, dt.style, dt.dwExStyle);

    dt.x  = (SHORT)((bFlags & CD_USEDEFAULTX) ? CW2_USEDEFAULT : rc.left);
    dt.y  = (SHORT)(rc.top);
    dt.cx = (SHORT)((bFlags & CD_USEDEFAULTCX) ? CW2_USEDEFAULT : rc.right - rc.left);
    dt.cy = (SHORT)(rc.bottom - rc.top);

    if (*lpszClass != 0) {
        if (IS_PTR(lpszClass)) {
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strClassName,
                    lpszClass, (UINT)-1);
            pstrClassName = &strClassName;
        } else {
            pstrClassName = (PLARGE_STRING)lpszClass;
        }
    } else {
        pstrClassName = (PLARGE_STRING)DIALOGCLASS;
    }

    RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strWindowName,
            lpszText, (UINT)-1);

    UserAssert((dt.dwExStyle & WS_EX_MDICHILD) == 0);
    hwnd = VerNtUserCreateWindowEx(
            dt.dwExStyle | ((fSCDLGFlags & SCDLG_ANSI) ? WS_EX_ANSICREATOR : 0),
            pstrClassName,
            &strWindowName,
            dt.style,
            DefShortToInt(dt.x),
            dt.y,
            DefShortToInt(dt.cx),
            dt.cy,
            hwndOwner,
            hMenu,
            hmod,
            (LPVOID)NULL,
            dwExpWinVer);

    if (hwnd == NULL) {
        RIPMSG0(RIP_WARNING, "CreateDialog() failed: couldn't create window");
DeleteFontAndMenuAndFail:
        if (hMenu != NULL)
            NtUserDestroyMenu(hMenu);
        /*
         * Only delete the font if we didn't grab it
         * from the dialog font cache.
         */
        if ((hNewFont != NULL)) {
            DeleteObject(hNewFont);
        }
        return NULL;
    }

    pwnd = ValidateHwnd(hwnd);

    // tell WOW the hDlg of the Window just created BEFORE they get any messages
    // at WOW32!w32win16wndprocex
    if(fSCDLGFlags & SCDLG_16BIT) {
        TellWOWThehDlg(hwnd);
    }

    /*
     * Before anything happens with this window, we need to mark it as a
     * dialog window!!!! So do that.
     */
    if (pwnd == NULL || !ValidateDialogPwnd(pwnd))
        goto DeleteFontAndMenuAndFail;

    if (dt.dwHelpID) {
        NtUserSetWindowContextHelpId(hwnd, dt.dwHelpID);
    }

    /*
     * Set up the system menu on this dialog box if it has one.
     */
    if (TestWF(pwnd, WFSYSMENU)) {

        /*
         * For a modal dialog box with a frame and caption, we want to
         * delete the unselectable items from the system menu.
         */
        UserAssert(HIBYTE(WFSIZEBOX) == HIBYTE(WFMINBOX));
        UserAssert(HIBYTE(WFMINBOX) == HIBYTE(WFMAXBOX));
        if (!TestWF(pwnd, WFSIZEBOX | WFMINBOX | WFMAXBOX)) {

            NtUserCallHwndLock(hwnd, SFI_XXXSETDIALOGSYSTEMMENU);
        } else {

            /*
             * We have to give this dialog its own copy of the system menu
             * in case it modifies the menu.
             */
            NtUserGetSystemMenu(hwnd, FALSE);
        }
    }

    /*
     * Set fDisabled to FALSE so EndDialog will Enable if dialog is ended
     * before returning to DialogBox (or if modeless).
     */
    PDLG(pwnd)->fDisabled = FALSE;

    PDLG(pwnd)->cxChar = cxChar;
    PDLG(pwnd)->cyChar = cyChar;
    PDLG(pwnd)->lpfnDlg = lpfnDialog;
    PDLG(pwnd)->fEnd = FALSE;
    PDLG(pwnd)->result = IDOK;

    /*
     * Need to remember Unicode status.
     */
    if (fSCDLGFlags & SCDLG_ANSI) {
        PDLG(pwnd)->flags |= DLGF_ANSI;
    }

    /*
     * Have to do a callback here for WOW apps.  WOW needs what's in lParam
     * before the dialog gets any messages.
     */

    /*
     * If the app is a Wow app then the Lo Word of the hInstance is the
     * 16-bit hInstance.  Set the lParam, which no-one should look at
     * but the app, to the 16 bit value
     */
    if (LOWORD((ULONG_PTR)hmod) != 0) {
        fWowWindow = TRUE;
    } else {
        fWowWindow = FALSE;
    }

    /*
     * If a user defined font is used, save the handle so that we can delete
     * it when the dialog is destroyed.
     */
    if (bFlags & CD_USERFONT) {

        PDLG(pwnd)->hUserFont = hNewFont;

        if (lpfnDialog != NULL) {
            /*
             * Tell the dialog that it will be using this font...
             */
            SendMessageWorker(pwnd, WM_SETFONT, (WPARAM)hNewFont, 0L, FALSE);
        }
    }

    if (!dt.wDlgVer) {
        dit.dwHelpID = 0;
    }

    /*
     * Loop through the dialog controls, doing a CreateWindowEx() for each of
     * them.
     */
    while (dt.cDlgItems-- != 0) {
        DWORD dwExpWinVer2;

        if (dt.wDlgVer) {
            RtlCopyMemory(&dit, lpdit, sizeof dit);
        } else {
            dit.dwHelpID = 0;
            dit.dwExStyle = lpdit->dwExtendedStyle;
            dit.style = lpdit->style;
            dit.x = lpdit->x;
            dit.y = lpdit->y;
            dit.cx = lpdit->cx;
            dit.cy = lpdit->cy;
            dit.dwID = lpdit->id;
        }

        dit.x = XPixFromXDU(dit.x, cxChar);
        dit.y = YPixFromYDU(dit.y, cyChar);
        dit.cx = XPixFromXDU(dit.cx, cxChar);
        dit.cy = YPixFromYDU(dit.cy, cyChar);

        lpszClass = (LPWSTR)(((PBYTE)(lpdit)) + (dt.wDlgVer ? sizeof(DLGITEMTEMPLATE2):sizeof(DLGITEMTEMPLATE)));

        /*
         * If the first WORD is 0xFFFF the second word is the encoded class name index.
         * Use it to look up the class name string.
         */
        if (*(LPWORD)lpszClass == 0xFFFF) {
            lpszText = lpszClass + 2;
            lpszClass = (LPWSTR)(gpsi->atomSysClass[*(((LPWORD)lpszClass)+1) & ~CODEBIT]);
        } else {
            lpszText = (UTCHAR *)SkipSz(lpszClass);
        }
        lpszText = (UTCHAR *)NextWordBoundary(lpszText); // UINT align lpszText

        dit.dwExStyle |= WS_EX_NOPARENTNOTIFY;

        //
        // Replace flat borders with 3D ones for DS_3DLOOK dialogs
        // We test the WINDOW style, not the template style now.  This is so
        // that 4.0 apps--who get 3D stuff automatically--can turn it off on
        // create if they want.
        //

        //
        // HACK!
        // Treat DS_3DLOOK combos like they have a WS_EX_CLIENTEDGE.  Why
        // should we have to draw the borders of a combobox ourselves?
        // We can't do the same thing for WS_BORDER though becaues of
        // PC Fools--they use the presence of WS_BORDER to distinguish
        // between lists and combos.
        //

        if (TestWF(pwnd, DF3DLOOK)) {
            if (    (dit.style & WS_BORDER) ||
                    (lpszClass == MAKEINTRESOURCE(gpsi->atomSysClass[ICLS_COMBOBOX]))) {

                dit.style &= ~WS_BORDER;
                dit.dwExStyle |= WS_EX_CLIENTEDGE;
            }
        }

        /*
         * Get pointer to additional data.  lpszText can point to an encoded
         * ordinal number for some controls (e.g.  static icon control) so
         * we check for that here.
         */
        if (*(LPWORD)lpszText == 0xFFFF) {
            lpCreateParams = (LPWSTR)((PBYTE)lpszText + 4);
            strWindowName.Buffer = lpszText;
            strWindowName.Length = 4;
            strWindowName.MaximumLength = 4;
            strWindowName.bAnsi = FALSE;
        } else {
            lpCreateParams = (LPWSTR)((PBYTE)WordSkipSz(lpszText));
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strWindowName,
                    lpszText, (UINT)-1);
        }

        /*
         * If control is edit control and caller wants global storage
         * of edit text, allocate object in WOW and pass instance
         * handle to CreateWindowEx().
         */
        if (fWowWindow && (bFlags & CD_GLOBALEDIT) &&
               ((!IS_PTR(lpszClass) &&
                    PTR_TO_ID(lpszClass) == (ATOM)(gpsi->atomSysClass[ICLS_EDIT])) ||
               (IS_PTR(lpszClass) &&
                    (wcscmp(lpszClass, szEDITCLASS) == 0)))) {

            /*
             * Allocate only one global object (first time we see editctl.)
             */
            if (!(PDLG(pwnd)->hData)) {
                PDLG(pwnd)->hData = GetEditDS();
                if (!(PDLG(pwnd)->hData))
                    goto NoCreate;
            }

            hmodCreate = KHANDLE_TO_HANDLE(PDLG(pwnd)->hData);
            dwExpWinVer2 = GETEXPWINVER(hmodCreate) | CW_FLAGS_VERSIONCLASS;
        } else {
            hmodCreate = hmod;
            dwExpWinVer2 = dwExpWinVer;
        }

#if DBG
        if ((dit.dwExStyle & WS_EX_ANSICREATOR) != 0) {
            RIPMSG1(RIP_WARNING, "Bad WS_EX_ style 0x%x for a control in the dialog",
                    dit.dwExStyle);
        }
#endif // DBG

        /*
         * Get pointer to additional data.
         *
         * For WOW, instead of pointing lpCreateParams at the CreateParams
         * data, set lpCreateParams to whatever DWORD is stored in the 32-bit
         * DLGTEMPLATE's CreateParams.  WOW has already made sure that that
         * 32-bit value is indeed a 16:16 pointer to the CreateParams in the
         * 16-bit DLGTEMPLATE.
         */

        if (*lpCreateParams) {
            lpCreateParamsData = (LPBYTE)lpCreateParams;
            if (fWowWindow || fSCDLGFlags & SCDLG_16BIT) {
                lpCreateParamsData =
                    (LPBYTE)ULongToPtr( *(UNALIGNED DWORD *) /* Sundown WOW: zero-extension */
                    (lpCreateParamsData + sizeof(WORD)) );
            }
        } else {
            lpCreateParamsData = NULL;
        }

        /*
         * If the dialog template specifies a menu ID then TestwndChild(pwnd)
         * must be TRUE or CreateWindowEx will think the ID is an hMenu rather
         * than an ID (in a dialog template you'll never have an hMenu).
         * However for compatibility reasons we let it go if the ID = 0.
         */
        if (dit.dwID) {
            /*
             * This makes TestwndChild(pwnd) on this window return TRUE.
             */
            dit.style |= WS_CHILD;
            dit.style &= ~WS_POPUP;
        }

        if (IS_PTR(lpszClass)) {
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strClassName,
                    lpszClass, (UINT)-1);
            pstrClassName = &strClassName;
        } else {
            pstrClassName = (PLARGE_STRING)lpszClass;
        }

        UserAssert((dit.dwExStyle & WS_EX_MDICHILD) == 0);

        hwnd2 = VerNtUserCreateWindowEx(
                dit.dwExStyle | ((fSCDLGFlags & SCDLG_ANSI) ? WS_EX_ANSICREATOR : 0),
                pstrClassName,
                &strWindowName,
                dit.style,
                DefShortToInt(dit.x),
                dit.y,
                DefShortToInt(dit.cx),
                dit.cy,
                hwnd,
                (HMENU)LongToHandle( dit.dwID ),
                hmodCreate,
                lpCreateParamsData,
                dwExpWinVer2);

        if (hwnd2 == NULL) {
NoCreate:
            /*
             * Couldn't create the window -- return NULL.
             */
            if (!TestWF(pwnd, DFNOFAILCREATE)) {
                RIPMSG0(RIP_WARNING, "CreateDialog() failed: couldn't create control");
                NtUserDestroyWindow(hwnd);
                return NULL;
            }
        } else {

            if (dit.dwHelpID) {
                NtUserSetWindowContextHelpId(hwnd2, dit.dwHelpID);
            }

        /*
         * If it is a not a default system font, set the font for all the
         * child windows of the dialogbox.
         */
            if (hNewFont != NULL) {
                SendMessage(hwnd2, WM_SETFONT, (WPARAM)hNewFont, 0L);
            }

        /*
         * Result gets ID of last (hopefully only) defpushbutton.
         */
            if (SendMessage(hwnd2, WM_GETDLGCODE, 0, 0L) & DLGC_DEFPUSHBUTTON) {
                PDLG(pwnd)->result = dit.dwID;
            }
        }

        /*
         * Point at next item template
         */
        lpdit = (LPDLGITEMTEMPLATE)NextDWordBoundary(
                (LPBYTE)(lpCreateParams + 1) + *lpCreateParams);
    }

    if (!TestWF(pwnd, DFCONTROL)) {
        PWND pwndT = _GetNextDlgTabItem(pwnd, NULL, FALSE);
        hwndEditFirst = HW(pwndT);
    }

    if (lpfnDialog != NULL) {
        fSuccess = (BOOL)SendMessageWorker(pwnd, WM_INITDIALOG,
                               (WPARAM)hwndEditFirst, lParam, FALSE);

        //
        // Make sure the window didn't get nuked during WM_INITDIALOG
        //
        if (!RevalidateHwnd(hwnd)) {
            goto CreateDialogReturn;
        }
        if (fSuccess && !PDLG(pwnd)->fEnd) {

            //
            // To remove the two-default-push-buttons problem, we must make
            // sure CheckDefPushButton() will remove default from other push
            // buttons.  This happens only if hwndEditFirst != hwndNewFocus;
            // So, we make it NULL here. This breaks Designer's install
            // program(which can't take a DM_GETDEFID.  So, we do a version
            // check here.
            //
            if (!TestWF(pwnd, DFCONTROL)) {
                PWND pwndT;
                if (!IsWindow(hwndEditFirst) || TestWF(pwnd, WFWIN40COMPAT))
                    hwndEditFirst = NULL;

                //
                // They could have disabled hwndEditFirst during WM_INITDIALOG.
                // So, let use obtain the First Tab again.
                //
                pwndT = _GetNextDlgTabItem(pwnd, NULL, FALSE);
                if (hwndNewFocus = HW(pwndT)) {
                    DlgSetFocus(hwndNewFocus);
                }

                xxxCheckDefPushButton(pwnd, hwndEditFirst, hwndNewFocus);
            }
        }
    }

    if (!IsWindow(hwnd))
    {
        // Omnis7 relies on a nonzero return even though they nuked this
        // dialog during processing of the WM_INITDIALOG message
        // -- jeffbog -- 2/24/95 -- Win95B B#12368
        if (GETAPPVER() < VER40) {
            return(hwnd);
        }

        return(NULL);
    }

    /*
     * UISTATE: if keyboard indicators are on and this is a topmost dialog
     * set the internal bit.
     */
    if (TEST_KbdCuesPUSIF) {
        /*
         * If property page, UISTATE bits were copied from parent when I was created
         * Top level dialogs act as containers and initialize their state based on
         * the type of the last input event, after sending UIS_INITIALIZE
         */
        if (!TestwndChild(pwnd)) {
            SendMessageWorker(pwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0, FALSE);
        }
    }

    /*
     * Bring this dialog into the foreground
     * if DS_SETFOREGROUND is set.
     */
    if (bFlags & CD_SETFOREGROUND) {
        NtUserSetForegroundWindow(hwnd);
        if (!IsWindow(hwnd)) {
            hwnd = NULL;
            goto CreateDialogReturn;
        }
    }

    if ((bFlags & CD_VISIBLE) && !PDLG(pwnd)->fEnd && (!TestWF(pwnd, WFVISIBLE))) {
        NtUserShowWindow(hwnd, SHOW_OPENWINDOW);
        UpdateWindow(hwnd);
    }

CreateDialogReturn:

    /*
     * 17609 Gupta's SQLWin deletes the window before CreateDialog returns
     * but still expects non-zero return value from CreateDialog so we will
     * do like win 3.1 and not revalidate for 16 bit apps
     */
    if (!(fSCDLGFlags & SCDLG_NOREVALIDATE) && !RevalidateHwnd(hwnd)) {
        hwnd = NULL;
    }

    return hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\dlgmgr2.c ===
/***************************************************************************\
*
*  DLGMGR2.C
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Dialog Management Routines
*
* ??-???-???? mikeke    Ported from Win 3.0 sources
* 12-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxRemoveDefaultButton
*
* Scan through all the controls in the dialog box and remove the default
* button style from any button that has it.  This is done since at times we
* do not know who has the default button.
*
* History:
*
* Bug 19449 - joejo
*
*   Stop infinite loop when pwnd != pwndStart but pwnd == pwnd after calling
*   _NextControl!
\***************************************************************************/

void xxxRemoveDefaultButton(
    PWND pwndRoot,
    PWND pwndStart)
{
    UINT code;
    PWND pwnd;
    PWND pwndDup;
    TL tlpwnd;

    CheckLock(pwndRoot);
    CheckLock(pwndStart);

    if (!pwndStart || TestWF(pwndStart, WEFCONTROLPARENT))
        pwndStart = _NextControl(pwndRoot, NULL, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);
    else
        pwndStart = _GetChildControl(pwndRoot, pwndStart);

    if (!pwndStart)
        return;

    pwnd = pwndStart;
    do {
        pwndDup = pwnd;
        
        ThreadLock(pwnd, &tlpwnd);

        code = (UINT)SendMessage(HWq(pwnd), WM_GETDLGCODE, 0, 0L);

        if (code & DLGC_DEFPUSHBUTTON) {
            SendMessage(HWq(pwnd), BM_SETSTYLE, BS_PUSHBUTTON, (LONG)TRUE);
        }

        pwnd = _NextControl(pwndRoot, pwnd, 0);

        ThreadUnlock(&tlpwnd);

    } while (pwnd && (pwnd != pwndStart) && (pwnd != pwndDup));
    
#if DBG
    if (pwnd && (pwnd != pwndStart) && (pwnd != pwndDup)) {
        RIPMSG0(RIP_WARNING, "xxxRemoveDefaultButton bailing potential infinite loop!");
    }
#endif
    
}


/***************************************************************************\
* xxxCheckDefPushButton
*
* History:
\***************************************************************************/

void xxxCheckDefPushButton(
    PWND pwndDlg,
    HWND hwndOldFocus,
    HWND hwndNewFocus)
{
    PWND pwndNewFocus;
    PWND pwndOldFocus;
    TL tlpwndT;
    PWND pwndT;
    UINT codeNewFocus = 0;
    UINT styleT;
    LONG lT;
    int id;

    if (hwndNewFocus)
        pwndNewFocus = ValidateHwnd(hwndNewFocus);
    else
        pwndNewFocus = NULL;

     if (hwndOldFocus)
         pwndOldFocus = ValidateHwnd(hwndOldFocus);
     else
         pwndOldFocus = NULL;

    CheckLock(pwndDlg);
    CheckLock(pwndNewFocus);
    CheckLock(pwndOldFocus);

    if (pwndNewFocus)
    {
        // Do nothing if clicking on dialog background or recursive dialog
        // background.
        if (TestWF(pwndNewFocus, WEFCONTROLPARENT))
            return;

        codeNewFocus = (UINT)SendMessage(hwndNewFocus, WM_GETDLGCODE, 0, 0L);
    }

    if (SAMEWOWHANDLE(hwndOldFocus, hwndNewFocus)) {
        //
        // NEW FOR 4.0:
        //
        // There is a very common frustrating scenario for ISVs who try to
        // set the default ID.  Our dialog manager assumes that if a push
        // button has the focus, it is the default button also.  As such
        // it passes in the focus window to this routine.  If someone tries
        // to change the focus or set the def ID such that they reside with
        // two different push buttons, the double-default-push button case
        // will result shortly.
        //
        // As such, for 4.0 dialogs, we will go check the def ID and see if
        // is the same as hwndOldFocus' ID.  If not, then we will find IT
        // and use that dude as hwndOldFocus
        //
        if (codeNewFocus & DLGC_UNDEFPUSHBUTTON)
        {
           if (TestWF(pwndDlg, WFWIN40COMPAT) && hwndOldFocus)
           {
               lT = (LONG)SendMessage(HWq(pwndDlg), DM_GETDEFID, 0, 0L);
               id = (HIWORD(lT) == DC_HASDEFID ? LOWORD(lT) : IDOK);
               lT = MAKELONG(id, 0);

               if (lT != PtrToLong(pwndNewFocus->spmenu))
               {
                   if (pwndOldFocus = _FindDlgItem(pwndDlg, lT))
                   {
                       hwndOldFocus = HW(pwndOldFocus);
                       if (SendMessage(hwndOldFocus, WM_GETDLGCODE, 0, 0L) & DLGC_DEFPUSHBUTTON)
                       {
                           xxxRemoveDefaultButton(pwndDlg, pwndOldFocus);
                           goto SetNewDefault;
                       }
                   }
               }
           }

           SendMessage(hwndNewFocus, BM_SETSTYLE, BS_DEFPUSHBUTTON, (LONG)TRUE);
        }
        return;
    }

    /*
     * If the focus is changing to or from a pushbutton, then remove the
     * default style from the current default button
     */
    if ((hwndOldFocus != NULL && (SendMessage(hwndOldFocus, WM_GETDLGCODE,
                0, 0) & (DLGC_DEFPUSHBUTTON | DLGC_UNDEFPUSHBUTTON))) ||
            (hwndNewFocus != NULL &&
                (codeNewFocus & (DLGC_DEFPUSHBUTTON | DLGC_UNDEFPUSHBUTTON)))) {
        xxxRemoveDefaultButton(pwndDlg, pwndNewFocus);
    }

SetNewDefault:
    /*
     * If moving to a button, make that button the default.
     */
    if (codeNewFocus & DLGC_UNDEFPUSHBUTTON) {
        SendMessage(hwndNewFocus, BM_SETSTYLE, BS_DEFPUSHBUTTON, (LONG)TRUE);
    } else {

        /*
         * Otherwise, make sure the original default button is default
         * and no others.
         */

        /*
         * Get the original default button handle
         */
        lT = (LONG)SendMessage(HWq(pwndDlg), DM_GETDEFID, 0, 0L);
        id = (HIWORD(lT) == DC_HASDEFID ? LOWORD(lT) : IDOK);
        pwndT = _FindDlgItem(pwndDlg, id);

        if (pwndT == NULL)
            return;
        ThreadLockAlways(pwndT, &tlpwndT);

        /*
         * If it already has the default button style, do nothing.
         */
        if ((styleT = (UINT)SendMessage(HWq(pwndT), WM_GETDLGCODE, 0, 0L)) & DLGC_DEFPUSHBUTTON) {
            ThreadUnlock(&tlpwndT);
            return;
        }

        /*
         * Also check to make sure it is really a button.
         */
        if (!(styleT & DLGC_UNDEFPUSHBUTTON)) {
            ThreadUnlock(&tlpwndT);
            return;
        }

        if (!TestWF(pwndT, WFDISABLED)) {
            SendMessage(HWq(pwndT), BM_SETSTYLE, BS_DEFPUSHBUTTON, (LONG)TRUE);
        }
        ThreadUnlock(&tlpwndT);
    }
}


/***************************************************************************\
* IsDialogMessage (API)
*
* History:
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsDialogMessageA, HWND, hwndDlg, LPMSG, lpmsg)
BOOL IsDialogMessageA(
    HWND hwndDlg,
    LPMSG lpmsg)
{
    WPARAM wParamSaved = lpmsg->wParam;
    BOOL bRet;

    switch (lpmsg->message) {
#ifdef FE_SB // IsDialogMessageA()
    case WM_CHAR:
    case EM_SETPASSWORDCHAR:
        /*
         * BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_CLIENTA() macro will return TRUE
         * for DBCS leadbyte message everytime, then we check there is some
         * possibility the return value become FALSE, here.
         *
         * These code originally come from IsDialogMessageW().
         */
         if (IS_DBCS_ENABLED()) {
            PWND pwndDlg, pwnd;
            TL tlpwndDlg;
            BOOL fLockDlg = FALSE;

            if ((pwndDlg = ValidateHwndNoRip(hwndDlg)) == NULL) {
                return FALSE;
            }

            if (lpmsg->hwnd == NULL) {
                return FALSE;
            }

            pwnd = ValidateHwnd(lpmsg->hwnd);
            //
            // THIS IS FOR MFC.
            //
            // This solves many problems with apps that use MFC but want to take
            // advantage of DS_CONTROL.  MFC blindly passes in child dialogs sometimes
            // to IsDialogMessage, which can mess up tabbing etc.
            //
            if (TestWF(pwndDlg, WEFCONTROLPARENT) && TestWF(pwndDlg, WFCHILD)) {
                pwndDlg = GetParentDialog(pwndDlg);
                ThreadLock(pwndDlg, &tlpwndDlg);
                fLockDlg = TRUE;
                hwndDlg = HWq(pwndDlg);
            }

            if (pwnd != pwndDlg && !_IsChild(pwndDlg, pwnd)) {
                if (fLockDlg)
                    ThreadUnlock(&tlpwndDlg);
                return FALSE;
            }

            /*
             * Build DBCS-aware message.
             */
            BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_CLIENTA(lpmsg->message,lpmsg->wParam,TRUE);

            /*
             * Fall through.....
             */
        }
#else
    case WM_CHAR:
    case EM_SETPASSWORDCHAR:
#endif // FE_SB
    case WM_CHARTOITEM:
    case WM_DEADCHAR:
    case WM_SYSCHAR:
    case WM_SYSDEADCHAR:
    case WM_MENUCHAR:
#ifdef FE_IME // IsDialogMessageA()
    case WM_IME_CHAR:
    case WM_IME_COMPOSITION:
#endif // FE_IME

        RtlMBMessageWParamCharToWCS(lpmsg->message, &lpmsg->wParam);
    }

    bRet = IsDialogMessageW(hwndDlg, lpmsg);

    /*
     * Restore the original ANSI char.
     */
    lpmsg->wParam = wParamSaved;
    return bRet;
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsDialogMessageW, HWND, hwndDlg, LPMSG, lpMsg)
BOOL IsDialogMessageW(
    HWND hwndDlg,
    LPMSG lpMsg)
{
    PWND pwndDlg;
    PWND pwnd;
    PWND pwnd2;
    HWND hwnd2;
    HWND hwndFocus;
    int iOK;
    BOOL fBack;
    UINT code;
    LONG lT;
    TL tlpwnd;
    TL tlpwndDlg;
    BOOL fLockDlg = FALSE;
    TL tlpwnd2;
    WORD langID;

    langID = PRIMARYLANGID(LANGIDFROMLCID(GetUserDefaultLCID()));

    if ((pwndDlg = ValidateHwndNoRip(hwndDlg)) == NULL) {
        return FALSE;
    }

    CheckLock(pwndDlg);

    /*
     * If this is a synchronous-only message (takes a pointer in wParam or
     * lParam), then don't allow this message to go through since those
     * parameters have not been thunked, and are pointing into outer-space
     * (which would case exceptions to occur).
     *
     * (This api is only called in the context of a message loop, and you
     * don't get synchronous-only messages in a message loop).
     */
    if (TESTSYNCONLYMESSAGE(lpMsg->message, lpMsg->wParam)) {
        /*
         * Fail if 32 bit app is calling.
         */
        if (!(GetClientInfo()->dwTIFlags & TIF_16BIT)) {
            RIPERR0(ERROR_MESSAGE_SYNC_ONLY, RIP_WARNING, "IsDialogMessage: must be sync only");
            return FALSE;
        }

        /*
         * For wow apps, allow it to go through (for compatibility). Change
         * the message id so our code doesn't understand the message - wow
         * will get the message and strip out this bit before dispatching
         * the message to the application.
         */
        lpMsg->message |= MSGFLAG_WOW_RESERVED;
    }

    if (CallMsgFilter(lpMsg, MSGF_DIALOGBOX))
        return TRUE;

    if (lpMsg->hwnd == NULL) {
        return FALSE;
    }

    pwnd = ValidateHwnd(lpMsg->hwnd);
    //
    // THIS IS FOR MFC.
    //
    // This solves many problems with apps that use MFC but want to take
    // advantage of DS_CONTROL.  MFC blindly passes in child dialogs sometimes
    // to IsDialogMessage, which can mess up tabbing etc.
    //
    if (TestWF(pwndDlg, WEFCONTROLPARENT) && TestWF(pwndDlg, WFCHILD)) {
        pwndDlg = GetParentDialog(pwndDlg);
        ThreadLock(pwndDlg, &tlpwndDlg);
        fLockDlg = TRUE;
        hwndDlg = HWq(pwndDlg);
    }

    if (pwnd != pwndDlg && !_IsChild(pwndDlg, pwnd)) {
        if (fLockDlg)
            ThreadUnlock(&tlpwndDlg);
        return FALSE;
    }
    ThreadLock(pwnd, &tlpwnd);

    fBack = FALSE;
    iOK = IDCANCEL;
    switch (lpMsg->message) {
    case WM_LBUTTONDOWN:

        /*
         * Move the default button styles around on button clicks in the
         * same way as TABs.
         */
        if ((pwnd != pwndDlg) && ((hwndFocus = GetFocus()) != NULL)) {
            xxxCheckDefPushButton(pwndDlg, hwndFocus, lpMsg->hwnd);
        }
        break;

    case WM_SYSCHAR:

        /*
         * If no control has focus, and Alt not down, then ignore.
         */
        if ((GetFocus() == NULL) && (GetKeyState(VK_MENU) >= 0)) {
            if (lpMsg->wParam == VK_RETURN && TestWF(pwnd, WFMINIMIZED)) {

                /*
                 * If this is an iconic dialog box window and the user hits
                 * return, send the message off to DefWindowProc so that it
                 * can be restored.  Especially useful for apps whose top
                 * level window is a dialog box.
                 */
                goto CallDefWindowProcAndReturnTrue;
            } else {
                NtUserMessageBeep(0);
            }

            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;
        }

        /*
         * If alt+menuchar, process as menu.
         */
        if (lpMsg->wParam == MENUSYSMENU) {
            DefWindowProcWorker(pwndDlg, lpMsg->message, lpMsg->wParam,
                    lpMsg->lParam, FALSE);
            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;
        }

    /*
     *** FALL THRU **
     */

    case WM_CHAR:

        /*
         * Ignore chars sent to the dialog box (rather than the control).
         */
        if (pwnd == pwndDlg) {
            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;
        }

        code = (UINT)SendMessage(lpMsg->hwnd, WM_GETDLGCODE, lpMsg->wParam,
                (LPARAM)lpMsg);

        /*
         * If the control wants to process the message, then don't check for
         * possible mnemonic key.
         */
        if ((lpMsg->message == WM_CHAR) && (code & (DLGC_WANTCHARS | DLGC_WANTMESSAGE)))
            break;

        /* If the control wants tabs, then don't let tab fall thru here
         */
        if ((lpMsg->wParam == VK_TAB) && (code & DLGC_WANTTAB))
            break;


        /*
         * HACK ALERT
         *
         * If ALT is held down (i.e., SYSCHARs), then ALWAYS do mnemonic
         * processing.  If we do away with SYSCHARS, then we should
         * check key state of ALT instead.
         */

        /*
         * Space is not a valid mnemonic, but it IS the char that toggles
         * button states.  Don't look for it as a mnemonic or we will
         * beep when it is typed....
         */
        if (lpMsg->wParam == VK_SPACE) {
            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;
        }

        if (!(pwnd2 = xxxGotoNextMnem(pwndDlg, pwnd, (WCHAR)lpMsg->wParam))) {

            if (code & DLGC_WANTMESSAGE)
                break;

            /*
             * No mnemonic could be found so we will send the sys char over
             * to xxxDefWindowProc so that any menu bar on the dialog box is
             * handled properly.
             */
            if (lpMsg->message == WM_SYSCHAR) {
CallDefWindowProcAndReturnTrue:
                DefWindowProcWorker(pwndDlg, lpMsg->message, lpMsg->wParam,
                        lpMsg->lParam, FALSE);

                ThreadUnlock(&tlpwnd);
                if (fLockDlg)
                    ThreadUnlock(&tlpwndDlg);
                return TRUE;
            }
            NtUserMessageBeep(0);
        } else {

            /*
             * pwnd2 is 1 if the mnemonic took us to a pushbutton.  We
             * don't change the default button status here since doing this
             * doesn't change the focus.
             */
            if (pwnd2 != (PWND)1) {
                ThreadLockAlways(pwnd2, &tlpwnd2);
                xxxCheckDefPushButton(pwndDlg, lpMsg->hwnd, HWq(pwnd2));
                ThreadUnlock(&tlpwnd2);
            }
        }

        ThreadUnlock(&tlpwnd);
        if (fLockDlg)
            ThreadUnlock(&tlpwndDlg);
        return TRUE;

    case WM_SYSKEYDOWN:
        /*
         * If Alt is down, deal with keyboard cues
         */
        if ((HIWORD(lpMsg->lParam) & SYS_ALTERNATE) && TEST_KbdCuesPUSIF) {
            if (TestWF(pwnd, WEFPUIFOCUSHIDDEN) || (TestWF(pwnd, WEFPUIACCELHIDDEN))) {
                    SendMessageWorker(pwndDlg, WM_CHANGEUISTATE,
                                      MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0, FALSE);
                }
        }
        break;

    case WM_KEYDOWN:
        code = (UINT)SendMessage(lpMsg->hwnd, WM_GETDLGCODE, lpMsg->wParam,
                (LPARAM)lpMsg);
        if (code & (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE))
            break;

        switch (lpMsg->wParam) {
        case VK_TAB:
            if (code & DLGC_WANTTAB)
                break;
            pwnd2 = _GetNextDlgTabItem(pwndDlg, pwnd,
                    (GetKeyState(VK_SHIFT) & 0x8000));

            if (TEST_KbdCuesPUSIF) {
                if (TestWF(pwnd, WEFPUIFOCUSHIDDEN)) {
                    SendMessageWorker(pwndDlg, WM_CHANGEUISTATE,
                                          MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0, FALSE);
                }
            }

            if (pwnd2 != NULL) {
                hwnd2 = HWq(pwnd2);
                ThreadLockAlways(pwnd2, &tlpwnd2);
                DlgSetFocus(hwnd2);
                xxxCheckDefPushButton(pwndDlg, lpMsg->hwnd, hwnd2);
                ThreadUnlock(&tlpwnd2);
            }
            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;

        /*
         * For Arabic and Hebrew locales the arrow keys are reversed. Also reverse them if
         * the dialog is RTL mirrored.
         */
        case VK_LEFT:
            if ((((langID == LANG_ARABIC) || (langID == LANG_HEBREW)) && TestWF(pwndDlg,WEFRTLREADING))
                    ^ (!!TestWF(pwndDlg, WEFLAYOUTRTL))) {

                goto DoKeyStuff;
            }
        case VK_UP:
            fBack = TRUE;
            goto DoKeyStuff;

        /*
         *** FALL THRU **
         */
        case VK_RIGHT:
            if ((((langID == LANG_ARABIC) || (langID == LANG_HEBREW)) && TestWF(pwndDlg,WEFRTLREADING)) 
                     ^ (!!TestWF(pwndDlg, WEFLAYOUTRTL))) {

                fBack = TRUE;
            }
        case VK_DOWN:
DoKeyStuff:
            if (code & DLGC_WANTARROWS)
                break;

            if (TEST_KbdCuesPUSIF) {
                if (TestWF(pwnd, WEFPUIFOCUSHIDDEN)) {
                        SendMessageWorker(pwndDlg, WM_CHANGEUISTATE,
                                          MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0, FALSE);
                    }
            }

            pwnd2 = _GetNextDlgGroupItem(pwndDlg, pwnd, fBack);
            if (pwnd2 == NULL) {
                ThreadUnlock(&tlpwnd);
                if (fLockDlg)
                    ThreadUnlock(&tlpwndDlg);
                return TRUE;
            }
            hwnd2 = HWq(pwnd2);
            ThreadLockAlways(pwnd2, &tlpwnd2);

            code = (UINT)SendMessage(hwnd2, WM_GETDLGCODE, lpMsg->wParam,
                    (LPARAM)lpMsg);

            /*
             * We are just moving the focus rect around! So, do not send
             * BN_CLICK messages, when WM_SETFOCUSing.  Fix for Bug
             * #4358.
             */
            if (code & (DLGC_UNDEFPUSHBUTTON | DLGC_DEFPUSHBUTTON)) {
                PBUTN pbutn;
                BOOL fIsNTButton = IS_BUTTON(pwnd2);
                if (fIsNTButton) {
                    pbutn = ((PBUTNWND)pwnd2)->pbutn;
                    BUTTONSTATE(pbutn) |= BST_DONTCLICK;
                }
                DlgSetFocus(hwnd2);
                if (fIsNTButton) {
                    BUTTONSTATE(pbutn) &= ~BST_DONTCLICK;
                }
                xxxCheckDefPushButton(pwndDlg, lpMsg->hwnd, hwnd2);
            } else if (code & DLGC_RADIOBUTTON) {
                DlgSetFocus(hwnd2);
                xxxCheckDefPushButton(pwndDlg, lpMsg->hwnd, hwnd2);
                if (TestWF(pwnd2, BFTYPEMASK) == LOBYTE(BS_AUTORADIOBUTTON)) {

                    /*
                     * So that auto radio buttons get clicked on
                     */
                    if (!SendMessage(hwnd2, BM_GETCHECK, 0, 0L)) {
                        SendMessage(hwnd2, BM_CLICK, TRUE, 0L);
                    }
                }
            } else if (!(code & DLGC_STATIC)) {
                DlgSetFocus(hwnd2);
                xxxCheckDefPushButton(pwndDlg, lpMsg->hwnd, hwnd2);
            }
            ThreadUnlock(&tlpwnd2);
            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;

        case VK_EXECUTE:
        case VK_RETURN:

            /*
             * Guy pressed return - if button with focus is
             * defpushbutton, return its ID.  Otherwise, return id
             * of original defpushbutton.
             */
            if (!(hwndFocus = GetFocus()))
                code = 0;
            else
            {
                code = (WORD)(DWORD)SendMessage(hwndFocus, WM_GETDLGCODE,
                    0, 0L);
            }

            if (code & DLGC_DEFPUSHBUTTON)
            {
                iOK = GetDlgCtrlID(hwndFocus);
                pwnd2 = ValidateHwnd(hwndFocus);
                goto HaveWindow;
            }
            else
            {
                lT = (LONG)SendMessage(hwndDlg, DM_GETDEFID, 0, 0L);
                iOK = MAKELONG(
                    (HIWORD(lT)==DC_HASDEFID ? LOWORD(lT) : IDOK),
                    0);
            }
            // FALL THRU

        case VK_ESCAPE:
        case VK_CANCEL:

            /*
             * Make sure button is not disabled.
             */
            pwnd2 = _FindDlgItem(pwndDlg, iOK);
HaveWindow:
            if (pwnd2 != NULL && TestWF(pwnd2, WFDISABLED)) {
                NtUserMessageBeep(0);
            } else {
                SendMessage(hwndDlg, WM_COMMAND,
                        MAKELONG(iOK, BN_CLICKED), (LPARAM)HW(pwnd2));
            }

            ThreadUnlock(&tlpwnd);
            if (fLockDlg)
                ThreadUnlock(&tlpwndDlg);
            return TRUE;
        }
        break;
    }

    ThreadUnlock(&tlpwnd);
    if (fLockDlg)
        ThreadUnlock(&tlpwndDlg);

    TranslateMessage(lpMsg);
    DispatchMessage(lpMsg);

    return TRUE;
}

/***************************************************************************\
*
* FindDlgItem32()
*
* Given a dialog, finds the window with the given ID anywhere w/in the
* descendant chain.
*
\***************************************************************************/

PWND _FindDlgItem(PWND pwndParent, DWORD id)
{
    PWND    pwndChild;
    PWND    pwndOrig;

    // QUICK TRY:
    pwndChild = _GetDlgItem(pwndParent, id);
    if (pwndChild || !TestWF(pwndParent, WFWIN40COMPAT))
        return(pwndChild);

    pwndOrig = _NextControl(pwndParent, NULL, CWP_SKIPINVISIBLE);
    if (pwndOrig == pwndParent)
        return(NULL);

    pwndChild = pwndOrig;

//    VerifyWindow(pwndChild);

    do
    {
        if (PtrToUlong(pwndChild->spmenu) == id)
            return(pwndChild);

        pwndChild = _NextControl(pwndParent, pwndChild, CWP_SKIPINVISIBLE);
    }
    while (pwndChild && (pwndChild != pwndOrig));

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\dmmnem.c ===
/***************************************************************************\
*
*  DMMNEM.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Mnemonic Character Processing Routines
*
* ??-???-???? mikeke    Ported from Win 3.0 sources
* 12-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * There are several loops that we could get stuck in that we just forcibly
 * break by a max iteration count. Ugly, but its legacy DialogManager
 * issues.
 */
#define INFINITE_LOOP_CURE 1024

/***************************************************************************\
* FindMnemChar
*
* Returns: 0x00 if no matching char,
*          0x01 if menmonic char is matching,
*          0x80 if first char is matching
*
* History:
*   11-18-90 JimA       Created.
\***************************************************************************/

int FindMnemChar(
    LPWSTR lpstr,
    WCHAR ch,
    BOOL fFirst,
    BOOL fPrefix)
{
    WCHAR chc;
    WCHAR chFirst;

    while (*lpstr == TEXT(' '))
        lpstr++;

    ch = (WCHAR)(ULONG_PTR)CharLowerW((LPWSTR)ULongToPtr( (DWORD)(UTCHAR)ch ));
    chFirst = (WCHAR)(ULONG_PTR)CharLowerW((LPWSTR)ULongToPtr( (DWORD)(UTCHAR)(*lpstr) ));

    if (fPrefix) {
        WORD wvch, xvkey;
        //
        // get OEM-dependent virtual key code
        //
        if (IS_DBCS_ENABLED() && (wvch = VkKeyScanW(ch)) != -1)
            wvch &= 0x00FF;

        while (chc = *lpstr++) {
            //
            // This should think about KOREA & TAIWAN case. But probably OK.
            //
            if ((chc == CH_PREFIX) || (chc == CH_ENGLISHPREFIX && IS_DBCS_ENABLED())) {

                WORD chnext = (WCHAR)(ULONG_PTR)CharLowerW((LPWSTR)ULongToPtr( (DWORD)(UTCHAR)*lpstr ));

                if (chnext == CH_PREFIX) {
                    //
                    // Two CH_PREFIX in the resrc string results in one "&" in the text displayed
                    //
                    lpstr++;
                } else {
                    if (chnext == ch) {
                        return 0x01;
                    }
                    if (IS_DBCS_ENABLED()) {
                        //
                        // Compare should be done with virtual key in Kanji menu mode
                        // in order to accept Digit shortcut key and save English
                        // windows applications!
                        //
                        xvkey = VkKeyScanW(chnext);
                        if (xvkey != 0xFFFF && ((xvkey & 0x00FF) == wvch)) {
                            return 0x01;
                        }
                   }
                   return 0x00;
                }
            }
        }
    }
#if 0   // the original US code on NT4
    if (fPrefix) {
        while (chc = *lpstr++) {
            if (((WCHAR)CharLower((LPWSTR)(DWORD)(UTCHAR)chc) == CH_PREFIX)) {
                chnext = (WCHAR)CharLowerW((LPWSTR)(DWORD)(UTCHAR)*lpstr);

                if (chnext == CH_PREFIX)
                    lpstr++;
                else if (chnext == ch)
                    return 0x01;
                else {
                    return 0x00;
                }
            }
        }
    }
#endif // FE_SB

    if (fFirst && (ch == chFirst))
        return 0x80;

    return 0x00;
}


/***************************************************************************\
* xxxFindNextMnem
*
* This function returns NULL if no control with the specified mnemonic
* can be found.
*
* History:
\***************************************************************************/

PWND xxxGNM_FindNextMnem(
    PWND pwndDlg,
    PWND pwnd,
    WCHAR ch)
{
    PWND pwndStart;
    PWND pwndT;
    WCHAR rgchText[256];
    int i = 0;
    TL tlpwndStart;
    TL tlpwnd;
    DWORD dwDlgCode;

    CheckLock(pwndDlg);
    CheckLock(pwnd);

    /*
     * Check if we are in a group box so we can find local mnemonics.
     */

    pwndStart = _GetChildControl(pwndDlg, pwnd);
    ThreadLock(pwndStart, &tlpwndStart);

    while (TRUE) {

        pwndT = _GetNextDlgGroupItem(pwndDlg, pwndStart, FALSE);

        ThreadUnlock(&tlpwndStart);

        i++;
        if (pwndT == NULL || pwndT == pwnd || i > INFINITE_LOOP_CURE) {

            /*
             * If we have returned to our starting window or if we have gone
             * through INFINITE_LOOP_CURE iterations, let's exit.  There are
             * no local mnemonics that match.  We have to check for 
             * INFINITE_LOOP_CURE iterations (or so) because we run into
             * problems with WS_GROUP not being properly defined in rc files
             * that we never reach this same starting window again....
             */
            break;
        }

        pwndStart = pwndT;

        /*
         * Only check for matching mnemonic if control doesn't want characters
         * and control isn't a static control with SS_NOPREFIX
         */
        ThreadLock(pwndStart, &tlpwndStart);

        dwDlgCode = (DWORD)SendMessage(HWq(pwndT), WM_GETDLGCODE, 0, 0L);
        if (!(dwDlgCode & DLGC_WANTCHARS) &&
                (!(dwDlgCode & DLGC_STATIC) || !(pwndT->style & SS_NOPREFIX))) {
            GetWindowText(HWq(pwndT), rgchText, sizeof(rgchText)/sizeof(WCHAR));
            if (FindMnemChar(rgchText, ch, FALSE, TRUE) != 0) {
                ThreadUnlock(&tlpwndStart);
                return pwndT;
            }
        }
    }

    pwnd = pwndStart = _GetChildControl(pwndDlg, pwnd);
    i = 0;

    ThreadLock(pwnd, &tlpwnd);
    while (TRUE) {

        /*
         * Start with next so we see multiples of same mnemonic.
         */
        pwnd = _NextControl(pwndDlg, pwnd, TRUE);
        ThreadUnlock(&tlpwnd);
        ThreadLock(pwnd, &tlpwnd);

        /*
         * Only check for matching mnemonic if control doesn't want characters
         * and control isn't a static control with SS_NOPREFIX
         */
        dwDlgCode = (DWORD)SendMessage(HW(pwnd), WM_GETDLGCODE, 0, 0L);
        if (!(dwDlgCode & DLGC_WANTCHARS) &&
                (!(dwDlgCode & DLGC_STATIC) || !(pwnd->style & SS_NOPREFIX))) {
            GetWindowText(HW(pwnd), rgchText, sizeof(rgchText)/sizeof(WCHAR));
            if (FindMnemChar(rgchText, ch, FALSE, TRUE) != 0)
                break;
        }

        i++;
        if (pwnd == pwndStart || i > INFINITE_LOOP_CURE) {
            pwnd = NULL;
            break;
        }
    }
    ThreadUnlock(&tlpwnd);

    return pwnd;
}

/***************************************************************************\
* xxxGotoNextMnem
*
* History:
\***************************************************************************/

PWND xxxGotoNextMnem(
    PWND pwndDlg,
    PWND pwnd,
    WCHAR ch)
{
    UINT code;
    PWND pwndFirstFound = NULL;
    int count = 0;
    TL tlpwnd;
    PWND pwndT;
    HWND hwnd;

    CheckLock(pwndDlg);
    CheckLock(pwnd);

    ThreadLock(pwnd, &tlpwnd);

    /*
     * Loop for a long time but not long enough so we hang...
     */
    while (count < INFINITE_LOOP_CURE) {

        /*
         * If the dialog box doesn't has the mnemonic specified, return NULL.
         */
        if ((pwnd = xxxGNM_FindNextMnem(pwndDlg, pwnd, ch)) == NULL) {
            ThreadUnlock(&tlpwnd);
            return NULL;
        }
        hwnd = HWq(pwnd);

        ThreadUnlock(&tlpwnd);
        ThreadLock(pwnd, &tlpwnd);

        code = (UINT)SendMessage(hwnd, WM_GETDLGCODE, 0, 0L);

        /*
         * If a non-disabled static item, then jump ahead to nearest tabstop.
         */
        if (code & DLGC_STATIC && !TestWF(pwnd, WFDISABLED)) {
            pwndT = _GetNextDlgTabItem(pwndDlg, pwnd, FALSE);

            /*
             * If there is no other tab item, keep looking
             */
            if (pwndT == NULL)
                continue;
            pwnd = pwndT;
            hwnd = HWq(pwnd);

            ThreadUnlock(&tlpwnd);
            ThreadLock(pwnd, &tlpwnd);

            /*
             * I suppose we should do a getdlgcode here, but who is going to
             * label a button with a static control?  The setup guys, that's
             * who...  Also, generally useful for ownerdraw buttons which are
             * labeled with a static text item.
             */
            code = (UINT)SendMessage(hwnd, WM_GETDLGCODE, 0, 0L);
        }

        if (!TestWF(pwnd, WFDISABLED)) {

            /*
             * Is it a Pushbutton?
             */
            if (!(code & DLGC_BUTTON)) {

                /*
                 * No, simply give it the focus.
                 */
                DlgSetFocus(hwnd);
            } else {

                /*
                 * Yes, click it, but don't give it the focus.
                 */
                if ((code & DLGC_DEFPUSHBUTTON) || (code & DLGC_UNDEFPUSHBUTTON)) {

                    /*
                     * Flash the button.
                     */
                    SendMessage(hwnd, BM_SETSTATE, TRUE, 0L);

                    /*
                     * Delay
                     */
#ifdef LATER
// JimA - 2/19/92
// There oughta be a better way of doing this...
                    for (i = 0; i < 10000; i++)
                        ;
#else
                    Sleep(1);
#endif

                    /*
                     * Un-Flash it.
                     */
                    SendMessage(hwnd, BM_SETSTATE, FALSE, 0L);

                    /*
                     * Send the WM_COMMAND message.
                     */
                    pwndT = REBASEPWND(pwnd, spwndParent);
                    SendMessage(HW(pwndT), WM_COMMAND,
                            MAKELONG(PTR_TO_ID(pwnd->spmenu), BN_CLICKED), (LPARAM)hwnd);
                    ThreadUnlock(&tlpwnd);
                    return (PWND)1;
                } else {

                    /*
                     * Because BM_CLICK processing will result in BN_CLICK msg,
                     * xxxSetFocus must be prevented from sending the same msg;
                     * Otherwise, it will notify parent twice!
                     * Fix for Bug #3024 -- SANKAR -- 09-22-89 --
                     */
                    BOOL fIsNTButton;
                    PBUTN pbutn;

                    fIsNTButton = IS_BUTTON(pwnd);
                    if (fIsNTButton) {
                      pbutn = ((PBUTNWND)pwnd)->pbutn;
                      BUTTONSTATE(pbutn) |= BST_DONTCLICK;
                    } else {
                     RIPMSG0(RIP_WARNING, "xxxGotoNextMnem: fnid != FNID_BUTTON");
                    }

                    DlgSetFocus(hwnd);

                    if (fIsNTButton) {
                      BUTTONSTATE(pbutn) &= ~BST_DONTCLICK;
                    }

                    /*
                     * Send click message if button has a UNIQUE mnemonic
                     */
                    if (xxxGNM_FindNextMnem(pwndDlg, pwnd, ch) == pwnd) {
                        SendMessage(hwnd, BM_CLICK, TRUE, 0L);
                    }
                }
            }

            ThreadUnlock(&tlpwnd);
            return pwnd;
        } else {

            /*
             * Stop if we've looped back to the first item we checked
             */
            if (pwnd == pwndFirstFound) {
                ThreadUnlock(&tlpwnd);
                return NULL;
            }

            if (pwndFirstFound == NULL)
                pwndFirstFound = pwnd;
        }

        count++;

    }  /* Loop for a long time */

    ThreadUnlock(&tlpwnd);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\draw.c ===
/****************************** Module Header ******************************\
* Module Name: draw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the DrawFrameControl API
*
* History:
* 12-12-93  FritzS  Ported from Chicago
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* PaintRect
*
* History:
* 11-15-90 DarrinM  Ported from Win 3.0 sources.
* 01-21-91 IanJa    Prefix '_' denoting exported function (although not API)
* 12-12-94 JerrySh  Copied from server - make sure to keep in sync
\***************************************************************************/

BOOL PaintRect(
    HWND hwndBrush,
    HWND hwndPaint,
    HDC hdc,
    HBRUSH hbr,
    LPRECT lprc)
{
    POINT ptOrg;
    PWND pwndBrush;
    PWND pwndPaint;
    HWND    hwndDesktop;

    hwndDesktop = GetDesktopWindow();
    if (hwndBrush == NULL) {
        hwndBrush = hwndDesktop;
    }

    if (hwndBrush != hwndPaint) {
        pwndBrush = ValidateHwnd(hwndBrush);
        if (pwndBrush == NULL) {
            RIPMSG1(RIP_WARNING, "PaintRect: invalid Brush window %lX", hwndBrush);
            return FALSE;
        }

        pwndPaint = ValidateHwnd(hwndPaint);
        if (pwndPaint == NULL) {
            RIPMSG1(RIP_WARNING, "PaintRect: invalid Paint window %lX", hwndBrush);
            return FALSE;
        }


        if (hwndBrush != hwndDesktop) {
            SetBrushOrgEx(
                    hdc,
                    pwndBrush->rcClient.left - pwndPaint->rcClient.left,
                    pwndBrush->rcClient.top - pwndPaint->rcClient.top,
                    &ptOrg);
        } else {
            SetBrushOrgEx(hdc, 0, 0, &ptOrg);
        }
    }

    /*
     * If hbr < CTLCOLOR_MAX, it isn't really a brush but is one of our
     * special color values.  Translate it to the appropriate WM_CTLCOLOR
     * message and send it off to get back a real brush.  The translation
     * process assumes the CTLCOLOR*** and WM_CTLCOLOR*** values map directly.
     */
    if (hbr < (HBRUSH)CTLCOLOR_MAX) {
        hbr = GetControlColor(hwndBrush, hwndPaint, hdc,
                HandleToUlong(hbr) + WM_CTLCOLORMSGBOX);
    }

    FillRect(hdc, lprc, hbr);

    if (hwndBrush != hwndPaint) {
        SetBrushOrgEx(hdc, ptOrg.x, ptOrg.y, NULL);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\drawtext.c ===
/****************************** Module Header ******************************\
* Module Name: drawtext.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains common text drawing functions.
*
* History:
* 02-12-92 mikeke   Moved Drawtext to the client side
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CR 13
#define LF 10

#define DT_HFMTMASK 0x03

/***************************************************************************\
* IsMetaFile
*
* History:
* 30-Nov-1992 mikeke    Created
\***************************************************************************/

BOOL IsMetaFile(
    HDC hdc)
{
    DWORD dwType = GetObjectType(hdc);
    return (dwType == OBJ_METAFILE ||
            dwType == OBJ_METADC ||
            dwType == OBJ_ENHMETAFILE ||
            dwType == OBJ_ENHMETADC);
}

/***************************************************************************\
* DrawTextA (API)
*
* History:
* 30-11-92 mikeke      Created
\***************************************************************************/


CONST WCHAR gwszNullStr[] = L"";


FUNCLOG6(LOG_GENERAL, int, DUMMYCALLINGTYPE, DrawTextExA, HDC, hdc, LPSTR, lpchText, int, cchText, LPRECT, lprc, UINT, format, LPDRAWTEXTPARAMS, lpdtp)
int DrawTextExA(
    HDC hdc,
    LPSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format,
    LPDRAWTEXTPARAMS lpdtp)
{
    LPWSTR lpwstr;
    int iRet;
    int iUniString;
    WORD wCodePage = (WORD)GdiGetCodePage(hdc);

    if (cchText == -1) {
        // USER_AWCONV_COUNTSTRINGSZ does not count/convert trailing \0.
        cchText = USER_AWCONV_COUNTSTRINGSZ;
    } else if (cchText < -1) {
        return 0;
    }

    if ((iUniString = MBToWCSEx(wCodePage, lpchText, cchText, &lpwstr, -1, TRUE)) == 0) {
        if (cchText == USER_AWCONV_COUNTSTRINGSZ) {
            lpwstr = (LPWSTR)gwszNullStr;
            format &= ~DT_MODIFYSTRING;
        } else {
            return 0;
        }
    }

    /*
     * Grow the buffer to accomodate the ellipsis (see AddEllipsisAndDrawLine)
     */
    if (format & DT_MODIFYSTRING) {
        int iNewLen = (iUniString + CCHELLIPSIS + 1) * sizeof(*lpwstr);
        LPWSTR lpwstrNew = UserLocalReAlloc(lpwstr, iNewLen, HEAP_ZERO_MEMORY);
        if (lpwstrNew == NULL) {
            UserLocalFree((HANDLE)lpwstr);
            return FALSE;
        }
        lpwstr = lpwstrNew;
    }

    iRet = DrawTextExWorker(hdc, lpwstr, iUniString, lprc, format, lpdtp, GetTextCharset(hdc));

    if (format & DT_MODIFYSTRING) {
        /*
         * Note that if the buffer grew and the caller provided the string size,
         *  then we won't return the additional characters... fixing this
         *  might break some apps so let's leave it alone until some one complains
         */
        if (cchText < 0) {
            UserAssert(cchText == USER_AWCONV_COUNTSTRINGSZ);
            // Guess how many bytes we can put in the buffer...
            // We can safely assume the maximum bytes available.
            // At worst, even for DBCS, the buffer size required
            // will be smaller than or equal to the orignal size,
            // because some DBCS characters would be substituted
            // to SBC ".", which is one byte each.
            // On the other hand, the number of characters converted
            // is limited by both iUniString and cchText.
            //
            if (IS_DBCS_ENABLED()) {
                cchText = iUniString * DBCS_CHARSIZE;
            } else {
                cchText = iUniString * sizeof(CHAR);
            }
        }
        WCSToMBEx(wCodePage, lpwstr, iUniString, &lpchText, cchText, FALSE);
    }

    if (lpwstr != gwszNullStr) {
        UserLocalFree((HANDLE)lpwstr);
    }

    return iRet;
}

/***************************************************************************\
* DrawTextW (API)
*
* History:
* 30-11-92 mikeke      Created
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, DrawTextW, HDC, hdc, LPCWSTR, lpchText, int, cchText, LPRECT, lprc, UINT, format)
int DrawTextW(
    HDC hdc,
    LPCWSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format)
{
    DRAWTEXTPARAMS      DTparams;
    LPDRAWTEXTPARAMS    lpDTparams = NULL;

    /* v-ronaar: fix bug #24985
     * Disallow negative string lengths, except -1 (which has special meaning).
     */
    if (cchText < -1)
        return(0);

    if (format & DT_TABSTOP)
    {
        DTparams.cbSize      = sizeof(DRAWTEXTPARAMS);
        DTparams.iLeftMargin = DTparams.iRightMargin = 0;
        DTparams.iTabLength  = (format & 0xff00) >> 8;
        lpDTparams           = &DTparams;
        format              &= 0xffff00ff;
    }

    return DrawTextExW(hdc, (LPWSTR)lpchText, cchText, lprc, format, lpDTparams);
}

/***************************************************************************\
* DrawTextA (API)
*
* History:
* 30-11-92 mikeke      Created
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, int, DUMMYCALLINGTYPE, DrawTextA, HDC, hdc, LPCSTR, lpchText, int, cchText, LPRECT, lprc, UINT, format)
int DrawTextA(
    HDC hdc,
    LPCSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format)
{
    DRAWTEXTPARAMS   DTparams;
    LPDRAWTEXTPARAMS lpDTparams = NULL;

    /* v-ronaar: fix bug #24985
     * Disallow negative string lengths, except -1 (which has special meaning).
     */
    if (cchText < -1)
        return(0);

    if (format & DT_TABSTOP) {
        DTparams.cbSize      = sizeof(DRAWTEXTPARAMS);
        DTparams.iLeftMargin = DTparams.iRightMargin = 0;
        DTparams.iTabLength  = (format & 0xff00) >> 8;
        lpDTparams           = &DTparams;
        format              &= 0xffff00ff;
    }

    return DrawTextExA(hdc, (LPSTR)lpchText, cchText, lprc, format, lpDTparams);
}

/***************************************************************************\
* ClientTabTheTextOutForWimps
*
* effects: Outputs the tabbed text if fDrawTheText is TRUE and returns the
* textextent of the tabbed text.
*
* nCount                    Count of bytes in string
* nTabPositions             Count of tabstops in tabstop array
* lpintTabStopPositions     Tab stop positions in pixels
* iTabOrigin                Tab stops are with respect to this
*
* History:
* 19-Jan-1993 mikeke   Client side
* 13-Sep-1996 GregoryW This routine now calls the LPK(s) to handle text out.
*                      If no LPKs are installed, this defaults to calling
*                      UserLpkTabbedTextOut (identical behavior to what we
*                      had before supporting LPKs).
\***************************************************************************/

LONG TabTextOut(
    HDC hdc,
    int x,
    int y,
    LPCWSTR lpstring,
    int nCount,
    int nTabPositions,
    CONST INT *lpTabPositions,
    int iTabOrigin,
    BOOL fDrawTheText,
    int iCharset)
{
    int     cxCharWidth;
    int     cyCharHeight = 0;

    if (nCount == -1 && lpstring) {
        nCount = wcslen(lpstring);
    }
    if (!lpstring || nCount < 0 || nTabPositions < 0)
        return 0;


    // Check if it is SysFont AND the mapping mode is MM_TEXT;
    // Fix made in connection with Bug #8717 --02-01-90  --SANKAR--
    if (IsSysFontAndDefaultMode(hdc))
    {
        cxCharWidth  = gpsi->cxSysFontChar;
        cyCharHeight = gpsi->cySysFontChar;
    } else {
        cxCharWidth  = GdiGetCharDimensions(hdc, NULL, &cyCharHeight);
        if (cxCharWidth == 0) {
            RIPMSG0(RIP_WARNING, "TabTextOut: GdiGetCharDimensions failed");
            return 0;
        }
    }

    return (*fpLpkTabbedTextOut)(hdc, x, y, lpstring, nCount, nTabPositions,
                                 lpTabPositions, iTabOrigin, fDrawTheText,
                                 cxCharWidth, cyCharHeight, iCharset);
}

LONG UserLpkTabbedTextOut(
    HDC hdc,
    int x,
    int y,
    LPCWSTR lpstring,
    int nCount,
    int nTabPositions,
    CONST INT *lpTabPositions,
    int iTabOrigin,
    BOOL fDrawTheText,
    int cxCharWidth,
    int cyCharHeight,
    int iCharset)
{
    SIZE textextent, viewextent, windowextent;
    int     initialx = x;
    int     cch;
    LPCWSTR  lp;
    int     iOneTab = 0;
    RECT rc;
    UINT uOpaque = (GetBkMode(hdc) == OPAQUE) ? ETO_OPAQUE : 0;
    BOOL    fStrStart = TRUE;
    int     ySign = 1; //Assume y increases in down direction.

    UNREFERENCED_PARAMETER(iCharset);   //Needed by lpk, but not us
    /*
     * If no tabstop positions are specified, then use a default of 8 system
     * font ave char widths or use the single fixed tab stop.
     */
    if (!lpTabPositions) {
       // no tab stops specified -- default to a tab stop every 8 characters
        iOneTab = 8 * cxCharWidth;
    } else if (nTabPositions == 1) {
        // one tab stop specified -- treat value as the tab increment, one
        // tab stop every increment
            iOneTab = lpTabPositions[0];

        if (!iOneTab)
             iOneTab = 1;
    }

    // Calculate if the y increases or decreases in the down direction using
    // the ViewPortExtent and WindowExtents.
    // If this call fails, hdc must be invalid
    if (!GetViewportExtEx(hdc, &viewextent))
        return 0;
    GetWindowExtEx(hdc, &windowextent);
    if ((viewextent.cy ^ windowextent.cy) & 0x80000000)
         ySign = -1;

    rc.left = initialx;
    rc.top = y;
    rc.bottom = rc.top + (ySign * cyCharHeight);

    while (TRUE) {
        // count the number of characters until the next tab character
        // this set of characters (substring) will be the working set for
        // each iteration of this loop
        for (cch = nCount, lp = lpstring; cch && (*lp != TEXT('\t')); lp++, cch--)
        {
        }

        // Compute the number of characters to be drawn with textout.
        cch = nCount - cch;

        // Compute the number of characters remaining.
        nCount -= cch + 1;

        // get height and width of substring
        if (cch == 0) {
            textextent.cx = 0;
            textextent.cy = cyCharHeight;
        } else
            GetTextExtentPointW(hdc, lpstring, cch, &textextent);

        if (fStrStart)
            // first iteration should just spit out the first substring
            // no tabbing occurs until the first tab character is encountered
            fStrStart = FALSE;
        else
        {
           // not the first iteration -- tab accordingly

            int xTab;
            int i;

            if (!iOneTab)
            {
                // look thru tab stop array for next tab stop after existing
                // text to put this substring
                for (i = 0; i < nTabPositions; i++)
                {
                    xTab = lpTabPositions[i];

                    if (xTab < 0)
                        // calc length needed to use this right justified tab
                        xTab = (iTabOrigin - xTab) - textextent.cx;
                    else
                        // calc length needed to use this left  justified tab
                        xTab = iTabOrigin + xTab;

                    if (x < xTab)
                    {
                        // we found a tab with enough room -- let's use it
                        x = xTab;
                        break;
                    }
                }

                if (i == nTabPositions)
                    // we've exhausted all of the given tab positions
                    // go back to default of a tab stop every 8 characters
                    iOneTab = 8 * cxCharWidth;
            }

            // we have to recheck iOneTab here (instead of just saying "else")
            // because iOneTab will be set if we've run out of tab stops
            if (iOneTab)
            {
                if (iOneTab < 0)
                {
                    // calc next available right justified tab stop
                    xTab = x + textextent.cx - iTabOrigin;
                    xTab = ((xTab / iOneTab) * iOneTab) - iOneTab - textextent.cx + iTabOrigin;
                }
                else
                {
                    // calc next available left justified tab stop
                    xTab = x - iTabOrigin;
                    xTab = ((xTab / iOneTab) * iOneTab) + iOneTab + iTabOrigin;
                }
                x = xTab;
            }
        }

        if (fDrawTheText) {

            /*
             * Output all text up to the tab (or end of string) and get its
             * extent.
             */
            rc.right = x + textextent.cx;
            ExtTextOutW(
                    hdc, x, y, uOpaque, &rc, (LPWSTR)lpstring,
                    cch, NULL);
            rc.left = rc.right;
        }

        // Skip over the tab and the characters we just drew.
        x += textextent.cx;

        // Skip over the characters we just drew.
        lpstring += cch;

        // See if we have more to draw OR see if this string ends in
        // a tab character that needs to be drawn.
        if((nCount > 0) || ((nCount == 0) && (*lpstring == TEXT('\t'))))
        {

            lpstring++;  // Skip over the tab
            continue;
        }
        else
            break;        // Break from the loop.
    }
    return MAKELONG((x - initialx), (short)textextent.cy);
}



/***************************************************************************\
*  TabbedTextOutW
*
* effects: Outputs the tabbed text and returns the
* textextent of the tabbed text.
*
* nCount                    Count of bytes in string
* nTabPositions             Count of tabstops in tabstop array
* lpintTabStopPositions     Tab stop positions in pixels
* iTabOrigin                Tab stops are with respect to this
*
* History:
* 19-Jan-1993 mikeke   Client side
\***************************************************************************/

LONG TabbedTextOutW(
    HDC hdc,
    int x,
    int y,
    LPCWSTR lpstring,
    int cchChars,
    int nTabPositions,
    CONST INT *lpintTabStopPositions,
    int iTabOrigin)
{
    return TabTextOut(hdc, x, y, lpstring, cchChars,
        nTabPositions, lpintTabStopPositions, iTabOrigin, TRUE, -1);
}

/***************************************************************************\
* TabbedTextOutA (API)
*
* History:
* 30-11-92 mikeke      Created
\***************************************************************************/

LONG TabbedTextOutA(
    HDC hdc,
    int x,
    int y,
    LPCSTR pString,
    int chCount,
    int nTabPositions,
    CONST INT *pnTabStopPositions,
    int nTabOrigin)
{
    LPWSTR lpwstr;
    BOOL bRet;
    WORD wCodePage = (WORD)GdiGetCodePage(hdc);
    int  iUniString;

    if (chCount == -1) {
        chCount = USER_AWCONV_COUNTSTRINGSZ;
    }

    if ((iUniString = MBToWCSEx(wCodePage, pString, chCount, &lpwstr, -1, TRUE)) == 0) {
        if (chCount == USER_AWCONV_COUNTSTRINGSZ) {
            lpwstr = (LPWSTR)gwszNullStr;
        } else {
            return FALSE;
        }
    }

    bRet = TabTextOut(
            hdc, x, y, lpwstr, iUniString, nTabPositions,
            pnTabStopPositions, nTabOrigin, TRUE, GetTextCharset(hdc));

    if (lpwstr != gwszNullStr) {
        UserLocalFree((HANDLE)lpwstr);
    }

    return bRet;
}

DWORD GetTabbedTextExtentW(
    HDC hdc,
    LPCWSTR pString,
    int chCount,
    int nTabPositions,
    CONST INT *pnTabStopPositions)
{
    return TabTextOut(hdc, 0, 0, pString, chCount,
        nTabPositions, pnTabStopPositions, 0, FALSE, -1);
}

DWORD GetTabbedTextExtentA(
    HDC hdc,
    LPCSTR pString,
    int chCount,
    int nTabPositions,
    CONST INT *pnTabStopPositions)
{
    LPWSTR lpwstr;
    BOOL bRet;
    WORD wCodePage = (WORD)GdiGetCodePage(hdc);
    int iUniString;

    if (chCount == -1) {
        chCount = USER_AWCONV_COUNTSTRINGSZ;
    }
    if ((iUniString = MBToWCSEx(wCodePage, pString, chCount, &lpwstr, -1, TRUE)) == 0) {
        if (chCount == USER_AWCONV_COUNTSTRINGSZ) {
            lpwstr = (LPWSTR)gwszNullStr;
        } else {
            return FALSE;
        }
    }

    bRet = TabTextOut(hdc, 0, 0, lpwstr, iUniString,
        nTabPositions, pnTabStopPositions, 0, FALSE, GetTextCharset(hdc));

    if (lpwstr != gwszNullStr) {
        UserLocalFree((HANDLE)lpwstr);
    }

    return bRet;
}


/***************************************************************************\
* PSMTextOut
*
* Outputs the text and puts and _ below the character with an &
* before it. Note that this routine isn't used for menus since menus
* have their own special one so that it is specialized and faster...
*
* History:
* 11-13-90 JimA         Ported to NT.
* 30-Nov-1992 mikeke    Client side version
* 7-Apr-1998 MCostea    Added dwFlags
\***************************************************************************/

void PSMTextOut(
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR lpsz,
    int cch,
    DWORD dwFlags)
{
    /*
     * By default this is just a call to UserLpkPSMTextOut.  If an
     * LPK is installed, this calls out to the LPK.  The LPK calls
     * UserLpkPSMTextOut, if necessary.
     */
    (*fpLpkPSMTextOut)(hdc, xLeft, yTop, lpsz, cch, dwFlags);
    return;
}

/***************************************************************************\
* UserLpkPSMTextOut
*
* NOTE: A very similar routine (xxxPSMTextOut) exists on the kernel
*       side in text.c.  Any changes to this routine most likely need
*       to be made in xxxPSMTextOut as well.
*
\***************************************************************************/

FUNCLOGVOID6(LOG_GENERAL, DUMMYCALLINGTYPE, UserLpkPSMTextOut, HDC, hdc, int, xLeft, int, yTop, LPWSTR, lpsz, int, cch, DWORD, dwFlags)
void UserLpkPSMTextOut(
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR lpsz,
    int cch,
    DWORD dwFlags)
{
   int cx;
   LONG textsize, result;
   WCHAR achWorkBuffer[255];
   WCHAR *pchOut = achWorkBuffer;
   TEXTMETRICW textMetric;
   SIZE size;
   RECT rc;
   COLORREF color;

   if (cch > sizeof(achWorkBuffer)/sizeof(WCHAR)) {
       pchOut = (WCHAR*)UserLocalAlloc(HEAP_ZERO_MEMORY, (cch+1) * sizeof(WCHAR));
       if (pchOut == NULL)
           return;
   }

   result = GetPrefixCount(lpsz, cch, pchOut, cch);
   /*
    * DT_PREFIXONLY is a new 5.0 option used when switching from keyboard cues off
    *  to on.
    */
   if (!(dwFlags & DT_PREFIXONLY)) {
       TextOutW(hdc, xLeft, yTop, pchOut, cch - HIWORD(result));
   }

   /*
    * Any true prefix characters to underline?
    */
   if (LOWORD(result) == 0xFFFF || dwFlags & DT_HIDEPREFIX) {
       if (pchOut != achWorkBuffer)
           UserLocalFree(pchOut);
       return;
   }

   if (!GetTextMetricsW(hdc, &textMetric)) {
       textMetric.tmOverhang = 0;
       textMetric.tmAscent = 0;
   }

   /*
    * For proportional fonts, find starting point of underline.
    */
   if (LOWORD(result) != 0) {

       /*
        * How far in does underline start (if not at 0th byte.).
        */
       GetTextExtentPointW(hdc, pchOut, LOWORD(result), &size);
       xLeft += size.cx;

       /*
        * Adjust starting point of underline if not at first char and there is
        * an overhang.  (Italics or bold fonts.)
        */
       xLeft = xLeft - textMetric.tmOverhang;
   }

   /*
    * Adjust for proportional font when setting the length of the underline and
    * height of text.
    */
   GetTextExtentPointW(hdc, pchOut + LOWORD(result), 1, &size);
   textsize = size.cx;

   /*
    * Find the width of the underline character.  Just subtract out the overhang
    * divided by two so that we look better with italic fonts.  This is not
    * going to effect embolded fonts since their overhang is 1.
    */
   cx = LOWORD(textsize) - textMetric.tmOverhang / 2;

   /*
    * Get height of text so that underline is at bottom.
    */
   yTop += textMetric.tmAscent + 1;

   /*
    * Draw the underline using the foreground color.
    */
   SetRect(&rc, xLeft, yTop, xLeft+cx, yTop+1);
   color = SetBkColor(hdc, GetTextColor(hdc));
   ExtTextOutW(hdc, xLeft, yTop, ETO_OPAQUE, &rc, TEXT(""), 0, NULL);
   SetBkColor(hdc, color);

   if (pchOut != achWorkBuffer) {
       UserLocalFree(pchOut);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\dlgmgrc.c ===
/****************************** Module Header ******************************\
* Module Name: dlgmgrc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains client side dialog functionality
*
* History:
* 15-Dec-1993 JohnC      Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* UT_PrevGroupItem
*
* History:
\***************************************************************************/

PWND UT_PrevGroupItem(
    PWND pwndDlg,
    PWND pwndCurrent)
{
    PWND pwnd, pwndPrev;

    if (pwndCurrent == NULL || !TestWF(pwndCurrent, WFGROUP))
        return _PrevControl(pwndDlg, pwndCurrent, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);

    pwndPrev = pwndCurrent;

    while (TRUE) {
        pwnd = _NextControl(pwndDlg, pwndPrev, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);

        if (TestWF(pwnd, WFGROUP) || pwnd == pwndCurrent)
            return pwndPrev;

        pwndPrev = pwnd;
    }
}


/***************************************************************************\
* UT_NextGroupItem
*
* History:
\***************************************************************************/

PWND UT_NextGroupItem(
    PWND pwndDlg,
    PWND pwndCurrent)
{
    PWND pwnd, pwndNext;

    pwnd = _NextControl(pwndDlg, pwndCurrent, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);

    if (pwndCurrent == NULL || !TestWF(pwnd, WFGROUP))
        return pwnd;

    pwndNext = pwndCurrent;

    while (!TestWF(pwndNext, WFGROUP)) {
        pwnd = _PrevControl(pwndDlg, pwndNext, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);
        if (pwnd == pwndCurrent)
            return pwndNext;
        pwndNext = pwnd;
    }

    return pwndNext;
}

/***************************************************************************\
* _PrevControl
*
* History:
\***************************************************************************/
PWND _PrevControl(
    PWND pwndRoot,
    PWND pwndStart,
    UINT uFlags)
{
    BOOL fFirstFound;
    PWND pwndNext;
    PWND pwnd, pwndFirst;

    if (!pwndStart)
        return(NULL);

    UserAssert(pwndRoot != pwndStart);
    UserAssert(!TestWF(pwndStart, WEFCONTROLPARENT));

    pwnd = _NextControl(pwndRoot, NULL, uFlags);

    pwndFirst = pwnd;
    fFirstFound = FALSE;
    while (pwndNext = _NextControl(pwndRoot, pwnd, uFlags)) {

        if (pwndNext == pwndStart)
            break;

        if (pwndNext == pwndFirst) {
            if (fFirstFound) {
                RIPMSG0(RIP_WARNING, "_PrevControl: Loop Detected");
                break;
            } else {
                fFirstFound = TRUE;
            }
        }

        pwnd = pwndNext;
    }

    return pwnd;
}
/***************************************************************************\
*
*  GetChildControl()
*
*  Gets valid ancestor of given window.
*  A valid dialog control is a direct descendant of a "form" control.
*
\***************************************************************************/

PWND  _GetChildControl(PWND pwndRoot, PWND pwndChild) {
    PWND    pwndControl = NULL;

    while (pwndChild && TestwndChild(pwndChild) && (pwndChild != pwndRoot)) {
        pwndControl = pwndChild;
        pwndChild = REBASEPWND(pwndChild, spwndParent);

        if (TestWF(pwndChild, WEFCONTROLPARENT))
            break;
    }

    return(pwndControl);
}

/***************************************************************************\
*
*  _NextSibblingOrAncestor
*
* Called by _NextControl. It returns the next control to pwndStart. If there
* is a next window (pwndStart->spwndNext), then that is it.
* Otherwise, the next control is up the parent chain. However, if it's already
* at the top of the chain (pwndRoot == pwndStart->spwndParent), then the next
* control is the first child of pwndRoot. But if it's not at the top of the chain,
* then the next control is pwndStart->spwndParent or an ancestor.
*
\***************************************************************************/
PWND _NextSibblingOrAncestor (PWND pwndRoot, PWND pwndStart)
{
    PWND pwndParent;
#if DBG
    PWND pwndNext;
#endif

    // If there is a sibbling, go for it
    if (pwndStart->spwndNext != NULL) {
        return (REBASEALWAYS(pwndStart, spwndNext));
    }

    // If it cannot go up the parent chain, then return the first sibbling.
    pwndParent = REBASEALWAYS(pwndStart, spwndParent);
    if (pwndParent == pwndRoot) {
        // Note that if pwndStart doesn't have any sibblings,
        //  this will return pwndStart again
        return (REBASEALWAYS(pwndParent, spwndChild));
    }


    // Otherwise walk up the parent chain looking for the first window with
    // a WS_EX_CONTROLPARENT parent.

#if DBG
    pwndNext =
#else
    return
#endif
        _GetChildControl(pwndRoot, pwndParent);

#if DBG
    if ((pwndNext != pwndParent) || !TestWF(pwndParent, WEFCONTROLPARENT)) {
        // Code looping through the controls in a dialog might go into an infinite
        //  loop because of this (i.e., xxxRemoveDefaultButton, _GetNextDlgTabItem,..)
        // We've walked up the parent chain but will never walk down the child chain again
        //  because there is a NON WS_EX_CONTROLPARENT parent window somewhere in the chain.
        RIPMSG0 (RIP_ERROR, "_NextSibblingOrAncestor: Non WS_EX_CONTROLPARENT window in parent chain");
    }
    return pwndNext;
#endif
}
/***************************************************************************\
*
*  _NextControl()
*
* It searches for the next NON WS_EX_CONTROLPARENT control following pwndStart.
* If pwndStart is NULL, the search begins with pwndRoot's first child;
* otherwise, it starts with the control next to pwndStart.
* This is a depth-first search that can start anywhere in the window tree.
* uFlags determine what WS_EX_CONTROLPARENT windows should be skipped or recursed into.
* If skipping a window, the search moves to the next control (see _NextSibblingOrAncestor);
* otherwise, the search walks down the child chain (recursive call).
* If the search fails, it returns pwndRoot.
*
\***************************************************************************/
PWND _NextControl(
    PWND pwndRoot,
    PWND pwndStart,
    UINT uFlags)
{
    BOOL fSkip, fAncestor;
    PWND pwndLast, pwndSibblingLoop;
    /* Bug 272874 - joejo
     *
     * Stop infinite loop by only looping a finite number of times and
     * then bailing.
     */
    int nLoopCount = 0;
    
    UserAssert (pwndRoot != NULL);

    if (pwndStart == NULL) {
        // Start with pwndRoot's first child
        pwndStart = REBASEPWND(pwndRoot, spwndChild);
        pwndLast = pwndStart;
        fAncestor = FALSE;
    } else {
        UserAssert ((pwndRoot != pwndStart) && _IsDescendant(pwndRoot, pwndStart));

        // Save starting handle and get next one
        pwndLast = pwndStart;
        pwndSibblingLoop = pwndStart;
        fAncestor = TRUE;
        goto TryNextOne;
    }


    // If no more controls, game over
    if (pwndStart == NULL) {
        return pwndRoot;
    }

    // Search for a non WS_EX_CONTROLPARENT window; if a window should be skipped,
    // try its spwndNext; otherwise, walk down its child chain.
    pwndSibblingLoop = pwndStart;
    do {
        
        //If not WS_EX_CONTROLPARENT parent, done.
        if (!TestWF(pwndStart, WEFCONTROLPARENT)) {
            return pwndStart;
        }

        // Do they want to skip this window?
        fSkip = ((uFlags & CWP_SKIPINVISIBLE) && !TestWF(pwndStart, WFVISIBLE))
                || ((uFlags & CWP_SKIPDISABLED) && TestWF(pwndStart, WFDISABLED));


        // Remember the current window
        pwndLast = pwndStart;

        // Walk down child chain?
        if (!fSkip && !fAncestor) {
            pwndStart = _NextControl (pwndStart, NULL, uFlags);
            // If it found one, done.
            if (pwndStart != pwndLast) {
                return pwndStart;
            }
        }

TryNextOne:
        // Try the next one.
        pwndStart = _NextSibblingOrAncestor (pwndRoot, pwndStart);
        if (pwndStart == NULL) {
            break;
        }

        // If parents are the same, we are still in the same sibbling chain
        if (pwndLast->spwndParent == pwndStart->spwndParent) {
            // If we had just moved up the parent chain last time around,
            //  mark this as the beginning of the new sibbling chain.
            // Otherwise, check if we've looped through all sibblings already.
            if (fAncestor) {
                // Beggining of new sibbling chain.
                pwndSibblingLoop = pwndStart;
            } else if (pwndStart == pwndSibblingLoop) {
                // Already visited all sibblings, so done.
                break;
            }
            fAncestor = FALSE;
        } else {
            // We must have moved up the parent chain, so don't
            //  walk down the child chain right away (try the next window first)
            // Eventhough we are on a new sibbling chain, we don't update
            // pwndSibblingLoop yet; this is because we must walk down this
            // child chain again to make sure we visit all the descendents
            fAncestor = TRUE;
        }

    /* Bug 272874 - joejo
     *
     * Stop infinite loop by only looping a finite number of times and
     * then bailing.
     */
    } while (nLoopCount++ < 256 * 4);

    // It couldn't find one...
    return pwndRoot;
}

/***************************************************************************\
* GetNextDlgTabItem
*
* History:
* 19-Feb-1991 JimA      Added access check
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, HWND, WINAPI, GetNextDlgTabItem, HWND, hwndDlg, HWND, hwnd, BOOL, fPrev)
HWND WINAPI GetNextDlgTabItem(
    HWND hwndDlg,
    HWND hwnd,
    BOOL fPrev)
{

    PWND pwnd;
    PWND pwndDlg;
    PWND pwndNext;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return NULL;

    if (hwnd != (HWND)0) {
        pwnd = ValidateHwnd(hwnd);

        if (pwnd == NULL)
            return NULL;

    } else {
        pwnd = (PWND)NULL;
    }

    pwndNext = _GetNextDlgTabItem(pwndDlg, pwnd, fPrev);

    return (HW(pwndNext));
}

PWND _GetNextDlgTabItem(
    PWND pwndDlg,
    PWND pwnd,
    BOOL fPrev)
{
    PWND pwndSave;

    if (pwnd == pwndDlg)
        pwnd = NULL;
    else
    {
        pwnd = _GetChildControl(pwndDlg, pwnd);
        if (pwnd && !_IsDescendant(pwndDlg, pwnd))
            return(NULL);
    }

    //
    // BACKWARD COMPATIBILITY
    //
    // Note that the result when there are no tabstops of
    // IGetNextDlgTabItem(pwndDlg, NULL, FALSE) was the last item, now
    // will be the first item.  We could put a check for fRecurse here
    // and do the old thing if not set.
    //

    // We are going to bug out if we hit the first child a second time.

    pwndSave = pwnd;

    pwnd = (fPrev ? _PrevControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED) :
                    _NextControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED));

    if (!pwnd)
        goto AllOver;

    while ((pwnd != pwndSave) && (pwnd != pwndDlg)) {
        UserAssert(pwnd);

        if (!pwndSave)
            pwndSave = pwnd;

        if ((pwnd->style & (WS_TABSTOP | WS_VISIBLE | WS_DISABLED))  == (WS_TABSTOP | WS_VISIBLE))
            // Found it.
            break;

        pwnd = (fPrev ? _PrevControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED) :
                        _NextControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE | CWP_SKIPDISABLED));
    }

AllOver:
    return pwnd;
}

/***************************************************************************\
*
*  _GetNextDlgGroupItem()
*
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetNextDlgGroupItem, HWND, hwndDlg, HWND, hwndCtl, BOOL, bPrevious)
HWND GetNextDlgGroupItem(
    HWND hwndDlg,
    HWND hwndCtl,
    BOOL bPrevious)
{
    PWND pwndDlg;
    PWND pwndCtl;
    PWND pwndNext;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return 0;


    if (hwndCtl != (HWND)0) {
        pwndCtl = ValidateHwnd(hwndCtl);

        if (pwndCtl == NULL)
            return 0;
    } else {
        pwndCtl = (PWND)NULL;
    }

    if (pwndCtl == pwndDlg)
        pwndCtl = pwndDlg;

    pwndNext = _GetNextDlgGroupItem(pwndDlg, pwndCtl, bPrevious);

    return (HW(pwndNext));
}

PWND _GetNextDlgGroupItem(
    PWND pwndDlg,
    PWND pwnd,
    BOOL fPrev)
{
    PWND pwndCurrent;
    BOOL fOnceAround = FALSE;

    pwnd = pwndCurrent = _GetChildControl(pwndDlg, pwnd);

    do {
        pwnd = (fPrev ? UT_PrevGroupItem(pwndDlg, pwnd) :
                        UT_NextGroupItem(pwndDlg, pwnd));

        if (pwnd == pwndCurrent)
            fOnceAround = TRUE;

        if (!pwndCurrent)
            pwndCurrent = pwnd;
    }
    while (!fOnceAround && ((TestWF(pwnd, WFDISABLED) || !TestWF(pwnd, WFVISIBLE))));

    return pwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\eckanji.c ===
/****************************************************************************/
/* */
/* ECKANJI.C -                                                                    */
/* */
/* Copyright (c) 1985 - 1999, Microsoft Corporation */
/* */
/* Kanji Support Routines */
/* */
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef KANJI

/***************************************************************************\
* SysHasKanji
*
* <brief description>
*
* History:
\***************************************************************************/

BOOL SysHasKanji(
    )
{
  return (*(WORD *)&keybdInfo.Begin_First_range != 0x0FEFF ||
          *(WORD *)&keybdInfo.Begin_Second_range != 0x0FEFF);
}

/***************************************************************************\
* KAlign
*
* Make sure the given char isn't the index of the second byte of a Kanji word.
*
* History:
\***************************************************************************/

int KAlign(
     PED ped,
    int ichIn)
{
   int ichCheck;
  int ichOut;
  LPSTR lpch;

  /*
   * ichOut chases ichCheck until ichCheck > ichIn
   */
  if (ped->fSingle)
      ichOut = ichCheck = 0;
  else
      ichOut = ichCheck = ped->mpilich[IlFromIch(ped, ichIn)];

  lpch = ECLock(ped) + ichCheck;
  while (ichCheck <= ichIn) {
      ichOut = ichCheck;
      if (IsTwoByteCharPrefix(*(unsigned char *)lpch))
	{
          lpch++;
          ichCheck++;
        }

      lpch++;
      ichCheck++;
    }
  ECUnlock(ped);
  return (ichOut);
}

/***************************************************************************\
* KBump
*
* If ichMaxSel references Kanji prefix, bump dch by cxChar to bypass prefix
* char. This routine is called only from DoKey in ea1.asm.
*
* History:
\***************************************************************************/

int KBump(
     PED ped,
    int dch)
{
  unsigned char *pch;

  pch = ECLock(ped) + ped->ichMaxSel;
  if (IsTwoByteCharPrefix(*pch))
      dch += ped->cxChar;
  ECUnlock(ped);

  return (dch);
}

/***************************************************************************\
* KCombine
*
* Kanji prefix byte was found in bytestream queue. Get next byte and combine.
*
* History:
\***************************************************************************/

int KCombine(
    HWND hwnd,
    int ch)
{
    MSG msg;
    int i;

    /*
     * Loop counter to avoid the infinite loop.
     */
    i = 10;

    while (!PeekMessage(&msg, hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
        if (--i == 0)
            return 0;
        Yield();
    }

    return (UINT)ch | ((UINT)msg.wParam << 8);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\edecrare.c ===
/****************************************************************************\
* edECRare.c - EC Edit controls Routines Called rarely are to be
* put in a seperate segment _EDECRare. This file contains
* these routines.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Support Routines common to Single-line and Multi-Line edit controls
* called Rarely.
*
* Created: 02-08-89 sankar
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop


extern LOOKASIDE EditLookaside;

#define WS_EX_EDGEMASK (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)

/*
 * Those two macros assume PED can be referred as "ped."
 */
#define GetCharABCWidthsAorW    ((ped)->fAnsi ? GetCharABCWidthsA : GetCharABCWidthsW)
#define GetCharWidthAorW        ((ped)->fAnsi ? GetCharWidthA : GetCharWidthW)

#define umin(a, b)  ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))

typedef BOOL (*PFNABCWIDTHS)(HDC, UINT, UINT, LPABC);
typedef BOOL (*PFNCHARWIDTH)(HDC, UINT, UINT, LPINT);

/***************************************************************************\
*
*  GetMaxOverlapChars - Gives maximum number of overlapping characters due to
*                       negative A or C widths.
*
\***************************************************************************/
DWORD GetMaxOverlapChars( void )
{
    return (DWORD) MAKELONG( gpsi->wMaxLeftOverlapChars, gpsi->wMaxRightOverlapChars ) ;
}

/***************************************************************************\
*
*  ECSetMargin()
*
\***************************************************************************/
void ECSetMargin(PED ped, UINT  wFlags, long lMarginValues, BOOL fRedraw)
{
    BOOL fUseFontInfo = FALSE;
    UINT wValue, wOldLeftMargin, wOldRightMargin;


    if (wFlags & EC_LEFTMARGIN)  /* Set the left margin */ {

        if ((int) (wValue = (int)(short)LOWORD(lMarginValues)) < 0) {
            fUseFontInfo = TRUE;
            wValue = min((ped->aveCharWidth / 2), (int)ped->wMaxNegA);
        }

        ped->rcFmt.left += wValue - ped->wLeftMargin;
        wOldLeftMargin = ped->wLeftMargin;
        ped->wLeftMargin = wValue;
    }

    if (wFlags & EC_RIGHTMARGIN)  /* Set the Right margin */ {

        if ((int) (wValue = (int)(short)HIWORD(lMarginValues)) < 0) {
            fUseFontInfo = TRUE;
            wValue = min((ped->aveCharWidth / 2), (int)ped->wMaxNegC);
        }

        ped->rcFmt.right -= wValue - ped->wRightMargin;
        wOldRightMargin = ped->wRightMargin;
        ped->wRightMargin = wValue;
    }

    if (fUseFontInfo) {
        if (ped->rcFmt.right - ped->rcFmt.left < 2 * ped->aveCharWidth) {
            RIPMSG0(RIP_WARNING, "ECSetMargin: rcFmt is too narrow for EC_USEFONTINFO");

            if (wFlags & EC_LEFTMARGIN)  /* Reset the left margin */ {
                ped->rcFmt.left += wOldLeftMargin - ped->wLeftMargin;
                ped->wLeftMargin = wOldLeftMargin;
            }

            if (wFlags & EC_RIGHTMARGIN)  /* Reset the Right margin */ {
                ped->rcFmt.right -= wOldRightMargin - ped->wRightMargin;
                ped->wRightMargin = wOldRightMargin;
            }

            return;
        }
    }

//    NtUserInvalidateRect(ped->hwnd, NULL, TRUE);
    if (fRedraw) {
        ECInvalidateClient(ped, TRUE);
    }
}

// --------------------------------------------------------------------------
//
//  ECCalcMarginfForDBCSFont()
//
// Jun.24.1996 HideyukN - Ported from Windows95 FarEast version (edecrare.c)
// --------------------------------------------------------------------------
void ECCalcMarginForDBCSFont(PED ped, BOOL fRedraw)
{
    if (!ped->fTrueType)
        return;

    if (!ped->fSingle) {
        // wMaxNegA came from ABC CharWidth.
        if (ped->wMaxNegA != 0) {
            ECSetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                    MAKELONG(EC_USEFONTINFO, EC_USEFONTINFO),fRedraw);
        }
    } else {
        int    iMaxNegA = 0, iMaxNegC = 0;
        int    i;
        PVOID  lpBuffer;
        LPABC  lpABCBuff;
        ABC    ABCInfo;
        HFONT  hOldFont;
        HDC    hdc = NtUserGetDC(ped->hwnd);

        if (!ped->hFont || !(hOldFont = SelectFont(hdc, ped->hFont))) {
            ReleaseDC(ped->hwnd, hdc);
            return;
        }

        if (lpBuffer = UserLocalAlloc(0,sizeof(ABC) * 256)) {
            lpABCBuff = lpBuffer;
            GetCharABCWidthsAorW(hdc, 0, 255, lpABCBuff);
        } else {
            lpABCBuff = &ABCInfo;
            GetCharABCWidthsAorW(hdc, 0, 0, lpABCBuff);
        }

        i = 0;
        while (TRUE) {
            iMaxNegA = min(iMaxNegA, lpABCBuff->abcA);
            iMaxNegC = min(iMaxNegC, lpABCBuff->abcC);
            if (++i == 256)
                break;
            if (lpBuffer) {
                lpABCBuff++;
            } else {
                GetCharABCWidthsAorW(hdc, i, i, lpABCBuff);
            }
        }

        SelectFont(hdc, hOldFont);

        if (lpBuffer) UserLocalFree(lpBuffer);

        ReleaseDC(ped->hwnd, hdc);

        if ((iMaxNegA != 0) || (iMaxNegC != 0))
           ECSetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                    MAKELONG((UINT)(-iMaxNegC), (UINT)(-iMaxNegA)),fRedraw);
    }

    return;
}

// --------------------------------------------------------------------------
//
//  GetCharDimensionsEx(HDC hDC, HFONT hfont, LPTEXTMETRIC lptm, LPINT lpcy)
//
// Jun.24.1996 HideyukN - Ported from Windows95 FarEast version (wmclient.c)
// --------------------------------------------------------------------------

CONST WCHAR AveCharWidthData[] = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
//
// if an app set a font for vertical writing, even though we don't
// handle it with EC, the escapement of tm can be NON 0. Then cxWidth from
// GetCharDimenstions() could be 0 in GetCharDimensions().
// This will break our caller who don't expect 0 at return. So I created
// this entry  for the case the caller set vertical font.
//
//
int UserGetCharDimensionsEx(HDC hDC, HFONT hfont, LPTEXTMETRIC lptm, LPINT lpcy)
{
    int         cxWidth;
    TEXTMETRIC  tm;
    LOGFONTW    lf;
    WCHAR       wchFaceName[LF_FACESIZE];

    //
    // Is this font vertical font ??
    //
    wchFaceName[0] = 0;
    GetTextFaceW(hDC, LF_FACESIZE, wchFaceName);
    if (wchFaceName[0] != L'@') {
        //
        // if not call GDI...
        //
        return(GdiGetCharDimensions(hDC, lptm, lpcy));
    }

    if (!lptm)
        lptm = &tm;

    GetTextMetrics(hDC, lptm);

    // TMPF_FIXED_PITCH
    //
    //   If this bit is set the font is a variable pitch font.
    //   If this bit is clear the font is a fixed pitch font.
    // Note very carefully that those meanings are the opposite of what the constant name implies.
    //
    if (!(lptm->tmPitchAndFamily & TMPF_FIXED_PITCH)) { // If !variable_width font
        // This is fixed pitch font....
        cxWidth = lptm->tmAveCharWidth;
    } else {
        // This is variable pitch font...
        if (hfont && GetObjectW(hfont, sizeof(LOGFONTW), &lf) && (lf.lfEscapement != 0)) {
            cxWidth = lptm->tmAveCharWidth;
        } else {
            SIZE size;
            GetTextExtentPointW(hDC, AveCharWidthData, 52, &size);
            cxWidth = ((size.cx / 26) + 1) / 2;
        }
    }

    if (lpcy)
        *lpcy = lptm->tmHeight;

    return(cxWidth);
}

/***************************************************************************\
* ECGetText AorW
*
* Copies at most maxCchToCopy chars to the buffer lpBuffer. Returns
* how many chars were actually copied. Null terminates the string based
* on the fNullTerminate flag:
* fNullTerminate --> at most (maxCchToCopy - 1) characters will be copied
* !fNullTerminate --> at most (maxCchToCopy) characters will be copied
*
* History:
\***************************************************************************/

ICH ECGetText(
    PED ped,
    ICH maxCchToCopy,
    LPSTR lpBuffer,
    BOOL fNullTerminate)
{
    PSTR pText;

    if (maxCchToCopy) {

        /*
         * Zero terminator takes the extra byte
         */
        if (fNullTerminate)
            maxCchToCopy--;
        maxCchToCopy = min(maxCchToCopy, ped->cch);

        /*
         * Zero terminate the string
         */
        if (ped->fAnsi)
            *(LPSTR)(lpBuffer + maxCchToCopy) = 0;
        else
            *(((LPWSTR)lpBuffer) + maxCchToCopy) = 0;

        pText = ECLock(ped);
        RtlCopyMemory(lpBuffer, pText, maxCchToCopy*ped->cbChar);
        ECUnlock(ped);
    }

    return maxCchToCopy;
}

/***************************************************************************\
* ECNcCreate AorW
*
* History:
\***************************************************************************/

BOOL ECNcCreate(
    PED ped,
    PWND pwnd,
    LPCREATESTRUCT lpCreateStruct)
{
    HWND hwnd = HWq(pwnd);
    BOOL fAnsi;

    fAnsi = TestWF(pwnd, WFANSICREATOR);

    /*
     * Initialize the ped
     */
    ped->fEncoded = FALSE;
    ped->iLockLevel = 0;

    ped->chLines = NULL;
    ped->pTabStops = NULL;
    ped->charWidthBuffer = NULL;
    ped->fAnsi = fAnsi ? 1 : 0; // Force TRUE to be 1 because its a 1 bit field
    ped->cbChar = (WORD)(fAnsi ? sizeof(CHAR) : sizeof(WCHAR));
    ped->hInstance = KHANDLE_TO_HANDLE(pwnd->hModule);
    // IME
    ped->hImcPrev = NULL_HIMC;

    {
        DWORD dwVer = GETEXPWINVER(lpCreateStruct->hInstance);

        ped->fWin31Compat = (dwVer >= 0x030a);
        ped->f40Compat = (dwVer >= 0x0400);
    }

    //
    // NOTE:
    // The order of the following two checks is important.  People can
    // create edit fields with a 3D and a normal border, and we don't
    // want to disallow that.  But we need to detect the "no 3D border"
    // border case too.
    //
    if (TestWF(pwnd, WEFEDGEMASK))
    {
        ped->fBorder = TRUE;
    }
    else if (TestWF(pwnd, WFBORDER))
    {
        ClearWindowState(pwnd, WFBORDER);
        ped->fFlatBorder = TRUE;
        ped->fBorder = TRUE;
    }

    if (!TestWF(pwnd, EFMULTILINE))
        ped->fSingle = TRUE;

    if (TestWF(pwnd, WFDISABLED))
        ped->fDisabled = TRUE;

    if (TestWF(pwnd, EFREADONLY)) {
        if (!ped->fWin31Compat) {
            /*
             * BACKWARD COMPATIBILITY HACK
             *
             * "MileStone" unknowingly sets the ES_READONLY style. So, we strip this
             * style here for all Win3.0 apps (this style is new for Win3.1).
             * Fix for Bug #12982 -- SANKAR -- 01/24/92 --
             */
             ClearWindowState(pwnd, EFREADONLY);
        } else
            ped->fReadOnly = TRUE;
    }


    /*
     * Allocate storage for the text for the edit controls. Storage for single
     * line edit controls will always get allocated in the local data segment.
     * Multiline will allocate in the local ds but the app may free this and
     * allocate storage elsewhere...
     */
    ped->hText = LOCALALLOC(LHND, CCHALLOCEXTRA*ped->cbChar, ped->hInstance);
    if (!ped->hText) {
        FreeLookasideEntry(&EditLookaside, ped);
        NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT); /* No ped for this window */
        return FALSE; /* If no_memory error */
    }

    ped->cchAlloc = CCHALLOCEXTRA;
    ped->lineHeight = 1;

    ped->hwnd = hwnd;
    ped->hwndParent = lpCreateStruct->hwndParent;

    ped->wImeStatus = 0;

    return (BOOL)DefWindowProcWorker(pwnd, WM_NCCREATE, 0,
            (LPARAM)lpCreateStruct, fAnsi);
}

/***************************************************************************\
* ECCreate AorW
*
* History:
\***************************************************************************/

BOOL ECCreate(
    PED ped,
    LONG windowStyle)
{
    HDC hdc;

    /*
     * Get values from the window instance data structure and put them in the
     * ped so that we can access them easier.
     */
    if (windowStyle & ES_AUTOHSCROLL)
        ped->fAutoHScroll = 1;
    if (windowStyle & ES_NOHIDESEL)
        ped->fNoHideSel = 1;

    ped->format = (LOWORD(windowStyle) & LOWORD(ES_FMTMASK));
    if (TestWF(ped->pwnd, WEFRIGHT) && !ped->format)
        ped->format = ES_RIGHT;

    ped->cchTextMax = MAXTEXT; /* Max # chars we will initially allow */

    /*
     * Set up undo initial conditions... (ie. nothing to undo)
     */
    ped->ichDeleted = (ICH)-1;
    ped->ichInsStart = (ICH)-1;
    ped->ichInsEnd = (ICH)-1;

    // initial charset value - need to do this BEFORE MLCreate is called
    // so that we know not to fool with scrollbars if nessacary
    hdc = ECGetEditDC(ped, TRUE);
    ped->charSet = (BYTE)GetTextCharset(hdc);
    ECReleaseEditDC(ped, hdc, TRUE);

    // FE_IME
    // EC_INSERT_COMPOSITION_CHARACTER: ECCreate() - call ECInitInsert()
    ECInitInsert(ped, THREAD_HKL());

    if(ped->pLpkEditCallout = fpLpkEditControl) {
        return ped->pLpkEditCallout->EditCreate(ped, HW(ped->pwnd));
    } else
        return TRUE;
}

/***************************************************************************\
* ECNcDestroyHandler AorW
*
* Destroys the edit control ped by freeing up all memory used by it.
*
* History:
\***************************************************************************/

void ECNcDestroyHandler(
    PWND pwnd,
    PED ped)
{
    PWND pwndParent;

    /*
     * ped could be NULL if WM_NCCREATE failed to create it...
     */
    if (ped) {

        /*
         * Free the text buffer (always present?)
         */
        LOCALFREE(ped->hText, ped->hInstance);

        /*
         * Free up undo buffer and line start array (if present)
         */
        if (ped->hDeletedText != NULL)
            UserGlobalFree(ped->hDeletedText);

        /*
         * Free tab stop buffer (if present)
         */
        if (ped->pTabStops)
            UserLocalFree(ped->pTabStops);

        /*
         * Free line start array (if present)
         */
        if (ped->chLines) {
            UserLocalFree(ped->chLines);
        }

        /*
         * Free the character width buffer (if present)
         */
        if (ped->charWidthBuffer)
            UserLocalFree(ped->charWidthBuffer);

        /*
         * Free the cursor bitmap
         */
        if (ped->pLpkEditCallout && ped->hCaretBitmap) {
            DeleteObject(ped->hCaretBitmap);
        }

        /*
         * Last but not least, free the ped
         */
        FreeLookasideEntry(&EditLookaside, ped);
    }

    /*
     * Set the window's fnid status so that we can ignore rogue messages
     */
    NtUserSetWindowFNID(HWq(pwnd), FNID_CLEANEDUP_BIT);

    /*
     * If we're part of a combo box, let it know we're gone
     */
    pwndParent = REBASEPWND(pwnd, spwndParent);
    if (pwndParent && GETFNID(pwndParent) == FNID_COMBOBOX) {
        ComboBoxWndProcWorker(pwndParent, WM_PARENTNOTIFY,
                MAKELONG(WM_DESTROY, PTR_TO_ID(pwnd->spmenu)), (LPARAM)HWq(pwnd), FALSE);
    }
}

/***************************************************************************\
* ECSetPasswordChar AorW
*
* Sets the password char to display.
*
* History:
\***************************************************************************/

void ECSetPasswordChar(
    PED ped,
    UINT pwchar)
{
    HDC hdc;
    SIZE size;

    ped->charPasswordChar = pwchar;

    if (pwchar) {
        hdc = ECGetEditDC(ped, TRUE);
        if (ped->fAnsi)
            GetTextExtentPointA(hdc, (LPSTR)&pwchar, 1, &size);
        else
            GetTextExtentPointW(hdc, (LPWSTR)&pwchar, 1, &size);

        GetTextExtentPointW(hdc, (LPWSTR)&pwchar, 1, &size);
        ped->cPasswordCharWidth = max(size.cx, 1);
        ECReleaseEditDC(ped, hdc, TRUE);
    }
    if (pwchar)
        SetWindowState(ped->pwnd, EFPASSWORD);
    else
        ClearWindowState(ped->pwnd, EFPASSWORD);

    ECEnableDisableIME(ped);
}

/***************************************************************************\
*  GetNegABCwidthInfo()
*    This function fills up the ped->charWidthBuffer buffer with the
*      negative A,B and C widths for all the characters below 0x7f in the
*      currently selected font.
*  Returns:
* TRUE, if the function succeeded.
* FALSE, if GDI calls to get the char widths have failed.
*
* Note: not used if LPK installed
\***************************************************************************/
BOOL   GetNegABCwidthInfo(
    PED ped,
    HDC hdc)
{
    LPABC lpABCbuff;
    int   i;
    int   CharWidthBuff[CHAR_WIDTH_BUFFER_LENGTH]; // Local char width buffer.
    int   iOverhang;

    if (!GetCharABCWidthsA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, (LPABC)ped->charWidthBuffer)) {
        RIPMSG0(RIP_WARNING, "GetNegABCwidthInfo: GetCharABCWidthsA Failed");
        return FALSE;
    }

   // The (A+B+C) returned for some fonts (eg: Lucida Caligraphy) does not
   // equal the actual advanced width returned by GetCharWidths() minus overhang.
   // This is due to font bugs. So, we adjust the 'B' width so that this
   // discrepancy is removed.
   // Fix for Bug #2932 --sankar-- 02/17/93
   iOverhang = ped->charOverhang;
   GetCharWidthA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, (LPINT)CharWidthBuff);
   lpABCbuff = (LPABC)ped->charWidthBuffer;
   for(i = 0; i < CHAR_WIDTH_BUFFER_LENGTH; i++) {
        lpABCbuff->abcB = CharWidthBuff[i] - iOverhang
                - lpABCbuff->abcA
                - lpABCbuff->abcC;
        lpABCbuff++;
   }

   return(TRUE);
}

/***************************************************************************\
*
*  ECSize() -
*
*  Handle sizing for an edit control's client rectangle.
*  Use lprc as the bounding rectangle if specified; otherwise use the current
*  client rectangle.
*
\***************************************************************************/

void ECSize(
    PED ped,
    LPRECT lprc,
    BOOL fRedraw)
{
    RECT    rc;

    /*
     *  BiDi VB32 Creates an Edit Control and immediately sends a WM_SIZE
     *  message which causes EXSize to be called before ECSetFont, which
     *  in turn causes a divide by zero exception below. This check for
     *  ped->lineHeight will pick it up safely. [samera] 3/5/97
     */
    if(ped->lineHeight == 0)
        return;

    // assume that we won't be able to display the caret
    ped->fCaretHidden = TRUE;


    if ( lprc )
        CopyRect(&rc, lprc);
    else
        _GetClientRect(ped->pwnd, &rc);

    if (!(rc.right - rc.left) || !(rc.bottom - rc.top)) {
        if (ped->rcFmt.right - ped->rcFmt.left)
            return;

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = ped->aveCharWidth * 10;
        rc.bottom   = ped->lineHeight;
    }

    if (!lprc) {
        // subtract the margins from the given rectangle --
        // make sure that this rectangle is big enough to have these margins.
        if ((rc.right - rc.left) > (int)(ped->wLeftMargin + ped->wRightMargin)) {
            rc.left  += ped->wLeftMargin;
            rc.right -= ped->wRightMargin;
        }
    }

    //
    // Leave space so text doesn't touch borders.
    // For 3.1 compatibility, don't subtract out vertical borders unless
    // there is room.
    //
    if (ped->fBorder) {
        int cxBorder = SYSMET(CXBORDER);
        int cyBorder = SYSMET(CYBORDER);

        if (ped->fFlatBorder)
        {
            cxBorder *= 2;
            cyBorder *= 2;
        }

        if (rc.bottom < rc.top + ped->lineHeight + 2*cyBorder)
            cyBorder = 0;

        InflateRect(&rc, -cxBorder, -cyBorder);
    }

    // Is the resulting rectangle too small?  Don't change it then.
    if ((!ped->fSingle) && ((rc.right - rc.left < (int) ped->aveCharWidth) ||
        ((rc.bottom - rc.top) / ped->lineHeight == 0)))
        return;

    // now, we know we're safe to display the caret
    ped->fCaretHidden = FALSE;

    CopyRect(&ped->rcFmt, &rc);

    if (ped->fSingle)
        ped->rcFmt.bottom = min(rc.bottom, rc.top + ped->lineHeight);
    else
        MLSize(ped, fRedraw);

    if (fRedraw) {
        NtUserInvalidateRect(ped->hwnd, NULL, TRUE);
        // UpdateWindow31(ped->hwnd);    Evaluates to NOP in Chicago - Johnl
    }

    // FE_IME
    // ECSize()  - call ECImmSetCompositionWindow()
    //
    // normally this isn't needed because WM_SIZE will cause
    // WM_PAINT and the paint handler will take care of IME
    // composition window. However when the edit window is
    // restored from maximized window and client area is out
    // of screen, the window will not be redrawn.
    //
    if (ped->fFocus && fpImmIsIME(THREAD_HKL())) {
        POINT pt;

        NtUserGetCaretPos(&pt);
        ECImmSetCompositionWindow(ped, pt.x, pt.y);
    }
}

/***************************************************************************\
*
*  ECSetFont AorW () -
*
*  Sets the font used in the edit control.  Warning:  Memory compaction may
*  occur if the font wasn't previously loaded.  If the font handle passed
*  in is NULL, assume the system font.
*
\***************************************************************************/
void   ECSetFont(
    PED ped,
    HFONT hfont,
    BOOL fRedraw)
{
    short  i;
    TEXTMETRIC      TextMetrics;
    HDC             hdc;
    HFONT           hOldFont=NULL;
    UINT            wBuffSize;
    LPINT           lpCharWidthBuff;
    DWORD           dwMaxOverlapChars;
    CHWIDTHINFO     cwi;
    UINT            uExtracharPos;

    hdc = NtUserGetDC(ped->hwnd);

    if (ped->hFont = hfont) {
        //
        // Since the default font is the system font, no need to select it in
        // if that's what the user wants.
        //
        if (!(hOldFont = SelectObject(hdc, hfont))) {
            hfont = ped->hFont = NULL;
        }

        //
        // Get the metrics and ave char width for the currently selected font
        //

        //
        // Call Vertical font-aware AveWidth compute function...
        //
        // FE_SB
        ped->aveCharWidth = UserGetCharDimensionsEx(hdc, hfont, &TextMetrics, &ped->lineHeight);

        /*
         * This might fail when people uses network fonts (or bad fonts).
         */
        if (ped->aveCharWidth == 0) {
            RIPMSG0(RIP_WARNING, "ECSetFont: GdiGetCharDimensions failed");
            if (hOldFont != NULL) {
                SelectObject(hdc, hOldFont);
            }

            /*
             * We've messed up the ped so let's reset the font.
             *  Note that we won't recurse more than once because we'll
             *  pass hfont == NULL.
             * Too bad WM_SETFONT doesn't return a value.
             */
            ECSetFont(ped, NULL, fRedraw);
            return;
        }
    } else {
        ped->aveCharWidth = gpsi->cxSysFontChar;
        ped->lineHeight = gpsi->cySysFontChar;
        TextMetrics = gpsi->tmSysFont;
    }

    ped->charOverhang = TextMetrics.tmOverhang;

    //assume that they don't have any negative widths at all.
    ped->wMaxNegA = ped->wMaxNegC = ped->wMaxNegAcharPos = ped->wMaxNegCcharPos = 0;


    // Check if Proportional Width Font
    //
    // NOTE: as SDK doc says about TEXTMETRIC:
    // TMPF_FIXED_PITCH
    // If this bit is set the font is a variable pitch font. If this bit is clear
    // the font is a fixed pitch font. Note very carefully that those meanings are
    // the opposite of what the constant name implies.
    //
    // Thus we have to reverse the value using logical not (fNonPropFont has 1 bit width)
    //
    ped->fNonPropFont = !(TextMetrics.tmPitchAndFamily & FIXED_PITCH);

    // Check for a TrueType font
    // Older app OZWIN chokes if we allocate a bigger buffer for TrueType fonts
    // So, for apps older than 4.0, no special treatment for TrueType fonts.
    if (ped->f40Compat && (TextMetrics.tmPitchAndFamily & TMPF_TRUETYPE)) {
        ped->fTrueType = GetCharWidthInfo(hdc, &cwi);
#if DBG
        if (!ped->fTrueType) {
            RIPMSG0(RIP_WARNING, "ECSetFont: GetCharWidthInfo Failed");
        }
#endif
    } else {
        ped->fTrueType = FALSE;
    }

    // FE_SB
    //
    // In DBCS Windows, Edit Control must handle Double Byte Character
    // if tmCharSet field of textmetrics is double byte character set
    // such as SHIFTJIS_CHARSET(128:Japan), HANGEUL_CHARSET(129:Korea).
    //
    // We call ECGetDBCSVector even when fAnsi is false so that we could
    // treat ped->fAnsi and ped->fDBCS indivisually. I changed ECGetDBCSVector
    // function so that it returns 0 or 1, because I would like to set ped->fDBCS
    // bit field here.
    //
    ped->fDBCS = ECGetDBCSVector(ped,hdc,TextMetrics.tmCharSet);
    ped->charSet = TextMetrics.tmCharSet;

    if (ped->fDBCS) {
        //
        // Free the character width buffer if ped->fDBCS.
        //
        // I expect single GetTextExtentPoint call is faster than multiple
        // GetTextExtentPoint call (because the graphic engine has a cache buffer).
        // See editec.c/ECTabTheTextOut().
        //
        if (ped->charWidthBuffer) {
            LocalFree(ped->charWidthBuffer);
            ped->charWidthBuffer = NULL;
        }

        //
        // if FullWidthChar : HalfWidthChar == 2 : 1....
        //
        // TextMetrics.tmMaxCharWidth = FullWidthChar width
        // ped->aveCharWidth          = HalfWidthChar width
        //
        if (ped->fNonPropFont &&
            ((ped->aveCharWidth * 2) == TextMetrics.tmMaxCharWidth)) {
            ped->fNonPropDBCS = TRUE;
        } else {
            ped->fNonPropDBCS = FALSE;
        }

    } else {

        //
        // Since the font has changed, let us obtain and save the character width
        // info for this font.
        //
        // First left us find out if the maximum chars that can overlap due to
        // negative widths. Since we can't access USER globals, we make a call here.
        //
        if (!(ped->fSingle || ped->pLpkEditCallout)) {  // Is this a multiline edit control with no LPK present?
            //
            // For multiline edit controls, we maintain a buffer that contains
            // the character width information.
            //
            wBuffSize = (ped->fTrueType) ? (CHAR_WIDTH_BUFFER_LENGTH * sizeof(ABC)) :
                                           (CHAR_WIDTH_BUFFER_LENGTH * sizeof(int));

            if (ped->charWidthBuffer) { /* If buffer already present */
                lpCharWidthBuff = ped->charWidthBuffer;
                ped->charWidthBuffer = UserLocalReAlloc(lpCharWidthBuff, wBuffSize, HEAP_ZERO_MEMORY);
                if (ped->charWidthBuffer == NULL) {
                    UserLocalFree((HANDLE)lpCharWidthBuff);
                }
            } else {
                ped->charWidthBuffer = UserLocalAlloc(HEAP_ZERO_MEMORY, wBuffSize);
            }

            if (ped->charWidthBuffer != NULL) {
                if (ped->fTrueType) {
                    ped->fTrueType = GetNegABCwidthInfo(ped, hdc);
                }

                /*
                 * It is possible that the above attempts could have failed and reset
                 * the value of fTrueType. So, let us check that value again.
                 */
                if (!ped->fTrueType) {
                    if (!GetCharWidthA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, ped->charWidthBuffer)) {
                        UserLocalFree((HANDLE)ped->charWidthBuffer);
                        ped->charWidthBuffer=NULL;
                    } else {
                        /*
                         * We need to subtract out the overhang associated with
                         * each character since GetCharWidth includes it...
                         */
                        for (i=0;i < CHAR_WIDTH_BUFFER_LENGTH;i++)
                            ped->charWidthBuffer[i] -= ped->charOverhang;
                    }
                }
            } /* if (ped->charWidthBuffer != NULL) */
        } /* if (!ped->fSingle) */
    } /* if (ped->fDBCS) */

    {
        /*
         * Calculate MaxNeg A C metrics
         */
        dwMaxOverlapChars = GetMaxOverlapChars();
        if (ped->fTrueType) {
            if (cwi.lMaxNegA < 0)
                ped->wMaxNegA = -cwi.lMaxNegA;
            else
                ped->wMaxNegA = 0;
            if (cwi.lMaxNegC < 0)
                ped->wMaxNegC = -cwi.lMaxNegC;
            else
                ped->wMaxNegC = 0;
            if (cwi.lMinWidthD != 0) {
                ped->wMaxNegAcharPos = (ped->wMaxNegA + cwi.lMinWidthD - 1) / cwi.lMinWidthD;
                ped->wMaxNegCcharPos = (ped->wMaxNegC + cwi.lMinWidthD - 1) / cwi.lMinWidthD;
                if (ped->wMaxNegA + ped->wMaxNegC > (UINT)cwi.lMinWidthD) {
                    uExtracharPos = (ped->wMaxNegA + ped->wMaxNegC - 1) / cwi.lMinWidthD;
                    ped->wMaxNegAcharPos += uExtracharPos;
                    ped->wMaxNegCcharPos += uExtracharPos;
                }
            } else {
                ped->wMaxNegAcharPos = LOWORD(dwMaxOverlapChars);     // Left
                ped->wMaxNegCcharPos = HIWORD(dwMaxOverlapChars);     // Right
            }

        } else if (ped->charOverhang != 0) {
            /*
             * Some bitmaps fonts (i.e., italic) have under/overhangs;
             *  this is pretty much like having negative A and C widths.
             */
            ped->wMaxNegA = ped->wMaxNegC = ped->charOverhang;
            ped->wMaxNegAcharPos = LOWORD(dwMaxOverlapChars);     // Left
            ped->wMaxNegCcharPos = HIWORD(dwMaxOverlapChars);     // Right
        }
    } /* if (ped->fDBCS) */

    if (!hfont) {
        //
        // We are getting the stats for the system font so update the system
        // font fields in the ed structure since we use these when calculating
        // some spacing.
        //
        ped->cxSysCharWidth = ped->aveCharWidth;
        ped->cySysCharHeight= ped->lineHeight;
    } else if (hOldFont)
        SelectObject(hdc, hOldFont);

    if (ped->fFocus) {
        //
        // Update the caret.
        //
        NtUserHideCaret(ped->hwnd);
        NtUserDestroyCaret();

        if (ped->pLpkEditCallout) {
            ped->pLpkEditCallout->EditCreateCaret (ped, hdc, ECGetCaretWidth(), ped->lineHeight, 0);
        }
        else {
            NtUserCreateCaret(ped->hwnd, (HBITMAP)NULL, ECGetCaretWidth(), ped->lineHeight);
        }
        NtUserShowCaret(ped->hwnd);
    }

    ReleaseDC(ped->hwnd, hdc);

    //
    // Update password character.
    //
    if (ped->charPasswordChar)
        ECSetPasswordChar(ped, ped->charPasswordChar);

    //
    // If it is a TrueType font and it's a new app, set both the margins at the
    // max negative width values for all types of the edit controls.
    // (NOTE: Can't use ped->f40Compat here because edit-controls inside dialog
    // boxes without DS_LOCALEDIT style are always marked as 4.0 compat.
    // This is the fix for NETBENCH 3.0)
    //

    if (ped->fTrueType && (GETAPPVER() >= VER40))
        if (ped->fDBCS) {
            // For DBCS TrueType Font, we calc margin from ABC width.
            ECCalcMarginForDBCSFont(ped, fRedraw);
        } else {
            ECSetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                        MAKELONG(EC_USEFONTINFO, EC_USEFONTINFO), fRedraw);
        }

    //
    // We need to calc maxPixelWidth when font changes.
    // If the word-wrap is ON, then this is done in MLSize() called later.
    //
    if((!ped->fSingle) && (!ped->fWrap))
        MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);

    //
    // Recalc the layout.
    //
    ECSize(ped, NULL, fRedraw);

    if ( ped->fFocus && fpImmIsIME(THREAD_HKL()) ) {
        ECImmSetCompositionFont( ped );
    }
}



/***************************************************************************\
*
*  ECIsCharNumeric AorW () -
*
*  Tests whether the character entered is a numeral.
*  For multiline and singleline edit controls with the ES_NUMBER style.
*
\***************************************************************************/
BOOL ECIsCharNumeric(
    PED ped,
    DWORD keyPress)
{
    WORD wCharType;

    if (ped->fAnsi) {
        char ch = (char)keyPress;
        LCID lcid = (LCID)((ULONG_PTR)THREAD_HKL() & 0xFFFF);
        GetStringTypeA(lcid, CT_CTYPE1, &ch, 1, &wCharType);
    } else {
        WCHAR wch = (WCHAR)keyPress;
        GetStringTypeW(CT_CTYPE1, &wch, 1, &wCharType);
    }
    return (wCharType & C1_DIGIT ? TRUE : FALSE);
}

/***************************************************************************\
*
*  ECEnableDisableIME( PED ped )
*
*
*  xx/xx/9x by somebody     Created for Win95
*  xx/xx/95 by kazum        Ported to NT-J 3.51
*  04/15/96 by takaok       Ported to NT 4.0
*
\***************************************************************************/
VOID ECEnableDisableIME( PED ped )
{
    if ( ped->fReadOnly || ped->charPasswordChar ) {
    //
    // IME should be disabled
    //
        HIMC hImc;
        hImc = fpImmGetContext( ped->hwnd );

        if ( hImc != NULL_HIMC ) {
            fpImmReleaseContext( ped->hwnd, hImc );
            ped->hImcPrev = fpImmAssociateContext( ped->hwnd, NULL_HIMC );
        }

    } else {
    //
    // IME should be enabled
    //
        if ( ped->hImcPrev != NULL_HIMC ) {
            ped->hImcPrev = fpImmAssociateContext( ped->hwnd, ped->hImcPrev );

            //
            // Font and the caret position might be changed while
            // IME was being disabled. Set those now if the window
            // has the focus.
            //
            if ( ped->fFocus ) {
                POINT pt;

                ECImmSetCompositionFont( ped );

                NtUserGetCaretPos( &pt );
                ECImmSetCompositionWindow( ped, pt.x, pt.y  );
            }
        }
    }
    ECInitInsert(ped, THREAD_HKL());
}


/***************************************************************************\
*
*  ECImmSetCompositionWindow( PED ped, LONG x, LONG y )
*
*  xx/xx/9x by somebody     Created for Win95
*  xx/xx/95 by kazum        Ported to NT-J 3.51
*  04/15/96 by takaok       Ported to NT 4.0
\***************************************************************************/
VOID ECImmSetCompositionWindow( PED ped, LONG x, LONG y )
{
    COMPOSITIONFORM cf;
    COMPOSITIONFORM cft;
    RECT rcScreenWindow;
    HIMC hImc;

    hImc = fpImmGetContext( ped->hwnd );
    if ( hImc != NULL_HIMC ) {

        if ( ped->fFocus ) {
            GetWindowRect( ped->hwnd, &rcScreenWindow);
            // assuming RECT.left is the first and and RECT.top is the second field
            MapWindowPoints( ped->hwnd, HWND_DESKTOP, (LPPOINT)&rcScreenWindow, 2);
            if (ped->fInReconversion) {
                DWORD dwPoint = (DWORD)(ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_POSFROMCHAR, ped->ichMinSel, 0);

                x = GET_X_LPARAM(dwPoint);
                y = GET_Y_LPARAM(dwPoint);

                RIPMSG2(RIP_WARNING, "ECImmSetCompositionWindow: fInReconversion (%d,%d)", x, y);
            }
            //
            // The window currently has the focus.
            //
            if (ped->fSingle) {
                //
                // Single line edit control.
                //
                cf.dwStyle = CFS_POINT;
                cf.ptCurrentPos.x = x;
                cf.ptCurrentPos.y = y;
                SetRectEmpty(&cf.rcArea);

            } else {
                //
                // Multi line edit control.
                //
                cf.dwStyle = CFS_RECT;
                cf.ptCurrentPos.x = x;
                cf.ptCurrentPos.y = y;
                cf.rcArea = ped->rcFmt;
            }
            fpImmGetCompositionWindow( hImc, &cft );
            if ( (!RtlEqualMemory(&cf,&cft,sizeof(COMPOSITIONFORM))) ||
                 (ped->ptScreenBounding.x != rcScreenWindow.left)    ||
                 (ped->ptScreenBounding.y  != rcScreenWindow.top) ) {

                ped->ptScreenBounding.x = rcScreenWindow.left;
                ped->ptScreenBounding.y = rcScreenWindow.top;
                fpImmSetCompositionWindow( hImc, &cf );
            }
        }
        fpImmReleaseContext( ped->hwnd, hImc );
    }
}

/***************************************************************************\
*
*  ECImmSetCompositionFont( PED ped )
*
*  xx/xx/9x by somebody     Created for Win95
*  xx/xx/95 by kazum        Ported to NT-J 3.51
*  04/15/96 by takaok       Ported to NT 4.0
\***************************************************************************/
VOID  ECImmSetCompositionFont( PED ped )
{
    HIMC hImc;
    LOGFONTW lf;

    if ( (hImc = fpImmGetContext( ped->hwnd )) != NULL_HIMC ) {

        if (ped->hFont) {
            GetObjectW( ped->hFont,
                        sizeof(LOGFONTW),
                        (LPLOGFONTW)&lf);
        } else {
            GetObjectW( GetStockObject(SYSTEM_FONT),
                        sizeof(LOGFONTW),
                        (LPLOGFONTW)&lf);
        }
        fpImmSetCompositionFontW( hImc, &lf );
        fpImmReleaseContext( ped->hwnd, hImc );
    }
}


/***************************************************************************\
*
*  ECInitInsert( PED ped, HKL hkl )
*
*  this function is called when:
*  1) a edit control window is initialized
*  2) active keyboard layout of current thread is changed
*  3) read only attribute of this edit control is changed
*
*  04/15/96 by takaok       Created
\***************************************************************************/
VOID ECInitInsert( PED ped, HKL hkl )
{
    ped->fKorea = FALSE;
    ped->fInsertCompChr = FALSE;
    ped->fNoMoveCaret = FALSE;
    ped->fResultProcess = FALSE;

    if ( fpImmIsIME(hkl) ) {
        if (  PRIMARYLANGID(LOWORD(HandleToUlong(hkl))) == LANG_KOREAN ) {

            ped->fKorea = TRUE;
        }
        //
        // LATER:this flag should be set based on the IME caps
        // retrieved from IME. (Such IME caps should be defined)
        // For now, we can safely assume that only Korean IMEs
        // set CS_INSERTCHAR.
        //
        if ( ped->fKorea ) {
            ped->fInsertCompChr = TRUE;
        }
    }

    //
    // if we had a composition character, the shape of caret
    // is changed. We need to reset the caret shape.
    //
    if ( ped->fReplaceCompChr ) {
        ped->fReplaceCompChr = FALSE;
        ECSetCaretHandler( ped );
    }
}

/***************************************************************************\
*
*  ECSetCaretHandler( PED ped )
*
* History:
*       07/16/96 by takaok      ported from NT 3.51
*
\***************************************************************************/

void ECSetCaretHandler(PED ped)
{
    HDC     hdc;
    SIZE    size;
    PSTR    pText;

//    if (!ped->fInsertCompChr || ped->fReadOnly)
//        return;

    // In any case destroy caret beforehand otherwise SetCaretPos()
    // will get crazy.. win95d-B#992,B#2370
    //
    if (ped->fFocus) {

        NtUserHideCaret(ped->hwnd);
        DestroyCaret();
        if ( ped->fReplaceCompChr ) {

            hdc = ECGetEditDC(ped, TRUE );
            pText = ECLock(ped);

            if ( ped->fAnsi)
                 GetTextExtentPointA(hdc, pText + ped->ichCaret, 2, &size);
            else
                 GetTextExtentPointW(hdc, (LPWSTR)pText + ped->ichCaret, 1, &size);

            ECUnlock(ped);
            ECReleaseEditDC(ped, hdc, TRUE);

            CreateCaret(ped->hwnd, (HBITMAP)NULL, size.cx, ped->lineHeight);
        }
        else {
            CreateCaret(ped->hwnd,
                        (HBITMAP)NULL,
                        (ped->cxSysCharWidth > ped->aveCharWidth ? 1 : 2),
                        ped->lineHeight);
        }

        hdc = ECGetEditDC(ped, TRUE );
        if ( ped->fSingle )
            SLSetCaretPosition( ped, hdc );
        else
            MLSetCaretPosition( ped, hdc );
        ECReleaseEditDC(ped, hdc, TRUE);
        NtUserShowCaret(ped->hwnd);
    }
}


/***************************************************************************\
*
* LONG ECImeCompoistion( PED ped, WPARAM wParam, LPARAM lParam )
*
* WM_IME_COMPOSITION handler for Korean IME
*
* History:
\***************************************************************************/

extern void MLReplaceSel(PED, LPSTR);

#define GET_COMPOSITION_STRING  (ped->fAnsi ? fpImmGetCompositionStringA : fpImmGetCompositionStringW)

BOOL FAR PASCAL ECResultStrHandler(PED ped)
{
    HIMC himc;
    LPSTR lpStr;
    LONG dwLen;

    ped->fInsertCompChr = FALSE;    // clear the state
    ped->fNoMoveCaret = FALSE;

    if ((himc = fpImmGetContext(ped->hwnd)) == 0) {
        return FALSE;
    }

    dwLen = GET_COMPOSITION_STRING(himc, GCS_RESULTSTR, NULL, 0);

    if (dwLen == 0) {
        fpImmReleaseContext(ped->hwnd, himc);
        return FALSE;
    }

    dwLen *= ped->cbChar;
    dwLen += ped->cbChar;

    lpStr = (LPSTR)UserGlobalAlloc(GPTR, dwLen);
    if (lpStr == NULL) {
        fpImmReleaseContext(ped->hwnd, himc);
        return FALSE;
    }

    GET_COMPOSITION_STRING(himc, GCS_RESULTSTR, lpStr, dwLen);

    if (ped->fSingle) {
        SLReplaceSel(ped, lpStr);
    } else {
        MLReplaceSel(ped, lpStr);
    }

    UserGlobalFree((HGLOBAL)lpStr);

    fpImmReleaseContext(ped->hwnd, himc);

    ped->fReplaceCompChr = FALSE;
    ped->fNoMoveCaret = FALSE;
    ped->fResultProcess = FALSE;

    ECSetCaretHandler(ped);

    return TRUE;
}

LRESULT ECImeComposition(PED ped, WPARAM wParam, LPARAM lParam)
{
    INT ich;
    LRESULT lReturn = 1;
    HDC hdc;
    BOOL fSLTextUpdated = FALSE;
    ICH iResult;
    HIMC hImc;
    BYTE TextBuf[4];

    if (!ped->fInsertCompChr) {
        if (lParam & GCS_RESULTSTR) {
            ECInOutReconversionMode(ped, FALSE);

            if (ped->wImeStatus & EIMES_GETCOMPSTRATONCE) {
ResultAtOnce:
                ECResultStrHandler(ped);
                lParam &= ~GCS_RESULTSTR;
            }
        }
        return DefWindowProcWorker(ped->pwnd, WM_IME_COMPOSITION, wParam, lParam, ped->fAnsi);
    }

    // In case of Ansi edit control, the length of minimum composition string
    // is 2. Check here maximum byte of edit control.
    if( ped->fAnsi && ped->cchTextMax == 1 ) {
        HIMC hImc;

        hImc = fpImmGetContext( ped->hwnd );
        fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0L);
        fpImmReleaseContext( ped->hwnd, hImc );
        NtUserMessageBeep(MB_ICONEXCLAMATION);
        return lReturn;
    }

    // Don't move this after CS_NOMOVECARET check.
    // In case if skip the message, fNoMoveCaret should not be set.
    if ((lParam & CS_INSERTCHAR) && ped->fResultProcess) {

        // Now we're in result processing. GCS_RESULTSTR ends up
        // to WM_IME_CHAR and WM_CHAR. Since WM_CHAR is posted,
        // the message(s) will come later than this CS_INSERTCHAR
        // message. This composition character should be handled
        // after the WM_CHAR message(s).
        //
        if(ped->fAnsi)
            PostMessageA(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
        else
            PostMessageW(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
        ped->fResultProcess = FALSE;
        return lReturn;
    }

//
// If fReplaceCompChr is TRUE, we change the shape of caret. A block
// caret is displayed on the composition character. From the user's
// point of view, there is no difference if the caret is before the
// composition character or after the composition character. When
// the composition character is finalized, the insertion point should
// be moved to after the character, any way. Therefore checking
// CS_NOMOVECARET bit doesn't make sense in our current implementation.
// [takaok]
//
#if 0
    if (lParam & CS_NOMOVECARET)
        ped->fNoMoveCaret=TRUE;   // stick to current caret pos.
    else
        ped->fNoMoveCaret=FALSE;
#endif

    if (lParam & GCS_RESULTSTR) {

        if (ped->wImeStatus & EIMES_GETCOMPSTRATONCE) {
            goto ResultAtOnce;
        }

        ped->fResultProcess=TRUE;
        if ( ped->fReplaceCompChr ) {
            //
            // we have a DBCS character to be replaced.
            // let's delete it before inserting the new one.
            //
            ich = (ped->fAnsi) ? 2 : 1;
            ped->fReplaceCompChr = FALSE;
            ped->ichMaxSel = min(ped->ichCaret + ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;
            if ( ECDeleteText( ped ) > 0 ) {
                if ( ped->fSingle ) {
                    //
                    // Update the display
                    //
                    ECNotifyParent(ped, EN_UPDATE);
                    hdc = ECGetEditDC(ped,FALSE);
                    SLDrawText(ped, hdc, 0);
                    ECReleaseEditDC(ped,hdc,FALSE);
                    //
                    // Tell parent our text contents changed.
                    //
                    ECNotifyParent(ped, EN_CHANGE);
                }
            }
            ECSetCaretHandler( ped );
        }

    } else if(lParam & CS_INSERTCHAR) {

        //
        // If we are in the middle of a mousedown command, don't do anything.
        //
        if (ped->fMouseDown) {
            return lReturn;
        }

        //
        // We can safely assume that interimm character is always DBCS.
        //
        ich = ( ped->fAnsi ) ? 2 : 1;

        if ( ped->fReplaceCompChr ) {
            //
            // we have a character to be replaced.
            // let's delete it before inserting the new one.
            // when we have a composition characters, the
            // caret is placed before the composition character.
            //
            ped->ichMaxSel = min(ped->ichCaret+ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;
        }

        //
        // let's delete current selected text or composition character
        //
        if ( ped->fSingle ) {
            if ( ECDeleteText( ped ) > 0 ) {
                fSLTextUpdated = TRUE;
            }
        } else {
            MLDeleteText( ped );
        }

        //
        // When the composition charcter is canceled, IME may give us NULL wParam,
        // with CS_INSERTCHAR flag on. We shouldn't insert a NULL character.
        //
        if ( wParam != 0 ) {

            if ( ped->fAnsi ) {
                TextBuf[0] = HIBYTE(LOWORD(wParam)); // leading byte
                TextBuf[1] = LOBYTE(LOWORD(wParam)); // trailing byte
                TextBuf[2] = '\0';
            } else {
                TextBuf[0] = LOBYTE(LOWORD(wParam));
                TextBuf[1] = HIBYTE(LOWORD(wParam));
                TextBuf[2] = '\0';
                TextBuf[3] = '\0';
            }

            if ( ped->fSingle ) {

                iResult = SLInsertText( ped, (LPSTR)TextBuf, ich );
                if (iResult == 0) {
                    /*
                     * Couldn't insert the text, for e.g. the text exceeded the limit.
                     */
                    NtUserMessageBeep(0);
                } else if (iResult > 0) {
                    /*
                     * Remember we need to update the text.
                     */
                    fSLTextUpdated = TRUE;
                }

            } else {

                iResult = MLInsertText( ped, (LPSTR)TextBuf, ich, TRUE);
            }

            if ( iResult > 0 ) {
                //
                // ped->fReplaceCompChr will be reset:
                //
                // 1) when the character is finalized.
                //    we will receive GCS_RESULTSTR
                //
                // 2) when the character is canceled.
                //
                //    we will receive WM_IME_COMPOSITION|CS_INSERTCHAR
                //    with wParam == 0 (in case of user types backspace
                //    at the first element of composition character).
                //
                //      or
                //
                //    we will receive WM_IME_ENDCOMPOSITION message
                //
                ped->fReplaceCompChr = TRUE;

                //
                // Caret should be placed BEFORE the composition
                // character.
                //
                ped->ichCaret = max( 0, (INT)(ped->ichCaret - ich));
                ECSetCaretHandler( ped );
            } else {

                //
                // We failed to insert a character. We might run out
                // of memory, or reached to the text size limit. let's
                // cancel the composition character.
                //
                hImc = fpImmGetContext(ped->hwnd);
                fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                fpImmReleaseContext(ped->hwnd, hImc);

                ped->fReplaceCompChr = FALSE;
                ECSetCaretHandler( ped );
            }
        } else {
            //
            // the composition character is canceled.
            //
            ped->fReplaceCompChr = FALSE;
            ECSetCaretHandler( ped );
        }

        //
        // We won't notify parent the text change
        // because the composition character has
        // not been finalized.
        //
        if ( fSLTextUpdated ) {

            //
            // Update the display
            //
            ECNotifyParent(ped, EN_UPDATE);

            hdc = ECGetEditDC(ped,FALSE);

            if ( ped->fReplaceCompChr ) {
                //
                // move back the caret to the original position
                // temporarily so that our new block cursor can
                // be located within the visible area of window.
                //
                ped->ichCaret = min( ped->cch, ped->ichCaret + ich);
                SLScrollText(ped, hdc);
                ped->ichCaret = max( 0, (INT)(ped->ichCaret - ich));
            } else {
                SLScrollText(ped, hdc);
            }
            SLDrawText(ped, hdc, 0);

            ECReleaseEditDC(ped,hdc,FALSE);

            //
            // Tell parent our text contents changed.
            //
            ECNotifyParent(ped, EN_CHANGE);
        }
        return lReturn;
    }

    return DefWindowProcWorker(ped->pwnd, WM_IME_COMPOSITION, wParam, lParam, ped->fAnsi);
}


#ifdef LATER    // fyi: window 98 equiv.
LRESULT ECImeComposition(PED ped, WPARAM wParam, LPARAM lParam)
{
    INT ich;
    LRESULT lReturn = 1;
    HDC hdc;
    BOOL fSLTextUpdated = FALSE;
    ICH iResult;
    HIMC hImc;
    BYTE TextBuf[4];

    // In case of Ansi edit control, the length of minimum composition string
    // is 2. Check here maximum byte of edit control.
    if( ped->fAnsi && ped->cchTextMax == 1 ) {
        HIMC hImc;

        hImc = fpImmGetContext( ped->hwnd );
        fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0L);
        fpImmReleaseContext( ped->hwnd, hImc );
        MessageBeep(MB_ICONEXCLAMATION);
        return lReturn;
    }

    // Don't move this after CS_NOMOVECARET check.
    // In case if skip the message, fNoMoveCaret should not be set.
    if ((lParam & CS_INSERTCHAR) && ped->fResultProcess) {

        // Now we're in result processing. GCS_RESULTSTR ends up
        // to WM_IME_CHAR and WM_CHAR. Since WM_CHAR is posted,
        // the message(s) will come later than this CS_INSERTCHAR
        // message. This composition character should be handled
        // after the WM_CHAR message(s).
        //
        (ped->fAnsi ? PostMessageA : PostMessageW)(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
        ped->fResultProcess = FALSE;
        return lReturn;
    }

    ped->fNoMoveCaret = (lParam & CS_NOMOVECARET) != 0;

    if (lParam & GCS_RESULTSTR) {
        ECInOutReconversionMode(ped, FALSE);

        if (ped->wImeStatus & EIMS_GETCOMPSTRATONCE) {
            ECGetCompStrAtOnce(ped);

            goto PassToDefaultWindowProc;
        }

        // Getting into result processing
        ped->fResultProcess = TRUE;
    }
    else if (lParam & CS_INSERTCHAR) {
        ped->fInsertCompChr = TRUE; // Process this composition character.

        (ped->fSingleLine ? SLChar : MLChar)(ped, wParam, 0);

        if (ped->fInsretCompChr) {
            ped->fReplaceCompChr = TRUE;    // The next character will replace this.
            ped->fInsertCompChr = FALSE;    // Clear the state for the next character.
        }

        ECSetCaretHandler(ped);
        return 0;
    }

PassToDefaultWindowProc:
    return DefWindowProcWorker(ped->pwnd, WM_IME_COMPOSITION, wParam, lParam, ped->fAnsi);
}
#endif


/***************************************************************************\
*
* BOOL HanjaKeyHandler( PED ped )
*
* VK_HANJA handler - Korean only
*
* History: July 15,1996 takaok  ported from NT 3.51
\***************************************************************************/
BOOL HanjaKeyHandler( PED ped )
{
    BOOL changeSelection = FALSE;

    if (ped->fKorea && !ped->fReadOnly) {
        ICH oldCaret = ped->ichCaret;

        if (ped->fReplaceCompChr)
                return FALSE;

        if (ped->ichMinSel < ped->ichMaxSel)
            ped->ichCaret = ped->ichMinSel;

        if (!ped->cch || ped->cch == ped->ichCaret) {
            ped->ichCaret = oldCaret;
            NtUserMessageBeep(MB_ICONEXCLAMATION);
            return FALSE;
        }

        if (ped->fAnsi) {
            if (fpImmEscapeA(THREAD_HKL(), fpImmGetContext(ped->hwnd),
                IME_ESC_HANJA_MODE, (ECLock(ped) + ped->ichCaret * ped->cbChar))) {
                changeSelection = TRUE;
            }
            else
                ped->ichCaret = oldCaret;
            ECUnlock(ped);
        }
        else {
            if (fpImmEscapeW(THREAD_HKL(), fpImmGetContext(ped->hwnd),
                IME_ESC_HANJA_MODE, (ECLock(ped) + ped->ichCaret * ped->cbChar))) {
                changeSelection = TRUE;
            }
            else
                ped->ichCaret = oldCaret;
            ECUnlock(ped);
        }
    }
    return changeSelection;
}


//////////////////////////////////////////////////////////////////////////////
// EcImeRequestHandler()
//
// Handles WM_IME_REQUEST message originated by IME
//
// Histroy:
// 27-Mar-97 Hiroyama Created
//////////////////////////////////////////////////////////////////////////////

#ifdef CUAS_ENABLE

#define MAX_ECDOCFEED 20

ICH EcImeGetDocFeedMin(PED ped, LPSTR lpstr)
{
    ICH ich;

    if (!IS_CICERO_ENABLED())
        return ped->ichMinSel;


    if (ped->ichMinSel > MAX_ECDOCFEED) {
        ich = ped->ichMinSel - MAX_ECDOCFEED;
        ich = ECAdjustIch(ped, lpstr, ich);
    } else {
        ich = 0;
    }

    return ich;
}

ICH EcImeGetDocFeedMax(PED ped, LPSTR lpstr)
{
    ICH ich;

    if (!IS_CICERO_ENABLED())
        return ped->ichMinSel;


    if ((ped->cch - ped->ichMaxSel) > MAX_ECDOCFEED) {
        ich = ped->ichMaxSel + MAX_ECDOCFEED;
        ich = ECAdjustIch(ped, lpstr, ich);
    } else {
        ich = ped->cch;
    }

    return ich;
}

#endif // CUAS_ENABLE

LRESULT EcImeRequestHandler(PED ped, WPARAM dwSubMsg, LPARAM lParam)
{
    LRESULT lreturn = 0L;

    switch (dwSubMsg) {
    case IMR_CONFIRMRECONVERTSTRING:

#if !defined(CUAS_ENABLE)
        // Edit control does not allow IME to change it.
        break;
#else

        // Edit control does not allow IME to change it if it is not CUAS.
        if (!IS_CICERO_ENABLED())
            return 0L;

        //
        // CHECK VERSION of the structure
        //
        if (lParam && ((LPRECONVERTSTRING)lParam)->dwVersion != 0) {
            RIPMSG1(RIP_WARNING, "EcImeRequestHandler: RECONVERTSTRING dwVersion is not expected.",
                ((LPRECONVERTSTRING)lParam)->dwVersion);
            return 0L;
        }

        if (lParam && ped && ped->fFocus && ped->hText && fpImmIsIME(THREAD_HKL())) {
            LPVOID lpSrc;
            lpSrc = ECLock(ped);
            if (lpSrc == NULL) {
                RIPMSG0(RIP_WARNING, "EcImeRequestHandler: LOCALLOCK(ped) failed.");
            } else {
                LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)lParam;
                ICH ichStart;
                ICH ichEnd;
                UINT cchLen;

                ichStart = EcImeGetDocFeedMin(ped, lpSrc);
                ichEnd = EcImeGetDocFeedMax(ped, lpSrc);
                UserAssert(ichEnd >= ichStart);

                cchLen = ichEnd - ichStart;    // holds character count.

                ECUnlock(ped);

                if (lpRCS->dwStrLen != cchLen) {
                    RIPMSG0(RIP_WARNING, "EcImeRequestHandler: the given string length is not expected.");
                } else {
                    ICH ichSelStart;
                    ICH ichSelEnd;

                    ichSelStart = ichStart + (lpRCS->dwCompStrOffset  / ped->cbChar);
                    ichSelEnd = ichSelStart + lpRCS->dwCompStrLen;


                    (ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_SETSEL, ichSelStart, ichSelEnd);

                    lreturn = 1L;
                }
            }
        }
        break;
#endif // CUAS_ENABLE

    case IMR_RECONVERTSTRING:
        //
        // CHECK VERSION of the structure
        //
        if (lParam && ((LPRECONVERTSTRING)lParam)->dwVersion != 0) {
            RIPMSG1(RIP_WARNING, "EcImeRequestHandler: RECONVERTSTRING dwVersion is not expected.",
                ((LPRECONVERTSTRING)lParam)->dwVersion);
            return 0L;
        }

        if (ped && ped->fFocus && ped->hText && fpImmIsIME(THREAD_HKL())) {
#if !defined(CUAS_ENABLE)
            UINT cchLen = ped->ichMaxSel - ped->ichMinSel;    // holds character count.
#else
            ICH ichStart;
            ICH ichEnd;
            UINT cchLen;
            UINT cchSelLen;
            LPVOID lpSrc;
            lpSrc = ECLock(ped);
            if (lpSrc == NULL) {
                RIPMSG0(RIP_WARNING, "EcImeRequestHandler: LOCALLOCK(ped) failed.");
                return 0L;
            }

            ichStart = EcImeGetDocFeedMin(ped, lpSrc);
            ichEnd = EcImeGetDocFeedMax(ped, lpSrc);
            UserAssert(ichEnd >= ichStart);

            cchLen = ichEnd - ichStart;    // holds character count.
            cchSelLen = ped->ichMaxSel - ped->ichMinSel;    // holds character count.
#endif

            if (cchLen == 0) {
#if defined(CUAS_ENABLE)
                ECUnlock(ped);
#endif
                // if we have no selection,
                // just return 0.
                break;
            }

            UserAssert(ped->cbChar == sizeof(BYTE) || ped->cbChar == sizeof(WCHAR));

            // This Edit Control has selection.
            if (lParam == 0) {
                //
                // IME just want to get required size for buffer.
                // cchLen + 1 is needed to reserve room for trailing L'\0'.
                //       ~~~~
                lreturn = sizeof(RECONVERTSTRING) + (cchLen + 1) * ped->cbChar;

#if defined(CUAS_ENABLE)
                ECUnlock(ped);
#endif

            } else {
                LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)lParam;
#if !defined(CUAS_ENABLE)
                LPVOID lpSrc;
#endif
                LPVOID lpDest = (LPBYTE)lpRCS + sizeof(RECONVERTSTRING);

                // check buffer size
                // if the given buffer is smaller than actual needed size,
                // shrink our size to fit the buffer
                if ((INT)lpRCS->dwSize <= sizeof(RECONVERTSTRING) + cchLen * ped->cbChar) {
                    RIPMSG0(RIP_WARNING, "EcImeRequest: ERR09");
                    cchLen = (lpRCS->dwSize - sizeof(RECONVERTSTRING)) / ped->cbChar - ped->cbChar;
                }

                lpRCS->dwStrOffset = sizeof(RECONVERTSTRING); // buffer begins just after RECONVERTSTRING
#if !defined(CUAS_ENABLE)
                lpRCS->dwCompStrOffset =
                lpRCS->dwTargetStrOffset = 0;
                lpRCS->dwStrLen =
                lpRCS->dwCompStrLen =
                lpRCS->dwTargetStrLen = cchLen; // StrLen means TCHAR count

                lpSrc = ECLock(ped);
                if (lpSrc == NULL) {
                    RIPMSG0(RIP_WARNING, "EcImeRequestHandler: LOCALLOCK(ped) failed.");
                } else
#else
                lpRCS->dwCompStrOffset =
                lpRCS->dwTargetStrOffset = (ped->ichMinSel - ichStart) * ped->cbChar; // BYTE count offset
                lpRCS->dwStrLen = cchLen; // TCHAR count
                lpRCS->dwCompStrLen = 
                lpRCS->dwTargetStrLen = cchSelLen; // TCHAR count
#endif
                {
#if !defined(CUAS_ENABLE)
                    RtlCopyMemory(lpDest,
                                  (LPBYTE)lpSrc + ped->ichMinSel * ped->cbChar,
                                  cchLen * ped->cbChar);
#else
                    RtlCopyMemory(lpDest,
                                  (LPBYTE)lpSrc + ichStart * ped->cbChar,
                                  cchLen * ped->cbChar);
#endif
                    // Null-Terminate the string
                    if (ped->fAnsi) {
                        LPBYTE psz = (LPBYTE)lpDest;
                        psz[cchLen] = '\0';
                    } else {
                        LPWSTR pwsz = (LPWSTR)lpDest;
                        pwsz[cchLen] = L'\0';
                    }
                    ECUnlock(ped);
                    // final buffer size
                    lreturn = sizeof(RECONVERTSTRING) + (cchLen + 1) * ped->cbChar;

                    ECInOutReconversionMode(ped, TRUE);
                    ECImmSetCompositionWindow(ped, 0, 0);
                }
            }

        }
        break;
    }

    return lreturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\editml.c ===
/***************************************************************************\
* editml.c - Edit controls rewrite. Version II of edit controls.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Multi-Line Support Routines
*
* Created: 24-Jul-88 davidds
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Number of lines to bump when reallocating index buffer
 */
#define LINEBUMP 32

/*
 * Code to catch bug #202678, please remove it get resolved.
 */
#define CHECK_LINE_NUMBER(iLine, ped)                                                       \
    if (((int)iLine < 0) || ((ICH)iLine >= ped->cLines)) {                                       \
        FRE_RIPMSG0(RIP_ERROR, "Line # is < 0 or >= ped->cLines, Please check this out!");  \
    }

/*
 * Used for ML scroll updates
 */
#define ML_REFRESH  0xffffffff

__inline void MLSanityCheck(PED ped)
{
    UNREFERENCED_PARAMETER(ped);    // For free build

    UserAssert(ped->cch >= ped->chLines[ped->cLines - 1]);
}


/***************************************************************************\
*
*  MLGetLineWidth()
*
*  Returns the max width in a line.  ECTabTheTextOut() ensures that max
*  width won't overflow.
*
\***************************************************************************/
UINT MLGetLineWidth(HDC hdc, LPSTR lpstr, int nCnt, PED ped)
{
    return(ECTabTheTextOut(hdc, 0, 0, 0, 0, lpstr, nCnt, 0, ped, 0, ECT_CALC, NULL));
}

/***************************************************************************\
*
*  MLSize()
*
*  Handles resizing of the edit control window and updating thereof.
*
*  Sets the edit field's formatting area given the passed in "client area".
*  We fudge it if it doesn't seem reasonable.
*
\***************************************************************************/

void   MLSize(PED ped, BOOL fRedraw)
{
    // Calculate the # of lines we can fit in our rectangle.
    ped->ichLinesOnScreen = (ped->rcFmt.bottom - ped->rcFmt.top) / ped->lineHeight;

    // Make the format rectangle height an integral number of lines
    ped->rcFmt.bottom = ped->rcFmt.top + ped->ichLinesOnScreen * ped->lineHeight;

    // Rebuild the line array
    if (ped->fWrap) {
        MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);
        MLUpdateiCaretLine(ped);
    } else {
        MLScroll(ped, TRUE,  ML_REFRESH, 0, fRedraw);
        MLScroll(ped, FALSE, ML_REFRESH, 0, fRedraw);
    }
}

/***************************************************************************\
* MLCalcXOffset AorW
*
* Calculates the horizontal offset (indent) required for centered
* and right justified lines.
*
* History:
*
* Not used if language pack loaded.
\***************************************************************************/

int MLCalcXOffset(
    PED ped,
    HDC hdc,
    int lineNumber)
{
    PSTR pText;
    ICH lineLength;
    ICH lineWidth;

    if (ped->format == ES_LEFT)
        return (0);

    lineLength = MLLine(ped, lineNumber);

    if (lineLength) {

        pText = ECLock(ped) + ped->chLines[lineNumber] * ped->cbChar;
        hdc = ECGetEditDC(ped, TRUE);
        lineWidth = MLGetLineWidth(hdc, pText, lineLength, ped);
        ECReleaseEditDC(ped, hdc, TRUE);
        ECUnlock(ped);
    } else {
        lineWidth = 0;
    }

    /*
     * If a SPACE or a TAB was eaten at the end of a line by MLBuildchLines
     * to prevent a delimiter appearing at the begining of a line, the
     * the following calculation will become negative causing this bug.
     * So, now, we take zero in such cases.
     * Fix for Bug #3566 --01/31/91-- SANKAR --
     */
    lineWidth = max(0, (int)(ped->rcFmt.right-ped->rcFmt.left-lineWidth));

    if (ped->format == ES_CENTER)
        return (lineWidth / 2);

    if (ped->format == ES_RIGHT) {

        /*
         * Subtract 1 so that the 1 pixel wide cursor will be in the visible
         * region on the very right side of the screen.
         */
        return max(0, (int)(lineWidth-1));
    }

    return 0;
}

/***************************************************************************\
* MLMoveSelection AorW
*
* Moves the selection character in the direction indicated. Assumes
* you are starting at a legal point, we decrement/increment the ich. Then,
* This decrements/increments it some more to get past CRLFs...
*
* History:
\***************************************************************************/

ICH MLMoveSelection(
    PED ped,
    ICH ich,
    BOOL fLeft)
{

    if (fLeft && ich > 0) {

        /*
         * Move left
         */
        ich = ECPrevIch( ped, NULL, ich );
        if (ich) {
            if (ped->fAnsi) {
                LPSTR pText;

                /*
                 * Check for CRLF or CRCRLF
                 */
                pText = ECLock(ped) + ich;

                /*
                 * Move before CRLF or CRCRLF
                 */
                if (*(WORD UNALIGNED *)(pText - 1) == 0x0A0D) {
                    ich--;
                    if (ich && *(pText - 2) == 0x0D)
                        ich--;
                }
                ECUnlock(ped);
            } else { // !fAnsi
                LPWSTR pwText;

                /*
                 * Check for CRLF or CRCRLF
                 */
                pwText = (LPWSTR)ECLock(ped) + ich;

                /*
                 * Move before CRLF or CRCRLF
                 */
                if (*(pwText - 1) == 0x0D && *pwText == 0x0A) {
                    ich--;
                    if (ich && *(pwText - 2) == 0x0D)
                        ich--;
                }
                ECUnlock(ped);
            }
        }
    } else if (!fLeft && ich < ped->cch) {
        /*
         * Move right.
         */
        ich = ECNextIch( ped, NULL, ich );
        if (ich < ped->cch) {
            if (ped->fAnsi) {
                LPSTR pText;
                pText = ECLock(ped) + ich;

                /*
                 * Move after CRLF
                 */
                if (*(WORD UNALIGNED *)(pText - 1) == 0x0A0D)
                    ich++;
                else {

                    /*
                     * Check for CRCRLF
                     */
                    if (ich && *(WORD UNALIGNED *)pText == 0x0A0D && *(pText - 1) == 0x0D)
                        ich += 2;
                }
                ECUnlock(ped);
            } else { // !fAnsi
                LPWSTR pwText;
                pwText = (LPWSTR)ECLock(ped) + ich;

                /*
                 * Move after CRLF
                 */
                if (*(pwText - 1) == 0x0D && *pwText == 0x0A)
                    ich++;
                else {

                    /*
                     * Check for CRCRLF
                     */
                    if (ich && *(pwText - 1) == 0x0D && *pwText == 0x0D &&
                            *(pwText + 1) == 0x0A)
                        ich += 2;
                }
                ECUnlock(ped);
            }
        }
    }
    return (ich);
}

/***************************************************************************\
* MLMoveSelectionRestricted AorW
*
* Moves the selection like MLMoveSelection, but also obeys limitations
* imposed by some languages such as Thai, where the cursor cannot stop
* between a character and it's attached vowel or tone marks.
*
* Only called if the language pack is loaded.
*
\***************************************************************************/

/***************************************************************************\
* MLMoveSelectionRestricted AorW
*
* Moves the selection like MLMoveSelection, but also obeys limitations
* imposed by some languages such as Thai, where the cursor cannot stop
* between a character and it's attached vowel or tone marks.
*
* Only called if the language pack is loaded.
*
\***************************************************************************/

ICH MLMoveSelectionRestricted(
    PED  ped,
    ICH  ich,
    BOOL fLeft)
{
    PSTR pText;
    HDC  hdc;
    ICH  ichResult;

    pText = ECLock(ped);
    hdc = ECGetEditDC(ped, TRUE);
    ichResult = ped->pLpkEditCallout->EditMoveSelection(ped, hdc, pText, ich, fLeft);
    ECReleaseEditDC(ped, hdc, TRUE);
    ECUnlock(ped);

    return ichResult;
}


/***************************************************************************\
* MLSetCaretPosition AorW
*
* If the window has the focus, find where the caret belongs and move
* it there.
*
* History:
\***************************************************************************/

void MLSetCaretPosition(
    PED ped,
    HDC hdc)
{
    POINT position;
    BOOL prevLine;
    int  x = -20000;
    int  y = -20000;

    /*
     * We will only position the caret if we have the focus since we don't want
     * to move the caret while another window could own it.
     */
    if (!ped->fFocus || !_IsWindowVisible(ped->pwnd))
         return;

    /*
     * Find the position of the caret
     */
    if (!ped->fCaretHidden &&
        ((ICH) ped->iCaretLine >= ped->ichScreenStart) &&
        ((ICH) ped->iCaretLine <  (ped->ichScreenStart + ped->ichLinesOnScreen))) {

        RECT    rcRealFmt;

        if (ped->f40Compat)
        {
            GetClientRect(ped->hwnd, &rcRealFmt);
            IntersectRect(&rcRealFmt, &rcRealFmt, &ped->rcFmt);
        } else {
            CopyRect(&rcRealFmt, &ped->rcFmt);
        }

        if (ped->cLines - 1 != ped->iCaretLine && ped->ichCaret == ped->chLines[ped->iCaretLine + 1]) {
            prevLine = TRUE;
        } else {
            prevLine = FALSE;
        }

        MLIchToXYPos(ped, hdc, ped->ichCaret, prevLine, &position);

        if ( (position.y >= rcRealFmt.top) &&
             (position.y <= rcRealFmt.bottom - ped->lineHeight)) {
            int xPos = position.x;
            int cxCaret = ECGetCaretWidth();

            if (ped->fWrap ||
                ((xPos > (rcRealFmt.left - cxCaret)) &&
                 (xPos <= rcRealFmt.right))) {
                // Make sure the caret is in the visible region if word
                // wrapping. This is so that the caret will be visible if the
                // line ends with a space.
                x = max(xPos, rcRealFmt.left);
                x = min(x, rcRealFmt.right - cxCaret);
                y = position.y;
            }
        }
    }

    if (ped->pLpkEditCallout) {
        NtUserSetCaretPos(x + ped->iCaretOffset, y);
    } else {
        NtUserSetCaretPos(x, y);
    }

    // FE_IME : MLSetCaretPosition -- ImmSetCompositionWindow(CFS_RECT)
    if (fpImmIsIME(THREAD_HKL())) {
        if (x != -20000 && y != -20000) {
            ECImmSetCompositionWindow(ped, x, y);
        }
    }
}

/***************************************************************************\
* MLLine
*
* Returns the length of the line (cch) given by lineNumber ignoring any
* CRLFs in the line.
*
* History:
\***************************************************************************/

ICH MLLine(
    PED ped,
    ICH lineNumber)
{
    ICH result;

    UserAssert(lineNumber < ped->cLines);

    if (lineNumber >= ped->cLines)
        return (0);

    if (lineNumber == ped->cLines - 1) {

        /*
         * Since we can't have a CRLF on the last line
         */
        return (ped->cch - ped->chLines[ped->cLines - 1]);
    } else {
        result = ped->chLines[lineNumber + 1] - ped->chLines[lineNumber];
        RIPMSG1(RIP_VERBOSE, "MLLine result=%d\n", result);

        /*
         * Now check for CRLF or CRCRLF at end of line
         */
        if (result > 1) {
            if (ped->fAnsi) {
                LPSTR pText;

                pText = ECLock(ped) + ped->chLines[lineNumber + 1] - 2;
                if (*(WORD UNALIGNED *)pText == 0x0A0D) {
                    result -= 2;
                    if (result && *(--pText) == 0x0D)
                        /*
                         * In case there was a CRCRLF
                         */
                        result--;
                }
            } else { // !fAnsi
                LPWSTR pwText;

                pwText = (LPWSTR)ECLock(ped) +
                        (ped->chLines[lineNumber + 1] - 2);
                if (*(DWORD UNALIGNED *)pwText == 0x000A000D) {
                    result = result - 2;
                    if (result && *(--pwText) == 0x0D)
                        /*
                         * In case there was a CRCRLF
                         */
                        result--;
                }

            }
            ECUnlock(ped);
        }
    }
    return (result);
}


/***************************************************************************\
* MLIchToLine AorW
*
* Returns the line number (starting from 0) which contains the given
* character index. If ich is -1, return the line the first char in the
* selection is on (the caret if no selection)
*
* History:
\***************************************************************************/

int MLIchToLine(
    PED ped,
    ICH ich)
{
    int iLo, iHi, iLine;

    iLo = 0;
    iHi = ped->cLines;

    if (ich == (ICH)-1)
        ich = ped->ichMinSel;

    while (iLo < iHi - 1) {
        iLine = max((iHi - iLo)/2, 1) + iLo;

        if (ped->chLines[iLine] > ich) {
            iHi = iLine;
        } else {
            iLo = iLine;
        }
    }

    CHECK_LINE_NUMBER(iLo, ped);

    return iLo;
}

/***************************************************************************\
* MLIchToYPos
*
* Given an ich, return its y coordinate with respect to the top line
* displayed in the window. If prevLine is TRUE and if the ich is at the
* beginning of the line, return the y coordinate of the
* previous line (if it is not a CRLF).
*
* Added for the LPK (3Dec96) - with an LPK installed, calculating X position is
* a far more processor intensive job. Where only the Y position is required
* this routine should be called instead of MLIchToXYPos.
*
* Called only when LPK installed.
*
\***************************************************************************/


/***************************************************************************\
* MLIchToYPos
*
* Given an ich, return its y coordinate with respect to the top line
* displayed in the window. If prevLine is TRUE and if the ich is at the
* beginning of the line, return the y coordinate of the
* previous line (if it is not a CRLF).
*
* Added for the LPK (3Dec96) - with an LPK installed, calculating X position is
* a far more processor intensive job. Where only the Y position is required
* this routine should be called instead of MLIchToXYPos.
*
* Called only when LPK installed.
*
\***************************************************************************/


INT MLIchToYPos(
    PED  ped,
    ICH  ich,
    BOOL prevLine)
{
    int  iline;
    int  yPosition;
    PSTR pText;

    /*
     * Determine what line the character is on
     */
    iline = MLIchToLine(ped, ich);

    /*
     * Calc. the yPosition now. Note that this may change by the height of one
     * char if the prevLine flag is set and the ICH is at the beginning of a
     * line.
     */
    yPosition = (iline - ped->ichScreenStart) * ped->lineHeight + ped->rcFmt.top;

    pText = ECLock(ped);
    if (prevLine && iline && (ich == ped->chLines[iline]) &&
            (!AWCOMPARECHAR(ped, pText + (ich - 2) * ped->cbChar, 0x0D) ||
             !AWCOMPARECHAR(ped, pText + (ich - 1) * ped->cbChar, 0x0A))) {

        /*
         * First char in the line. We want Y position of the previous
         * line if we aren't at the 0th line.
         */
        iline--;

        yPosition = yPosition - ped->lineHeight;
    }
    ECUnlock(ped);

    return yPosition;
}

/***************************************************************************\
* MLIchToXYPos
*
* Given an ich, return its x,y coordinates with respect to the top
* left character displayed in the window. Returns the coordinates of the top
* left position of the char. If prevLine is TRUE then if the ich is at the
* beginning of the line, we will return the coordinates to the right of the
* last char on the previous line (if it is not a CRLF).
*
* History:
\***************************************************************************/

void MLIchToXYPos(
    PED ped,
    HDC hdc,
    ICH ich,
    BOOL prevLine,
    LPPOINT ppt)
{
    int iline;
    ICH cch;
    int xPosition, yPosition;
    int xOffset;

    /*
     * For horizontal scroll displacement on left justified text and
     * for indent on centered or right justified text
     */
    PSTR pText, pTextStart, pLineStart;

    /*
     * Determine what line the character is on
     */
    iline = MLIchToLine(ped, ich);

    /*
     * Calc. the yPosition now. Note that this may change by the height of one
     * char if the prevLine flag is set and the ICH is at the beginning of a
     * line.
     */
    yPosition = (iline - ped->ichScreenStart) * ped->lineHeight + ped->rcFmt.top;

    /*
     * Now determine the xPosition of the character
     */
    pTextStart = ECLock(ped);

    if (prevLine && iline && (ich == ped->chLines[iline]) &&
            (!AWCOMPARECHAR(ped, pTextStart + (ich - 2) * ped->cbChar, 0x0D) ||
            !AWCOMPARECHAR(ped, pTextStart + (ich - 1) * ped->cbChar, 0x0A))) {

        /*
         * First char in the line. We want text extent upto end of the previous
         * line if we aren't at the 0th line.
         */
        iline--;

        yPosition = yPosition - ped->lineHeight;
        pLineStart = pTextStart + ped->chLines[iline] * ped->cbChar;

        /*
         * Note that we are taking the position in front of any CRLFs in the
         * text.
         */
        cch = MLLine(ped, iline);

    } else {

        pLineStart = pTextStart + ped->chLines[iline] * ped->cbChar;
        pText = pTextStart + ich * ped->cbChar;

        /*
         * Strip off CRLF or CRCRLF. Note that we may be pointing to a CR but in
         * which case we just want to strip off a single CR or 2 CRs.
         */

        /*
         * We want pText to point to the first CR at the end of the line if
         * there is one. Thus, we will get an xPosition to the right of the last
         * visible char on the line otherwise we will be to the left of
         * character ich.
         */

        /*
         * Check if we at the end of text
         */
        if (ich < ped->cch) {
            if (ped->fAnsi) {
                if (ich && *(WORD UNALIGNED *)(pText - 1) == 0x0A0D) {
                    pText--;
                    if (ich > 2 && *(pText - 1) == 0x0D)
                        pText--;
                }
            } else {
                LPWSTR pwText = (LPWSTR)pText;

                if (ich && *(DWORD UNALIGNED *)(pwText - 1) == 0x000A000D) {
                    pwText--;
                    if (ich > 2 && *(pwText - 1) == 0x0D)
                        pwText--;
                }
                pText = (LPSTR)pwText;
            }
        }

        if (pText < pLineStart)
            pText = pLineStart;

        cch = (ICH)(pText - pLineStart)/ped->cbChar;
    }

    /*
     * Find out how many pixels we indent the line for funny formats
     */
    if (ped->pLpkEditCallout) {
        /*
         * Must find position at start of character offset cch from start of line.
         * This depends on the layout and the reading order
         */
        xPosition = ped->pLpkEditCallout->EditIchToXY(
                          ped, hdc, pLineStart, MLLine(ped, iline), cch);
    } else {
        if (ped->format != ES_LEFT) {
            xOffset = MLCalcXOffset(ped, hdc, iline);
        } else {
            xOffset = -(int)ped->xOffset;
        }

        xPosition = ped->rcFmt.left + xOffset +
                MLGetLineWidth(hdc, pLineStart, cch, ped);
    }

    ECUnlock(ped);
    ppt->x = xPosition;
    ppt->y = yPosition;
    return ;
}

/***************************************************************************\
* MLMouseToIch AorW
*
* Returns the closest cch to where the mouse point is.  Also optionally
* returns lineindex in pline (So that we can tell if we are at the beginning
* of the line or end of the previous line.)
*
* History:
\***************************************************************************/

ICH MLMouseToIch(
    PED ped,
    HDC hdc,
    LPPOINT mousePt,
    LPICH pline)
{
    int xOffset;
    LPSTR pLineStart;
    int height = mousePt->y;
    int line; //WASINT
    int width = mousePt->x;
    ICH cch;
    ICH cLineLength;
    ICH cLineLengthNew;
    ICH cLineLengthHigh;
    ICH cLineLengthLow;
    ICH cLineLengthTemp;
    int textWidth;
    int iCurWidth;
    int lastHighWidth, lastLowWidth;

    /*
     * First determine which line the mouse is pointing to.
     */
    line = ped->ichScreenStart;
    if (height <= ped->rcFmt.top) {

        /*
         * Either return 0 (the very first line, or one line before the top line
         * on the screen. Note that these are signed mins and maxes since we
         * don't expect (or allow) more than 32K lines.
         */
        line = max(0, line-1);
    } else if (height >= ped->rcFmt.bottom) {

        /*
         * Are we below the last line displayed
         */
        line = min(line+(int)ped->ichLinesOnScreen, (int)(ped->cLines-1));
    } else {

        /*
         * We are somewhere on a line visible on screen
         */
        line = min(line + (int)((height - ped->rcFmt.top) / ped->lineHeight),
                (int)(ped->cLines - 1));
    }

    /*
     * Now determine what horizontal character the mouse is pointing to.
     */
    pLineStart = ECLock(ped) + ped->chLines[line] * ped->cbChar;
    cLineLength = MLLine(ped, line); /* Length is sans CRLF or CRCRLF */
    RIPMSG3(RIP_VERBOSE, "MLLine(ped=%x, line=%d) returned %d\n", ped, line, cLineLength);
    UserAssert((int)cLineLength >= 0);

    /*
     * If the language pack is loaded, visual and logical character order
     * may differ.
     */
    if (ped->pLpkEditCallout) {
        /*
         * Use the language pack to find the character nearest the cursor.
         */
        cch = ped->chLines[line] + ped->pLpkEditCallout->EditMouseToIch
            (ped, hdc, pLineStart, cLineLength, width);
    } else {
        /*
         * xOffset will be a negative value for center and right justified lines.
         * ie. We will just displace the lines left by the amount of indent for
         * right and center justification. Note that ped->xOffset will be 0 for
         * these lines since we don't support horizontal scrolling with them.
         */
        if (ped->format != ES_LEFT) {
            xOffset = MLCalcXOffset(ped, hdc, line);
        } else {
            /*
             * So that we handle a horizontally scrolled window for left justified
             * text.
             */
            xOffset = 0;
        }

        width = width - xOffset;

        /*
         * The code below is tricky... I depend on the fact that ped->xOffset is 0
         * for right and center justified lines
         */

        /*
         * Now find out how many chars fit in the given width
         */
        if (width >= ped->rcFmt.right) {

            /*
             * Return 1+last char in line or one plus the last char visible
             */
            cch = ECCchInWidth(ped, hdc, pLineStart, cLineLength,
                    ped->rcFmt.right - ped->rcFmt.left + ped->xOffset, TRUE);
            //
            // Consider DBCS in case of width >= ped->rcFmt.right
            //
            // Since ECCchInWidth and MLLineLength takes care of DBCS, we only need to
            // worry about if the last character is a double byte character or not.
            //
            // cch = ped->chLines[line] + min( ECNextIch(ped, pLineStart, cch), cLineLength);
            //
            // we need to adjust the position. LiZ -- 5/5/93
            if (ped->fAnsi && ped->fDBCS) {
                ICH cch2 = min(cch+1,cLineLength);
                if (ECAdjustIch(ped, pLineStart, cch2) != cch2) {
                    /* Displayed character on the right edge is DBCS */
                    cch = min(cch+2,cLineLength);
                } else {
                    cch = cch2;
                }
                cch += ped->chLines[line];
            } else {
                cch = ped->chLines[line] + min(cch + 1, cLineLength);
            }
        } else if (width <= ped->rcFmt.left + ped->aveCharWidth / 2) {

            /*
             * Return first char in line or one minus first char visible. Note that
             * ped->xOffset is 0 for right and centered text so we will just return
             * the first char in the string for them. (Allow a avecharwidth/2
             * positioning border so that the user can be a little off...
             */
            cch = ECCchInWidth(ped, hdc, pLineStart, cLineLength,
                    ped->xOffset, TRUE);
            if (cch)
                cch--;

            cch = ECAdjustIch( ped, pLineStart, cch );
            cch += ped->chLines[line];
        } else {

            if (cLineLength == 0) {
                cch = ped->chLines[line];
                goto edUnlock;
            }

            iCurWidth = width + ped->xOffset - ped->rcFmt.left;
            /*
             * If the user clicked past the end of the text, return the last character
             */
            lastHighWidth = MLGetLineWidth(hdc, pLineStart, cLineLength, ped);
            if (lastHighWidth <= iCurWidth) {
                cLineLengthNew = cLineLength;
                goto edAdjust;
            }
            /*
             * Now the mouse is somewhere on the visible portion of the text
             * remember cch contains the length of the line.
             */
            cLineLengthLow = 0;
            cLineLengthHigh = cLineLength + 1;
            lastLowWidth = 0;

            while (cLineLengthLow < cLineLengthHigh - 1) {

                cLineLengthNew = (cLineLengthHigh + cLineLengthLow) / 2;

                if (ped->fAnsi && ped->fDBCS) {
                    /*
                     * MLGetLineWidth returns meaningless value for truncated DBCS.
                     */
                    cLineLengthTemp = ECAdjustIch(ped, pLineStart, cLineLengthNew);
                    textWidth = MLGetLineWidth(hdc, pLineStart, cLineLengthTemp, ped);

                } else {
                    textWidth = MLGetLineWidth(hdc, pLineStart, cLineLengthNew, ped);
                }

                if (textWidth > iCurWidth) {
                    cLineLengthHigh = cLineLengthNew;
                    lastHighWidth = textWidth;
                } else {
                    cLineLengthLow = cLineLengthNew;
                    lastLowWidth = textWidth;
                }
            }

            /*
             * When the while ends, you can't know the exact desired position.
             * Try to see if the mouse pointer was on the farest half
             * of the char we got and if so, adjust cch.
             */
            if (cLineLengthLow == cLineLengthNew) {
                /*
                 * Need to compare with lastHighWidth
                 */
                if ((lastHighWidth - iCurWidth) < (iCurWidth - textWidth)) {
                    cLineLengthNew++;
                }
            } else {
                /*
                 * Need to compare with lastLowHigh
                 */
                if ((iCurWidth - lastLowWidth) < (textWidth - iCurWidth)) {
                    cLineLengthNew--;
                }
            }
edAdjust:
            cLineLength = ECAdjustIch( ped, pLineStart, cLineLengthNew );

            cch = ped->chLines[line] + cLineLength;
        }
    }
edUnlock:
    ECUnlock(ped);

    if (pline) {
        CHECK_LINE_NUMBER(line, ped);
        *pline = line;
    }
    return cch;
}

/***************************************************************************\
* MLChangeSelection AorW
*
* Changes the current selection to have the specified starting and
* ending values. Properly highlights the new selection and unhighlights
* anything deselected. If NewMinSel and NewMaxSel are out of order, we swap
* them. Doesn't update the caret position.
*
* History:
\***************************************************************************/

void MLChangeSelection(
    PED ped,
    HDC hdc,
    ICH ichNewMinSel,
    ICH ichNewMaxSel)
{

    ICH temp;
    ICH ichOldMinSel, ichOldMaxSel;

    if (ichNewMinSel > ichNewMaxSel) {
        temp = ichNewMinSel;
        ichNewMinSel = ichNewMaxSel;
        ichNewMaxSel = temp;
    }
    ichNewMinSel = min(ichNewMinSel, ped->cch);
    ichNewMaxSel = min(ichNewMaxSel, ped->cch);

    /*
     * Save the current selection
     */
    ichOldMinSel = ped->ichMinSel;
    ichOldMaxSel = ped->ichMaxSel;

    /*
     * Set new selection
     */
    ped->ichMinSel = ichNewMinSel;
    ped->ichMaxSel = ichNewMaxSel;

    /*
     * This finds the XOR of the old and new selection regions and redraws it.
     * There is nothing to repaint if we aren't visible or our selection
     * is hidden.
     */
    if (_IsWindowVisible(ped->pwnd) && (ped->fFocus || ped->fNoHideSel)) {

        BLOCK Blk[2];
        int i;

        if (ped->fFocus) {
            NtUserHideCaret(ped->hwnd);
        }

        Blk[0].StPos = ichOldMinSel;
        Blk[0].EndPos = ichOldMaxSel;
        Blk[1].StPos = ped->ichMinSel;
        Blk[1].EndPos = ped->ichMaxSel;

        if (ECCalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel, (LPBLOCK)&Blk[0], (LPBLOCK)&Blk[1])) {

            /*
             * Paint both Blk[0] and Blk[1], if they exist
             */
            for (i = 0; i < 2; i++) {
                if (Blk[i].StPos != 0xFFFFFFFF)
                    MLDrawText(ped, hdc, Blk[i].StPos, Blk[i].EndPos, TRUE);
            }
        }

        /*
         * Update caret.
         */
        MLSetCaretPosition(ped, hdc);

        if (ped->fFocus) {
            NtUserShowCaret(ped->hwnd);
        }

    }
}


/**************************************************************************\
* MLUpdateiCaretLine AorW
*
* This updates the ped->iCaretLine field from the ped->ichCaret;
* Also, when the caret gets to the beginning of next line, pop it up to
* the end of current line when inserting text;
*
* History
* 4-18-91 Mikehar 31Merge
\**************************************************************************/

void MLUpdateiCaretLine(PED ped)
{
    PSTR pText;

    ped->iCaretLine = MLIchToLine(ped, ped->ichCaret);

    /*
     * If caret gets to beginning of next line, pop it up to end of current line
     * when inserting text.
     */
    pText = ECLock(ped) +
            (ped->ichCaret - 1) * ped->cbChar;
    if (ped->iCaretLine && ped->chLines[ped->iCaretLine] == ped->ichCaret &&
            (!AWCOMPARECHAR(ped, pText - ped->cbChar, 0x0D) ||
            !AWCOMPARECHAR(ped, pText, 0x0A)))
        ped->iCaretLine--;
    ECUnlock(ped);
}

/***************************************************************************\
* MLInsertText AorW
*
* Adds up to cchInsert characters from lpText to the ped starting at
* ichCaret. If the ped only allows a maximum number of characters, then we
* will only add that many characters to the ped. The number of characters
* actually added is return ed (could be 0). If we can't allocate the required
* space, we notify the parent with EN_ERRSPACE and no characters are added.
* We will rebuild the lines array as needed. fUserTyping is true if the
* input was the result of the user typing at the keyboard. This is so we can
* do some stuff faster since we will be getting only one or two chars of
* input.
*
* History:
* Created ???
* 4-18-91 Mikehar Win31 Merge
\***************************************************************************/

ICH MLInsertText(
    PED ped,
    LPSTR lpText,
    ICH cchInsert,
    BOOL fUserTyping)
{
    HDC hdc;
    ICH validCch = cchInsert;
    ICH oldCaret = ped->ichCaret;
    int oldCaretLine = ped->iCaretLine;
    BOOL fCRLF = FALSE;
    LONG ll, hl;
    POINT xyPosInitial;
    POINT xyPosFinal;
    HWND hwndSave = ped->hwnd;
    UNDO undo;
    ICH validCchTemp;

    xyPosInitial.x=0;
    xyPosInitial.y=0;
    xyPosFinal.x=0;
    xyPosFinal.y=0;

    if (validCch == 0)
        return 0;

    if (ped->cchTextMax <= ped->cch) {

        /*
         * When the max chars is reached already, notify parent
         * Fix for Bug #4183 -- 02/06/91 -- SANKAR --
         */
        ECNotifyParent(ped,EN_MAXTEXT);
        return 0;
    }

    /*
     * Limit the amount of text we add
     */
    validCch = min(validCch, ped->cchTextMax - ped->cch);

    /*
     * Make sure we don't split a CRLF in half
     */
    if (validCch) {
        if (ped->fAnsi) {
            if (*(WORD UNALIGNED *)(lpText + validCch - 1) == 0x0A0D)
                validCch--;
        } else {
            if (*(DWORD UNALIGNED *)(lpText + (validCch - 1) * ped->cbChar) == 0x000A000D)
                validCch--;
        }
    }
    if (!validCch) {
        /*
         * When the max chars is reached already, notify parent
         * Fix for Bug #4183 -- 02/06/91 -- SANKAR --
         */
        ECNotifyParent(ped,EN_MAXTEXT);
        return 0;
    }

    if (validCch == 2) {
        if (ped->fAnsi) {
            if (*(WORD UNALIGNED *)lpText == 0x0A0D)
                fCRLF = TRUE;
        } else {
            if (*(DWORD UNALIGNED *)lpText == 0x000A000D)
                fCRLF = TRUE;
        }
    }

    //
    // Save current undo state always, but clear it out only if !AutoVScroll
    //
    ECSaveUndo(Pundo(ped), (PUNDO)&undo, !ped->fAutoVScroll);

    hdc = ECGetEditDC(ped, FALSE);
    /*
     * We only need the y position. Since with an LPK loaded
     * calculating the x position is an intensive job, just
     * call MLIchToYPos.
     */
    if (ped->cch)
        if (ped->pLpkEditCallout)
            xyPosInitial.y = MLIchToYPos(ped, ped->cch-1, FALSE);
        else
            MLIchToXYPos(ped, hdc, ped->cch - 1, FALSE, &xyPosInitial);

    /*
     * Insert the text
     */
    validCchTemp = validCch;    // may not be needed, but just for precautions..
    if (!ECInsertText(ped, lpText, &validCchTemp)) {

        // Restore previous undo buffer if it was cleared
        if (!ped->fAutoVScroll)
            ECSaveUndo((PUNDO)&undo, Pundo(ped), FALSE);

        ECReleaseEditDC(ped, hdc, FALSE);
        ECNotifyParent(ped, EN_ERRSPACE);
        return (0);
    }

#if DBG
    if (validCch != validCchTemp) {
        /*
         * All characters in lpText has not been inserted to ped.
         * This could happen when cch is close to cchMax.
         * Better revisit this after NT5 ships.
         */
        RIPMSG2(RIP_WARNING, "MLInsertText: validCch is changed (%x -> %x) in ECInsertText.",
            validCch, validCchTemp);
    }
#endif

    /*
     * Note that ped->ichCaret is updated by ECInsertText
     */
    MLBuildchLines(ped, (ICH)oldCaretLine, (int)validCch, fCRLF?(BOOL)FALSE:fUserTyping, &ll, &hl);

    if (ped->cch)
       /*
        * We only need the y position. Since with an LPK loaded
        * calculating the x position is an intensive job, just
        * call MLIchToYPos.
        */
       if (ped->pLpkEditCallout)
           xyPosFinal.y = MLIchToYPos(ped, ped->cch-1, FALSE);
       else
           MLIchToXYPos(ped, hdc, ped->cch - 1, FALSE,&xyPosFinal);

    if (xyPosFinal.y < xyPosInitial.y && ((ICH)ped->ichScreenStart) + ped->ichLinesOnScreen >= ped->cLines - 1) {
        RECT rc;

        CopyRect((LPRECT)&rc, (LPRECT)&ped->rcFmt);
        rc.top = xyPosFinal.y + ped->lineHeight;
        if (ped->pLpkEditCallout) {
            int xFarOffset = ped->xOffset + ped->rcFmt.right - ped->rcFmt.left;
            // Include left or right margins in display unless clipped
            // by horizontal scrolling.
            if (ped->wLeftMargin) {
                if (!(   ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
                      && (   (!ped->fRtoLReading && ped->xOffset > 0)  // LTR and first char not fully in view
                          || ( ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) { //RTL and last char not fully in view
                    rc.left  -= ped->wLeftMargin;
                }
            }

            // Process right margin
            if (ped->wRightMargin) {
                if (!(   ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
                      && (   ( ped->fRtoLReading && ped->xOffset > 0)  // RTL and first char not fully in view
                          || (!ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) { // LTR and last char not fully in view
                    rc.right += ped->wRightMargin;
                }
            }
        }
        NtUserInvalidateRect(ped->hwnd, (LPRECT)&rc, TRUE);
    }

    if (!ped->fAutoVScroll) {
        if (ped->ichLinesOnScreen < ped->cLines) {
            MLUndo(ped);
            ECEmptyUndo(Pundo(ped));

            ECSaveUndo(&undo, Pundo(ped), FALSE);

            NtUserMessageBeep(0);
            ECReleaseEditDC(ped, hdc, FALSE);

            /*
             * When the max lines is reached already, notify parent
             * Fix for Bug #7586 -- 10/14/91 -- SANKAR --
             */
            ECNotifyParent(ped,EN_MAXTEXT);
            return (0);
        } else {
            ECEmptyUndo(&undo);
        }
    }

    if (fUserTyping && ped->fWrap) {
        //
        // To avoid oldCaret points intermediate of DBCS character,
        // adjust oldCaret position if necessary.
        //
        // !!!CR If MLBuildchLines() returns reasonable value ( and I think
        //       it does), we don't probably need this. Check this out later.
        //
        if (ped->fDBCS && ped->fAnsi) {
            oldCaret = ECAdjustIch(ped,
                                   ECLock(ped),
                                   min((ICH)LOWORD(ll),oldCaret));
            /* ECUnlock(ped); */
        } else { // same as original code
            oldCaret = min((ICH)LOWORD(ll), oldCaret);
        }
    }

    // Update ped->iCaretLine properly.
    MLUpdateiCaretLine(ped);

    ECNotifyParent(ped, EN_UPDATE);

    /*
     * Make sure window still exists.
     */
    if (!IsWindow(hwndSave))
        return 0;

    if (_IsWindowVisible(ped->pwnd)) {

        //
        // If the current font has negative A widths, we may have to start
        // drawing a few characters before the oldCaret position.
        //
        if (ped->wMaxNegAcharPos) {
            int iLine = MLIchToLine(ped, oldCaret);
            oldCaret = max( ((int)(oldCaret - ped->wMaxNegAcharPos)),
                          ((int)(ped->chLines[iLine])));
        }

        // Redraw to end of screen/text if CRLF or large insert
        if (fCRLF || !fUserTyping) {

            /*
             * Redraw to end of screen/text if crlf or large insert.
             */
            MLDrawText(ped, hdc, (fUserTyping ? oldCaret : 0), ped->cch, FALSE);
        } else
            MLDrawText(ped, hdc, oldCaret, max(ped->ichCaret, (ICH)hl), FALSE);
    }

    ECReleaseEditDC(ped, hdc, FALSE);

    /*
     * Make sure we can see the cursor
     */
    MLEnsureCaretVisible(ped);

    ped->fDirty = TRUE;

    ECNotifyParent(ped, EN_CHANGE);

    if (validCch < cchInsert)
        ECNotifyParent(ped, EN_MAXTEXT);

    if (validCch) {
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    /*
     * Make sure the window still exists.
     */
    if (!IsWindow(hwndSave))
        return 0;
    else
        return validCch;
}

/***************************************************************************\
*
*  MLReplaceSel() -
*
*  Replaces currently selected text with the passed in text, WITH UNDO
*  CAPABILITIES.
*
\***************************************************************************/
void   MLReplaceSel(PED ped, LPSTR lpText)
{
    ICH  cchText;

    //
    // Delete text, which will put it into the clean undo buffer.
    //
    ECEmptyUndo(Pundo(ped));
    MLDeleteText(ped);

    //
    // B#3356
    // Some apps do "clear" by selecting all of the text, then replacing
    // it with "", in which case MLInsertText() will return 0.  But that
    // doesn't mean failure...
    //
    if ( ped->fAnsi )
        cchText = strlen(lpText);
    else
        cchText = wcslen((LPWSTR)lpText);

    if (cchText ) {
        BOOL fFailed;
        UNDO undo;
        HWND hwndSave;

        //
        // B#1385,1427
        // Save undo buffer, but DO NOT CLEAR IT.  We want to restore it
        // if insertion fails due to OOM.
        //
        ECSaveUndo(Pundo(ped), (PUNDO)&undo, FALSE);

        hwndSave = ped->hwnd;
        fFailed = (BOOL) !MLInsertText(ped, lpText, cchText, FALSE);
        if (!IsWindow(hwndSave))
            return;

        if (fFailed) {
            //
            // UNDO the previous edit
            //
            ECSaveUndo((PUNDO)&undo, Pundo(ped), FALSE);
            MLUndo(ped);
        }
    }
}


/***************************************************************************\
* MLDeleteText AorW
*
* Deletes the characters between ichMin and ichMax. Returns the
* number of characters we deleted.
*
* History:
\***************************************************************************/

ICH MLDeleteText(
    PED ped)
{
    ICH minSel = ped->ichMinSel;
    ICH maxSel = ped->ichMaxSel;
    ICH cchDelete;
    HDC hdc;
    int minSelLine;
    int maxSelLine;
    POINT xyPos;
    RECT rc;
    BOOL fFastDelete = FALSE;
    LONG hl;
    INT  cchcount = 0;

    /*
     * Get what line the min selection is on so that we can start rebuilding the
     * text from there if we delete anything.
     */
    minSelLine = MLIchToLine(ped, minSel);
    maxSelLine = MLIchToLine(ped, maxSel);
    //
    // Calculate fFastDelete and cchcount
    //
    if (ped->fAnsi && ped->fDBCS) {
        if ((ped->fAutoVScroll) &&
            (minSelLine == maxSelLine) &&
            (ped->chLines[minSelLine] != minSel)  &&
            (ECNextIch(ped,NULL,minSel) == maxSel)) {

                fFastDelete = TRUE;
                cchcount = ((maxSel - minSel) == 1) ? 0 : -1;
        }
    } else if (((maxSel - minSel) == 1) && (minSelLine == maxSelLine) && (ped->chLines[minSelLine] != minSel)) {
            if (!ped->fAutoVScroll)
                fFastDelete = FALSE;
            else
                fFastDelete = TRUE;
    }
    if (!(cchDelete = ECDeleteText(ped)))
        return (0);

    /*
     * Start building lines at minsel line since caretline may be at the max sel
     * point.
     */
    if (fFastDelete) {
        //
        // cchcount is (-1) if it's a double byte character
        //
        MLShiftchLines(ped, minSelLine + 1, -2 + cchcount);
        MLBuildchLines(ped, minSelLine, 1, TRUE, NULL, &hl);
    } else {
        MLBuildchLines(ped, max(minSelLine-1,0), -(int)cchDelete, FALSE, NULL, NULL);
    }

    MLUpdateiCaretLine(ped);

    ECNotifyParent(ped, EN_UPDATE);

    if (_IsWindowVisible(ped->pwnd)) {

        /*
         * Now update the screen to reflect the deletion
         */
        hdc = ECGetEditDC(ped, FALSE);

        /*
         * Otherwise just redraw starting at the line we just entered
         */
        minSelLine = max(minSelLine-1,0);
        MLDrawText(ped, hdc, ped->chLines[minSelLine],
                   fFastDelete ? hl : ped->cch, FALSE);

        CopyRect(&rc, &ped->rcFmt);
        rc.left  -= ped->wLeftMargin;
        rc.right += ped->wRightMargin;

        if (ped->cch) {

            /*
             * Clear from end of text to end of window.
             *
             * We only need the y position. Since with an LPK loaded
             * calculating the x position is an intensive job, just
             * call MLIchToYPos.
             */
            if (ped->pLpkEditCallout)
                xyPos.y = MLIchToYPos(ped, ped->cch, FALSE);
            else
                MLIchToXYPos(ped, hdc, ped->cch, FALSE, &xyPos);
            rc.top = xyPos.y + ped->lineHeight;
        }

        NtUserInvalidateRect(ped->hwnd, &rc, TRUE);
        ECReleaseEditDC(ped, hdc, FALSE);

        MLEnsureCaretVisible(ped);
    }

    ped->fDirty = TRUE;

    ECNotifyParent(ped, EN_CHANGE);

    if (cchDelete)
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);

    return cchDelete;
}

/***************************************************************************\
* MLInsertchLine AorW
*
* Inserts the line iline and sets its starting character index to be
* ich. All the other line indices are moved up. Returns TRUE if successful
* else FALSE and notifies the parent that there was no memory.
*
* History:
\***************************************************************************/

BOOL MLInsertchLine(
    PED ped,
    ICH iLine,
    ICH ich,
    BOOL fUserTyping)
{
    DWORD dwSize;

    if (fUserTyping && iLine < ped->cLines) {
        ped->chLines[iLine] = ich;
        return (TRUE);
    }

    dwSize = (ped->cLines + 2) * sizeof(int);

    if (dwSize > UserLocalSize(ped->chLines)) {
        LPICH hResult;
        /*
         * Grow the line index buffer
         */
        dwSize += LINEBUMP * sizeof(int);
        hResult = (LPICH)UserLocalReAlloc(ped->chLines, dwSize, 0);

        if (!hResult) {
            ECNotifyParent(ped, EN_ERRSPACE);
            return FALSE;
        }
        ped->chLines = hResult;
    }

    /*
     * Move indices starting at iLine up
     */
    if (ped->cLines != iLine)
        RtlMoveMemory(&ped->chLines[iLine + 1], &ped->chLines[iLine],
                (ped->cLines - iLine) * sizeof(int));
    ped->cLines++;

    ped->chLines[iLine] = ich;
    return TRUE;
}

/***************************************************************************\
* MLShiftchLines AorW
*
* Move the starting index of all lines iLine or greater by delta
* bytes.
*
* History:
\***************************************************************************/

void MLShiftchLines(
    PED ped,
    ICH iLine,
    int delta)
{
    if (iLine >= ped->cLines)
        return;

    /*
     * Just add delta to the starting point of each line after iLine
     */
    for (; iLine < ped->cLines; iLine++)
        ped->chLines[iLine] += delta;
}

/***************************************************************************\
* MLBuildchLines AorW
*
* Rebuilds the start of line array (ped->chLines) starting at line
* number ichLine.
*
* History:
\***************************************************************************/

void MLBuildchLines(
    PED ped,
    ICH iLine,
    int cchDelta, // Number of chars added or deleted
    BOOL fUserTyping,
    PLONG pll,
    PLONG phl)
{
    PSTR ptext; /* Starting address of the text */

    /*
     * We keep these ICH's so that we can Unlock ped->hText when we have to grow
     * the chlines array. With large text handles, it becomes a problem if we
     * have a locked block in the way.
     */
    ICH ichLineStart;
    ICH ichLineEnd;
    ICH ichLineEndBeforeCRLF;
    ICH ichCRLF;

    ICH cch;
    HDC hdc;

    BOOL fLineBroken = FALSE; /* Initially, no new line breaks are made */
    ICH minCchBreak;
    ICH maxCchBreak;
    BOOL fOnDelimiter;

    if (!ped->cch) {
        ped->maxPixelWidth = 0;
        ped->xOffset = 0;
        ped->ichScreenStart = 0;
        ped->cLines = 1;

        if (pll)
            *pll = 0;
        if (phl)
            *phl = 0;

        goto UpdateScroll;
    }

    if (fUserTyping && cchDelta)
        MLShiftchLines(ped, iLine + 1, cchDelta);

    hdc = ECGetEditDC(ped, TRUE);

    if (!iLine && !cchDelta && !fUserTyping) {

        /*
         * Reset maxpixelwidth only if we will be running through the whole
         * text. Better too long than too short.
         */
        ped->maxPixelWidth = 0;

        /*
         * Reset number of lines in text since we will be running through all
         * the text anyway...
         */
        ped->cLines = 1;
    }

    /*
     * Set min and max line built to be the starting line
     */
    minCchBreak = maxCchBreak = (cchDelta ? ped->chLines[iLine] : 0);

    ptext = ECLock(ped);

    ichCRLF = ichLineStart = ped->chLines[iLine];

    while (ichLineStart < ped->cch) {
        if (ichLineStart >= ichCRLF) {
            ichCRLF = ichLineStart;

            /*
             * Move ichCRLF ahead to either the first CR or to the end of text.
             */
            if (ped->fAnsi) {
                while (ichCRLF < ped->cch) {
                    if (*(ptext + ichCRLF) == 0x0D) {
                        if (*(ptext + ichCRLF + 1) == 0x0A ||
                                *(WORD UNALIGNED *)(ptext + ichCRLF + 1) == 0x0A0D)
                            break;
                    }
                    ichCRLF++;
                }
            } else {
                LPWSTR pwtext = (LPWSTR)ptext;

                while (ichCRLF < ped->cch) {
                    if (*(pwtext + ichCRLF) == 0x0D) {
                        if (*(pwtext + ichCRLF + 1) == 0x0A ||
                                *(DWORD UNALIGNED *)(pwtext + ichCRLF + 1) == 0x000A000D)
                            break;
                    }
                    ichCRLF++;
                }
            }
        }


        if (!ped->fWrap) {

            UINT  LineWidth;
            /*
             * If we are not word wrapping, line breaks are signified by CRLF.
             */

            //
            // If we cut off the line at MAXLINELENGTH, we should
            // adjust ichLineEnd.
            //
            if ((ichCRLF - ichLineStart) <= MAXLINELENGTH) {
                ichLineEnd = ichCRLF;
            } else {
                ichLineEnd = ichLineStart + MAXLINELENGTH;
                if (ped->fAnsi && ped->fDBCS) {
                    ichLineEnd = ECAdjustIch( ped, (PSTR)ptext, ichLineEnd);
                }
            }

            /*
             * We will keep track of what the longest line is for the horizontal
             * scroll bar thumb positioning.
             */
            if (ped->pLpkEditCallout) {
                LineWidth = ped->pLpkEditCallout->EditGetLineWidth(
                    ped, hdc, ptext + ichLineStart*ped->cbChar,
                    ichLineEnd - ichLineStart);
            } else {
                LineWidth = MLGetLineWidth(hdc, ptext + ichLineStart * ped->cbChar,
                                            ichLineEnd - ichLineStart,
                                            ped);
            }
            ped->maxPixelWidth = max(ped->maxPixelWidth,(int)LineWidth);

        } else {

            /*
             * Check if the width of the edit control is non-zero;
             * a part of the fix for Bug #7402 -- SANKAR -- 01/21/91 --
             */
            if(ped->rcFmt.right > ped->rcFmt.left) {

                /*
                 * Find the end of the line based solely on text extents
                 */
                if (ped->pLpkEditCallout) {
                    ichLineEnd = ichLineStart +
                        ped->pLpkEditCallout->EditCchInWidth(
                            ped, hdc, ptext + ped->cbChar*ichLineStart,
                            ichCRLF - ichLineStart,
                            ped->rcFmt.right - ped->rcFmt.left);
                } else {
                    if (ped->fAnsi) {
                        ichLineEnd = ichLineStart +
                                 ECCchInWidth(ped, hdc,
                                              ptext + ichLineStart,
                                              ichCRLF - ichLineStart,
                                              ped->rcFmt.right - ped->rcFmt.left,
                                              TRUE);
                    } else {
                        ichLineEnd = ichLineStart +
                                 ECCchInWidth(ped, hdc,
                                              (LPSTR)((LPWSTR)ptext + ichLineStart),
                                              ichCRLF - ichLineStart,
                                              ped->rcFmt.right - ped->rcFmt.left,
                                              TRUE);
                    }
                }
            } else {
                ichLineEnd = ichLineStart;
            }

            if (ichLineEnd == ichLineStart && ichCRLF - ichLineStart) {

                /*
                 * Maintain a minimum of one char per line
                 */
                //
                // Since it might be a double byte char, so calling ECNextIch.
                //
                ichLineEnd = ECNextIch(ped, NULL, ichLineEnd);
            }

            /*
             * Now starting from ichLineEnd, if we are not at a hard line break,
             * then if we are not at a space AND the char before us is
             * not a space,(OR if we are at a CR) we will look word left for the
             * start of the word to break at.
             * This change was done for TWO reasons:
             * 1. If we are on a delimiter, no need to look word left to break at.
             * 2. If the previous char is a delimter, we can break at current char.
             * Change done by -- SANKAR --01/31/91--
             */
            if (ichLineEnd != ichCRLF) {
                if(ped->lpfnNextWord) {
                     fOnDelimiter = (CALLWORDBREAKPROC(*ped->lpfnNextWord, ptext,
                            ichLineEnd, ped->cch, WB_ISDELIMITER) ||
                            CALLWORDBREAKPROC(*ped->lpfnNextWord, ptext, ichLineEnd - 1,
                            ped->cch, WB_ISDELIMITER));
                //
                // This change was done for FOUR reasons:
                //
                // 1. If we are on a delimiter, no need to look word left to break at.
                // 2. If we are on a double byte character, we can break at current char.
                // 3. If the previous char is a delimter, we can break at current char.
                // 4. If the previous char is a double byte character, we can break at current char.
                //
                } else if (ped->fAnsi) {
                    fOnDelimiter = (ISDELIMETERA(*(ptext + ichLineEnd)) ||
                                    ECIsDBCSLeadByte(ped, *(ptext + ichLineEnd)));
                    if (!fOnDelimiter) {
                        PSTR pPrev = ECAnsiPrev(ped,ptext,ptext+ichLineEnd);

                        fOnDelimiter = ISDELIMETERA(*pPrev) ||
                                       ECIsDBCSLeadByte(ped,*pPrev);
                    }
                } else { // Unicode
                    fOnDelimiter = (ISDELIMETERW(*((LPWSTR)ptext + ichLineEnd))     ||
                                    UserIsFullWidth(CP_ACP,*((LPWSTR)ptext + ichLineEnd))      ||
                                    ISDELIMETERW(*((LPWSTR)ptext + ichLineEnd - 1)) ||
                                    UserIsFullWidth(CP_ACP,*((LPWSTR)ptext + ichLineEnd - 1)));
                }
                if (!fOnDelimiter ||
                    (ped->fAnsi && *(ptext + ichLineEnd) == 0x0D) ||
                    (!ped->fAnsi && *((LPWSTR)ptext + ichLineEnd) == 0x0D)) {

                    if (ped->lpfnNextWord != NULL) {
                        cch = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)ptext, ichLineEnd,
                                ped->cch, WB_LEFT);
                    } else {
                        ped->fCalcLines = TRUE;
                        ECWord(ped, ichLineEnd, TRUE, &cch, NULL);
                        ped->fCalcLines = FALSE;
                    }
                    if (cch > ichLineStart) {
                        ichLineEnd = cch;
                    }

                    /*
                     * Now, if the above test fails, it means the word left goes
                     * back before the start of the line ie. a word is longer
                     * than a line on the screen. So, we just fit as much of
                     * the word on the line as possible. Thus, we use the
                     * pLineEnd we calculated solely on width at the beginning
                     * of this else block...
                     */
                }
            }
        }
#if 0
        if (!ISDELIMETERAW((*(ptext + (ichLineEnd - 1)*ped->cbChar))) && ISDELIMETERAW((*(ptext + ichLineEnd*ped->cbChar)))) #ERROR

            if ((*(ptext + ichLineEnd - 1) != ' ' &&
                        *(ptext + ichLineEnd - 1) != VK_TAB) &&
                        (*(ptext + ichLineEnd) == ' ' ||
                        *(ptext + ichLineEnd) == VK_TAB))
#endif
        if (AWCOMPARECHAR(ped,ptext + ichLineEnd * ped->cbChar, ' ') ||
                AWCOMPARECHAR(ped,ptext + ichLineEnd * ped->cbChar, VK_TAB)) {
            /*
             * Swallow the space at the end of a line.
             */
            if (ichLineEnd < ped->cch) {
                ichLineEnd++;
            }
        }

        /*
         * Skip over crlf or crcrlf if it exists. Thus, ichLineEnd is the first
         * character in the next line.
         */
        ichLineEndBeforeCRLF = ichLineEnd;

        if (ped->fAnsi) {
            if (ichLineEnd < ped->cch && *(ptext + ichLineEnd) == 0x0D)
                ichLineEnd += (ichLineEnd + 1 == ped->cch) ? 1 : 2;

            /*
             * Skip over CRCRLF
             */
            if (ichLineEnd < ped->cch && *(ptext + ichLineEnd) == 0x0A)
                ichLineEnd++;
            UserAssert(ichLineEnd <= ped->cch);
        } else {
            if (ichLineEnd < ped->cch && *(((LPWSTR)ptext) + ichLineEnd) == 0x0D)
                ichLineEnd += (ichLineEnd + 1 == ped->cch) ? 1 : 2;

            /*
             * Skip over CRCRLF
             */
            if (ichLineEnd < ped->cch && *(((LPWSTR)ptext) + ichLineEnd) == 0x0A) {
                ichLineEnd++;
                RIPMSG0(RIP_VERBOSE, "Skip over CRCRLF\n");
            }
            UserAssert(ichLineEnd <= ped->cch);
        }

        /*
         * Now, increment iLine, allocate space for the next line, and set its
         * starting point
         */
        iLine++;

        if (!fUserTyping || (iLine > ped->cLines - 1) || (ped->chLines[iLine] != ichLineEnd)) {

            /*
             * The line break occured in a different place than before.
             */
            if (!fLineBroken) {

                /*
                 * Since we haven't broken a line before, just set the min
                 * break line.
                 */
                fLineBroken = TRUE;
                if (ichLineEndBeforeCRLF == ichLineEnd)
                    minCchBreak = maxCchBreak = (ichLineEnd ? ichLineEnd - 1 : 0);
                else
                    minCchBreak = maxCchBreak = ichLineEndBeforeCRLF;
            }
            maxCchBreak = max(maxCchBreak, ichLineEnd);

            ECUnlock(ped);

            /*
             * Now insert the new line into the array
             */
            if (!MLInsertchLine(ped, iLine, ichLineEnd, (BOOL)(cchDelta != 0)))
                goto EndUp;

            ptext = ECLock(ped);
        } else {
            maxCchBreak = ped->chLines[iLine];

            /*
             * Quick escape
             */
            goto UnlockAndEndUp;
        }

        ichLineStart = ichLineEnd;
    } /* end while (ichLineStart < ped->cch) */


    if (iLine != ped->cLines) {
        RIPMSG1(RIP_VERBOSE, "chLines[%d] is being cleared.\n", iLine);
        ped->cLines = iLine;
        ped->chLines[ped->cLines] = 0;
    }

    /*
     * Note that we incremented iLine towards the end of the while loop so, the
     * index, iLine, is actually equal to the line count
     */
    if (ped->cch && AWCOMPARECHAR(ped, ptext + (ped->cch - 1)*ped->cbChar, 0x0A) &&
            ped->chLines[ped->cLines - 1] < ped->cch) {

        /*
         * Make sure last line has no crlf in it
         */
        if (!fLineBroken) {

            /*
             * Since we haven't broken a line before, just set the min break
             * line.
             */
            fLineBroken = TRUE;
            minCchBreak = ped->cch - 1;
        }
        maxCchBreak = max(maxCchBreak, ichLineEnd);
        ECUnlock(ped);
        MLInsertchLine(ped, iLine, ped->cch, FALSE);
        MLSanityCheck(ped);
    } else
UnlockAndEndUp:
        ECUnlock(ped);

EndUp:
    ECReleaseEditDC(ped, hdc, TRUE);
    if (pll)
        *pll = minCchBreak;
    if (phl)
        *phl = maxCchBreak;

UpdateScroll:
    MLScroll(ped, FALSE, ML_REFRESH, 0, TRUE);
    MLScroll(ped, TRUE,  ML_REFRESH, 0, TRUE);

    MLSanityCheck(ped);

    return;
}

/***************************************************************************\
*
*  MLPaint()
*
*  Response to WM_PAINT message.
*
\***************************************************************************/
void   MLPaint(PED ped, HDC hdc, LPRECT lprc)
{
    HFONT       hOldFont;
    ICH         imin;
    ICH         imax;

    //
    // Do we need to draw the border ourself for old apps?
    //
    if (ped->fFlatBorder)
    {
        RECT    rcT;

        _GetClientRect(ped->pwnd, &rcT);
        if (TestWF(ped->pwnd, WFSIZEBOX))
        {
            InflateRect(&rcT, SYSMET(CXBORDER) - SYSMET(CXFRAME),
                SYSMET(CYBORDER) - SYSMET(CYFRAME));
        }
        DrawFrame(hdc, &rcT, 1, DF_WINDOWFRAME);
    }

    ECSetEditClip(ped, hdc, (BOOL) (ped->xOffset == 0));

    if (ped->hFont)
        hOldFont = SelectObject(hdc, ped->hFont);

    if (!lprc) {
        // no partial rect given -- draw all text
        imin = 0;
        imax = ped->cch;
    } else {
        // only draw pertinent text
        imin = (ICH) MLMouseToIch(ped, hdc, ((LPPOINT) &lprc->left), NULL) - 1;
        if (imin == -1)
            imin = 0;

        // HACK_ALERT:
        // The 3 is required here because, MLMouseToIch() returns decremented
        // value; We must fix MLMouseToIch.
        imax = (ICH) MLMouseToIch(ped, hdc, ((LPPOINT) &lprc->right), NULL) + 3;
        if (imax > ped->cch)
            imax = ped->cch;
    }

    MLDrawText(ped, hdc, imin, imax, FALSE);

    if (ped->hFont)
        SelectObject(hdc, hOldFont);
}

/***************************************************************************\
* MLKeyDown AorW
*
* Handles cursor movement and other VIRT KEY stuff. keyMods allows
* us to make MLKeyDownHandler calls and specify if the modifier keys (shift
* and control) are up or down. If keyMods == 0, we get the keyboard state
* using GetKeyState(VK_SHIFT) etc. Otherwise, the bits in keyMods define the
* state of the shift and control keys.
*
* History:
\***************************************************************************/

void MLKeyDown(
    PED ped,
    UINT virtKeyCode,
    int keyMods)
{
    HDC hdc;
    BOOL prevLine;
    POINT mousePt;
    int defaultDlgId;
    int iScrollAmt;

    /*
     * Variables we will use for redrawing the updated text
     */

    /*
     * new selection is specified by newMinSel, newMaxSel
     */
    ICH newMaxSel = ped->ichMaxSel;
    ICH newMinSel = ped->ichMinSel;

    /*
     * Flags for drawing the updated text
     */
    BOOL changeSelection = FALSE;

    /*
     * Comparisons we do often
     */
    BOOL MinEqMax = (newMaxSel == newMinSel);
    BOOL MinEqCar = (ped->ichCaret == newMinSel);
    BOOL MaxEqCar = (ped->ichCaret == newMaxSel);

    /*
     * State of shift and control keys.
     */
    int scState;

    if (ped->fMouseDown) {

        /*
         * If we are in the middle of a mousedown command, don't do anything.
         */
        return ;
    }

    scState = ECGetModKeys(keyMods);

    switch (virtKeyCode) {
    case VK_ESCAPE:
        if (ped->fInDialogBox) {

            /*
             * This condition is removed because, if the dialogbox does not
             * have a CANCEL button and if ESC is hit when focus is on a
             * ML edit control the dialogbox must close whether it has cancel
             * button or not to be consistent with SL edit control;
             * DefDlgProc takes care of the disabled CANCEL button case.
             * Fix for Bug #4123 -- 02/07/91 -- SANKAR --
             */
#if 0
            if (GetDlgItem(ped->hwndParent, IDCANCEL))
#endif

                /*
                 * User hit ESC...Send a close message (which in turn sends a
                 * cancelID to the app in DefDialogProc...
                 */
                PostMessage(ped->hwndParent, WM_CLOSE, 0, 0L);
        }
        return ;

    case VK_RETURN:
        if (ped->fInDialogBox) {

            /*
             * If this multiline edit control is in a dialog box, then we want
             * the RETURN key to be sent to the default dialog button (if there
             * is one). CTRL-RETURN will insert a RETURN into the text. Note
             * that CTRL-RETURN automatically translates into a linefeed (0x0A)
             * and in the MLCharHandler, we handle this as if a return was
             * entered.
             */
            if (scState != CTRLDOWN) {

                if (TestWF(ped->pwnd, EFWANTRETURN)) {

                    /*
                     * This edit control wants cr to be inserted so break out of
                     * case.
                     */
                    return ;
                }

                defaultDlgId = (int)(DWORD)LOWORD(SendMessage(ped->hwndParent,
                        DM_GETDEFID, 0, 0L));
                if (defaultDlgId) {
                    HWND hwnd = GetDlgItem(ped->hwndParent, defaultDlgId);
                    if (hwnd) {
                        SendMessage(ped->hwndParent, WM_NEXTDLGCTL, (WPARAM)hwnd, 1L);
                        if (!ped->fFocus)
                            PostMessage(hwnd, WM_KEYDOWN, VK_RETURN, 0L);
                    }
                }
            }

            return ;
        }
        break;

    case VK_TAB:

        /*
         * If this multiline edit control is in a dialog box, then we want the
         * TAB key to take you to the next control, shift TAB to take you to the
         * previous control. We always want CTRL-TAB to insert a tab into the
         * edit control regardless of weather or not we're in a dialog box.
         */
        if (scState == CTRLDOWN)
            MLChar(ped, virtKeyCode, keyMods);
        else if (ped->fInDialogBox)
            SendMessage(ped->hwndParent, WM_NEXTDLGCTL, scState == SHFTDOWN, 0L);

        return ;

    case VK_LEFT:
        //
        // If the caret isn't at the beginning, we can move left
        //
        if (ped->ichCaret) {
            // Get new caret pos.
            if (scState & CTRLDOWN) {
                // Move caret word left
                ECWord(ped, ped->ichCaret, TRUE, &ped->ichCaret, NULL);
            } else {
                if (ped->pLpkEditCallout) {
                    ped->ichCaret = MLMoveSelectionRestricted(ped, ped->ichCaret, TRUE);
                } else {
                    // Move caret char left
                    ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, TRUE);
                }
            }

            // Get new selection
            if (scState & SHFTDOWN) {
                if (MaxEqCar && !MinEqMax) {
                    // Reduce selection
                    newMaxSel = ped->ichCaret;

                    UserAssert(newMinSel == ped->ichMinSel);
                } else {
                    // Extend selection
                    newMinSel = ped->ichCaret;
                }
            } else {
                // Clear selection
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } else {
            //
            // If the user tries to move left and we are at the 0th
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) {
                changeSelection = TRUE;
                newMaxSel = newMinSel = ped->ichCaret;
            }
        }
        break;

    case VK_RIGHT:
        //
        // If the caret isn't at the end, we can move right.
        //
        if (ped->ichCaret < ped->cch) {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) {
                // Move caret word right
                ECWord(ped, ped->ichCaret, FALSE, NULL, &ped->ichCaret);
            } else {
                // Move caret char right
                if (ped->pLpkEditCallout) {
                    ped->ichCaret = MLMoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } else {
                    ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, FALSE);
                }
            }

            //
            // Get new selection.
            //
            if (scState & SHFTDOWN) {
                if (MinEqCar && !MinEqMax) {
                    // Reduce selection
                    newMinSel = ped->ichCaret;

                    UserAssert(newMaxSel == ped->ichMaxSel);
                } else {
                    // Extend selection
                    newMaxSel = ped->ichCaret;
                }
            } else {
                // Clear selection
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } else {
            //
            // If the user tries to move right and we are at the last
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) {
                newMaxSel = newMinSel = ped->ichCaret;
                changeSelection = TRUE;
            }
        }
        break;

    case VK_UP:
    case VK_DOWN:
        if (ped->cLines - 1 != ped->iCaretLine &&
                ped->ichCaret == ped->chLines[ped->iCaretLine + 1])
            prevLine = TRUE;
        else
            prevLine = FALSE;

        hdc = ECGetEditDC(ped, TRUE);
        MLIchToXYPos(ped, hdc, ped->ichCaret, prevLine, &mousePt);
        ECReleaseEditDC(ped, hdc, TRUE);
        mousePt.y += 1 + (virtKeyCode == VK_UP ? -ped->lineHeight : ped->lineHeight);

        if (!(scState & CTRLDOWN)) {
            //
            // Send fake mouse messages to handle this
            // If VK_SHIFT is down, extend selection & move caret up/down
            // 1 line.  Otherwise, clear selection & move caret.
            //
            MLMouseMotion(ped, WM_LBUTTONDOWN,
                            !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
            MLMouseMotion(ped, WM_LBUTTONUP,
                            !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
        }
        break;

    case VK_HOME:
        //
        // Update caret.
        //
        if (scState & CTRLDOWN) {
            // Move caret to beginning of text.
            ped->ichCaret = 0;
        } else {
            // Move caret to beginning of line.
            ped->ichCaret = ped->chLines[ped->iCaretLine];
        }

        //
        // Update selection.
        //
        newMinSel = ped->ichCaret;

        if (scState & SHFTDOWN) {
            if (MaxEqCar && !MinEqMax) {
                if (scState & CTRLDOWN)
                    newMaxSel = ped->ichMinSel;
                else {
                    newMinSel = ped->ichMinSel;
                    newMaxSel = ped->ichCaret;
                }
            }
        } else {
            // Clear selection
            newMaxSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    case VK_END:
        //
        // Update caret.
        //
        if (scState & CTRLDOWN) {
            // Move caret to end of text.
            ped->ichCaret = ped->cch;
        } else {
            // Move caret to end of line.
            ped->ichCaret = ped->chLines[ped->iCaretLine] +
                MLLine(ped, ped->iCaretLine);
        }

        // Update selection.
        newMaxSel = ped->ichCaret;

        if (scState & SHFTDOWN) {
            if (MinEqCar && !MinEqMax) {
                // Reduce selection
                if (scState & CTRLDOWN) {
                    newMinSel = ped->ichMaxSel;
                } else {
                    newMinSel = ped->ichCaret;
                    newMaxSel = ped->ichMaxSel;
                }
            }
        } else {
            // Clear selection
            newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    // FE_IME // EC_INSERT_COMPOSITION_CHAR : MLKeyDown() : VK_HANJA support
    case VK_HANJA:
        if ( HanjaKeyHandler( ped ) ) {
            changeSelection = TRUE;
            newMinSel = ped->ichCaret;
            newMaxSel = ped->ichCaret + (ped->fAnsi ? 2 : 1);
        }
        break;

    case VK_PRIOR:
    case VK_NEXT:
        if (!(scState & CTRLDOWN)) {
            /*
             * Vertical scroll by one visual screen
             */
            hdc = ECGetEditDC(ped, TRUE);
            MLIchToXYPos(ped, hdc, ped->ichCaret, FALSE, &mousePt);
            ECReleaseEditDC(ped, hdc, TRUE);
            mousePt.y += 1;

            SendMessage(ped->hwnd, WM_VSCROLL, virtKeyCode == VK_PRIOR ? SB_PAGEUP : SB_PAGEDOWN, 0L);

            /*
             * Move the cursor there
             */
            MLMouseMotion(ped, WM_LBUTTONDOWN, !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
            MLMouseMotion(ped, WM_LBUTTONUP,   !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);

        } else {
            /*
             * Horizontal scroll by one screenful minus one char
             */
            iScrollAmt = ((ped->rcFmt.right - ped->rcFmt.left) / ped->aveCharWidth) - 1;
            if (virtKeyCode == VK_PRIOR)
                iScrollAmt *= -1; /* For previous page */

            SendMessage(ped->hwnd, WM_HSCROLL, MAKELONG(EM_LINESCROLL, iScrollAmt), 0);
            break;
        }
        break;

    case VK_DELETE:
        if (ped->fReadOnly)
            break;

        switch (scState) {
        case NONEDOWN:

            /*
             * Clear selection. If no selection, delete (clear) character
             * right
             */
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) {

                /*
                 * Move cursor forwards and send a backspace message...
                 */
                if (ped->pLpkEditCallout) {
                    ped->ichMinSel = ped->ichCaret;
                    ped->ichMaxSel = MLMoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } else {
                    ped->ichCaret = MLMoveSelection(ped, ped->ichCaret, FALSE);
                    ped->ichMaxSel = ped->ichMinSel = ped->ichCaret;
                }

                goto DeleteAnotherChar;
            }
            break;

        case SHFTDOWN:

            /*
             * CUT selection ie. remove and copy to clipboard, or if no
             * selection, delete (clear) character left.
             */
            if (ped->ichMinSel == ped->ichMaxSel) {
                goto DeleteAnotherChar;
            } else {
                SendMessage(ped->hwnd, WM_CUT, (UINT)0, 0L);
            }

            break;

        case CTRLDOWN:

            /*
             * Clear selection, or delete to end of line if no selection
             */
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) {
                ped->ichMaxSel = ped->ichCaret = ped->chLines[ped->iCaretLine] +
                                                 MLLine(ped, ped->iCaretLine);
            }
            break;
        }

        if (!(scState & SHFTDOWN) && (ped->ichMinSel != ped->ichMaxSel)) {

DeleteAnotherChar:
            if (GETAPPVER() >= VER40) {
                MLChar(ped, VK_BACK, 0);
            } else {
                SendMessageWorker(ped->pwnd, WM_CHAR, VK_BACK, 0, ped->fAnsi);
            }
        }

        /*
         * No need to update text or selection since BACKSPACE message does it
         * for us.
         */
        break;

    case VK_INSERT:
        if (scState == CTRLDOWN || scState == SHFTDOWN) {

            /*
             * if CTRLDOWN Copy current selection to clipboard
             */

            /*
             * if SHFTDOWN Paste clipboard
             */
            SendMessage(ped->hwnd, (UINT)(scState == CTRLDOWN ? WM_COPY : WM_PASTE), 0, 0);
        }
        break;
    }

    if (changeSelection) {
        hdc = ECGetEditDC(ped, FALSE);
        MLChangeSelection(ped, hdc, newMinSel, newMaxSel);

        /*
         * Set the caret's line
         */
        ped->iCaretLine = MLIchToLine(ped, ped->ichCaret);

        if (virtKeyCode == VK_END &&
                // Next line: Win95 Bug#11822, EditControl repaint (Sankar)
                (ped->ichCaret == ped->chLines[ped->iCaretLine]) &&
                ped->ichCaret < ped->cch &&
                ped->fWrap && ped->iCaretLine > 0) {
            LPSTR pText = ECLock(ped);

            /*
             * Handle moving to the end of a word wrapped line. This keeps the
             * cursor from falling to the start of the next line if we have word
             * wrapped and there is no CRLF.
             */
            if ( ped->fAnsi ) {
                if (*(WORD UNALIGNED *)(pText +
                        ped->chLines[ped->iCaretLine] - 2) != 0x0A0D) {
                    ped->iCaretLine--;
                }
            } else {
                if (*(DWORD UNALIGNED *)(pText +
                     (ped->chLines[ped->iCaretLine] - 2)*ped->cbChar) != 0x000A000D) {
                    ped->iCaretLine--;
                }
            }
            CHECK_LINE_NUMBER(ped->iCaretLine, ped);
            ECUnlock(ped);
        }

        /*
         * Since drawtext sets the caret position
         */
        MLSetCaretPosition(ped, hdc);
        ECReleaseEditDC(ped, hdc, FALSE);

        /*
         * Make sure we can see the cursor
         */
        MLEnsureCaretVisible(ped);
    }
}

/***************************************************************************\
* MLChar
*
* Handles character and virtual key input
*
* History:
\***************************************************************************/

void MLChar(
    PED ped,
    DWORD keyValue,
    int keyMods)
{
    WCHAR keyPress;
    BOOL updateText = FALSE;

    /*
     * keyValue is either:
     *    a Virtual Key (eg: VK_TAB, VK_ESCAPE, VK_BACK)
     *    a character (Unicode or "ANSI")
     */
    if (ped->fAnsi)
        keyPress = LOBYTE(keyValue);
    else
        keyPress = LOWORD(keyValue);

    if (ped->fMouseDown || keyPress == VK_ESCAPE) {

        /*
         * If we are in the middle of a mousedown command, don't do anything.
         * Also, just ignore it if we get a translated escape key which happens
         * with multiline edit controls in a dialog box.
         */
        return ;
    }

    ECInOutReconversionMode(ped, FALSE);

    {
        int scState;
        scState = ECGetModKeys(keyMods);

        if (ped->fInDialogBox && scState != CTRLDOWN) {

            /*
             * If this multiline edit control is in a dialog box, then we want the
             * TAB key to take you to the next control, shift TAB to take you to the
             * previous control, and CTRL-TAB to insert a tab into the edit control.
             * We moved the focus when we received the keydown message so we will
             * ignore the TAB key now unless the ctrl key is down. Also, we want
             * CTRL-RETURN to insert a return into the text and RETURN to be sent to
             * the default button.
             */
            if (keyPress == VK_TAB ||
                    (keyPress == VK_RETURN && !TestWF(ped->pwnd, EFWANTRETURN)))
                return ;
        }

        /*
         * Allow CTRL+C to copy from a read only edit control
         * Ignore all other keys in read only controls
         */
        if ((ped->fReadOnly) && !((keyPress == 3) && (scState == CTRLDOWN))) {
            return ;
        }
    }

    switch (keyPress) {
    case 0x0A: // linefeed
        keyPress = VK_RETURN;
        /*
         * FALL THRU
         */

    case VK_RETURN:
    case VK_TAB:
    case VK_BACK:
DeleteSelection:
        if (MLDeleteText(ped))
            updateText = TRUE;
        break;

    default:
        if (keyPress >= TEXT(' ')) {
            /*
             * If this is in [a-z],[A-Z] and we are an ES_NUMBER
             * edit field, bail.
             */
            if (ped->f40Compat && TestWF(ped->pwnd, EFNUMBER)) {
                if (!ECIsCharNumeric(ped, keyPress)) {
                    goto IllegalChar;
                }
            }

            goto DeleteSelection;
        }
        break;
    }

    /*
     * Handle key codes
     */
    switch(keyPress) {
    UINT msg;

    // Ctrl+Z == Undo
    case 26:
        msg = WM_UNDO;
        goto SendEditingMessage;
        break;

    // Ctrl+X == Cut
    case 24:
        if (ped->ichMinSel == ped->ichMaxSel)
            goto IllegalChar;
        else
        {
            msg = WM_CUT;
            goto SendEditingMessage;
        }
        break;

    // Ctrl+C == Copy
    case 3:
        msg = WM_COPY;
        goto SendEditingMessage;
        break;

    // Ctrl+V == Paste
    case 22:
        msg = WM_PASTE;
SendEditingMessage:
        SendMessage(ped->hwnd, msg, 0, 0L);
        break;

    case VK_BACK:
        //
        // Delete any selected text or delete character left if no sel
        //
        if (!updateText && ped->ichMinSel)
        {
            //
            // There was no selection to delete so we just delete
            // character left if available
            //
            ped->ichMinSel = MLMoveSelection(ped, ped->ichCaret, TRUE);
            MLDeleteText(ped);
        }
        break;

    default:
        if (keyPress == VK_RETURN)
            if (ped->fAnsi)
                keyValue = 0x0A0D;
            else
                keyValue = 0x000A000D;

        if (   keyPress >= TEXT(' ')
            || keyPress == VK_RETURN
            || keyPress == VK_TAB
            || keyPress == 0x1E     // RS - Unicode block separator
            || keyPress == 0x1F     // US - Unicode segment separator
            ) {

            NtUserCallNoParam(SFI_ZZZHIDECURSORNOCAPTURE);
            if (ped->fAnsi) {
                //
                // check if it's a leading byte of double byte character
                //
                if (ECIsDBCSLeadByte(ped,(BYTE)keyPress)) {
                    int DBCSkey;

                    if ((DBCSkey = DbcsCombine(ped->hwnd, keyPress)) != 0)
                        keyValue = DBCSkey;
                }
                MLInsertText(ped, (LPSTR)&keyValue, HIBYTE(keyValue) ? 2 : 1, TRUE);
            } else
                MLInsertText(ped, (LPSTR)&keyValue, HIWORD(keyValue) ? 2 : 1, TRUE);
        } else {
IllegalChar:
            NtUserMessageBeep(0);
        }
        break;
    }
}

/***************************************************************************\
* MLPasteText AorW
*
* Pastes a line of text from the clipboard into the edit control
* starting at ped->ichCaret. Updates ichMaxSel and ichMinSel to point to the
* end of the inserted text. Notifies the parent if space cannot be
* allocated. Returns how many characters were inserted.
*
* History:
\***************************************************************************/

ICH PASCAL NEAR MLPasteText(
    PED ped)
{
    HANDLE hData;
    LPSTR lpchClip;
    ICH cchAdded = 0;
    HCURSOR hCursorOld;

#ifdef UNDO_CLEANUP           // #ifdef Added in Chicago  - johnl
    if (!ped->fAutoVScroll) {

        /*
         * Empty the undo buffer if this edit control limits the amount of text
         * the user can add to the window rect. This is so that we can undo this
         * operation if doing in causes us to exceed the window boundaries.
         */
        ECEmptyUndo(ped);
    }
#endif

    hCursorOld = NtUserSetCursor(LoadCursor(NULL, IDC_WAIT));

    if (!OpenClipboard(ped->hwnd))
        goto PasteExitNoCloseClip;

    if (!(hData = GetClipboardData(ped->fAnsi ? CF_TEXT : CF_UNICODETEXT)) ||
            (GlobalFlags(hData) == GMEM_INVALID_HANDLE)) {
        RIPMSG1(RIP_WARNING, "MLPasteText(): couldn't get a valid handle(%x)", hData);
        goto PasteExit;
    }

    /*
     * See if any text should be deleted
     */
    MLDeleteText(ped);

    USERGLOBALLOCK(hData, lpchClip);
    if (lpchClip == NULL) {
        RIPMSG1(RIP_WARNING, "MLPasteText: USERGLOBALLOCK(%x) failed.", hData);
        goto PasteExit;
    }

    /*
     * Get the length of the addition.
     */
    if (ped->fAnsi)
        cchAdded = strlen(lpchClip);
    else
        cchAdded = wcslen((LPWSTR)lpchClip);

    /*
     * Insert the text (MLInsertText checks line length)
     */
    cchAdded = MLInsertText(ped, lpchClip, cchAdded, FALSE);

    USERGLOBALUNLOCK(hData);

PasteExit:
    NtUserCloseClipboard();

PasteExitNoCloseClip:
    NtUserSetCursor(hCursorOld);

    return (cchAdded);
}

/***************************************************************************\
* MLMouseMotion AorW
*
* History:
\***************************************************************************/

void MLMouseMotion(
    PED ped,
    UINT message,
    UINT virtKeyDown,
    LPPOINT mousePt)
{
    BOOL fChangedSel = FALSE;

    HDC hdc = ECGetEditDC(ped, TRUE);

    ICH ichMaxSel = ped->ichMaxSel;
    ICH ichMinSel = ped->ichMinSel;

    ICH mouseCch;
    ICH mouseLine;
    int i, j;
    LONG  ll, lh;

    mouseCch = MLMouseToIch(ped, hdc, mousePt, &mouseLine);

    /*
     * Save for timer
     */
    ped->ptPrevMouse = *mousePt;
    ped->prevKeys = virtKeyDown;

    switch (message) {
    case WM_LBUTTONDBLCLK:
        /*
         * if shift key is down, extend selection to word we double clicked on
         * else clear current selection and select word.
         */
        // LiZ -- 5/5/93
        if (ped->fAnsi && ped->fDBCS) {
            LPSTR pText = ECLock(ped);
            ECWord(ped,ped->ichCaret,
                   ECIsDBCSLeadByte(ped, *(pText+(ped->ichCaret)))
                        ? FALSE :
                          (ped->ichCaret == ped->chLines[ped->iCaretLine]
                              ? FALSE : TRUE), &ll, &lh);
            ECUnlock(ped);
        } else {
            ECWord(ped, mouseCch, !(mouseCch == ped->chLines[mouseLine]), &ll, &lh);
        }
        if (!(virtKeyDown & MK_SHIFT)) {
            // If shift key isn't down, move caret to mouse point and clear
            // old selection
            ichMinSel = ll;
            ichMaxSel = ped->ichCaret = lh;
        } else {
            // Shiftkey is down so we want to maintain the current selection
            // (if any) and just extend or reduce it
            if (ped->ichMinSel == ped->ichCaret) {
                ichMinSel = ped->ichCaret = ll;
                ECWord(ped, ichMaxSel, TRUE, &ll, &lh);
            } else {
                ichMaxSel = ped->ichCaret = lh;
                ECWord(ped, ichMinSel, FALSE, &ll, &lh);
            }
        }

        ped->ichStartMinSel = ll;
        ped->ichStartMaxSel = lh;

        goto InitDragSelect;

    case WM_MOUSEMOVE:
        if (ped->fMouseDown) {

            /*
             * Set the system timer to automatically scroll when mouse is
             * outside of the client rectangle. Speed of scroll depends on
             * distance from window.
             */
            i = mousePt->y < 0 ? -mousePt->y : mousePt->y - ped->rcFmt.bottom;
            j = gpsi->dtScroll - ((UINT)i << 4);
            if (j < 1)
                j = 1;
            NtUserSetSystemTimer(ped->hwnd, IDSYS_SCROLL, (UINT)j, NULL);

            fChangedSel = TRUE;

            // Extend selection, move caret right
            if (ped->ichStartMinSel || ped->ichStartMaxSel) {
                // We're in WORD SELECT mode
                BOOL fReverse = (mouseCch <= ped->ichStartMinSel);
                ECWord(ped, mouseCch, !fReverse, &ll, &lh);
                if (fReverse) {
                    ichMinSel = ped->ichCaret = ll;
                    ichMaxSel = ped->ichStartMaxSel;
                } else {
                    ichMinSel = ped->ichStartMinSel;
                    ichMaxSel = ped->ichCaret = lh;
                }
            } else if ((ped->ichMinSel == ped->ichCaret) &&
                    (ped->ichMinSel != ped->ichMaxSel))
                // Reduce selection extent
                ichMinSel = ped->ichCaret = mouseCch;
            else
                // Extend selection extent
                ichMaxSel = ped->ichCaret = mouseCch;

            ped->iCaretLine = mouseLine;
        }
        break;

    case WM_LBUTTONDOWN:
        ll = lh = mouseCch;

        if (!(virtKeyDown & MK_SHIFT)) {
            // If shift key isn't down, move caret to mouse point and clear
            // old selection
            ichMinSel = ichMaxSel = ped->ichCaret = mouseCch;
        } else {
            // Shiftkey is down so we want to maintain the current selection
            // (if any) and just extend or reduce it
            if (ped->ichMinSel == ped->ichCaret)
                ichMinSel = ped->ichCaret = mouseCch;
            else
                ichMaxSel = ped->ichCaret = mouseCch;
        }

        ped->ichStartMinSel = ped->ichStartMaxSel = 0;

InitDragSelect:
        ped->iCaretLine = mouseLine;

        ped->fMouseDown = FALSE;
        NtUserSetCapture(ped->hwnd);
        ped->fMouseDown = TRUE;
        fChangedSel = TRUE;

        // Set the timer so that we can scroll automatically when the mouse
        // is moved outside the window rectangle.
        NtUserSetSystemTimer(ped->hwnd, IDSYS_SCROLL, gpsi->dtScroll, NULL);
        break;

    case WM_LBUTTONUP:
        if (ped->fMouseDown) {

            /*
             * Kill the timer so that we don't do auto mouse moves anymore
             */
            NtUserKillSystemTimer(ped->hwnd, IDSYS_SCROLL);
            NtUserReleaseCapture();
            MLSetCaretPosition(ped, hdc);
            ped->fMouseDown = FALSE;
        }
        break;
    }


    if (fChangedSel) {
        MLChangeSelection(ped, hdc, ichMinSel, ichMaxSel);
        MLEnsureCaretVisible(ped);
    }

    ECReleaseEditDC(ped, hdc, TRUE);

    if (!ped->fFocus && (message == WM_LBUTTONDOWN)) {

        /*
         * If we don't have the focus yet, get it
         */
        NtUserSetFocus(ped->hwnd);
    }
}

/***************************************************************************\
* MLScroll AorW
*
* History:
\***************************************************************************/

LONG MLScroll(
    PED  ped,
    BOOL fVertical,
    int  cmd,
    int  iAmt,
    BOOL fRedraw)
{
    SCROLLINFO  si;
    int         dx = 0;
    int         dy = 0;
    BOOL        fIncludeLeftMargin;
    int         newPos;
    int         oldPos;
    BOOL        fUp = FALSE;
    UINT        wFlag;
    DWORD       dwTime = 0;

    if (fRedraw && (cmd != ML_REFRESH)) {
        UpdateWindow(ped->hwnd);
    }

    if (ped->pLpkEditCallout && ped->fRtoLReading && !fVertical
        && ped->maxPixelWidth > ped->rcFmt.right - ped->rcFmt.left) {
        /*
         * Horizontal scoll of a right oriented window with a scrollbar.
         * Map the logical xOffset to visual coordinates.
         */
        oldPos = ped->maxPixelWidth
                 - ((int)ped->xOffset + ped->rcFmt.right - ped->rcFmt.left);
    } else
        oldPos = (int) (fVertical ? ped->ichScreenStart : ped->xOffset);

    fIncludeLeftMargin = (ped->xOffset == 0);

    switch (cmd) {
        case ML_REFRESH:
            newPos = oldPos;
            break;

        case EM_GETTHUMB:
            return(oldPos);

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:

            /*
             * If the edit contains more than 0xFFFF lines
             * it means that the scrolbar can return a position
             * that cannot fit in a WORD (16 bits), so use
             * GetScrollInfo (which is slower) in this case.
             */
            if (ped->cLines < 0xFFFF) {
                newPos = iAmt;
            } else {
                SCROLLINFO si;

                si.cbSize   = sizeof(SCROLLINFO);
                si.fMask    = SIF_TRACKPOS;

                GetScrollInfo( ped->hwnd, SB_VERT, &si);

                newPos = si.nTrackPos;
            }
            break;

        case SB_TOP:      // == SB_LEFT
            newPos = 0;
            break;

        case SB_BOTTOM:   // == SB_RIGHT
            if (fVertical)
                newPos = ped->cLines;
            else
                newPos = ped->maxPixelWidth;
            break;

        case SB_PAGEUP:   // == SB_PAGELEFT
            fUp = TRUE;
        case SB_PAGEDOWN: // == SB_PAGERIGHT

            if (fVertical)
                iAmt = ped->ichLinesOnScreen - 1;
            else
                iAmt = (ped->rcFmt.right - ped->rcFmt.left) - 1;

            if (iAmt == 0)
                iAmt++;

            if (fUp)
                iAmt = -iAmt;
            goto AddDelta;

        case SB_LINEUP:   // == SB_LINELEFT
            fUp = TRUE;
        case SB_LINEDOWN: // == SB_LINERIGHT

            dwTime = iAmt;

            iAmt = 1;

            if (fUp)
                iAmt = -iAmt;

            //   |             |
            //   |  FALL THRU  |
            //   V             V

        case EM_LINESCROLL:
            if (!fVertical)
                iAmt *= ped->aveCharWidth;

AddDelta:
            newPos = oldPos + iAmt;
            break;

        default:
            return(0L);
    }

    if (fVertical) {
        if (si.nMax = ped->cLines)
            si.nMax--;

        if (!ped->hwndParent ||
            TestWF(ValidateHwnd(ped->hwndParent), WFWIN40COMPAT))
            si.nPage = ped->ichLinesOnScreen;
        else
            si.nPage = 0;

        wFlag = WFVSCROLL;
    } else         {
        si.nMax  = ped->maxPixelWidth;
        si.nPage = ped->rcFmt.right - ped->rcFmt.left;
        wFlag = WFHSCROLL;
    }

    if (TestWF(ValidateHwnd(ped->hwnd), wFlag)) {
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
        si.nMin  = 0;
        si.nPos = newPos;
        newPos = SetScrollInfo(ped->hwnd, fVertical ? SB_VERT : SB_HORZ,
                                     &si, fRedraw);
    } else {
        // BOGUS -- this is duped code from ScrollBar code
        // but it's for the case when we want to limit the position without
        // actually having the scroll bar
        int iMaxPos;

        // Clip page to 0, range + 1
        si.nPage = max(min((int)si.nPage, si.nMax + 1), 0);


        iMaxPos = si.nMax - (si.nPage ? si.nPage - 1 : 0);
        newPos = min(max(newPos, 0), iMaxPos);
    }

    oldPos -= newPos;

    if (!oldPos)
        return(0L);

    if (ped->pLpkEditCallout && ped->fRtoLReading && !fVertical
        && ped->maxPixelWidth > ped->rcFmt.right - ped->rcFmt.left) {
        // Map visual oldPos and newPos back to logical coordinates
        newPos = ped->maxPixelWidth
                 - (newPos + ped->rcFmt.right - ped->rcFmt.left);
        oldPos = -oldPos;
        if (newPos<0) {
            // Compensate for scroll bar returning pos > max-page
            oldPos += newPos;
            newPos=0;
        }
    }

    if (fVertical) {
        ped->ichScreenStart = newPos;
        dy = oldPos * ped->lineHeight;
    } else {
        ped->xOffset = newPos;
        dx = oldPos;
    }

    if (cmd != SB_THUMBTRACK)
        // We don't want to notify the parent of thumbtracking since they might
        // try to set the thumb position to something bogus.
        // NOTEPAD used to be guilty of this -- but I rewrote it so it's not.
        // The question is WHO ELSE does this? (jeffbog)
        ECNotifyParent(ped, fVertical ? EN_VSCROLL : EN_HSCROLL);

    if (fRedraw && _IsWindowVisible(ped->pwnd)) {
        RECT    rc;
        RECT    rcUpdate;
        RECT    rcClipRect;
        HDC     hdc;

        _GetClientRect(ped->pwnd, &rc);
        CopyRect(&rcClipRect, &ped->rcFmt);

        if (fVertical) { // Is this a vertical scroll?
            rcClipRect.left -= ped->wLeftMargin;
            rcClipRect.right += ped->wRightMargin;
        }

        IntersectRect(&rc, &rc, &rcClipRect);
        rc.bottom++;

        /*
         * Chicago has this HideCaret but there doesn't appear to be a
         * corresponding ShowCaret, so we lose the Caret under NT when the
         * EC scrolls - Johnl
         *
         * HideCaret(ped->hwnd);
         */

        hdc = ECGetEditDC(ped, FALSE);
        ECSetEditClip(ped, hdc, fIncludeLeftMargin);
        if (ped->hFont)
            SelectObject(hdc, ped->hFont);
        ECGetBrush(ped, hdc);

        if (ped->pLpkEditCallout && !fVertical) {
            // Horizontal scroll with complex script support
            int xFarOffset = ped->xOffset + ped->rcFmt.right - ped->rcFmt.left;

            rc = ped->rcFmt;
            if (dwTime != 0)
                ScrollWindowEx(ped->hwnd, ped->fRtoLReading ? -dx : dx, dy, NULL, NULL, NULL,
                        &rcUpdate, MAKELONG(SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime));
            else
                NtUserScrollDC(hdc, ped->fRtoLReading ? -dx : dx, dy,
                               &rc, &rc, NULL, &rcUpdate);

            // Handle margins: Blank if clipped by horizontal scrolling,
            // display otherwise.
            if (ped->wLeftMargin) {
                rc.left  = ped->rcFmt.left - ped->wLeftMargin;
                rc.right = ped->rcFmt.left;
                if (   (ped->format != ES_LEFT)   // Always display margin for centred or far-aligned text
                    ||  // Display LTR left margin if first character fully visible
                        (!ped->fRtoLReading && ped->xOffset == 0)
                    ||  // Display RTL left margin if last character fully visible
                        (ped->fRtoLReading && xFarOffset >= ped->maxPixelWidth)) {
                    UnionRect(&rcUpdate, &rcUpdate, &rc);
                } else {
                    ExtTextOutW(hdc, rc.left, rc.top,
                        ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX,
                        &rc, L"", 0, 0L);
                }
            }
            if (ped->wRightMargin) {
                rc.left  = ped->rcFmt.right;
                rc.right = ped->rcFmt.right + ped->wRightMargin;
                if (   (ped->format != ES_LEFT)   // Always display margin for centred or far-aligned text
                    ||  // Display RTL right margin if first character fully visible
                        (ped->fRtoLReading && ped->xOffset == 0)
                    ||  // Display LTR right margin if last character fully visible
                        (!ped->fRtoLReading && xFarOffset >= ped->maxPixelWidth)) {
                    UnionRect(&rcUpdate, &rcUpdate, &rc);
                } else {
                    ExtTextOutW(hdc, rc.left, rc.top,
                        ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX,
                        &rc, L"", 0, 0L);
                }
            }
        } else {
            if (dwTime != 0)
                ScrollWindowEx(ped->hwnd, dx, dy, NULL, NULL, NULL,
                        &rcUpdate, MAKELONG(SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime));
            else
                NtUserScrollDC(hdc, dx, dy, &rc, &rc, NULL, &rcUpdate);

            // If we need to wipe out the left margin area
            if (ped->wLeftMargin && !fVertical) {
                // Calculate the rectangle to be wiped out
                rc.right = rc.left;
                rc.left = max(0, (INT)(ped->rcFmt.left - ped->wLeftMargin));
                if (rc.left < rc.right) {
                    if (fIncludeLeftMargin && (ped->xOffset != 0)) {

                        ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED | ETO_OPAQUE,
                            &rc, L"", 0, 0L);
                    } else
                        if((!fIncludeLeftMargin) && (ped->xOffset == 0))
                            UnionRect(&rcUpdate, &rcUpdate, &rc);
                }
            }
        }
        MLSetCaretPosition(ped,hdc);

        ECReleaseEditDC(ped, hdc, FALSE);
        NtUserInvalidateRect(ped->hwnd, &rcUpdate,
                ((ped->ichLinesOnScreen + ped->ichScreenStart) >= ped->cLines));
        UpdateWindow(ped->hwnd);
    }

    return(MAKELONG(-oldPos, 1));
}

/***************************************************************************\
* MLSetFocus AorW
*
* Gives the edit control the focus and notifies the parent
* EN_SETFOCUS.
*
* History:
\***************************************************************************/

void MLSetFocus(
    PED ped)
{
    HDC hdc;

    if (!ped->fFocus) {
        ped->fFocus = 1; /* Set focus */

        hdc = ECGetEditDC(ped, TRUE);

        /*
         * Draw the caret. We need to do this even if the window is hidden
         * because in dlg box initialization time we may set the focus to a
         * hidden edit control window. If we don't create the caret etc, it will
         * never end up showing properly.
         */
        if (ped->pLpkEditCallout) {
            ped->pLpkEditCallout->EditCreateCaret (ped, hdc, ECGetCaretWidth(), ped->lineHeight, 0);
        }
        else {
            NtUserCreateCaret(ped->hwnd, (HBITMAP)NULL, ECGetCaretWidth(), ped->lineHeight);
        }
        NtUserShowCaret(ped->hwnd);
        MLSetCaretPosition(ped, hdc);

        /*
         * Show the current selection. Only if the selection was hidden when we
         * lost the focus, must we invert (show) it.
         */
        if (!ped->fNoHideSel && ped->ichMinSel != ped->ichMaxSel &&
                _IsWindowVisible(ped->pwnd))
            MLDrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel, TRUE);

        ECReleaseEditDC(ped, hdc, TRUE);

    }
#if 0
    MLEnsureCaretVisible(ped);
#endif

    /*
     * Notify parent we have the focus
     */
    ECNotifyParent(ped, EN_SETFOCUS);
}

/***************************************************************************\
* MLKillFocus AorW
*
* The edit control loses the focus and notifies the parent via
* EN_KILLFOCUS.
*
* History:
\***************************************************************************/

void MLKillFocus(
    PED ped)
{
    HDC hdc;

    /*
     * Reset the wheel delta count.
     */
    gcWheelDelta = 0;

    if (ped->fFocus) {
        ped->fFocus = 0; /* Clear focus */

        /*
         * Do this only if we still have the focus. But we always notify the
         * parent that we lost the focus whether or not we originally had the
         * focus.
         */

        /*
         * Hide the current selection if needed
         */
        if (!ped->fNoHideSel && ped->ichMinSel != ped->ichMaxSel &&
            _IsWindowVisible(ped->pwnd)) {
            hdc = ECGetEditDC(ped, FALSE);
            MLDrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel, TRUE);
            ECReleaseEditDC(ped, hdc, FALSE);
        }

        /*
         * Destroy the caret
         */
        NtUserDestroyCaret();
    }

    /*
     * Notify parent that we lost the focus.
     */
    ECNotifyParent(ped, EN_KILLFOCUS);
}

/***************************************************************************\
* MLEnsureCaretVisible AorW
*
* Scrolls the caret into the visible region.
* Returns TRUE if scrolling was done else return s FALSE.
*
* History:
\***************************************************************************/

BOOL MLEnsureCaretVisible(
    PED ped)
{
    UINT   iLineMax;
    int    xposition;
    BOOL   fPrevLine;
    HDC    hdc;
    BOOL   fVScroll = FALSE;
    BOOL   fHScroll = FALSE;

    if (_IsWindowVisible(ped->pwnd)) {
        int iAmt;
        int iFmtWidth = ped->rcFmt.right - ped->rcFmt.left;

        if (ped->fAutoVScroll) {
            iLineMax = ped->ichScreenStart + ped->ichLinesOnScreen - 1;

            if (fVScroll = (ped->iCaretLine > iLineMax))
                iAmt = iLineMax;
            else if (fVScroll = (ped->iCaretLine < ped->ichScreenStart))
                iAmt = ped->ichScreenStart;

            if (fVScroll)
                MLScroll(ped, TRUE, EM_LINESCROLL, ped->iCaretLine - iAmt, TRUE);
        }

        if (ped->fAutoHScroll && ((int) ped->maxPixelWidth > iFmtWidth)) {
            POINT pt;
            /* Get the current position of the caret in pixels */
            if ((UINT) (ped->cLines - 1) != ped->iCaretLine &&
                ped->ichCaret == ped->chLines[ped->iCaretLine + 1])
                fPrevLine = TRUE;
            else
                fPrevLine = FALSE;

            hdc = ECGetEditDC(ped,TRUE);
            MLIchToXYPos(ped, hdc, ped->ichCaret, fPrevLine, &pt);
            ECReleaseEditDC(ped, hdc, TRUE);
            xposition = pt.x;

            // Remember, MLIchToXYPos returns coordinates with respect to the
            // top left pixel displayed on the screen.  Thus, if xPosition < 0,
            // it means xPosition is less than current ped->xOffset.

            iFmtWidth /= 3;
            if (fHScroll = (xposition < ped->rcFmt.left))
                // scroll to the left
                iAmt = ped->rcFmt.left + iFmtWidth;
            else if (fHScroll = (xposition > ped->rcFmt.right))
                // scroll to the right
                iAmt = ped->rcFmt.right - iFmtWidth;

            if (fHScroll)
                MLScroll(ped, FALSE, EM_LINESCROLL, (xposition - iAmt) / ped->aveCharWidth, TRUE);
        }
    }
    return(fVScroll);
}

/***************************************************************************\
* MLEditWndProc
*
* Class procedure for all multi line edit controls.
* Dispatches all messages to the appropriate handlers which are named
* as follows:
* SL (single line) prefixes all single line edit control procedures while
* EC (edit control) prefixes all common handlers.
*
* The MLEditWndProc only handles messages specific to multi line edit
* controls.
*
* WARNING: If you add a message here, add it to gawEditWndProc[] in
* kernel\server.c too, otherwise EditWndProcA/W will send it straight to
* DefWindowProcWorker
*
* History:
\***************************************************************************/

LRESULT MLEditWndProc(
    HWND hwnd,
    PED ped,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    LPRECT      lprc;
    POINT       pt;
    DWORD       windowstyle;

    switch (message) {

    case WM_INPUTLANGCHANGE:
        if (ped && ped->fFocus && ped->pLpkEditCallout) {
            NtUserHideCaret(hwnd);
            hdc = ECGetEditDC(ped, TRUE);
            NtUserDestroyCaret();
            ped->pLpkEditCallout->EditCreateCaret (ped, hdc, ECGetCaretWidth(), ped->lineHeight, (UINT)lParam);
            MLSetCaretPosition(ped, hdc);
            ECReleaseEditDC(ped, hdc, TRUE);
            NtUserShowCaret(hwnd);
        }
        goto PassToDefaultWindowProc;


    case WM_STYLECHANGED:
        if (ped && ped->pLpkEditCallout) {
            switch (wParam) {

                case GWL_STYLE:
                    ECUpdateFormat(ped,
                        ((LPSTYLESTRUCT)lParam)->styleNew,
                        GetWindowLong(ped->hwnd, GWL_EXSTYLE));
                    return 1L;

                case GWL_EXSTYLE:
                    ECUpdateFormat(ped,
                        GetWindowLong(ped->hwnd, GWL_STYLE),
                        ((LPSTYLESTRUCT)lParam)->styleNew);
                    return 1L;
            }
        }

        goto PassToDefaultWindowProc;

    case WM_CHAR:

        /*
         * wParam - the value of the key
         * lParam - modifiers, repeat count etc (not used)
         */
        MLChar(ped, (UINT)wParam, 0);
        break;

    case WM_ERASEBKGND:  {
            HBRUSH  hbr;

            // USE SAME RULES AS IN ECGetBrush()
            if (ped->f40Compat &&
                (ped->fReadOnly || ped->fDisabled))
                hbr = (HBRUSH) CTLCOLOR_STATIC;
            else
                hbr = (HBRUSH) CTLCOLOR_EDIT;

            FillWindow(ped->hwndParent, hwnd, (HDC)wParam, hbr);
        }
        return ((LONG)TRUE);

    case WM_GETDLGCODE: {
            LONG code = DLGC_WANTCHARS | DLGC_HASSETSEL | DLGC_WANTARROWS | DLGC_WANTALLKEYS;

            /*
             ** !!! JEFFBOG HACK !!!
             ** Only set Dialog Box Flag if GETDLGCODE message is generated by
             ** IsDialogMessage -- if so, the lParam will be a pointer to the
             ** message structure passed to IsDialogMessage; otherwise, lParam
             ** will be NULL. Reason for the HACK alert: the wParam & lParam
             ** for GETDLGCODE is still not clearly defined and may end up
             ** changing in a way that would throw this off
             **
             */
            if (lParam)
               ped->fInDialogBox = TRUE; // Mark ML edit ctrl as in a dialog box

            /*
             ** If this is a WM_SYSCHAR message generated by the UNDO keystroke
             ** we want this message so we can EAT IT in "case WM_SYSCHAR:"
             */
            if (lParam && (((LPMSG)lParam)->message == WM_SYSCHAR) &&
                    ((DWORD)((LPMSG)lParam)->lParam & SYS_ALTERNATE) &&
                    ((WORD)wParam == VK_BACK))
                 code |= DLGC_WANTMESSAGE;
            return code;
        }

    case EM_SCROLL:
        message = WM_VSCROLL;

        /*
         * FALL THROUGH
         */
    case WM_HSCROLL:
    case WM_VSCROLL:
        return MLScroll(ped, (message==WM_VSCROLL), LOWORD(wParam), HIWORD(wParam), TRUE);

    case WM_MOUSEWHEEL:
        /*
         * Don't handle zoom and datazoom.
         */
        if (wParam & (MK_SHIFT | MK_CONTROL)) {
            goto PassToDefaultWindowProc;
        }

        gcWheelDelta -= (short) HIWORD(wParam);
        windowstyle = ped->pwnd->style;
        if (    abs(gcWheelDelta) >= WHEEL_DELTA &&
                gpsi->ucWheelScrollLines > 0 &&
                (windowstyle & (WS_VSCROLL | WS_HSCROLL))) {

            int     cLineScroll;
            BOOL    fVert;
            int     cPage;

            if (windowstyle & WS_VSCROLL) {
                fVert = TRUE;
                cPage = ped->ichLinesOnScreen;
            } else {
                fVert = FALSE;
                cPage = (ped->rcFmt.right - ped->rcFmt.left) / ped->aveCharWidth;
            }

            /*
             * Limit a roll of one (1) WHEEL_DELTA to scroll one (1) page.
             */
            cLineScroll = (int) min(
                    (UINT) (max(1, (cPage - 1))),
                    gpsi->ucWheelScrollLines);

            cLineScroll *= (gcWheelDelta / WHEEL_DELTA);
            UserAssert(cLineScroll != 0);
            gcWheelDelta = gcWheelDelta % WHEEL_DELTA;
            MLScroll(ped, fVert, EM_LINESCROLL, cLineScroll, TRUE);
        }

        break;

    case WM_KEYDOWN:

        /*
         * wParam - virt keycode of the given key
         * lParam - modifiers such as repeat count etc. (not used)
         */
        MLKeyDown(ped, (UINT)wParam, 0);
        break;

    case WM_KILLFOCUS:

        /*
         * wParam - handle of the window that receives the input focus
         * lParam - not used
         */
        MLKillFocus(ped);
        break;

    case WM_CAPTURECHANGED:
        //
        // wParam -- unused
        // lParam -- hwnd of window gaining capture.
        //
        if (ped->fMouseDown) {
            //
            // We don't change the caret pos here.  If this is happening
            // due to button up, then we'll change the pos in the
            // handler after ReleaseCapture().  Otherwise, just end
            // gracefully because someone else has stolen capture out
            // from under us.
            //

            ped->fMouseDown = FALSE;
            NtUserKillSystemTimer(ped->hwnd, IDSYS_SCROLL);
        }
        break;

    case WM_SYSTIMER:

        /*
         * This allows us to automatically scroll if the user holds the mouse
         * outside the edit control window. We simulate mouse moves at timer
         * intervals set in MouseMotionHandler.
         */
        if (ped->fMouseDown)
            MLMouseMotion(ped, WM_MOUSEMOVE, ped->prevKeys, &ped->ptPrevMouse);
        break;

    case WM_MBUTTONDOWN:
        EnterReaderModeHelper(ped->hwnd);
        break;

    case WM_MOUSEMOVE:
        UserAssert(ped->fMouseDown);

        /*
         * FALL THROUGH
         */
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
        /*
         * wParam - contains a value that indicates which virtual keys are down
           lParam - contains x and y coords of the mouse cursor
         */
        POINTSTOPOINT(pt, lParam);
        MLMouseMotion(ped, message, (UINT)wParam, &pt);
        break;

    case WM_CREATE:

        /*
         * wParam - handle to window being created
         * lParam - points to a CREATESTRUCT that contains copies of parameters
         * passed to the CreateWindow function.
         */
        return (MLCreate(ped, (LPCREATESTRUCT)lParam));

    case WM_PRINTCLIENT:
        MLPaint(ped, (HDC) wParam, NULL);
        break;

    case WM_PAINT:
        /*
         * wParam - can be hdc from subclassed paint
           lParam - not used
         */
        if (wParam) {
            hdc = (HDC) wParam;
            lprc = NULL;
        } else {
            hdc = NtUserBeginPaint(ped->hwnd, &ps);
            lprc = &ps.rcPaint;
        }

        if (_IsWindowVisible(ped->pwnd))
            MLPaint(ped, hdc, lprc);

        if (!wParam)
            NtUserEndPaint(ped->hwnd, &ps);
        break;

    case WM_PASTE:

        /*
         * wParam - not used
           lParam - not used
         */
        if (!ped->fReadOnly)
            MLPasteText(ped);
        break;

    case WM_SETFOCUS:

        /*
         * wParam - handle of window that loses the input focus (may be NULL)
           lParam - not used
         */
        MLSetFocus(ped);
        break;

    case WM_SIZE:

        /*
         * wParam - defines the type of resizing fullscreen, sizeiconic,
                    sizenormal etc.
           lParam - new width in LOWORD, new height in HIGHWORD of client area
         */
        ECSize(ped, NULL, TRUE);
        break;

    case EM_FMTLINES:

        /*
         * wParam - indicates disposition of end-of-line chars. If non
         * zero, the chars CR CR LF are placed at the end of a word
         * wrapped line. If wParam is zero, the end of line chars are
         * removed. This is only done when the user gets a handle (via
         * EM_GETHANDLE) to the text. lParam - not used.
         */
        if (wParam)
            MLInsertCrCrLf(ped);
        else
            MLStripCrCrLf(ped);
        MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);
        return (LONG)(wParam != 0);

    case EM_GETHANDLE:

        /*
         * wParam - not used
            lParam - not used
         */

        /*
         * Returns a handle to the edit control's text.
         */

        /*
         * Null terminate the string. Note that we are guaranteed to have the
         * memory for the NULL since ECInsertText allocates an extra
         * WCHAR for the NULL terminator.
         */

        if (ped->fAnsi)
            *(ECLock(ped) + ped->cch) = 0;
        else
            *((LPWSTR)ECLock(ped) + ped->cch) = 0;
        ECUnlock(ped);
        return ((LRESULT)ped->hText);

    case EM_GETLINE:

        /*
         * wParam - line number to copy (0 is first line)
         * lParam - buffer to copy text to. First WORD is max # of bytes to
         * copy
         */
        return MLGetLine(ped, (ICH)wParam, (ICH)*(WORD UNALIGNED *)lParam, (LPSTR)lParam);

    case EM_LINEFROMCHAR:

        /*
         * wParam - Contains the index value for the desired char in the text
         * of the edit control. These are 0 based.
         * lParam - not used
         */
        return (LRESULT)MLIchToLine(ped, (ICH)wParam);

    case EM_LINEINDEX:

        /*
         * wParam - specifies the desired line number where the number of the
         * first line is 0. If linenumber = 0, the line with the caret is used.
         * lParam - not used.
         * This function return s the number of character positions that occur
         * preceeding the first char in a given line.
         */
        {
            ICH ichResult = MLLineIndex(ped, (ICH)wParam);
            if (ichResult == (ICH)-1) {
                return -1;
            }
            return (LRESULT)ichResult;
        }
        break;

    case EM_LINELENGTH:

        /*
         * wParam - specifies the character index of a character in the
           specified line, where the first line is 0. If -1, the length
           of the current line (with the caret) is return ed not including the
           length of any selected text.
           lParam - not used
         */
        return (LRESULT)MLLineLength(ped, (ICH)wParam);

    case EM_LINESCROLL:

        /*
         * wParam - not used
           lParam - Contains the number of lines and char positions to scroll
         */
        MLScroll(ped, TRUE,  EM_LINESCROLL, (INT)lParam, TRUE);
        MLScroll(ped, FALSE, EM_LINESCROLL, (INT)wParam, TRUE);
        break;

    case EM_REPLACESEL:

        /*
         * wParam - flag for 4.0+ apps saying whether to clear undo
           lParam - Points to a null terminated replacement text.
         */
        MLReplaceSel(ped, (LPSTR)lParam);
        if (!ped->f40Compat || !wParam)
            ECEmptyUndo(Pundo(ped));
        break;

    case EM_SETHANDLE:

        /*
         * wParam - contains a handle to the text buffer
           lParam - not used
         */
        MLSetHandle(ped, (HANDLE)wParam);
        break;

    case EM_SETRECT:
    case EM_SETRECTNP:

        //
        // wParamLo --    not used
        // lParam --    LPRECT with new formatting area
        //
        ECSize(ped, (LPRECT) lParam, (message != EM_SETRECTNP));
        break;

    case EM_SETSEL:

        /*
         * wParam - Under 3.1, specifies if we should scroll caret into
         * view or not. 0 == scroll into view. 1 == don't scroll
         * lParam - starting pos in lowword ending pos in high word
         *
         * Under Win32, wParam is the starting pos, lParam is the
         * ending pos, and the caret is not scrolled into view.
         * The message EM_SCROLLCARET forces the caret to be scrolled
         * into view.
         */
        MLSetSelection(ped, TRUE, (ICH)wParam, (ICH)lParam);
        break;

    case EM_SCROLLCARET:

        /*
         * Scroll caret into view
         */
        MLEnsureCaretVisible(ped);
        break;

    case EM_GETFIRSTVISIBLELINE:

        /*
         * Returns the first visible line for multiline edit controls.
         */
        return (LONG)ped->ichScreenStart;

    case WM_SYSKEYDOWN:
        if (((WORD)wParam == VK_BACK) && ((DWORD)lParam & SYS_ALTERNATE)) {
            SendMessage(ped->hwnd, EM_UNDO, 0, 0L);
            break;
        }
        goto PassToDefaultWindowProc;

    case WM_UNDO:
    case EM_UNDO:
        return MLUndo(ped);

    case EM_SETTABSTOPS:

        /*
         * This sets the tab stop positions for multiline edit controls.
         * wParam - Number of tab stops
         * lParam - Far ptr to a UINT array containing the Tab stop positions
         */
        return MLSetTabStops(ped, (int)wParam, (LPINT)lParam);

    case EM_POSFROMCHAR:
        //
        // wParam --    char index in text
        // lParam --    not used
        // This function returns the (x,y) position of the character
        //
    case EM_CHARFROMPOS:
        //
        // wParam --    unused
        // lParam --    pt in client coordinates
        // This function returns
        //      LOWORD: the position of the closest character
        //              to the passed in point.  Beware of
        //              points not actually in the edit client...
        //      HIWORD: the index of the line the char is on
        //
        {
            LONG  xyPos;
            LONG  line;

            hdc = ECGetEditDC(ped, TRUE);

            if (message == EM_POSFROMCHAR) {
                MLIchToXYPos(ped, hdc, (ICH)wParam, FALSE, &pt);
                xyPos = MAKELONG(pt.x, pt.y);
            } else {
                POINTSTOPOINT(pt, lParam);
                xyPos = MLMouseToIch(ped, hdc, &pt, &line);
                xyPos = MAKELONG(xyPos, line);
            }

            ECReleaseEditDC(ped, hdc, TRUE);
            return((LRESULT)xyPos);
            break;
        }

    case WM_SETREDRAW:
        DefWindowProcWorker(ped->pwnd, message, wParam, lParam, FALSE);
        if (wParam) {

            /*
             * Backwards compatability hack needed so that winraid's edit
             * controls work fine.
             */
            RedrawWindow(hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME);
        }
      break;

#if LATER
    case WM_IME_ENDCOMPOSITION:
        ECInOutReconversionMode(ped, FALSE);
        break;
#endif

    default:
PassToDefaultWindowProc:
        return DefWindowProcWorker(ped->pwnd, message, wParam, lParam, ped->fAnsi);
    }

    return 1L;
} /* MLEditWndProc */


/***************************************************************************\
* MLDrawText AorW
*
*  This function draws all the characters between ichStart and ichEnd for
*  the given Multiline Edit Control.
*
*  This function divides the block of text between ichStart and ichEnd
*  into lines and each line into strips of text based on the selection
*  attributes. It calls ECTabTheTextOut() to draw each strip.
*  This takes care of the Negative A anc C widths of the current font, if
*  it has any, on either side of each strip of text.
*
*  NOTE: If the language pack is loaded the text is not divided into strips,
*  nor is selection highlighting performed here. Whole lines are passed
*  to the language pack to display with tab expansion and selection
*  highlighting. (Since the language pack supports scripts with complex
*  character re-ordering rules, only it can do this).
*
* History:
\***************************************************************************/

void MLDrawText(
    PED ped,
    HDC hdc,
    ICH ichStart,
    ICH ichEnd,
    BOOL fSelChange)
{
    DWORD   textColorSave;
    DWORD   bkColorSave;
    PSTR    pText;
    UINT    wCurLine;
    UINT    wEndLine;
    int     xOffset;
    ICH     LengthToDraw;
    ICH     CurStripLength;
    ICH     ichAttrib, ichNewStart;
    ICH     ExtraLengthForNegA;
    ICH     ichT;
    int     iRemainingLengthInLine;
    int     xStPos, xClipStPos, xClipEndPos, yPos;
    BOOL    fFirstLineOfBlock   = TRUE;
    BOOL    fDrawEndOfLineStrip = FALSE;
    BOOL    fDrawOnSameLine     = FALSE;
    BOOL    fSelected                = FALSE;
    BOOL    fLineBegins      = FALSE;
    STRIPINFO   NegCInfo;
    POINT   pt;

    //
    // Just return if nothing to draw
    if (!ped->ichLinesOnScreen)
        return;

    ECGetBrush(ped, hdc);

    //
    // Adjust the value of ichStart such that we need to draw only those lines
    // visible on the screen.
    //
    if ((UINT)ichStart < (UINT)ped->chLines[ped->ichScreenStart]) {
        ichStart = ped->chLines[ped->ichScreenStart];
        if (ichStart > ichEnd)
            return;
    }

    // Adjust the value of ichEnd such that we need to draw only those lines
    // visible on the screen.
    wCurLine = min(ped->ichScreenStart+ped->ichLinesOnScreen,ped->cLines-1);
    ichT = ped->chLines[wCurLine] + MLLine(ped, wCurLine);
    ichEnd = min(ichEnd, ichT);

    wCurLine = MLIchToLine(ped, ichStart);    // Starting line.
    wEndLine = MLIchToLine(ped, ichEnd);           // Ending line.

    UserAssert(ped->chLines[wCurLine] <= ped->cch + 1);
    UserAssert(ped->chLines[wEndLine] <= ped->cch + 1);

    if (fSelChange && (GetBkMode(hdc) != OPAQUE))
    {
        /*
         * if changing selection on a transparent edit control, just
         * draw those lines from scratch
         */
        RECT rcStrip;
        CopyRect(&rcStrip, &ped->rcFmt);
        rcStrip.left -= ped->wLeftMargin;
        if (ped->pLpkEditCallout) {
            rcStrip.right += ped->wRightMargin;
        }
        rcStrip.top += (wCurLine - ped->ichScreenStart) * ped->lineHeight;
        rcStrip.bottom = rcStrip.top + ((wEndLine - wCurLine) + 1) * ped->lineHeight;
        NtUserInvalidateRect(ped->hwnd, &rcStrip, TRUE);
        return;
    }

    // If it is either centered or right-justified, then draw the whole lines.
    // Also draw whole lines if the language pack is handling line layout.
    if ((ped->format != ES_LEFT) || (ped->pLpkEditCallout)) {
        ichStart = ped->chLines[wCurLine];
        ichEnd = ped->chLines[wEndLine] + MLLine(ped, wEndLine);
    }

    pText = ECLock(ped);

    NtUserHideCaret(ped->hwnd);

    //
    // If ichStart stays on Second byte of DBCS, we have to
    // adjust it. LiZ -- 5/5/93
    //
    if (ped->fAnsi && ped->fDBCS) {
        ichStart = ECAdjustIch( ped, pText, ichStart );
    }
    UserAssert(ichStart <= ped->cch);
    UserAssert(ichEnd <= ped->cch);

    while (ichStart <= ichEnd) {
        // Pass whole lines to the language pack to display with selection
        // marking and tab expansion.
        if (ped->pLpkEditCallout) {
            ped->pLpkEditCallout->EditDrawText(
                ped, hdc, pText + ped->cbChar*ichStart,
                MLLine(ped, wCurLine),
                (INT)ped->ichMinSel - (INT)ichStart, (INT)ped->ichMaxSel - (INT)ichStart,
                MLIchToYPos(ped, ichStart, FALSE));
        } else {
        // xStPos:      The starting Position where the string must be drawn.
        // xClipStPos:  The starting position for the clipping rect for the block.
        // xClipEndPos: The ending position for the clipping rect for the block.

        // Calculate the xyPos of starting point of the block.
        MLIchToXYPos(ped, hdc, ichStart, FALSE, &pt);
        xClipStPos = xStPos = pt.x;
        yPos = pt.y;

        // The attributes of the block is the same as that of ichStart.
        ichAttrib = ichStart;

        // If the current font has some negative C widths and if this is the
        // begining of a block, we must start drawing some characters before the
        // block to account for the negative C widths of the strip before the
        // current strip; In this case, reset ichStart and xStPos.

        if (fFirstLineOfBlock && ped->wMaxNegC) {
            fFirstLineOfBlock = FALSE;
            ichNewStart = max(((int)(ichStart - ped->wMaxNegCcharPos)), ((int)ped->chLines[wCurLine]));

            // If ichStart needs to be changed, then change xStPos also accordingly.
            if (ichNewStart != ichStart) {
                if (ped->fAnsi && ped->fDBCS) {
                    //
                    // Adjust DBCS alignment...
                    //
                    ichNewStart = ECAdjustIchNext( ped, pText, ichNewStart );
                }
                MLIchToXYPos(ped, hdc, ichStart = ichNewStart, FALSE, &pt);
                xStPos = pt.x;
            }
        }

        // Calc the number of characters remaining to be drawn in the current line.
        iRemainingLengthInLine = MLLine(ped, wCurLine) -
                                (ichStart - ped->chLines[wCurLine]);

        // If this is the last line of a block, we may not have to draw all the
        // remaining lines; We must draw only upto ichEnd.
        if (wCurLine == wEndLine)
            LengthToDraw = ichEnd - ichStart;
        else
            LengthToDraw = iRemainingLengthInLine;

        // Find out how many pixels we indent the line for non-left-justified
        // formats
        if (ped->format != ES_LEFT)
            xOffset = MLCalcXOffset(ped, hdc, wCurLine);
        else
            xOffset = -((int)(ped->xOffset));

        // Check if this is the begining of a line.
        if (ichAttrib == ped->chLines[wCurLine]) {
            fLineBegins = TRUE;
            xClipStPos = ped->rcFmt.left - ped->wLeftMargin;
        }

        //
        // The following loop divides this 'wCurLine' into strips based on the
        // selection attributes and draw them strip by strip.
        do  {
            //
            // If ichStart is pointing at CRLF or CRCRLF, then iRemainingLength
            // could have become negative because MLLine does not include
            // CR and LF at the end of a line.
            //
            if (iRemainingLengthInLine < 0)  // If Current line is completed,
                break;                   // go on to the next line.

            //
            // Check if a part of the block is selected and if we need to
            // show it with a different attribute.
            //
            if (!(ped->ichMinSel == ped->ichMaxSel ||
                        ichAttrib >= ped->ichMaxSel ||
                        ichEnd   <  ped->ichMinSel ||
                        (!ped->fNoHideSel && !ped->fFocus))) {
                //
                // OK! There is a selection somewhere in this block!
                // Check if this strip has selection attribute.
                //
                if (ichAttrib < ped->ichMinSel) {
                    fSelected = FALSE;  // This strip is not selected

                    // Calculate the length of this strip with normal attribute.
                    CurStripLength = min(ichStart+LengthToDraw, ped->ichMinSel)-ichStart;
                    fLineBegins = FALSE;
                } else {
                    // The current strip has the selection attribute.
                    if (fLineBegins) {  // Is it the first part of a line?
                        // Then, draw the left margin area with normal attribute.
                        fSelected = FALSE;
                        CurStripLength = 0;
                        xClipStPos = ped->rcFmt.left - ped->wLeftMargin;
                        fLineBegins = FALSE;
                    } else {
                        // Else, draw the strip with selection attribute.
                        fSelected = TRUE;
                        CurStripLength = min(ichStart+LengthToDraw, ped->ichMaxSel)-ichStart;

                        // Select in the highlight colors.
                        bkColorSave = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                        if (!ped->fDisabled)
                            textColorSave = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                    }
                }
            } else {
                // The whole strip has no selection attributes.
                CurStripLength = LengthToDraw;
            }

            //
            // Other than the current strip, do we still have anything
            // left to be drawn in the current line?
            //
            fDrawOnSameLine = (LengthToDraw != CurStripLength);

            //
            // When we draw this strip, we need to draw some more characters
            // beyond the end of this strip to account for the negative A
            // widths of the characters that follow this strip.
            //
            ExtraLengthForNegA = min(iRemainingLengthInLine-CurStripLength, ped->wMaxNegAcharPos);

            //
            // The blank strip at the end of the line needs to be drawn with
            // normal attribute irrespective of whether the line has selection
            // attribute or not. Hence, if the last strip of the line has selection
            // attribute, then this blank strip needs to be drawn separately.
            // Else, we can draw the blank strip along with the last strip.
            //

            // Is this the last strip of the current line?
            if (iRemainingLengthInLine == (int)CurStripLength) {
                if (fSelected) { // Does this strip have selection attribute?
                    // Then we need to draw the end of line strip separately.
                    fDrawEndOfLineStrip = TRUE;  // Draw the end of line strip.
                    MLIchToXYPos(ped, hdc, ichStart+CurStripLength, TRUE, &pt);
                    xClipEndPos = pt.x;
                } else {
                    //
                    // Set the xClipEndPos to a big value sothat the blank
                    // strip will be drawn automatically when the last strip
                    // is drawn.
                    //
                    xClipEndPos = MAXCLIPENDPOS;
                }
            } else {
                //
                // This is not the last strip of this line; So, set the ending
                // clip position accurately.
                //
                MLIchToXYPos(ped, hdc, ichStart+CurStripLength, FALSE, &pt);
                xClipEndPos = pt.x;
            }

            //
            // Draw the current strip starting from xStPos, clipped to the area
            // between xClipStPos and xClipEndPos. Obtain "NegCInfo" and use it
            // in drawing the next strip.
            //
            ECTabTheTextOut(hdc, xClipStPos, xClipEndPos,
                    xStPos, yPos, (LPSTR)(pText+ichStart*ped->cbChar),
                CurStripLength+ExtraLengthForNegA, ichStart, ped,
                ped->rcFmt.left+xOffset, fSelected ? ECT_SELECTED : ECT_NORMAL, &NegCInfo);

            if (fSelected) {
                //
                // If this strip was selected, then the next strip won't have
                // selection attribute
                //
                fSelected = FALSE;
                SetBkColor(hdc, bkColorSave);
                if (!ped->fDisabled)
                    SetTextColor(hdc, textColorSave);
            }

            // Do we have one more strip to draw on the current line?
            if (fDrawOnSameLine || fDrawEndOfLineStrip) {
                int  iLastDrawnLength;

                //
                // Next strip's attribute is decided based on the char at ichAttrib
                //
                ichAttrib = ichStart + CurStripLength;

                //
                // When drawing the next strip, start at a few chars before
                // the actual start to account for the Neg 'C' of the strip
                // just drawn.
                //
                iLastDrawnLength = CurStripLength +ExtraLengthForNegA - NegCInfo.nCount;
                //
                // Adjust DBCS alignment...
                //
                if (ped->fAnsi && ped->fDBCS) {
                    ichNewStart = ECAdjustIch(ped,pText,ichStart+iLastDrawnLength);
                    iLastDrawnLength = ichNewStart - ichStart;
                    ichStart = ichNewStart;
                } else {
                    ichStart += iLastDrawnLength;
                }
                LengthToDraw -= iLastDrawnLength;
                iRemainingLengthInLine -= iLastDrawnLength;

                //
                // The start of clip rect for the next strip.
                //
                xStPos = NegCInfo.XStartPos;
                xClipStPos = xClipEndPos;
            }

            // Draw the blank strip at the end of line seperately, if required.
            if (fDrawEndOfLineStrip) {
                ECTabTheTextOut(hdc, xClipStPos, MAXCLIPENDPOS, xStPos, yPos,
                    (LPSTR)(pText+ichStart*ped->cbChar), LengthToDraw, ichStart,
                    ped, ped->rcFmt.left+xOffset, ECT_NORMAL, &NegCInfo);

                fDrawEndOfLineStrip = FALSE;
            }
        }
        while(fDrawOnSameLine);   // do while loop ends here.
        }

        // Let us move on to the next line of this block to be drawn.
        wCurLine++;
        if (ped->cLines > wCurLine)
            ichStart = ped->chLines[wCurLine];
        else
            ichStart = ichEnd+1;   // We have reached the end of the text.
    }  // while loop ends here

    ECUnlock(ped);

    NtUserShowCaret(ped->hwnd);
    MLSetCaretPosition(ped, hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\editec.c ===
/****************************************************************************\
* editec.c - Edit controls rewrite. Version II of edit controls.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 24-Jul-88 davidds
\****************************************************************************/

/* Warning: The single line editcontrols contain internal styles and API which
 * are need to support comboboxes. They are defined in combcom.h/combcom.inc
 * and may be redefined or renumbered as needed.
 */

#include "precomp.h"
#pragma hdrstop

LOOKASIDE EditLookaside;

ICH ECFindTabA(LPSTR lpstr, ICH cch);
ICH ECFindTabW(LPWSTR lpstr, ICH cch);

#define umin(a, b)  ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))
#define umax(a, b)  ((unsigned)(a) > (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))

#define UNICODE_CARRIAGERETURN ((WCHAR)0x0d)
#define UNICODE_LINEFEED ((WCHAR)0x0a)
#define UNICODE_TAB ((WCHAR)0x09)


// IME Menu IDs
#define ID_IMEOPENCLOSE      10001
#define ID_SOFTKBDOPENCLOSE  10002
#define ID_RECONVERTSTRING   10003

typedef struct {
    DWORD fDisableCut : 1;
    DWORD fDisablePaste : 1;
    DWORD fNeedSeparatorBeforeImeMenu : 1;
    DWORD fIME : 1;
} EditMenuItemState;

/***************************************************************************\
* Handlers common to both single and multi line edit controls.
/***************************************************************************/

/***************************************************************************\
* ECLock
*
* History:
\***************************************************************************/

PSTR ECLock(
    PED ped)
{
    PSTR ptext = LOCALLOCK(ped->hText, ped->hInstance);
    ped->iLockLevel++;

    /*
     * If this is the first lock of the text and the text is encoded
     * decode the text.
     */
    //RIPMSG2(RIP_VERBOSE, "lock  : %d '%10s'\n", ped->iLockLevel, ptext);
    if (ped->iLockLevel == 1 && ped->fEncoded) {
        /*
         * rtlrundecode can't handle zero length strings
         */
        if (ped->cch != 0) {
            STRING string;
            string.Length = string.MaximumLength = (USHORT)(ped->cch * ped->cbChar);
            string.Buffer = ptext;

            RtlRunDecodeUnicodeString(ped->seed, (PUNICODE_STRING)&string);
            //RIPMSG1(RIP_VERBOSE, "Decoding: '%10s'\n", ptext);
        }
        ped->fEncoded = FALSE;
    }
    return ptext;
}

/***************************************************************************\
* ECUnlock
*
* History:
\***************************************************************************/

void ECUnlock(
    PED ped)
{
    /*
     * if we are removing the last lock on the text and the password
     * character is set then encode the text
     */
    //RIPMSG1(RIP_VERBOSE, "unlock: %d '%10s'\n", ped->iLockLevel, ped->ptext);
    if (ped->charPasswordChar && ped->iLockLevel == 1 && ped->cch != 0) {
        UNICODE_STRING string;
        string.Length = string.MaximumLength = (USHORT)(ped->cch * ped->cbChar);
        string.Buffer = LOCALLOCK(ped->hText, ped->hInstance);

        RtlRunEncodeUnicodeString(&(ped->seed), &string);
        //RIPMSG1(RIP_VERBOSE, "Encoding: '%10s'\n", ped->ptext);
        ped->fEncoded = TRUE;
        LOCALUNLOCK(ped->hText, ped->hInstance);
    }
    LOCALUNLOCK(ped->hText, ped->hInstance);
    ped->iLockLevel--;
}

/***************************************************************************\
*
*  GetActualNegA()
*     For a given strip of text, this function computes the negative A width
* for the whole strip and returns the value as a postive number.
*     It also fills the NegAInfo structure with details about the postion
* of this strip that results in this Negative A.
*
\***************************************************************************/
UINT GetActualNegA(
    HDC hdc,
    PED ped,
    int x,
    LPSTR lpstring,
    ICH ichString,
    int nCount,
    LPSTRIPINFO NegAInfo)
{
    int iCharCount, i;
    int iLeftmostPoint = x;
    PABC  pABCwidthBuff;
    UINT  wCharIndex;
    int xStartPoint = x;
    ABC abc;

    // To begin with, let us assume that there is no negative A width for
    // this strip and initialize accodingly.

    NegAInfo->XStartPos = x;
    NegAInfo->lpString = lpstring;
    NegAInfo->nCount  = 0;
    NegAInfo->ichString = ichString;

    // If the current font is not a TrueType font, then there can not be any
    // negative A widths.
    if (!ped->fTrueType) {
        if(!ped->charOverhang) {
            return 0;
        } else {
            NegAInfo->nCount = min(nCount, (int)ped->wMaxNegAcharPos);
            return ped->charOverhang;
        }
    }

    // How many characters are to be considered for computing Negative A ?
    iCharCount = min(nCount, (int)ped->wMaxNegAcharPos);

    // Do we have the info on individual character's widths?
    if(!ped->charWidthBuffer) {
        // No! So, let us tell them to consider all the characters.
        NegAInfo->nCount = iCharCount;
        return(iCharCount * ped->aveCharWidth);
    }

    pABCwidthBuff = (PABC) ped->charWidthBuffer;

    if (ped->fAnsi) {
        for (i = 0; i < iCharCount; i++) {
            wCharIndex = (UINT)(*((unsigned char *)lpstring));
            if (*lpstring == VK_TAB) {
                // To play it safe, we assume that this tab results in a tab length of
                // 1 pixel because this is the minimum possible tab length.
                x++;
            } else {
                if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                    x += pABCwidthBuff[wCharIndex].abcA;  // Add the 'A' width.
                else {
                    GetCharABCWidthsA(hdc, wCharIndex, wCharIndex, &abc) ;
                    x += abc.abcA;
                }

                if (x < iLeftmostPoint)
                    iLeftmostPoint = x;             // Reset the leftmost point.
                if (x < xStartPoint)
                    NegAInfo->nCount = i+1;   // 'i' is index; To get the count add 1.

                if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH ) {
                    x += pABCwidthBuff[wCharIndex].abcB + pABCwidthBuff[wCharIndex].abcC;
                } else {
                    x += abc.abcB + abc.abcC;
                }
            }

            lpstring++;
        }
    } else {   // Unicode
        LPWSTR lpwstring = (LPWSTR) lpstring ;

        for (i = 0; i < iCharCount; i++) {
            wCharIndex = *lpwstring ;
            if (*lpwstring == VK_TAB) {
                // To play it safe, we assume that this tab results in a tab length of
                // 1 pixel because this is the minimum possible tab length.
                x++;
            } else {
                if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                    x += pABCwidthBuff[wCharIndex].abcA;  // Add the 'A' width.
                else {
                    GetCharABCWidthsW(hdc, wCharIndex, wCharIndex, &abc) ;
                    x += abc.abcA ;
                }

                if (x < iLeftmostPoint)
                    iLeftmostPoint = x;             // Reset the leftmost point.
                if (x < xStartPoint)
                    NegAInfo->nCount = i+1;   // 'i' is index; To get the count add 1.

                if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                    x += pABCwidthBuff[wCharIndex].abcB +
                         pABCwidthBuff[wCharIndex].abcC;
                else
                    x += abc.abcB + abc.abcC ;
            }

            lpwstring++;
        }
    }

    // Let us return the negative A for the whole strip as a positive value.
    return((UINT)(xStartPoint - iLeftmostPoint));
}


/***************************************************************************\
*
*  ECIsAncestorActive()
*
*  Returns whether or not we're the child of an "active" window.  Looks for
*  the first parent window that has a caption.
*
*  This is a function because we might use it elsewhere when getting left
*  clicked on, etc.
*
\***************************************************************************/
BOOL   ECIsAncestorActive(HWND hwnd)
{
    // We want to return TRUE always for top level windows.  That's because
    // of how WM_MOUSEACTIVATE works.  If we see the click at all, the
    // window is active.  However, if we reach a child ancestor that has
    // a caption, return the frame-on style bit.
    //
    // Note that calling FlashWindow() will have an effect.  If the user
    // clicks on an edit field in a child window that is flashed off, nothing
    // will happen unless the window stops flashing and ncactivates first.

    while (hwnd) {
        PWND pwnd = ValidateHwnd( hwnd );
        //
        // Bail out if some parent window isn't 4.0 compatible or we've
        // reached the top.  Fixes compatibility problems with 3.x apps,
        // especially MFC samples.
        //
        if (!TestWF(pwnd, WFWIN40COMPAT) || !TestWF(pwnd, WFCHILD))
            hwnd = NULL; // to break us out of the loop
        else if (TestWF(pwnd, WFCPRESENT))
            return(TestWF(pwnd, WFFRAMEON) != 0);
        else
            hwnd = GetParent(hwnd);
    }

    return(TRUE);
}

/***************************************************************************\
 * ECSetIMEMenu()
 *
 * support IME specific context menu
 *
 * Create: 30-Apr-97 Hiroyama : Ported from Memphis
\***************************************************************************/
BOOL ECSetIMEMenu(
    HMENU hMenu,
    HWND hwnd,
    EditMenuItemState state)
{

    MENUITEMINFO mii;
    HIMC hIMC;
    HKL hKL;
    HMENU hmenuSub;
    WCHAR szRes[32];
    int nPrevLastItem;
    int nItemsAdded = 0;

    UserAssert(IS_IME_ENABLED() && state.fIME);

    hKL = THREAD_HKL();
    if (!fpImmIsIME(hKL))
        return TRUE;

    hIMC = fpImmGetContext(hwnd);
    if (hIMC == NULL) {
        // early out
        return FALSE;
    }

    hmenuSub = GetSubMenu(hMenu, 0);

    if (hmenuSub == NULL) {
        return FALSE;
    }

    nPrevLastItem = GetMenuItemCount(hmenuSub);

    if (hIMC) {
        if (LOWORD(HandleToUlong(hKL)) != 0x412) {
            //
            // If Korean, do not show open/close menus
            //
            if (fpImmGetOpenStatus(hIMC))
                LoadString(hmodUser, STR_IMECLOSE, szRes, ARRAYSIZE(szRes));
            else
                LoadString(hmodUser, STR_IMEOPEN, szRes, ARRAYSIZE(szRes));

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szRes;
            mii.cch = 0xffff;
            mii.wID = ID_IMEOPENCLOSE;
            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }

        if (fpImmGetProperty(hKL, IGP_CONVERSION) & IME_CMODE_SOFTKBD) {
            DWORD fdwConversion;

            fpImmGetConversionStatus(hIMC, &fdwConversion, NULL);

            if (fdwConversion & IME_CMODE_SOFTKBD)
               LoadString(hmodUser, STR_SOFTKBDCLOSE, szRes, ARRAYSIZE(szRes));
            else
               LoadString(hmodUser, STR_SOFTKBDOPEN, szRes, ARRAYSIZE(szRes));

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szRes;
            mii.cch = 0xffff;
            mii.wID = ID_SOFTKBDOPENCLOSE;
            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }

        if (LOWORD(HandleToUlong(hKL)) != 0x412) {
            //
            // If Korean, do not show reconversion menus
            //
            DWORD dwSCS = fpImmGetProperty(hKL, IGP_SETCOMPSTR);

            LoadString(hmodUser, STR_RECONVERTSTRING, szRes, ARRAYSIZE(szRes));

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID | MIIM_STATE;
            mii.dwTypeData = szRes;
            mii.fState = 0;
            mii.cch = 0xffff;
            mii.wID = ID_RECONVERTSTRING;

            if (state.fDisableCut ||
                    !(dwSCS & SCS_CAP_SETRECONVERTSTRING) ||
                    !(dwSCS & SCS_CAP_MAKEREAD)) {
                mii.fState |= MFS_GRAYED;
            }

            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }
    }

    //
    // Add or remove the menu separator
    //
    if (state.fNeedSeparatorBeforeImeMenu && nItemsAdded != 0) {
        //
        // If the menu for Middle East has left a separator,
        // fNeedSeparatorBeforeImeMenu is FALSE.
        // I.e. we don't need to add more.
        //
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_FTYPE;
        mii.fType = MFT_SEPARATOR;
        InsertMenuItem(hmenuSub, nPrevLastItem, TRUE, &mii);
    }
    else if (!state.fNeedSeparatorBeforeImeMenu && nItemsAdded == 0) {
        //
        // Extra separator is left by ME menus. Remove it.
        //
        UserVerify(NtUserDeleteMenu(hmenuSub, nPrevLastItem - 1, MF_BYPOSITION));
    }

    fpImmReleaseContext(hwnd, hIMC);

    return TRUE;
}

void ECInOutReconversionMode(PED ped, BOOL fIn)
{
    UserAssert(fIn == TRUE || fIn == FALSE);
    if (fIn == ped->fInReconversion) {
        return;
    }
    ped->fInReconversion = fIn;
    if (ped->fFocus) {
        (fIn ? NtUserHideCaret: NtUserShowCaret)(ped->hwnd);
    }

    return;
}

/***************************************************************************\
 * ECDoIMEMenuCommand()
 *
 * support IME specific context menu
 *
 * Create: 30-Apr-97 Hiroyama : Ported from Memphis
\***************************************************************************/
BOOL NEAR ECDoIMEMenuCommand(PED ped, int cmd, HWND hwnd)
{
    HIMC hIMC;

    // early out
    switch (cmd) {
    case ID_IMEOPENCLOSE:
    case ID_SOFTKBDOPENCLOSE:
    case ID_RECONVERTSTRING:
        break;
    default:
        return FALSE;
    }

    // everybody needs hIMC, so get it here
    hIMC = fpImmGetContext(hwnd);
    if (hIMC == NULL) {
        // indicate to caller, that no further command processing needed
        return TRUE;
    }

    switch (cmd) {
    case ID_IMEOPENCLOSE:
        {
            // switch IME Open/Close status
            BOOL fOpen = fpImmGetOpenStatus(hIMC);

            fpImmSetOpenStatus(hIMC, !fOpen);
        }
        break;

    case ID_SOFTKBDOPENCLOSE:
        {
            DWORD fdwConversion;

            if (fpImmGetConversionStatus(hIMC, &fdwConversion, NULL)) {
                //
                // Toggle soft keyboard Open/Close status
                //
                fpImmEnumInputContext(0, SyncSoftKbdState,
                        (fdwConversion & IME_CMODE_SOFTKBD) != IME_CMODE_SOFTKBD);
            }
        }
        break;

    case ID_RECONVERTSTRING:
        {
            DWORD dwStrLen; // holds TCHAR count of recionversion string
            DWORD cbLen;    // holds BYTE SIZE of reconversion string
            DWORD dwSize;
            LPRECONVERTSTRING lpRCS;

            // pass current selection to IME for reconversion
            dwStrLen = ped->ichMaxSel - ped->ichMinSel;
            cbLen = dwStrLen * ped->cbChar;
            dwSize = cbLen + sizeof(RECONVERTSTRING) + 8;

            lpRCS = (LPRECONVERTSTRING)UserLocalAlloc(0, dwSize);

            if (lpRCS) {
                LPBYTE pText;
                ICH    ichSelMinOrg;

                ichSelMinOrg = ped->ichMinSel;

                pText = ECLock(ped);
                if (pText != NULL) {
                    LPBYTE lpDest;
                    BOOL (WINAPI* fpSetCompositionStringAW)(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);

                    lpRCS->dwSize = dwSize;
                    lpRCS->dwVersion = 0;

                    lpRCS->dwStrLen =
                    lpRCS->dwCompStrLen =
                    lpRCS->dwTargetStrLen = dwStrLen;

                    lpRCS->dwStrOffset = sizeof(RECONVERTSTRING);
                    lpRCS->dwCompStrOffset =
                    lpRCS->dwTargetStrOffset = 0;

                    lpDest = (LPBYTE)lpRCS + sizeof(RECONVERTSTRING);

                    RtlCopyMemory(lpDest, pText + ped->ichMinSel * ped->cbChar, cbLen);
                    if (ped->fAnsi) {
                        LPBYTE psz = (LPBYTE)lpDest;
                        psz[cbLen] = '\0';
                        fpSetCompositionStringAW = fpImmSetCompositionStringA;
                    } else {
                        LPWSTR pwsz = (LPWSTR)lpDest;
                        pwsz[dwStrLen] = L'\0';
                        fpSetCompositionStringAW = fpImmSetCompositionStringW;
                    }

                    ECUnlock(ped);

                    UserAssert(fpSetCompositionStringAW != NULL);

                    ECInOutReconversionMode(ped, TRUE);
                    ECImmSetCompositionWindow(ped, 0, 0); // x and y will be overriden anyway

                    // Query the IME for a valid Reconvert string range first.
                    fpSetCompositionStringAW(hIMC, SCS_QUERYRECONVERTSTRING, lpRCS, dwSize, NULL, 0);

                    // If current IME updates the original reconvert structure,
                    // it is necessary to update the text selection based on the 
                    // new reconvert text range.
                    if ((lpRCS->dwCompStrLen != dwStrLen) || (ichSelMinOrg != ped->ichMinSel)) {
                        ICH ichSelStart;
                        ICH ichSelEnd;

                        ichSelStart = ichSelMinOrg + (lpRCS->dwCompStrOffset  / ped->cbChar);
                        ichSelEnd = ichSelStart + lpRCS->dwCompStrLen;

                        (ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_SETSEL, ichSelStart, ichSelEnd);
                    }

                    fpSetCompositionStringAW(hIMC, SCS_SETRECONVERTSTRING, lpRCS, dwSize, NULL, 0);
                } // pText
                UserLocalFree(lpRCS);
            }
        }
        break;

    default:
        // should never reach here.
        RIPMSG1(RIP_ERROR, "ECDoIMEMenuCommand: unknown command id %d; should never reach here.", cmd);
        return FALSE;
    }

    UserAssert(hIMC != NULL);
    fpImmReleaseContext(hwnd, hIMC);

    return TRUE;
}

/***************************************************************************\
*
*  ECMenu()
*
*  Handles context menu for edit fields.  Disables inappropriate commands.
*  Note that this is NOT subclassing friendly, like most of our functions,
*  for speed and convenience.
*
\***************************************************************************/
void  ECMenu(
    HWND hwnd,
    PED ped,
    LPPOINT pt)
{
    HMENU   hMenu;
    int     cmd = 0;
    int     x;
    int     y;
    UINT    uFlags = TPM_NONOTIFY | TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON;
    EditMenuItemState state = {
        FALSE,              // fDisableCut
        TRUE,               // fDisablePaste
        TRUE,               // fNeedSeparatorBeforeImeMenu
        IS_IME_ENABLED() && fpImmIsIME(THREAD_HKL()), // fIME
    };

    // Set focus if we don't have it.
    if (!ped->fFocus)
        NtUserSetFocus(hwnd);

    // Grab the menu from USER's resources...
    if (!(hMenu = LoadMenu( hmodUser, MAKEINTRESOURCE( ID_EC_PROPERTY_MENU ))))
        return ;


    // Undo -- not allowed if we have no saved undo info
    if (ped->undoType == UNDO_NONE)
        EnableMenuItem(hMenu, WM_UNDO, MF_BYCOMMAND | MFS_GRAYED);

    if (ped->fReadOnly || ped->charPasswordChar) {
        // Cut and Delete -- not allowed if read-only or password
        state.fDisableCut = TRUE;
    } else {
        // Cut, Delete -- not allowed if there's no selection
        if (ped->ichMinSel == ped->ichMaxSel)
            state.fDisableCut = TRUE;
    }
    // Paste -- not allowed if there's no text on the clipboard
    // (this works for both OEM and Unicode)
    // Used to be always disabled for password edits MCostea #221035

    if (NtUserIsClipboardFormatAvailable(CF_TEXT))
        state.fDisablePaste = FALSE;

    if (state.fDisableCut) {
        EnableMenuItem(hMenu, WM_CUT,   MF_BYCOMMAND | MFS_GRAYED);
        EnableMenuItem(hMenu, WM_CLEAR, MF_BYCOMMAND | MFS_GRAYED);
    }

    if (state.fDisablePaste)
        EnableMenuItem(hMenu, WM_PASTE, MF_BYCOMMAND | MFS_GRAYED);

    // Copy -- not allowed if there's no selection or password ec
    if ((ped->ichMinSel == ped->ichMaxSel) || (ped->charPasswordChar))
        EnableMenuItem(hMenu, WM_COPY, MF_BYCOMMAND | MFS_GRAYED);

    // Select All -- not allowed if there's no text or if everything is
    // selected.   Latter case takes care of first one.
    if ((ped->ichMinSel == 0) && (ped->ichMaxSel == ped->cch))
        EnableMenuItem(hMenu, EM_SETSEL, MF_BYCOMMAND | MFS_GRAYED);

    if (ped->pLpkEditCallout) {
        ped->pLpkEditCallout->EditSetMenu(ped, hMenu);
    } else {
        NtUserDeleteMenu(hMenu, ID_CNTX_DISPLAYCTRL, MF_BYCOMMAND);
        NtUserDeleteMenu(hMenu, ID_CNTX_RTL,         MF_BYCOMMAND);
        NtUserDeleteMenu(hMenu, ID_CNTX_INSERTCTRL,  MF_BYCOMMAND);

        if (state.fIME) {
            // One separator is left in the menu,
            // no need to add the one before IME menus
            state.fNeedSeparatorBeforeImeMenu = FALSE;
        } else {
            // Extra separator is left. Remove it.
            HMENU hmenuSub = GetSubMenu(hMenu, 0);
            int nItems = GetMenuItemCount(hmenuSub) - 1;

            UserAssert(nItems >= 0);
            UserAssert(GetMenuState(hmenuSub, nItems, MF_BYPOSITION) & MF_SEPARATOR);
            // remove needless separator
            UserVerify(NtUserDeleteMenu(hmenuSub, nItems, MF_BYPOSITION));
        }
    }

    // IME specific menu
    if (state.fIME) {
        ECSetIMEMenu(hMenu, hwnd, state);
    }

    // BOGUS
    // We position the menu below & to the right of the point clicked on.
    // Is this cool?  I think so.  Excel 4.0 does the same thing.  It
    // seems like it would be neat if we could avoid obscuring the
    // selection.  But in actuality, it seems even more awkward to move
    // the menu out of the way of the selection.  The user can't click
    // and drag that way, and they have to move the mouse a ton.
    //
    // We need to use TPM_NONOTIFY because VBRUN100 and VBRUN200 GP-fault
    // on unexpected menu messages.
    //

    /*
     *  if message came via the keyboard then center on the control
     *  We use -1 && -1 here not 0xFFFFFFFF like Win95 becuase we
     *  previously converted the lParam to a point with sign extending.
     */
    if (pt->x == -1 && pt->y == -1) {
        RECT rc;

        GetWindowRect(hwnd, &rc);
        x = rc.left + (rc.right - rc.left) / 2;
        y = rc.top + (rc.bottom - rc.top) / 2;
    } else {
        x = pt->x;
        y = pt->y;
    }

    if (RTL_UI()) {
        uFlags |= TPM_LAYOUTRTL;
    }
    cmd = NtUserTrackPopupMenuEx(GetSubMenu(hMenu, 0),  uFlags, x, y, hwnd, NULL);

    // Free our menu
    NtUserDestroyMenu(hMenu);

    if (cmd && (cmd != -1)) {
        if (ped->pLpkEditCallout && cmd) {
            ped->pLpkEditCallout->EditProcessMenu(ped, cmd);
        }
        if (!state.fIME || !ECDoIMEMenuCommand(ped, cmd, hwnd)) {
            // if cmd is not IME specific menu, send it.
            SendMessage(hwnd, cmd, 0, (cmd == EM_SETSEL) ? 0xFFFFFFFF : 0L );
        }
    }
}



/***************************************************************************\
*
*  ECClearText()
*
*  Clears selected text.  Does NOT _send_ a fake char backspace.
*
\***************************************************************************/
void   ECClearText(PED ped) {
    if (!ped->fReadOnly &&
        (ped->ichMinSel < ped->ichMaxSel)) {
        if (ped->fSingle)
            SLEditWndProc(ped->hwnd, ped, WM_CHAR, VK_BACK, 0L );
        else
            MLEditWndProc(ped->hwnd, ped, WM_CHAR, VK_BACK, 0L );
    }

}


/***************************************************************************\
*
*  ECCutText() -
*
*  Cuts selected text.  This removes and copies the selection to the clip,
*  or if nothing is selected we delete (clear) the left character.
*
\***************************************************************************/
void   ECCutText(PED ped) {
    // Cut selection--IE, remove and copy to clipboard, or if no selection,
    // delete (clear) character left.
    if (!ped->fReadOnly &&
        (ped->ichMinSel < ped->ichMaxSel) &&
        SendMessage(ped->hwnd, WM_COPY, 0, 0L)) {
        // If copy was successful, delete the copied text by sending a
        // backspace message which will redraw the text and take care of
        // notifying the parent of changes.
        ECClearText(ped);
    }
}

/***************************************************************************\
*
*  ECGetModKeys()
*
*  Gets modifier key states.  Currently, we only check for VK_CONTROL and
*  VK_SHIFT.
*
\***************************************************************************/
int   ECGetModKeys(int keyMods) {
    int scState;

    scState = 0;

    if (!keyMods) {
        if (GetKeyState(VK_CONTROL) < 0)
            scState |= CTRLDOWN;
        if (GetKeyState(VK_SHIFT) < 0)
            scState |= SHFTDOWN;
    } else if (keyMods != NOMODIFY)
        scState = keyMods;

    return scState;
}

/***************************************************************************\
*
*  ECTabTheTextOut() AorW
*    If fDrawText == FALSE, then this function returns the text extent of
*  of the given strip of text. It does not worry about the Negative widths.
*
*    If fDrawText == TRUE, this draws the given strip of Text expanding the
*  tabs to proper lengths, calculates and fills up the NegCInfoForStrip with
*  details required to draw the portions of this strip that goes beyond the
*  xClipEndPos due to Negative C widths.
*
*  Returns the max width AS A DWORD.  We don't care about the height
*  at all.  No one uses it.  We keep a DWORD because that way we avoid
*  overflow.
*
*  NOTE: If the language pack is loaded EcTabTheTextOut is not used - the
*  language pack must take care of all tab expansion and selection
*  highlighting with full support for bidi layout and complex script
*  glyph reordering.
*
\***************************************************************************/
UINT ECTabTheTextOut(
    HDC hdc,
    int xClipStPos,
    int xClipEndPos,
    int xStart,
    int y,
    LPSTR lpstring,
    int nCount,
    ICH ichString,
    PED ped,
    int iTabOrigin,
    BOOL fDraw,
    LPSTRIPINFO NegCInfoForStrip)
{
    int     nTabPositions;         // Count of tabstops in tabstop array.
    LPINT   lpintTabStopPositions; // Tab stop positions in pixels.

    int     cch;
    UINT    textextent;
    int     xEnd;
    int     pixeltabstop = 0;
    int     i;
    int     cxCharWidth;
    RECT    rc;
    BOOL    fOpaque;
    BOOL    fFirstPass = TRUE;
    PINT    charWidthBuff;

    int     iTabLength;
    int     nConsecutiveTabs;
    int     xStripStPos;
    int     xStripEndPos;
    int     xEndOfStrip;
    STRIPINFO  RedrawStripInfo;
    STRIPINFO  NegAInfo;
    LPSTR    lpTab;
    LPWSTR   lpwTab;
    UINT     wNegCwidth, wNegAwidth;
    int      xRightmostPoint = xClipStPos;
    int      xTabStartPos;
    int      iSavedBkMode = 0;
    WCHAR    wchar;
    SIZE     size;
    ABC   abc ;

    // Algorithm: Draw the strip opaquely first. If a tab length is so
    // small that the portions of text on either side of a tab overlap with
    // the other, then this will result in some clipping. So, such portion
    // of the strip is remembered in "RedrawStripInfo" and redrawn
    // transparently later to compensate the clippings.
    //    NOTE: "RedrawStripInfo" can hold info about just one portion. So, if
    // more than one portion of the strip needs to be redrawn transparently,
    // then we "merge" all such portions into a single strip and redraw that
    // strip at the end.

    if (fDraw) {
        // To begin with, let us assume that there is no Negative C for this
        // strip and initialize the Negative Width Info structure.
        NegCInfoForStrip->nCount = 0;
        NegCInfoForStrip->XStartPos = xClipEndPos;

        // We may not have to redraw any portion of this strip.
        RedrawStripInfo.nCount = 0;

        fOpaque = (GetBkMode(hdc) == OPAQUE) || (fDraw == ECT_SELECTED);
    }
#if DBG
    else {
        //
        // Both MLGetLineWidth() and ECCchInWidth() should be clipping
        // nCount to avoid overflow.
        //
        if (nCount > MAXLINELENGTH)
            RIPMSG0(RIP_WARNING, "ECTabTheTextOut: nCount > MAXLINELENGTH");
    }
#endif

    // Let us define the Clip rectangle.
    rc.left   = xClipStPos;
    rc.right  = xClipEndPos;
    rc.top    = y;
    rc.bottom = y + ped->lineHeight;

    // Check if anything needs to be drawn.
    if (!lpstring || !nCount) {
        if (fDraw)
            ExtTextOutW(hdc, xClipStPos, y,
                  (fOpaque ? ETO_OPAQUE | ETO_CLIPPED : ETO_CLIPPED),
                  &rc, L"", 0, 0L);
        return(0L);
    }

    //
    // Starting position
    //
    xEnd = xStart;

    cxCharWidth  = ped->aveCharWidth;

    nTabPositions = (ped->pTabStops ? *(ped->pTabStops) : 0);
    if (ped->pTabStops) {
        lpintTabStopPositions = (LPINT)(ped->pTabStops+1);
        if (nTabPositions == 1) {
            pixeltabstop = lpintTabStopPositions[0];
            if (!pixeltabstop)
                pixeltabstop = 1;
        }
    } else {
        lpintTabStopPositions = NULL;
        pixeltabstop = 8*cxCharWidth;
    }

    // The first time we will draw the strip Opaquely. If some portions need
    // to be redrawn , then we will set the mode to TRANSPARENT and
    // jump to this location to redraw those portions.

RedrawStrip:
    while (nCount) {
        wNegCwidth = ped->wMaxNegC;

        // Search for the first TAB in this strip; also compute the extent
        // of the the strip upto and not including the tab character.
        //
        // Note - If the langpack is loaded, there will be no charWidthBuffer.
        //
        if (ped->charWidthBuffer) {     // Do we have a character width buffer?
            textextent = 0;
            cch = nCount;

            if (ped->fTrueType) {     // If so, does it have ABC widths?

                UINT iRightmostPoint = 0;
                UINT wCharIndex;
                PABC pABCwidthBuff;

                pABCwidthBuff = (PABC) ped->charWidthBuffer;

                if ( ped->fAnsi ) {
                    for (i = 0; i < nCount; i++) {

                        if (lpstring[i] == VK_TAB) {
                            cch = i;
                            break;
                        }

                        wCharIndex = (UINT)(((unsigned char  *)lpstring)[i]);
                        if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH) {
                            textextent += (UINT)(pABCwidthBuff[wCharIndex].abcA +
                                pABCwidthBuff[wCharIndex].abcB);
                        } else {    // not in cache, will ask driver
                            GetCharABCWidthsA(hdc, wCharIndex, wCharIndex, &abc);
                            textextent += abc.abcA + abc.abcB ;
                        }

                        if (textextent > iRightmostPoint)
                            iRightmostPoint = textextent;

                        if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH) {
                            textextent += pABCwidthBuff[wCharIndex].abcC;
                        } else {    // not in cache
                            textextent += abc.abcC;
                        }

                        if (textextent > iRightmostPoint)
                            iRightmostPoint = textextent;
                    }

                } else {   // Unicode
                    for (i = 0; i < nCount; i++) {
                        WCHAR UNALIGNED * lpwstring = (WCHAR UNALIGNED *)lpstring;

                        if (lpwstring[i] == VK_TAB) {
                            cch = i;
                            break;
                        }

                        wCharIndex = lpwstring[i] ;
                        if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                            textextent += pABCwidthBuff[wCharIndex].abcA +
                                          pABCwidthBuff[wCharIndex].abcB;
                        else {
                            GetCharABCWidthsW(hdc, wCharIndex, wCharIndex, &abc) ;
                            textextent += abc.abcA + abc.abcB ;
                        }

                        /*
                         * Note that abcC could be negative so we need this
                         * statement here *and* below
                         */
                        if (textextent > iRightmostPoint)
                            iRightmostPoint = textextent;

                        if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                            textextent += pABCwidthBuff[wCharIndex].abcC;
                        else
                            textextent += abc.abcC ;

                        if (textextent > iRightmostPoint)
                            iRightmostPoint = textextent;
                    }
                }

                wNegCwidth = (int)(iRightmostPoint - textextent);
            } else {   // !ped->fTrueType
                // No! This is not a TrueType font; So, we have only character
                // width info in this buffer.

                charWidthBuff = ped->charWidthBuffer;

                if ( ped->fAnsi ) {
                    // Initially assume no tabs exist in the text so cch=nCount.
                    for (i = 0; i < nCount; i++) {
                        if (lpstring[i] == VK_TAB) {
                            cch = i;
                            break;
                        }

                        //
                        // Call GetTextExtentPoint for dbcs/hankaku characters
                        //
                        if (ped->fDBCS && (i+1 < nCount)
                                && ECIsDBCSLeadByte(ped,lpstring[i])) {
                            GetTextExtentPointA(hdc, &lpstring[i], 2, &size);
                            textextent += size.cx;
                            i++;
                        } else if ((UCHAR)lpstring[i] >= CHAR_WIDTH_BUFFER_LENGTH) {
                            // Skip this GetExtentPoint call for non hankaku code points
                            // Or if the character is in the width cache.
                            GetTextExtentPointA(hdc, &lpstring[i], 1, &size);
                            textextent += size.cx;
                        } else {
                            textextent += (UINT)(charWidthBuff[(UINT)(((unsigned char  *)lpstring)[i])]);
                        }
                    }
                } else {
                    LPWSTR lpwstring = (LPWSTR) lpstring ;
                    INT    cchUStart;  // start of unicode character count

                    for (i = 0; i < nCount; i++) {
                        if (lpwstring[i] == VK_TAB) {
                            cch = i;
                            break;
                        }

                        wchar = lpwstring[i];
                        if (wchar >= CHAR_WIDTH_BUFFER_LENGTH) {

                            /*
                             * We have a Unicode character that is not in our
                             * cache, get all the characters outside the cache
                             * before getting the text extent on this part of the
                             * string.
                             */
                            cchUStart = i;
                            while (wchar >= CHAR_WIDTH_BUFFER_LENGTH &&
                                    wchar != VK_TAB && i < nCount) {
                                wchar = lpwstring[++i];
                            }

                            GetTextExtentPointW(hdc, (LPWSTR)lpwstring + cchUStart,
                                    i-cchUStart, &size);
                            textextent += size.cx;


                            if (wchar == VK_TAB || i >= nCount) {
                                cch = i;
                                break;
                            }
                            /*
                             * We have a char that is in the cache, fall through.
                             */
                        }
                        /*
                         * The width of this character is in the cache buffer.
                         */
                        textextent += ped->charWidthBuffer[wchar];
                    }
                }
            } // fTrueType else.

            nCount -= cch;
        } else {  // If we don't have a buffer that contains the width info.
            /*
             * Gotta call the driver to do our text extent.
             */

            if ( ped->fAnsi ) {
                cch = (int)ECFindTabA(lpstring, nCount);
                GetTextExtentPointA(hdc, lpstring, cch, &size) ;
            } else {
                cch = (int)ECFindTabW((LPWSTR) lpstring, nCount);
                GetTextExtentPointW(hdc, (LPWSTR)lpstring, cch, &size);
            }
            nCount -= cch;
            //
            // Subtruct Overhang for Italic fonts.
            //
            textextent = (size.cx - ped->charOverhang);
        }

        //
        // textextent is computed.
        //

        xStripStPos = xEnd;
        xEnd += (int)textextent;
        xStripEndPos = xEnd;

        // We will consider the negative widths only if when we draw opaquely.
        if (fFirstPass && fDraw) {
            xRightmostPoint = max(xStripEndPos + (int)wNegCwidth, xRightmostPoint);

            // Check if this strip peeps beyond the clip region.
            if (xRightmostPoint > xClipEndPos) {
                if (!NegCInfoForStrip->nCount) {
                    NegCInfoForStrip->lpString = lpstring;
                    NegCInfoForStrip->ichString = ichString;
                    NegCInfoForStrip->nCount = nCount+cch;
                    NegCInfoForStrip->XStartPos = xStripStPos;
                }
            }
        }  /* if (fFirstPass && fDraw) */

        if ( ped->fAnsi )
            lpTab = lpstring + cch; // Possibly Points to a tab character.
        else
            lpwTab = ((LPWSTR)lpstring) + cch ;

        // we must consider all the consecutive tabs and calculate the
        // the begining of next strip.
        nConsecutiveTabs = 0;
        while (nCount &&
               (ped->fAnsi ? (*lpTab == VK_TAB) : (*lpwTab == VK_TAB))) {
            // Find the next tab position and update the x value.
            xTabStartPos = xEnd;
            if (pixeltabstop)
                xEnd = (((xEnd-iTabOrigin)/pixeltabstop)*pixeltabstop) +
                    pixeltabstop + iTabOrigin;
            else {
                for (i = 0; i < nTabPositions; i++) {
                    if (xEnd < (lpintTabStopPositions[i] + iTabOrigin)) {
                        xEnd = (lpintTabStopPositions[i] + iTabOrigin);
                        break;
                    }
                 }

                // Check if all the tabstops set are exhausted; Then start using
                // default tab stop positions.
                if (i == nTabPositions) {
                    pixeltabstop = 8*cxCharWidth;
                    xEnd = ((xEnd - iTabOrigin)/pixeltabstop)*pixeltabstop +
                        pixeltabstop + iTabOrigin;
                }
            }

            if (fFirstPass && fDraw) {
                xRightmostPoint = max(xEnd, xRightmostPoint);

                /* Check if this strip peeps beyond the clip region */
                if (xRightmostPoint > xClipEndPos) {
                    if (!NegCInfoForStrip->nCount) {
                        NegCInfoForStrip->ichString = ichString + cch + nConsecutiveTabs;
                        NegCInfoForStrip->nCount = nCount;
                        NegCInfoForStrip->lpString = (ped->fAnsi ?
                                                        lpTab : (LPSTR) lpwTab);
                        NegCInfoForStrip->XStartPos = xTabStartPos;
                    }
                }
            }   /* if(fFirstPass) */

            nConsecutiveTabs++;
            nCount--;
            ped->fAnsi ? lpTab++ : (LPSTR) (lpwTab++) ;  // Move to the next character.
        }  // while(*lpTab == TAB) //

        if (fDraw) {
            if (fFirstPass) {
                // Is anything remaining to be drawn in this strip?
                if (!nCount)
                    rc.right = xEnd;      // No! We are done.
                else {
                    // "x" is the effective starting position of next strip.
                    iTabLength = xEnd - xStripEndPos;

                    // Check if there is a possibility of this tab length being too small
                    // compared to the negative A and C widths if any.
                    if ((wNegCwidth + (wNegAwidth = ped->wMaxNegA)) > (UINT)iTabLength) {
                        // Unfortunately, there is a possiblity of an overlap.
                        // Let us find out the actual NegA for the next strip.
                        wNegAwidth = GetActualNegA(
                              hdc,
                              ped,
                              xEnd,
                              lpstring + (cch + nConsecutiveTabs)*ped->cbChar,
                              ichString + cch + nConsecutiveTabs,
                              nCount,
                              &NegAInfo);
                    }

                    // Check if they actually overlap //
                    if ((wNegCwidth + wNegAwidth) <= (UINT)iTabLength) {
                        // No overlap between the strips. This is the ideal situation.
                        rc.right = xEnd - wNegAwidth;
                    } else {
                        // Yes! They overlap.
                        rc.right = xEnd;

                        // See if negative C width is too large compared to tab length.
                        if (wNegCwidth > (UINT)iTabLength) {
                            // Must redraw transparently a part of the current strip later.
                            if (RedrawStripInfo.nCount) {
                                // A previous strip also needs to be redrawn; So, merge this
                                // strip to that strip.
                                RedrawStripInfo.nCount = (ichString -
                                    RedrawStripInfo.ichString) + cch;
                            } else {
                                RedrawStripInfo.nCount = cch;
                                RedrawStripInfo.lpString = lpstring;
                                RedrawStripInfo.ichString = ichString;
                                RedrawStripInfo.XStartPos = xStripStPos;
                            }
                        }

                        if (wNegAwidth) {
                            // Must redraw transparently the first part of the next strip later.
                            if (RedrawStripInfo.nCount) {
                                // A previous strip also needs to be redrawn; So, merge this
                                // strip to that strip.
                                RedrawStripInfo.nCount = (NegAInfo.ichString - RedrawStripInfo.ichString) +
                                       NegAInfo.nCount;
                            } else
                                RedrawStripInfo = NegAInfo;
                        }
                    }
                } // else (!nCount) //
            }  // if (fFirstPass) //

            if (rc.left < xClipEndPos) {
                if (fFirstPass) {
                    // If this is the end of the strip, then complete the rectangle.
                    if ((!nCount) && (xClipEndPos == MAXCLIPENDPOS))
                        rc.right = max(rc.right, xClipEndPos);
                    else
                        rc.right = min(rc.right, xClipEndPos);
                }

                // Draw the current strip.
                if (rc.left < rc.right)
                    if ( ped->fAnsi )
                        ExtTextOutA(hdc,
                                    xStripStPos,
                                    y,
                                    (fFirstPass && fOpaque ? (ETO_OPAQUE | ETO_CLIPPED) : ETO_CLIPPED),
                                    (LPRECT)&rc, lpstring, cch, 0L);
                    else
                        ExtTextOutW(hdc,
                                    xStripStPos,
                                    y,
                                    (fFirstPass && fOpaque ? (ETO_OPAQUE | ETO_CLIPPED) : ETO_CLIPPED),
                                    (LPRECT)&rc, (LPWSTR)lpstring, cch, 0L);

            }

            if (fFirstPass)
                rc.left = max(rc.right, xClipStPos);
            ichString += (cch+nConsecutiveTabs);
        }  // if (fDraw) //

        // Skip over the tab and the characters we just drew.
        lpstring += (cch + nConsecutiveTabs) * ped->cbChar;
    }  // while (nCount) //

    xEndOfStrip = xEnd;

    // check if we need to draw some portions transparently.
    if (fFirstPass && fDraw && RedrawStripInfo.nCount) {
        iSavedBkMode = SetBkMode(hdc, TRANSPARENT);
        fFirstPass = FALSE;

        nCount = RedrawStripInfo.nCount;
        rc.left = xClipStPos;
        rc.right = xClipEndPos;
        lpstring = RedrawStripInfo.lpString;
        ichString = RedrawStripInfo.ichString;
        xEnd = RedrawStripInfo.XStartPos;
        goto RedrawStrip;  // Redraw Transparently.
    }

    if (iSavedBkMode)             // Did we change the Bk mode?
        SetBkMode(hdc, iSavedBkMode);  // Then, let us set it back!

    return((UINT)(xEndOfStrip - xStart));
}



/***************************************************************************\
* ECCchInWidth AorW
*
* Returns maximum count of characters (up to cch) from the given
* string (starting either at the beginning and moving forward or at the
* end and moving backwards based on the setting of the fForward flag)
* which will fit in the given width. ie. Will tell you how much of
* lpstring will fit in the given width even when using proportional
* characters. WARNING: If we use kerning, then this loses...
*
* History:
*
* NOTE: ECCchInWidth is not called if the language pack is loaded.
\***************************************************************************/

ICH ECCchInWidth(
    PED ped,
    HDC hdc,
    LPSTR lpText,
    ICH cch,
    int width,
    BOOL fForward)
{
    int stringExtent;
    int cchhigh;
    int cchnew = 0;
    int cchlow = 0;
    SIZE size;
    LPSTR lpStart;

    if ((width <= 0) || !cch)
        return (0);

    /*
     * Optimize nonproportional fonts for single line ec since they don't have
     * tabs.
     */
    //
    // Change optimize condition for fixed pitch font
    //
    if (ped->fNonPropFont && ped->fSingle && !ped->fDBCS) {
        return (ECAdjustIch( ped, lpText, umin(width/ped->aveCharWidth,(int)cch)));
    }

    /*
     * Check if password hidden chars are being used.
     */
    if (ped->charPasswordChar) {
        return (umin(width / ped->cPasswordCharWidth, (int)cch));
    }

    /*
     * ALWAYS RESTRICT TO AT MOST MAXLINELENGTH to avoid overflow...
     */
    cch = umin(MAXLINELENGTH, cch);

    cchhigh = cch + 1;
    while (cchlow < cchhigh - 1) {
        cchnew = umax((cchhigh - cchlow) / 2, 1) + cchlow;

        lpStart = lpText;

        /*
         * If we want to figure out how many fit starting at the end and moving
         * backwards, make sure we move to the appropriate position in the
         * string before calculating the text extent.
         */
        if (!fForward)
            lpStart += (cch - cchnew)*ped->cbChar;

        if (ped->fSingle) {
            if (ped->fAnsi)
                GetTextExtentPointA(hdc, (LPSTR)lpStart, cchnew, &size);
            else
                GetTextExtentPointW(hdc, (LPWSTR)lpStart, cchnew, &size);
            stringExtent = size.cx;
        } else {
            stringExtent = ECTabTheTextOut(hdc, 0, 0, 0, 0,
                lpStart,
                cchnew, 0,
                ped, 0, ECT_CALC, NULL );
        }

        if (stringExtent > width) {
            cchhigh = cchnew;
        } else {
            cchlow = cchnew;
        }
    }
    //
    // Call ECAdjustIch ( generic case )
    //
    cchlow = ECAdjustIch( ped, lpText, cchlow );
    return (cchlow);
}

/***************************************************************************\
* ECFindTab
*
* Scans lpstr and return s the number of CHARs till the first TAB.
* Scans at most cch chars of lpstr.
*
* History:
\***************************************************************************/

ICH ECFindTabA(
    LPSTR lpstr,
    ICH cch)
{
    LPSTR copylpstr = lpstr;

    if (!cch)
        return 0;

    while (*lpstr != VK_TAB) {
        lpstr++;
        if (--cch == 0)
            break;
    }
    return ((ICH)(lpstr - copylpstr));
}

ICH ECFindTabW(
    LPWSTR lpstr,
    ICH cch)
{
    LPWSTR copylpstr = lpstr;

    if (!cch)
        return 0;

    while (*lpstr != VK_TAB) {
        lpstr++;
        if (--cch == 0)
            break;
    }
    return ((ICH)(lpstr - copylpstr));
}

/***************************************************************************\
*
*  ECGetBrush()
*
*  Gets appropriate background brush to erase with.
*
\***************************************************************************/
HBRUSH ECGetBrush(PED ped, HDC hdc)
{
    HBRUSH  hbr;
    BOOL    f40Compat;

    f40Compat = (GETAPPVER() >= VER40);

    // Get background brush
    if ((ped->fReadOnly || ped->fDisabled) && f40Compat) {
        hbr = ECGetControlBrush(ped, hdc, WM_CTLCOLORSTATIC);
    } else
        hbr = ECGetControlBrush(ped, hdc, WM_CTLCOLOREDIT);

    if (ped->fDisabled && (ped->fSingle || f40Compat)) {
        DWORD rgb;

        // Change text color
        rgb = GetSysColor(COLOR_GRAYTEXT);
        if (rgb != GetBkColor(hdc))
            SetTextColor(hdc, rgb);
    }
    return(hbr);
}


/***************************************************************************\
* NextWordCallBack
*
*
*
* History:
* 02-19-92 JimA Ported from Win31 sources.
\***************************************************************************/

void NextWordCallBack(
    PED ped,
    ICH ichStart,
    BOOL fLeft,
    ICH  *pichMin,
    ICH  *pichMax )
{
    ICH ichMinSel;
    ICH ichMaxSel;
    LPSTR pText;

    pText = ECLock(ped);

    if (fLeft || (!(BOOL)CALLWORDBREAKPROC(ped->lpfnNextWord, (LPSTR)pText,
            ichStart, ped->cch, WB_ISDELIMITER) &&
            (ped->fAnsi ? (*(pText + ichStart) != VK_RETURN) : (*((LPWSTR)pText + ichStart) != VK_RETURN))
        ))
        ichMinSel = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)pText, ichStart, ped->cch, WB_LEFT);
    else
        ichMinSel = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)pText, ichStart, ped->cch, WB_RIGHT);

    ichMaxSel = min(ichMinSel + 1, ped->cch);

    if (ped->fAnsi) {
        if (*(pText + ichMinSel) == VK_RETURN) {
            if (ichMinSel > 0 && *(pText + ichMinSel - 1) == VK_RETURN) {

                /*
                 * So that we can treat CRCRLF as one word also.
                 */
                ichMinSel--;
            } else if (*(pText+ichMinSel + 1) == VK_RETURN) {

                /*
                 * Move MaxSel on to the LF
                 */
                ichMaxSel++;
            }
        }
    } else {
        if (*((LPWSTR)pText + ichMinSel) == VK_RETURN) {
            if (ichMinSel > 0 && *((LPWSTR)pText + ichMinSel - 1) == VK_RETURN) {

                /*
                 * So that we can treat CRCRLF as one word also.
                 */
                ichMinSel--;
            } else if (*((LPWSTR)pText+ichMinSel + 1) == VK_RETURN) {

                /*
                 * Move MaxSel on to the LF
                 */
                ichMaxSel++;
            }
        }
    }
    ichMaxSel = CALLWORDBREAKPROC(ped->lpfnNextWord, (LPSTR)pText, ichMaxSel, ped->cch, WB_RIGHT);
    ECUnlock(ped);

    if (pichMin)  *pichMin = ichMinSel;
    if (pichMax)  *pichMax = ichMaxSel;
}

/***************************************************************************\
* NextWordLpkCallback
*
* Identifies next/prev word position for complex scripts
*
* History:
* 04-22-97 DBrown
\***************************************************************************/

void NextWordLpkCallBack(
    PED  ped,
    ICH  ichStart,
    BOOL fLeft,
    ICH *pichMin,
    ICH *pichMax)
{
    PSTR pText = ECLock(ped);
    HDC  hdc   = ECGetEditDC(ped, TRUE);

    ped->pLpkEditCallout->EditNextWord(ped, hdc, pText, ichStart, fLeft, pichMin, pichMax);

    ECReleaseEditDC(ped, hdc, TRUE);
    ECUnlock(ped);
}

/***************************************************************************\
* ECWordAorW
*
* if fLeft, Returns the ichMinSel and ichMaxSel of the word to the
* left of ichStart. ichMinSel contains the starting letter of the word,
* ichmaxsel contains all spaces up to the first character of the next word.
*
* if !fLeft, Returns the ichMinSel and ichMaxSel of the word to the right of
* ichStart. ichMinSel contains the starting letter of the word, ichmaxsel
* contains the first letter of the next word. If ichStart is in the middle
* of a word, that word is considered the left or right word.
*
* A CR LF pair or CRCRLF triple is considered a single word in
* multiline edit controls.
*
* History:
\***************************************************************************/

void ECWord(
    PED ped,
    ICH ichStart,
    BOOL fLeft,
    ICH  *pichMin,
    ICH  *pichMax )
{
    BOOL charLocated = FALSE;
    BOOL spaceLocated = FALSE;

    if ((!ichStart && fLeft) || (ichStart == ped->cch && !fLeft)) {

        /*
         * We are at the beginning of the text (looking left) or we are at end
         * of text (looking right), no word here
         */
        if (pichMin) *pichMin=0;
        if (pichMax) *pichMax=0;
        return;
    }

    /*
     * Don't give out hints about word breaks if password chars are being used,
     */
    if (ped->charPasswordChar) {
        if (pichMin) *pichMin=0;
        if (pichMax) *pichMax=ped->cch;
        return;
    }

    if (ped->fAnsi) {
        PSTR pText;
        PSTR pWordMinSel;
        PSTR pWordMaxSel;
        PSTR pPrevChar;

        UserAssert(ped->cbChar == sizeof(CHAR));

        if (ped->lpfnNextWord) {
            NextWordCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        if (ped->pLpkEditCallout) {
            NextWordLpkCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        pText = ECLock(ped);
        pWordMinSel = pWordMaxSel = pText + ichStart;

        /*
         * if fLeft: Move pWordMinSel to the left looking for the start of a word.
         * If we start at a space, we will include spaces in the selection as we
         * move left untill we find a nonspace character. At that point, we continue
         * looking left until we find a space. Thus, the selection will consist of
         * a word with its trailing spaces or, it will consist of any leading at the
         * beginning of a line of text.
         */

        /*
         * if !fLeft: (ie. right word) Move pWordMinSel looking for the start of a
         * word. If the pWordMinSel points to a character, then we move left
         * looking for a space which will signify the start of the word. If
         * pWordMinSel points to a space, we look right till we come upon a
         * character. pMaxWord will look right starting at pMinWord looking for the
         * end of the word and its trailing spaces.
         */

        if (fLeft || !ISDELIMETERA(*pWordMinSel) && *pWordMinSel != 0x0D) {

            /*
             * If we are moving left or if we are moving right and we are not on a
             * space or a CR (the start of a word), then we was look left for the
             * start of a word which is either a CR or a character. We do this by
             * looking left till we find a character (or if CR we stop), then we
             * continue looking left till we find a space or LF.
             */
            while (pWordMinSel > pText && ((!ISDELIMETERA(*(pWordMinSel - 1)) &&
                    *(pWordMinSel - 1) != 0x0A) || !charLocated)) {

                /*
                 * Treat double byte character as a word  ( in ansi pWordMinSel loop )
                 */
                pPrevChar = ECAnsiPrev( ped, pText, pWordMinSel );

                /*
                ** we are looking right ( !fLeft ).
                ** if current character is a double byte chararacter or
                ** previous character is a double byte character, we
                ** are on the beggining of a word.
                */
                if ( !fLeft && ( ISDELIMETERA( *pPrevChar )           ||
                                 *pPrevChar == 0x0A                   ||
                                 ECIsDBCSLeadByte(ped, *pWordMinSel)  ||
                                 pWordMinSel - pPrevChar == 2 ) ) {
                    /*
                     * If we are looking for the start of the word right, then we
                     * stop when we have found it. (needed in case charLocated is
                     * still FALSE)
                     */
                    break;
                }

                if ( pWordMinSel - pPrevChar == 2 ) {
                    /*
                    ** previous character is a double byte character.
                    ** if we are in a word ( charLocated == TRUE )
                    ** current position is the beginning of the word
                    ** if we are not in a word ( charLocated == FALSE )
                    ** the previous character is what we looking for.
                    */
                    if ( ! charLocated ) {
                        pWordMinSel = pPrevChar;
                    }
                    break;
                }
                pWordMinSel = pPrevChar;

                if (!ISDELIMETERA(*pWordMinSel) && *pWordMinSel != 0x0A) {

                    /*
                     * We have found the last char in the word. Continue looking
                     * backwards till we find the first char of the word
                     */
                    charLocated = TRUE;

                    /*
                     * We will consider a CR the start of a word
                     */
                    if (*pWordMinSel == 0x0D)
                        break;
                }
            }
        } else {
            while ((ISDELIMETERA(*pWordMinSel) || *pWordMinSel == 0x0A) && pWordMinSel < pText + ped->cch)
                pWordMinSel++;
        }

        /*
         * Adjust the initial position of pWordMaxSel ( in ansi )
         */
        pWordMaxSel = ECAnsiNext(ped, pWordMinSel);
        pWordMaxSel = min(pWordMaxSel, pText + ped->cch);

        /*
        ** If pWordMinSel points a double byte character AND
        **    pWordMaxSel points non space
        ** then
        **    pWordMaxSel points the beggining of next word.
        */
        if ( ( pWordMaxSel - pWordMinSel == 2 ) && ! ISDELIMETERA(*pWordMaxSel) )
            goto FastReturnA;
        if (*pWordMinSel == 0x0D) {
            if (pWordMinSel > pText && *(pWordMinSel - 1) == 0x0D)
                /* So that we can treat CRCRLF as one word also. */
                pWordMinSel--;
            else if (*(pWordMinSel + 1) == 0x0D)
                /* Move MaxSel on to the LF */
                pWordMaxSel++;
        }



        /*
         * Check if we have a one character word
         */
        if (ISDELIMETERA(*pWordMaxSel))
            spaceLocated = TRUE;

        /*
         * Move pWordMaxSel to the right looking for the end of a word and its
         * trailing spaces. WordMaxSel stops on the first character of the next
         * word. Thus, we break either at a CR or at the first nonspace char after
         * a run of spaces or LFs.
         */
        while ((pWordMaxSel < pText + ped->cch) && (!spaceLocated || (ISDELIMETERA(*pWordMaxSel)))) {
            if (*pWordMaxSel == 0x0D)
                break;

            /*
             * Treat double byte character as a word ( in ansi pWordMaxSel loop )
             */
            /*
            ** if it's a double byte character then
            ** we are at the beginning of next word
            ** which is a double byte character.
            */
            if (ECIsDBCSLeadByte( ped, *pWordMaxSel))
                break;

            pWordMaxSel++;

            if (ISDELIMETERA(*pWordMaxSel))
                spaceLocated = TRUE;

            if (*(pWordMaxSel - 1) == 0x0A)
                break;
        }

        /*
         * label for fast return ( for Ansi )
         */
FastReturnA:
        ECUnlock(ped);

        if (pichMin)   *pichMin = (ICH)(pWordMinSel - pText);
        if (pichMax)   *pichMax = (ICH)(pWordMaxSel - pText);
        return;

    } else {  // !fAnsi
        LPWSTR pwText;
        LPWSTR pwWordMinSel;
        LPWSTR pwWordMaxSel;
        BOOL charLocated = FALSE;
        BOOL spaceLocated = FALSE;
        PWSTR pwPrevChar;

        UserAssert(ped->cbChar == sizeof(WCHAR));

        if (ped->lpfnNextWord) {
            NextWordCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        if (ped->pLpkEditCallout) {
            NextWordLpkCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        pwText = (LPWSTR)ECLock(ped);
        pwWordMinSel = pwWordMaxSel = pwText + ichStart;

        /*
         * if fLeft: Move pWordMinSel to the left looking for the start of a word.
         * If we start at a space, we will include spaces in the selection as we
         * move left untill we find a nonspace character. At that point, we continue
         * looking left until we find a space. Thus, the selection will consist of
         * a word with its trailing spaces or, it will consist of any leading at the
         * beginning of a line of text.
         */

        /*
         * if !fLeft: (ie. right word) Move pWordMinSel looking for the start of a
         * word. If the pWordMinSel points to a character, then we move left
         * looking for a space which will signify the start of the word. If
         * pWordMinSel points to a space, we look right till we come upon a
         * character. pMaxWord will look right starting at pMinWord looking for the
         * end of the word and its trailing spaces.
         */


        if (fLeft || (!ISDELIMETERW(*pwWordMinSel) && *pwWordMinSel != 0x0D))
         /* If we are moving left or if we are moving right and we are not on a
          * space or a CR (the start of a word), then we was look left for the
          * start of a word which is either a CR or a character. We do this by
          * looking left till we find a character (or if CR we stop), then we
          * continue looking left till we find a space or LF.
          */ {
            while (pwWordMinSel > pwText && ((!ISDELIMETERW(*(pwWordMinSel - 1)) && *(pwWordMinSel - 1) != 0x0A) || !charLocated)) {
                /*
                 * Treat double byte character as a word  ( in unicode pwWordMinSel loop )
                 */
                pwPrevChar = pwWordMinSel - 1;
                /*
                ** we are looking right ( !fLeft ).
                **
                ** if current character is a double width chararacter
                ** or previous character is a double width character,
                ** we are on the beggining of a word.
                */
                if (!fLeft && (ISDELIMETERW( *pwPrevChar)  ||
                               *pwPrevChar == 0x0A         ||
                               UserIsFullWidth(CP_ACP,*pwWordMinSel) ||
                               UserIsFullWidth(CP_ACP,*pwPrevChar)))    {
                    /*
                     * If we are looking for the start of the word right, then we
                     * stop when we have found it. (needed in case charLocated is
                     * still FALSE)
                     */
                    break;
                }

                if (UserIsFullWidth(CP_ACP,*pwPrevChar)) {
                    /*
                    ** Previous character is a double width character.
                    **
                    ** if we are in a word ( charLocated == TRUE )
                    ** current position is the beginning of the word
                    ** if we are not in a word ( charLocated == FALSE )
                    ** the previous character is what we looking for.
                    */
                    if ( ! charLocated ) {
                        pwWordMinSel = pwPrevChar;
                    }
                    break;
                }
                pwWordMinSel = pwPrevChar;

                if (!ISDELIMETERW(*pwWordMinSel) && *pwWordMinSel != 0x0A)
                 /*
                  * We have found the last char in the word. Continue looking
                  * backwards till we find the first char of the word
                  */ {
                    charLocated = TRUE;

                    /*
                     * We will consider a CR the start of a word
                     */
                    if (*pwWordMinSel == 0x0D)
                        break;
                }
            }
        } else {

            /*
             * We are moving right and we are in between words so we need to move
             * right till we find the start of a word (either a CR or a character.
             */
            while ((ISDELIMETERW(*pwWordMinSel) || *pwWordMinSel == 0x0A) && pwWordMinSel < pwText + ped->cch)
                pwWordMinSel++;
        }

        pwWordMaxSel = min((pwWordMinSel + 1), (pwText + ped->cch));

        /*
        ** If pwWordMinSel points a double width character AND
        **    pwWordMaxSel points non space
        ** then
        **    pwWordMaxSel points the beggining of next word.
        */
        if (UserIsFullWidth(CP_ACP,*pwWordMinSel) && ! ISDELIMETERW(*pwWordMaxSel))
            goto FastReturnW;
        if (*pwWordMinSel == 0x0D) {
            if (pwWordMinSel > pwText && *(pwWordMinSel - 1) == 0x0D)
                /* So that we can treat CRCRLF as one word also. */
                pwWordMinSel--;
            else if (*(pwWordMinSel + 1) == 0x0D)
                /* Move MaxSel on to the LF */
                pwWordMaxSel++;
        }



        /*
         * Check if we have a one character word
         */
        if (ISDELIMETERW(*pwWordMaxSel))
            spaceLocated = TRUE;

        /*
         * Move pwWordMaxSel to the right looking for the end of a word and its
         * trailing spaces. WordMaxSel stops on the first character of the next
         * word. Thus, we break either at a CR or at the first nonspace char after
         * a run of spaces or LFs.
         */
        while ((pwWordMaxSel < pwText + ped->cch) && (!spaceLocated || (ISDELIMETERW(*pwWordMaxSel)))) {
            if (*pwWordMaxSel == 0x0D)
                break;

            /*
             * treat double byte character as a word ( in unicode pwWordMaxSel loop )
             */
            /*
            ** if it's a double width character
            ** then we are at the beginning of
            ** the next word which is a double
            ** width character.
            */
            if (UserIsFullWidth(CP_ACP,*pwWordMaxSel))
                break;

            pwWordMaxSel++;

            if (ISDELIMETERW(*pwWordMaxSel))
                spaceLocated = TRUE;


            if (*(pwWordMaxSel - 1) == 0x0A)
                break;
        }

        /*
         * label for fast return ( for Unicode )
         */
FastReturnW:
        ECUnlock(ped);

        if (pichMin)   *pichMin = (ICH)(pwWordMinSel - pwText);
        if (pichMax)   *pichMax = (ICH)(pwWordMaxSel - pwText);
        return;
    }
}

/***************************************************************************\
*
*  ECSaveUndo() -
*
*  Saves old undo information into given buffer, and clears out info in
*  passed in undo buffer.  If we're restoring, pundoFrom and pundoTo are
*  reversed.
*
\***************************************************************************/
void ECSaveUndo(PUNDO pundoFrom, PUNDO pundoTo, BOOL fClear)
{
    /*
     *  Save undo data
     */
    RtlCopyMemory(pundoTo, pundoFrom, sizeof(UNDO));

    /*
     *  Clear passed in undo buffer
     */
    if (fClear)
        RtlZeroMemory(pundoFrom, sizeof(UNDO) );
}

/***************************************************************************\
* ECEmptyUndo AorW
*
* empties the undo buffer.
*
* History:
\***************************************************************************/

void ECEmptyUndo(
    PUNDO pundo )
{
    if (pundo->hDeletedText)
        UserGlobalFree(pundo->hDeletedText);

    RtlZeroMemory(pundo, sizeof(UNDO) );
}

/***************************************************************************\
*
*  ECMergeUndoInsertInfo() -
*
*  When an insert takes place, this function is called with the info about
*  the new insertion (the insertion point and the count of chars inserted);
*  This looks at the existing Undo info and merges the new new insert info
*  with it.
*
\***************************************************************************/
void   ECMergeUndoInsertInfo(PUNDO pundo, ICH ichInsert, ICH cchInsert) \
{
    //
    // If undo buffer is empty, just insert the new info as UNDO_INSERT
    //
    if (pundo->undoType == UNDO_NONE) {
        pundo->undoType    = UNDO_INSERT;
        pundo->ichInsStart = ichInsert;
        pundo->ichInsEnd   = ichInsert+cchInsert;
    } else if (pundo->undoType & UNDO_INSERT) {
        //
        // If there's already some undo insert info,
        // try to merge the two.
        //
        if (pundo->ichInsEnd == ichInsert) // Check they are adjacent.
            pundo->ichInsEnd += cchInsert; // if so, just concatenate.
        else {
                // The new insert is not contiguous with the old one.
UNDOINSERT:
            //
            // If there is some UNDO_DELETE info already here, check to see
            // if the new insert takes place at a point different from where
            // that deletion occurred.
            //
            if ((pundo->undoType & UNDO_DELETE) && (pundo->ichDeleted != ichInsert)) {
                //
                // User is inserting into a different point; So, let us
                // forget any UNDO_DELETE info;
                //
                if (pundo->hDeletedText)
                    UserGlobalFree(pundo->hDeletedText);

                pundo->hDeletedText = NULL;
                pundo->ichDeleted = 0xFFFFFFFF;
                pundo->undoType &= ~UNDO_DELETE;
            }

            // Since the old insert and new insert are not adjacent, let us
            // forget everything about the old insert and keep just the new
            // insert info as the UNDO_INSERT.
            pundo->ichInsStart = ichInsert;
            pundo->ichInsEnd   = ichInsert + cchInsert;
            pundo->undoType |= UNDO_INSERT;
        }
    } else if (pundo->undoType == UNDO_DELETE) {
        // If there is some Delete Info already present go and handle it.
        goto UNDOINSERT;
    }
}


/***************************************************************************\
* ECInsertText AorW
*
* Adds cch characters from lpText into the ped->hText starting at
* ped->ichCaret. Returns TRUE if successful else FALSE. Updates
* ped->cchAlloc and ped->cch properly if additional memory was allocated or
* if characters were actually added. Updates ped->ichCaret to be at the end
* of the inserted text. min and maxsel are equal to ichcaret.
*
* History:
\***************************************************************************/

BOOL ECInsertText(
    PED ped,
    LPSTR lpText,
    ICH* pcchInsert)
{
    PSTR pedText;
    PSTR pTextBuff;
    LONG style;
    HANDLE hTextCopy;
    DWORD allocamt;

    //
    // If the last byte (lpText[cchInsert - 1]) is a DBCS leading byte
    // we need to adjust it.
    //
    *pcchInsert = ECAdjustIch(ped, lpText, *pcchInsert);

    if (!*pcchInsert)
        return TRUE;

    /*
     * Do we already have enough memory??
     */
    if (*pcchInsert >= (ped->cchAlloc - ped->cch)) {

        /*
         * Allocate what we need plus a little extra. Return FALSE if we are
         * unsuccessful.
         */
        allocamt = (ped->cch + *pcchInsert) * ped->cbChar;
        allocamt += CCHALLOCEXTRA;

// if (!ped->fSingle) {
              hTextCopy = LOCALREALLOC(ped->hText, allocamt, LHND, ped->hInstance, &lpText);
              if (hTextCopy) {
                  ped->hText = hTextCopy;
              } else {
                  return FALSE;
              }
// } else {
// if (!LocalReallocSafe(ped->hText, allocamt, LHND, pped))
//                return FALSE;
// }

        ped->cchAlloc = LOCALSIZE(ped->hText, ped->hInstance) / ped->cbChar;
    }


    /*
     * Ok, we got the memory. Now copy the text into the structure
     */
    pedText = ECLock(ped);

    if (ped->pLpkEditCallout) {
        HDC     hdc;
        INT     iResult;

        hdc = ECGetEditDC (ped, TRUE);
        iResult = ped->pLpkEditCallout->EditVerifyText (ped, hdc, pedText, ped->ichCaret, lpText, *pcchInsert);
        ECReleaseEditDC (ped, hdc, TRUE);

        if (iResult == 0) {
            ECUnlock (ped);
            return TRUE;
        }
    }

    /*
     * Get a pointer to the place where text is to be inserted
     */
    pTextBuff = pedText + ped->ichCaret * ped->cbChar;

    if (ped->ichCaret != ped->cch) {

        /*
         * We are inserting text into the middle. We have to shift text to the
         * right before inserting new text.
         */
         memmove(pTextBuff + *pcchInsert * ped->cbChar, pTextBuff, (ped->cch-ped->ichCaret) * ped->cbChar);
    }

    /*
     * Make a copy of the text being inserted in the edit buffer.
     * Use this copy for doing UPPERCASE/LOWERCASE ANSI/OEM conversions
     * Fix for Bug #3406 -- 01/29/91 -- SANKAR --
     */
    memmove(pTextBuff, lpText, *pcchInsert * ped->cbChar);
    ped->cch += *pcchInsert;

    /*
     * Get the control's style
     */
    style = ped->pwnd->style;

    /*
     * Do the Upper/Lower conversion
     */
    if (style & ES_LOWERCASE) {
        if (ped->fAnsi)
            CharLowerBuffA((LPSTR)pTextBuff, *pcchInsert);
        else
            CharLowerBuffW((LPWSTR)pTextBuff, *pcchInsert);
    } else {
        if (style & ES_UPPERCASE) {
            if (ped->fAnsi) {
                CharUpperBuffA(pTextBuff, *pcchInsert);
            } else {
                CharUpperBuffW((LPWSTR)pTextBuff, *pcchInsert);
            }
        }
    }

    /*
     * Do the OEM conversion
     */
    if ((style & ES_OEMCONVERT) &&
            // For backward compatibility with NT4, we don't perform OEM conversion
            // for older apps if the system locale is FarEast.
            //
            (!IS_DBCS_ENABLED() || GETAPPVER() >= VER50 || GetOEMCP() != GetACP())) {

        ICH i;

        if (ped->fAnsi) {
            for (i = 0; i < *pcchInsert; i++) {
                //
                // We don't need to call CharToOemBuff etc. if the character
                // is a double byte character.  And, calling ECIsDBCSLeadByte is
                // faster and less complicated because we don't have to deal
                // with the 2 byte dbcs cases.
                //
                if (IS_DBCS_ENABLED() && ECIsDBCSLeadByte(ped, *(lpText+i))) {
                    i++;
                    continue;
                }

                //
                // Windows Bug (Whistler) 35289
                // greek has funny rules for casing, so we need to check for it.
                // for nashville we should be doing something more appropriate
                // but for now, leave as Win95 golden
                //
                if (ped->charSet != GREEK_CHARSET && IsCharLowerA(*(pTextBuff + i))) {
                    CharUpperBuffA(pTextBuff + i, 1);
                    CharToOemBuffA(pTextBuff + i, pTextBuff + i, 1);
                    OemToCharBuffA(pTextBuff + i, pTextBuff + i, 1);
                    CharLowerBuffA(pTextBuff + i, 1);
                } else {
                    CharToOemBuffA(pTextBuff + i, pTextBuff + i, 1);
                    OemToCharBuffA(pTextBuff + i, pTextBuff + i, 1);
                }
            }
        } else {
            //
            // Because 'ch' may become DBCS, and have a space for NULL.
            //
            UCHAR ch[4];
            LPWSTR lpTextW = (LPWSTR)pTextBuff;

            for (i = 0; i < *pcchInsert; i++) {
                if (*(lpTextW + i) == UNICODE_CARRIAGERETURN ||
                    *(lpTextW + i) == UNICODE_LINEFEED ||
                    *(lpTextW + i) == UNICODE_TAB) {
                    continue;
                }
                //
                // Windows Bug (Whistler) 35289
                // greek has funny rules for casing, so we need to check for it.
                // for nashville we should be doing something more appropriate
                // but for now, leave as Win95 golden
                //
                if (ped->charSet != GREEK_CHARSET && IsCharLowerW(*(lpTextW + i))) {
                    CharUpperBuffW(lpTextW + i, 1);
                    *(LPDWORD)ch = 0; // make sure the null-terminate.
                    CharToOemBuffW(lpTextW + i, ch, 1);
                    //
                    // We assume any SBCS/DBCS character will converted
                    // to 1 Unicode char, Otherwise, we may overwrite
                    // next character...
                    //
                    OemToCharBuffW(ch, lpTextW + i, strlen(ch));
                    CharLowerBuffW(lpTextW + i, 1);
                } else {
                    *(LPDWORD)ch = 0; // make sure the null-terminate.
                    CharToOemBuffW(lpTextW + i, ch, 1);
                    //
                    // We assume any SBCS/DBCS character will converted
                    // to 1 Unicode char, Otherwise, we may overwrite
                    // next character...
                    //
                    OemToCharBuffW(ch, lpTextW + i, strlen(ch));
                }
            }
        }
    }

    /* Adjust UNDO fields so that we can undo this insert... */
    ECMergeUndoInsertInfo(Pundo(ped), ped->ichCaret, *pcchInsert);

    ped->ichCaret += *pcchInsert;

    if (ped->pLpkEditCallout) {
        HDC     hdc;

        hdc = ECGetEditDC (ped, TRUE);
        ped->ichCaret = ped->pLpkEditCallout->EditAdjustCaret (ped, hdc, pedText, ped->ichCaret);
        ECReleaseEditDC (ped, hdc, TRUE);
    }

    ped->ichMinSel = ped->ichMaxSel = ped->ichCaret;

    ECUnlock(ped);

    /*
     * Set dirty bit
     */
    ped->fDirty = TRUE;

    return TRUE;
}

/***************************************************************************\
* ECDeleteText AorW
*
* Deletes the text between ped->ichMinSel and ped->ichMaxSel. The
* character at ichMaxSel is not deleted. But the character at ichMinSel is
* deleted. ped->cch is updated properly and memory is deallocated if enough
* text is removed. ped->ichMinSel, ped->ichMaxSel, and ped->ichCaret are set
* to point to the original ped->ichMinSel. Returns the number of characters
* deleted.
*
* History:
\***************************************************************************/

ICH ECDeleteText(
    PED ped)
{
    PSTR pedText;
    ICH cchDelete;
    LPSTR lpDeleteSaveBuffer;
    HANDLE hDeletedText;
    DWORD bufferOffset;

    cchDelete = ped->ichMaxSel - ped->ichMinSel;

    if (!cchDelete)
        return (0);

    /*
     * Ok, now lets delete the text.
     */
    pedText = ECLock(ped);

    /*
     * Adjust UNDO fields so that we can undo this delete...
     */
    if (ped->undoType == UNDO_NONE) {
UNDODELETEFROMSCRATCH:
        if (ped->hDeletedText = UserGlobalAlloc(GPTR, (LONG)((cchDelete+1)*ped->cbChar))) {
            ped->undoType = UNDO_DELETE;
            ped->ichDeleted = ped->ichMinSel;
            ped->cchDeleted = cchDelete;
            lpDeleteSaveBuffer = ped->hDeletedText;
            RtlCopyMemory(lpDeleteSaveBuffer, pedText + ped->ichMinSel*ped->cbChar, cchDelete*ped->cbChar);
            lpDeleteSaveBuffer[cchDelete*ped->cbChar] = 0;
        }
    } else if (ped->undoType & UNDO_INSERT) {
UNDODELETE:
        ECEmptyUndo(Pundo(ped));

        ped->ichInsStart = ped->ichInsEnd = 0xFFFFFFFF;
        ped->ichDeleted = 0xFFFFFFFF;
        ped->cchDeleted = 0;
        goto UNDODELETEFROMSCRATCH;
    } else if (ped->undoType == UNDO_DELETE) {
        if (ped->ichDeleted == ped->ichMaxSel) {

            /*
             * Copy deleted text to front of undo buffer
             */
            hDeletedText = UserGlobalReAlloc(ped->hDeletedText, (LONG)(cchDelete + ped->cchDeleted + 1)*ped->cbChar, GHND);
            if (!hDeletedText)
                goto UNDODELETE;
            bufferOffset = 0;
            ped->ichDeleted = ped->ichMinSel;
        } else if (ped->ichDeleted == ped->ichMinSel) {

            /*
             * Copy deleted text to end of undo buffer
             */
            hDeletedText = UserGlobalReAlloc(ped->hDeletedText, (LONG)(cchDelete + ped->cchDeleted + 1)*ped->cbChar, GHND);
            if (!hDeletedText)
                goto UNDODELETE;
            bufferOffset = ped->cchDeleted*ped->cbChar;
        } else {

            /*
             * Clear the current UNDO delete and add the new one since
               the deletes aren't contiguous.
             */
            goto UNDODELETE;
        }

        ped->hDeletedText = hDeletedText;
        lpDeleteSaveBuffer = (LPSTR)hDeletedText;
        if (!bufferOffset) {

            /*
             * Move text in delete buffer up so that we can insert the next
             * text at the head of the buffer.
             */
            RtlMoveMemory(lpDeleteSaveBuffer + cchDelete*ped->cbChar, lpDeleteSaveBuffer,
                    ped->cchDeleted*ped->cbChar);
        }
        RtlCopyMemory(lpDeleteSaveBuffer + bufferOffset, pedText + ped->ichMinSel*ped->cbChar,
                cchDelete*ped->cbChar);

        lpDeleteSaveBuffer[(ped->cchDeleted + cchDelete)*ped->cbChar] = 0;
        ped->cchDeleted += cchDelete;
    }

    if (ped->ichMaxSel != ped->cch) {

        /*
         * We are deleting text from the middle of the buffer so we have to
           shift text to the left.
         */
        RtlMoveMemory(pedText + ped->ichMinSel*ped->cbChar, pedText + ped->ichMaxSel*ped->cbChar,
                (ped->cch - ped->ichMaxSel)*ped->cbChar);
    }

    if (ped->cchAlloc - ped->cch > CCHALLOCEXTRA) {

        /*
         * Free some memory since we deleted a lot
         */
        LOCALREALLOC(ped->hText, (DWORD)(ped->cch + (CCHALLOCEXTRA / 2))*ped->cbChar, LHND, ped->hInstance, NULL);
        ped->cchAlloc = LOCALSIZE(ped->hText, ped->hInstance) / ped->cbChar;
    }

    ped->cch -= cchDelete;

    if (ped->pLpkEditCallout) {
        HDC     hdc;

        hdc = ECGetEditDC (ped, TRUE);
        ped->ichMinSel = ped->pLpkEditCallout->EditAdjustCaret (ped, hdc, pedText, ped->ichMinSel);
        ECReleaseEditDC (ped, hdc, TRUE);
    }

    ped->ichCaret = ped->ichMaxSel = ped->ichMinSel;

    ECUnlock(ped);

    /*
     * Set dirty bit
     */
    ped->fDirty = TRUE;

    return (cchDelete);
}

/***************************************************************************\
* ECNotifyParent AorW
*
* Sends the notification code to the parent of the edit control
*
* History:
\***************************************************************************/

void ECNotifyParent(
    PED ped,
    int notificationCode)
{
    /*
     * wParam is NotificationCode (hiword) and WindowID (loword)
     * lParam is HWND of control sending the message
     * Windows 95 checks for hwndParent != NULL before sending the message, but
     * this is surely rare, and SendMessage NULL hwnd does nowt anyway (IanJa)
     */
    SendMessage(ped->hwndParent, WM_COMMAND,
            (DWORD)MAKELONG(PTR_TO_ID(ped->pwnd->spmenu), notificationCode),
            (LPARAM)ped->hwnd);
}

/***************************************************************************\
*
*  ECSetEditClip() AorW
*
*  Sets the clip rect for the hdc to the formatting rectangle intersected
*  with the client area.
*
\***************************************************************************/
void   ECSetEditClip(PED ped, HDC hdc, BOOL fLeftMargin)
{
    RECT rcClient;
    RECT rcClip;

    CopyRect(&rcClip, &ped->rcFmt);

    if (ped->pLpkEditCallout) {
        // Complex script handling chooses whether to write margins later
        rcClip.left  -= ped->wLeftMargin;
        rcClip.right += ped->wRightMargin;
    } else {
        if (fLeftMargin)  /* Should we consider the left margin?   */
            rcClip.left  -= ped->wLeftMargin;
        if (ped->fWrap)        /* Should we consider the right margin? */
            rcClip.right += ped->wRightMargin;
    }

    /* Set clip rectangle to rectClient intersect rectClip */
    /* We must clip for single line edits also. -- B#1360 */
    _GetClientRect(ped->pwnd, &rcClient);
    if (ped->fFlatBorder)
        InflateRect(&rcClient, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

    IntersectRect(&rcClient, &rcClient, &rcClip);
    IntersectClipRect(hdc,rcClient.left, rcClient.top,
            rcClient.right, rcClient.bottom);
}

/***************************************************************************\
* ECGetEditDC AorW
*
* Hides the caret, gets the DC for the edit control, and clips to
* the rcFmt rectangle specified for the edit control and sets the proper
* font. If fFastDC, just select the proper font but don't bother about clip
* regions or hiding the caret.
*
* History:
\***************************************************************************/

HDC ECGetEditDC(
    PED ped,
    BOOL fFastDC )
{
    HDC hdc;

    if (!fFastDC)
        NtUserHideCaret(ped->hwnd);

    if ( hdc = NtUserGetDC(ped->hwnd) ) {
        ECSetEditClip(ped, hdc, (BOOL)(ped->xOffset == 0));

        /*
         * Select the proper font for this edit control's dc.
         */
        if (ped->hFont)
            SelectObject(hdc, ped->hFont);
    }

    return hdc;
}

/***************************************************************************\
* ECReleaseEditDC AorW
*
* Releases the DC (hdc) for the edit control and shows the caret.
* If fFastDC, just select the proper font but don't bother about showing the
* caret.
*
* History:
\***************************************************************************/

void ECReleaseEditDC(
    PED ped,
    HDC hdc,
    BOOL fFastDC)
{
    /*
     * Restoring font not necessary
     */

    ReleaseDC(ped->hwnd, hdc);

    if (!fFastDC)
        NtUserShowCaret(ped->hwnd);
}

/***************************************************************************\
*
*  ECResetTextInfo() AorW
*
*  Handles a global change to the text by resetting text offsets, emptying
*  the undo buffer, and rebuilding the lines
*
\***************************************************************************/
void   ECResetTextInfo(PED ped)
{
    //
    // Reset caret, selections, scrolling, and dirty information.
    //
    ped->iCaretLine = ped->ichCaret = 0;
    ped->ichMinSel = ped->ichMaxSel = 0;
    ped->xOffset = ped->ichScreenStart = 0;
    ped->fDirty = FALSE;

    ECEmptyUndo(Pundo(ped));

    if (ped->fSingle) {
        if (!ped->listboxHwnd)
            ECNotifyParent(ped, EN_UPDATE);
    } else {
#ifdef BOGUS
        // B#14640
        // We don't want to strip soft breaks or anything else from text
        // that was passed in by the caller. - karlst.
        MLStripCrCrLf(ped);
#endif
        MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);
    }

    if (_IsWindowVisible(ped->pwnd)) {
        BOOL fErase;

        if (ped->fSingle)
            fErase = FALSE;
        else
            fErase = ((ped->ichLinesOnScreen + ped->ichScreenStart) >= ped->cLines);

        // Always redraw whether or not the insert was successful.  We might
        // have NULL text.  Paint() will check the redraw flag for us.
        ECInvalidateClient(ped, fErase);

        // BACKWARD COMPAT HACK: RAID expects the text to have been updated,
        // so we have to do an UpdateWindow here.  It moves an edit control
        // around with fRedraw == FALSE, so it'll never get the paint message
        // with the control in the right place.
        if (!ped->fWin31Compat)
            UpdateWindow(ped->hwnd);
    }

    if (ped->fSingle && !ped->listboxHwnd) {
        ECNotifyParent(ped, EN_CHANGE);
    }

    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, HW(ped->pwnd), OBJID_CLIENT, INDEXID_CONTAINER);
}

/***************************************************************************\
* ECSetText AorW
*
* Copies the null terminated text in lpstr to the ped. Notifies the
* parent if there isn't enough memory. Sets the minsel, maxsel, and caret to
* the beginning of the inserted text. Returns TRUE if successful else FALSE
* if no memory (and notifies the parent).
*
* History:
\***************************************************************************/

BOOL ECSetText(
    PED ped,
    LPSTR lpstr)
{
    ICH cchLength;
    ICH cchSave = ped->cch;
    ICH ichCaretSave = ped->ichCaret;
    HWND hwndSave    = ped->hwnd;
    HANDLE hText;

    ped->cch = ped->ichCaret = 0;

    ped->cchAlloc = LOCALSIZE(ped->hText, ped->hInstance) / ped->cbChar;
    if (!lpstr) {
        hText = LOCALREALLOC(ped->hText, CCHALLOCEXTRA*ped->cbChar, LHND, ped->hInstance, &lpstr);
        if (hText != NULL) {
            ped->hText = hText;
        } else {
            return FALSE;
        }
    } else {
        cchLength = StringLength(lpstr, ped->fAnsi);

#ifdef NEVER
// win3.1 does limit single line edit controls to 32K (minus 3) but NT doesn't

        if (ped->fSingle) {
            /*
             * Limit single line edit controls to 32K
             */
            cchLength = min(cchLength, (ICH)(0x7FFD/ped->cbChar));
        }
#endif

        /*
         * Add the text
         */
        if (cchLength && !ECInsertText(ped, lpstr, &cchLength)) {

            /*
             * Restore original state and notify parent we ran out of memory.
             */
            ped->cch = cchSave;
            ped->ichCaret = ichCaretSave;
            ECNotifyParent(ped, EN_ERRSPACE);
            return FALSE;
        }
    }

    ped->cchAlloc = LOCALSIZE(ped->hText, ped->hInstance) / ped->cbChar;

    if (IsWindow(hwndSave))
        ECResetTextInfo(ped);

    return TRUE;
}

/***************************************************************************\
*
* ECInvalidateClient()
*
* Invalidates client of edit field.  For old 3.x guys with borders,
* we draw it ourself (compatibility).  So we don't want to invalidate
* the border or we'll get flicker.
*
\***************************************************************************/

void ECInvalidateClient(PED ped, BOOL fErase)
{
    if (ped->fFlatBorder) {
        RECT    rcT;

        _GetClientRect(ped->pwnd, &rcT);
        InflateRect(&rcT, -SYSMET(CXBORDER),
            -SYSMET(CYBORDER));
        NtUserInvalidateRect(ped->hwnd, &rcT, fErase);
    } else {
        NtUserInvalidateRect(ped->hwnd, NULL, fErase);
    }
}


/***************************************************************************\
* ECCopy AorW
*
* Copies the text between ichMinSel and ichMaxSel to the clipboard.
* Returns the number of characters copied.
*
* History:
\***************************************************************************/

ICH ECCopy(
    PED ped)
{
    HANDLE hData;
    char *pchSel;
    char FAR *lpchClip;
    ICH cbData;

    /*
     * Don't allow copies from password style controls
     */
    if (ped->charPasswordChar) {
        NtUserMessageBeep(0);
        return 0;
    }

    cbData = (ped->ichMaxSel - ped->ichMinSel) * ped->cbChar;

    if (!cbData)
        return 0;

    if (!OpenClipboard(ped->hwnd))
        return 0;

    NtUserEmptyClipboard();

    /*
     * If we just called EmptyClipboard in the context of a 16 bit
     * app then we also have to tell WOW to nix its 16 handle copy of
     * clipboard data.  WOW does its own clipboard caching because
     * some 16 bit apps use clipboard data even after the clipboard
     * has been emptied.  See the note in the server code.
     *
     * Note: this is the only place where EmptyClipboard is called
     * for a 16 bit app not going through WOW.  If we added others
     * we might want to move this into EmptyClipboard and have two
     * versions.
     */
    if (GetClientInfo()->CI_flags & CI_16BIT) {
        pfnWowEmptyClipBoard();
    }


    /*
     * +1 for the terminating NULL
     */
    if (!(hData = UserGlobalAlloc(LHND, (LONG)(cbData + ped->cbChar)))) {
        NtUserCloseClipboard();
        return (0);
    }

    USERGLOBALLOCK(hData, lpchClip);
    UserAssert(lpchClip);
    pchSel = ECLock(ped);
    pchSel = pchSel + (ped->ichMinSel * ped->cbChar);

    RtlCopyMemory(lpchClip, pchSel, cbData);

    if (ped->fAnsi)
        *(lpchClip + cbData) = 0;
    else
        *(LPWSTR)(lpchClip + cbData) = (WCHAR)0;

    ECUnlock(ped);
    USERGLOBALUNLOCK(hData);

    SetClipboardData( ped->fAnsi ? CF_TEXT : CF_UNICODETEXT, hData);

    NtUserCloseClipboard();

    return (cbData);
}



/***************************************************************************\
* EditWndProcA
*
* Always receives Ansi messages and translates them if appropriate to unicode
* depending on the PED type
*
*
\***************************************************************************/

LRESULT EditWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_EDIT))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, TRUE);

    return EditWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT EditWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_EDIT)) {
        return DefWindowProcWorker(pwnd, message, wParam, lParam, FALSE);
    }

    return EditWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}


LRESULT EditWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    PED ped;
    HWND hwnd = HWq(pwnd);
    static BOOL fInit = TRUE;

    VALIDATECLASSANDSIZE(pwnd, FNID_EDIT);
    INITCONTROLLOOKASIDE(&EditLookaside, ED, pwnd, 4);

    /*
     * Get the ped for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,hped) when
     * we initially created the edit control.
     */
    ped = ((PEDITWND)pwnd)->ped;

    /*
     * Make sure the ANSI flag is set correctly.
     */
    if (!ped->fInitialized) {
        ped->fInitialized = TRUE;
        ped->fAnsi = TestWF(pwnd, WFANSICREATOR) ? TRUE : FALSE;
    }

    /*
     * We just call the regular EditWndProc if the ped is not created, the
     * incoming message type already matches the PED type or the message
     * does not need any translation.
     */
    if (ped->fAnsi == fAnsi ||
            (message >= WM_USER) ||
            !MessageTable[message].bThunkMessage) {
        return EditWndProc(pwnd, message, wParam, lParam);
    }

    return CsSendMessage(hwnd, message, wParam, lParam,
                         fAnsi ? (ULONG_PTR)EditWndProcW : (ULONG_PTR)EditWndProcA,
                         FNID_CALLWINDOWPROC, fAnsi);
}

/***************************************************************************\
* EditWndProc
*
* Class procedure for all edit controls.
* Dispatches all messages to the appropriate handlers which are named
* as follows:
* SL (single line) prefixes all single line edit control procedures while
* ML (multi line) prefixes all multi- line edit controls.
* EC (edit control) prefixes all common handlers.
*
* The EditWndProc only handles messages common to both single and multi
* line edit controls. Messages which are handled differently between
* single and multi are sent to SLEditWndProc or MLEditWndProc.
*
* Top level procedures are EditWndPoc, SLEditWndProc, and MLEditWndProc.
* SL*Handler or ML*Handler or EC*Handler procs are called to handle
* the various messages. Support procedures are prefixed with SL ML or
* EC depending on which code they support. They are never called
* directly and most assumptions/effects are documented in the effects
* clause.
*
* WARNING: If you add a message here, add it to gawEditWndProc[] in
* kernel\server.c too, otherwise EditWndProcA/W will send it straight to
* DefWindowProcWorker
*
* History:
\***************************************************************************/

LRESULT EditWndProc(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwnd = HWq(pwnd);
    LRESULT lreturn;
    PED  ped;

    /*
     * Get the ped for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,hped) when
     * we initially created the edit control.
     */
    ped = ((PEDITWND)pwnd)->ped;

    /*
     * Dispatch the various messages we can receive
     */
    lreturn = 1L;
    switch (message) {

    /*
     * Messages which are handled the same way for both single and multi line
     * edit controls.
     */
    case WM_KEYDOWN:
         // LPK handling of Ctrl/LShift, Ctrl/RShift
         if (ped && ped->pLpkEditCallout && ped->fAllowRTL) {

             ped->fSwapRoOnUp = FALSE; // Any keydown cancels a ctrl/shift reading order change

             switch (wParam) {
                 case VK_SHIFT:
                     if ((GetKeyState(VK_CONTROL) & 0x8000) && !(GetKeyState(VK_MENU) & 0x8000)) {
                         // Left shift or right shift pressed while control held down
                         // Check that alt (VK_MENU) isn't down to avoid false firing on AltGr which equals Ctrl+Alt.
                         if (MapVirtualKey((LONG)lParam>>16&0xff, 3) == VK_LSHIFT) {
                             // User wants left to right reading order
                             ped->fSwapRoOnUp = (ped->fRtoLReading)  || (ped->format & ES_RIGHT) ;
                             ped->fLShift = TRUE;
                         } else {
                             // User wants right to left reading order
                             ped->fSwapRoOnUp = (!ped->fRtoLReading) || (ped->format & ES_RIGHT);
                             ped->fLShift = FALSE;
                         }
                     }
                     break;

                 case VK_LEFT:
                     if (ped->fRtoLReading) {
                        wParam = VK_RIGHT;
                     }
                     break;

                 case VK_RIGHT:
                     if (ped->fRtoLReading) {
                         wParam = VK_LEFT;
                     }
                     break;
             }
         }
         goto HandleEditMsg;

    case WM_KEYUP:
        if (ped && ped->pLpkEditCallout && ped->fAllowRTL && ped->fSwapRoOnUp) {

            BOOL fReadingOrder;
            // Complete reading order change detected earlier during keydown

            ped->fSwapRoOnUp = FALSE;
            fReadingOrder = ped->fRtoLReading;

            // Remove any overriding ES_CENTRE or ES_RIGHT format from dwStyle
            SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE) & ~ES_FMTMASK);

            if (ped->fLShift) {
                // Set Left to Right reading order and right scrollbar in EX_STYLE
                SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE)
                              & ~(WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR));

                // Edit control is LTR now, then notify the parent.
                ECNotifyParent(ped, EN_ALIGN_LTR_EC);
                // ? Select a keyboard layout appropriate to LTR operation
            } else {
                // Set Right to Left reading order, right alignment and left scrollbar
                SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE)
                              | WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR);

                // Edit control is RTL now, then notify the parent.
                ECNotifyParent(ped, EN_ALIGN_RTL_EC);
                // ? Select a keyboard layout appropriate to RTL operation
            }

            // If reading order didn't change, so we are sure the alignment changed and the edit window didn't invalidate yet.
            if (fReadingOrder == (BOOL) ped->fRtoLReading) {
              ECInvalidateClient(ped, TRUE);
            }
        }
        goto HandleEditMsg;

    case WM_INPUTLANGCHANGE:
        if (ped) {
            // EC_INSERT_COMPOSITION_CHAR : WM_INPUTLANGCHANGE - call ECInitInsert()
            HKL hkl = THREAD_HKL();

            ECInitInsert(ped, hkl);

            if (ped->fInReconversion) {
                ECInOutReconversionMode(ped, FALSE);
            }

            //
            // Font and caret position might be changed while
            // another keyboard layout is active. Set those
            // if the edit control has the focus.
            //
            if (ped->fFocus && fpImmIsIME(hkl)) {
                POINT pt;

                ECImmSetCompositionFont(ped);
                NtUserGetCaretPos(&pt);
                ECImmSetCompositionWindow(ped, pt.x, pt.y);
            }
        }

        goto HandleEditMsg;

    case WM_COPY:

        /*
         * wParam - not used
         * lParam - not used
         */
        lreturn = (LONG)ECCopy(ped);
        break;

    case WM_CUT:
        /*
         *
         * wParamLo --    unused
         * lParam --    unused
         */
        ECCutText(ped);
        return 0;

    case WM_CLEAR:
        /*
         * wParamLo --    unused
         * lParam --    unused
         */
        ECClearText(ped);
        return 0;

    case WM_ENABLE:

        /*
         * wParam - nonzero if window is enabled else disable window if 0.
         * lParam - not used
         */
        lreturn = (LONG)(ped->fDisabled = !((BOOL)wParam));
        ECInvalidateClient(ped, TRUE);
        break;

    case WM_SYSCHAR:
        //
        // wParamLo --    key value
        // lParam --    unused
        //

        //
        // If this is a WM_SYSCHAR message generated by the UNDO
        // keystroke we want to EAT IT
        //
        if ((lParam & SYS_ALTERNATE) && ((WORD)wParam == VK_BACK))
            return TRUE;
        else {
            return DefWindowProcWorker(pwnd, message, wParam, lParam, ped->fAnsi);
        }
        break;

    case EM_GETLINECOUNT:

        /*
         * wParam - not used
           lParam - not used
         */
        lreturn = (LONG)ped->cLines;
        break;

    case EM_GETMODIFY:

        /*
         * wParam - not used
           lParam - not used
         */

        /*
         * Gets the state of the modify flag for this edit control.
         */
        lreturn = (LONG)ped->fDirty;
        break;

    case EM_SETMODIFY:

        /*
         * wParam - specifies the new value for the modify flag
           lParam - not used
         */

        /*
         * Sets the state of the modify flag for this edit control.
         */
        ped->fDirty = (wParam != 0);
        break;

    case EM_GETRECT:

        /*
         * wParam - not used
           lParam - pointer to a RECT data structure that gets the dimensions.
         */

        /*
         * Copies the rcFmt rect to *lpRect.
         */
        CopyRect((LPRECT)lParam, (LPRECT)&ped->rcFmt);
        lreturn = (LONG)TRUE;
        break;

    case WM_GETFONT:

        /*
         * wParam - not used
           lParam - not used
         */
        lreturn = (LRESULT)ped->hFont;
        break;

    case WM_SETFONT:

        /*
         * wParam - handle to the font
           lParam - redraw if true else don't
         */
        ECSetFont(ped, (HANDLE)wParam, (BOOL)LOWORD(lParam));
        break;

    case WM_GETTEXT:

        /*
         * wParam - max number of _bytes_ (not characters) to copy
         * lParam - buffer to copy text to. Text is 0 terminated.
         */
        lreturn = (LRESULT)ECGetText(ped, (ICH)wParam, (LPSTR)lParam, TRUE);
        break;

    case WM_SETTEXT:
        //
        // wParamLo --    unused
        // lParam --    LPSTR, null-terminated, with new text.
        //
        lreturn = (LRESULT)ECSetText(ped, (LPSTR)lParam);
        break;

    case WM_GETTEXTLENGTH:

        /*
         * Return count of CHARs!!!
         */
        lreturn = (LONG)ped->cch;
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:

        /*
         * wParam - not used
           lParam - not used
         */
        ECNcDestroyHandler(pwnd, ped);
        return 0;

    /*
     * Most apps (i.e. everyone but Quicken) don't pass on the rbutton
     * messages when they do something with 'em inside of subclassed
     * edit fields.  As such, we keep track of whether we saw the
     * down before the up.  If we don't see the up, then DefWindowProc
     * won't generate the context menu message, so no big deal.  If
     * we didn't see the down, then don't let WM_CONTEXTMENU do
     * anything.
     *
     * We also might want to not generate WM_CONTEXTMENUs for old
     * apps when the mouse is captured.
     */

    case WM_RBUTTONDOWN:
        ped->fSawRButtonDown = TRUE;
        goto HandleEditMsg;

    case WM_RBUTTONUP:
        if (ped->fSawRButtonDown) {
            ped->fSawRButtonDown = FALSE;
            if (!ped->fInReconversion) {
                goto HandleEditMsg;
            }
        }
        // Don't pass this on to DWP so WM_CONTEXTMENU isn't generated.
        return 0;

    case WM_CONTEXTMENU: {
            POINT pt ;
            int nHit = FindNCHit(pwnd, (LONG)lParam);
            if ((nHit == HTVSCROLL) || (nHit == HTHSCROLL)) {
                return DefWindowProcWorker(pwnd, message, wParam, lParam, ped->fAnsi);
            }
            POINTSTOPOINT(pt, lParam);
            if (!TestWF(pwnd, WFOLDUI) && ECIsAncestorActive(hwnd))
                ECMenu(hwnd, ped, &pt);
        }
        return 0;

    case EM_CANUNDO:

        /*
         * wParam - not used
           lParam - not used
         */
        lreturn = (LONG)(ped->undoType != UNDO_NONE);
        break;

    case EM_EMPTYUNDOBUFFER:

        /*
         * wParam - not used
           lParam - not used
         */
        ECEmptyUndo(Pundo(ped));
        break;

    case EM_GETMARGINS:
        //
        // wParam --    unused
        // lParam --    unused
        //
        return(MAKELONG(ped->wLeftMargin, ped->wRightMargin));

    case EM_SETMARGINS:
        //
        // wParam --    EC_ margin flags
        // lParam --    LOWORD is left, HIWORD is right margin
        //
        ECSetMargin(ped, (UINT)wParam, (DWORD)lParam, TRUE);
        return 0;

    case EM_GETSEL:

        /*
         * Gets the selection range for the given edit control. The
         * starting position is in the low order word. It contains the position
         * of the first nonselected character after the end of the selection in
         * the high order word.
         */
        if ((PDWORD)wParam != NULL) {
           *((PDWORD)wParam) = ped->ichMinSel;
        }
        if ((PDWORD)lParam != NULL) {
           *((PDWORD)lParam) = ped->ichMaxSel;
        }
        lreturn = MAKELONG(ped->ichMinSel,ped->ichMaxSel);
        break;

    case EM_GETLIMITTEXT:
        //
        // wParamLo --    unused
        // lParam --    unused
        //
        return(ped->cchTextMax);

    case EM_SETLIMITTEXT:        /* Renamed from EM_LIMITTEXT in Chicago */
        /*
         * wParam - max number of CHARACTERS that can be entered
         * lParam - not used
         */

        /*
         * Specifies the maximum number of characters of text the user may
         * enter. If maxLength is 0, we may enter MAXINT number of CHARACTERS.
         */
        if (ped->fSingle) {
            if (wParam) {
                wParam = min(0x7FFFFFFEu, wParam);
            } else {
                wParam = 0x7FFFFFFEu;
            }
        }

        if (wParam) {
            ped->cchTextMax = (ICH)wParam;
        } else {
            ped->cchTextMax = 0xFFFFFFFFu;
        }
        break;

    case EM_POSFROMCHAR:
        //
        // Validate that char index is within text range
        //
        if (wParam >= ped->cch) {
            return(-1L);
        }
        goto HandleEditMsg;

    case EM_CHARFROMPOS: {
        // Validate that point is within client of edit field
        RECT    rc;
        POINT   pt;

        POINTSTOPOINT(pt, lParam);
        _GetClientRect(pwnd, &rc);
        if (!PtInRect(&rc, pt)) {
            return(-1L);
        }
        goto HandleEditMsg;
    }

    case EM_SETPASSWORDCHAR:

        /*
         * wParam - sepecifies the new char to display instead of the
         * real text. if null, display the real text.
         */
        ECSetPasswordChar(ped, (UINT)wParam);
        break;

    case EM_GETPASSWORDCHAR:
        lreturn = (DWORD)ped->charPasswordChar;
        break;

    case EM_SETREADONLY:

        /*
         * wParam - state to set read only flag to
         */
        ped->fReadOnly = (wParam != 0);
        if (wParam)
            SetWindowState(pwnd, EFREADONLY);
        else
            ClearWindowState(pwnd, EFREADONLY);
        lreturn = 1L;

        ECEnableDisableIME( ped );
        // We need to redraw the edit field so that the background color
        // changes.  Read-only edits are drawn in CTLCOLOR_STATIC while
        // others are drawn with CTLCOLOR_EDIT.
        ECInvalidateClient(ped, TRUE);
        break;

    case EM_SETWORDBREAKPROC:

        /*
         * wParam - unused
         * lParam - FARPROC address of an app supplied call back function
         */
        ped->lpfnNextWord = (EDITWORDBREAKPROCA)lParam;
        break;

    case EM_GETWORDBREAKPROC:
        lreturn = (LRESULT)ped->lpfnNextWord;
        break;

    // IME
    case EM_GETIMESTATUS:
        // wParam == sub command
        switch (wParam) {
        case  EMSIS_COMPOSITIONSTRING:
            return ped->wImeStatus;
#if 0   // memphis
        case  EMSIS_GETLBBIT:
            return (DWORD)ped->bLBBit;
#endif
        }
        break;

    case EM_SETIMESTATUS:
        // wParam == sub command
        switch (wParam) {
        case EMSIS_COMPOSITIONSTRING:
            ped->wImeStatus = (WORD)lParam;
        }
        break;


    case WM_NCCREATE:
        lreturn = ECNcCreate(ped, pwnd, (LPCREATESTRUCT)lParam);
        break;

    case WM_LBUTTONDOWN:
        //
        // B#3623
        // Don't set focus to edit field if it is within an inactive,
        // captioned child.
        // We might want to version switch this...  I haven't found
        // any problems by not, but you never know...
        //
        if (ECIsAncestorActive(hwnd)) {
            /*
             * Reconversion support: quit reconversion if left button is clicked.
             * Otherwise, if the current KL is Korean, finailize the composition string.
             */
            if (ped->fInReconversion || ped->fKorea) {
                BOOLEAN fReconversion = (BOOLEAN)ped->fInReconversion;
                DWORD dwIndex = fReconversion ? CPS_CANCEL : CPS_COMPLETE;
                HIMC hImc;

                ped->fReplaceCompChr = FALSE;

                hImc = fpImmGetContext(ped->hwnd);
                if (hImc) {
                    fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, dwIndex, 0);
                    fpImmReleaseContext(ped->hwnd, hImc);
                }

                if (fReconversion) {
                    ECInOutReconversionMode(ped, FALSE);
                }

                ECSetCaretHandler(ped);
            }

            goto HandleEditMsg;
        }
        break;

    case WM_MOUSEMOVE:
        //
        // We only care about mouse messages when mouse is down.
        //
        if (ped->fMouseDown)
            goto HandleEditMsg;
        break;

    case WM_IME_SETCONTEXT:
        //
        // If ped->fInsertCompChr is TRUE, that means we will do
        // all the composition character drawing by ourself.
        //
        if ( ped->fInsertCompChr ) {
            lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
        }

        if ( wParam ) {

            PINPUTCONTEXT pInputContext;
            HIMC hImc;

            hImc = fpImmGetContext( hwnd );
            if ( (pInputContext = fpImmLockIMC( hImc )) != NULL ) {
                pInputContext->fdw31Compat &= ~F31COMPAT_ECSETCFS;
                fpImmUnlockIMC( hImc );
            }
            if (GetClientInfo()->CI_flags & CI_16BIT) {
                fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0L);
            }
            fpImmReleaseContext( hwnd, hImc );
        }
        return DefWindowProcWorker(pwnd, message, wParam, lParam, ped->fAnsi);

    case WM_IME_ENDCOMPOSITION:
        ECInOutReconversionMode(ped, FALSE);

        if (ped->fReplaceCompChr) {
            ICH ich;
            HDC hdc;
            //
            // we have a DBCS character to be replaced.
            // let's delete it before inserting the new one.
            //
            ich = (ped->fAnsi) ? 2 : 1;
            ped->fReplaceCompChr = FALSE;
            ped->ichMaxSel = min(ped->ichCaret + ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;
            if (ped->fSingle) {
                if (ECDeleteText( ped ) > 0) {
                    //
                    // Update the display
                    //
                    ECNotifyParent(ped, EN_UPDATE);
                    hdc = ECGetEditDC(ped, FALSE);
                    SLDrawText(ped, hdc, 0);
                    ECReleaseEditDC(ped, hdc, FALSE);
                    //
                    // Tell parent our text contents changed.
                    //
                    ECNotifyParent(ped, EN_CHANGE);
                }
            }
            else {
                MLDeleteText(ped);
            }

            ECSetCaretHandler( ped );
        }
        return DefWindowProcWorker(pwnd, message, wParam, lParam, ped->fAnsi);

    case WM_IME_STARTCOMPOSITION:
        if ( ped->fInsertCompChr ) {
            //
            // NOTE:
            // sending WM_IME_xxxCOMPOSITION will let
            // IME draw composition window. IME should
            // not do that since we cleared
            // ISC_SHOWUICOMPOSITIONWINDOW bit when
            // we got WM_IME_SETCONTEXT message.
            //
            // Korean IME should be fixed in the future.
            //
            break;

        } else {
            return DefWindowProcWorker(pwnd, message, wParam, lParam, ped->fAnsi);
        }

    // simple composition character support for FE IME.
    case WM_IME_COMPOSITION:
        return ECImeComposition(ped, wParam, lParam);

    case WM_KILLFOCUS:
        //
        // when focus is removed from the window,
        // composition character should be finalized
        //
        if (ped && fpImmIsIME(THREAD_HKL())) {
            HIMC hImc = fpImmGetContext(hwnd);

            if (hImc != NULL_HIMC) {
                if (ped->fReplaceCompChr || (ped->wImeStatus & EIMES_COMPLETECOMPSTRKILLFOCUS)) {
                    // If the composition string to be determined upon kill focus,
                    // do it now.
                    fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
                } else if (ped->fInReconversion) {
                    // If the composition string it not to be determined,
                    // and if we're in reconversion mode, cancel reconversion now.
                    fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                }

                // Get out from reconversion mode
                if (ped->fInReconversion) {
                    ECInOutReconversionMode(ped, FALSE);
                }

                fpImmReleaseContext(hwnd, hImc);
            }
        }
        goto HandleEditMsg;
        break;

    case WM_SETFOCUS:
        if (ped && !ped->fFocus) {
            HKL hkl = THREAD_HKL();

            if (fpImmIsIME(hkl)) {
                HIMC hImc;

                hImc = fpImmGetContext(hwnd);
                if (hImc) {
                    LPINPUTCONTEXT lpImc;

                    if (ped->wImeStatus & EIMES_CANCELCOMPSTRINFOCUS) {
                        // cancel when in-focus
                        fpImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                    }

                    ECImmSetCompositionFont(ped);

                    if ((lpImc = fpImmLockIMC(hImc)) != NULL) {

                        // We presume the CompForm will reset to CFS_DEFAULT,
                        // when the edit control loses Focus.
                        // IMEWndProc32 will call ImmSetCompositionWindow with
                        // CFS_DEFAULT, when it receive WM_IME_SETCONTEXT.
                        lpImc->fdw31Compat |= F31COMPAT_ECSETCFS;

                        fpImmUnlockIMC(hImc);
                    }
                    fpImmReleaseContext(hwnd, hImc);
                }

                //
                // force to set IME composition window when
                // first getting focus.
                //
                ped->ptScreenBounding.x = -1;
                ped->ptScreenBounding.y = -1;
            }
            /*
             * Insert and replace flags are initialized when the edit control gets the focus.
             *
             * Compat hack: a bogus application tries to cheat the system by sending input messages
             * *before* it sets the focus to the edit control. They rely on the flags not being set
             * at WM_SETFOCUS. Raid #411686
             */
            if ((GetAppCompatFlags2(VER40) & GACF2_NO_INIT_ECFLAGS_ON_SETFOCUS) == 0) {
                ECInitInsert(ped, hkl);
            }
        }
        goto HandleEditMsg;
        break;

    case WM_IME_REQUEST:
        // simple ImeRequest Handler
        return EcImeRequestHandler(ped, wParam, lParam);

    case WM_CREATE:
        if (ped)
            ECEnableDisableIME(ped);
        goto HandleEditMsg;
        break;

    default:
HandleEditMsg:
        /* (picked up from NT40FE SP3)
         * HACK ALERT: We may receive messages before the PED has been
         * allocated (eg: WM_GETMINMAXINFO is sent before WM_NCCREATE)
         * so we must test ped before dreferencing.
         */
        if (ped != NULL) {
            if (ped->fSingle) {
                lreturn = SLEditWndProc(hwnd, ped, message, wParam, lParam);
            } else {
                lreturn = MLEditWndProc(hwnd, ped, message, wParam, lParam);
            }
        }
    }

    return lreturn;
}

/***************************************************************************\
* ECFindXORblks
*
* This finds the XOR of lpOldBlk and lpNewBlk and return s resulting blocks
* through the lpBlk1 and lpBlk2; This could result in a single block or
* at the maximum two blocks;
* If a resulting block is empty, then it's StPos field has -1.
* NOTE:
* When called from MultiLine edit control, StPos and EndPos fields of
* these blocks have the Starting line and Ending line of the block;
* When called from SingleLine edit control, StPos and EndPos fields
* of these blocks have the character index of starting position and
* ending position of the block.
*
* History:
\***************************************************************************/

void ECFindXORblks(
    LPBLOCK lpOldBlk,
    LPBLOCK lpNewBlk,
    LPBLOCK lpBlk1,
    LPBLOCK lpBlk2)
{
    if (lpOldBlk->StPos >= lpNewBlk->StPos) {
        lpBlk1->StPos = lpNewBlk->StPos;
        lpBlk1->EndPos = min(lpOldBlk->StPos, lpNewBlk->EndPos);
    } else {
        lpBlk1->StPos = lpOldBlk->StPos;
        lpBlk1->EndPos = min(lpNewBlk->StPos, lpOldBlk->EndPos);
    }

    if (lpOldBlk->EndPos <= lpNewBlk->EndPos) {
        lpBlk2->StPos = max(lpOldBlk->EndPos, lpNewBlk->StPos);
        lpBlk2->EndPos = lpNewBlk->EndPos;
    } else {
        lpBlk2->StPos = max(lpNewBlk->EndPos, lpOldBlk->StPos);
        lpBlk2->EndPos = lpOldBlk->EndPos;
    }
}

/***************************************************************************\
* ECCalcChangeSelection
*
* This function finds the XOR between two selection blocks(OldBlk and NewBlk)
* and return s the resulting areas thro the same parameters; If the XOR of
* both the blocks is empty, then this return s FALSE; Otherwise TRUE.
*
* NOTE:
* When called from MultiLine edit control, StPos and EndPos fields of
* these blocks have the Starting line and Ending line of the block;
* When called from SingleLine edit control, StPos and EndPos fields
* of these blocks have the character index of starting position and
* ending position of the block.
*
* History:
\***************************************************************************/

BOOL ECCalcChangeSelection(
    PED ped,
    ICH ichOldMinSel,
    ICH ichOldMaxSel,
    LPBLOCK OldBlk,
    LPBLOCK NewBlk)
{
    BLOCK Blk[2];
    int iBlkCount = 0;

    Blk[0].StPos = Blk[0].EndPos = Blk[1].StPos = Blk[1].EndPos = 0xFFFFFFFF;

    /*
     * Check if the Old selection block existed
     */
    if (ichOldMinSel != ichOldMaxSel) {

        /*
         * Yes! Old block existed.
         */
        Blk[0].StPos = OldBlk->StPos;
        Blk[0].EndPos = OldBlk->EndPos;
        iBlkCount++;
    }

    /*
     * Check if the new Selection block exists
     */
    if (ped->ichMinSel != ped->ichMaxSel) {

        /*
         * Yes! New block exists
         */
        Blk[1].StPos = NewBlk->StPos;
        Blk[1].EndPos = NewBlk->EndPos;
        iBlkCount++;
    }

    /*
     * If both the blocks exist find the XOR of them
     */
    if (iBlkCount == 2) {

        /*
         * Check if both blocks start at the same character position
         */
        if (ichOldMinSel == ped->ichMinSel) {

            /*
             * Check if they end at the same character position
             */
            if (ichOldMaxSel == ped->ichMaxSel)
                return FALSE; /* Nothing changes */

            Blk[0].StPos = min(NewBlk -> EndPos, OldBlk -> EndPos);
            Blk[0].EndPos = max(NewBlk -> EndPos, OldBlk -> EndPos);
            Blk[1].StPos = 0xFFFFFFFF;
        } else {
            if (ichOldMaxSel == ped->ichMaxSel) {
                Blk[0].StPos = min(NewBlk->StPos, OldBlk->StPos);
                Blk[0].EndPos = max(NewBlk->StPos, OldBlk->StPos);
                Blk[1].StPos = 0xFFFFFFFF;
            } else {
                ECFindXORblks(OldBlk, NewBlk, &Blk[0], &Blk[1]);
            }
        }
    }

    RtlCopyMemory(OldBlk, &Blk[0], sizeof(BLOCK));
    RtlCopyMemory(NewBlk, &Blk[1], sizeof(BLOCK));

    return TRUE; /* Yup , There is something to paint */
}


/***************************************************************************\
* ECGetControlBrush
*
* Client side optimization replacement for NtUserGetControlBrush
*
* message is one of the WM_CTLCOLOR* messages.
*
\***************************************************************************/

HBRUSH ECGetControlBrush(
    PED  ped,
    HDC  hdc,
    LONG message)
{
    PWND pwndSend;
    PWND pwndEdit;

    pwndEdit = ValidateHwnd(ped->hwnd);

    if (pwndEdit == (PWND)NULL)
        return (HBRUSH)0;

    if ((pwndSend = (TestwndPopup(pwndEdit) ? pwndEdit->spwndOwner : pwndEdit->spwndParent)) == NULL)
        pwndSend = pwndEdit;
    else
        pwndSend = REBASEPTR(pwndEdit, pwndSend);

    UserAssert(pwndSend);

    if (PtiCurrent() != GETPTI(pwndSend)) {
        return (HBRUSH)DefWindowProcWorker(pwndSend, message,
                (WPARAM)hdc, (LPARAM)pwndEdit, ped->fAnsi);
    }

    /*
     * By using the correct A/W call we avoid a c/s transition
     * on this SendMessage().
     */
    return (HBRUSH)SendMessageWorker(pwndSend, message, (WPARAM)hdc,
            (LPARAM)ped->hwnd, ped->fAnsi);
}

UINT WINAPI QueryFontAssocStatus(void);
UINT fFontAssocStatus = 0xffff;

/***************************************************************************\
* ECGetDBCSVector( PED ped, BYTE CharSet )
*
*   This function sets DBCS Vector for specified character set and sets
*   ped->fDBCS flag if needed.
*
* History: 18-Jun-1996 Hideyuki Nagase
\***************************************************************************/
int ECGetDBCSVector(PED ped, HDC hdc, BYTE CharSet)
{
    BOOL bDBCSCodePage = FALSE;
    /*
     * if DEFAUT_CHARSET was passed, we will convert that to Shell charset..
     */
    if (CharSet == DEFAULT_CHARSET) {
        CharSet = (BYTE)GetTextCharset(hdc);

        /*
         * if CharSet is still DEFAULT_CHARSET, it means gdi has some problem..
         * then just return default.. we get charset from CP_ACP..
         */
        if (CharSet == DEFAULT_CHARSET) {
            CharSet = (BYTE)GetACPCharSet();
        }
    }

    switch (CharSet) {
    case SHIFTJIS_CHARSET:
    case HANGEUL_CHARSET:
    case CHINESEBIG5_CHARSET:
    case GB2312_CHARSET:
        bDBCSCodePage = TRUE;
        break;

    case ANSI_CHARSET:            // 0
    case SYMBOL_CHARSET:          // 2
    case OEM_CHARSET:             // 255
        if (fFontAssocStatus == 0xffff)
            fFontAssocStatus = QueryFontAssocStatus();

        if ((((CharSet + 2) & 0xf) & fFontAssocStatus)) {
            bDBCSCodePage = TRUE;
            /*
             * Bug 117558, etc.
             * Try to get a meaningful character set for associated font.
             */
            CharSet = (BYTE)GetACPCharSet();
        } else {
            bDBCSCodePage = FALSE;
        }
        break;

    default:
        bDBCSCodePage = FALSE;
    }

    if (bDBCSCodePage) {
        CHARSETINFO CharsetInfo;
        DWORD CodePage;
        CPINFO CPInfo;
        int lbIX;

        if (TranslateCharsetInfo((DWORD *)CharSet, &CharsetInfo, TCI_SRCCHARSET)) {
            CodePage = CharsetInfo.ciACP;
        } else {
            CodePage = CP_ACP;
        }

        GetCPInfo(CodePage, &CPInfo);
        for (lbIX=0 ; CPInfo.LeadByte[lbIX] != 0 ; lbIX+=2) {
            ped->DBCSVector[lbIX  ] = CPInfo.LeadByte[lbIX];
            ped->DBCSVector[lbIX+1] = CPInfo.LeadByte[lbIX+1];
        }
        ped->DBCSVector[lbIX  ] = 0x0;
        ped->DBCSVector[lbIX+1] = 0x0;
    } else {
        ped->DBCSVector[0] = 0x0;
        ped->DBCSVector[1] = 0x0;
    }

    //
    // Final check: if the font supports DBCS glyphs
    //
    // If we've got a font with DBCS glyphs, let's mark PED so.
    // But since the font's primary charset is the one other than FE,
    // we can only support UNICODE Edit control.
    //
    //  a) GDI performs A/W conversion for ANSI apps based on the primary
    //     character set in hDC, so it will break anyway.
    //  b) ANSI applications are only supported on their native system locales:
    //     GetACPCharSet() is expected to return a FE code page.
    //  c) ANSI Edit control requires DBCSVector, which cannot be
    //     initialized without a FE code page.
    //
    if (!ped->fAnsi) {
        FONTSIGNATURE fontSig;

        GetTextCharsetInfo(hdc, &fontSig, 0);
        if (fontSig.fsCsb[0] & FAREAST_CHARSET_BITS) {
            bDBCSCodePage = TRUE;
            // Since this is UNICODE, we're not
        }
    }

    return bDBCSCodePage;
}

/***************************************************************************\
* LPSTR ECAnsiNext( ped, lpCurrent )
*
*   This function advances string pointer for Edit Control use only.
*
* History:
\***************************************************************************/
LPSTR ECAnsiNext(PED ped, LPSTR lpCurrent)
{
    return lpCurrent+((ECIsDBCSLeadByte(ped,*lpCurrent)==TRUE) ? 2 : 1);
}

/***************************************************************************\
* LPSTR ECAnsiPrev( ped, lpBase, lpStr )
*
*   This function decrements string pointer for Edit Control use only.
*
* History:
\***************************************************************************/
LPSTR ECAnsiPrev(PED ped, LPSTR lpBase, LPSTR lpStr )
{
    LPSTR lpCurrent = lpStr -1;

    if (!ped->fDBCS)
        return lpCurrent;                        // just return ( lpStr - 1 )

    if (lpBase >= lpCurrent)
        return lpBase;

    if (ECIsDBCSLeadByte(ped, *lpCurrent))     // this check makes things faster
        return (lpCurrent - 1);                  // 92/04/04 takaok

    do {
        lpCurrent--;
        if (!ECIsDBCSLeadByte(ped, *lpCurrent)) {
            lpCurrent++;
            break;
        }
    } while(lpCurrent != lpBase);

    return lpStr - (((lpStr - lpCurrent) & 1) ? 1 : 2);
}

/***************************************************************************\
* ICH ECNextIch( ped, pText, ichCurrent )
*
*   This function advances string pointer for Edit Control use only.
*
* History:
\***************************************************************************/
ICH ECNextIch( PED ped, LPSTR pStart, ICH ichCurrent )
{
    if (!ped->fDBCS || !ped->fAnsi) {

        return (ichCurrent + 1);

    } else {

        ICH ichRet;
        LPSTR pText;

        if (pStart)
            pText = pStart + ichCurrent;
        else
            pText = (LPSTR)ECLock(ped) + ichCurrent;

        ichRet = ichCurrent + ( ECIsDBCSLeadByte(ped, *pText) ? 2 : 1 );

        if (!pStart)
            ECUnlock(ped);

        return (ichRet);
    }
}

/***************************************************************************\
* ICH ECPrevIch( ped, LPSTR pStart, ICH ichCurrent )
*
*   This function decrements string pointer for Edit Control use only.
*
* History:
\***************************************************************************/
ICH ECPrevIch( PED ped, LPSTR pStart, ICH ichCurrent )
{
    LPSTR lpCurrent;
    LPSTR lpStr;
    LPSTR lpBase;

#ifdef SURROGATE
    // Handle Unicode surrogates pairs when CSLPK is loaded
    if (ped->fAnsi || !ped->pLpkEditCallout)  // if no surrogate processing required
#endif
        if (!ped->fDBCS || !ped->fAnsi)
            if ( ichCurrent )
                return (ichCurrent - 1);
            else
                return (ichCurrent);

    if (ichCurrent <= 1)
        return 0;

    if (pStart)
        lpBase = pStart;
    else
        lpBase = ECLock(ped);

#ifdef SURROGATE

    // Handle characters represented by multiple codepoints

    if (ped->fAnsi) {

        // ANSI PrevIch with DBCS support
#endif

        lpStr = lpBase + ichCurrent;
        lpCurrent = lpStr - 1;
        if (ECIsDBCSLeadByte(ped,*lpCurrent)) {
            if (!pStart)
                ECUnlock(ped);
            return (ichCurrent - 2);
        }

        do {
            lpCurrent--;
            if (!ECIsDBCSLeadByte(ped, *lpCurrent)) {
                lpCurrent++;
                break;
            }
        } while(lpCurrent != lpBase);

        if (!pStart)
            ECUnlock(ped);
        return (ichCurrent - (((lpStr - lpCurrent) & 1) ? 1 : 2));

#ifdef SURROGATE

    } else {

        // Unicode PrevIch with surrogate pair support

        ichCurrent--;

        if (    (((WCHAR*)lpBase)[ichCurrent]   & 0xFC00) == 0xDC00
            &&  (((WCHAR*)lpBase)[ichCurrent-1] & 0xFC00) == 0xD800) {

            ichCurrent--;
        }

        if (!pStart)
            ECUnlock(ped);

        return ichCurrent;
    }
#endif
}

/***************************************************************************\
* BOOL ECIsDBCSLeadByte( PED ped, BYTE cch )
*
*   IsDBCSLeadByte for Edit Control use only.
*
* History: 18-Jun-1996 Hideyuki Nagase
\***************************************************************************/
BOOL ECIsDBCSLeadByte(PED ped, BYTE cch)
{
    int i;

    if (!ped->fDBCS || !ped->fAnsi)
        return (FALSE);

    for (i = 0; ped->DBCSVector[i]; i += 2) {
        if ((ped->DBCSVector[i] <= cch) && (ped->DBCSVector[i+1] >= cch))
            return (TRUE);
    }

    return (FALSE);
}

/***************************************************************************\
* int DBCSCombine(HWND hwnd, int ch)
*
* Assemble two WM_CHAR messages to single DBCS character.
* If program detects first byte of DBCS character in WM_CHAR message,
* it calls this function to obtain second WM_CHAR message from queue.
* finally this routine assembles first byte and second byte into single
* DBCS character.
*
* History:
\***************************************************************************/
WORD DbcsCombine(HWND hwnd, WORD ch)
{
    MSG msg;
    int i = 10; /* loop counter to avoid the infinite loop */

    while (!PeekMessageA(&msg, hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
        if (--i == 0)
            return 0;
        Sleep(1);
    }

    return (WORD)ch | ((WORD)(msg.wParam) << 8);
}

/***************************************************************************\
* ICH ECAdjustIch( PED ped, LPSTR lpstr, ICH ch )
*
* This function adjusts a current pointer correctly. If a current
* pointer is lying between DBCS first byte and second byte, this
* function adjusts a current pointer to a first byte of DBCS position
* by decrement once.
*
* History:
\***************************************************************************/
ICH ECAdjustIch( PED ped, LPSTR lpstr, ICH ch )
{
    ICH newch = ch;

    if (!ped->fAnsi || !ped->fDBCS || newch == 0)
        return ( ch );

    if (!ECIsDBCSLeadByte(ped,lpstr[--newch]))
        return ( ch );  // previous char is SBCS
    while(1) {
        if (!ECIsDBCSLeadByte(ped,lpstr[newch])) {
            newch++;
            break;
        }
        if (newch)
            newch--;
        else
            break;
    }
    return ((ch - newch) & 1) ? ch-1 : ch;
}

/***************************************************************************\
* ICH ECAdjustIchNext( PED ped, LPSTR lpstr, ICH ch )
*
* History:
* 19.Jun.1996 Hideyuki Nagase [hideyukn] - Port from Win95-FarEast version
\***************************************************************************/

ICH FAR PASCAL ECAdjustIchNext(PED ped, LPSTR lpstr, ICH ch)
{
    ICH ichNew = ECAdjustIch(ped,lpstr,ch);
    LPSTR lpnew = lpstr+ichNew;

    // if ch > ichNew then ECAdjustIch adjusted ich.
    if (ch > ichNew)
       lpnew = ECAnsiNext(ped, lpnew);

    return (ICH)(lpnew-lpstr);
}

/***************************************************************************\
* ECUpdateFormat
*
* Computes ped->format and ped->fRtoLReading from dwStyle and dwExStyle.
* Refreshes the display if either are changed.
*
* History:
*    May 12, 1997   [samera]     wrote it
*    May 12, 1997   [dbrown]     rewrote it
\***************************************************************************/

void ECUpdateFormat(
    PED   ped,
    DWORD dwStyle,
    DWORD dwExStyle)
{
    UINT fNewRtoLReading;
    UINT uiNewFormat;

    // Extract new format and reading order from style

    fNewRtoLReading = dwExStyle & WS_EX_RTLREADING ? 1 : 0;
    uiNewFormat     = dwStyle & ES_FMTMASK;


    // WS_EX_RIGHT is ignored unless dwStyle is ES_LEFT

    if (uiNewFormat == ES_LEFT && dwExStyle & WS_EX_RIGHT) {
        uiNewFormat = ES_RIGHT;
    }


    // Internally ES_LEFT and ES_RIGHT are swapped for RtoLReading order
    // (Think of them as ES_LEADING and ES_TRAILING)

    if (fNewRtoLReading) {
        switch (uiNewFormat) {
            case ES_LEFT:  uiNewFormat = ES_RIGHT; break;
            case ES_RIGHT: uiNewFormat = ES_LEFT;  break;
        }
    }


    // Format change does not cause redisplay by itself

    ped->format = uiNewFormat;


    // Refresh display on change of reading order

    if (fNewRtoLReading != ped->fRtoLReading) {

        ped->fRtoLReading = fNewRtoLReading;

        if (ped->fWrap) {
            // Redo wordwrap
            MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);
            MLUpdateiCaretLine(ped);
        } else {
            // Refresh horizontal scrollbar display
            MLScroll(ped, FALSE, 0xffffffff, 0, TRUE);
        }
        ECInvalidateClient(ped, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\edmlonce.c ===
/****************************************************************************\
* edmlonce.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* dec 1990 mikeke from win30
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* MLCreate AorW
*
* Creates the edit control for the window hwnd by allocating memory
* as required from the application's heap. Notifies parent if no memory
* error (after cleaning up if needed). Returns TRUE if no error else return s
* -1.
*
* History:
\***************************************************************************/

LONG MLCreate(
    PED ped,
    LPCREATESTRUCT lpCreateStruct)
{
    LONG windowStyle;
    LPWSTR lpszName;

    /*
     * Get values from the window instance data structure and put them in the
     * ped so that we can access them easier
     */
    windowStyle = ped->pwnd->style;

    /*
     * Do the standard creation stuff
     */
    if (!ECCreate(ped, windowStyle)) {
        return (-1);
    }

    /*
     * Allocate line start array in local heap and lock it down
     */
    ped->chLines = (LPICH)LocalAlloc(LPTR, 2 * sizeof(int));
    if (ped->chLines == NULL) {
        return (-1);
    }

    /*
     * Call it one line of text...
     */
    ped->cLines = 1;

    /*
     * If app wants WS_VSCROLL or WS_HSCROLL, it automatically gets AutoVScroll
     * or AutoHScroll.
     */
    if ((windowStyle & ES_AUTOVSCROLL) || (windowStyle & WS_VSCROLL)) {
        ped->fAutoVScroll = 1;
    }

    if (ped->format != ES_LEFT)
    {
        /*
         * If user wants right or center justified text, then we turn off
         * AUTOHSCROLL and WS_HSCROLL since non-left styles don't make sense
         * otherwise.
         */
        windowStyle &= ~WS_HSCROLL;
        ClearWindowState(ped->pwnd, WFHSCROLL);
        ped->fAutoHScroll = FALSE;
    }
    else if (windowStyle & WS_HSCROLL) {
        ped->fAutoHScroll = TRUE;
    }

    ped->fWrap = (!ped->fAutoHScroll && !(windowStyle & WS_HSCROLL));

    /*
     * Max # chars we will allow user to enter
     */
    ped->cchTextMax = MAXTEXT;

    /*
     * Set the default font to be the system font.
     */
    ECSetFont(ped, NULL, FALSE) ;

    /*
     * Set the window text if needed and notify parent if not enough memory to
     * set the initial text.
     */
    if ((ULONG_PTR)lpCreateStruct->lpszName > gHighestUserAddress)
        lpszName = REBASEPTR(ped->pwnd, (PVOID)lpCreateStruct->lpszName);
    else
        lpszName = (LPWSTR)lpCreateStruct->lpszName;
    if (!ECSetText(ped, (LPSTR)lpszName))
        return (-1);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\edslrare.c ===
/****************************************************************************\
* edslRare.c - SL Edit controls Routines Called rarely are to be
* put in a seperate segment _EDSLRare. This file contains
* these routines.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Single-Line Support Routines called Rarely
*
* Created: 02-08-89 sankar
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* SLCreate
*
* Creates the edit control for the window hwnd by allocating memory
* as required from the application's heap. Notifies parent if no memory
* error (after cleaning up if needed). Returns TRUE if no error else return s
* -1.
*
* History:
\***************************************************************************/

LONG SLCreate(
    PED ped,
    LPCREATESTRUCT lpCreateStruct) //!!! CREATESTRUCT AorW and in other routines
{
    LPSTR lpWindowText;
    LONG windowStyle = ped->pwnd->style;

    /*
     * Do the standard creation stuff
     */
    if (!ECCreate(ped, windowStyle))
        return (-1);

    /*
     * Single lines always have no undo and 1 line
     */
    ped->cLines = 1;
    ped->undoType = UNDO_NONE;

    /*
     * Check if this edit control is part of a combobox and get a pointer to the
     * combobox structure.
     */
    if (windowStyle & ES_COMBOBOX)
        ped->listboxHwnd = GetDlgItem(lpCreateStruct->hwndParent, CBLISTBOXID);

    /*
     * Set the default font to be the system font.
     */
    ECSetFont(ped, NULL, FALSE);

    /*
     * Set the window text if needed. Return false if we can't set the text
     * SLSetText notifies the parent in case there is a no memory error.
     */
    if ((ULONG_PTR)lpCreateStruct->lpszName > gHighestUserAddress)
        lpWindowText = REBASEPTR(ped->pwnd, (PVOID)lpCreateStruct->lpszName);
    else
        lpWindowText = (LPSTR)lpCreateStruct->lpszName;

    if ((lpWindowText != NULL)
            && !IsEmptyString(lpWindowText, ped->fAnsi)
            && !ECSetText(ped, lpWindowText)) {
        return (-1);
    }

    if (windowStyle & ES_PASSWORD)
        ECSetPasswordChar(ped, (UINT)'*');

    return TRUE;
}

/***************************************************************************\
* SLUndoHandler AorW
*
* Handles UNDO for single line edit controls.
*
* History:
\***************************************************************************/

BOOL SLUndo(
    PED ped)
{
    PBYTE hDeletedText = ped->hDeletedText;
    BOOL fDelete = (BOOL)(ped->undoType & UNDO_DELETE);
    ICH cchDeleted = ped->cchDeleted;
    ICH ichDeleted = ped->ichDeleted;
    BOOL fUpdate = FALSE;

    if (ped->undoType == UNDO_NONE) {

        /*
         * No undo...
         */
        return FALSE;
    }

    ped->hDeletedText = NULL;
    ped->cchDeleted = 0;
    ped->ichDeleted = (ICH)-1;
    ped->undoType &= ~UNDO_DELETE;

    if (ped->undoType == UNDO_INSERT) {
        ped->undoType = UNDO_NONE;

        /*
         * Set the selection to the inserted text
         */
        SLSetSelection(ped, ped->ichInsStart, ped->ichInsEnd);
        ped->ichInsStart = ped->ichInsEnd = (ICH)-1;

#ifdef NEVER

        /*
         * Now send a backspace to deleted and save it in the undo buffer...
         */
        SLCharHandler(pped, VK_BACK);
        fUpdate = TRUE;
#else

        /*
         * Delete the selected text and save it in undo buff.
         * Call ECDeleteText() instead of sending a VK_BACK message
         * which results in an EN_UPDATE notification send even before
         * we insert the deleted chars. This results in Bug #6610.
         * Fix for Bug #6610 -- SANKAR -- 04/19/91 --
         */
        if (ECDeleteText(ped)) {

            /*
             * Text was deleted -- flag for update and clear selection
             */
            fUpdate = TRUE;
            SLSetSelection(ped, ichDeleted, ichDeleted);
        }
#endif
    }

    if (fDelete) {
        HWND hwndSave = ped->hwnd; // Used for validation.

        /*
         * Insert deleted chars. Set the selection to the inserted text.
         */
        SLSetSelection(ped, ichDeleted, ichDeleted);
        SLInsertText(ped, hDeletedText, cchDeleted);
        UserGlobalFree(hDeletedText);
        if (!IsWindow(hwndSave))
            return FALSE;
        SLSetSelection(ped, ichDeleted, ichDeleted + cchDeleted);
        fUpdate = TRUE;
    }

    if (fUpdate) {
        /*
         * If we have something to update, send EN_UPDATE before and
         * EN_CHANGE after the actual update.
         * A part of the fix for Bug #6610 -- SANKAR -- 04/19/91 --
         */
        ECNotifyParent(ped, EN_UPDATE);

        if (FChildVisible(ped->hwnd)) {
// JimA changed this to ECInvalidateClient(ped, FALSE) Nov 1994
//            GetClientRect(ped->hwnd, &rcEdit);
//            if (ped->fBorder && rcEdit.right - rcEdit.left && rcEdit.bottom - rcEdit.top) {
//
//                /*
//                 * Don't invalidate the border so that we avoid flicker
//                 */
//                InflateRect(&rcEdit, -1, -1);
//            }
//            NtUserInvalidateRect(ped->hwnd, &rcEdit, FALSE);
            ECInvalidateClient(ped, FALSE);
        }

        ECNotifyParent(ped, EN_CHANGE);

        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\editsl.c ===
/****************************************************************************\
* editsl.c - Edit controls rewrite. Version II of edit controls.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Single Line Support Routines
*
* Created: 24-Jul-88 davidds
*
* Language pack notes:
*   With the language pack loaded all positional processing is based on
*   ped->xOffset rather than ped->ichScreenStart. The non-lpk optimisation of
*   maintaining ped->ichScreenStart doesn't work because of the
*   glyph reordering features of complex scripts.
*
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define SYS_ALTERNATE 0x2000

typedef BOOL (*FnGetTextExtentPoint)(HDC, PVOID, int, LPSIZE);

/***************************************************************************\
* SLCalcStringWidth
*
\***************************************************************************/

int SLCalcStringWidth(PED ped, HDC hdc, ICH ich, ICH cch)
{
    if (cch == 0)
        return 0;

    if (ped->charPasswordChar) {
        return cch * ped->cPasswordCharWidth;
    } else {
        SIZE size;

        if (ped->fNonPropFont && !ped->fDBCS) {
            size.cx = cch * ped->aveCharWidth;
        } else {
            PSTR pText = ECLock(ped);
            if (ped->fAnsi) {
                GetTextExtentPointA(hdc, (LPSTR)(pText + ich), cch, &size);
            } else {
                GetTextExtentPointW(hdc, (LPWSTR)pText + ich, cch, &size);
            }
            ECUnlock(ped);
        }
        return size.cx - ped->charOverhang;
    }
}

/***************************************************************************\
* SLCalcXOffsetLeft
*
* Calculates the starting offset for left-aligned strings.
*
\***************************************************************************/

int SLCalcXOffsetLeft(PED ped, HDC hdc, ICH ich)
{
    int cch = (int)(ich - ped->ichScreenStart);

    if (cch <= 0)
        return 0;

    return SLCalcStringWidth(ped, hdc, ped->ichScreenStart, cch);
}

/***************************************************************************\
* SLCalcXOffsetSpecial
*
* Calculates the horizontal offset (indent) required for right or center
* justified lines.
*
\***************************************************************************/

int SLCalcXOffsetSpecial(PED ped, HDC hdc, ICH ich)
{
    PSTR pText;
    ICH cch, ichStart = ped->ichScreenStart;
    int cx;

    /*
     * Calc the number of characters from start to right end.
     */
    pText = ECLock(ped);
    cch = ECCchInWidth(ped, hdc, (LPSTR)(pText + ichStart * ped->cbChar),
            ped->cch - ichStart, ped->rcFmt.right - ped->rcFmt.left, TRUE);
    ECUnlock(ped);

    /*
     * Once the last character of the string has been scrolled out of
     * the view, use normal offset calculation.
     */
    if (ped->ichScreenStart + cch < ped->cch)
        return SLCalcXOffsetLeft(ped, hdc, ich);

    cx = ped->rcFmt.right - ped->rcFmt.left - SLCalcStringWidth(ped,
            hdc, ichStart, cch);

    if (ped->format == ES_CENTER) {
         cx = max(0, cx / 2);
    } else if (ped->format == ES_RIGHT) {
        /*
         * Subtract 1 so that the 1 pixel wide cursor will be in the visible
         * region on the very right side of the screen, mle does this.
         */
        cx = max(0, cx - 1);
    }

    return cx + SLCalcStringWidth(ped, hdc, ichStart, ich - ichStart);
}

/***************************************************************************\
* SLSetCaretPosition AorW
*
* If the window has the focus, find where the caret belongs and move
* it there.
*
* History:
\***************************************************************************/

void SLSetCaretPosition(
    PED ped,
    HDC hdc)
{
    int xPosition;

    /*
     * We will only position the caret if we have the focus since we don't want
     * to move the caret while another window could own it.
     */
    if (!ped->fFocus)
        return;

    if (ped->fCaretHidden) {
        NtUserSetCaretPos(-20000, -20000);
        return;
    }

    xPosition = SLIchToLeftXPos(ped, hdc, ped->ichCaret);

    /*
     * Don't let caret go out of bounds of edit control if there is too much
     * text.
     */
    if (ped->pLpkEditCallout) {
        xPosition += ped->iCaretOffset;
        xPosition = max(xPosition , 0);
        xPosition = min(xPosition, ped->rcFmt.right - 1 -
            ((ped->cxSysCharWidth > ped->aveCharWidth) ? 1 : 2));
    } else {
        xPosition = min(xPosition, ped->rcFmt.right -
            ((ped->cxSysCharWidth > ped->aveCharWidth) ? 1 : 2));
    }

    NtUserSetCaretPos(xPosition, ped->rcFmt.top);

    // FE_IME SLSetCaretPosition - ECImmSetCompostionWindow( CFS_POINT )
    if (fpImmIsIME(THREAD_HKL())) {
        ECImmSetCompositionWindow(ped, xPosition, ped->rcFmt.top);
    }
}

/***************************************************************************\
* SLIchToLeftXPos AorW
*
* Given a character index, find its (left side) x coordinate within
* the ped->rcFmt rectangle assuming the character ped->ichScreenStart is at
* coordinates (ped->rcFmt.top, ped->rcFmt.left). A negative value is
* return ed if the character ich is to the left of ped->ichScreenStart. WARNING:
* ASSUMES AT MOST 1000 characters will be VISIBLE at one time on the screen.
* There may be 64K total characters in the editcontrol, but we can only
* display 1000 without scrolling. This shouldn't be a problem obviously.
* !NT
* History:
\***************************************************************************/

int SLIchToLeftXPos(
    PED ped,
    HDC hdc,
    ICH ich)
{
    int textExtent;
    PSTR pText;
    SIZE size;
    int  cchDiff;

    if (ped->pLpkEditCallout) {

       pText = ECLock(ped);
       textExtent = ped->pLpkEditCallout->EditIchToXY(ped, hdc, pText, ped->cch, ich);
       ECUnlock(ped);

       return textExtent;

    }

    /*
     * Check if we are adding lots and lots of chars. A paste for example could
     * cause this and GetTextExtents could overflow on this.
     */
    cchDiff = (int)ich - (int)ped->ichScreenStart;
    if (cchDiff > 1000)
        return (30000);
    else if (cchDiff < -1000)
        return (-30000);

    if (ped->format != ES_LEFT)
        return (ped->rcFmt.left + SLCalcXOffsetSpecial(ped, hdc, ich));

    /*
     * Caret position /w DBCS text, we can not optimize...
     */
    if (ped->fNonPropFont && !ped->fDBCS)
        return (ped->rcFmt.left + cchDiff*ped->aveCharWidth);

    /*
     * Check if password hidden chars are being used.
     */
    if (ped->charPasswordChar)
        return ( ped->rcFmt.left + cchDiff*ped->cPasswordCharWidth);

    pText = ECLock(ped);

    if (ped->fAnsi) {
        if (cchDiff >= 0) {

            GetTextExtentPointA(hdc, (LPSTR)(pText + ped->ichScreenStart),
                    cchDiff, &size);
            textExtent =  size.cx;

            /*
             * In case of signed/unsigned overflow since the text extent may be
             * greater than maxint. This happens with long single line edit
             * controls. The rect we edit text in will never be greater than 30000
             * pixels so we are ok if we just ignore them.
             */
            if (textExtent < 0 || textExtent > 31000)
                textExtent = 30000;
        } else {
            GetTextExtentPointA(hdc,(LPSTR)(pText + ich), -cchDiff, &size);
            textExtent = (-1) * size.cx;
        }
    } else {  //!fAnsi
        if (cchDiff >= 0) {

            GetTextExtentPointW(hdc, (LPWSTR)(pText + ped->ichScreenStart*sizeof(WCHAR)),
                    cchDiff, &size);
            textExtent =  size.cx;

            /*
             * In case of signed/unsigned overflow since the text extent may be
             * greater than maxint. This happens with long single line edit
             * controls. The rect we edit text in will never be greater than 30000
             * pixels so we are ok if we just ignore them.
             */
            if (textExtent < 0 || textExtent > 31000)
                textExtent = 30000;
        } else {
            GetTextExtentPointW(hdc,(LPWSTR)(pText + ich*sizeof(WCHAR)), -cchDiff, &size);
            textExtent = (-1) * size.cx;
        }
    }

    ECUnlock(ped);

    return (ped->rcFmt.left + textExtent -
            (textExtent ? ped->charOverhang : 0));
}

/***************************************************************************\
* SLSetSelection AorW
*
* Sets the PED to have the new selection specified.
*
* History:
\***************************************************************************/

void SLSetSelection(
    PED ped,
    ICH ichSelStart,
    ICH ichSelEnd)
{
    HDC hdc = ECGetEditDC(ped, FALSE );

    if (ichSelStart == 0xFFFFFFFF) {

        /*
         * Set no selection if we specify -1
         */
        ichSelStart = ichSelEnd = ped->ichCaret;
    }

    /*
     * Bounds ichSelStart, ichSelEnd are checked in SLChangeSelection...
     */
    SLChangeSelection(ped, hdc, ichSelStart, ichSelEnd);

    /*
     * Put the caret at the end of the selected text
     */
    ped->ichCaret = ped->ichMaxSel;

    SLSetCaretPosition(ped, hdc);

    /*
     * We may need to scroll the text to bring the caret into view...
     */
    SLScrollText(ped, hdc);

    ECReleaseEditDC(ped, hdc, FALSE);
}

/***************************************************************************\
*
*  SLGetClipRect()
*
\***************************************************************************/
void SLGetClipRect(
    PED     ped,
    HDC     hdc,
    ICH     ichStart,
    int     iCount,
    LPRECT  lpClipRect )
{
    int    iStCount;
    PSTR   pText;

    if (ped->pLpkEditCallout) {
        RIPMSG0(RIP_WARNING, "SLGetClipRect - Error - Invalid call with language pack loaded");
        RtlZeroMemory(lpClipRect, sizeof(RECT));
        return;
    }

    CopyRect(lpClipRect, &ped->rcFmt);

    pText = ECLock(ped) ;

    // Calculates the starting pos for this piece of text
    if ((iStCount = (int)(ichStart - ped->ichScreenStart)) > 0) {
        if (ped->format == ES_LEFT) {
            lpClipRect->left += SLCalcXOffsetLeft(ped, hdc, ichStart);
        }
    } else {
            // Reset the values to visible portions
            iCount -= (ped->ichScreenStart - ichStart);
            ichStart = ped->ichScreenStart;
    }

    if (ped->format != ES_LEFT) {
        lpClipRect->left += SLCalcXOffsetSpecial(ped, hdc, ichStart);
    }

    if (iCount < 0) {
        /*
         * This is not in the visible area of the edit control, so return
         * an empty rect.
         */
        SetRectEmpty(lpClipRect);
        ECUnlock(ped);
        return;
    }

    if (ped->charPasswordChar)
             lpClipRect->right = lpClipRect->left + ped->cPasswordCharWidth * iCount;
    else {
        SIZE size ;

        if ( ped->fAnsi) {
            GetTextExtentPointA(hdc, pText + ichStart, iCount, &size);
        } else {
            GetTextExtentPointW(hdc, ((LPWSTR)pText) + ichStart, iCount, &size);
        }
        lpClipRect->right = lpClipRect->left + size.cx - ped->charOverhang;
    }

    ECUnlock(ped);
}

/***************************************************************************\
* SLChangeSelection AorW
*
* Changes the current selection to have the specified starting and
* ending values. Properly highlights the new selection and unhighlights
* anything deselected. If NewMinSel and NewMaxSel are out of order, we swap
* them. Doesn't update the caret position.
*
* History:
\***************************************************************************/

void SLChangeSelection(
    PED ped,
    HDC hdc,
    ICH ichNewMinSel,
    ICH ichNewMaxSel)
{
    ICH temp;
    ICH ichOldMinSel;
    ICH ichOldMaxSel;

    if (ichNewMinSel > ichNewMaxSel) {
        temp = ichNewMinSel;
        ichNewMinSel = ichNewMaxSel;
        ichNewMaxSel = temp;
    }
    ichNewMinSel = min(ichNewMinSel, ped->cch);
    ichNewMaxSel = min(ichNewMaxSel, ped->cch);

    //
    // To avoid position to half of DBCS, check and ajust position if necessary
    //
    // We check ped->fDBCS and ped->fAnsi though ECAdjustIch checks these bits.
    // We're worrying about the overhead of EcLock and EcUnlock.
    //
    if (ped->fDBCS && ped->fAnsi) {
        PSTR pText;

        pText = ECLock(ped);
        ichNewMinSel = ECAdjustIch( ped, pText, ichNewMinSel );
        ichNewMaxSel = ECAdjustIch( ped, pText, ichNewMaxSel );
        ECUnlock(ped);
    }

    /*
     * Preserve the Old selection
     */
    ichOldMinSel = ped->ichMinSel;
    ichOldMaxSel = ped->ichMaxSel;

    /*
     * Set new selection
     */
    ped->ichMinSel = ichNewMinSel;
    ped->ichMaxSel = ichNewMaxSel;

    /*
     * We will find the intersection of current selection rectangle with the new
     * selection rectangle. We will then invert the parts of the two rectangles
     * not in the intersection.
     */
    if (_IsWindowVisible(ped->pwnd) && (ped->fFocus || ped->fNoHideSel)) {
        BLOCK Blk[2];
        int   i;
        RECT  rc;

        if (ped->fFocus)
            NtUserHideCaret(ped->hwnd);

        if (ped->pLpkEditCallout) {
            /*
             * The language pack handles display while complex script support present
             */
            PSTR pText;

            ECGetBrush(ped, hdc);   // Give user a chance to manipulate the DC
            pText = ECLock(ped);
            ped->pLpkEditCallout->EditDrawText(ped, hdc, pText, ped->cch, ped->ichMinSel, ped->ichMaxSel, ped->rcFmt.top);
            ECUnlock(ped);
        } else {
            Blk[0].StPos = ichOldMinSel;
            Blk[0].EndPos = ichOldMaxSel;
            Blk[1].StPos = ped->ichMinSel;
            Blk[1].EndPos = ped->ichMaxSel;

            if (ECCalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel,
                (LPBLOCK)&Blk[0], (LPBLOCK)&Blk[1])) {

                //
                // Paint the rectangles where selection has changed.
                // Paint both Blk[0] and Blk[1], if they exist.
                //
                for (i = 0; i < 2; i++) {
                    if (Blk[i].StPos != 0xFFFFFFFF) {
                               SLGetClipRect(ped, hdc, Blk[i].StPos,
                                                       Blk[i].EndPos - Blk[i].StPos, (LPRECT)&rc);
                               SLDrawLine(ped, hdc, rc.left, rc.right, Blk[i].StPos,
                                                    Blk[i].EndPos - Blk[i].StPos,
                                          ((Blk[i].StPos >= ped->ichMinSel) &&
                                       (Blk[i].StPos < ped->ichMaxSel)));
                    }
                }
            }
        }

        //
        // Update caret.
        //
        SLSetCaretPosition(ped, hdc);

        if (ped->fFocus)
            NtUserShowCaret(ped->hwnd);
    }
}

/***************************************************************************\
*
*  SLDrawLine()
*
*  This draws the line starting from ichStart, iCount number of characters;
*  fSelStatus is TRUE if we're to draw the text as selected.
*
\***************************************************************************/
void SLDrawLine(
    PED     ped,
    HDC     hdc,
    int     xClipStPos,
    int     xClipEndPos,
    ICH     ichStart,
    int     iCount,
    BOOL    fSelStatus )
{
    RECT    rc;
    RECT    rcClip;
    PSTR    pText;
    DWORD   rgbSaveBk;
    DWORD   rgbSaveText;
    DWORD   wSaveBkMode;
    int     iStCount;
    ICH     ichNewStart;
    HBRUSH  hbrBack;

    if (ped->pLpkEditCallout) {
        RIPMSG0(RIP_WARNING, "SLDrawLine - Error - Invalid call with language pack loaded");
        return;
    }

    //
    // Anything to draw?
    //
    if (xClipStPos >= xClipEndPos || !_IsWindowVisible(ped->pwnd) )
        return;

    if (ped->fAnsi && ped->fDBCS) {
        PSTR pT,pTOrg;
        int iTCount;

        pText = ECLock(ped);
        ichNewStart = 0;
        if (ichStart > 0) {
            pT = pText + ichStart;
            ichNewStart = ichStart;

            while (ichNewStart &&
                  (ichStart - ichNewStart < ped->wMaxNegCcharPos)) {
                pT = ECAnsiPrev(ped, pText, pT);
                ichNewStart = (ICH)(pT - pText);
                if (!ichNewStart)
                    break;
            }

            // B#16152 - win95.
            // In case of T2, SLE always set an additional margin
            // to erase a character (iCount == 0 case), using aveCharWidth.
            // It erases unexpected an extra char if we don't use ichNewStart
            // and it happens when wMaxNegCcharPos == 0.
            //
            if (ped->wMaxNegCcharPos == 0 && iCount == 0) {
                pT = ECAnsiPrev(ped, pText, pT);
                ichNewStart = (ICH)(pT - pText);
            }
        }

        iTCount = 0;
        if (ichStart + iCount < ped->cch) {
            pTOrg = pT = pText + ichStart + iCount;
            while ((iTCount < (int)ped->wMaxNegAcharPos) &&
                   (ichStart + iCount + iTCount < ped->cch)) {
                pT = ECAnsiNext(ped, pT);
                iTCount = (int)(pT - pTOrg);
            }
        }

        ECUnlock(ped);
        iCount = (int)(min(ichStart+iCount+iTCount, ped->cch) - ichNewStart);
    } else {
        // Reset ichStart to take care of the negative C widths
        ichNewStart = max((int)(ichStart - ped->wMaxNegCcharPos), 0);

        // Reset ichCount to take care of the negative C and A widths
        iCount = (int)(min(ichStart+iCount+ped->wMaxNegAcharPos, ped->cch)
                    - ichNewStart);
    }
    ichStart = ichNewStart;

    //
    // Reset ichStart and iCount to the first one visible on the screen
    //
    if (ichStart < ped->ichScreenStart) {
        if (ichStart+iCount < ped->ichScreenStart)
            return;

        iCount -= (ped->ichScreenStart-ichStart);
        ichStart = ped->ichScreenStart;
    }

    CopyRect(&rc, &ped->rcFmt);

    //
    // Set the drawing rectangle
    //
    rcClip.left   = xClipStPos;
    rcClip.right  = xClipEndPos;
    rcClip.top    = rc.top;
    rcClip.bottom = rc.bottom;

    //
    // Set the proper clipping rectangle
    //
    ECSetEditClip(ped, hdc, TRUE);

    pText = ECLock(ped);

    //
    // Calculate the starting pos for this piece of text
    //
    if (ped->format == ES_LEFT) {
        if (iStCount = (int)(ichStart - ped->ichScreenStart)) {
            rc.left += SLCalcXOffsetLeft(ped, hdc, ichStart);
        }
    } else {
        rc.left += SLCalcXOffsetSpecial(ped, hdc, ichStart);
    }

    //
    // Set the background mode before calling NtUserGetControlBrush so that the app
    // can change it to TRANSPARENT if it wants to.
    //
    SetBkMode(hdc, OPAQUE);

    if (fSelStatus) {
        hbrBack = SYSHBR(HIGHLIGHT);
        if (hbrBack == NULL) {
            goto sldl_errorexit;
        }
        rgbSaveBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
        rgbSaveText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

    } else {
        //
        // We always want to send this so that the app has a chance to muck
        // with the DC.
        //
        // Note that ReadOnly and Disabled edit fields are drawn as "static"
        // instead of as "active."
        //
        hbrBack = ECGetBrush(ped, hdc);
        rgbSaveText = GetTextColor(hdc);
    }

    //
    // Erase the rectangular area before text is drawn. Note that we inflate
    // the rect by 1 so that the selection color has a one pixel border around
    // the text.
    //
    InflateRect(&rcClip, 0, 1);
    FillRect(hdc, &rcClip, hbrBack);
    InflateRect(&rcClip, 0, -1);

    if (ped->charPasswordChar) {
        wSaveBkMode = SetBkMode(hdc, TRANSPARENT);

        for (iStCount = 0; iStCount < iCount; iStCount++) {
            if ( ped->fAnsi )
                ExtTextOutA(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                            (LPSTR)&ped->charPasswordChar, 1, NULL);
            else
                ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                            (LPWSTR)&ped->charPasswordChar, 1, NULL);

            rc.left += ped->cPasswordCharWidth;
        }

        SetBkMode(hdc, wSaveBkMode);
    } else {
        if ( ped->fAnsi )
            ExtTextOutA(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                    pText+ichStart,iCount, NULL);
        else
            ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                    ((LPWSTR)pText)+ichStart,iCount, NULL);
    }

    SetTextColor(hdc, rgbSaveText);
    if (fSelStatus) {
        SetBkColor(hdc, rgbSaveBk);
    }

sldl_errorexit:
    ECUnlock(ped);
}

/***************************************************************************\
* SLGetBlkEnd AorW
*
* Given a Starting point and and end point, this function return s whether the
* first few characters fall inside or outside the selection block and if so,
* howmany characters?
*
* History:
\***************************************************************************/

int SLGetBlkEnd(
    PED ped,
    ICH ichStart,
    ICH ichEnd,
    BOOL FAR *lpfStatus)
{
    *lpfStatus = FALSE;
    if (ichStart >= ped->ichMinSel) {
        if (ichStart >= ped->ichMaxSel)
            return (ichEnd - ichStart);
        *lpfStatus = TRUE;
        return (min(ichEnd, ped->ichMaxSel) - ichStart);
    }
    return (min(ichEnd, ped->ichMinSel) - ichStart);
}

/***************************************************************************\
* SLDrawText AorW
*
* Draws text for a single line edit control in the rectangle
* specified by ped->rcFmt. If ichStart == 0, starts drawing text at the left
* side of the window starting at character index ped->ichScreenStart and draws
* as much as will fit. If ichStart > 0, then it appends the characters
* starting at ichStart to the end of the text showing in the window. (ie. We
* are just growing the text length and keeping the left side
* (ped->ichScreenStart to ichStart characters) the same. Assumes the hdc came
* from ECGetEditDC so that the caret and such are properly hidden.
*
* History:
\***************************************************************************/

void SLDrawText(
    PED ped,
    HDC hdc,
    ICH ichStart)
{
    ICH    cchToDraw;
    RECT   rc;
    PSTR   pText;
    BOOL   fSelStatus;
    int    iCount, iStCount;
    ICH    ichEnd;
    BOOL   fNoSelection;
    BOOL   fCalcRect;
    BOOL   fDrawLeftMargin = FALSE;
    BOOL   fDrawEndOfLineStrip = FALSE;
    SIZE   size;

    if (!_IsWindowVisible(ped->pwnd))
        return;

    if (ped->pLpkEditCallout) {
        // The language pack handles display while complex script support present
        ECGetBrush(ped, hdc);   // Give user a chance to manipulate the DC
        pText = ECLock(ped);
        ped->pLpkEditCallout->EditDrawText(ped, hdc, pText, ped->cch, ped->ichMinSel, ped->ichMaxSel, ped->rcFmt.top);
        ECUnlock(ped);
        SLSetCaretPosition(ped, hdc);
        return;
    }

    /*
     * When drawing the entire visible content of special-aligned sle
     * erase the view.
     */
    if (ped->format != ES_LEFT && ichStart == 0)
        FillRect(hdc, &ped->rcFmt, ECGetBrush(ped, hdc));

    pText = ECLock(ped);

    if (ichStart < ped->ichScreenStart) {
#if DBG
        ICH ichCompare = ECAdjustIch(ped, pText, ped->ichScreenStart);
        UserAssert(ichCompare == ped->ichScreenStart);
#endif
        ichStart = ped->ichScreenStart;
    }
    else if (ped->fDBCS && ped->fAnsi) {
        /*
         * If ichStart stays on trailing byte of DBCS, we have to
         * adjust it.
         */
        ichStart = ECAdjustIch(ped, pText, ichStart);
    }

    CopyRect((LPRECT)&rc, (LPRECT)&ped->rcFmt);

    /*
     * Find out how many characters will fit on the screen so that we don't do
     * any needless drawing.
     */
    cchToDraw = ECCchInWidth(ped, hdc,
            (LPSTR)(pText + ped->ichScreenStart * ped->cbChar),
            ped->cch - ped->ichScreenStart, rc.right - rc.left, TRUE);
    ichEnd = ped->ichScreenStart + cchToDraw;

    /*
     * There is no selection if,
     * 1. MinSel and MaxSel are equal OR
     * 2. (This has lost the focus AND Selection is to be hidden)
     */
    fNoSelection = ((ped->ichMinSel == ped->ichMaxSel) || (!ped->fFocus && !ped->fNoHideSel));

    if (ped->format == ES_LEFT) {
        if (iStCount = (int)(ichStart - ped->ichScreenStart)) {
            rc.left += SLCalcXOffsetLeft(ped, hdc, ichStart);
        }
    } else {
        rc.left += SLCalcXOffsetSpecial(ped, hdc, ichStart);
    }

    //
    // If this is the begining of the whole line, we may have to draw a blank
    // strip at the begining.
    //
    if ((ichStart == 0) && ped->wLeftMargin)
        fDrawLeftMargin = TRUE;

    //
    // If there is nothing to draw, that means we need to draw the end of
    // line strip, which erases the last character.
    //
    if (ichStart == ichEnd) {
        fDrawEndOfLineStrip = TRUE;
        rc.left -= ped->wLeftMargin;
    }

    while (ichStart < ichEnd) {
        fCalcRect = TRUE;

        if (fNoSelection) {
            fSelStatus = FALSE;
            iCount = ichEnd - ichStart;
        } else {
            if (fDrawLeftMargin) {
                iCount = 0;
                fSelStatus = FALSE;
                fCalcRect = FALSE;
                rc.right = rc.left;
            } else
                iCount = SLGetBlkEnd(ped, ichStart, ichEnd,
                    (BOOL  *)&fSelStatus);
        }


        if (ichStart+iCount == ichEnd) {
            if (fSelStatus)
                fDrawEndOfLineStrip = TRUE;
            else {
                rc.right = ped->rcFmt.right + ped->wRightMargin;
                fCalcRect = FALSE;
            }
        }

        if (fCalcRect) {
            if (ped->charPasswordChar)
                rc.right = rc.left + ped->cPasswordCharWidth * iCount;
            else {
                if ( ped->fAnsi )
                    GetTextExtentPointA(hdc, pText + ichStart,
                                        iCount, &size);
                else
                    GetTextExtentPointW(hdc, ((LPWSTR)pText) + ichStart,
                                        iCount, &size);
                rc.right = rc.left + size.cx;
                /*
                 * The extent is equal to the advance width. So for TrueType fonts
                 *  we need to take care of Neg A and C. For non TrueType, the extent
                 *  includes the overhang.
                 * If drawing the selection, draw only the advance width
                 */
                if (fSelStatus) {
                    rc.right -= ped->charOverhang;
                } else if (ped->fTrueType) {
                   rc.right += ped->wMaxNegC;
                   if (iStCount > 0) {
                      rc.right += ped->wMaxNegA;
                      iStCount = 0;
                   }
                }

            } /* if (ped->charPasswordChar) */

        }

        if (fDrawLeftMargin) {
            fDrawLeftMargin = FALSE;
            rc.left -= ped->wLeftMargin;
            if (rc.right < rc.left) {
                rc.right = rc.left;
            }
        }

        SLDrawLine(ped, hdc, rc.left, rc.right, ichStart, iCount, fSelStatus);
        ichStart += iCount;
        rc.left = rc.right;
        /*
         * If we're going to draw the selection, adjust rc.left
         * to include advance width of the selected text
         * For non TT fonts, ped->wMaxNegC equals ped->charOverhang
         */
        if (!fSelStatus && (iCount != 0) && (ichStart < ichEnd)) {
            rc.left -= ped->wMaxNegC;
        }
    }

    ECUnlock(ped);

    // Check if anything to be erased on the right hand side
    if (fDrawEndOfLineStrip &&
            (rc.left < (rc.right = (ped->rcFmt.right+ped->wRightMargin)))) {
        SLDrawLine(ped, hdc, rc.left, rc.right, ichStart, 0, 
            (ichEnd < ped->ichMaxSel) ? TRUE : FALSE);
    }

    SLSetCaretPosition(ped, hdc);
}

/***************************************************************************\
* SLScrollText AorW
*
* Scrolls the text to bring the caret into view. If the text is
* scrolled, the current selection is unhighlighted. Returns TRUE if the text
* is scrolled else return s false.
*
* History:
\***************************************************************************/

BOOL SLScrollText(
    PED ped,
    HDC hdc)
{
    PSTR pTextScreenStart;
    ICH scrollAmount;
    ICH newScreenStartX = ped->ichScreenStart;
    ICH cch;
    BOOLEAN fAdjustNext = FALSE;

    if (!ped->fAutoHScroll)
        return (FALSE);

    if (ped->pLpkEditCallout) {
        BOOL fChanged;

        // With complex script glyph reordering, use lpk to do horz scroll
        pTextScreenStart = ECLock(ped);
        fChanged = ped->pLpkEditCallout->EditHScroll(ped, hdc, pTextScreenStart);
        ECUnlock(ped);

        if (fChanged) {
            SLDrawText(ped, hdc, 0);
        }

        return fChanged;
    }

    /*
     * Calculate the new starting screen position
     */
    if (ped->ichCaret <= ped->ichScreenStart) {

        /*
         * Caret is to the left of the starting text on the screen we must
         * scroll the text backwards to bring it into view. Watch out when
         * subtracting unsigned numbers when we have the possibility of going
         * negative.
         */
        pTextScreenStart = ECLock(ped);

        scrollAmount = ECCchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                ped->ichCaret, (ped->rcFmt.right - ped->rcFmt.left) / 4, FALSE);

        newScreenStartX = ped->ichCaret - scrollAmount;
        ECUnlock(ped);
    } else if (ped->ichCaret != ped->ichScreenStart) {
        pTextScreenStart = ECLock(ped);
        pTextScreenStart += ped->ichScreenStart * ped->cbChar;

        cch = ECCchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                ped->ichCaret - ped->ichScreenStart,
                ped->rcFmt.right - ped->rcFmt.left, FALSE);

        if (cch < ped->ichCaret - ped->ichScreenStart) {
            fAdjustNext = TRUE;

            /*
             * Scroll Forward 1/4 -- if that leaves some empty space
             * at the end, scroll back enough to fill the space
             */
            newScreenStartX = ped->ichCaret - (3 * cch / 4);

            cch = ECCchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                    ped->cch - ped->ichScreenStart,
                    ped->rcFmt.right - ped->rcFmt.left, FALSE);

            if (newScreenStartX > (ped->cch - cch))
                newScreenStartX = ped->cch - cch;
        } else if (ped->format != ES_LEFT) {

            cch = ECCchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                    ped->cch - ped->ichScreenStart,
                    ped->rcFmt.right - ped->rcFmt.left, FALSE);

           /*
            * Scroll the text hidden behind the left border back
            * into view.
            */
           if (ped->ichScreenStart == ped->cch - cch) {

               pTextScreenStart -= ped->ichScreenStart * ped->cbChar;
               cch = ECCchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                       ped->cch, ped->rcFmt.right - ped->rcFmt.left, FALSE);

               newScreenStartX = ped->cch - cch;
           }
        }

        ECUnlock(ped);
    }

    //
    // Adjust newScreenStartX
    //
    if (ped->fAnsi && ped->fDBCS) {
        newScreenStartX = (fAdjustNext ? ECAdjustIchNext : ECAdjustIch)(ped,
                                                                        ECLock(ped),
                                                                        newScreenStartX);
        ECUnlock(ped);
    }

    if (ped->ichScreenStart != newScreenStartX) {
        // Check if we have to wipe out the left margin
        if (ped->wLeftMargin && (ped->ichScreenStart == 0)) {
            RECT   rc;
            HBRUSH hBrush;

            hBrush = ECGetBrush(ped, hdc);

            CopyInflateRect(&rc, &ped->rcFmt, 0, 1);
            rc.right = rc.left;
            rc.left -= ped->wLeftMargin;

            FillRect(hdc, &rc, hBrush);
        }

        ped->ichScreenStart = newScreenStartX;
        SLDrawText(ped, hdc, 0);

        // Caret pos is set by SLDrawText().
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* SLInsertText AorW
*
* Adds up to cchInsert characters from lpText to the ped starting at
* ichCaret. If the ped only allows a maximum number of characters, then we
* will only add that many characters to the ped and send a EN_MAXTEXT
* notification code to the parent of the ec. Also, if !fAutoHScroll, then we
* only allow as many chars as will fit in the client rectangle. The number of
* characters actually added is return ed (could be 0). If we can't allocate
* the required space, we notify the parent with EN_ERRSPACE and no characters
* are added.
*
* History:
\***************************************************************************/

ICH SLInsertText(
    PED ped,
    LPSTR lpText,
    ICH cchInsert)
{
    HDC hdc;
    PSTR pText;
    ICH cchInsertCopy = cchInsert;
    ICH cchT;
    int textWidth;
    SIZE size;

    /*
     * First determine exactly how many characters from lpText we can insert
     * into the ped.
     */
    if( ped->cchTextMax <= ped->cch)
       cchInsert = 0;
    else {
        if (!ped->fAutoHScroll) {
            pText = ECLock(ped);
            hdc = ECGetEditDC(ped, TRUE);

            cchInsert = min(cchInsert, (unsigned)(ped->cchTextMax - ped->cch));
            if (ped->charPasswordChar)
                textWidth = ped->cch * ped->cPasswordCharWidth;
            else {
                if (ped->fAnsi)
                    GetTextExtentPointA(hdc, (LPSTR)pText,  ped->cch, &size);
                else
                    GetTextExtentPointW(hdc, (LPWSTR)pText, ped->cch, &size);
                textWidth = size.cx;
            }
            cchT = ECCchInWidth(ped, hdc, lpText, cchInsert,
                                ped->rcFmt.right - ped->rcFmt.left -
                                textWidth, TRUE);
            cchInsert = min(cchInsert, cchT);

            ECUnlock(ped);
            ECReleaseEditDC(ped, hdc, TRUE);
        } else {
            cchInsert = min((unsigned)(ped->cchTextMax - ped->cch), cchInsert);
        }
    }


    /*
     * Now try actually adding the text to the ped
     */
    if (cchInsert && !ECInsertText(ped, lpText, &cchInsert)) {
        ECNotifyParent(ped, EN_ERRSPACE);
        return (0);
    }
    if (cchInsert)
        ped->fDirty = TRUE; /* Set modify flag */

    if (cchInsert < cchInsertCopy) {

        /*
         * Notify parent that we couldn't insert all the text requested
         */
        ECNotifyParent(ped, EN_MAXTEXT);
    }

    /*
     * Update selection extents and the caret position. Note that ECInsertText
     * updates ped->ichCaret, ped->ichMinSel, and ped->ichMaxSel to all be after
     * the inserted text.
     */
    return (cchInsert);
}

/***************************************************************************\
* SLPasteText AorW
*
* Pastes a line of text from the clipboard into the edit control
* starting at ped->ichMaxSel. Updates ichMaxSel and ichMinSel to point to
* the end of the inserted text. Notifies the parent if space cannot be
* allocated. Returns how many characters were inserted.
*
* History:
\***************************************************************************/

ICH PASCAL NEAR SLPasteText(
    PED ped)
{
    HANDLE hData;
    LPSTR lpchClip;
    ICH cchAdded = 0;
    ICH clipLength;

    if (!OpenClipboard(ped->hwnd))
        goto PasteExitNoCloseClip;

    if (!(hData = GetClipboardData(ped->fAnsi ? CF_TEXT : CF_UNICODETEXT)) ||
            (GlobalFlags(hData) == GMEM_INVALID_HANDLE)) {
        RIPMSG1(RIP_WARNING, "SLPasteText(): couldn't get a valid handle(%x)", hData);
        goto PasteExit;
    }

    USERGLOBALLOCK(hData, lpchClip);
    if (lpchClip == NULL) {
        RIPMSG1(RIP_WARNING, "SLPasteText(): USERGLOBALLOCK(%x) failed.", hData);
        goto PasteExit;
    }

    if (ped->fAnsi) {
        LPSTR lpchClip2 = lpchClip;

        /*
         * Find the first carrage return or line feed. Just add text to that point.
         */
        clipLength = (UINT)strlen(lpchClip);
        for (cchAdded = 0; cchAdded < clipLength; cchAdded++)
            if (*lpchClip2++ == 0x0D)
                break;

    } else { // !fAnsi
        LPWSTR lpwstrClip2 = (LPWSTR)lpchClip;

        /*
         * Find the first carrage return or line feed. Just add text to that point.
         */
        clipLength = (UINT)wcslen((LPWSTR)lpchClip);
        for (cchAdded = 0; cchAdded < clipLength; cchAdded++)
            if (*lpwstrClip2++ == 0x0D)
                break;
    }

    /*
     * Insert the text (SLInsertText checks line length)
     */
    cchAdded = SLInsertText(ped, lpchClip, cchAdded);

    USERGLOBALUNLOCK(hData);

PasteExit:
    NtUserCloseClipboard();

PasteExitNoCloseClip:
    return (cchAdded);
}

/***************************************************************************\
* SLReplaceSel AorW
*
* Replaces the text in the current selection with the given text.
*
* History:
\***************************************************************************/

void SLReplaceSel(
    PED ped,
    LPSTR lpText)
{
    UINT cchText;

    //
    // Delete text, putting it into the clean undo buffer.
    //
    ECEmptyUndo(Pundo(ped));
    ECDeleteText(ped);

    //
    // B#3356
    // Some apps do "clear" by selecting all of the text, then replacing it
    // with "", in which case SLInsertText() will return 0.  But that
    // doesn't mean failure...
    //
    if ( ped->fAnsi )
        cchText = strlen(lpText);
    else
        cchText = wcslen((LPWSTR)lpText);

    if (cchText) {
        BOOL fFailed;
        UNDO undo;
        HWND hwndSave;

        //
        // Save undo buffer, but DO NOT CLEAR IT!
        //
        ECSaveUndo(Pundo(ped), &undo, FALSE);

        hwndSave = ped->hwnd;
        fFailed = (BOOL) !SLInsertText(ped, lpText, cchText);
        if (!IsWindow(hwndSave))
            return;

        if (fFailed) {
            //
            // UNDO the previous edit.
            //
            ECSaveUndo(&undo, Pundo(ped), FALSE);
            SLUndo(ped);
            return;
        }
    }

    //
    // Success.  So update the display
    //
    ECNotifyParent(ped, EN_UPDATE);

    if (_IsWindowVisible(ped->pwnd)) {
        HDC hdc;

        hdc = ECGetEditDC(ped, FALSE);

        if (!SLScrollText(ped, hdc))
            SLDrawText(ped, hdc, 0);

        ECReleaseEditDC(ped, hdc, FALSE);
    }

    ECNotifyParent(ped, EN_CHANGE);

    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
}

/***************************************************************************\
* SLChar AorW
*
* Handles character input
*
* History:
\***************************************************************************/

void SLChar(
    PED ped,
    DWORD keyValue)
{
    HDC hdc;
    WCHAR keyPress;
    BOOL updateText = FALSE;
    HWND hwndSave = ped->hwnd;
    int InsertTextLen = 1;
    int DBCSkey;

    if (ped->fAnsi)
        keyPress = LOBYTE(keyValue);
    else
        keyPress = LOWORD(keyValue);

    if (ped->fMouseDown || (ped->fReadOnly && keyPress != 3)) {

        /*
         * Don't do anything if we are in the middle of a mousedown deal or if
         * this is a read only edit control, with exception of allowing
         * ctrl-C in order to copy to the clipboard.
         */
        return ;
    }

    if (IS_IME_ENABLED()) {
        ECInOutReconversionMode(ped, FALSE);
    }

    switch (keyPress) {
    case VK_BACK:
DeleteSelection:
        if (ECDeleteText(ped))
            updateText = TRUE;
        break;

    default:
        if (keyPress >= TEXT(' '))
        {
            /*
             * If this is in [a-z],[A-Z] and we are an ES_NUMBER
             * edit field, bail.
             */
            if (ped->f40Compat && TestWF(ped->pwnd, EFNUMBER)) {
                if (!ECIsCharNumeric(ped, keyPress)) {
                    goto IllegalChar;
                }
            }
            goto DeleteSelection;
        }
        break;
    }

    switch (keyPress) {
    case 3:

        /*
         * CTRL-C Copy
         */
        SendMessage(ped->hwnd, WM_COPY, 0, 0L);
        return;

    case VK_BACK:

        /*
         * Delete any selected text or delete character left if no sel
         */
        if (!updateText && ped->ichMinSel) {

            /*
             * There was no selection to delete so we just delete character
               left if available
             */
            //
            // Calling PrevIch rather than just doing a decrement for VK_BACK
            //
            ped->ichMinSel = ECPrevIch( ped, NULL, ped->ichMinSel);
            ECDeleteText(ped);
            updateText = TRUE;
        }
        break;

    case 22: /* CTRL-V Paste */
        SendMessage(ped->hwnd, WM_PASTE, 0, 0L);
        return;

    case 24: /* CTRL-X Cut */
        if (ped->ichMinSel == ped->ichMaxSel)
            goto IllegalChar;

        SendMessage(ped->hwnd, WM_CUT, 0, 0L);
        return;

    case 26: /* CTRL-Z Undo */
        SendMessage(ped->hwnd, EM_UNDO, 0, 0L);
        return;

    case VK_RETURN:
    case VK_ESCAPE:
        //
        // If this is an edit control for a combobox and the dropdown list
        // is visible, forward it up to the combo.
        //
        if (ped->listboxHwnd && SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L)) {
            SendMessage(ped->hwndParent, WM_KEYDOWN, (WPARAM)keyPress, 0L);
        } else
            goto IllegalChar;
        return;

    default:
        if (keyPress >= 0x1E) {  // 1E,1F are unicode block and segment separators
            /*
             * Hide the cursor if typing, if the mouse is captured, do not mess with this
             * as it is going to desapear forever (no WM_SETCURSOR is sent to restore it
             * at the first mouse-move)
             * MCostea #166951
             */
            NtUserCallNoParam(SFI_ZZZHIDECURSORNOCAPTURE);

            if (IS_DBCS_ENABLED() && ped->fAnsi && (ECIsDBCSLeadByte(ped,(BYTE)keyPress))) {
                if ((DBCSkey = DbcsCombine(ped->hwnd, keyPress)) != 0 &&
                     SLInsertText(ped,(LPSTR)&DBCSkey, 2) == 2) {
                    InsertTextLen = 2;
                    updateText = TRUE;
                } else {
                    NtUserMessageBeep(0);
                }
            } else {  // Here the original code begins
                InsertTextLen = 1;
                if (SLInsertText(ped, (LPSTR)&keyPress, 1))
                    updateText = TRUE;
                else

                    /*
                     * Beep. Since we couldn't add the text
                     */
                    NtUserMessageBeep(0);
            } // Here the original code ends
        } else {

            /*
             * User hit an illegal control key
             */
IllegalChar:
            NtUserMessageBeep(0);
        }

        if (!IsWindow(hwndSave))
            return;
        break;
    }

    if (updateText) {

        /*
         * Dirty flag (ped->fDirty) was set when we inserted text
         */
        ECNotifyParent(ped, EN_UPDATE);
        hdc = ECGetEditDC(ped, FALSE);
        if (!SLScrollText(ped, hdc)) {
            if (ped->format == ES_LEFT) {
            //
            // Call SLDrawText with correct ichStart
            //
                SLDrawText(ped, hdc, max(0, (int)(ped->ichCaret - InsertTextLen - ped->wMaxNegCcharPos)));
            } else {
                /*
                 * We can't just draw from ichStart because string may have
                 * shifted because of alignment.
                 */
                SLDrawText(ped, hdc, 0);
            }
        }
        ECReleaseEditDC(ped, hdc, FALSE);
        ECNotifyParent(ped, EN_CHANGE);

        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }
}

/***************************************************************************\
* SLMoveSelectionRestricted AorW
*
* Moves the selection like MLMoveSelection, but also obeys limitations
* imposed by some languages such as Thai, where the cursor cannot stop
* between a character and it's attached vowel or tone marks.
*
* Only called if the language pack is loaded.
*
\***************************************************************************/

ICH SLMoveSelectionRestricted(
    PED  ped,
    ICH  ich,
    BOOL fLeft)
{
    PSTR pText;
    HDC  hdc;
    ICH  ichResult;

    pText = ECLock(ped);
    hdc = ECGetEditDC(ped, TRUE);
    ichResult = ped->pLpkEditCallout->EditMoveSelection(ped, hdc, pText, ich, fLeft);
    ECReleaseEditDC(ped, hdc, TRUE);
    ECUnlock(ped);

    return ichResult;
}

/***************************************************************************\
* SLKeyDown AorW
*
* Handles cursor movement and other VIRT KEY stuff. keyMods allows
* us to make SLKeyDownHandler calls and specify if the modifier keys (shift
* and control) are up or down. This is useful for imnplementing the
* cut/paste/clear messages for single line edit controls. If keyMods == 0,
* we get the keyboard state using GetKeyState(VK_SHIFT) etc. Otherwise, the
* bits in keyMods define the state of the shift and control keys.
*
* History:
\***************************************************************************/

void SLKeyDown(
    PED ped,
    DWORD virtKeyCode,
    int keyMods)
{
    HDC hdc;

    /*
     * Variables we will use for redrawing the updated text
     */
    ICH newMaxSel = ped->ichMaxSel;
    ICH newMinSel = ped->ichMinSel;

    /*
     * Flags for drawing the updated text
     */
    BOOL updateText = FALSE;
    BOOL changeSelection = FALSE; /* new selection is specified by
                                      newMinSel, newMaxSel */

    /*
     * Comparisons we do often
     */
    BOOL MinEqMax = (newMaxSel == newMinSel);
    BOOL MinEqCar = (ped->ichCaret == newMinSel);
    BOOL MaxEqCar = (ped->ichCaret == newMaxSel);

    /*
     * State of shift and control keys.
     */
    int scState;

    /*
     * Combo box support
     */
    BOOL fIsListVisible;
    BOOL fIsExtendedUI;

    if (ped->fMouseDown) {

        /*
         * If we are in the middle of a mouse down handler, then don't do
         * anything. ie. ignore keyboard input.
         */
        return;
    }

    scState = ECGetModKeys(keyMods);

    switch (virtKeyCode) {
    case VK_UP:
        if ( ped->listboxHwnd ) {

            /*
             * Handle Combobox support
             */
            fIsExtendedUI = (BOOL)SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0);
            fIsListVisible = (BOOL)SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0);

            if (!fIsListVisible && fIsExtendedUI) {

                /*
                 * For TandyT
                 */
DropExtendedUIListBox:

                /*
                 * Since an extendedui combo box doesn't do anything on f4, we
                 * turn off the extended ui, send the f4 to drop, and turn it
                 * back on again.
                 */
                SendMessage(ped->hwndParent, CB_SETEXTENDEDUI, 0, 0);
                SendMessage(ped->listboxHwnd, WM_KEYDOWN, VK_F4, 0);
                SendMessage(ped->hwndParent, CB_SETEXTENDEDUI, 1, 0);
                return;
            } else
                goto SendKeyToListBox;
        }

    /*
     * else fall through
     */
    case VK_LEFT:
        //
        // If the caret isn't at the beginning, we can move left
        //
        if (ped->ichCaret) {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) {
                // Move caret word left
                ECWord(ped, ped->ichCaret, TRUE, &ped->ichCaret, NULL);
            } else {
                // Move caret char left
                if (ped->pLpkEditCallout) {
                    ped->ichCaret = SLMoveSelectionRestricted(ped, ped->ichCaret, TRUE);
                } else
                ped->ichCaret = ECPrevIch(ped,NULL,ped->ichCaret);
            }

            //
            // Get new selection
            //
            if (scState & SHFTDOWN) {
                if (MaxEqCar && !MinEqMax) {
                    // Reduce selection
                    newMaxSel = ped->ichCaret;

                    UserAssert(newMinSel == ped->ichMinSel);
                } else {
                    // Extend selection
                    newMinSel = ped->ichCaret;
                }
            } else {
                //
                // Clear selection
                //
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } else {
            //
            // If the user tries to move left and we are at the 0th
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) {
                changeSelection = TRUE;
                newMaxSel = newMinSel = ped->ichCaret;
            }
        }
        break;

    case VK_DOWN:
        if (ped->listboxHwnd) {

            /*
             * Handle Combobox support
             */
            fIsExtendedUI = (BOOL)SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0);
            fIsListVisible = (BOOL)SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0);

            if (!fIsListVisible && fIsExtendedUI) {

                /*
                 * For TandyT
                 */
                goto DropExtendedUIListBox;
            } else
                goto SendKeyToListBox;
        }

    /*
     * else fall through
     */
    case VK_RIGHT:
        //
        // If the caret isn't at the end, we can move right.
        //
        if (ped->ichCaret < ped->cch) {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) {
                // Move caret word right
                ECWord(ped, ped->ichCaret, FALSE, NULL, &ped->ichCaret);
            } else {
                // Move caret char right
                if (ped->pLpkEditCallout) {
                    ped->ichCaret = SLMoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } else
                ped->ichCaret = ECNextIch(ped,NULL,ped->ichCaret);
            }

            //
            // Get new selection.
            //
            if (scState & SHFTDOWN) {
                if (MinEqCar && !MinEqMax) {
                    // Reduce selection
                    newMinSel = ped->ichCaret;

                    UserAssert(newMaxSel == ped->ichMaxSel);
                } else {
                    // Extend selection
                    newMaxSel = ped->ichCaret;
                }
            } else {
                // Clear selection
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } else {
            //
            // If the user tries to move right and we are at the last
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) {
                newMaxSel = newMinSel = ped->ichCaret;
                changeSelection = TRUE;
            }
        }
        break;

    case VK_HOME:
        //
        // Move caret to top.
        //
        ped->ichCaret = 0;

        //
        // Update selection.
        //
        if (scState & SHFTDOWN) {
            if (MaxEqCar && !MinEqMax) {
                // Reduce selection
                newMinSel = ped->ichCaret;
                newMaxSel = ped->ichMinSel;
            } else {
                // Extend selection
                newMinSel = ped->ichCaret;
            }
        } else {
            // Clear selection
            newMaxSel = newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    case VK_END:
        //
        // Move caret to end.
        //
        ped->ichCaret = ped->cch;

        //
        // Update selection.
        //
        newMaxSel = ped->ichCaret;
        if (scState & SHFTDOWN) {
            if (MinEqCar && !MinEqMax) {
                // Reduce selection
                newMinSel = ped->ichMaxSel;
            }
        } else {
            // Clear selection
            newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    case VK_DELETE:
        if (ped->fReadOnly)
            break;

        switch (scState) {
        case NONEDOWN:

            /*
             * Clear selection. If no selection, delete (clear) character
             * right.
             */
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) {

                /*
                 * Move cursor forwards and simulate a backspace.
                 */
                if (ped->pLpkEditCallout) {
                    ped->ichMinSel = ped->ichCaret;
                    ped->ichMaxSel = ped->ichCaret = SLMoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } else {
                    ped->ichCaret = ECNextIch(ped,NULL,ped->ichCaret);
                    ped->ichMaxSel = ped->ichMinSel = ped->ichCaret;
                }
                SLChar(ped, (UINT)VK_BACK);
            }
            if (ped->ichMinSel != ped->ichMaxSel)
                SLChar(ped, (UINT)VK_BACK);
            break;

        case SHFTDOWN:

            //
            // Send ourself a WM_CUT message if a selection exists.
            // Otherwise, delete the left character.
            //
            if (ped->ichMinSel == ped->ichMaxSel) {
                UserAssert(!ped->fEatNextChar);
                SLChar(ped, VK_BACK);
            } else
                SendMessage(ped->hwnd, WM_CUT, 0, 0L);

            break;

        case CTRLDOWN:

            /*
             * Delete to end of line if no selection else delete (clear)
             * selection.
             */
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) {

                /*
                 * Move cursor to end of line and simulate a backspace.
                 */
                ped->ichMaxSel = ped->ichCaret = ped->cch;
            }
            if (ped->ichMinSel != ped->ichMaxSel)
                SLChar(ped, (UINT)VK_BACK);
            break;

        }

        /*
         * No need to update text or selection since BACKSPACE message does it
         * for us.
         */
        break;

    case VK_INSERT:
        switch (scState) {
        case CTRLDOWN:

            /*
             * Copy current selection to clipboard
             */
            SendMessage(ped->hwnd, WM_COPY, 0, 0);
            break;

        case SHFTDOWN:
            SendMessage(ped->hwnd, WM_PASTE, 0, 0L);
            break;
        }
        break;

    // VK_HANJA support
    case VK_HANJA:
        if ( HanjaKeyHandler( ped ) ) {
            changeSelection = TRUE;
            newMinSel = ped->ichCaret;
            newMaxSel = ped->ichCaret + (ped->fAnsi ? 2 : 1);
        }
        break;

    case VK_F4:
    case VK_PRIOR:
    case VK_NEXT:

        /*
         * Send keys to the listbox if we are a part of a combo box. This
         * assumes the listbox ignores keyup messages which is correct right
         * now.
         */
SendKeyToListBox:
        if (ped->listboxHwnd) {

            /*
             * Handle Combobox support
             */
            SendMessage(ped->listboxHwnd, WM_KEYDOWN, virtKeyCode, 0L);
            return;
        }
    }

    if (changeSelection || updateText) {
        hdc = ECGetEditDC(ped, FALSE);

        /*
         * Scroll if needed
         */
        SLScrollText(ped, hdc);

        if (changeSelection)
            SLChangeSelection(ped, hdc, newMinSel, newMaxSel);

        if (updateText)
            SLDrawText(ped, hdc, 0);

        ECReleaseEditDC(ped, hdc, FALSE);
        if (updateText) {
            ECNotifyParent(ped, EN_CHANGE);
            NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        }
    }
}

/***************************************************************************\
* SLMouseToIch AorW
*
* Returns the closest cch to where the mouse point is.
*
* History:
\***************************************************************************/

ICH SLMouseToIch(
    PED ped,
    HDC hdc,
    LPPOINT mousePt)
{
    PSTR pText;
    int width = mousePt->x;
    int lastHighWidth, lastLowWidth;
    SIZE size;
    ICH cch;
    ICH cchLo, cchHi;
    LPSTR lpText;
    FnGetTextExtentPoint pGetTextExtentPoint;

    if (ped->pLpkEditCallout) {
        pText = ECLock(ped);
        cch = ped->pLpkEditCallout->EditMouseToIch(ped, hdc, pText, ped->cch, width);
        ECUnlock(ped);
        return cch;
    }

    if (width <= ped->rcFmt.left) {

        /*
         * Return either the first non visible character or return 0 if at
         * beginning of text
         */
        if (ped->ichScreenStart) {
            cch = ECAdjustIch(ped, ECLock(ped), ped->ichScreenStart - 1);
            ECUnlock(ped);
            return cch;
        }
        else {
            return 0;
        }
    }

    if (width > ped->rcFmt.right) {
        pText = ECLock(ped);

        /*
         * Return last char in text or one plus the last char visible
         */
        cch = ECCchInWidth(ped, hdc,
                (LPSTR)(pText + ped->ichScreenStart * ped->cbChar),
                ped->cch - ped->ichScreenStart, ped->rcFmt.right -
                ped->rcFmt.left, TRUE) + ped->ichScreenStart;

        //
        // This is marked as JAPAN in Win31J. But it should be a DBCS
        // issue. LiZ -- 5/5/93
        // We must check DBCS Lead byte. Because ECAdjustIch() pick up Prev Char.
        //  1993.3.9 by yutakas
        //
        if (ped->fAnsi && ped->fDBCS) {
            if (cch >= ped->cch) {
                cch = ped->cch;
            } else {
                if (ECIsDBCSLeadByte(ped,*(pText+cch))) {
                    cch += 2;
                } else {
                    cch ++;
                }
            }
            ECUnlock(ped);
            return cch;
        } else {
            ECUnlock(ped);
            if (cch >= ped->cch)
                return (ped->cch);
            else
                return (cch + 1);
        }
    }

    if (ped->format != ES_LEFT) {
        width -= SLCalcXOffsetSpecial(ped, hdc, ped->ichScreenStart);
    }

    /*
     * Check if password hidden chars are being used.
     */
    if (ped->charPasswordChar)
        return min( (DWORD)( (width - ped->rcFmt.left) / ped->cPasswordCharWidth),
                    ped->cch);

    if (!ped->cch)
        return (0);

    pText = ECLock(ped);
    lpText = pText + ped->ichScreenStart * ped->cbChar;

    pGetTextExtentPoint = ped->fAnsi ? (FnGetTextExtentPoint)GetTextExtentPointA
                                     : (FnGetTextExtentPoint)GetTextExtentPointW;
    width -= ped->rcFmt.left;

    /*
     * If the user clicked past the end of the text, return the last character
     */
    cchHi = ped->cch - ped->ichScreenStart;
    pGetTextExtentPoint(hdc, lpText, cchHi, &size);
    if (size.cx <= width) {
        cch = cchHi;
        goto edAdjust;
    }
    /*
     * Initialize Binary Search Bounds
     */
    cchLo = 0;
    cchHi ++;
    lastLowWidth = 0;
    lastHighWidth = size.cx;

    /*
     * Binary search for closest char
     */
    while (cchLo < cchHi - 1) {

        cch = (cchHi + cchLo) / 2;
        pGetTextExtentPoint(hdc, lpText, cch, &size);

        if (size.cx <= width) {
            cchLo = cch;
            lastLowWidth = size.cx;
        } else {
            cchHi = cch;
            lastHighWidth = size.cx;
        }
    }

    /*
     * When the while ends, you can't know the exact position.
     * Try to see if the mouse pointer was on the farest half
     * of the char we got and if so, adjust cch.
     */
    if (cchLo == cch) {
        /*
         * Need to compare with lastHighWidth
         */
        if ((lastHighWidth - width) < (width - size.cx)) {
            cch++;
        }
    } else {
        /*
         * Need to compare with lastLowWidth
         */
        if ((width - lastLowWidth) < (size.cx - width)) {
            cch--;
        }
    }

edAdjust:
    //
    // Avoid to point the intermediate of double byte character
    //
    cch = ECAdjustIch( ped, pText, cch + ped->ichScreenStart );
    ECUnlock(ped);
    return ( cch );
}

/***************************************************************************\
* SLMouseMotion AorW
*
* <brief description>
*
* History:
\***************************************************************************/

void SLMouseMotion(
    PED ped,
    UINT message,
    UINT virtKeyDown,
    LPPOINT mousePt)
{
    DWORD   selectionl;
    DWORD   selectionh;
    BOOL    changeSelection;
    ICH     newMaxSel;
    ICH     newMinSel;
    HDC     hdc;
    ICH     mouseIch;
    LPSTR   pText;

    changeSelection = FALSE;

    newMinSel = ped->ichMinSel;
    newMaxSel = ped->ichMaxSel;

    hdc = ECGetEditDC(ped, FALSE);
    mouseIch = SLMouseToIch(ped, hdc, mousePt);

    switch (message) {
        case WM_LBUTTONDBLCLK:

            // if shift key is down, extend selection to word we double clicked on
            // else clear current selection and select word.

            // in DBCS, we have different word breaking. LiZ -- 5/5/93
            // In Hangeul Environment we use word selection feature because Hangeul
            // use SPACE as word break
            if (ped->fAnsi && ped->fDBCS) {
                pText = ECLock(ped) + mouseIch;
                ECWord(ped, mouseIch,
                       (ECIsDBCSLeadByte(ped,*pText) && mouseIch < ped->cch) ? FALSE : TRUE,
                       &selectionl, &selectionh);
                ECUnlock(ped);
            } else {
                ECWord(ped, mouseIch, (mouseIch) ? TRUE : FALSE, &selectionl, &selectionh);
            }

            if (!(virtKeyDown & MK_SHIFT)) {
                // If shift key isn't down, move caret to mouse point and clear
                // old selection
                newMinSel = selectionl;
                newMaxSel = ped->ichCaret = selectionh;
            } else {
                // Shiftkey is down so we want to maintain the current selection
                // (if any) and just extend or reduce it
                if (ped->ichMinSel == ped->ichCaret) {
                    newMinSel = ped->ichCaret = selectionl;
                    ECWord(ped, newMaxSel, TRUE, &selectionl, &selectionh);
                } else {
                    newMaxSel = ped->ichCaret = selectionh;
                    ECWord(ped, newMinSel, FALSE, &selectionl, &selectionh);
                }
                /*
                 * v-ronaar: fix bug 24627 - edit selection is weird.
                 */
                ped->ichMaxSel = ped->ichCaret;
            }

            ped->ichStartMinSel = selectionl;
            ped->ichStartMaxSel = selectionh;

            goto InitDragSelect;

        case WM_MOUSEMOVE:
            //
            // We know the mouse button's down -- otherwise the OPTIMIZE
            // test would've failed in SLEditWndProc and never called
            //
            changeSelection = TRUE;

            // Extend selection, move caret word right
            if (ped->ichStartMinSel || ped->ichStartMaxSel) {
                // We're in WORD SELECT mode
                BOOL fReverse = (mouseIch <= ped->ichStartMinSel);

                ECWord(ped, mouseIch, !fReverse, &selectionl, &selectionh);

                if (fReverse) {
                    newMinSel = ped->ichCaret = selectionl;
                    newMaxSel = ped->ichStartMaxSel;
                } else {
                    newMinSel = ped->ichStartMinSel;
                    newMaxSel = ped->ichCaret = selectionh;
                }
            } else if ((ped->ichMinSel == ped->ichCaret) &&
                (ped->ichMinSel != ped->ichMaxSel))
                // Reduce selection extent
                newMinSel = ped->ichCaret = mouseIch;
            else
                // Extend selection extent
                newMaxSel = ped->ichCaret=mouseIch;
            break;

        case WM_LBUTTONDOWN:
            // If we currently don't have the focus yet, try to get it.
            if (!ped->fFocus) {
                if (!ped->fNoHideSel)
                    // Clear the selection before setting the focus so that we
                    // don't get refresh problems and flicker. Doesn't matter
                    // since the mouse down will end up changing it anyway.
                    ped->ichMinSel = ped->ichMaxSel = ped->ichCaret;

                NtUserSetFocus(ped->hwnd);

                //
                // BOGUS
                // (1) We should see if SetFocus() succeeds.
                // (2) We should ignore mouse messages if the first window
                //      ancestor with a caption isn't "active."
                //

                // If we are part of a combo box, then this is the first time
                // the edit control is getting the focus so we just want to
                // highlight the selection and we don't really want to position
                // the caret.
                if (ped->listboxHwnd)
                    break;

                // We yield at SetFocus -- text might have changed at that point
                // update selection and caret info accordingly
                // FIX for bug # 11743 -- JEFFBOG 8/23/91
                newMaxSel = ped->ichMaxSel;
                newMinSel = ped->ichMinSel;
                mouseIch  = min(mouseIch, ped->cch);
            }

            if (ped->fFocus) {
                // Only do this if we have the focus since a clever app may not
                // want to give us the focus at the SetFocus call above.
                if (!(virtKeyDown & MK_SHIFT)) {
                    // If shift key isn't down, move caret to mouse point and
                    // clear old selection
                    newMinSel = newMaxSel = ped->ichCaret = mouseIch;
                } else {
                    // Shiftkey is down so we want to maintain the current
                    // selection (if any) and just extend or reduce it
                    if (ped->ichMinSel == ped->ichCaret)
                        newMinSel = ped->ichCaret = mouseIch;
                    else
                        newMaxSel = ped->ichCaret = mouseIch;
                }

                ped->ichStartMinSel = ped->ichStartMaxSel = 0;

InitDragSelect:
                ped->fMouseDown = FALSE;
                NtUserSetCapture(ped->hwnd);
                ped->fMouseDown = TRUE;
                changeSelection = TRUE;
            }
            break;

        case WM_LBUTTONUP:
            if (ped->fMouseDown) {
                ped->fMouseDown = FALSE;
                NtUserReleaseCapture();
            }
            break;
    }

    if (changeSelection) {
        SLScrollText(ped,hdc);
        SLChangeSelection(ped, hdc, newMinSel, newMaxSel);
    }

    ECReleaseEditDC(ped, hdc, FALSE);
}

/***************************************************************************\
* SLPaint AorW
*
* Handles painting of the edit control window. Draws the border if
* necessary and draws the text in its current state.
*
* History:
\***************************************************************************/

void SLPaint(
    PED ped,
    HDC hdc)
{
    HWND   hwnd = ped->hwnd;
    HBRUSH hBrushRemote;
    RECT   rcEdit;
    HANDLE hOldFont;

    /*
     * Had to put in hide/show carets. The first one needs to be done before
     * beginpaint to correctly paint the caret if part is in the update region
     * and part is out. The second is for 1.03 compatibility. It breaks
     * micrografix's worksheet edit control if not there.
     */
    NtUserHideCaret(hwnd);

    if (_IsWindowVisible(ped->pwnd)) {
        /*
         * Erase the background since we don't do it in the erasebkgnd message.
         */
        hBrushRemote = ECGetBrush(ped, hdc);
        _GetClientRect(ped->pwnd, (LPRECT)&rcEdit);
        FillRect(hdc, &rcEdit, hBrushRemote);

        if (ped->fFlatBorder)
        {
            RECT    rcT;

            _GetClientRect(ped->pwnd, &rcT);
            DrawFrame(hdc, &rcT, 1, DF_WINDOWFRAME);
        }

        if (ped->hFont != NULL) {
            /*
             * We have to select in the font since this may be a subclassed dc
             * or a begin paint dc which hasn't been initialized with out fonts
             * like ECGetEditDC does.
             */
            hOldFont = SelectObject(hdc, ped->hFont);
        }

        SLDrawText(ped, hdc, 0);

        if (ped->hFont != NULL && hOldFont != NULL) {
            SelectObject(hdc, hOldFont);
        }
    }

    NtUserShowCaret(hwnd);
}

/***************************************************************************\
* SLSetFocus AorW
*
* Gives the edit control the focus and notifies the parent
* EN_SETFOCUS.
*
* History:
\***************************************************************************/

void SLSetFocus(
    PED ped)
{
    HDC hdc;

    if (!ped->fFocus) {

        ped->fFocus = TRUE; /* Set focus */

        /*
         * We don't want to muck with the caret since it isn't created.
         */
        hdc = ECGetEditDC(ped, TRUE);

        /*
         * Show the current selection if necessary.
         */
        if (!ped->fNoHideSel)
            SLDrawText(ped, hdc, 0);

        /*
         * Create the caret
         */
        if (ped->pLpkEditCallout) {
            ped->pLpkEditCallout->EditCreateCaret (ped, hdc, ECGetCaretWidth(),
                                                   ped->lineHeight, 0);
        }
        else {
            NtUserCreateCaret(ped->hwnd, (HBITMAP)NULL,
                    ECGetCaretWidth(),
                    ped->lineHeight );
        }
        SLSetCaretPosition(ped, hdc);
        ECReleaseEditDC(ped, hdc, TRUE);
        NtUserShowCaret(ped->hwnd);

    }

    /*
     * Notify parent we have the focus
     */
    ECNotifyParent(ped, EN_SETFOCUS);
}

/***************************************************************************\
* SLKillFocus AorW
*
* The edit control loses the focus and notifies the parent via
* EN_KILLFOCUS.
*
* History:
\***************************************************************************/

void SLKillFocus(
    PED ped,
    HWND newFocusHwnd)
{
    if (ped->fFocus) {

        /*
         * Destroy the caret (Win31/Chicago hides it first)
         */
        NtUserDestroyCaret();

        ped->fFocus = FALSE; /* Clear focus */
        /*
         * Do this only if we still have the focus. But we always notify the
         * parent that we lost the focus whether or not we originally had the
         * focus.
         */

        /*
         * Hide the current selection if needed
         */
        if (!ped->fNoHideSel && (ped->ichMinSel != ped->ichMaxSel)) {
            NtUserInvalidateRect(ped->hwnd, NULL, FALSE);
#if 0
            SLSetSelection(ped, ped->ichCaret, ped->ichCaret);
#endif
        }
    }

    /*
     * If we aren't a combo box, notify parent that we lost the focus.
     */
    if (!ped->listboxHwnd)
        ECNotifyParent(ped, EN_KILLFOCUS);
    else {

        /*
         * This editcontrol is part of a combo box and is losing the focus. If
         * the focus is NOT being sent to another control in the combo box
         * window, then it means the combo box is losing the focus. So we will
         * notify the combo box of this fact.
         */
        if ((newFocusHwnd == NULL) ||
                    (!IsChild(ped->hwndParent, newFocusHwnd))) {
            // Excel has a slaker in it's midst.  They're not using our combo
            // boxes, but they still expect to get all the internal messages
            // that we give to OUR comboboxes.  And they expect them to be at
            // the same offset from WM_USER as they were in 3.1.
            //                                           (JEFFBOG - 01/26/94)
            /*
             * Windows NT won't fix the bug described above: it only applies
             * to old 16-bit excel, and WOW converts msgs to Win3.1 values.
             */

            /*
             * Focus is being sent to a window which is not a child of the combo
             * box window which implies that the combo box is losing the focus.
             * Send a message to the combo box informing him of this fact so
             * that he can clean up...
             */
            SendMessage(ped->hwndParent, CBEC_KILLCOMBOFOCUS, 0, 0L);
        }
    }
}


/***************************************************************************\
*
*  SLPaste()
*
*  Does actual text paste and update.
*
\***************************************************************************/
void   SLPaste(PED ped)
{
    HDC hdc;

    //
    // Insert contents of clipboard, after unhilighting current selection
    // and deleting it.
    //
    ECDeleteText(ped);
    SLPasteText(ped);

    //
    // Update display
    //
    ECNotifyParent(ped, EN_UPDATE);

    hdc = ECGetEditDC(ped,FALSE);

    SLScrollText(ped, hdc);
    SLDrawText(ped, hdc, 0);

    ECReleaseEditDC(ped,hdc,FALSE);

    /*
     * Tell parent our text contents changed.
     */
    ECNotifyParent(ped, EN_CHANGE);
    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
}



/***************************************************************************\
* SLEditWndProc
*
* Class procedure for all single line edit controls.
* Dispatches all messages to the appropriate handlers which are named
* as follows:
* SL (single line) prefixes all single line edit control procedures while
* EC (edit control) prefixes all common handlers.
*
* The SLEditWndProc only handles messages specific to single line edit
* controls.
*
* WARNING: If you add a message here, add it to gawEditWndProc[] in
* kernel\server.c too, otherwise EditWndProcA/W will send it straight to
* DefWindowProcWorker
*
* History:
\***************************************************************************/

LRESULT SLEditWndProc(
    HWND hwnd,
    PED ped,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    POINT       pt;

    /*
     * Dispatch the various messages we can receive
     */
    switch (message) {

    case WM_INPUTLANGCHANGE:
        if (ped && ped->fFocus && ped->pLpkEditCallout) {
            NtUserHideCaret(hwnd);
            hdc = ECGetEditDC(ped, TRUE);
            NtUserDestroyCaret();
            ped->pLpkEditCallout->EditCreateCaret (ped, hdc, ECGetCaretWidth(), ped->lineHeight, (UINT)lParam);
            SLSetCaretPosition(ped, hdc);
            ECReleaseEditDC(ped, hdc, TRUE);
            NtUserShowCaret(hwnd);
        }
        goto PassToDefaultWindowProc;

    case WM_STYLECHANGED:
        if (ped && ped->pLpkEditCallout) {
            switch (wParam) {

                case GWL_STYLE:
                    ECUpdateFormat(ped,
                        ((LPSTYLESTRUCT)lParam)->styleNew,
                        GetWindowLong(ped->hwnd, GWL_EXSTYLE));
                    return 1L;

                case GWL_EXSTYLE:
                    ECUpdateFormat(ped,
                        GetWindowLong(ped->hwnd, GWL_STYLE),
                        ((LPSTYLESTRUCT)lParam)->styleNew);
                    return 1L;
            }
        }

        goto PassToDefaultWindowProc;

    case WM_CHAR:

        /*
         * wParam - the value of the key
           lParam - modifiers, repeat count etc (not used)
         */
        if (!ped->fEatNextChar)
            SLChar(ped, (UINT)wParam);
        else
            ped->fEatNextChar = FALSE;
        break;

    case WM_ERASEBKGND:

       /*
        * wParam - device context handle
        * lParam - not used
        * We do nothing on this message and we don't want DefWndProc to do
        * anything, so return 1
        */
        return (1L);
        break;

    case WM_GETDLGCODE: {
           LONG code = DLGC_WANTCHARS | DLGC_HASSETSEL | DLGC_WANTARROWS;

           /*
            * If this is a WM_SYSCHAR message generated by the UNDO keystroke
            * we want this message so we can EAT IT in "case WM_SYSCHAR:"
            */
            if (lParam) {
                switch (((LPMSG)lParam)->message) {
                    case WM_SYSCHAR:
                        if ((HIWORD(((LPMSG)lParam)->lParam) & SYS_ALTERNATE) &&
                            ((WORD)wParam == VK_BACK)) {
                            code |= DLGC_WANTMESSAGE;
                        }
                        break;

                    case WM_KEYDOWN:
                        if (( (((WORD)wParam == VK_RETURN) ||
                               ((WORD)wParam == VK_ESCAPE)) &&
                            (ped->listboxHwnd)      &&
                            TestWF(ValidateHwnd(ped->hwndParent), CBFDROPDOWN) &&
                            SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L))) {
                            code |= DLGC_WANTMESSAGE;
                        }
                        break;
                }
            }
            return code;
        }

        break;

    case WM_KEYDOWN:

        /*
         * wParam - virt keycode of the given key
         * lParam - modifiers such as repeat count etc. (not used)
         */
        SLKeyDown(ped, (UINT)wParam, 0);
        break;

    case WM_KILLFOCUS:

        /*
         * wParam - handle of the window that receives the input focus
           lParam - not used
         */

        SLKillFocus(ped, (HWND)wParam);
        break;

    case WM_CAPTURECHANGED:
        if (ped->fMouseDown)
            ped->fMouseDown = FALSE;
        break;

    case WM_MOUSEMOVE:
        UserAssert(ped->fMouseDown);
        /*
         * FALL THRU
         */

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
        /*
         * wParam - contains a value that indicates which virtual keys are down
         * lParam - contains x and y coords of the mouse cursor
         */
        POINTSTOPOINT(pt, lParam);
        SLMouseMotion(ped, message, (UINT)wParam, &pt);
        break;

    case WM_CREATE:

        /*
         * wParam - handle to window being created
           lParam - points to a CREATESTRUCT that contains copies of parameters
                    passed to the CreateWindow function.
         */
        return (SLCreate(ped, (LPCREATESTRUCT)lParam));
        break;

    case WM_PRINTCLIENT:
        // wParam --    can be hdc from subclassed paint
        // lParam --    unused
        SLPaint(ped, (HDC) wParam);
        break;

    case WM_PAINT:

        /*
         * wParam --    can be hdc from subclassed paint
         * lParam --    unused
         */
        if (wParam)
            hdc = (HDC) wParam;
        else {
            // this hide/show caret is outside Begin/EndPaint to handle the
            // case when the caret is half in/half out of the update region
            NtUserHideCaret(hwnd);
            hdc = NtUserBeginPaint(hwnd, &ps);
        }

        if (_IsWindowVisible(ped->pwnd))
            SLPaint(ped, hdc);

        if (!wParam) {
            NtUserEndPaint(hwnd, &ps);
            NtUserShowCaret(hwnd);
        }
        break;

    case WM_PASTE:

        /*
         * wParam - not used
         * lParam - not used
         */
        if (!ped->fReadOnly)
            SLPaste(ped);
        break;

    case WM_SETFOCUS:

        /*
         * wParam - handle of window that loses the input focus (may be NULL)
           lParam - not used
         */
        SLSetFocus(ped);
        break;

    case WM_SIZE:

        /*
         * wParam - defines the type of resizing fullscreen, sizeiconic,
                    sizenormal etc.
           lParam - new width in LOWORD, new height in HIGHWORD of client area
         */
        ECSize(ped, NULL, TRUE);
        return 0L;

    case WM_SYSKEYDOWN:
        /*
         * wParam --    virtual key code
         * lParam --    modifiers
         */

        /*
         * Are we in a combobox with the Alt key down?
         */
        if (ped->listboxHwnd && (lParam & 0x20000000L)) {
            /*
             * Handle Combobox support. We want alt up or down arrow to behave
             * like F4 key which completes the combo box selection
             */
            if (lParam & 0x1000000) {

                /*
                 * This is an extended key such as the arrow keys not on the
                 * numeric keypad so just drop the combobox.
                 */
                if (wParam == VK_DOWN || wParam == VK_UP)
                    goto DropCombo;
                else
                    goto foo;
            }

            if (!(GetKeyState(VK_NUMLOCK) & 1) &&
                    (wParam == VK_DOWN || wParam == VK_UP)) {

                /*
                 * NUMLOCK is up and the keypad up or down arrow hit:
                 * eat character generated by keyboard driver.
                 */
                ped->fEatNextChar = TRUE;
            } else {
                goto foo;
            }

DropCombo:
            if (SendMessage(ped->hwndParent,
                    CB_GETEXTENDEDUI, 0, 0) & 0x00000001) {

                /*
                 * Extended ui doesn't honor VK_F4.
                 */
                if (SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0))
                    return(SendMessage(ped->hwndParent, CB_SHOWDROPDOWN, 0, 0));
                else
                    return (SendMessage(ped->hwndParent, CB_SHOWDROPDOWN, 1, 0));
            } else
                return (SendMessage(ped->listboxHwnd, WM_KEYDOWN, VK_F4, 0));
        }
foo:
        if (wParam == VK_BACK) {
            SendMessage(ped->hwnd, WM_UNDO, 0, 0L);
            break;
        }
        else
            goto PassToDefaultWindowProc;
        break;

    case EM_GETLINE:

        /*
         * wParam - line number to copy (always the first line for SL)
         * lParam - buffer to copy text to. FIrst word is max # of bytes to copy
         */
        return ECGetText(ped, (*(LPWORD)lParam), (LPSTR)lParam, FALSE);

    case EM_LINELENGTH:

        /*
         * wParam - ignored
         * lParam - ignored
         */
        return (LONG)ped->cch;
        break;

    case EM_SETSEL:
        /*
         * wParam -- start pos
         * lParam -- end pos
         */
        SLSetSelection(ped, (ICH)wParam, (ICH)lParam);
        break;

    case EM_REPLACESEL:

        /*
         * wParam - flag for 4.0+ apps saying whether to clear undo
         * lParam - points to a null terminated string of replacement text
         */
        SLReplaceSel(ped, (LPSTR)lParam);
        if (!ped->f40Compat || !wParam)
            ECEmptyUndo(Pundo(ped));
        break;

    case EM_GETFIRSTVISIBLELINE:

        /*
         * wParam - not used
         * lParam - not used
         *
         * effects: Returns the first visible line for single line edit controls.
         */
        return ped->ichScreenStart;
        break;

    case EM_POSFROMCHAR:
        //
        // wParam --    char index in text
        // lParam --    not used
        // This function returns the (x,y) position of the character.
        //      y is always 0 for single.
        //
    case EM_CHARFROMPOS:
        //
        // wParam --    unused
        // lParam --    pt in edit client coords
        // This function returns
        //          LOWORD: the position of the _closest_ char
        //                  to the passed in point.
        //          HIWORD: the index of the line (always 0 for single)

        {
            LONG xyPos;

            hdc = ECGetEditDC(ped, TRUE);

            if (message == EM_POSFROMCHAR)
                xyPos = MAKELONG(SLIchToLeftXPos(ped, hdc, (ICH)wParam), 0);
            else {
                POINTSTOPOINT(pt, lParam);
                xyPos = SLMouseToIch(ped, hdc, &pt);
            }

            ECReleaseEditDC(ped, hdc, TRUE);
            return((LRESULT)xyPos);
            break;
        }

    case WM_UNDO:
    case EM_UNDO:
        SLUndo(ped);
        break;

#if 0
    case WM_NCPAINT: // not in server.c gawEditWndProc[] anyway.

        /*
         * LATER - This is an NT optimization.  It needs to be revisited
         * for validity once all of the Chicago changes are done - Johnl
         */

        pwnd = (PWND)HtoP(hwnd);

        /*
         * Check to see if this window has any non-client areas that
         * would be painted.  If not, don't bother calling DefWindowProc()
         * since it'll be a wasted c/s transition.
         */
        if (!ped->fBorder &&
            TestWF(pwnd, WEFDLGMODALFRAME) == 0 &&
            !TestWF(pwnd, (WFMPRESENT | WFVPRESENT | WFHPRESENT)) &&
            TestWF(pwnd, WFSIZEBOX) == 0) {
            break;
        } else {
            goto PassToDefaultWindowProc;
        }
        break;
#endif

    default:
PassToDefaultWindowProc:
        return DefWindowProcWorker(ped->pwnd, message, wParam, lParam, ped->fAnsi);
        break;
    } /* switch (message) */

    return 1L;
} /* SLEditWndProc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\extract.c ===
/****************************** Module Header ******************************\
*
* Module Name: extract.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Icon Extraction Routines
*
* History:
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "newexe.h"

/****************************************************************************
 ****************************************************************************/

#define ICON_MAGIC      0
#define ICO_MAGIC1      1
#define CUR_MAGIC1      2
#define BMP_MAGIC       ((WORD)'B'+((WORD)'M'<<8))
#define ANI_MAGIC       ((WORD)'R'+((WORD)'I'<<8))
#define ANI_MAGIC1      ((WORD)'F'+((WORD)'F'<<8))
#define ANI_MAGIC4      ((WORD)'A'+((WORD)'C'<<8))
#define ANI_MAGIC5      ((WORD)'O'+((WORD)'N'<<8))
#define MZMAGIC         ((WORD)'M'+((WORD)'Z'<<8))
#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))
#define LEMAGIC         ((WORD)'L'+((WORD)'E'<<8))

typedef struct new_exe          NEWEXE,      *LPNEWEXE;
typedef struct exe_hdr          EXEHDR,      *LPEXEHDR;
typedef struct rsrc_nameinfo    RESNAMEINFO, *LPRESNAMEINFO;
typedef struct rsrc_typeinfo    RESTYPEINFO, *LPRESTYPEINFO;
typedef struct rsrc_typeinfo    UNALIGNED    *ULPRESTYPEINFO;
typedef struct new_rsrc         RESTABLE,    *LPRESTABLE;

#define NUMBER_OF_SECTIONS(x) ((x)->FileHeader.NumberOfSections)

#define FCC(c0,c1,c2,c3) ((DWORD)(c0)|((DWORD)(c1)<<8)|((DWORD)(c2)<<16)|((DWORD)(c3)<<24))

#define COM_FILE    FCC('.', 'c', 'o', 'm')
#define BAT_FILE    FCC('.', 'b', 'a', 't')
#define CMD_FILE    FCC('.', 'c', 'm', 'd')
#define PIF_FILE    FCC('.', 'p', 'i', 'f')
#define LNK_FILE    FCC('.', 'l', 'n', 'k')
#define ICO_FILE    FCC('.', 'i', 'c', 'o')
#define EXE_FILE    FCC('.', 'e', 'x', 'e')


#define WIN32VER30  0x00030000  // for CreateIconFromResource()

#define GET_COUNT   424242


/***************************************************************************\
* PathIsUNC
*
* Inline function to check for a double-backslash at the
* beginning of a string
*
\***************************************************************************/

__inline BOOL PathIsUNC(
    LPWSTR psz)
{
    return (psz[0] == L'\\' && psz[1] == L'\\');
}

/***************************************************************************\
* ReadAByte
*
* This is used to touch memory to assure that if we page-fault, it is
* outside win16lock.  Most icons aren't more than two pages.
*
\***************************************************************************/

BOOL ReadAByte(
    LPCVOID pMem)
{
    return ((*(PBYTE)pMem) == 0);
}

/***************************************************************************\
* RVAtoP
*
*
\***************************************************************************/

LPVOID RVAtoP(
    LPVOID pBase,
    DWORD  rva)
{
    LPEXEHDR             pmz;
    IMAGE_NT_HEADERS     *ppe;
    IMAGE_SECTION_HEADER *pSection; // section table
    int                  i;
    DWORD                size;

    pmz = (LPEXEHDR)pBase;
    ppe = (IMAGE_NT_HEADERS*)((BYTE*)pBase + pmz->e_lfanew);

    /*
     * Scan the section table looking for the RVA
     */
    pSection = IMAGE_FIRST_SECTION(ppe);

    for (i = 0; i < NUMBER_OF_SECTIONS(ppe); i++) {

        size = pSection[i].Misc.VirtualSize ?
               pSection[i].Misc.VirtualSize : pSection[i].SizeOfRawData;

        if (rva >= pSection[i].VirtualAddress &&
            rva <  pSection[i].VirtualAddress + size) {

            return (LPBYTE)pBase + pSection[i].PointerToRawData + (rva - pSection[i].VirtualAddress);
        }
    }

    return NULL;
}

/***************************************************************************\
* GetResourceTablePE
*
*
\***************************************************************************/

LPVOID GetResourceTablePE(
    LPVOID pBase)
{
    LPEXEHDR         pmz;
    IMAGE_NT_HEADERS *ppe;

    pmz = (LPEXEHDR)pBase;
    ppe = (IMAGE_NT_HEADERS*)((BYTE*)pBase + pmz->e_lfanew);

    if (pmz->e_magic != MZMAGIC)
        return 0;

    if (ppe->Signature != IMAGE_NT_SIGNATURE)
        return 0;

    // NOTE: if we have more 64-bit platforms, we need to check for their image types here
    // and make sure that we treat them as a IMAGE_NT_HEADERS64
    if (ppe->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64)
    {
        IMAGE_NT_HEADERS64* ppe64 = (IMAGE_NT_HEADERS64*)ppe;

        if (ppe64->FileHeader.SizeOfOptionalHeader < IMAGE_SIZEOF_NT_OPTIONAL64_HEADER)
        {
            return 0;
        }
        return RVAtoP(pBase, ppe64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress);
    }
    else 
    {
        // assume a 32-bit image
        IMAGE_NT_HEADERS32* ppe32 = (IMAGE_NT_HEADERS32*)ppe;

        if (ppe32->FileHeader.SizeOfOptionalHeader < IMAGE_SIZEOF_NT_OPTIONAL32_HEADER)
        {
            return 0;
        }
        return RVAtoP(pBase, ppe32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress);
    }
}

/****************************************************************************
* FindResourcePE
*
*   given a PE resource directory will find a resource in it.
*
*   if iResIndex < 0 we will search for the specific index
*   if iResIndex >= 0 we will return the Nth index
*   if iResIndex == GET_COUNT the count of resources will be returned
*
\*****************************************************************************/

LPVOID FindResourcePE(
    LPVOID pBase,
    LPVOID prt,
    int    iResIndex,
    int    ResType,
    DWORD  *pcb)
{
    int                            i;
    int                            cnt;
    IMAGE_RESOURCE_DIRECTORY       *pdir;
    IMAGE_RESOURCE_DIRECTORY_ENTRY *pres;
    IMAGE_RESOURCE_DATA_ENTRY      *pent;

    pdir = (IMAGE_RESOURCE_DIRECTORY *)prt;

    /*
     * First find the type always a ID so ignore strings totaly
     */
    cnt  = pdir->NumberOfIdEntries + pdir->NumberOfNamedEntries;
    pres = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(pdir+1);

    for (i = 0; i < cnt; i++) {

        if (pres[i].Name == (DWORD)ResType)
            break;
    }

    if (i==cnt)             // did not find the type
        return 0;

    /*
     * Now go find the actual resource  either by id (iResIndex < 0) or
     * by ordinal (iResIndex >= 0)
     */
    pdir = (IMAGE_RESOURCE_DIRECTORY*)((LPBYTE)prt +
        (pres[i].OffsetToData & ~IMAGE_RESOURCE_DATA_IS_DIRECTORY));

    cnt  = pdir->NumberOfIdEntries + pdir->NumberOfNamedEntries;
    pres = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(pdir+1);

    /*
     * If we just want size, do it.
     */
    if (iResIndex == GET_COUNT)
        return (LPVOID)UIntToPtr( cnt );

    /*
     * if we are to search for a specific id do it.
     */
    if (iResIndex < 0) {

        for (i = 0; i < cnt; i++)
            if (pres[i].Name == (DWORD)(-iResIndex))
                break;
    } else {
        i = iResIndex;
    }

    /*
     * is the index in range?
     */
    if (i >= cnt)
        return 0;

    /*
     * if we get this far the resource has a language part, ick!
     * We don't handle multi-language icons, so just return the first one.
     * Note, this isn't a problem since this function isn't called from
     * anywhere that could specify a language. As this is called from an
     * API (albeit a private one), changing this behavior is dangerous.
     */
    if (pres[i].OffsetToData & IMAGE_RESOURCE_DATA_IS_DIRECTORY) {

        pdir = (IMAGE_RESOURCE_DIRECTORY*)((LPBYTE)prt +
                (pres[i].OffsetToData & ~IMAGE_RESOURCE_DATA_IS_DIRECTORY));
        pres = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(pdir+1);
        i = 0;  // choose first one
    }

    /*
     * Nested way to deep for me!
     */
    if (pres[i].OffsetToData & IMAGE_RESOURCE_DATA_IS_DIRECTORY)
        return 0;

    pent = (IMAGE_RESOURCE_DATA_ENTRY*)((LPBYTE)prt + pres[i].OffsetToData);

    /*
     * all OffsetToData fields except the final one are relative to
     * the start of the section.  the final one is a virtual address
     * we need to go back to the header and get the virtual address
     * of the resource section to do this right.
     */
    *pcb = pent->Size;
    return RVAtoP(pBase, pent->OffsetToData);
}

/***************************************************************************\
* GetResourceTableNE
*
*
\***************************************************************************/

LPVOID GetResourceTableNE(
    LPVOID pBase)
{
    LPNEWEXE pne;
    LPEXEHDR pmz;

    pmz = (LPEXEHDR)pBase;
    pne = (LPNEWEXE)((LPBYTE)pBase + pmz->e_lfanew);

    if (pmz->e_magic != MZMAGIC)
        return 0;

    if (pne->ne_magic != NEMAGIC)           // must be a NEWEXE
        return 0;

    if (pne->ne_exetyp != NE_WINDOWS &&     // must be a Win DLL/EXE/386
        pne->ne_exetyp != NE_DEV386)
        return 0;

    if (pne->ne_expver < 0x0300)            // must be 3.0 or greater
        return 0;

    if (pne->ne_rsrctab == pne->ne_restab)  // no resources
        return 0;

    return (LPBYTE)pne + pne->ne_rsrctab;   // return resource table pointer
}

/***************************************************************************\
* FindResourceNE
*
* This returns a pointer to the rsrc_nameinfo of the resource with the
* given index and type, if it is found, otherwise it returns NULL.
*
* if iResIndex is < 0, then it is assumed to be a ID and the res table
* will be searched for a matching id.
*
* if iResIndex is >= 0, then it is assumed to be a index and the Nth
* resorce of the specifed type will be returned.
*
* if iResIndex == GET_COUNT the count of resources will be returned
*
\***************************************************************************/

LPVOID FindResourceNE(
    LPVOID lpBase,
    LPVOID prt,
    int    iResIndex,
    int    iResType,
    DWORD  *pcb)
{
    LPRESTABLE     lpResTable;
    ULPRESTYPEINFO ulpResTypeInfo;
    LPRESNAMEINFO  lpResNameInfo;  // 16 bit alignment ok - had ushorts only
    int            i;

    lpResTable = (LPRESTABLE)prt;
//ulpResTypeInfo = (ULPRESTYPEINFO)(LPWBYTE)&lpResTable->rs_typeinfo;
    ulpResTypeInfo = (ULPRESTYPEINFO)((LPBYTE)lpResTable + 2);

    while (ulpResTypeInfo->rt_id) {

        if (ulpResTypeInfo->rt_id == (iResType | RSORDID)) {

            lpResNameInfo = (LPRESNAMEINFO)(ulpResTypeInfo + 1);

            if (iResIndex == GET_COUNT)
                return (LPVOID)ulpResTypeInfo->rt_nres;

            if (iResIndex < 0) {

                for (i=0; i < (int)ulpResTypeInfo->rt_nres; i++) {

                    if (lpResNameInfo[i].rn_id == ((-iResIndex) | RSORDID))
                        break;
                }

                iResIndex = i;
            }

            if (iResIndex >= (int)ulpResTypeInfo->rt_nres)
                return NULL;

            *pcb = ((DWORD)lpResNameInfo[iResIndex].rn_length) << lpResTable->rs_align;
            return (LPBYTE)lpBase + ((long)lpResNameInfo[iResIndex].rn_offset << lpResTable->rs_align);
        }

        ulpResTypeInfo =
               (ULPRESTYPEINFO)((LPRESNAMEINFO)(ulpResTypeInfo + 1) +
                ulpResTypeInfo->rt_nres);
    }

    *pcb = 0;
    return NULL;
}

/***************************************************************************\
* ExtractIconFromICO
*
*
\***************************************************************************/

UINT ExtractIconFromICO(
    LPTSTR szFile,
    int    nIconIndex,
    int    cxIcon,
    int    cyIcon,
    HICON  *phicon,
    UINT   flags)
{
    HICON hicon;

    if (nIconIndex >= 1)
        return 0;

    flags |= LR_LOADFROMFILE;

again:

    hicon = LoadImage(NULL,
                      szFile,
                      IMAGE_ICON,
                      LOWORD(cxIcon),
                      LOWORD(cyIcon),
                      flags);

    if (hicon == NULL)
        return 0;

    /*
     * Do we just want a count?
     */
    if (phicon == NULL)
        DestroyCursor((HCURSOR)hicon);
    else
        *phicon = hicon;

    /*
     * Check for large/small icon extract
     */
    if (HIWORD(cxIcon)) {

        cxIcon = HIWORD(cxIcon);
        cyIcon = HIWORD(cyIcon);
        phicon++;

        goto again;
    }

    return 1;
}

/***************************************************************************\
* ExtractIconFromBMP
*
*
\***************************************************************************/

#define ROP_DSna 0x00220326

UINT ExtractIconFromBMP(
    LPTSTR szFile,
    int    nIconIndex,
    int    cxIcon,
    int    cyIcon,
    HICON  *phicon,
    UINT   flags)
{
    HICON    hicon;
    HBITMAP  hbm;
    HBITMAP  hbmMask;
    HDC      hdc;
    HDC      hdcMask;
    ICONINFO ii;

    if (nIconIndex >= 1)
        return 0;

    /*
     * BUGUS: don't use LR_CREATEDIBSECTION.  USER can't make an icon out
     * of a DibSection.
     */
    flags |= LR_LOADFROMFILE;

again:

    hbm = (HBITMAP)LoadImage(NULL,
                             szFile,
                             IMAGE_BITMAP,
                             LOWORD(cxIcon),
                             LOWORD(cyIcon),
                             flags);

    if (hbm == NULL)
        return 0;

    /*
     *  do we just want a count?
     */
    if (phicon == NULL) {
        DeleteObject(hbm);
        return 1;
    }

    hbmMask = CreateBitmap(LOWORD(cxIcon), LOWORD(cyIcon), 1, 1, NULL);

    hdc = CreateCompatibleDC(NULL);
    SelectObject(hdc, hbm);

    hdcMask = CreateCompatibleDC(NULL);
    SelectObject(hdcMask, hbmMask);

    SetBkColor(hdc, GetPixel(hdc, 0, 0));

    BitBlt(hdcMask, 0, 0, LOWORD(cxIcon), LOWORD(cyIcon), hdc, 0, 0, SRCCOPY);
    BitBlt(hdc, 0, 0, LOWORD(cxIcon), LOWORD(cyIcon), hdcMask, 0, 0, ROP_DSna);

    ii.fIcon    = TRUE;
    ii.xHotspot = 0;
    ii.yHotspot = 0;
    ii.hbmColor = hbm;
    ii.hbmMask  = hbmMask;
    hicon = CreateIconIndirect(&ii);

    DeleteObject(hdc);
    DeleteObject(hbm);
    DeleteObject(hdcMask);
    DeleteObject(hbmMask);

    *phicon = hicon;

    /*
     * Check for large/small icon extract
     */
    if (HIWORD(cxIcon)) {
        cxIcon = HIWORD(cxIcon);
        cyIcon = HIWORD(cyIcon);
        phicon++;

        goto again;
    }

    return 1;
}

/***************************************************************************\
* ExtractIconFromEXE
*
*
\***************************************************************************/

UINT ExtractIconFromEXE(
    HANDLE hFile,
    int    nIconIndex,
    int    cxIconSize,
    int    cyIconSize,
    HICON  *phicon,
    UINT   *piconid,
    UINT   nIcons,
    UINT   flags)
{
    HANDLE           hFileMap = INVALID_HANDLE_VALUE;
    LPVOID           lpFile = NULL;
    EXEHDR           *pmz;
    NEWEXE UNALIGNED *pne;
    LPVOID           pBase;
    LPVOID           pres = NULL;
    UINT             result = 0;
    LONG             FileLength;
    DWORD            cbSize;
    int              cxIcon;
    int              cyIcon;

    LPVOID (*FindResourceX)(LPVOID pBase,
                            LPVOID prt,
                            int    iResIndex,
                            int    iResType,
                            DWORD  *pcb);

    FileLength = (LONG)GetFileSize(hFile, NULL);

    hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hFileMap == NULL)
        goto exit;

    lpFile = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);
    if (lpFile == NULL)
        goto exit;

    pBase = (LPVOID)lpFile;
    pmz = (struct exe_hdr *)pBase;

    _try {

        if (pmz->e_magic != MZMAGIC)
            goto exit;

        if (pmz->e_lfanew <= 0)             // not a new exe
            goto exit;

        if (pmz->e_lfanew >= FileLength)    // not a new exe
            goto exit;

        pne = (NEWEXE UNALIGNED *)((BYTE*)pmz + pmz->e_lfanew);

        switch (pne->ne_magic) {
        case NEMAGIC:
            pres = GetResourceTableNE(pBase);
            FindResourceX = FindResourceNE;
            break;

        case PEMAGIC:
            pres = GetResourceTablePE(pBase);
            FindResourceX = FindResourcePE;
            break;
        }

        /*
         * cant find the resource table, fail
         */
        if (pres == NULL)
            goto exit;

        /*
         * do we just want a count?
         */
        if (phicon == NULL) {
            result = PtrToUlong(FindResourceX(pBase,
                                             pres,
                                             GET_COUNT,
                                             (LONG_PTR)RT_GROUP_ICON,
                                             &cbSize));
            goto exit;
        }

        while (result < nIcons) {

            LPVOID lpIconDir;
            LPVOID lpIcon;
            int    idIcon;

            cxIcon = cxIconSize;
            cyIcon = cyIconSize;

            /*
             *  find the icon dir for this icon.
             */
            lpIconDir = FindResourceX(pBase,
                                      pres,
                                      nIconIndex,
                                      (LONG_PTR)RT_GROUP_ICON,
                                      &cbSize);

            if (lpIconDir == NULL)
                goto exit;

            if ((((LPNEWHEADER)lpIconDir)->Reserved != 0) ||
                (((LPNEWHEADER)lpIconDir)->ResType != FT_ICON)) {

                goto exit;
            }
again:
            idIcon = LookupIconIdFromDirectoryEx((LPBYTE)lpIconDir,
                                                 TRUE,
                                                 LOWORD(cxIcon),
                                                 LOWORD(cyIcon),
                                                 flags);
            lpIcon = FindResourceX(pBase,
                                   pres,
                                   -idIcon,
                                   (LONG_PTR)RT_ICON,
                                   &cbSize);

            if (lpIcon == NULL)
                goto exit;

            if ((((UPBITMAPINFOHEADER)lpIcon)->biSize != sizeof(BITMAPINFOHEADER)) &&
                (((UPBITMAPINFOHEADER)lpIcon)->biSize != sizeof(BITMAPCOREHEADER))) {

                goto exit;
            }

#ifndef WINNT
            /* touch this memory before calling USER
             * so if we page fault we will do it outside of the Win16Lock
             * most icons aren't more than 2 pages
             */
            ReadAByte(((BYTE *)lpIcon) + cbSize - 1);
#endif

            if (piconid)
                piconid[result] = idIcon;

            phicon[result++] = CreateIconFromResourceEx((LPBYTE)lpIcon,
                                                        cbSize,
                                                        TRUE,
                                                        WIN32VER30,
                                                        LOWORD(cxIcon),
                                                        LOWORD(cyIcon),
                                                        flags);

            /*
             * check for large/small icon extract
             */
            if (HIWORD(cxIcon)) {

                cxIcon = HIWORD(cxIcon);
                cyIcon = HIWORD(cyIcon);

                goto again;
            }

            nIconIndex++;       // next icon index
        }

    } _except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        result = 0;
    }

exit:

    if (lpFile)
        UnmapViewOfFile(lpFile);

    if (hFileMap != INVALID_HANDLE_VALUE)
        CloseHandle(hFileMap);

    return result;
}

/***************************************************************************\
* PathFindExtension
*
*
\***************************************************************************/

LPWSTR PathFindExtension(
    LPWSTR pszPath)
{
    LPWSTR pszDot;

    for (pszDot = NULL; *pszPath; pszPath = CharNext(pszPath)) {

        switch (*pszPath) {
        case L'.':
            pszDot = pszPath;    // remember the last dot
            break;

        case L'\\':
        case L' ':               // extensions can't have spaces
            pszDot = NULL;       // forget last dot, it was in a directory
            break;
        }
    }

    /*
     * if we found the extension, return ptr to the dot, else
     * ptr to end of the string (NULL extension) (cast->non const)
     */
    return pszDot ? (LPWSTR)pszDot : (LPWSTR)pszPath;
}

/***************************************************************************\
* PrivateExtractIconExA
*
* Ansi version of PrivateExtractIconExW
*
\***************************************************************************/

WINUSERAPI UINT PrivateExtractIconExA(
    LPCSTR szFileName,
    int    nIconIndex,
    HICON  *phiconLarge,
    HICON  *phiconSmall,
    UINT   nIcons)
{
    LPWSTR szFileNameW;
    UINT    uRet;

    if (!MBToWCS(szFileName, -1, &szFileNameW, -1, TRUE))
        return 0;

    uRet = PrivateExtractIconExW(szFileNameW,
                                 nIconIndex,
                                 phiconLarge,
                                 phiconSmall,
                                 nIcons);

    UserLocalFree(szFileNameW);

    return uRet;
}

/***************************************************************************\
* HasExtension
*
*
\***************************************************************************/

DWORD HasExtension(
    LPWSTR pszPath)
{
    LPWSTR p = PathFindExtension(pszPath);

    /*
     * (BobDay, emended by JasonSch):
     *
     * NOTE: This routine can produce false positives. E.g., "Fister.Bather"
     * would return .BAT. This doesn't currently hurt us in the instances where
     * this routine is used. However, people stealing this code should verify
     * that this is okay for them.
     *
     * NOTE: We could make this EXTKEY based like the extension matching
     * stuff elsewhere (e.g., shlwapi\urlpars.cpp).  EXTKEY is a QWORD
     * so UNICODE would fit.
     */
    if (*p == L'.') {

        WCHAR szExt[5];

        lstrcpynW(szExt, p, 5);

        if (lstrcmpiW(szExt,TEXT(".com")) == 0) return COM_FILE;
        if (lstrcmpiW(szExt,TEXT(".bat")) == 0) return BAT_FILE;
        if (lstrcmpiW(szExt,TEXT(".cmd")) == 0) return CMD_FILE;
        if (lstrcmpiW(szExt,TEXT(".pif")) == 0) return PIF_FILE;
        if (lstrcmpiW(szExt,TEXT(".lnk")) == 0) return LNK_FILE;
        if (lstrcmpiW(szExt,TEXT(".ico")) == 0) return ICO_FILE;
        if (lstrcmpiW(szExt,TEXT(".exe")) == 0) return EXE_FILE;
    }

    return 0;
}

/***************************************************************************\
* PrivateExtractIconsW
*
* Extracts 1 or more icons from a file.
*
* input:
*     szFileName          - EXE/DLL/ICO/CUR/ANI file to extract from
*     nIconIndex          - what icon to extract
*                             0 = first icon, 1=second icon, etc.
*                            -N = icon with id==N
*     cxIcon              - icon size wanted (if HIWORD != 0 two sizes...)
*     cyIcon              - icon size wanted (if HIWORD != 0 two sizes...)
*                           0,0 means extract at natural size.
*     phicon              - place to return extracted icon(s)
*     nIcons              - number of icons to extract.
*     flags               - LoadImage LR_* flags
*
* returns:
*     if picon is NULL, number of icons in the file is returned.
*
* notes:
*     handles extraction from PE (Win32), NE (Win16), ICO (Icon),
*     CUR (Cursor), ANI (Animated Cursor), and BMP (Bitmap) files.
*     only Win16 3.x files are supported (not 2.x)
*
*     cx/cyIcon are the size of the icon to extract, two sizes
*     can be extracted by putting size 1 in the loword and size 2 in the
*     hiword, ie MAKELONG(24, 48) would extract 24 and 48 size icons.
*     This is a hack it is done so IExtractIcon::Extract can be called by
*     outside people with custom large/small icon sizes that are not what
*     the shell uses internaly.
*
\***************************************************************************/

WINUSERAPI UINT WINAPI PrivateExtractIconsW(
    LPCWSTR szFileName,
    int     nIconIndex,
    int     cxIcon,
    int     cyIcon,
    HICON   *phicon,
    UINT    *piconid,
    UINT    nIcons,
    UINT    flags)
{
    HANDLE   hFile = (HANDLE)INVALID_HANDLE_VALUE;
    UINT     result = 0;
    WORD     magic[6];
    WCHAR    achFileName[MAX_PATH];
    FILETIME ftAccess;
    WCHAR    szExpFileName[MAX_PATH];
    DWORD    dwBytesRead;

    /*
     * Set failure defaults.
     */
    if (phicon)
        *phicon = NULL;

    /*
     * Check for special extensions, and fail quick
     */
    switch (HasExtension((LPWSTR)szFileName)) {
    case COM_FILE:
    case BAT_FILE:
    case CMD_FILE:
    case PIF_FILE:
    case LNK_FILE:
        goto exit;

    default:
        break;
    }

    /*
     * Try expanding environment variables in the file name we're passed.
     */
    ExpandEnvironmentStrings(szFileName, szExpFileName, MAX_PATH);
    szExpFileName[ MAX_PATH-1 ] = (WCHAR)0;

    /*
     * Open the file - First check to see if it is a UNC path.  If it
     * is make sure that we have access to the path...
     */
    if (PathIsUNC(szExpFileName)) {

        lstrcpynW(achFileName, szExpFileName, ARRAYSIZE(achFileName));

    } else {

        if (SearchPath(NULL,
                       szExpFileName,
                       NULL,
                       ARRAYSIZE(achFileName),
                       achFileName, NULL) == 0) {

            goto error_file;
        }
    }

    hFile = CreateFile(achFileName,
                       GENERIC_READ|FILE_WRITE_ATTRIBUTES,
                       FILE_SHARE_WRITE | FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                       0);

    if (hFile == INVALID_HANDLE_VALUE) {

        hFile = CreateFile(achFileName, GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                           0);

        if (hFile == INVALID_HANDLE_VALUE)
            goto error_file;

    } else {

        /*
         * Restore the Access Date
         */
        if (GetFileTime(hFile, NULL, &ftAccess, NULL))
            SetFileTime(hFile, NULL, &ftAccess, NULL);
    }


    ReadFile(hFile, &magic, sizeof(magic), &dwBytesRead, NULL);
    if (dwBytesRead != sizeof(magic))
        goto exit;

    if (piconid)
        *piconid = (UINT)-1;    // Fill in "don't know" value

    switch (magic[0]) {
    case MZMAGIC:
        result = ExtractIconFromEXE(hFile,
                                    nIconIndex,
                                    cxIcon,
                                    cyIcon,
                                    phicon,
                                    piconid,
                                    nIcons,
                                    flags);
        break;

    case ANI_MAGIC:    // possible .ani cursor

        /*
         * Ani cursors are easy they are RIFF files of type 'ACON'
         */
        if (magic[1] == ANI_MAGIC1 && magic[4] == ANI_MAGIC4 &&
            magic[5] == ANI_MAGIC5) {

            result = ExtractIconFromICO(achFileName,
                                        nIconIndex,
                                        cxIcon,
                                        cyIcon,
                                        phicon,
                                        flags);
        }
        break;

    case BMP_MAGIC:    // possible bitmap
        result = ExtractIconFromBMP(achFileName,
                                    nIconIndex,
                                    cxIcon,
                                    cyIcon,
                                    phicon,
                                    flags);
        break;

    case ICON_MAGIC:   // possible .ico or .cur

        /*
         * Icons and cursors look like this
         *
         * iReserved       - always zero
         * iResourceType   - 1 for icons 2 cor cursor.
         * cresIcons       - number of resolutions in this file
         *
         * We only allow 1 <= cresIcons <= 10
         */
        if (magic[1] == ICO_MAGIC1 || magic[1] == CUR_MAGIC1) {

            result = ExtractIconFromICO(achFileName,
                                        nIconIndex,
                                        cxIcon,
                                        cyIcon,
                                        phicon,
                                        flags);
        }
        break;
    }

exit:

    if (hFile!=INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return result;

    /*
     *  if we cant open the file, return a code saying we cant open the file
     *  if phicon==NULL return the count of icons in the file 0
     */

error_file:

    result = (phicon ? (UINT)-1 : 0);

    goto exit;
}

/***************************************************************************\
* PrivateExtractIconsA
*
*
\***************************************************************************/

WINUSERAPI UINT WINAPI PrivateExtractIconsA(
    LPCSTR szFileName,
    int     nIconIndex,
    int     cxIcon,
    int     cyIcon,
    HICON   *phicon,
    UINT    *piconid,
    UINT    nIcons,
    UINT    flags)
{
    LPWSTR szFileNameW;
    UINT uRet;

    if (!MBToWCS(szFileName, -1, &szFileNameW, -1, TRUE))
        return 0;

    uRet = PrivateExtractIconsW(szFileNameW,
                                nIconIndex,
                                cxIcon,
                                cyIcon,
                                phicon,
                                piconid,
                                nIcons,
                                flags);

    UserLocalFree(szFileNameW);

    return uRet;
}

/***************************************************************************\
* PrivateExtractIconExW
*
* extracts 1 or more icons from a file.
*
* input:
*     szFileName          - EXE/DLL/ICO file to extract from
*     nIconIndex          - what icon to extract
*                             0 = first icon, 1=second icon, etc.
*                            -N = icon with id==N
*     phiconLarge         - place to return extracted icon(s)
*     phiconSmall         - place to return extracted icon(s) (small size)
*     nIcons              - number of icons to extract.
*
* returns:
*     number of icons extracted, or the count of icons if phiconLarge==NULL
*
* notes:
*     handles extraction from PE (Win32), NE (Win16), and ICO (Icon) files.
*     only Win16 3.x files are supported (not 2.x)
*
\***************************************************************************/

WINUSERAPI UINT PrivateExtractIconExW(
    LPCWSTR szFileName,
    int     nIconIndex,
    HICON   *phiconLarge,
    HICON   *phiconSmall,
    UINT    nIcons)
{
    UINT result = 0;

    if ((nIconIndex == -1) || ((phiconLarge == NULL) && (phiconSmall == NULL)))
        return PrivateExtractIconsW(szFileName, 0, 0, 0, NULL, NULL, 0, 0);

    if (phiconLarge && phiconSmall && (nIcons == 1)) {

        HICON ahicon[2];

        ahicon[0] = NULL;
        ahicon[1] = NULL;

        result = PrivateExtractIconsW(szFileName,
                                      nIconIndex,
                                      MAKELONG(GetSystemMetrics(SM_CXICON),
                                               GetSystemMetrics(SM_CXSMICON)),
                                      MAKELONG(GetSystemMetrics(SM_CYICON),
                                               GetSystemMetrics(SM_CYSMICON)),
                                      ahicon,
                                      NULL,
                                      2,
                                      0);

        *phiconLarge = ahicon[0];
        *phiconSmall = ahicon[1];

    } else {

        if (phiconLarge)
            result = PrivateExtractIconsW(szFileName,
                                          nIconIndex,
                                          GetSystemMetrics(SM_CXICON),
                                          GetSystemMetrics(SM_CYICON),
                                          phiconLarge,
                                          NULL,
                                          nIcons,
                                          0);

        if (phiconSmall)
            result = PrivateExtractIconsW(szFileName,
                                          nIconIndex,
                                          GetSystemMetrics(SM_CXSMICON),
                                          GetSystemMetrics(SM_CYSMICON),
                                          phiconSmall,
                                          NULL,
                                          nIcons,
                                          0);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\edmlrare.c ===
/****************************************************************************\
* edmlRare.c - Edit controls Routines Called rarely are to be
* put in a seperate segment _EDMLRare. This file contains
* these routines.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Multi-Line Support Routines called Rarely
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* MLInsertCrCrLf AorW
*
* Inserts CR CR LF characters into the text at soft (word-wrap) line
* breaks. CR LF (hard) line breaks are unaffected. Assumes that the text
* has already been formatted ie. ped->chLines is where we want the line
* breaks to occur. Note that ped->chLines is not updated to reflect the
* movement of text by the addition of CR CR LFs. Returns TRUE if successful
* else notify parent and return FALSE if the memory couldn't be allocated.
*
* History:
\***************************************************************************/

BOOL MLInsertCrCrLf(
    PED ped)
{
    ICH dch;
    ICH li;
    ICH lineSize;
    unsigned char *pchText;
    unsigned char *pchTextNew;

    if (!ped->fWrap || !ped->cch) {

        /*
         * There are no soft line breaks if word-wrapping is off or if no chars
         */
        return TRUE;
    }

    /*
     * Calc an upper bound on the number of additional characters we will be
     * adding to the text when we insert CR CR LFs.
     */
    dch = 3 * ped->cLines;

    if (!LOCALREALLOC(ped->hText, (ped->cch + dch) * ped->cbChar, 0, ped->hInstance, NULL)) {
        ECNotifyParent(ped, EN_ERRSPACE);
        return FALSE;
    }

    ped->cchAlloc = ped->cch + dch;

    /*
     * Move the text up dch bytes and then copy it back down, inserting the CR
     * CR LF's as necessary.
     */
    pchTextNew = pchText = ECLock(ped);
    pchText += dch * ped->cbChar;

    /*
     * We will use dch to keep track of how many chars we add to the text
     */
    dch = 0;

    /*
     * Copy the text up dch bytes to pchText. This will shift all indices in
     * ped->chLines up by dch bytes.
     */
    memmove(pchText, pchTextNew, ped->cch * ped->cbChar);

    /*
     * Now copy chars from pchText down to pchTextNew and insert CRCRLF at soft
     * line breaks.
     */
    if (ped->fAnsi) {
        for (li = 0; li < ped->cLines - 1; li++) {
            lineSize = ped->chLines[li + 1] - ped->chLines[li];
            memmove(pchTextNew, pchText, lineSize);
            pchTextNew += lineSize;
            pchText += lineSize;

            /*
             * If last character in newly copied line is not a line feed, then we
             * need to add the CR CR LF triple to the end
             */
            if (*(pchTextNew - 1) != 0x0A) {
                *pchTextNew++ = 0x0D;
                *pchTextNew++ = 0x0D;
                *pchTextNew++ = 0x0A;
                dch += 3;
            }
        }

        /*
         * Now move the last line up. It won't have any line breaks in it...
         */
        memmove(pchTextNew, pchText, ped->cch - ped->chLines[ped->cLines - 1]);
    } else { //!fAnsi
        LPWSTR pwchTextNew = (LPWSTR)pchTextNew;

        for (li = 0; li < ped->cLines - 1; li++) {
            lineSize = ped->chLines[li + 1] - ped->chLines[li];
            memmove(pwchTextNew, pchText, lineSize * sizeof(WCHAR));
            pwchTextNew += lineSize;
            pchText += lineSize * sizeof(WCHAR);

            /*
             * If last character in newly copied line is not a line feed, then we
             * need to add the CR CR LF triple to the end
             */
            if (*(pwchTextNew - 1) != 0x0A) {
                *pwchTextNew++ = 0x0D;
                *pwchTextNew++ = 0x0D;
                *pwchTextNew++ = 0x0A;
                dch += 3;
            }
        }

        /*
         * Now move the last line up. It won't have any line breaks in it...
         */
        memmove(pwchTextNew, pchText,
            (ped->cch - ped->chLines[ped->cLines - 1]) * sizeof(WCHAR));
    }

    ECUnlock(ped);

    if (dch) {
        /*
         * Update number of characters in text handle
         */
        ped->cch += dch;

        /*
         * So that the next time we do anything with the text, we can strip the
         * CRCRLFs
         */
        ped->fStripCRCRLF = TRUE;
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* MLStripCrCrLf AorW
*
* Strips the CR CR LF character combination from the text. This
* shows the soft (word wrapped) line breaks. CR LF (hard) line breaks are
* unaffected.
*
* History:
\***************************************************************************/

void MLStripCrCrLf(
    PED ped)
{
    if (ped->cch) {
        if (ped->fAnsi) {
            unsigned char *pchSrc;
            unsigned char *pchDst;
            unsigned char *pchLast;

            pchSrc = pchDst = ECLock(ped);
            pchLast = pchSrc + ped->cch;
            while (pchSrc < pchLast) {
                if (   (pchSrc[0] == 0x0D)
                    && (pchSrc[1] == 0x0D)
                    && (pchSrc[2] == 0x0A)
                ) {
                    pchSrc += 3;
                    ped->cch -= 3;
                } else {
                    *pchDst++ = *pchSrc++;
                }
            }
        } else { // !fAnsi
            LPWSTR pwchSrc;
            LPWSTR pwchDst;
            LPWSTR pwchLast;

            pwchSrc = pwchDst = (LPWSTR)ECLock(ped);
            pwchLast = pwchSrc + ped->cch;
            while (pwchSrc < pwchLast) {
                if (   (pwchSrc[0] == 0x0D)
                    && (pwchSrc[1] == 0x0D)
                    && (pwchSrc[2] == 0x0A)
                ) {
                    pwchSrc += 3;
                    ped->cch -= 3;
                } else {
                    *pwchDst++ = *pwchSrc++;
                }
            }
        }
        ECUnlock(ped);

        /*
         * Make sure we don't have any values past the last character
         */
        if (ped->ichCaret > ped->cch)
            ped->ichCaret  = ped->cch;
        if (ped->ichMinSel > ped->cch)
            ped->ichMinSel = ped->cch;
        if (ped->ichMaxSel > ped->cch)
            ped->ichMaxSel = ped->cch;
    }
}

/***************************************************************************\
* MLSetHandle AorW
*
* Sets the ped to contain the given handle.
*
* History:
\***************************************************************************/

void MLSetHandle(
    PED ped,
    HANDLE hNewText)
{
    ICH newCch;

    ped->cch = ped->cchAlloc =
            LOCALSIZE(ped->hText = hNewText, ped->hInstance) / ped->cbChar;
    ped->fEncoded = FALSE;

    if (ped->cch) {

        /*
         * We have to do it this way in case the app gives us a zero size handle
         */
        if (ped->fAnsi)
            ped->cch = strlen(ECLock(ped));
        else
            ped->cch = wcslen((LPWSTR)ECLock(ped));
        ECUnlock(ped);
    }

    newCch = (ICH)(ped->cch + CCHALLOCEXTRA);

    /*
     * We do this LocalReAlloc in case the app changed the size of the handle
     */
    if (LOCALREALLOC(ped->hText, newCch*ped->cbChar, 0, ped->hInstance, NULL))
        ped->cchAlloc = newCch;

    ECResetTextInfo(ped);
}

/***************************************************************************\
* MLGetLine AorW
*
* Copies maxCchToCopy bytes of line lineNumber to the buffer
* lpBuffer. The string is not zero terminated.
*
* Returns number of characters copied
*
* History:
\***************************************************************************/

LONG MLGetLine(
    PED ped,
    ICH lineNumber, //WASDWORD
    ICH maxCchToCopy,
    LPSTR lpBuffer)
{
    PSTR pText;
    ICH cchLen;

    if (lineNumber > ped->cLines - 1) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"lineNumber\" (%ld) to MLGetLine",
                lineNumber);

        return 0L;
    }

    cchLen = MLLine(ped, lineNumber);
    maxCchToCopy = min(cchLen, maxCchToCopy);

    if (maxCchToCopy) {
        pText = ECLock(ped) +
                ped->chLines[lineNumber] * ped->cbChar;
        memmove(lpBuffer, pText, maxCchToCopy*ped->cbChar);
        ECUnlock(ped);
    }

    return maxCchToCopy;
}

/***************************************************************************\
* MLLineIndex AorW
*
* This function return s the number of character positions that occur
* preceeding the first char in a given line.
*
* History:
\***************************************************************************/

ICH MLLineIndex(
    PED ped,
    ICH iLine) //WASINT
{
    if (iLine == -1)
        iLine = ped->iCaretLine;
    if (iLine < ped->cLines) {
        return ped->chLines[iLine];
    } else {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"iLine\" (%ld) to MLLineIndex",
                iLine);

        return (ICH)-1;
    }
}

/***************************************************************************\
* MLLineLength AorW
*
* if ich = -1, return the length of the lines containing the current
* selection but not including the selection. Otherwise, return the length of
* the line containing ich.
*
* History:
\***************************************************************************/

ICH MLLineLength(
    PED ped,
    ICH ich)
{
    ICH il1, il2;
    ICH temp;

    if (ich != 0xFFFFFFFF)
        return (MLLine(ped, MLIchToLine(ped, ich)));

    /*
     * Find length of lines corresponding to current selection
     */
    il1 = MLIchToLine(ped, ped->ichMinSel);
    il2 = MLIchToLine(ped, ped->ichMaxSel);
    if (il1 == il2)
        return (MLLine(ped, il1) - (ped->ichMaxSel - ped->ichMinSel));

    temp = ped->ichMinSel - ped->chLines[il1];
    temp += MLLine(ped, il2);
    temp -= (ped->ichMaxSel - ped->chLines[il2]);

    return temp;
}

/***************************************************************************\
* MLSetSelection AorW
*
* Sets the selection to the points given and puts the cursor at
* ichMaxSel.
*
* History:
\***************************************************************************/

void MLSetSelection(
    PED  ped,
    BOOL fDoNotScrollCaret,
    ICH  ichMinSel,
    ICH  ichMaxSel)
{
    HDC hdc;

    if (ichMinSel == 0xFFFFFFFF) {

        /*
         * Set no selection if we specify -1
         */
        ichMinSel = ichMaxSel = ped->ichCaret;
    }

    /*
     * Since these are unsigned, we don't check if they are greater than 0.
     */
    ichMinSel = min(ped->cch, ichMinSel);
    ichMaxSel = min(ped->cch, ichMaxSel);

#ifdef FE_SB // MLSetSelectionHander()
    //
    // To avoid position to half of DBCS, check and ajust position if necessary
    //
    // We check ped->fDBCS and ped->fAnsi though ECAdjustIch checks these bits
    // at first. We're worrying about the overhead of ECLock and ECUnlock.
    //
    if ( ped->fDBCS && ped->fAnsi ) {

        PSTR pText;

        pText = ECLock(ped);
        ichMinSel = ECAdjustIch( ped, pText, ichMinSel );
        ichMaxSel = ECAdjustIch( ped, pText, ichMaxSel );
        ECUnlock(ped);
    }
#endif // FE_SB

    /*
     * Set the caret's position to be at ichMaxSel.
     */
    ped->ichCaret = ichMaxSel;
    ped->iCaretLine = MLIchToLine(ped, ped->ichCaret);

    hdc = ECGetEditDC(ped, FALSE);
    MLChangeSelection(ped, hdc, ichMinSel, ichMaxSel);

    MLSetCaretPosition(ped, hdc);
    ECReleaseEditDC(ped, hdc, FALSE);

#ifdef FE_SB // MLSetSelectionHander()
    if (!fDoNotScrollCaret)
        MLEnsureCaretVisible(ped);
    /*
     * #ifdef KOREA is history, with FE_SB (FarEast Single Binary).
     */
#else
#ifdef KOREA
    /*
     * Extra parameter specified interim character mode
     */
    MLEnsureCaretVisible(ped,NULL);
#else
    if (!fDoNotScrollCaret)
        MLEnsureCaretVisible(ped);
#endif
#endif // FE_SB
}

/***************************************************************************\
* MLSetTabStops AorW
*
*
* MLSetTabStops(ped, nTabPos, lpTabStops)
*
* This sets the tab stop positions set by the App by sending
* a EM_SETTABSTOPS message.
*
* nTabPos : Number of tab stops set by the caller
* lpTabStops: array of tab stop positions in Dialog units.
*
* Returns:
* TRUE if successful
* FALSE if memory allocation error.
*
* History:
\***************************************************************************/

BOOL MLSetTabStops(
    PED ped,
    int nTabPos,
    LPINT lpTabStops)
{
    int *pTabStops;

    /*
     * Check if tab positions already exist
     */
    if (!ped->pTabStops) {

        /*
         * Check if the caller wants the new tab positions
         */
        if (nTabPos) {

            /*
             * Allocate the array of tab stops
             */
            if (!(pTabStops = (LPINT)UserLocalAlloc(HEAP_ZERO_MEMORY, (nTabPos + 1) * sizeof(int)))) {
                return FALSE;
            }
        } else {
            return TRUE; /* No stops then and no stops now! */
        }
    } else {

        /*
         * Check if the caller wants the new tab positions
         */
        if (nTabPos) {

            /*
             * Check if the number of tab positions is different
             */
            if (ped->pTabStops[0] != nTabPos) {

                /*
                 * Yes! So ReAlloc to new size
                 */
                if (!(pTabStops = (LPINT)UserLocalReAlloc(ped->pTabStops,
                        (nTabPos + 1) * sizeof(int), 0)))
                    return FALSE;
            } else {
                pTabStops = ped->pTabStops;
            }
        } else {

            /*
             * Caller wants to remove all the tab stops; So, release
             */
            if (!UserLocalFree(ped->pTabStops))
                return FALSE;  /* Failure */
            ped->pTabStops = NULL;
            goto RedrawAndReturn;
        }
    }

    /*
     * Copy the new tab stops onto the tab stop array after converting the
     * dialog co-ordinates into the pixel co-ordinates
     */
    ped->pTabStops = pTabStops;
    *pTabStops++ = nTabPos; /* First element contains the count */
    while (nTabPos--) {

        /*
         * aveCharWidth must be used instead of cxSysCharWidth.
         * Fix for Bug #3871 --SANKAR-- 03/14/91
         */
        *pTabStops++ = MultDiv(*lpTabStops++, ped->aveCharWidth, 4);
    }

RedrawAndReturn:
    // Because the tabstops have changed, we need to recompute the
    // maxPixelWidth. Otherwise, horizontal scrolls will have problems.
    // Fix for Bug #6042 - 3/15/94
    MLBuildchLines(ped, 0, 0, FALSE, NULL, NULL);

    // Caret may have changed line by the line recalc above.
    MLUpdateiCaretLine(ped);

    MLEnsureCaretVisible(ped);

    // Also, we need to redraw the whole window.
    NtUserInvalidateRect(ped->hwnd, NULL, TRUE);
    return TRUE;
}

/***************************************************************************\
* MLUndo AorW
*
* Handles Undo for multiline edit controls.
*
* History:
\***************************************************************************/

BOOL MLUndo(
    PED ped)
{
    HANDLE hDeletedText = ped->hDeletedText;
    BOOL fDelete = (BOOL)(ped->undoType & UNDO_DELETE);
    ICH cchDeleted = ped->cchDeleted;
    ICH ichDeleted = ped->ichDeleted;

    if (ped->undoType == UNDO_NONE) {

        /*
         * No undo...
         */
        return FALSE;
    }

    ped->hDeletedText = NULL;
    ped->cchDeleted = 0;
    ped->ichDeleted = (ICH)-1;
    ped->undoType &= ~UNDO_DELETE;

    if (ped->undoType == UNDO_INSERT) {
        ped->undoType = UNDO_NONE;

        /*
         * Set the selection to the inserted text
         */
        MLSetSelection(ped, FALSE, ped->ichInsStart, ped->ichInsEnd);
        ped->ichInsStart = ped->ichInsEnd = (ICH)-1;

        /*
         * Now send a backspace to delete and save it in the undo buffer...
         */
        SendMessage(ped->hwnd, WM_CHAR, (WPARAM)VK_BACK, 0L);
    }

    if (fDelete) {

        /*
         * Insert deleted chars
         */

        /*
         * Set the selection to the inserted text
         */
        MLSetSelection(ped, FALSE, ichDeleted, ichDeleted);
        MLInsertText(ped, hDeletedText, cchDeleted, FALSE);

        UserGlobalFree(hDeletedText);
        MLSetSelection(ped, FALSE, ichDeleted, ichDeleted + cchDeleted);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\fareast.c ===
/**************************************************************************\
* Module Name: fareast.c
*
* Win32 IMM/IME API functions
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 07-May-1996 takaok    Created.
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define COMMON_RETURN_ZERO  \
    return 0;

////////////////////////
// Fake routines
////////////////////////

VOID fakeImm_v1(PVOID dummy)
{
    UNREFERENCED_PARAMETER(dummy);
}

#ifdef CUAS_ENABLE
VOID fakeImm_vd1(DWORD dummy)
{
    UNREFERENCED_PARAMETER(dummy);
};
#endif // CUAS_ENABLE

DWORD fakeImm_d1(DWORD dummy)
{
    UNREFERENCED_PARAMETER(dummy);
    return 0;
}

#ifdef CUAS_ENABLE
DWORD fakeImm_dv1(VOID)
{
    return 0;
};
#endif // CUAS_ENABLE

VOID fakeImm_v2(PVOID dummy1, PVOID dummy2)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
}

DWORD fakeImm_d2(DWORD dummy1, DWORD dummy2)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    return 0;
}

DWORD fakeImm_d3(DWORD dummy1, DWORD dummy2, DWORD dummy3)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);
    return 0;
}

DWORD fakeImm_bwuwl(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(msg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    return 0;
}

VOID WINAPI fakeImm_wv1(PVOID dummy)
{
    UNREFERENCED_PARAMETER(dummy);
}

DWORD WINAPI fakeImm_wd1(PVOID dummy)
{
    UNREFERENCED_PARAMETER(dummy);
    COMMON_RETURN_ZERO;
}

DWORD WINAPI fakeImm_wd2(PVOID dummy1, PVOID dummy2)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    COMMON_RETURN_ZERO;
}

//
// This stub returns true.
//
BOOL WINAPI fakeImm_bd2(PVOID dummy1, PVOID dummy2)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    return TRUE;
}

DWORD WINAPI fakeImm_wd3(PVOID dummy1, PVOID dummy2, PVOID dummy3)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);

    COMMON_RETURN_ZERO;
}

DWORD WINAPI fakeImm_wd4(PVOID dummy1, PVOID dummy2, PVOID dummy3, PVOID dummy4)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);
    UNREFERENCED_PARAMETER(dummy4);

    COMMON_RETURN_ZERO;
}

DWORD WINAPI fakeImm_wd5(PVOID dummy1, PVOID dummy2, PVOID dummy3, PVOID dummy4, PVOID dummy5)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);
    UNREFERENCED_PARAMETER(dummy4);
    UNREFERENCED_PARAMETER(dummy5);

    COMMON_RETURN_ZERO;
}

DWORD WINAPI fakeImm_wd6(PVOID dummy1, PVOID dummy2, PVOID dummy3, PVOID dummy4, PVOID dummy5, PVOID dummy6)
{
    UNREFERENCED_PARAMETER(dummy1);
    UNREFERENCED_PARAMETER(dummy2);
    UNREFERENCED_PARAMETER(dummy3);
    UNREFERENCED_PARAMETER(dummy4);
    UNREFERENCED_PARAMETER(dummy5);
    UNREFERENCED_PARAMETER(dummy6);

    COMMON_RETURN_ZERO;
}

ImmApiEntries gImmApiEntries = {
    (BOOL (WINAPI* /*ImmWINNLSEnableIME*/)(HWND, BOOL))     fakeImm_wd2,
    (BOOL (WINAPI* /*ImmWINNLSGetEnableStatus*/)(HWND))     fakeImm_wd1,
    (LRESULT (WINAPI* /*SendIMEMessageExW*/)(HWND, LPARAM)) fakeImm_wd2,
    (LRESULT (WINAPI* /*SendIMEMessageExA*/)(HWND, LPARAM)) fakeImm_wd2,
    (BOOL (WINAPI* /*IMPGetIMEW*/)(HWND, LPIMEPROW))        fakeImm_wd2,
    (BOOL (WINAPI* /*IMPGetIMEA*/)(HWND, LPIMEPROA))        fakeImm_wd2,
    (BOOL (WINAPI* /*IMPQueryIMEW*/)(LPIMEPROW))            fakeImm_wd1,
    (BOOL (WINAPI* /*IMPQueryIMEA*/)(LPIMEPROA))            fakeImm_wd1,
    (BOOL (WINAPI* /*IMPSetIMEW*/)(HWND, LPIMEPROW))        fakeImm_wd2,
    (BOOL (WINAPI* /*IMPSetIMEA*/)(HWND, LPIMEPROA))        fakeImm_wd2,

    (HIMC (WINAPI* /*ImmAssociateContext*/)(HWND, HIMC))    fakeImm_wd2,
    (LRESULT (WINAPI* /*ImmEscapeA*/)(HKL, HIMC, UINT, LPVOID)) fakeImm_wd4,
    (LRESULT (WINAPI* /*ImmEscapeW*/)(HKL, HIMC, UINT, LPVOID)) fakeImm_wd4,
    (LONG (WINAPI* /*ImmGetCompositionStringA*/)(HIMC, DWORD, LPVOID, DWORD)) fakeImm_wd4,
    (LONG (WINAPI* /*ImmGetCompositionStringW*/)(HIMC, DWORD, LPVOID, DWORD)) fakeImm_wd4,
    (BOOL (WINAPI* /*ImmGetCompositionWindow*/)(HIMC, LPCOMPOSITIONFORM)) fakeImm_wd2,
    (HIMC (WINAPI* /*ImmGetContext*/)(HWND))                fakeImm_wd1,
    (HWND (WINAPI* /*ImmGetDefaultIMEWnd*/)(HWND))          fakeImm_wd1,
    (BOOL (WINAPI* /*ImmIsIME*/)(HKL))                      fakeImm_wd1,
    (BOOL (WINAPI* /*ImmReleaseContext*/)(HWND, HIMC))      fakeImm_wd2,
    (BOOL (* /*ImmRegisterClient*/)(PSHAREDINFO, HINSTANCE))           fakeImm_bd2,

    (BOOL (WINAPI* /*ImmGetCompositionFontW*/)(HIMC, LPLOGFONTW)) fakeImm_wd2,
    (BOOL (WINAPI* /*ImmGetCompositionFontA*/)(HIMC, LPLOGFONTA)) fakeImm_wd2,
    (BOOL (WINAPI* /*ImmSetCompositionFontW*/)(HIMC, LPLOGFONTW)) fakeImm_wd2,
    (BOOL (WINAPI* /*ImmSetCompositionFontA*/)(HIMC, LPLOGFONTA)) fakeImm_wd2,

    (BOOL (WINAPI* /*ImmSetCompositionWindow*/)(HIMC, LPCOMPOSITIONFORM)) fakeImm_wd2,
    (BOOL (WINAPI* /*ImmNotifyIME*/)(HIMC, DWORD, DWORD, DWORD)) fakeImm_wd4,
    (PINPUTCONTEXT (WINAPI* /*ImmLockIMC*/)(HIMC))          fakeImm_wd1,
    (BOOL (WINAPI* /*ImmUnlockIMC*/)(HIMC))                 fakeImm_wd1,
    (BOOL (WINAPI* /*ImmLoadIME*/)(HKL))                    fakeImm_wd1,
    (BOOL (WINAPI* /*ImmSetOpenStatus*/)(HIMC, BOOL))       fakeImm_wd2,
    (BOOL (WINAPI* /*ImmFreeLayout*/)(DWORD dwFlag))        fakeImm_wd1,
    (BOOL (WINAPI* /*ImmActivateLayout*/)(HKL))             fakeImm_wd1,
    (BOOL (WINAPI* /*ImmGetCandidateWindow*/)(HIMC, DWORD, LPCANDIDATEFORM)) fakeImm_wd3,
    (BOOL (WINAPI* /*ImmSetCandidateWindow*/)(HIMC, LPCANDIDATEFORM))   fakeImm_wd2,
    (BOOL (WINAPI* /*ImmConfigureIMEW*/)(HKL, HWND, DWORD, LPVOID)) fakeImm_wd4,
    (BOOL (WINAPI* /*ImmGetConversionStatus*/)(HIMC, LPDWORD, LPDWORD)) fakeImm_wd3,
    (BOOL (WINAPI* /*ImmSetConversionStatus*/)(HIMC, DWORD, DWORD)) fakeImm_wd3,
    (BOOL (WINAPI* /*ImmSetStatusWindowPos*/)(HIMC, LPPOINT))           fakeImm_wd2,
    (BOOL (WINAPI* /*ImmGetImeInfoEx*/)(PIMEINFOEX, IMEINFOEXCLASS, PVOID)) fakeImm_wd3,
    (PIMEDPI (WINAPI* /*ImmLockImeDpi*/)(HKL))              fakeImm_wd1,
    (VOID (WINAPI* /*ImmUnlockImeDpi*/)(PIMEDPI))           fakeImm_wv1,
    (BOOL (WINAPI* /*ImmGetOpenStatus*/)(HIMC))             fakeImm_wd1,
    (BOOL (* /*ImmSetActiveContext*/)(HWND, HIMC, BOOL))    fakeImm_d3,
    (BOOL (* /*ImmTranslateMessage*/)(HWND, UINT, WPARAM, LPARAM)) fakeImm_bwuwl,
    (BOOL (* /*ImmLoadLayout*/)(HKL, PIMEINFOEX))           fakeImm_d2,
    (DWORD (WINAPI* /*ImmProcessKey*/)(HWND, HKL, UINT, LPARAM, DWORD)) fakeImm_wd5,
    (LRESULT (* /*ImmPutImeMenuItemsIntoMappedFile*/)(HIMC)) fakeImm_d1,
    (DWORD (WINAPI* /*ImmGetProperty*/)(HKL, DWORD))        fakeImm_wd2,
    (BOOL (WINAPI* /*ImmSetCompositionStringA*/)(
         HIMC hImc, DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen))
                                                            fakeImm_wd6,
    (BOOL (WINAPI* /*ImmSetCompositionStringW*/)(
         HIMC hImc, DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen))
                                                            fakeImm_wd6,
    (BOOL (WINAPI* /*ImmEnumInputContext*/)(
         DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam))  fakeImm_wd3,

    (LRESULT (WINAPI* /*ImmSystemHandler*/)(HIMC, WPARAM, LPARAM))
                                                             fakeImm_wd3,
#ifdef CUAS_ENABLE
    // Cicero
    (HRESULT (WINAPI* /* CtfImmTIMActivate*/)(HKL))             fakeImm_wd1,
    (VOID  (WINAPI* /* CtfImmRestoreToolbarWnd*/)(DWORD))       fakeImm_vd1,
    (DWORD (WINAPI* /* CtfImmHideToolbarWnd*/)(VOID))           fakeImm_dv1,
    (LRESULT (WINAPI* /* CtfImmDispatchDefImeMessage*/)(HWND, UINT, WPARAM, LPARAM))          fakeImm_bwuwl,
#endif // CUAS_ENABLE
};


//
// Imm32's instance handle
//
// NULL if not initialized.
//

HMODULE ghImm32;

#define IMMMODULENAME L"IMM32.DLL"
#define PATHDLM     L'\\'
#define IMMMODULENAMELEN    ((sizeof PATHDLM + sizeof IMMMODULENAME) / sizeof(WCHAR))

VOID GetImmFileName(PWSTR wszImmFile)
{
    UINT i = GetSystemDirectoryW(wszImmFile, MAX_PATH);
    if (i > 0 && i < MAX_PATH - IMMMODULENAMELEN) {
        wszImmFile += i;
        if (wszImmFile[-1] != PATHDLM) {
            *wszImmFile++ = PATHDLM;
        }
    }
    wcscpy(wszImmFile, IMMMODULENAME);
}

#define REGISTER(name,cast) \
    gImmApiEntries.name = (cast)GetProcAddress(hImm, #name); \
    if (gImmApiEntries.name == NULL) { \
        RIPMSG1(RIP_WARNING, "gImmApiEntries.%s got to be NULL", #name); \
        gImmApiEntries.name = (PVOID)fakeImm_v1; \
        return; \
    } else

///////////////////////////////////////////////////////
// _InitializeImmEntryTable(HMODULE)
//
//  Initialize IMM entry table:
///////////////////////////////////////////////////////
VOID _InitializeImmEntryTable(VOID)
{
    HMODULE hImm = ghImm32;
    WCHAR wszImmFile[MAX_PATH];

    if (((PVOID)gImmApiEntries.ImmWINNLSEnableIME) != ((PVOID)fakeImm_wd2)) {
        // already initialized.
        return;
    }

    GetImmFileName(wszImmFile);

    if (hImm == NULL) {
        // check if IMM DLL is already attached to the process
        hImm = GetModuleHandleW(wszImmFile);
    }

    if (hImm == NULL) {
        hImm = ghImm32 = LoadLibraryW(wszImmFile);
        if (hImm == NULL) {
            RIPMSG1(RIP_WARNING, "_InitializeImmEntryTable: failed to load Imm32.Dll: err=%d\n", GetLastError());
            return;
        }

        // at this point, Init routine of IMM32 has been called, thus User32InitializeImmEntry.. called.
        // all what we have to do is just return here.
        return;
    }

    if (hImm == NULL) {
        RIPMSG0(RIP_WARNING, "Failed to attach IMM32.DLL.\n");
        return;
    }

    // get the addresses of the procedures
    REGISTER(ImmWINNLSEnableIME, BOOL (WINAPI*)(HWND, BOOL));
    REGISTER(ImmWINNLSGetEnableStatus, BOOL (*)(HWND));
    REGISTER(ImmSendIMEMessageExW, LRESULT (*)(HWND, LPARAM));
    REGISTER(ImmSendIMEMessageExA, LRESULT (*)(HWND, LPARAM));
    REGISTER(ImmIMPGetIMEW, BOOL(*)(HWND, LPIMEPROW));
    REGISTER(ImmIMPGetIMEA, BOOL(*)(HWND, LPIMEPROA))
    REGISTER(ImmIMPQueryIMEW, BOOL(*)(LPIMEPROW))
    REGISTER(ImmIMPQueryIMEA, BOOL(*)(LPIMEPROA));
    REGISTER(ImmIMPSetIMEW, BOOL(*)(HWND, LPIMEPROW));
    REGISTER(ImmIMPSetIMEA, BOOL(*)(HWND, LPIMEPROA));

    REGISTER(ImmAssociateContext, HIMC (WINAPI*)(HWND, HIMC));
    REGISTER(ImmEscapeA, LRESULT(WINAPI*)(HKL, HIMC, UINT, LPVOID));
    REGISTER(ImmEscapeW, LRESULT(WINAPI*)(HKL, HIMC, UINT, LPVOID));
    REGISTER(ImmGetCompositionStringA, LONG (WINAPI*)(HIMC, DWORD, LPVOID, DWORD));
    REGISTER(ImmGetCompositionStringW, LONG (WINAPI*)(HIMC, DWORD, LPVOID, DWORD));
    REGISTER(ImmGetCompositionWindow, BOOL (WINAPI*)(HIMC, LPCOMPOSITIONFORM));
    REGISTER(ImmGetContext, HIMC (WINAPI*)(HWND));
    REGISTER(ImmGetDefaultIMEWnd, HWND (WINAPI*)(HWND));
    REGISTER(ImmIsIME, BOOL (WINAPI*)(HKL));
    REGISTER(ImmReleaseContext, BOOL (WINAPI*)(HWND, HIMC));
    REGISTER(ImmRegisterClient, BOOL(*)(PSHAREDINFO, HINSTANCE));

    REGISTER(ImmGetCompositionFontW, BOOL (WINAPI*)(HIMC, LPLOGFONTW));
    REGISTER(ImmGetCompositionFontA, BOOL (WINAPI*)(HIMC, LPLOGFONTA));
    REGISTER(ImmSetCompositionFontW, BOOL (WINAPI*)(HIMC, LPLOGFONTW));
    REGISTER(ImmSetCompositionFontA, BOOL (WINAPI*)(HIMC, LPLOGFONTA));

    REGISTER(ImmSetCompositionWindow, BOOL(WINAPI*)(HIMC, LPCOMPOSITIONFORM));
    REGISTER(ImmNotifyIME, BOOL (WINAPI*)(HIMC, DWORD, DWORD, DWORD));
    REGISTER(ImmLockIMC, PINPUTCONTEXT(WINAPI*)(HIMC));
    REGISTER(ImmUnlockIMC, BOOL (WINAPI*)(HIMC));
    REGISTER(ImmLoadIME, BOOL (WINAPI*)(HKL));
    REGISTER(ImmSetOpenStatus, BOOL (WINAPI*)(HIMC, BOOL));
    REGISTER(ImmFreeLayout, BOOL (WINAPI*)(DWORD));
    REGISTER(ImmActivateLayout, BOOL (WINAPI*)(HKL));
    REGISTER(ImmGetCandidateWindow, BOOL (WINAPI*)(HIMC, DWORD, LPCANDIDATEFORM));
    REGISTER(ImmSetCandidateWindow, BOOL (WINAPI*)(HIMC, LPCANDIDATEFORM));
    REGISTER(ImmConfigureIMEW, BOOL (WINAPI*)(HKL, HWND, DWORD, LPVOID));
    REGISTER(ImmGetConversionStatus, BOOL (WINAPI*)(HIMC, LPDWORD, LPDWORD));
    REGISTER(ImmSetConversionStatus, BOOL (WINAPI*)(HIMC, DWORD, DWORD));
    REGISTER(ImmSetStatusWindowPos, BOOL (WINAPI*)(HIMC, LPPOINT));
    REGISTER(ImmGetImeInfoEx, BOOL (WINAPI*)(PIMEINFOEX, IMEINFOEXCLASS, PVOID));
    REGISTER(ImmLockImeDpi, PIMEDPI (WINAPI*)(HKL));
    REGISTER(ImmUnlockImeDpi, VOID (WINAPI*)(PIMEDPI));
    REGISTER(ImmGetOpenStatus, BOOL (WINAPI*)(HIMC));
    REGISTER(ImmSetActiveContext, BOOL (*)(HWND, HIMC, BOOL));
    REGISTER(ImmTranslateMessage, BOOL (*)(HWND, UINT, WPARAM, LPARAM));
    REGISTER(ImmLoadLayout, BOOL (*)(HKL, PIMEINFOEX));
    REGISTER(ImmProcessKey, DWORD (*)(HWND, HKL, UINT, LPARAM, DWORD));
    REGISTER(ImmPutImeMenuItemsIntoMappedFile, LRESULT(*)(HIMC));
    REGISTER(ImmGetProperty, DWORD (WINAPI*)(HKL, DWORD));
    REGISTER(ImmSetCompositionStringA,
             BOOL (WINAPI*)(HIMC hImc, DWORD dwIndex, LPCVOID lpComp,
                   DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen))
    REGISTER(ImmSetCompositionStringW,
             BOOL (WINAPI*)(HIMC hImc, DWORD dwIndex, LPCVOID lpComp,
                   DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen));
    REGISTER(ImmEnumInputContext,
             BOOL (WINAPI*)(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam));
    REGISTER(ImmSystemHandler,
            LRESULT (WINAPI*)(HIMC, WPARAM, LPARAM));

#ifdef CUAS_ENABLE
    // Cicero
    REGISTER(CtfImmTIMActivate, HRESULT (WINAPI*)(HKL));
    REGISTER(CtfImmRestoreToolbarWnd, VOID (WINAPI*)(DWORD));
    REGISTER(CtfImmHideToolbarWnd, DWORD (WINAPI*)(VOID));
    REGISTER(CtfImmDispatchDefImeMessage, LRESULT (WINAPI*)(HWND, UINT, WPARAM, LPARAM));
#endif // CUAS_ENABLE
}

BOOL bImmInitializing = FALSE;

VOID InitializeImmEntryTable(VOID)
{
    bImmInitializing = TRUE;
    _InitializeImmEntryTable();
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, User32InitializeImmEntryTable, DWORD, magic)
BOOL User32InitializeImmEntryTable(DWORD magic)
{
    if (magic != IMM_MAGIC_CALLER_ID) {
        RIPMSG1(RIP_WARNING, "User32InitializeImmEntryTable: magic # does not match: 0x%08x", magic);
        return FALSE;
    }

    if (((PVOID)gImmApiEntries.ImmWINNLSEnableIME) != ((PVOID)fakeImm_wd2)) {
        // already initialized
        return TRUE;
    }

    _InitializeImmEntryTable();

    if (ghImm32 == NULL) {
        if (!bImmInitializing) {
            // increment the load counter of IMM32.DLL; application may call FreeLibrary later
            WCHAR wszImmFile[MAX_PATH];
            GetImmFileName(wszImmFile);
            ghImm32 = LoadLibraryW(wszImmFile);
        }
    }
    // for IMM initialization
    return fpImmRegisterClient(&gSharedInfo, ghImm32);
}

//
// for historical reasons, these entries are put in user32.dll
//

FUNCLOG1(LOG_GENERAL, UINT, WINAPI, WINNLSGetIMEHotkey, HWND, hwndIme)
UINT WINAPI WINNLSGetIMEHotkey(HWND hwndIme)
{
    UNREFERENCED_PARAMETER(hwndIme);

    //
    // Win95/NT3.51 behavior, i.e. always return 0.
    //
    return 0;
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, WINNLSEnableIME, HWND, hwnd, BOOL, bFlag)
BOOL WINAPI WINNLSEnableIME(HWND hwnd, BOOL bFlag)
{
    return gImmApiEntries.ImmWINNLSEnableIME(hwnd, bFlag);
}


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, WINNLSGetEnableStatus, HWND, hwnd)
BOOL WINAPI WINNLSGetEnableStatus(HWND hwnd)
{
    return gImmApiEntries.ImmWINNLSGetEnableStatus(hwnd);
}


FUNCLOG2(LOG_GENERAL, LRESULT, WINAPI, SendIMEMessageExW, HWND, hwnd, LPARAM, lParam)
LRESULT WINAPI SendIMEMessageExW(HWND hwnd, LPARAM lParam)
{
    return gImmApiEntries.ImmSendIMEMessageExW(hwnd, lParam);
}


FUNCLOG2(LOG_GENERAL, LRESULT, WINAPI, SendIMEMessageExA, HWND, hwnd, LPARAM, lParam)
LRESULT WINAPI SendIMEMessageExA(HWND hwnd, LPARAM lParam)
{
    return gImmApiEntries.ImmSendIMEMessageExA(hwnd, lParam);
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, IMPGetIMEW, HWND, hwnd, LPIMEPROW, lpImeProW)
BOOL WINAPI IMPGetIMEW(HWND hwnd, LPIMEPROW lpImeProW)
{
    return gImmApiEntries.ImmIMPGetIMEW(hwnd, lpImeProW);
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, IMPGetIMEA, HWND, hwnd, LPIMEPROA, lpImeProA)
BOOL WINAPI IMPGetIMEA(HWND hwnd, LPIMEPROA lpImeProA)
{
    return gImmApiEntries.ImmIMPGetIMEA(hwnd, lpImeProA);
}


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IMPQueryIMEW, LPIMEPROW, lpImeProW)
BOOL WINAPI IMPQueryIMEW(LPIMEPROW lpImeProW)
{
    return gImmApiEntries.ImmIMPQueryIMEW(lpImeProW);
}


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IMPQueryIMEA, LPIMEPROA, lpImeProA)
BOOL WINAPI IMPQueryIMEA(LPIMEPROA lpImeProA)
{
    return gImmApiEntries.ImmIMPQueryIMEA(lpImeProA);
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, IMPSetIMEW, HWND, hwnd, LPIMEPROW, lpImeProW)
BOOL WINAPI IMPSetIMEW(HWND hwnd, LPIMEPROW lpImeProW)
{
    return gImmApiEntries.ImmIMPSetIMEW(hwnd, lpImeProW);
}


FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, IMPSetIMEA, HWND, hwnd, LPIMEPROA, lpImeProA)
BOOL WINAPI IMPSetIMEA(HWND hwnd, LPIMEPROA lpImeProA)
{
    return gImmApiEntries.ImmIMPSetIMEA(hwnd, lpImeProA);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\getsetc.c ===
/****************************** Module Header ******************************\
* Module Name: getsetc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains window manager information routines
*
* History:
* 10-Mar-1993 JerrySh   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _GetWindowWord (supports the GetWindowWord API)
*
* Return a window word.  Positive index values return application window words
* while negative index values return system window words.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 11-26-90 darrinm      Wrote.
\***************************************************************************/

WORD _GetWindowWord(
    PWND pwnd,
    int index)
{
    if (GETFNID(pwnd) != 0) {
        if ((index >= 0) && (index <
                (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {

            switch (GETFNID(pwnd)) {
            case FNID_MDICLIENT:
                if (index == 0)
                    break;
                goto DoDefault;

            case FNID_BUTTON:
                /*
                 * CorelDraw does a get/set on the first button window word.
                 * Allow it to.
                 */
                if (index == 0) {
                    /*
                     *  Since we now use a lookaside buffer for the control's
                     *  private data, we need to indirect into this structure.
                     */
                    PBUTN pbutn = ((PBUTNWND)pwnd)->pbutn;
                    if (!pbutn || (LONG_PTR)pbutn == (LONG_PTR)-1) {
                        return 0;
                    } else {
                        return (WORD)(pbutn->buttonState);
                    }
                }
                goto DoDefault;

            case FNID_DIALOG:
                if (index == DWLP_USER)
                    return LOWORD(((PDIALOG)pwnd)->unused);
                if (index == DWLP_USER+2)
                    return HIWORD(((PDIALOG)pwnd)->unused);
                goto DoDefault;

            default:
DoDefault:
                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "GetWindowWord: Trying to read private server data pwnd=(%#p) index=(%ld) fnid=(%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
                break;
            }
        }
    }

    if (index == GWLP_USERDATA)
        return (WORD)pwnd->dwUserData;

    if ((index < 0) || ((UINT)index + sizeof(WORD) > (UINT)pwnd->cbwndExtra)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    } else {
        return *((WORD UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pwnd + 1) + index));
    }
}

ULONG_PTR GetWindowData(PWND pwnd, int index, BOOL bAnsi);

/***************************************************************************\
* _GetWindowLong (supports GetWindowLongA/W API)
*
* Return a window long.  Positive index values return application window longs
* while negative index values return system window longs.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 11-26-90 darrinm      Wrote.
\***************************************************************************/

ULONG_PTR _GetWindowLongPtr(
    PWND pwnd,
    int index,
    BOOL bAnsi)
{
    ULONG_PTR           dwProc;
    DWORD              dwCPDType = 0;
    ULONG_PTR UNALIGNED * KPTR_MODIFIER pudw;

    /*
     * If it's a dialog window, only a few indices are permitted.
     */
    if (GETFNID(pwnd) != 0) {
        if (TestWF(pwnd, WFDIALOGWINDOW)) {
            switch (index) {
            case DWLP_DLGPROC:    // See similar case GWLP_WNDGPROC

                /*
                 * Hide the window proc from other processes
                 */
                if (!TestWindowProcess(pwnd)) {
                    RIPERR1(ERROR_ACCESS_DENIED,
                            RIP_WARNING,
                            "Access denied to \"pwnd\" (%#p) in _GetWindowLong",
                            pwnd);

                    return 0;
                }

                dwProc = (ULONG_PTR)PDLG(pwnd)->lpfnDlg;

                /*
                 * If a proc exists check it to see if we need a translation
                 */
                if (dwProc) {

                    /*
                     * May need to return a CallProc handle if there is an
                     * Ansi/Unicode transition
                     */
                    if (bAnsi != ((PDLG(pwnd)->flags & DLGF_ANSI) ? TRUE : FALSE)) {
                        dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
                    }

                    if (dwCPDType) {
                        ULONG_PTR cpd;

                        cpd = GetCPD(pwnd, dwCPDType | CPD_DIALOG, dwProc);

                        if (cpd) {
                            dwProc = cpd;
                        } else {
                            RIPMSG0(RIP_WARNING, "GetWindowLong unable to alloc CPD returning handle\n");
                        }
                    }
                }

                /*
                 * return proc (or CPD handle)
                 */
                return dwProc;

            case DWLP_MSGRESULT:
                 return (ULONG_PTR)((PDIALOG)pwnd)->resultWP;

            case DWLP_USER:
                 return (ULONG_PTR)((PDIALOG)pwnd)->unused;

            default:
                if (index >= 0 && index < DLGWINDOWEXTRA) {
                    RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                    return 0;
                }
            }
        } else {
            if (index >= 0 &&
                    (index < (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {
                switch (GETFNID(pwnd)) {
                case FNID_MDICLIENT:
                    /*
                     * Allow the 0 index (which is reserved) to be set/get.
                     * Quattro Pro 1.0 uses this index!
                     */
                    if (index != 0)
                        break;

                    goto GetData;
                    break;

                case FNID_EDIT:

                    if (index != 0)
                        break;

                    /*
                     * If we get to this point we need to return the first
                     * entry in the lookaside.  This will provide backward
                     * compatibilty for 3.51 that allowed edit-controls to
                     * do this.  PeachTree is one app which required this.
                     */
                    pudw = (ULONG_PTR UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pwnd + 1));

                    /*
                     * Do not dereference the pointer if we are not in
                     *  the proper address space. Apps like Spyxx like to
                     *  do this on other process' windows
                     */
                    return (TestWindowProcess(pwnd) ? *(ULONG_PTR UNALIGNED *)*pudw : (ULONG_PTR)pudw);

                }

                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "GetWindowLong: Trying to read private server data pwnd=(%#p) index=(%ld) fnid (%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
            }
        }
    }

    if (index < 0) {
        return GetWindowData(pwnd, index, bAnsi);
    } else {
        if ((UINT)index + sizeof(ULONG_PTR) > (UINT)pwnd->cbwndExtra) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return 0;
        } else {

GetData:
            pudw = (ULONG_PTR UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pwnd + 1) + index);
            return *pudw;
        }
    }
}


#ifdef _WIN64
DWORD _GetWindowLong(
    PWND pwnd,
    int index,
    BOOL bAnsi)
{
    DWORD UNALIGNED * KPTR_MODIFIER pudw;

    /*
     * If it's a dialog window, only a few indices are permitted.
     */
    if (GETFNID(pwnd) != 0) {
        if (TestWF(pwnd, WFDIALOGWINDOW)) {
            switch (index) {
            case DWLP_DLGPROC:    // See similar case GWLP_WNDPROC
                RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "GetWindowLong: invalid index %d", index);
                return 0;

            case DWLP_MSGRESULT:
                 return (DWORD)((PDIALOG)pwnd)->resultWP;

            case DWLP_USER:
                 return (DWORD)((PDIALOG)pwnd)->unused;

            default:
                if (index >= 0 && index < DLGWINDOWEXTRA) {
                    RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                    return 0;
                }
            }
        } else {
            if (index >= 0 &&
                    (index < (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {
                switch (GETFNID(pwnd)) {
                case FNID_MDICLIENT:
                    /*
                     * Allow the 0 index (which is reserved) to be set/get.
                     * Quattro Pro 1.0 uses this index!
                     */
                    if (index != 0)
                        break;

                    goto GetData;
                    break;

                case FNID_EDIT:

                    if (index != 0)
                        break;

                    /*
                     * If we get to this point we need to return the first
                     * entry in the lookaside.  This will provide backward
                     * compatibilty for 3.51 that allowed edit-controls to
                     * do this.  PeachTree is one app which required this.
                     */
                    pudw = (DWORD UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pwnd + 1));

                    /*
                     * Do not dereference the pointer if we are not in
                     *  the proper address space. Apps like Spyxx like to
                     *  do this on other process' windows
                     */
                    return (TestWindowProcess(pwnd) ? *(DWORD UNALIGNED *)*(ULONG_PTR UNALIGNED *)pudw : PtrToUlong(pudw));


                }

                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "GetWindowLong: Trying to read private server data pwnd=(%#p) index=(%ld) fnid (%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
            }
        }
    }

    if (index < 0) {
        if ((index != GWL_STYLE) && (index != GWL_EXSTYLE) && (index != GWL_ID) && (index != GWLP_USERDATA)) {
            RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "GetWindowLong: invalid index %d", index);
            return 0;
        }
        return (DWORD)GetWindowData(pwnd, index, bAnsi);
    } else {
        if ((UINT)index + sizeof(DWORD) > (UINT)pwnd->cbwndExtra) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return 0;
        } else {

GetData:
            pudw = (DWORD UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pwnd + 1) + index);
            return *pudw;
        }
    }
}
#endif


/***************************************************************************\
* GetWindowData
*
* History:
* 11-26-90 darrinm      Wrote.
\***************************************************************************/

ULONG_PTR GetWindowData(
    PWND pwnd,
    int index,
    BOOL bAnsi)
{
    KERNEL_ULONG_PTR dwProc;
    DWORD dwCPDType = 0;
    PWND pwndParent;

    switch (index) {
    case GWLP_USERDATA:
        return KERNEL_ULONG_PTR_TO_ULONG_PTR(pwnd->dwUserData);

    case GWL_EXSTYLE:
        /*
         * Apps should not mess with unused bits.  We use them privately
         */
        return pwnd->ExStyle & WS_EX_ALLVALID;

    case GWL_STYLE:
        return pwnd->style;

    case GWLP_ID:
        if (TestwndChild(pwnd)) {
            return (ULONG_PTR)pwnd->spmenu;
        } else if (pwnd->spmenu != NULL) {
            PMENU pmenu;

            pmenu = REBASEALWAYS(pwnd, spmenu);
            return (ULONG_PTR)PtoH(pmenu);
        }
        return 0;

    case GWLP_HINSTANCE:
        return (ULONG_PTR)pwnd->hModule;

    case GWLP_WNDPROC: // See similar case DWLP_DLGPROC
        /*
         * Hide the window proc from other processes
         */
        if (!TestWindowProcess(pwnd)) {
            RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING, "Can not subclass another process's window %#p", pwnd);
            return 0;
        }

        /*
         * If the client queries a server-side winproc we return the
         * address of the client-side winproc (expecting ANSI or Unicode
         * depending on bAnsi)
         */
        if (TestWF(pwnd, WFSERVERSIDEPROC)) {
            dwProc = MapServerToClientPfn((KERNEL_ULONG_PTR)pwnd->lpfnWndProc, bAnsi);
            if (dwProc == 0)
                RIPMSG1(RIP_WARNING, "GetWindowLong: GWL_WNDPROC: Kernel-side wndproc can't be mapped for pwnd=%#p", pwnd);
        } else {

            /*
             * Keep edit control behavior compatible with NT 3.51.
             */
            if (GETFNID(pwnd) == FNID_EDIT) {
                dwProc = (ULONG_PTR)MapKernelClientFnToClientFn(pwnd->lpfnWndProc);
                goto CheckAnsiUnicodeMismatch;
            } else {
                PCLS pcls = REBASEALWAYS(pwnd, pcls);
                dwProc = MapClientNeuterToClientPfn(pcls, (KERNEL_ULONG_PTR)pwnd->lpfnWndProc, bAnsi);
            }

            /*
             * If the client mapping didn't change the window proc then see if
             * we need a callproc handle.
             */
            if (dwProc == (KERNEL_ULONG_PTR)pwnd->lpfnWndProc) {
CheckAnsiUnicodeMismatch:
                /*
                 * Need to return a CallProc handle if there is an Ansi/Unicode mismatch
                 */
                if (bAnsi != (TestWF(pwnd, WFANSIPROC) ? TRUE : FALSE)) {
                    dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
                }
            }

            if (dwCPDType) {
                ULONG_PTR cpd;

                cpd = GetCPD(pwnd, dwCPDType | CPD_WND, KERNEL_ULONG_PTR_TO_ULONG_PTR(dwProc));

                if (cpd) {
                    dwProc = cpd;
                } else {
                    RIPMSG0(RIP_WARNING, "GetWindowLong unable to alloc CPD returning handle\n");
                }
            }
        }

        /*
         * return proc (or CPD handle)
         */
        return KERNEL_ULONG_PTR_TO_ULONG_PTR(dwProc);

    case GWLP_HWNDPARENT:

        /*
         * If the window is the desktop window, return
         * NULL to keep it compatible with Win31 and
         * to prevent any access to the desktop owner
         * window.
         */
        if (GETFNID(pwnd) == FNID_DESKTOP) {
            return 0;
        }

        /*
         * Special case for pre-1.1 versions of Windows
         * Set/GetWindowWord(GWL_HWNDPARENT) needs to be mapped
         * to the hwndOwner for top level windows.
         *
         * Note that we find the desktop window through the
         * pti because the PWNDDESKTOP macro only works in
         * the server.
         */

        /*
         * Remove this test when we later add a test for WFDESTROYED
         * in Client handle validation.
         */
        if (pwnd->spwndParent == NULL) {
            return 0;
        }
        pwndParent = REBASEALWAYS(pwnd, spwndParent);
        if (GETFNID(pwndParent) == FNID_DESKTOP) {
            pwnd = REBASEPWND(pwnd, spwndOwner);
            return (ULONG_PTR)HW(pwnd);
        }

        return (ULONG_PTR)HW(pwndParent);

    /*
     * WOW uses a pointer straight into the window structure.
     */
    case GWLP_WOWWORDS:
        return (ULONG_PTR) &pwnd->state;

    }

    RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
    return 0;
}

#ifdef GENERIC_INPUT

FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetRawInputBuffer, PRAWINPUT, pData, PUINT, pcbSize, UINT, cbSizeHeader)
UINT GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader)
{
    CLIENTTHREADINFO *pcti;

    pcti = GETCLIENTTHREADINFO();

    // Validate parameters
    if (pcbSize == NULL || cbSizeHeader != sizeof(RAWINPUTHEADER)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return -1;
    }

    // Don't even go into the kernel if there's no reason to
    if (pcti == NULL || (pcti->fsWakeBits & QS_RAWINPUT) == 0) {
        *pcbSize = 0;
        return 0;
    }

    return NtUserGetRawInputBuffer(pData, pcbSize, cbSizeHeader);
}
#endif // GENERIC_INPUT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\fntsweep.c ===
/******************************Module*Header*******************************\
* Module Name: fntsweep.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* This file contains font sweeper related stuff.
* On the boot of ths system, i.e.  initialization of userk, the
* [Fonts] section of win.ini is checked to
* find out if any new fonts have been added by any font installers.
* If third party installers have installed fonts in the system directory
* those are copied to fonts directory. Any fot entries are replaced
* by appropriate *.ttf entries, any fot files are deleted if they were
* ever installed.
*
\**************************************************************************/


#include "precomp.h"
#pragma hdrstop
#include <setupbat.h>      // in sdkinc

CONST WCHAR pwszType1Key[]      = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\Type 1 Fonts";
CONST WCHAR pwszSweepType1Key[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\LastType1Sweep";
CONST WCHAR pwszUpdType1Key[]   = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\Upgraded Type1";

CONST WCHAR pwszFontsKey[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
CONST WCHAR pwszSweepKey[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\LastFontSweep";
CONST WCHAR pwszFontDrivers[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Font Drivers";

#define LAST_SWEEP_TIME L"LastSweepTime"
#define UPGRADED_TYPE1 L"UpgradedType1"

#define DWORDALIGN(X) (((X) + 3) & ~3)

WCHAR *gpwcSystemDir;
WCHAR *gpwcFontsDir;
BOOL   gbWin31Upgrade;


BOOL bCheckIfDualBootingWithWin31()
{
    WCHAR Buffer[32];
    WCHAR awcWindowsDir[MAX_PATH];
    DWORD dwRet;
    UINT  cwchWinPath;

    awcWindowsDir[0] = L'\0'; // prefix:make sure to zero terminated
    cwchWinPath = GetSystemWindowsDirectoryW(awcWindowsDir, MAX_PATH);

    if ((cwchWinPath == 0) || (cwchWinPath > MAX_PATH))
        return FALSE;

// the cwchWinPath value does not include the terminating zero

    if (awcWindowsDir[cwchWinPath - 1] == L'\\')
    {
        cwchWinPath -= 1;
    }
    awcWindowsDir[cwchWinPath] = L'\0'; // make sure to zero terminated

    lstrcatW(awcWindowsDir, L"\\system32\\");
    lstrcatW(awcWindowsDir, WINNT_GUI_FILE_W);

    dwRet = GetPrivateProfileStringW(
                WINNT_DATA_W,
                WINNT_D_WIN31UPGRADE_W,
                WINNT_A_NO_W,
                Buffer,
                sizeof(Buffer)/sizeof(WCHAR),
                awcWindowsDir
                );

    #if DBGSWEEP
    DbgPrint("\n dwRet = %ld, win31upgrade = %ws\n\n", dwRet, Buffer);
    #endif

    return (BOOL)(dwRet ? (!lstrcmpiW(Buffer,WINNT_A_YES)) : 0);
}


/******************************Public*Routine******************************\
*
* VOID vNullTermWideString (WCHAR *pwcDest, WCHAR *pwcSrc, ULONG ulLength)
*
* Given pwcSrc, which is not necessarily null-terminated, copy ulLength characters
* the into pwcDest and place a null character after it.
*
* History:
*  03-Feb-99 -by- Donald Chinn [dchinn]
* Wrote it.
\**************************************************************************/
VOID vNullTermWideString (WCHAR *pwcDest, WCHAR *pwcSrc, ULONG ulLength)
{
    ULONG index;

    for (index = 0; index < ulLength; index++) {
        *pwcDest++ = *pwcSrc++;
    }
    *pwcDest = '\0';
}


/******************************Public*Routine******************************\
*
* BOOL bCheckFontEntry(WCHAR *pwcName, WCHAR *pwcExtension)
*
* This function assumes that both pwcName and pwcExtension are null-terminated.
*
* History:
*  25-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL bCheckFontEntry(WCHAR *pwcName, WCHAR *pwcExtension)
{
    BOOL bRet = FALSE;
    LONG cwc = (LONG)wcslen(pwcName) - (LONG)wcslen(pwcExtension);
    if (cwc > 0)
    {
        bRet = !_wcsicmp(&pwcName[cwc], pwcExtension);
    }
    return bRet;

}



/******************************Public*Routine******************************\
*   Process win.ini line
*
* History:
*  24-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define EXT_TRUETYPE  L"(TrueType)"
#define EXT_FOT       L".FOT"


VOID vProcessFontEntry(
    HKEY   hkey,
    WCHAR *pwcValueName,
    ULONG ulValueNameLength,
    WCHAR *pwcFileName,
    ULONG ulFileNameLength
)
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    BOOL  bFot = FALSE;
    WCHAR awcTTF[MAX_PATH];
    WCHAR awcTmpBuf[MAX_PATH];
    WCHAR *pwcTTF;
    FLONG fl, fl2;
    FLONG flEmbed;
    DWORD dwPidTid;
    WCHAR awcValueName[MAX_PATH];  // null-terminated pwcValueName
    WCHAR awcFileName[MAX_PATH];   // null-terminated pwcFileName
    

    // Make sure the ValueName is null-terminated
    ulValueNameLength = min(MAX_PATH - 1, ulValueNameLength);
    vNullTermWideString (awcValueName, pwcValueName, ulValueNameLength);
    
    // Make sure the FileName is null-terminated
    ulFileNameLength = min(MAX_PATH - 1, ulFileNameLength);
    vNullTermWideString (awcFileName, pwcFileName, ulFileNameLength);
    
    if (bCheckFontEntry(awcValueName, EXT_TRUETYPE))
    {
    // This is a tt entry, either .fot or .ttf

        if (bFot = bCheckFontEntry(awcFileName, EXT_FOT))
        {
        // this is an .fot entry, must find ttf pointed to by .fot,
        // but first must get the full path to the .fot file
        // for cGetTTFFromFOT routine expects it. We will also need
        // the full path to the .fot file so that we can delete it
        // eventually.

            if (bMakePathNameW(awcTmpBuf, awcFileName, NULL, &fl2))
            {
                if (cGetTTFFromFOT(awcTmpBuf, MAX_PATH, awcTTF, &fl, &flEmbed, &dwPidTid, TRUE) &&
                    !(fl & FONT_ISNOT_FOT))
                {
                // fix the entry to point to .ttf file. At this point
                // awcTTF points to the FULL path to the .ttf file.
                // However, we will only need a relative path to the
                // .ttf file, when the .ttf file is in the %windir%\system
                // or %windir%\fonts directories. In case the file is in the
                // %windir%\system directory we shall copy it to %windir%\fonts
                // directory and write the relative path to the registry.
                // In case it is in the %windir%\fonts directory we do not
                // touch the file and also just write the relative path to the
                // registry. In any other case we just write the full .ttf
                // path to the registry.

                // first delete the .fot file, it is no longer needed

                    if (bFot && !gbWin31Upgrade)
                    {
                        UserVerify(DeleteFileW(awcTmpBuf));
                    }

                    if ((fl & (FONT_IN_FONTS_DIR | FONT_IN_SYSTEM_DIR)) == 0)
                    {
                    // if ttf file is not in either the system or the fonts
                    // directories, just write the full path to the registry

                        pwcTTF = awcTTF;
                    }
                    else
                    {
                    // find the bare file part, this is what will be written
                    // in the registry

                        pwcTTF = &awcTTF[wcslen(awcTTF) - 1];
                        while ((pwcTTF >= awcTTF) && (*pwcTTF != L'\\') && (*pwcTTF != L':'))
                            pwcTTF--;
                        pwcTTF++;

                        if (fl & FONT_IN_SYSTEM_DIR)
                        {
                        // need to move the ttf to fonts dir, can reuse the
                        // buffer on the stack:

                            wcscpy(awcTmpBuf, gpwcFontsDir);
                            lstrcatW(awcTmpBuf, L"\\");
                            lstrcatW(awcTmpBuf, pwcTTF);

                        // note that MoveFile should succeed, for if there was
                        // a ttf file of the same file name in %windir%\fonts dir
                        // we would not have been in this code path.

                                RIPMSG2(RIP_VERBOSE, "Moving %ws to %ws", awcTTF, awcTmpBuf);
                                if (!gbWin31Upgrade)
                                {
                                    UserVerify(MoveFileW(awcTTF, awcTmpBuf));
                                }
                                else
                                {
                                // Boolean value TRUE means "do not copy if target exists"

                                    UserVerify(CopyFileW(awcTTF, awcTmpBuf, TRUE));
                                }
                        }
                    }

                    RIPMSG2(RIP_VERBOSE, "writing to the registry:\n    %ws=%ws", pwcValueName, pwcTTF);
                    RtlInitUnicodeString(&UnicodeString, awcValueName);
                    Status = NtSetValueKey(hkey,
                                           &UnicodeString,
                                           0,
                                           REG_SZ,
                                           pwcTTF,
                                           (wcslen(pwcTTF)+1) * sizeof(WCHAR));
                    UserAssert(NT_SUCCESS(Status));
                }
                #if DBG
                else
                {
                    RIPMSG1(RIP_WARNING, "Could not locate ttf pointed to by %ws", awcTmpBuf);
                }
                #endif
            }
            #if DBG
            else
            {
                RIPMSG1(RIP_WARNING, "Could not locate .fot:  %ws", awcFileName);
            }
            #endif
        }
    }
    else
    {
    // not a true type case. little bit simpler,
    // we will use awcTTF buffer for the full path name, and pwcTTF
    // as local variable even though these TTF names are misnomer
    // for these are not tt fonts

        if (bMakePathNameW(awcTTF, awcFileName,NULL, &fl))
        {
        // At this point
        // awcTTF points to the FULL path to the font file.

        // If the font is in the system subdirectory we will just move it
        // to the fonts subdirectory. If the path in the registry is relative
        // we will leave it alone. If it is an absolute path, we shall
        // fix the registry entry to only contain relative path, the
        // absolute path is redundant.

            if (fl & (FONT_IN_SYSTEM_DIR | FONT_IN_FONTS_DIR))
            {
            // find the bare file part, this is what will be written
            // in the registry

                pwcTTF = &awcTTF[wcslen(awcTTF) - 1];
                while ((pwcTTF >= awcTTF) && (*pwcTTF != L'\\') && (*pwcTTF != L':'))
                    pwcTTF--;
                pwcTTF++;

                if (fl & FONT_IN_SYSTEM_DIR)
                {
                // need to move the font to fonts dir, can reuse the
                // buffer on the stack to build the full destination path

                    wcscpy(awcTmpBuf, gpwcFontsDir);
                    lstrcatW(awcTmpBuf, L"\\");
                    lstrcatW(awcTmpBuf, pwcTTF);

                // note that MoveFile should succeed, for if there was
                // a font file of the same file name in %windir%\fonts dir
                // we would not have been in this code path. The only time
                // it could fail if the path in the registry is absolute.

                    RIPMSG2(RIP_VERBOSE, "Moving %ws to %ws", awcTTF, awcTmpBuf);
                    if (!gbWin31Upgrade)
                    {
                        UserVerify(MoveFileW(awcTTF, awcTmpBuf));
                    }
                    else
                    {
                    // Boolean value TRUE means "do not copy if target exists"

                        UserVerify(CopyFileW(awcTTF, awcTmpBuf, TRUE));
                    }
                }

            // check if the file path in the registry is absolute,
            // if so make it relative:

                if (!(fl & FONT_RELATIVE_PATH))
                {
                    RIPMSG2(RIP_VERBOSE, "writing to the registry:\n    %ws=%ws", pwcValueName, pwcTTF);
                    RtlInitUnicodeString(&UnicodeString, awcValueName);
                    Status = NtSetValueKey(hkey,
                                           &UnicodeString,
                                           0,
                                           REG_SZ,
                                           pwcTTF,
                                           (wcslen(pwcTTF)+1) * sizeof(WCHAR));
                    UserAssert(NT_SUCCESS(Status));
                }
            }
        }
    }
}


/******************************Public*Routine******************************\
*
* VOID vMoveFileFromSystemToFontsDir(WCHAR *pwcFile)
*
* History:
*  24-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




VOID vMoveFileFromSystemToFontsDir(WCHAR *pwcFile)
{
    WCHAR awcTmpBuf[MAX_PATH];
    WCHAR awcTmp[MAX_PATH];
    FLONG fl;
    WCHAR *pwcTmp;

#if DBG
    BOOL  bOk;
#endif

    if (bMakePathNameW(awcTmp, pwcFile,NULL, &fl))
    {
    // If the font is in the system subdirectory we will just move it
    // to the fonts subdirectory. The path in the registry is relative
    // and we will leave it alone.

        if
        (
            (fl & (FONT_IN_SYSTEM_DIR | FONT_RELATIVE_PATH)) ==
            (FONT_IN_SYSTEM_DIR | FONT_RELATIVE_PATH)
        )
        {
        // find the bare file part, this is what will be written
        // in the registry

            pwcTmp = &awcTmp[wcslen(awcTmp) - 1];
            while ((pwcTmp >= awcTmp) && (*pwcTmp != L'\\') && (*pwcTmp != L':'))
                pwcTmp--;

            if (pwcTmp > awcTmp)
                pwcTmp++;

        // need to move the font to fonts dir, can reuse the
        // buffer on the stack to build the full destination path

            wcscpy(awcTmpBuf, gpwcFontsDir);
            lstrcatW(awcTmpBuf, L"\\");
            lstrcatW(awcTmpBuf, pwcTmp);

        // note that MoveFile should succeed, for if there was
        // a font file of the same file name in %windir%\fonts dir
        // we would not have been in this code path.

            #if DBG
                bOk =
            #endif
                MoveFileW(awcTmp, awcTmpBuf);

            RIPMSG3(RIP_VERBOSE,
                    "move %ws to %ws %s",
                    awcTmp,
                    awcTmpBuf,
                    (bOk) ? "succeeded" : "failed");
        }
        #if DBG
        else
        {
            RIPMSG2(RIP_WARNING,
                    "File %ws not in system directory, fl = 0x%lx\n",
                    awcTmp, fl);
        }
        #endif

    }
    #if DBG
    else
    {
        RIPMSG1(RIP_WARNING, "Could not locate %ws", pwcFile);
    }
    #endif
}



/******************************Public*Routine******************************\
*
* VOID vProcessType1FontEntry
*
*
* Effects: All this routine does is to check if pwcPFM and pwcPFB pointed to
*          by pwcValueData point to files in the %windir%system directory
*          and if so copies these type 1 files to %windir%\fonts directory
*
* History:
*  20-Nov-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vProcessType1FontEntry(
    HKEY   hkey,
    WCHAR *pwcValueName,
    ULONG ulValueNameLength,
    WCHAR *pwcValueData,
    ULONG ulValueDataLength
)
{
    WCHAR *pwcPFM, *pwcPFB;

    UNREFERENCED_PARAMETER(hkey);
    UNREFERENCED_PARAMETER(pwcValueName);
    UNREFERENCED_PARAMETER(ulValueNameLength);
    UNREFERENCED_PARAMETER(ulValueDataLength);

// skip unused boolean value in this multi reg_sz string:

    if ((pwcValueData[0] != L'\0') && (pwcValueData[1] == L'\0'))
    {
        pwcPFM = &pwcValueData[2];
        pwcPFB = pwcPFM + wcslen(pwcPFM) + 1; // add 1 for zero separator

        vMoveFileFromSystemToFontsDir(pwcPFM);
        vMoveFileFromSystemToFontsDir(pwcPFB);
    }
}


/******************************Public*Routine******************************\
*
* VOID vAddRemote/LocalType1Font
*
* History:
*  25-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vAddType1Font(
    WCHAR *pwcValueData,
    DWORD  dwFlags
)
{
    WCHAR *pwcPFM, *pwcPFB, *pwcMMM;

    #if DBG
    int iRet;
    #endif

// skip unused boolean value in this multi reg_sz string:

    if ((pwcValueData[0] != L'\0') && (pwcValueData[1] == L'\0'))
    {
        pwcPFM = &pwcValueData[2];
        pwcPFB = pwcPFM + wcslen(pwcPFM) + 1; // add 1 for zero separator
        pwcMMM = pwcPFB + wcslen(pwcPFB) + 1; // may of may not be there.

    // replace space by separator and call addfontresourcew

        pwcPFB[-1] = PATH_SEPARATOR;

    // if this is a multiple master font, need one more separator:

        if (pwcMMM[0] != L'\0')
            pwcMMM[-1] = PATH_SEPARATOR;

        #if DBG
            iRet =
        #endif

        GdiAddFontResourceW(pwcPFM, dwFlags, NULL);

        #if DBGSWEEP
            DbgPrint("%ld = GdiAddFontResourceW(%ws, 0x%lx);\n",
                iRet, pwcPFM, dwFlags);
        #endif
    }
}


VOID vAddRemoteType1Font(
    HKEY   hkey,
    WCHAR *pwcValueName,
    ULONG ulValueNameLength,
    WCHAR *pwcValueData,
    ULONG ulValueDataLength
)
{
    UNREFERENCED_PARAMETER(hkey);
    UNREFERENCED_PARAMETER(pwcValueName);
    UNREFERENCED_PARAMETER(ulValueNameLength);
    UNREFERENCED_PARAMETER(ulValueDataLength);
    vAddType1Font(pwcValueData, AFRW_ADD_REMOTE_FONT);
}

VOID vAddLocalType1Font(
    HKEY   hkey,
    WCHAR *pwcValueName,
    ULONG ulValueNameLength,
    WCHAR *pwcValueData,
    ULONG ulValueDataLength
)
{
    UNREFERENCED_PARAMETER(hkey);
    UNREFERENCED_PARAMETER(pwcValueName);
    UNREFERENCED_PARAMETER(ulValueNameLength);
    UNREFERENCED_PARAMETER(ulValueDataLength);
    vAddType1Font(pwcValueData, AFRW_ADD_LOCAL_FONT);
}


typedef  VOID (*PFNENTRY)(HKEY hkey, WCHAR *, ULONG, WCHAR *, ULONG);


/******************************Public*Routine******************************\
*
* VOID vFontSweep()
*
* This is the main routine in this module. Checks if the fonts need to be
* "sweeped" and does so if need be.
*
* History:
*  27-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vSweepFonts(
    PCWSTR   pwszFontListKey,       // font list key
    PCWSTR   pwszFontSweepKey,      // the corresponding sweep key
    PFNENTRY pfnProcessFontEntry,   // function that processes individual entry
    BOOL     bForceEnum             // force enumeration
    )
{
    DWORD      cjMaxValueName;
    DWORD      iFont;
    NTSTATUS   Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjA;
    KEY_FULL_INFORMATION KeyInfo;
    DWORD      dwReturnLength;

    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
    BYTE       *pjValueData;

    HKEY       hkey = NULL;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION;
        LARGE_INTEGER;
    } SweepValueInfo;
    LARGE_INTEGER LastSweepTime;
    BOOL       bSweep = FALSE;

    HKEY       hkeyLastSweep;
    DWORD      cjData;

    if (!bForceEnum)
    {
    // first check if anything needs to be done, that is, if anybody
    // touched the [Fonts] section of the registry since the last time we sweeped it.
    // get the time of the last sweep of the fonts section of the registry:

        RtlInitUnicodeString(&UnicodeString, pwszFontSweepKey);
        InitializeObjectAttributes(&ObjA,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
        Status = NtOpenKey(&hkeyLastSweep,
                           KEY_READ | KEY_WRITE,
                           &ObjA);

        if (!NT_SUCCESS(Status))
        {
            DWORD  dwDisposition;

        // We are running for the first time, we need to create the key
        // for it does not exist as yet at this time

            bSweep = TRUE;

        // Create the key, open it for writing, since we will have to
        // store the time when the [Fonts] section of the registry was last swept

            Status = NtCreateKey(&hkeyLastSweep,
                                 KEY_WRITE,
                                 &ObjA,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 &dwDisposition);

            if (!NT_SUCCESS(Status))
                return;
        }
        else
        {
            RtlInitUnicodeString(&UnicodeString, LAST_SWEEP_TIME);
            Status = NtQueryValueKey(hkeyLastSweep,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     &SweepValueInfo,
                                     sizeof(SweepValueInfo),
                                     &dwReturnLength);
            if (!NT_SUCCESS(Status))
            {
                bSweep = TRUE; // force sweep, something is suspicious
            }
            else
            {
                UserAssert(SweepValueInfo.Type == REG_BINARY);
                UserAssert(SweepValueInfo.DataLength == sizeof(LastSweepTime));
                RtlCopyMemory(&LastSweepTime, &SweepValueInfo.Data, sizeof(LastSweepTime));
            }
        }
    }
    else
    {
        bSweep = TRUE;
    }

// now open the Fonts key and get the time the key last changed:
// now get the time of the time of the last change is bigger than
// the time of last sweep, must sweep again:

    RtlInitUnicodeString(&UnicodeString, pwszFontListKey);
    InitializeObjectAttributes(&ObjA,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&hkey,
                       KEY_READ | KEY_WRITE,
                       &ObjA);

    if (NT_SUCCESS(Status))
    {
    // get the number of entries in the [Fonts] section

        Status = NtQueryKey(hkey,
                    KeyFullInformation,
                    &KeyInfo,
                    sizeof(KeyInfo),
                    &dwReturnLength);

        if (NT_SUCCESS(Status) && KeyInfo.Values)
        {
            UserAssert(!(KeyInfo.ClassLength | KeyInfo.SubKeys | KeyInfo.MaxNameLen | KeyInfo.MaxClassLen));

        // now let us check if the fonts need to be sweeped. This is the case
        // when the registry last write time is bigger than the last sweep time

            if (!bSweep)
            {
                if (KeyInfo.LastWriteTime.QuadPart != LastSweepTime.QuadPart ) {
                    bSweep = TRUE;
                }
            }

        // init system dir, we will need it:

            if (bSweep &&
                bInitSystemAndFontsDirectoriesW(&gpwcSystemDir, &gpwcFontsDir))
            {
            // alloc buffer big enough to hold the biggest ValueName and ValueData

                cjMaxValueName = DWORDALIGN(KeyInfo.MaxValueNameLen + sizeof(WCHAR));

            // allocate temporary buffer into which we are going to pull the contents
            // of the registry

                KeyInfo.MaxValueDataLen = DWORDALIGN(KeyInfo.MaxValueDataLen);
                cjData = cjMaxValueName +    // space for the value name
                         KeyInfo.MaxValueDataLen ;    // space for the value data

                if (KeyValueInfo = UserLocalAlloc(0, sizeof(*KeyValueInfo) + cjData))
                {
                    for (iFont = 0; iFont < KeyInfo.Values; iFont++)
                    {
                        Status = NtEnumerateValueKey(
                                    hkey,
                                    iFont,
                                    KeyValueFullInformation,
                                    KeyValueInfo,
                                    sizeof(*KeyValueInfo) + cjData,
                                    &dwReturnLength);

                        if (NT_SUCCESS(Status))
                        {
                            UserAssert(KeyValueInfo->NameLength <= KeyInfo.MaxValueNameLen);
                            UserAssert(KeyValueInfo->DataLength <= KeyInfo.MaxValueDataLen);
                            UserAssert((KeyValueInfo->Type == REG_SZ) || (KeyValueInfo->Type == REG_MULTI_SZ));

                        // data goes into the second half of the buffer

                            pjValueData = (BYTE *)KeyValueInfo + KeyValueInfo->DataOffset;

                        // see if the font files are where the registry claims they are.
                        // It is unfortunate we have to do this because SearchPathW
                        // is slow because it touches the disk.

                            (*pfnProcessFontEntry)(hkey,
                                                   KeyValueInfo->Name,
                                                   KeyValueInfo->NameLength / sizeof(WCHAR),
                                                   (WCHAR *)pjValueData,
                                                   KeyValueInfo->DataLength / sizeof(WCHAR));
                        }
                    }

                    if (!bForceEnum)
                    {
                    // now that the sweep is completed, get the last write time
                    // and store it as the LastSweepTime at the appropriate location

                        Status = NtQueryKey(hkey,
                                    KeyFullInformation,
                                    &KeyInfo,
                                    sizeof(KeyInfo),
                                    &dwReturnLength);
                        UserAssert(NT_SUCCESS(Status));

                    // now remember the result

                        RtlInitUnicodeString(&UnicodeString, LAST_SWEEP_TIME);
                        Status = NtSetValueKey(hkeyLastSweep,
                                               &UnicodeString,
                                               0,
                                               REG_BINARY,
                                               &KeyInfo.LastWriteTime,
                                               sizeof(KeyInfo.LastWriteTime));
                        UserAssert(NT_SUCCESS(Status));
                    }

                // free the memory that will be no longer needed

                    UserLocalFree(KeyValueInfo);
                }
            }
        }
        NtClose(hkey);
    }

    if (!bForceEnum)
    {
        NtClose(hkeyLastSweep);
    }
}


/******************************Public*Routine******************************\
*
* BOOL bLoadableFontDrivers()
*
* open the font drivers key and check if there are any entries, if so
* return true. If that is the case we will call AddFontResourceW on
* Type 1 fonts at boot time, right after user had logged on
* PostScript printer drivers are not initialized at this time yet,
* it is safe to do it at this time.
* Effects:
*
* Warnings:
*
* History:
*  24-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL bLoadableFontDrivers()
{
    NTSTATUS             Status;
    UNICODE_STRING       UnicodeString;
    OBJECT_ATTRIBUTES    ObjA;
    KEY_FULL_INFORMATION KeyInfo;
    DWORD                dwReturnLength;
    HKEY                 hkey = NULL;
    BOOL                 bRet = FALSE;

// open the font drivers key and check if there are any entries, if so
// return true. If that is the case we will call AddFontResourceW on
// Type 1 fonts at boot time, right after user had logged on
// PostScript printer drivers are not initialized at this time yet,
// it is safe to do it at this time.

    RtlInitUnicodeString(&UnicodeString, pwszFontDrivers);
    InitializeObjectAttributes(&ObjA,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&hkey,
                       KEY_READ,
                       &ObjA);

    if (NT_SUCCESS(Status))
    {
    // get the number of entries in the [Fonts] section

        Status = NtQueryKey(hkey,
                    KeyFullInformation,
                    &KeyInfo,
                    sizeof(KeyInfo),
                    &dwReturnLength);

        if (NT_SUCCESS(Status) && KeyInfo.Values)
        {
            UserAssert(!(KeyInfo.ClassLength | KeyInfo.SubKeys | KeyInfo.MaxNameLen | KeyInfo.MaxClassLen));

        // externally loadable drivers are present, force sweep

            bRet = TRUE;
        }

        NtClose(hkey);
    }
    return bRet;
}



/***********************Public*Routine******************************\
*
* BOOL bCheckAndDeleteTTF()
*
* Checks whether there is a converted TTF corresponding to
* a Type1 font. Delete the TTF file and the reg entry if there is.
*
* History:
*  29-Jan-1998 -by- Xudong Wu [TessieW]
* Wrote it.
\*******************************************************************/
BOOL bCheckAndDeleteTTF
(
    HKEY    hkey,
    PKEY_FULL_INFORMATION pKeyInfo,
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo,
    PKEY_VALUE_BASIC_INFORMATION KeyValueBasicInfo,
    DWORD   cjData
)
{
    NTSTATUS    Status;
    UNICODE_STRING UnicodeString;
    DWORD       dwReturnLength;
    ULONG       iFont;
    WCHAR       awcTmp[MAX_PATH], *pFontName, *pType1Name, *pwcFile;
    BOOL        bDelTTFfile, bRet = TRUE;
    FLONG       fl;
    WCHAR       awcType1Name[MAX_PATH];  // null-terminated pType1Name
    WCHAR       awcFontName[MAX_PATH];   // null-terminated pFontName
    WCHAR       awcFile[MAX_PATH];       // null-terminated pwcFile

    // pKeyInfo holds the full info on the key "Fonts"
    for (iFont = 0; iFont < pKeyInfo->Values; iFont++)
    {
        RtlZeroMemory(KeyValueInfo->Name, cjData);
        Status = NtEnumerateValueKey(
                    hkey,
                    iFont,
                    KeyValueFullInformation,
                    KeyValueInfo,
                    sizeof(*KeyValueInfo) + cjData,
                    &dwReturnLength);

        if (NT_SUCCESS(Status))
        {
            UserAssert(KeyValueInfo->NameLength <= pKeyInfo->MaxValueNameLen);
            UserAssert(KeyValueInfo->DataLength <= pKeyInfo->MaxValueDataLen);
            UserAssert(KeyValueInfo->Type == REG_SZ);

            bDelTTFfile = FALSE;

            // Make sure we use null-terminated strings
            vNullTermWideString (awcType1Name,
                                 KeyValueBasicInfo->Name,
                                 KeyValueBasicInfo->NameLength / sizeof(WCHAR));
            vNullTermWideString (awcFontName,
                                 KeyValueInfo->Name,
                                 KeyValueInfo->NameLength / sizeof(WCHAR));
            vNullTermWideString (awcFile,
                                 (WCHAR *) ((BYTE *)KeyValueInfo + KeyValueInfo->DataOffset),
                                 KeyValueInfo->DataLength / sizeof(WCHAR));
            pType1Name = awcType1Name;
            pFontName = awcFontName;
            pwcFile = awcFile;

            while((*pType1Name) && (*pType1Name++ == *pFontName++))
                ;

            // if the font name match the type1 name
            // check whether this is a ttf font
            if ((*pType1Name == 0) && (*pFontName++ == L' '))
            {
                WCHAR *pTrueType = L"(TrueType)";

                while(*pTrueType && (*pTrueType++ == *pFontName++))
                    ;
                if (*pTrueType == 0)
                {
                    bDelTTFfile = TRUE;
                }
            }

            if (bDelTTFfile)
            {
                // delete the converted TTF file
                if (bRet = bMakePathNameW(awcTmp, pwcFile, NULL, &fl))
                {
                    UserVerify((bRet = DeleteFileW(awcTmp)));
                }

                // remove the reg entry
                *pFontName = 0;
                RtlInitUnicodeString(&UnicodeString, awcFontName);
                Status = NtDeleteValueKey(hkey, (PUNICODE_STRING)&UnicodeString);

                // decrement the number of values under [Fonts]
                if (NT_SUCCESS(Status))
                    pKeyInfo->Values--;
                else
                    bRet = FALSE;

                break;
            }
        }
        else
        {
            bRet = FALSE;
            break;
        }
    }

    return bRet;
}


/***********************Public*Routine**************************\
*
* BOOL bCleanConvertedTTFs()
*
* Enumerate each entry under "Upgrade Type1" key, call
* bCheckAndDeleteTTF() to remove the coverted TTFs.
*
* History:
*  29-Jan-1998 -by- Xudong Wu [TessieW]
* Wrote it.
\***************************************************************/
BOOL bCleanConvertedTTFs()
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS    Status;
    HKEY        hkeyFonts = NULL, hkeyType1 = NULL;
    DWORD       dwReturnLength;
    DWORD       iFontT1, cjData;
    DWORD       cjMaxValueNameT1, cjMaxValueNameFonts;
    BOOL        bRet = FALSE, bError = FALSE;

    KEY_FULL_INFORMATION KeyInfoType1, KeyInfoFonts;
    PKEY_VALUE_BASIC_INFORMATION KeyValueBasicInfo;
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;

    // Open and query the value from the "Type1 Fonts" key
    // No need to continue if not succeed or no Type1 font listed
    RtlInitUnicodeString(&UnicodeString, pwszType1Key);
    InitializeObjectAttributes(&ObjA,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    Status = NtOpenKey(&hkeyType1,
                    KEY_READ | KEY_WRITE,
                    &ObjA);

    if (NT_SUCCESS(Status))
    {
        Status = NtQueryKey(hkeyType1,
                    KeyFullInformation,
                    &KeyInfoType1,
                    sizeof(KeyInfoType1),
                    &dwReturnLength);

        if (NT_SUCCESS(Status) && KeyInfoType1.Values)
        {
            UserAssert(!(KeyInfoType1.ClassLength | KeyInfoType1.SubKeys |
                         KeyInfoType1.MaxNameLen | KeyInfoType1.MaxClassLen));

            cjMaxValueNameT1 = DWORDALIGN(KeyInfoType1.MaxValueNameLen + sizeof(WCHAR));

            // Alloc buffer big enough to hold the longest Name
            if (KeyValueBasicInfo = UserLocalAlloc(0, sizeof(*KeyValueBasicInfo) + cjMaxValueNameT1))
            {
                RtlInitUnicodeString(&UnicodeString, pwszFontsKey);
                InitializeObjectAttributes(&ObjA,
                                    &UnicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);
                Status = NtOpenKey(&hkeyFonts,
                                KEY_READ | KEY_WRITE,
                                &ObjA);

                if (NT_SUCCESS(Status))
                {
                    Status = NtQueryKey(hkeyFonts,
                                KeyFullInformation,
                                &KeyInfoFonts,
                                sizeof(KeyInfoFonts),
                                &dwReturnLength);

                    if (NT_SUCCESS(Status) && KeyInfoFonts.Values)
                    {
                        UserAssert(!(KeyInfoFonts.ClassLength | KeyInfoFonts.SubKeys |
                                     KeyInfoFonts.MaxNameLen | KeyInfoFonts.MaxClassLen));

                        cjMaxValueNameFonts = DWORDALIGN(KeyInfoFonts.MaxValueNameLen + sizeof(WCHAR));
                        KeyInfoFonts.MaxValueDataLen = DWORDALIGN(KeyInfoFonts.MaxValueDataLen);
                        cjData = cjMaxValueNameFonts + KeyInfoFonts.MaxValueDataLen;

                        // Alloc buffer big enough to hold the longest Name and Value
                        if (KeyValueInfo = UserLocalAlloc(0, sizeof(*KeyValueInfo) + cjData))
                        {
                            // Enum the "Type1 Fonts" key
                            for (iFontT1 = 0; iFontT1 < KeyInfoType1.Values; iFontT1++)
                            {
                                RtlZeroMemory(KeyValueBasicInfo->Name, cjMaxValueNameT1);
                                Status = NtEnumerateValueKey(
                                            hkeyType1,
                                            iFontT1,
                                            KeyValueBasicInformation,
                                            KeyValueBasicInfo,
                                            sizeof(*KeyValueBasicInfo) + cjMaxValueNameT1,
                                            &dwReturnLength);

                                if (NT_SUCCESS(Status))
                                {
                                    UserAssert(KeyValueBasicInfo->NameLength <= KeyInfoType1.MaxValueNameLen);
                                    UserAssert(KeyValueBasicInfo->Type == REG_MULTI_SZ);

                                    // For each Type1 font, check to see whether
                                    // there is corresponding converted TTF
                                    // Delete the TTF file and reg entry if any

                                    bRet = bCheckAndDeleteTTF(hkeyFonts, &KeyInfoFonts, KeyValueInfo,
                                                            KeyValueBasicInfo, cjData);
                                    if (!bRet)
                                    {
                                        bError = TRUE;
                                    }
                                }
                            }
                            UserLocalFree(KeyValueInfo);
                            // no type1 fonts installed
                            if (KeyInfoType1.Values == 0)
                            {
                                bRet = TRUE;
                            }
                        }
                    }
                    NtClose(hkeyFonts);
                }  // NtOpenKey (hkeyFonts)
                UserLocalFree(KeyValueBasicInfo);
            }
        }  // NtQueryKey (hkeyType1)
        NtClose(hkeyType1);
    }

    return (bRet && !bError);
}


/***********************Public*Routine******************************\
*
* VOID vCleanConvertedTTFs()
*
* Delete the converted TTFs and clean the registry if there is any
* TTFs generated from Type1 fonts.
*
* History:
*  29-Jan-1998 -by- Xudong Wu [TessieW]
* Wrote it.
\*******************************************************************/
VOID vCleanConvertedTTFs()
{
    BOOL    bNeedUpgrade = FALSE;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjA;
    DWORD      dwReturnLength;
    NTSTATUS   Status;
    HKEY       hkeyUpgradeType1 = NULL;

    struct {
        KEY_VALUE_PARTIAL_INFORMATION;
        LARGE_INTEGER;
    } UpgradeValueInfo;
    DWORD      UpgradeValue = 0;

    RtlInitUnicodeString(&UnicodeString, pwszUpdType1Key);
    InitializeObjectAttributes(&ObjA,
                           &UnicodeString,
                           OBJ_CASE_INSENSITIVE,
                           NULL,
                           NULL);

    Status = NtOpenKey(&hkeyUpgradeType1,
                   KEY_READ | KEY_WRITE,
                   &ObjA);

    if (!NT_SUCCESS(Status))
    {
        // Key doesn't exist, run for the first time
        // Create the key, open it for writing

        DWORD  dwDisposition;

        Status = NtCreateKey(&hkeyUpgradeType1,
                         KEY_WRITE,
                         &ObjA,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &dwDisposition);
        if (NT_SUCCESS(Status))
        {
            bNeedUpgrade = TRUE;
        }
    }
    else
    {
        RtlInitUnicodeString(&UnicodeString, UPGRADED_TYPE1);
        Status = NtQueryValueKey(hkeyUpgradeType1,
                         &UnicodeString,
                         KeyValuePartialInformation,
                         &UpgradeValueInfo,
                         sizeof(UpgradeValueInfo),
                         &dwReturnLength);

        if (NT_SUCCESS(Status))
        {
            UserAssert(UpgradeValueInfo.Type == REG_DWORD);
            UserAssert(UpgradeValueInfo.DataLength == sizeof(UpgradeValue));
            RtlCopyMemory(&UpgradeValue, &UpgradeValueInfo.Data, sizeof(UpgradeValue));

            // Done if the value is non-zero.
            if (UpgradeValue == 0)
            {
               bNeedUpgrade = TRUE;
            }
        }
    }

    if (bNeedUpgrade)
    {
        if (bCleanConvertedTTFs())
        {
            UpgradeValue = 1;
        }

        RtlInitUnicodeString(&UnicodeString, UPGRADED_TYPE1);
        Status = NtSetValueKey(hkeyUpgradeType1,
              &UnicodeString,
              0,
              REG_DWORD,
              &UpgradeValue,
              sizeof(UpgradeValue));
        UserAssert(NT_SUCCESS(Status));
    }

    if (hkeyUpgradeType1)
    {
        NtClose(hkeyUpgradeType1);
    }
}


/******************************Public*Routine******************************\
*
* VOID vFontSweep()
*
* Effects: The main routine, calls vSweepFonts to sweep "regular" fonts
*          and then to sweep type 1 fonts
*
* History:
*  20-Nov-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFontSweep()
{
// check if shared windows directory installation:

    gbWin31Upgrade = bCheckIfDualBootingWithWin31();

// before we sweep the files to the Fonts directory,
// check whether the 'converted' ttf's have been rmoved

    vCleanConvertedTTFs();

// sweep fonts in the [Fonts] key

    vSweepFonts(pwszFontsKey, pwszSweepKey, vProcessFontEntry, FALSE);

// now sweep type 1 fonts, if any

    vSweepFonts(pwszType1Key, pwszSweepType1Key, vProcessType1FontEntry, FALSE);

// one of the two routines above may have initialized %windir%\system
// and %windir%\fonts directories. Free the memory associated with this

    if (gpwcSystemDir)
    {
        LocalFree(gpwcSystemDir);
        gpwcSystemDir = NULL;
    }

}


/******************************Public*Routine******************************\
*
* VOID vLoadLocal/RemoteT1Fonts()
*
* History:
*  30-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vLoadT1Fonts(PFNENTRY pfnProcessFontEntry)
{

    if (bLoadableFontDrivers())
    {
    #if DBGSWEEP
        DbgPrint("vLoadT1Fonts(0x%lx) was called\n", pfnProcessFontEntry);
    #endif
    // now enum and add remote type1 fonts if any

        vSweepFonts(pwszType1Key, pwszSweepType1Key, pfnProcessFontEntry, TRUE);

    // if the routines above initialized %windir%\system
    // and %windir%\fonts directories. Free the memory associated with this

        if (gpwcSystemDir)
        {
            LocalFree(gpwcSystemDir);
            gpwcSystemDir = NULL;
        }
    }
}

VOID vLoadLocalT1Fonts()
{
    vLoadT1Fonts(vAddLocalType1Font);
}

VOID vLoadRemoteT1Fonts()
{
    vLoadT1Fonts(vAddRemoteType1Font);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\handles.c ===
/****************************** Module Header ******************************\
* Module Name: handles.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* HANDLES.C - Data handle manager
*
*
* This module allows a 32 bit value to be converted into a handle that
* can be validated with a high probability of correctness.
*
* A handle array is kept which contains the 32 bit data associated with
* it, and a copy of the correect handle value. The handle itself is
* composed of a combination of the index into the array for the associated
* data, the instance value, a type value and a DDEML instance value.
*
* The HIWORD of a handle is guarenteed not to be 0.
*
* History:
* 10-28-91 Sanfords Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

// globals

PCHANDLEENTRY aHandleEntry = NULL;

// statics

int cHandlesAllocated = 0;
int iFirstFree = 0;
DWORD nextId = 1;

#define GROW_COUNT 16
// #define TESTING
#ifdef TESTING
VOID CheckHandleTable()
{
    int i;

    for (i = 0; i < cHandlesAllocated; i++) {
        if (aHandleEntry[i].handle && aHandleEntry[i].dwData) {
            switch (TypeFromHandle(aHandleEntry[i].handle)) {
            case HTYPE_INSTANCE:
                UserAssert(((PCL_INSTANCE_INFO)aHandleEntry[i].dwData)->hInstClient == aHandleEntry[i].handle);
                break;

            case HTYPE_CLIENT_CONVERSATION:
            case HTYPE_SERVER_CONVERSATION:
                UserAssert(((PCONV_INFO)aHandleEntry[i].dwData)->hConv == (HCONV)aHandleEntry[i].handle ||
                        ((PCONV_INFO)aHandleEntry[i].dwData)->hConv == 0);
                break;
            }
        }
    }
}
#else
#define CheckHandleTable()
#endif // TESTING


/***************************************************************************\
* CreateHandle
*
* Description:
* Creates a client side handle.
*
* Returns 0 on error.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
HANDLE CreateHandle(
ULONG_PTR dwData,
DWORD type,
DWORD inst)
{
    HANDLE h;
    int i, iNextFree;
    PCHANDLEENTRY phe;

    if (iFirstFree >= cHandlesAllocated) {
        if (cHandlesAllocated == 0) {
           aHandleEntry = (PCHANDLEENTRY)DDEMLAlloc(sizeof(CHANDLEENTRY) * GROW_COUNT);
        } else {
           aHandleEntry = (PCHANDLEENTRY)DDEMLReAlloc(aHandleEntry,
               sizeof(CHANDLEENTRY) * (cHandlesAllocated + GROW_COUNT));
        }
        if (aHandleEntry == NULL) {
            return (0);
        }
        i = cHandlesAllocated;
        cHandlesAllocated += GROW_COUNT;
        phe = &aHandleEntry[i];
        while (i < cHandlesAllocated) {
           // phe->handle = 0; // indicates empty - ZERO init.
           phe->dwData = ++i; // index to next free spot.
           phe++;
        }
    }
    h = aHandleEntry[iFirstFree].handle = (HANDLE)LongToHandle(
         HandleFromId(nextId) |
         HandleFromIndex(iFirstFree) |
         HandleFromType(type) |
         HandleFromInst(inst) );
    iNextFree = (int)aHandleEntry[iFirstFree].dwData;
    aHandleEntry[iFirstFree].dwData = dwData;
    nextId++;
    if (nextId == 0) {     // guarentees HIWORD of handle != 0
       nextId++;
    }
    iFirstFree = iNextFree;

    CheckHandleTable();
    return (h);
}


/***************************************************************************\
* DestroyHandle
*
* Description:
* Frees up a handle.
*
* Assumptions:
* The handle is valid.
* Critical Section is entered.
*
* Returns:
* Data in handle before destruction.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
ULONG_PTR DestroyHandle(
HANDLE h)
{
    register int i;
    register ULONG_PTR dwRet;

    CheckHandleTable();

    i = IndexFromHandle(h);
    UserAssert(aHandleEntry[i].handle == h);
    aHandleEntry[i].handle = 0;
    dwRet = aHandleEntry[i].dwData;
    aHandleEntry[i].dwData = iFirstFree;
    iFirstFree = i;

    return (dwRet);
}


/***************************************************************************\
* GetHandleData
*
* Description:
* A quick way to retrieve a valid handle's data
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
ULONG_PTR GetHandleData(
HANDLE h)
{
    register ULONG_PTR dwRet;

    CheckHandleTable();
    dwRet = aHandleEntry[IndexFromHandle(h)].dwData;
    return (dwRet);
}


/***************************************************************************\
* SetHandleData
*
* Description:
* A quick way to change a valid handle's data.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
VOID SetHandleData(
HANDLE h,
ULONG_PTR dwData)
{
    aHandleEntry[IndexFromHandle(h)].dwData = dwData;
}


/***************************************************************************\
* ValidateCHandle
*
* Description:
* General handle validation routine. ExpectedType or ExpectedInstance
* can be HTYPE_ANY/HINST_ANY. (note Expected Instance is an instance
* index into the aInstance array, NOT a instance handle.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
ULONG_PTR ValidateCHandle(
HANDLE h,
DWORD ExpectedType,
DWORD ExpectedInstance)
{
    register int i;
    register ULONG_PTR dwRet;

    CheckHandleTable();
    dwRet = 0;
    i = IndexFromHandle(h);
    if (i < cHandlesAllocated &&
          aHandleEntry[i].handle == h &&
          (ExpectedType == -1 || ExpectedType == TypeFromHandle(h)) &&
          (ExpectedInstance == -1 || ExpectedInstance == InstFromHandle(h))) {
       dwRet = aHandleEntry[i].dwData;
    }

    return (dwRet);
}


PCL_INSTANCE_INFO PciiFromHandle(
HANDLE h)
{
    PCHANDLEENTRY phe;

    CheckDDECritIn;

    if (!cHandlesAllocated) {
        return(NULL);
    }
    phe = &aHandleEntry[cHandlesAllocated];

    do {
        phe--;
        if (phe->handle != 0 &&
                TypeFromHandle(phe->handle) == HTYPE_INSTANCE &&
                (InstFromHandle(phe->handle) == InstFromHandle(h))) {
            return(((PCL_INSTANCE_INFO)phe->dwData)->tid == GetCurrentThreadId() ?
                (PCL_INSTANCE_INFO)phe->dwData : NULL);
        }
    } while (phe != aHandleEntry);
    return(NULL);
}



/***************************************************************************\
* ApplyFunctionToObjects
*
* Description:
* Used for cleanup, this allows the handle array to be scanned for
* handles meeting the ExpectedType and ExpectedInstance criteria
* and apply the given function to each handle.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
VOID ApplyFunctionToObjects(
DWORD ExpectedType,
DWORD ExpectedInstance,
PFNHANDLEAPPLY pfn)
{
    PCHANDLEENTRY phe;

    CheckDDECritIn;

    if (!cHandlesAllocated) {
        return;
    }
    phe = &aHandleEntry[cHandlesAllocated];

    do {
        phe--;
        if (phe->handle != 0 &&
                (ExpectedType == HTYPE_ANY ||
                    ExpectedType == TypeFromHandle(phe->handle)) &&
                (ExpectedInstance == HTYPE_ANY ||
                    ExpectedInstance == InstFromHandle(phe->handle))) {
            LeaveDDECrit;
            CheckDDECritOut;
            (*pfn)(phe->handle);
            EnterDDECrit;
        }
    } while (phe != aHandleEntry);
}


DWORD GetFullUserHandle(WORD wHandle)
{
    DWORD dwHandle;
    PHE phe;

    dwHandle = HMIndexFromHandle(wHandle);

    if (dwHandle < gpsi->cHandleEntries) {

        phe = &gSharedInfo.aheList[dwHandle];

        if (phe->bType == TYPE_WINDOW)
            return(MAKELONG(dwHandle, phe->wUniq));
    }

    /*
     * object may be gone, but we must pass something.
     * DDE terminates will fail if we don't map this right even after
     * the window is dead!
     *
     * NOTE: This fix will only work for WOW apps, but since the 32bit
     * tracking layer locks dde windows until the last terminate is
     * received, we won't see this problem on the 32bit side.
     *
     * BUG: We WILL see a problem for OLE32 thunked DDE though.
     */
    return(wHandle);
}



/***************************************************************************\
* BestSetLastDDEMLError
*
* Description:
* This sets the LastError field of all instances that belong to the
* current thread. This is used to get error information to applications
* which generated an error where the exact instance could not be
* determined.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID BestSetLastDDEMLError(
DWORD error)
{
    PCHANDLEENTRY phe;

    CheckDDECritIn;

    if (!cHandlesAllocated) {
        return;
    }
    phe = &aHandleEntry[cHandlesAllocated];
    do {
        phe--;
        if (phe->handle != 0 && TypeFromHandle(phe->handle) == HTYPE_INSTANCE) {
            SetLastDDEMLError((PCL_INSTANCE_INFO)phe->dwData, error);
        }
    } while (phe != aHandleEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\help.c ===
/**************************************************************************\
* Module Name: help.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 23-May-95 BradG   Created to consolidate client-side help routines.
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define MAX_ATTEMPTS    5       // maximum -1 id controls to search through
char szDefaultHelpFileA[] = "windows.hlp";

PWCHAR szEXECHELP = TEXT("\\winhlp32 - ");
PWCHAR szMS_WINHELP =     L"MS_WINHELP";    // Application class
PWCHAR szMS_POPUPHELP =   L"MS_POPUPHELP";  // Popup class
PWCHAR szMS_TCARDHELP =   L"MS_TCARDHELP";  // Training card class

// These are in winhelp.h in Chicago
#define HLP_POPUP               'p'     // Execute WinHelp as a popup
#define HLP_TRAININGCARD        'c'     // Execute WinHelp as a training card
#define HLP_APPLICATION         'x'     // Execute WinHelp as application help


/***************************************************************************\
* SendWinHelpMessage
*
* Attempts to give the winhelp process the right to take the
*  foreground (it will fail if the calling processs doesn't have
*  the right itself). Then it sends the WM_WINHELP message
*
* History:
* 02-10-98 GerardoB     Created
\***************************************************************************/
LRESULT SendWinHelpMessage(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam)
{
    DWORD dwProcessId = 0;
    GetWindowThreadProcessId(hwnd, &dwProcessId);
    AllowSetForegroundWindow(dwProcessId);
    return SendMessage(hwnd, WM_WINHELP, wParam, lParam);
}

/***************************************************************************\
* HFill
*
* Builds a data block for communicating with help
*
* LATER 13 Feb 92 GregoryW
* This needs to stay ANSI until we have a Unicode help engine
*
* History:
* 04-15-91 JimA Ported.
* 03-24-95 BradG - YAP of Win95 code.  Added code to prevent memory
*                  overwrite on bad ulData == 0 parameter.
\***************************************************************************/
LPHLP HFill(
    LPCSTR lpszHelp,
    DWORD  ulCommand,        // HELP_ constant
    ULONG_PTR ulData)
{
    DWORD   cb;     // Size of the data block
    DWORD   cbStr;  // Length of the help file name
    DWORD   cbData; // Size of the dwData parameter in bytes (0 if not used)
    LPHLP   phlp;   // Pointer to data block
    BYTE    bType;  // dwData parameter type

    /*
     * Get the length of the help file name
     */
    cbStr = (lpszHelp) ? strlen(lpszHelp) + 1 : 0;

    /*
     * Get the length of any dwData parameters
     */
    bType = HIBYTE(LOWORD(ulCommand));
    if (ulData) {
        switch (bType) {
        case HIBYTE(HELP_HB_STRING):
            /*
             * ulData is an ANSI string, so compute its length
             */
            cbData = strlen((LPSTR)ulData) + 1;
            break;

        case HIBYTE(HELP_HB_STRUCT):
            /*
             * ulData points to a structure who's first member is
             * an int that contains the size of the structure in bytes.
             */
            cbData = *((int *)ulData);
            break;

        default:
            /*
             * dwData has no parameter
             */
            cbData = 0;
        }
    } else {
        /*
         * No parameter is present
         */
        cbData = 0;
    }

    /*
     * Calculate size (NOTE: HLP is called WINHLP in Win95)
     */
    cb = sizeof(HLP) + cbStr + cbData;

    /*
     * Get data block
     */
    if ((phlp = (LPHLP)LocalAlloc(LPTR, cb)) == NULL)
        return NULL;

    /*
     * Fill in info
     */
    phlp->cbData = (WORD)cb;
    phlp->usCommand = (WORD)ulCommand;
    phlp->ulReserved = 0;
    // phlp->ulTopic = 0;

    /*
     * Fill in file name
     */
    if (lpszHelp) {
        phlp->offszHelpFile = sizeof(HLP);  // NOTE: HLP is called WINHLP in Win95
        strcpy((LPSTR)(phlp + 1), lpszHelp);
    } else {
        phlp->offszHelpFile = 0;
    }

    /*
     * Fill in data
     */
    switch (bType) {
    case HIBYTE(HELP_HB_STRING):
        if (cbData) {
            phlp->offabData = (WORD)(sizeof(HLP) + cbStr);  // NOTE: HLP is called WINHLP in Win95
            strcpy((LPSTR)phlp + phlp->offabData, (LPSTR)ulData);
        } else {
            phlp->offabData = 0;
        }
        break;

    case HIBYTE(HELP_HB_STRUCT):
        if (cbData) {
            phlp->offabData = (WORD)(sizeof(HLP) + cbStr);  // NOTE: HLP is called WINHLP in Win95
            RtlCopyMemory((LPBYTE)phlp + phlp->offabData, (PVOID)ulData,
                    *((int far *)ulData));
        } else {
            phlp->offabData = 0;
        }
        break;

    default:
        phlp->offabData = 0;
// BradG - This item is named differently in the Win95 WINHLP structure
//      phlp->ctx   = ulData;
        phlp->ulTopic = ulData;
        break;
    }

    return phlp;
}


/***************************************************************************\
* LaunchHelper
*
* This function launches the WinHlp32 executable with the correct command
* line arguments.
*
* History:
*   3/23/95 BradG   YAP (yet another port) of changes from Win95.
\***************************************************************************/
BOOL LaunchHelper(
    LPWSTR lpfile,
    DWORD dwType)
{
    int                 cchLen;
    int                 cchShift;
    DWORD               idProcess;
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    PWCHAR pwcExecHelp;

    pwcExecHelp = szEXECHELP;

    /*
     * Are we at the root? If so, skip over leading backslash in text string.
     */
    if (*lpfile) {
        cchLen = wcslen(lpfile);
        cchShift = (lpfile[cchLen - 1] == TEXT('\\')) ? 1 : 0;
        wcscat(lpfile, pwcExecHelp + cchShift);
    } else {
        wcscat(lpfile, pwcExecHelp + 1);
    }


    /*
     * Defaultly send "winhlp32 -x" or adjust the last flag character
     */
    switch (dwType) {
    case TYPE_POPUP:
        lpfile[wcslen(lpfile)-1] = TEXT(HLP_POPUP);
        break;

    case TYPE_TCARD:
        lpfile[wcslen(lpfile)-1] = TEXT(HLP_TRAININGCARD);
        break;

    default:
        lpfile[wcslen(lpfile)-1] = TEXT(HLP_APPLICATION);
        break;
    }

    /*
     *  Launch winhelp
     */
    RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.wShowWindow = SW_SHOW;
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_FORCEONFEEDBACK;

    idProcess = (DWORD)CreateProcessW(NULL, lpfile,
            NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &StartupInfo,
            &ProcessInformation);

    if (idProcess) {
        WaitForInputIdle(ProcessInformation.hProcess, 10000);
        NtClose(ProcessInformation.hProcess);
        NtClose(ProcessInformation.hThread);
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* LaunchHelp
*
* Traverse the Windows, System, and %PATH% directories attempting to launch
* the WinHelp32 application.
*
* History:
* 3/23/95 BradG     YAP of new changes from Win95
\***************************************************************************/
BOOL LaunchHelp(
    DWORD dwType)
{
    WCHAR wszPath[MAX_PATH] = L"";

    GetSystemWindowsDirectoryW(wszPath, MAX_PATH);

    if (LaunchHelper(wszPath, dwType))
        return TRUE;

    /*
     * Search the system directory (Not in Win95)
     */
    GetSystemDirectoryW(wszPath, MAX_PATH);
    if (LaunchHelper(wszPath, dwType))
        return TRUE;

    /*
     * Try the search path
     */
    wszPath[0] = L'\0';
    return LaunchHelper(wszPath, dwType);
}


/***************************************************************************\
* GetNextDlgHelpItem
*
* This is a reduced version of the GetNextDlgTabItem function that does not
* skip disabled controls.
*
* History:
* 3/25/95 BradG     Ported from Win95
\***************************************************************************/
PWND GetNextDlgHelpItem(PWND pwndDlg, PWND pwnd)
{
    PWND pwndSave;

    if (pwnd == pwndDlg) {
        pwnd = NULL;
    } else {
        pwnd = _GetChildControl(pwndDlg, pwnd);
        if (pwnd) {
            if (!_IsDescendant(pwndDlg, pwnd))
                return NULL;
        }
    }

    /*
     *  BACKWARD COMPATIBILITY
     *
     *  Note that the result when there are no tabstops of
     *  IGetNextDlgTabItem(hwndDlg, NULL, FALSE) was the last item, now
     *  will be the first item.  We could put a check for fRecurse here
     *  and do the old thing if not set.
     */

    /*
     *  We are going to bug out if we hit the first child a second time.
     */
    pwndSave = pwnd;
    pwnd = _NextControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE);

    while ((pwnd != pwndSave) && (pwnd != pwndDlg))
    {
        UserAssert(pwnd);

        if (!pwndSave)
            pwndSave = pwnd;

        if ((pwnd->style & (WS_TABSTOP | WS_VISIBLE))  == (WS_TABSTOP | WS_VISIBLE))
            /*
             *  Found it.
             */
            break;

        pwnd = _NextControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE);
    }

    return pwnd;
}


/***************************************************************************\
* HelpMenu
*
* History:
* 01-Feb-1994 mikeke    Ported.
\***************************************************************************/
UINT HelpMenu(
    HWND hwnd,
    PPOINT ppt)
{
    INT     cmd;
    HMENU   hmenu = LoadMenu( hmodUser, MAKEINTRESOURCE(ID_HELPMENU));

    if (hmenu != NULL) {
        cmd = TrackPopupMenu( GetSubMenu(hmenu, 0),
              TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON,
              ppt->x, ppt->y, 0, hwnd, NULL);
        NtUserDestroyMenu(hmenu);
        return cmd;
    }

    return (UINT)-1;
}

/***************************************************************************\
* FindWinHelpWindow
*
* This function attempts to locate the help window.  If it fails, it attempts
* to launch WinHlp32.exe and then look for its window.
*
* History:
* 03/24/95 BradG   Created by extracting code from xxxWinHelpA
\***************************************************************************/
HWND FindWinHelpWindow(
    LPCWSTR lpwstrHelpWindowClass,
    DWORD   dwType,
    BOOL    bLaunchIt)
{
    HWND    hwndHelp;

    /*
     * Find the current help window. If not found, try and launch
     * the WinHlp32 application. We are interested only in 32 bit help.
     *
     * Note that 16 bit apps don't walk this path, ntvdm takes care of
     * starting the 16 bit help for them.
     */
    hwndHelp = InternalFindWindowExW(NULL, NULL, lpwstrHelpWindowClass, NULL, FW_32BIT);

    if (hwndHelp == NULL) {
        if (bLaunchIt) {
            /*
             *  Can't find it --> see if we want to launch it
             */
            if ((LaunchHelp(dwType) == FALSE) ||
                (hwndHelp = FindWindowEx(NULL, NULL, (LPWSTR)lpwstrHelpWindowClass, NULL)) == NULL)
              {

                /*
                 *  Can't find help, or not enough memory to load help.
                 *  hwndHelp will be NULL at this point.
                 */
                RIPMSG0(RIP_WARNING, "FindWinHelpWindow: LaunchHelp and FindWindow failed.");
            }
        }
    }

    return hwndHelp;
}


/*
 *  HWND version of Enumeration function to find controls while
 *  ignoring group boxes but not disabled controls.
 */
BOOL CALLBACK EnumHwndDlgChildProc(
    HWND hwnd,
    LPARAM lParam)
{
    PWND pwnd;
    BOOL bResult;

    if (pwnd = ValidateHwnd(hwnd)) {
        bResult = EnumPwndDlgChildProc(pwnd, lParam);
    } else {
        bResult = TRUE;
    }

    return bResult;
}


/***************************************************************************\
* WinHelp
*
* Displays help
*
* History:
* 04-15-91 JimA             Ported.
* 01-29-92 GregoryW         Neutral version.
* 05-22-92 SanfordS         Added support for help structures
* 03-24-95 BradG            Moved from Client side WinHelpA to server side
*                           xxxWinHelpA because of changes in Win95.  The
*                           function xxxServerWinHelp was merged.
\***************************************************************************/
BOOL WinHelpA(
    HWND    hwnd,       // hwndMain may be NULL.
    LPCSTR  lpszHelp,
    UINT    uCommand,
    ULONG_PTR dwData)
{
    LPWSTR  lpwstrHelpWindowClass;
    LPHLP   lpHlp = NULL;
    DWORD   dwType;
    PWND    pwnd;
    HWND    hwndHelp = NULL;    /* Handle of help's main window         */
    PWND    pwndTop = NULL;     /* Top level window that WinHelp uses.  */
    PWND    pwndMain;           /* pointer to main help control         */
    LRESULT lResult;
    POINT   ptCur;
    BOOL    bResult = TRUE;

    pwnd = ValidateHwnd(hwnd);

    if (uCommand & HELP_TCARD) {
        /*
         * For Training Cards, the HELP_TCARD bit is set.  We need to
         * set our help window class to szMS_TCARDHELP and then remove
         * the HELP_TCARD bit.
         */
        lpwstrHelpWindowClass = szMS_TCARDHELP;
        uCommand &= ~HELP_TCARD;    // mask out the tcard flag
        dwType = TYPE_TCARD;
    } else {
        if( (uCommand == HELP_CONTEXTMENU) || (uCommand == HELP_CONTEXTPOPUP) ||
            (uCommand == HELP_SETPOPUP_POS) || (uCommand == HELP_WM_HELP)) {
            /*
             *  Popups should be connected to a valid window.  pwndMain has already
             *  been validated as a real window handle or NULL, so we just need to
             *  check the NULL case here.
             */
            if (pwnd == NULL) {
                RIPERR1(ERROR_INVALID_PARAMETER,
                        RIP_WARNING,
                        "WinHelpA: NULL hWnd invalid for this type of help command (0x%X)",
                        uCommand);

                bResult = FALSE;
                goto Exit_WinHelp;
            }
            dwType = TYPE_POPUP;
            lpwstrHelpWindowClass = szMS_POPUPHELP;
        } else {
            dwType = TYPE_NORMAL;
            lpwstrHelpWindowClass = szMS_WINHELP;
        }
    }

    /*
     * Get the cursor's current location  This is where we assume the user
     * clicked.  We will use this position to search for a child window and
     * to set the context sensitive help popup window's location.
     *
     * If the last input was a keyboard one, use the point in the center
     * of the focus window rectangle. MCostea #249270
     */
    if (gpsi->bLastRITWasKeyboard) {
        HWND hWndFocus = GetFocus();
        RECT rcWindow;

        if (GetWindowRect(hWndFocus, &rcWindow)) {
            ptCur.x = (rcWindow.left + rcWindow.right)/2;
            ptCur.y = (rcWindow.top + rcWindow.bottom)/2;
        } else {
            goto getCursorPos;
        }
    } else {
getCursorPos:
        GetCursorPos(&ptCur);
    }

    /*
     * If we are handling the HELP_CONTEXTMENU command, see if we
     * can determine the correct child window.
     */
    if (uCommand == HELP_CONTEXTMENU && FIsParentDude(pwnd)) {
        LONG        lPt;
        int         nHit;
        DLGENUMDATA DlgEnumData;

        /*
         *  If the user really clicked on the caption or the system menu,
         *  then we want the context menu for the window, not help for a
         *  control.  This makes it consistent across all 3.x and 4.0
         *  windows.
         */
        lPt = MAKELONG(ptCur.x,ptCur.y);
        nHit = FindNCHit(pwnd, lPt);
        if ((nHit == HTCAPTION) || (nHit == HTSYSMENU))
            DefWindowProc(hwnd, WM_CONTEXTMENU, (WPARAM)hwnd, lPt);

        /*
         * If this is a dialog class, then one of three things has
         * happened:
         *
         *  o   This is a disabled control
         *  o   This is a static text control
         *  o   This is the background of the dialog box.
         *
         * What we do is enumerate the child windows and see if
         * any of them contain the current cursor point. If they do,
         * change our window handle and continue on. Otherwise,
         * return doing nothing -- we don't want context-sensitive
         * help for a dialog background.
         *
         * If this is a group box, then we might have clicked on a
         * disabled control, so we enumerate child windows to see
         * if we get another control.
         */
        DlgEnumData.pwndDialog = pwnd;
        DlgEnumData.pwndControl = NULL;
        DlgEnumData.ptCurHelp = ptCur;
        EnumChildWindows(hwnd, (WNDENUMPROC)EnumHwndDlgChildProc, (LPARAM)&DlgEnumData);
        if (DlgEnumData.pwndControl == NULL) {
            /*
             * Can't find a control, so nothing to do.
             */
            goto Exit_WinHelp;
        } else {
            /*
             * Remember this control because it will be used as the
             * control for context sensitive help.
             */
            pwndMain = DlgEnumData.pwndControl;
        }
    } else {
        /*
         * We will use pwnd as our main control.  No need to lock it
         * because it is already locked.
         */
        pwndMain = pwnd;
    }

    /*
     * For HELP_CONTEXTPOPUP and HELP_WM_HELP, see if we can derive the
     * context id by looking at the array of double word ID pairs that
     * have been passed in in dwData.
     */
    if (uCommand == HELP_CONTEXTMENU || uCommand == HELP_WM_HELP) {
        int     id;
        int     i;
        LPDWORD pid;

        /*
         * Be careful about the cast below.  We need the ID, which is stored
         * in the LOWORD of spmenu to be sign extended to an int.
         * Don't sign extend so IDs like 8008 work
         */
        id = (DWORD)(PTR_TO_ID(pwndMain->spmenu));   // get control id
        pid = (LPDWORD) dwData;

        /*
         * Is the control's ID -1?
         */
        if ((SHORT)id == -1)
        {
            /*
             * This is a static (i.e., ID'less) control
             */
            PWND pwndCtrl;
            int cAttempts = 0;

            /*
             * If the control is a group box, with an ID of -1, bail out
             * as the UI specs decided to have no context help
             * for these cases.  MCostea
             */
            if ((TestWF(pwndMain, BFTYPEMASK) == BS_GROUPBOX) &&
                IS_BUTTON(pwndMain)) {
                goto Exit_WinHelp;
            }

            /*
             * For non-id controls (typically static controls), step
             * through to the next tab item. Keep finding the next tab
             * item until we find a valid id, or we have tried
             * MAX_ATTEMPTS times.
             */
            do {
                pwndCtrl = GetNextDlgHelpItem(REBASEPWND(pwndMain,spwndParent), pwndMain);

                /*
                 * pwndCtrl will be NULL if hwndMain doesn't have a parent,
                 * or if there are no tab stops.
                 */
                if (!pwndCtrl) {
                    /*
                     * Remember to unlock the control
                     */
                    bResult = FALSE;
                    goto Exit_WinHelp;
                }

                /*
                 * Be careful about the cast below.  We need the ID, which is
                 * stored in the LOWORD of spmenu to be sign extended to an int.
                 * Don't sign extend so IDs like 8008 work
                 */
                id = (DWORD)(PTR_TO_ID(pwndCtrl->spmenu));

            } while (((SHORT)id == -1) && (++cAttempts < MAX_ATTEMPTS));
        }

        if ((SHORT)id == -1) {
            id = -1;
        }

        /*
         * Find the id value in array of id/help context values
         */
        for (i = 0; pid[i]; i += 2) {
            if ((int) pid[i] == id)
                break;
        }

        /*
         * Since no help was specified for the found control, see if
         * the control is one of the known ID (i.e., OK, Cancel...)
         */
        if (!pid[i]) {
            /*
             * Help for the standard controls is in the default
             * help file windows.hlp.  Switch to this file.
             */
            lpszHelp = szDefaultHelpFileA;

            switch (id) {
            case IDOK:
                dwData = IDH_OK;
                break;

            case IDCANCEL:
                dwData = IDH_CANCEL;
                break;

            case IDHELP:
                dwData = IDH_HELP;
                break;

            default:
                /*
                 * Unknown control, give a generic missing context info
                 * popup message in windows.hlp.
                 */
                dwData = IDH_MISSING_CONTEXT;
            }
        } else {
            dwData = pid[i + 1];
            if (dwData == (DWORD)-1) {
                /*
                 * Remember, to unlock the control
                 */
                goto Exit_WinHelp;     // caller doesn't want help after all
            }
        }

        /*
         *  Now that we know the caller wants help for this control, display the
         *  help menu.
         */
        if (uCommand == HELP_CONTEXTMENU)
        {
            int cmd;

            /*
             * Must lock pwndMain because it may have been reassigned above.
             */
            cmd = HelpMenu(HW(pwndMain), &ptCur);
            if (cmd <= 0)   // probably means user cancelled the menu
                goto Exit_WinHelp;
        }

        /*
         * Create WM_WINHELP's HLP data structure for HELP_SETPOPUP_POS
         */
        if (!(lpHlp = HFill(lpszHelp, HELP_SETPOPUP_POS,
                MAKELONG(pwndMain->rcWindow.left, pwndMain->rcWindow.top)))) {
            /*
             * Remember to unlock pwndMain if needed
             */
            bResult = FALSE;
            goto Exit_WinHelp;
        }

        /*
         * Tell WinHelp where to put the popup.  This is different than Win95
         * because we try and avoid a recursive call here.  So, we find the
         * WinHlp32 window and send the HELP_SETPOPUP_POS.  No recursion.
         */
        hwndHelp = FindWinHelpWindow(lpwstrHelpWindowClass, dwType, TRUE);
        if (hwndHelp == NULL) {
            /*
             * Uable to communicate with WinHlp32.exe.
             * Remember to unlock the control
             */
            bResult = FALSE;
            goto Exit_WinHelp;
        }

        /*
         * Send the WM_WINHELP message to WinHlp32's window.
         */
        lResult = SendWinHelpMessage(hwndHelp, (WPARAM)HW(pwndMain), (LPARAM)lpHlp);
        LocalFree(lpHlp);
        lpHlp = NULL;

        if (!lResult) {
            /*
             * WinHlp32 couldn't process the command. Bail out!
             */
            bResult = FALSE;
            goto Exit_WinHelp;
        }

        /*
         * Make HELP_WM_HELP and HELP_CONTEXTMENU act like HELP_CONTEXTPOPUP
         */
        uCommand = HELP_CONTEXTPOPUP;
    }


    if (uCommand == HELP_CONTEXTPOPUP) {
        /*
         * If no help file was specified, use windows.hlp
         */
        if (lpszHelp == NULL || *lpszHelp == '\0')
            lpszHelp = szDefaultHelpFileA;  // default: use windows.hlp

        /*
         *  WINHELP.EXE will call SetForegroundWindow on the hwnd that we pass
         *  to it below.  We really want to pass the parent dialog hwnd of the
         *  control so that focus will properly be restored to the dialog and
         *  not the control that wants help.
         */
        pwndTop = GetTopLevelWindow(pwndMain);
    } else {
        pwndTop = pwndMain;
    }


    /*
     * Move Help file name to a handle
     */
    if (!(lpHlp = HFill(lpszHelp, uCommand, dwData))) {
        /*
         * Can't allocate memory
         */
        bResult = FALSE;
        goto Exit_WinHelp;
    }

    /*
     *  Get a pointer to the help window.
     */
    hwndHelp = FindWinHelpWindow(lpwstrHelpWindowClass, dwType, (uCommand != HELP_QUIT));
    if (hwndHelp == NULL) {
        if (uCommand != HELP_QUIT)
            /*
             * Can't find Winhlp
             */
            bResult = FALSE;
        goto Exit_WinHelp;
    }

    /*
     * Send the WM_WINHELP message to WinHlp32's window
     * Must ThreadLock pwndHelp AND pwndMain (because pwndMain may have been
     * reassigned above).
     */
    SendWinHelpMessage(hwndHelp, (WPARAM)HW(pwndTop), (LPARAM)lpHlp);

    /*
     * Free the help info data structure (if not already free).
     */
Exit_WinHelp:
    if (lpHlp != NULL) {
        LocalFree(lpHlp);
    }

    return bResult;
}


#if 0
/*
 *
 * Communicating with WinHelp involves using Windows SendMessage function
 * to pass blocks of information to WinHelp. The call looks like.
 *
 * SendMessage(hwndHelp, WM_WINHELP, pidSource, pwinhlp);
 *
 * Where:
 *
 * hwndHelp - the window handle of the help application. This
 * is obtained by enumerating all the windows in the
 * system and sending them HELP_FIND commands. The
 * application may have to load WinHelp.
 * pidSource - the process id of the sending process
 * pwinhlp - a pointer to a WINHLP structure
 *
 * The data in the handle will look like:
 *
 * +-------------------+
 * |     cbData        |
 * |    ulCommand      |
 * |    hwndHost       |
 * |     ulTopic       |
 * |    ulReserved     |
 * |   offszHelpFile   |\ - offsets measured from beginning
 * | offaData          | \ of header.
 * +-------------------+ /
 * | Help file name    |/
 * | and path          |
 * +-------------------+
 * | Other data        |
 * |    (keyword)      |
 * +-------------------+
 *
 * hwndMain - the handle to the main window of the application
 * calling help
 *
 * The defined commands are:
 *
 * HELP_CONTEXT 0x0001 Display topic in ulTopic
 * HELP_KEY 0x0101 Display topic for keyword in offabData
 * HELP_QUIT 0x0002 Terminate help
 *
 */


BOOL WinHelpA(
    HWND hwndMain,
    LPCSTR lpszHelp,
    UINT uCommand,
    ULONG_PTR dwData)
{
    LPHLP lpHlp;
    BOOL fSuccess;
    DWORD dwType;
    HWND hwndHelp; /* Handle of help's main window */
    LPWSTR lpwstr;
    PWND pwndMain;

    pwndMain = ValidateHwnd(hwndMain);

    if ((uCommand == HELP_CONTEXTMENU) || (uCommand == HELP_CONTEXTPOPUP) ||
            (uCommand == HELP_SETPOPUP_POS) || (uCommand == HELP_WM_HELP)) {
        dwType = TYPE_POPUP;
    } else {
        dwType = TYPE_NORMAL;
    }

    switch (uCommand) {

    case HELP_WM_HELP:
        {
#if 0
        // Tell WinHelp where to put the popup

        if (!WinHelpA(hwndMain, lpszHelp, HELP_SETPOPUP_POS,
                MAKELONG(pwndMain->rcWindow.left, pwndMain->rcWindow.top)))
            return FALSE;

        /*
         * Unlike HELP_CONTEXTMENU, with this command we pop up the help
         * topic immediately instead of making the user go through a menu.
         */
#endif

        goto MapIdToHelp;

        }
        break;

    case HELP_CONTEXTMENU:
        {
        int cmd;
        int id;
        int i;
        POINT ptCur;
        LPDWORD pid;

        GetCursorPos(&ptCur);

        if (pwndMain != NULL && pwndMain->fnid == FNID_DIALOG) {
            /*
             * If this is a dialog class, then one of three things has
             * happened:
             *
             *  o   This is a disabled control
             *  o   This is a static text control
             *  o   This is the background of the dialog box.
             *
             * What we do is enumerate the child windows and see if
             * any of them contain the current cursor point. If they do,
             * change our window handle and continue on. Otherwise,
             * return doing nothing -- we don't want context-sensitive
             * help for a dialog background.
             */

            pwndMain = REBASEPWND(pwndMain, spwndChild);

            while (pwndMain != NULL
                   && PtInRect(&(pwndMain->rcWindow), ptCur)) {
                pwndMain = REBASEPWND(pwndMain, spwndNext);
            }

            if (pwndMain == NULL)
                return FALSE;
        }

        cmd = HelpMenu(hwndMain, &ptCur);

        if (cmd <= 0) { // probably means user cancelled the menu
            return FALSE;

        } else if (cmd == HELP_INDEX) {
            // Search
            uCommand = HELP_FINDER;
        } else {
MapIdToHelp:
            UserAssert(pwndMain);

            // Tell WinHelp where to put the popup

            if (!WinHelpA(hwndMain, lpszHelp, HELP_SETPOPUP_POS,
                    MAKELONG(pwndMain->rcWindow.left, pwndMain->rcWindow.top)))
                return FALSE;
            id = LOWORD(pwndMain->spmenu);   // get control id

            pid = (LPDWORD) dwData;

            if (id == -1) {
                // static control?
                PWND pwndCtrl;
                int cAttempts = 0;

                // For non-id controls (typically static controls), step
                // through to the next tab item. Keep finding the next tab
                // item until we find a valid id, or we have tried
                // MAX_ATTEMPTS times.
                do {
                    pwndCtrl = _GetNextDlgTabItem(REBASEPWND(pwndMain, spwndParent),
                                    pwndMain, FALSE);

                    // hwndCtrl will be NULL if hwndMain doesn't have a parent,
                    // or if there are no tab stops.

                    if (!pwndCtrl) {
                        return FALSE;
                    }



                    id = LOWORD(pwndCtrl->spmenu);
                }
                while ((id == -1) && (++cAttempts < MAX_ATTEMPTS));
            }

            // Find the id value in array of id/help context values

            for (i = 0; pid[i]; i += 2) {
                if ((int) pid[i] == id)
                    break;
            }

            if (!pid[i]) {


                lpszHelp = szDefaultHelpFileA;  // switch to windows.hlp

                switch (id) {
                    case IDOK:
                        dwData = IDH_OK;
                        break;

                    case IDCANCEL:
                        dwData = IDH_CANCEL;
                        break;

                    case IDHELP:
                        dwData = IDH_HELP;
                        break;

                    default:
                        dwData = IDH_MISSING_CONTEXT;
                }
            } else {
                dwData = pid[i + 1];
                if (dwData == (DWORD) -1) {
                    return TRUE;   // caller doesn't want help after all
                }
            }

            uCommand = HELP_CONTEXTPOPUP;
        }

        // If no help file was specified, use windows.hlp

        if (lpszHelp == NULL || *lpszHelp == '\0')
            lpszHelp = szDefaultHelpFileA;  // default: use windows.hlp
        }
    }

    /*
     * Move Help file name to a handle
     */
    if (!(lpHlp = HFill(lpszHelp, uCommand, dwData)))
        return FALSE;

    /*
     * Pass it on to WinHelp32
     */
    fSuccess = TRUE;
    if (dwType == TYPE_POPUP)
        lpwstr = szMS_POPUPHELP;
    else
        lpwstr = szMS_WINHELP;

    if ((hwndHelp = FindWindowEx(NULL, NULL, lpwstr, NULL)) == NULL) {
        if (uCommand == HELP_QUIT)
            fSuccess = TRUE;

        /*
         * Can't find it --> launch it
         */
        if (!LaunchHelp(dwType) ||
                (hwndHelp = FindWindowEx(NULL, NULL, lpwstr, NULL)) == NULL)
            fSuccess = FALSE;
    }

    if (hwndHelp != NULL)
        SendMessage(hwndHelp, WM_WINHELP, (DWORD)hwndMain, (LONG)lpHlp);

    LocalFree(lpHlp);

    return fSuccess;
}
#endif



/***************************************************************************\
* WinHelpW
*
* Calls WinHelpA after doing any necessary translation.
* Our help engine is ASCII only.
*
\***************************************************************************/
BOOL WinHelpW(
    HWND hwndMain,
    LPCWSTR lpwszHelp,
    UINT uCommand,
    ULONG_PTR dwData)
{
    BOOL fSuccess = FALSE;
    LPSTR lpAnsiHelp = NULL;
    LPSTR lpAnsiKey = NULL;
    PMULTIKEYHELPA pmkh = NULL;
    PHELPWININFOA phwi = NULL;
    NTSTATUS Status;


    /*
     * First convert the string.
     */
    if (lpwszHelp != NULL &&
            !WCSToMB(lpwszHelp, -1, &lpAnsiHelp, -1, TRUE)) {
        return FALSE;
    }

    /*
     * Then convert dwData if needed
     */
    switch (uCommand) {
    case HELP_MULTIKEY:
        if (!WCSToMB(((PMULTIKEYHELPW)dwData)->szKeyphrase, -1, &lpAnsiKey,
                -1, TRUE)) {
            goto FreeAnsiHelp;
        }

        pmkh = (PMULTIKEYHELPA)LocalAlloc(LPTR,
                sizeof(MULTIKEYHELPA) + strlen(lpAnsiKey));
        if (pmkh == NULL) {
            goto FreeAnsiKeyAndHelp;
        }

        pmkh->mkSize = sizeof(MULTIKEYHELPA) + strlen(lpAnsiKey);
        Status = RtlUnicodeToMultiByteN((LPSTR)&pmkh->mkKeylist, sizeof(CHAR),
                NULL, (LPWSTR)&((PMULTIKEYHELPW)dwData)->mkKeylist,
                sizeof(WCHAR));
        strcpy(pmkh->szKeyphrase, lpAnsiKey);
        if (!NT_SUCCESS(Status)) {
            goto FreeAnsiKeyAndHelp;
        }

        dwData = (ULONG_PTR)pmkh;
        break;

    case HELP_SETWINPOS:
        if (!WCSToMB(((PHELPWININFOW)dwData)->rgchMember, -1, &lpAnsiKey,
                -1, TRUE)) {
            goto FreeAnsiKeyAndHelp;
        }

        phwi = (PHELPWININFOA)LocalAlloc(LPTR, ((PHELPWININFOW)dwData)->wStructSize);
        if (phwi == NULL) {
            goto FreeAnsiKeyAndHelp;
        }

        *phwi = *((PHELPWININFOA)dwData);   // copies identical parts
        strcpy(phwi->rgchMember, lpAnsiKey);
        dwData = (ULONG_PTR)phwi;
        break;

    case HELP_KEY:
    case HELP_PARTIALKEY:
    case HELP_COMMAND:
        if (!WCSToMB((LPCTSTR)dwData, -1, &lpAnsiKey, -1, TRUE)) {
            goto FreeAnsiKeyAndHelp;
        }

        dwData = (ULONG_PTR)lpAnsiKey;
        break;
    }

    /*
     * Call the Ansi version
     */
    fSuccess = WinHelpA(hwndMain, lpAnsiHelp, uCommand, dwData);

    if (pmkh) {
        LocalFree(pmkh);
    }

    if (phwi) {
        LocalFree(phwi);
    }

FreeAnsiKeyAndHelp:
    if (lpAnsiKey) {
        LocalFree(lpAnsiKey);
    }


FreeAnsiHelp:
    if (lpAnsiHelp)
        LocalFree(lpAnsiHelp);

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\globals.h ===
/****************************** Module Header ******************************\
* Module Name: globals.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all of USER.DLL's global variables.  These are all
* instance-specific, i.e. each client has his own copy of these.  In general,
* there shouldn't be much reason to create instance globals.
*
* History:
* 10-18-90 DarrinM      Created.
\***************************************************************************/

#ifndef _GLOBALS_
#define _GLOBALS_

// Debug globals
#if DBG
extern INT gbCheckHandleLevel;
#endif

extern CONST ALWAYSZERO gZero;

extern int gcWheelDelta;

extern WORD gDispatchTableValues;

extern WCHAR awchSlashStar[];
extern CHAR achSlashStar[];

extern PSERVERINFO gpsi;
extern SHAREDINFO gSharedInfo;

extern HMODULE hmodUser;            // USER.DLL's hmodule
extern ULONG_PTR gHighestUserAddress;

extern BOOL gfServerProcess;        // USER is linked on the CSR server side.
extern BOOL gfSystemInitialized;    // System has been initialized
extern ACCESS_MASK gamWinSta;       // ACCESS_MASK for the current WindowStation

extern PVOID pUserHeap;

extern CONST CFNSCSENDMESSAGE gapfnScSendMessage[];

extern WCHAR szUSER32[];
extern CONST WCHAR szNull[];
extern CONST WCHAR szOneChar[];
extern WCHAR szSLASHSTARDOTSTAR[];

extern CONST BYTE mpTypeCcmd[];
extern CONST BYTE mpTypeIich[];
extern CONST UINT SEBbuttons[];
extern CONST BYTE rgReturn[];

extern ATOM atomMDIActivateProp;
extern ATOM gatomReaderMode;

extern CRITICAL_SECTION gcsLookaside;
extern CRITICAL_SECTION gcsHdc;
extern CRITICAL_SECTION gcsClipboard;
extern CRITICAL_SECTION gcsAccelCache;

#ifdef _JANUS_
extern BOOL gfEMIEnable;
extern DWORD gdwEMIControl;
extern BOOL gfDMREnable;
extern HANDLE gEventSource;
#endif

extern HDC    ghdcBits2;
extern HDC    ghdcGray;
extern HFONT  ghFontSys;
extern HBRUSH ghbrWindowText;
extern int    gcxGray;
extern int    gcyGray;

extern LPWSTR pwcHighContrastScheme;
extern LPSTR  pcHighContrastScheme;


/*
 * LATER: client-side user needs to use moveable memory objects for
 * WOW compatibility (at least until/if/when we copy all the edit control
 * code into 16-bit space);  that's also why we can't just party with
 * handles like LMHtoP does... -JeffPar
 */
#ifndef RC_INVOKED       // RC can't handle #pragmas
#undef  LHND
#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)

#undef  LMHtoP
#define LMHtoP(handle)      // Don't use this macro
#endif

/*
 * WOW HACK - apps can pass a global handle as the hInstance on a call
 * to CreateWindow for an edit control and expect allocations for the
 * control to come out of that global block. (MSJ 1/91 p.122)
 * WOW needs this hInstance during the LocalAlloc callback to set up
 * the DS for the LocalAlloc, so we pass hInstance as an 'extra' parameter.
 * !!! this is dependent on calling convention !!!
 * (SAS 6-18-92) added hack for all macros
 */

#define LOCALALLOC(dwFlags, dwBytes, hInstance)         \
                            (*pfnLocalAlloc)(dwFlags, dwBytes, hInstance)
#define LOCALREALLOC(hMem, dwBytes, dwFlags, hInstance, ppv) \
                            (*pfnLocalReAlloc)(hMem, dwBytes, dwFlags, hInstance, ppv)
#define LOCALLOCK(hMem, hInstance)                      \
                            (*pfnLocalLock)(hMem, hInstance)
#define LOCALUNLOCK(hMem, hInstance)                    \
                            (*pfnLocalUnlock)(hMem, hInstance)
#define LOCALSIZE(hMem, hInstance)                      \
                            (*pfnLocalSize)(hMem, hInstance)
#define LOCALFREE(hMem, hInstance)                      \
                            (*pfnLocalFree)(hMem, hInstance)

extern PFNFINDA             pfnFindResourceExA;
extern PFNFINDW             pfnFindResourceExW;
extern PFNLOAD              pfnLoadResource;
extern PFNLOCK              pfnLockResource;
extern PFNUNLOCK            pfnUnlockResource;
extern PFNFREE              pfnFreeResource;
extern PFNSIZEOF            pfnSizeofResource;
extern PFNLALLOC            pfnLocalAlloc;
extern PFNLREALLOC          pfnLocalReAlloc;
extern PFNLLOCK             pfnLocalLock;
extern PFNLUNLOCK           pfnLocalUnlock;
extern PFNLSIZE             pfnLocalSize;
extern PFNLFREE             pfnLocalFree;
extern PFNGETEXPWINVER      pfnGetExpWinVer;
extern PFN16GALLOC          pfn16GlobalAlloc;
extern PFN16GFREE           pfn16GlobalFree;
extern PFNGETMODFNAME       pfnGetModFileName;
extern PFNEMPTYCB           pfnWowEmptyClipBoard;
extern PFNWOWWNDPROCEX      pfnWowWndProcEx;
extern PFNWOWDLGPROCEX      pfnWowDlgProcEx;
extern PFNWOWEDITNEXTWORD   pfnWowEditNextWord;
extern PFNWOWCBSTOREHANDLE  pfnWowCBStoreHandle;
extern PFNGETPROCMODULE16   pfnWowGetProcModule;
extern PFNWOWTELLWOWTHEHDLG pfnWOWTellWOWThehDlg;
extern PFNWOWMSGBOXINDIRECTCALLBACK pfnWowMsgBoxIndirectCallback;
extern PFNWOWILSTRCMP       pfnWowIlstrcmp;
extern PFNWOWTASK16SCHEDNOTIFY pfnWowTask16SchedNotify;

extern UNICODE_STRING strRootDirectory;

/*
 * UserApiHook
 */
extern BYTE                 grgbDwpLiteHookMsg[(WM_USER + 7) / 8];
extern BYTE                 grgbWndLiteHookMsg[(WM_USER + 7) / 8];
extern BYTE                 grgbDlgLiteHookMsg[(WM_USER + 7) / 8];
extern HMODULE              ghmodUserApiHook;   // the module containing the UserApiHook hooks
extern USERAPIHOOK          guah;               // Dynamic function pointers
extern BOOL                 gfUserApiHook;      // Set TRUE if should use the UAH
extern LONG                 gcCallUserApiHook;  // reference count of ongoing calls to UserApiHook hooks
extern LONG                 gcLoadUserApiHook;  // reference count of UserApiHook module loads
extern RTL_CRITICAL_SECTION gcsUserApiHook;     // CS for UAH DLL load / unload
extern INITUSERAPIHOOK      gpfnInitUserApi;    // UserApiHook callback

#ifdef MESSAGE_PUMP_HOOK

/*
 * MessagePumpHook
 */
extern BOOL                 gfMessagePumpHook;  // Set TRUE if should use the MPH
extern LONG                 gcLoadMPH;          // reference count of MPH Init
extern MESSAGEPUMPHOOK      gmph;               // Dynamic function pointers
extern RTL_CRITICAL_SECTION gcsMPH;             // CS for MPH DLL load / unload
extern INITMESSAGEPUMPHOOK  gpfnInitMPH;        // MessagePumpHook callback

#endif


/*
 * Menu Drag and Drop
 */
extern HINSTANCE ghinstOLE;
extern FARPROC gpfnOLEOleUninitialize;
extern FARPROC gpfnOLERegisterDD;
extern FARPROC gpfnOLERevokeDD;
extern FARPROC gpfnOLEDoDD;

/*
 * Accelerator table resources list.
 */
extern PACCELCACHE gpac;

/*
 * IME Window Handling.
 */
extern DWORD gfConIme;
#define UNKNOWN_CONIME ~0

extern UNICODE_STRING strRootDirectory;

extern BOOL gfLogonProcess;
#endif // ifndef _GLOBALS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\hsz.c ===
/****************************** Module Header ******************************\
* Module Name: hsz.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* HSZ.C - DDEML String handle functions
*
* History:
* 10-28-91 Sanfords Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* DdeCreateStringHandle (DDEML API)
*
* Description:
* Create an HSZ from a string.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, HSZ, DUMMYCALLINGTYPE, DdeCreateStringHandleA, DWORD, idInst, LPCSTR, psz, int, iCodePage)
HSZ DdeCreateStringHandleA(
DWORD idInst,
LPCSTR psz,
int iCodePage)
{
    if (iCodePage == 0) {
        iCodePage = CP_WINANSI;
    }
    return (InternalDdeCreateStringHandle(idInst, (PVOID)psz, iCodePage));
}



FUNCLOG3(LOG_GENERAL, HSZ, DUMMYCALLINGTYPE, DdeCreateStringHandleW, DWORD, idInst, LPCWSTR, psz, int, iCodePage)
HSZ DdeCreateStringHandleW(
DWORD idInst,
LPCWSTR psz,
int iCodePage)
{
    if (iCodePage == 0) {
        iCodePage = CP_WINUNICODE;
    }
    return (InternalDdeCreateStringHandle(idInst, (PVOID)psz, iCodePage));
}



HSZ InternalDdeCreateStringHandle(
DWORD idInst,
PVOID psz,
int iCodePage)
{
    PCL_INSTANCE_INFO pcii;
    HSZ hszRet = 0;
    int cb;
    WCHAR szw[256];

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    switch (iCodePage) {
    case CP_WINANSI:
        if (*(LPSTR)psz == '\0') {
            goto Exit;
        }
        hszRet = NORMAL_HSZ_FROM_LATOM(AddAtomA((LPSTR)psz));
        break;

    default:

        /*
         * Convert psz to unicode and fall through.
         */
        cb = sizeof(szw) /  sizeof(WCHAR);
#ifdef LATER
        MultiByteToWideChar((UINT)iCodePage, MB_PRECOMPOSED,
                            (LPSTR)psz, -1, szw, cb);
#endif
        psz = &szw[0];


    case CP_WINUNICODE:
        if (*(LPWSTR)psz == L'\0') {
            goto Exit;
        }
        hszRet = NORMAL_HSZ_FROM_LATOM(AddAtomW((LPWSTR)psz));
        break;
    }
    MONHSZ(pcii, hszRet, MH_CREATE);

Exit:
    LeaveDDECrit;
    return (hszRet);
}



/***************************************************************************\
* DdeQueryString (DDEML API)
*
* Description:
* Recall the string associated with an HSZ.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG5(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, DdeQueryStringA, DWORD, idInst, HSZ, hsz, LPSTR, psz, DWORD, cchMax, INT, iCodePage)
DWORD DdeQueryStringA(
DWORD idInst,
HSZ hsz,
LPSTR psz,
DWORD cchMax,
INT iCodePage)
{
    if (iCodePage == 0) {
        iCodePage = CP_WINANSI;
    }
    return (InternalDdeQueryString(idInst, hsz, psz, cchMax, iCodePage));
}



FUNCLOG5(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, DdeQueryStringW, DWORD, idInst, HSZ, hsz, LPWSTR, psz, DWORD, cchMax, INT, iCodePage)
DWORD DdeQueryStringW(
DWORD idInst,
HSZ hsz,
LPWSTR psz,
DWORD cchMax,
INT iCodePage)
{
    if (iCodePage == 0) {
        iCodePage = CP_WINUNICODE;
    }
    return (InternalDdeQueryString(idInst, hsz, psz, cchMax * sizeof(WCHAR), iCodePage));
}


DWORD InternalDdeQueryString(
DWORD idInst,
HSZ hsz,
PVOID psz,
DWORD cbMax,
INT iCodePage)
{
    PCL_INSTANCE_INFO pcii;
    DWORD dwRet = 0;
    WCHAR szw[256];
// BOOL fDefUsed; // LATER

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (ValidateHSZ(hsz) == HSZT_INVALID) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (LATOM_FROM_HSZ(hsz) == 0) {
        if (iCodePage == CP_WINUNICODE) {
            if (psz != NULL) {
                *(LPWSTR)psz = L'\0';
            }
            dwRet = sizeof(WCHAR);
            goto Exit;
        } else {
            if (psz != NULL) {
                *(LPSTR)psz = '\0';
            }
            dwRet = sizeof(CHAR);
            goto Exit;
        }
    }

    if (psz == NULL) {
        cbMax = sizeof(szw);
        psz = (PVOID)szw;
    }

    switch (iCodePage) {
    case CP_WINANSI:
        dwRet = GetAtomNameA(LATOM_FROM_HSZ(hsz), psz, cbMax);
        break;

    default:
        dwRet = GetAtomNameW(LATOM_FROM_HSZ(hsz), (LPWSTR)psz, cbMax / sizeof(WCHAR));
        if (iCodePage != CP_WINUNICODE) {

            /*
             * convert psz to the appropriate codepage and count the
             * characters(ie BYTES for DBCS!) to alter dwRet.
             */
#ifdef LATER
            // Does this routine work in place? (i.e. input and output buffer the same).
            WideCharToMultiByte((UINT)iCodePage, 0, szw,
                    sizeof(szw) /  sizeof(WCHAR),
                    (LPSTR)psz, cbMax, NULL, &fDefUsed);
#endif
            dwRet = cbMax + 1;
        }
        break;
    }

Exit:
    LeaveDDECrit;
    return (dwRet);
}



/***************************************************************************\
* DdeFreeStringHandle (DDEML API)
*
* Description:
* Decrement the use count of an HSZ.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeFreeStringHandle, DWORD, idInst, HSZ, hsz)
BOOL DdeFreeStringHandle(
DWORD idInst,
HSZ hsz)
{
    PCL_INSTANCE_INFO pcii;
    BOOL fRet = FALSE;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (ValidateHSZ(hsz) == HSZT_INVALID) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    MONHSZ(pcii, hsz, MH_DELETE);
    fRet = TRUE;
    if (LATOM_FROM_HSZ(hsz) != 0) {
        if (DeleteAtom(LATOM_FROM_HSZ(hsz))) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            fRet = FALSE;
        }
    }

Exit:
    LeaveDDECrit;
    return (fRet);
}



/***************************************************************************\
* DdeKeepStringHandle (DDEML API)
*
* Description:
* Increments the use count of an HSZ.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeKeepStringHandle, DWORD, idInst, HSZ, hsz)
BOOL DdeKeepStringHandle(
DWORD idInst,
HSZ hsz)
{
    PCL_INSTANCE_INFO pcii;
    BOOL fRet = FALSE;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (ValidateHSZ(hsz) == HSZT_INVALID) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (LATOM_FROM_HSZ(hsz) == 0) {
        fRet = TRUE;
        goto Exit;
    }
    MONHSZ(pcii, hsz, MH_KEEP);
    fRet = IncLocalAtomCount(LATOM_FROM_HSZ(hsz)) ? TRUE : FALSE;

Exit:
    LeaveDDECrit;
    return (fRet);
}



/***************************************************************************\
* DdeCmpStringHandles (DDEML API)
*
* Description:
* Useless comparison of hszs. Provided for case sensitivity expandability.
* Direct comparison of hszs would be a case sensitive comparison while
* using this function would be case-insensitive. For now both ways are ==.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, int, DUMMYCALLINGTYPE, DdeCmpStringHandles, HSZ, hsz1, HSZ, hsz2)
int DdeCmpStringHandles(
HSZ hsz1,
HSZ hsz2)
{
    if (hsz2 > hsz1) {
        return (-1);
    } else if (hsz2 < hsz1) {
        return (1);
    } else {
        return (0);
    }
}


/***************************************************************************\
* ValidateHSZ
*
* Description:
* Verifies the probability of a reasonable hsz
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
DWORD ValidateHSZ(
HSZ hsz)
{
    if (hsz == 0) {
        return (HSZT_NORMAL);
    }
    if (LOWORD((ULONG_PTR)hsz) < 0xC000) {
        return (HSZT_INVALID);
    }
    if (HIWORD((ULONG_PTR)hsz) == 0) {
        return (HSZT_NORMAL);
    }
    if (HIWORD((ULONG_PTR)hsz) == 1) {
        return (HSZT_INST_SPECIFIC);
    }
    return (HSZT_INVALID);
}

/***************************************************************************\
* MakeInstSpecificAtom
*
* Description:
* Creates a new atom that has hwnd imbeded into it.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
LATOM MakeInstSpecificAtom(
LATOM la,
HWND hwnd)
{
    WCHAR sz[256];
    LPWSTR psz;

    if (GetAtomName(la, sz, 256) == 0) {
        return (0);
    }
#ifdef UNICODE
    psz = sz + wcslen(sz);
#else
    psz = sz + strlen(sz);
#endif
    wsprintf(psz, TEXT("(%#p)"), hwnd);
    la = AddAtom(sz);
    return (la);
}



/***************************************************************************\
* ParseInstSpecificAtom
*
* Description:
* Extracts the hwnd value out of the atom.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
HWND ParseInstSpecificAtom(
LATOM la,
LATOM *plaNormal)
{
    CHAR sz[256];
    LPSTR pszHwnd;
    HWND hwnd;

    /*
     * LATER- NEED TO MAKE THIS UNICODE BASED WHEN WE GET A SCANF WE CAN USE
     */
    if (GetAtomNameA(la, sz, 256) == 0) {
        return (0);
    }
    pszHwnd = strrchr(sz, '(');
    if (pszHwnd == NULL) {
        return (0);
    }
    if (sscanf(pszHwnd, "(%#p)", &hwnd) != 1) {
        return (0);
    }
    if (plaNormal != NULL) {
        *pszHwnd = '\0';
        *plaNormal = AddAtomA(sz);
    }
    return (hwnd);
}




/***************************************************************************\
* LocalToGlobalAtom
*
* Description:
* Converts a Local Atom to a Global Atom
*
* History:
* 12-1-91 sanfords Created.
\***************************************************************************/
GATOM LocalToGlobalAtom(
LATOM la)
{
    WCHAR sz[256];

    if (la == 0) {
        return (0);
    }
    if (GetAtomName((ATOM)la, sz, 256) == 0) {
        RIPMSG0(RIP_WARNING, "LocalToGlobalAtom out of memory");
        return (0);
    }
    return ((GATOM)GlobalAddAtom(sz));
}



/***************************************************************************\
* GlobalToLocalAtom
*
* Description:
* Converts a Global Atom to a Local Atom
*
* History:
* 12-1-91 sanfords Created.
\***************************************************************************/
LATOM GlobalToLocalAtom(
GATOM ga)
{
    WCHAR sz[256];

    if (ga == 0) {
        return (0);
    }
    if (GlobalGetAtomName((ATOM)ga, sz, 256) == 0) {
        RIPMSG0(RIP_WARNING, "GlobalToLocalAtom out of memory");
        return (0);
    }
    return ((LATOM)AddAtom(sz));
}


/***************************************************************************\
* IncGlobalAtomCount
*
* Description:
* Duplicates an atom.
*
*
* History:
* 1-22-91 sanfords Created.
\***************************************************************************/
GATOM IncGlobalAtomCount(
GATOM ga)
{
    WCHAR sz[256];

    if (ga == 0) {
        return (0);
    }
    if (GlobalGetAtomName(ga, sz, 256) == 0) {
        RIPMSG0(RIP_WARNING, "IncGlobalAtomCount out of memory");
        return (0);
    }
    return ((GATOM)GlobalAddAtom(sz));
}


/***************************************************************************\
* IncGlobalAtomCount
*
* Description:
* Duplicates an atom.
*
*
* History:
* 1-22-91 sanfords Created.
\***************************************************************************/
LATOM IncLocalAtomCount(
LATOM la)
{
    WCHAR sz[256];

    if (la == 0) {
        return (0);
    }
    if (GetAtomName(la, sz, 256) == 0) {
        RIPMSG0(RIP_WARNING, "IncLocalAtomCount out of memory");
        return (0);
    }
    return ((LATOM)AddAtom(sz));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\imectl.c ===
/**************************************************************************\
* Module Name: imectl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME Window Handling Routines
*
* History:
* 20-Dec-1995 wkwok
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <intlshar.h>

#define LATE_CREATEUI 1

CONST WCHAR szIndicDLL[] = L"indicdll.dll";

FARPROC gpfnGetIMEMenuItemData = NULL;
BOOL IMEIndicatorGetMenuIDData(PUINT puMenuID, PDWORD pdwData);

/*
 * Local Routines.
 */
LONG ImeWndCreateHandler(PIMEUI, LPCREATESTRUCT);
void ImeWndDestroyHandler(PIMEUI);
LRESULT ImeSystemHandler(PIMEUI, UINT, WPARAM, LPARAM);
LONG ImeSelectHandler(PIMEUI, UINT, WPARAM, LPARAM);
LRESULT ImeControlHandler(PIMEUI, UINT, WPARAM, LPARAM, BOOL);
LRESULT ImeSetContextHandler(PIMEUI, UINT, WPARAM, LPARAM);
LRESULT ImeNotifyHandler(PIMEUI, UINT, WPARAM, LPARAM);
HWND CreateIMEUI(PIMEUI, HKL);
VOID DestroyIMEUI(PIMEUI);
LRESULT SendMessageToUI(PIMEUI, UINT, WPARAM, LPARAM, BOOL);
VOID SendOpenStatusNotify(PIMEUI, HWND, BOOL);
VOID ImeSetImc(PIMEUI, HIMC);
VOID FocusSetIMCContext(HWND, BOOL);
BOOL ImeBroadCastMsg(PIMEUI, UINT, WPARAM, LPARAM);
VOID ImeMarkUsedContext(HWND, HIMC);
BOOL ImeIsUsableContext(HWND, HIMC);
BOOL GetIMEShowStatus(void);
LRESULT ImeCopyDataHandler(WPARAM, LPARAM);

/*
 * Common macros for IME UI, HKL and IMC handlings
 */
#define GETHKL(pimeui)        (KHKL_TO_HKL(pimeui->hKL))
#define SETHKL(pimeui, hkl)   (pimeui->hKL=(hkl))
#define GETIMC(pimeui)        (KHIMC_TO_HIMC(pimeui->hIMC))
#define SETIMC(pimeui, himc)  (ImeSetImc(pimeui, KHIMC_TO_HIMC(himc)))
#define GETUI(pimeui)         (KHWND_TO_HWND(pimeui->hwndUI))
#define SETUI(pimeui, hwndui) (pimeui->hwndUI=(hwndui))

LOOKASIDE ImeUILookaside;

/***************************************************************************\
* NtUserBroadcastImeShowStatusChange(), NtUserCheckImeShowStatusInThread()
*
* Stub for kernel mode routines
*
\***************************************************************************/

_inline void NtUserBroadcastImeShowStatusChange(HWND hwndDefIme, BOOL fShow)
{
    NtUserCallHwndParamLock(hwndDefIme, fShow, SFI_XXXBROADCASTIMESHOWSTATUSCHANGE);
}

_inline void NtUserCheckImeShowStatusInThread(HWND hwndDefIme)
{
    NtUserCallHwndLock(hwndDefIme, SFI_XXXCHECKIMESHOWSTATUSINTHREAD);
}

/***************************************************************************\
* ImeWndProc
*
* WndProc for IME class
*
* History:
\***************************************************************************/

LRESULT APIENTRY ImeWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND        hwnd = HWq(pwnd);
    PIMEUI      pimeui;
    static BOOL fInit = TRUE;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, FNID_IME);
    INITCONTROLLOOKASIDE(&ImeUILookaside, IMEUI, spwnd, 8);

#ifdef CUAS_ENABLE
    if (IS_CICERO_ENABLED()) {
        LRESULT lRet;
        lRet = fpCtfImmDispatchDefImeMessage(hwnd, message, wParam, lParam);
        if (lRet)
            return lRet;
    }
#endif

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_IME))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);

    /*
     * Get the pimeui for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,pimeui) when
     * we initially created the IME control.
     */
    pimeui = ((PIMEWND)pwnd)->pimeui;

    if (pimeui == NULL) {
        /*
         * Further processing not needed
         */
        RIPMSG0(RIP_WARNING, "ImeWndProcWorker: pimeui == NULL\n");
        return 0L;
    }

    /*
     * This is necessary to avoid recursion call from IME UI.
     */
    UserAssert(pimeui->nCntInIMEProc >= 0);

    if (pimeui->nCntInIMEProc > 0) {
        TAGMSG5(DBGTAG_IMM, "ImeWndProcWorker: Recursive for pwnd=%08p, msg=%08x, wp=%08x, lp=%08x, fAnsi=%d\n",
                pwnd, message, wParam, lParam, fAnsi);
        switch (message) {
        case WM_IME_SYSTEM:
            switch (wParam) {
            case IMS_ISACTIVATED:
            case IMS_SETOPENSTATUS:
//          case IMS_SETCONVERSIONSTATUS:
            case IMS_SETSOFTKBDONOFF:
                /*
                 * Because these will not be pass to UI.
                 * We can do it.
                 */
                break;

            default:
                return 0L;
            }
            break;

        case WM_IME_STARTCOMPOSITION:
        case WM_IME_ENDCOMPOSITION:
        case WM_IME_COMPOSITION:
        case WM_IME_SETCONTEXT:
#if !defined(CUAS_ENABLE)
        case WM_IME_NOTIFY:
#endif
        case WM_IME_CONTROL:
        case WM_IME_COMPOSITIONFULL:
        case WM_IME_SELECT:
        case WM_IME_CHAR:
        case WM_IME_REQUEST:
            return 0L;

#ifdef CUAS_ENABLE
        case WM_IME_NOTIFY:
            if (wParam >= IMN_PRIVATE &&
                ! IS_IME_KBDLAYOUT(GETHKL(pimeui)) && IS_CICERO_ENABLED()) {
                //
                // CUAS: IMN_PRIVATE always call UI window.
                //
                break;
            }
            return 0L;
#endif

        default:
            return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
        }
    }

    if (TestWF(pwnd, WFINDESTROY) || TestWF(pwnd, WFDESTROYED)) {
        switch (message) {
        case WM_DESTROY:
        case WM_NCDESTROY:
        case WM_FINALDESTROY:
            break;
        default:
            RIPMSG1(RIP_WARNING, "ImeWndProcWorker: message %x is sent to destroyed window.", message);
            return 0L;
        }
    }

    switch (message) {
    case WM_ERASEBKGND:
        return (LONG)TRUE;

    case WM_PAINT:
        break;

    case WM_CREATE:

        return ImeWndCreateHandler(pimeui, (LPCREATESTRUCT)lParam);

    case WM_DESTROY:
        /*
         * We are destroying the IME window, destroy
         * any UI window that it owns.
         */
        ImeWndDestroyHandler(pimeui);
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        if (pimeui) {
            Unlock(&pimeui->spwnd);
            FreeLookasideEntry(&ImeUILookaside, pimeui);
        }
        NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);
        goto CallDWP;

    case WM_IME_SYSTEM:
        UserAssert(pimeui->spwnd == pwnd);
        return ImeSystemHandler(pimeui, message, wParam, lParam);

    case WM_IME_SELECT:
        return ImeSelectHandler(pimeui, message, wParam, lParam);

    case WM_IME_CONTROL:
        return ImeControlHandler(pimeui, message, wParam, lParam, fAnsi);

    case WM_IME_SETCONTEXT:
        return ImeSetContextHandler(pimeui, message, wParam, lParam);

    case WM_IME_NOTIFY:
        return ImeNotifyHandler(pimeui, message, wParam, lParam);

    case WM_IME_REQUEST:
        return 0;

    case WM_IME_COMPOSITION:
    case WM_IME_ENDCOMPOSITION:
    case WM_IME_STARTCOMPOSITION:
        return SendMessageToUI(pimeui, message, wParam, lParam, fAnsi);

    case WM_COPYDATA:
        return ImeCopyDataHandler(wParam, lParam);

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }

    return 0L;
}


LRESULT WINAPI ImeWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    return ImeWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}


LRESULT WINAPI ImeWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    return ImeWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}


LONG ImeWndCreateHandler(
    PIMEUI pimeui,
    LPCREATESTRUCT lpcs)
{
    PWND pwndParent;
    HIMC hImc;
    PWND pwndIme = pimeui->spwnd;
#if _DBG
    static DWORD dwFirstWinlogonThreadId;
#endif

#if _DBG
    /*
     * For Winlogon, only the first thread can have IME processing.
     */
    if (gfLogonProcess) {
        UserAssert(dwFirstWinLogonThreadId == 0);
        dwFirstWinlogonThreadId = GetCurrentThreadId();
    }
#endif

    if (!TestWF(pwndIme, WFPOPUP) || !TestWF(pwndIme, WFDISABLED)) {
        RIPMSG0(RIP_WARNING, "IME window should have WS_POPUP and WS_DISABLE!!");
        return -1L;
    }

    /*
     * Check with parent window, if exists, try to get IMC.
     * If this is top level window, wait for first WM_IME_SETCONTEXT.
     */
    if ((pwndParent = ValidateHwndNoRip(lpcs->hwndParent)) != NULL) {
        hImc = KHIMC_TO_HIMC(pwndParent->hImc);
        if (hImc != NULL_HIMC && ImeIsUsableContext(HWq(pwndIme), hImc)) {
            /*
             * Store it for later use.
             */
            SETIMC(pimeui, hImc);
        }
        else {
            SETIMC(pimeui, NULL_HIMC);
        }
    }
    else {
        SETIMC(pimeui, NULL_HIMC);
    }

    /*
     * Initialize status window show state
     * The status window is not open yet.
     */
    pimeui->fShowStatus = 0;
    pimeui->nCntInIMEProc = 0;
    pimeui->fActivate = 0;
    pimeui->fDestroy = 0;
    pimeui->hwndIMC = NULL;
    pimeui->hKL = THREAD_HKL();
    pimeui->fCtrlShowStatus = TRUE;

#if !defined(CUAS_ENABLE)  // move to LoadThreadLayout
    /*
     * Load up the IME DLL of current keyboard layout.
     */
    fpImmLoadIME(GETHKL(pimeui));

#ifdef LATE_CREATEUI
    SETUI(pimeui, NULL);
#else
    SETUI(pimeui, CreateIMEUI(pimeui, pimeui->hKL));
#endif

#else

    // Cicero
    pimeui->dwPrevToolbarStatus = 0;

#endif // CUAS_ENABLE // move to LoadThreadLayout

    return 0L;
}

void ImeWndDestroyHandler(
    PIMEUI pimeui)
{
    DestroyIMEUI(pimeui);
}


#ifdef CUAS_ENABLE

VOID
CtfLoadThreadLayout(
    PIMEUI pimeui)
{
#if 1
    /*
     * Cicero Unaware Support. Activate Thread Input Manager.
     */
    fpCtfImmTIMActivate(pimeui->hKL);

    /*
     * Load up the IME DLL of current keyboard layout.
     */
    pimeui->hKL = THREAD_HKL();        // Reload thread hKL if TIM activated, hKL changed.
    fpImmLoadIME(GETHKL(pimeui));

#ifdef LATE_CREATEUI
    SETUI(pimeui, NULL);
#else
    SETUI(pimeui, CreateIMEUI(pimeui, pimeui->hKL));
#endif

#else
    UNREFERENCED_PARAMETER(pimeui);
#endif
}

#endif // CUAS_ENABLE

/***************************************************************************\
* ImeRunHelp
*
* Display Help file (HLP and CHM).
*
* History:
* 27-Oct-98 Hiroyama
\***************************************************************************/

void ImeRunHelp(LPWSTR wszHelpFile)
{
    static const WCHAR wszHelpFileExt[] = L".HLP";
    UINT cchLen = wcslen(wszHelpFile);

    if (cchLen > 4 && _wcsicmp(wszHelpFile + cchLen - 4, wszHelpFileExt) == 0) {
#ifdef FYI
        WinHelpW(NULL, wszHelpFile, HELP_CONTENTS, 0);
#else
        WinHelpW(NULL, wszHelpFile, HELP_FINDER, 0);
#endif
    } else {
        //
        // If it's not HLP file, try to run hh.exe, HTML based
        // help tool. It should be in %windir%\hh.exe.
        //
        static const WCHAR wszHH[] = L"hh.exe ";
        WCHAR wszCmdLine[MAX_PATH * 2];
        LPWSTR lpwszCmdLine = wszCmdLine;
        DWORD               idProcess;
        STARTUPINFO         StartupInfo;
        PROCESS_INFORMATION ProcessInformation;
        UINT i;

        i = GetSystemWindowsDirectoryW(wszCmdLine, MAX_PATH);
        if (i > 0 && i < MAX_PATH - cchLen - (sizeof L'\\' + sizeof wszHH) / sizeof(WCHAR)) {
            lpwszCmdLine += i;
            if (lpwszCmdLine[-1] != L'\\') {
                *lpwszCmdLine++ = L'\\';
            }
        }
        wcscpy(lpwszCmdLine, wszHH);
        wcscat(lpwszCmdLine, wszHelpFile);

        /*
         *  Launch HTML Help.
         */
        RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.wShowWindow = SW_SHOW;
        StartupInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_FORCEONFEEDBACK;

        TAGMSG1(DBGTAG_IMM, "Invoking help with '%S'", wszCmdLine);

        idProcess = (DWORD)CreateProcessW(NULL, wszCmdLine,
                NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &StartupInfo,
                &ProcessInformation);

        if (idProcess) {
            WaitForInputIdle(ProcessInformation.hProcess, 10000);
            NtClose(ProcessInformation.hProcess);
            NtClose(ProcessInformation.hThread);
        }
    }
}

LRESULT ImeSystemHandler(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    PINPUTCONTEXT pInputContext;
    HIMC          hImc = GETIMC(pimeui);
    LRESULT       dwRet = 0L;

    UNREFERENCED_PARAMETER(message);

    switch (wParam) {

    case IMS_SETOPENCLOSE:
        if (hImc != NULL_HIMC)
            fpImmSetOpenStatus(hImc, (BOOL)lParam);
        break;

    case IMS_WINDOWPOS:
        if (hImc != NULL_HIMC) {
            BOOL f31Hidden = FALSE;

            if ((pInputContext = fpImmLockIMC(hImc)) != NULL) {
                f31Hidden = (pInputContext->fdw31Compat & F31COMPAT_MCWHIDDEN);
                fpImmUnlockIMC(hImc);
            }

            if (IsWindow(KHWND_TO_HWND(pimeui->hwndIMC))) {
                int i;

                if (!f31Hidden) {
                    COMPOSITIONFORM cof;

                    if (fpImmGetCompositionWindow(hImc, &cof) && cof.dwStyle != CFS_DEFAULT) {
                        fpImmSetCompositionWindow(hImc, &cof);
                    }
                }

                for (i = 0; i < 4 ; i++) {
                    CANDIDATEFORM caf;

                    if (fpImmGetCandidateWindow(hImc, (DWORD)i, &caf) && caf.dwStyle != CFS_DEFAULT) {
                        fpImmSetCandidateWindow(hImc, &caf);
                    }
                }
            }
        }
        break;

    case IMS_ACTIVATECONTEXT:
        FocusSetIMCContext((HWND)(lParam), TRUE);
        break;

    case IMS_DEACTIVATECONTEXT:
        FocusSetIMCContext((HWND)(lParam), FALSE);
        break;

#ifdef CUAS_ENABLE
    case IMS_LOADTHREADLAYOUT:
        CtfLoadThreadLayout(pimeui);
        break;
#endif // CUAS_ENABLE

    case IMS_UNLOADTHREADLAYOUT:
        return (LONG)(fpImmFreeLayout((DWORD)lParam));

    case IMS_ACTIVATETHREADLAYOUT:
        return (LONG)(fpImmActivateLayout((HKL)lParam));

    case IMS_SETCANDIDATEPOS:
        if ( (pInputContext = fpImmLockIMC( hImc )) != NULL ) {
            LPCANDIDATEFORM lpcaf;
            DWORD dwIndex = (DWORD)lParam;

            lpcaf = &(pInputContext->cfCandForm[dwIndex]);
            fpImmSetCandidateWindow( hImc, lpcaf );
            fpImmUnlockIMC( hImc );
        }
        break;

    case IMS_SETCOMPOSITIONWINDOW:
        if ( (pInputContext = fpImmLockIMC( hImc )) != NULL ) {
            LPCOMPOSITIONFORM lpcof;

            lpcof = &(pInputContext->cfCompForm);
            pInputContext->fdw31Compat |= F31COMPAT_CALLFROMWINNLS;
            fpImmSetCompositionWindow( hImc, lpcof);
        }
        break;

    case IMS_SETCOMPOSITIONFONT:
        if ( (pInputContext = fpImmLockIMC( hImc )) != NULL ) {
            LPLOGFONT lplf;

            lplf = &(pInputContext->lfFont.W);
            fpImmSetCompositionFont( hImc, lplf );
        }
        break;

    case IMS_CONFIGUREIME:
        fpImmConfigureIMEW( (HKL)lParam, KHWND_TO_HWND(pimeui->hwndIMC), IME_CONFIG_GENERAL, NULL);
        break;

    case IMS_CHANGE_SHOWSTAT:
        // Private message from internat.exe
        // Before it reaches here, the registry is already updated.
        if (GetIMEShowStatus() == !lParam) {
#if 1
            NtUserBroadcastImeShowStatusChange(HW(pimeui->spwnd), !!lParam);
#else
            SystemParametersInfo(SPI_SETSHOWIMEUI, lParam, NULL, FALSE);
#endif
        }
        break;

    case IMS_GETCONVERSIONMODE:
    {
        DWORD dwConv = 0;
        DWORD dwTemp;

        fpImmGetConversionStatus(hImc, &dwConv, &dwTemp);
        return (dwConv);
        break;
    }

    case IMS_SETSOFTKBDONOFF:
        fpImmEnumInputContext(0, SyncSoftKbdState, lParam);
        break;

    case IMS_GETIMEMENU:
        // new in NT50
        // IMS_GETIEMMENU is used to handle Inter Process GetMenu.
        // NOTE: This operation is only intended to internat.exe
        return fpImmPutImeMenuItemsIntoMappedFile((HIMC)lParam);

    case IMS_IMEHELP:
        dwRet = IME_ESC_GETHELPFILENAME;
        dwRet = fpImmEscapeW(GETHKL(pimeui), GETIMC(pimeui), IME_ESC_QUERY_SUPPORT, (LPVOID)&dwRet);
        if (lParam) {
            // try to run WinHelp
            WCHAR wszHelpFile[MAX_PATH];

            if (dwRet) {
                if (fpImmEscapeW(GETHKL(pimeui), GETIMC(pimeui), IME_ESC_GETHELPFILENAME,
                        (LPVOID)wszHelpFile)) {
                    ImeRunHelp(wszHelpFile);
                }
            }
        }
        return dwRet;

    case IMS_GETCONTEXT:
        dwRet = (ULONG_PTR)fpImmGetContext((HWND)lParam);
        return dwRet;

    case IMS_ENDIMEMENU:
        // New in NT5.0: Special support for Internat.exe
        if (IsWindow((HWND)lParam)) {
            HIMC hImc;
            UINT uID;
            DWORD dwData;

            hImc = fpImmGetContext((HWND)lParam);

            if (hImc != NULL) {
                //
                // Call Indicator to get IME menu data.
                //
                if (IMEIndicatorGetMenuIDData(&uID, &dwData)) {
                    fpImmNotifyIME(hImc, NI_IMEMENUSELECTED, uID, dwData);
                }
                fpImmReleaseContext((HWND)lParam, hImc);
            }
        }
        break;

    case IMS_SENDNOTIFICATION:
    case IMS_FINALIZE_COMPSTR:
        dwRet = fpImmSystemHandler(hImc, wParam, lParam);
        break;

#ifdef CUAS_ENABLE
    case IMS_SETLANGBAND:
    case IMS_RESETLANGBAND:
        dwRet = fpImmSystemHandler(hImc, wParam, lParam);
        break;
#endif // CUAS_ENABLE

    default:
        break;
    }

    return dwRet;
}


LONG ImeSelectHandler(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndUI;

    /*
     * Deliver this message to other IME windows in this thread.
     */
    if (pimeui->fDefault)
        ImeBroadCastMsg(pimeui, message, wParam, lParam);

    /*
     * We must re-create UI window of newly selected IME.
     */
    if ((BOOL)wParam == TRUE) {
        UserAssert(!IsWindow(GETUI(pimeui)));

        SETHKL(pimeui, (HKL)lParam);

#ifdef LATE_CREATEUI
        if (!pimeui->fActivate)
            return 0L;
#endif

        hwndUI = CreateIMEUI(pimeui, (HKL)lParam);

        SETUI(pimeui, hwndUI);

        if (hwndUI != NULL) {
            SetWindowLongPtr(hwndUI, IMMGWLP_IMC, (LONG_PTR)GETIMC(pimeui));
            SendMessageToUI(pimeui, message, wParam, lParam, FALSE);
        }

        if (GetIMEShowStatus() && pimeui->fCtrlShowStatus) {
            if (!pimeui->fShowStatus && pimeui->fActivate &&
                    IsWindow(KHWND_TO_HWND(pimeui->hwndIMC))) {
                /*
                 * This must be sent to an application as an app may want
                 * to hook this message to do its own UI.
                 */
                SendOpenStatusNotify(pimeui, KHWND_TO_HWND(pimeui->hwndIMC), TRUE);
            }
        }
    }
    else {

        if (pimeui->fShowStatus && pimeui->fActivate &&
                IsWindow(KHWND_TO_HWND(pimeui->hwndIMC))) {
            /*
             * This must be sent to an application as an app may want
             * to hook this message to do its own UI.
             */
            SendOpenStatusNotify(pimeui, KHWND_TO_HWND(pimeui->hwndIMC), FALSE);
        }

        SendMessageToUI(pimeui, message, wParam, lParam, FALSE);

        DestroyIMEUI(pimeui);

        SETHKL(pimeui, (HKL)NULL);
    }

    return 0L;
}


LRESULT ImeControlHandler(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL   fAnsi)
{
    HIMC  hImc;
    DWORD dwConversion, dwSentence;

#ifdef CUAS_ENABLE
    if (IS_CICERO_ENABLED()) {
        if (wParam == IMC_OPENSTATUSWINDOW) {
            fpCtfImmRestoreToolbarWnd(pimeui->dwPrevToolbarStatus);
            pimeui->dwPrevToolbarStatus = 0;
        }
        else if (wParam == IMC_CLOSESTATUSWINDOW) {
            pimeui->dwPrevToolbarStatus = fpCtfImmHideToolbarWnd();
        }
    }
#endif // CUAS_ENABLE

    /*
     * Do nothing with NULL hImc.
     */
    if ((hImc = GETIMC(pimeui)) == NULL_HIMC)
        return 0L;

    switch (wParam) {

    case IMC_OPENSTATUSWINDOW:
        if (GetIMEShowStatus() && !pimeui->fShowStatus) {
            pimeui->fShowStatus = TRUE;
            SendMessageToUI(pimeui, WM_IME_NOTIFY,
                    IMN_OPENSTATUSWINDOW, 0L, FALSE);
        }
        pimeui->fCtrlShowStatus = TRUE;
        break;

    case IMC_CLOSESTATUSWINDOW:
        if (GetIMEShowStatus() && pimeui->fShowStatus) {
            pimeui->fShowStatus = FALSE;
            SendMessageToUI(pimeui, WM_IME_NOTIFY,
                    IMN_CLOSESTATUSWINDOW, 0L, FALSE);
        }
        pimeui->fCtrlShowStatus = FALSE;
        break;

    /*
     * ------------------------------------------------
     * IMC_SETCOMPOSITIONFONT,
     * IMC_SETCONVERSIONMODE,
     * IMC_SETOPENSTATUS
     * ------------------------------------------------
     * Don't pass these WM_IME_CONTROLs to UI window.
     * Call Imm in order to process these requests instead.
     * It makes message flows simpler.
     */
    case IMC_SETCOMPOSITIONFONT:
        if (fAnsi) {
            if (!fpImmSetCompositionFontA(hImc, (LPLOGFONTA)lParam))
                return 1L;
        }
        else {
            if (!fpImmSetCompositionFontW(hImc, (LPLOGFONTW)lParam))
                return 1L;
        }
        break;

    case IMC_SETCONVERSIONMODE:
        if (!fpImmGetConversionStatus(hImc, &dwConversion, &dwSentence) ||
            !fpImmSetConversionStatus(hImc, (DWORD)lParam, dwSentence))
            return 1L;
        break;

    case IMC_SETSENTENCEMODE:
        if (!fpImmGetConversionStatus(hImc, &dwConversion, &dwSentence) ||
            !fpImmSetConversionStatus(hImc, dwConversion, (DWORD)lParam))
            return 1L;
        break;

    case IMC_SETOPENSTATUS:
        if (!fpImmSetOpenStatus(hImc, (BOOL)lParam))
            return 1L;
        break;

    case IMC_GETCONVERSIONMODE:
        if (!fpImmGetConversionStatus(hImc,&dwConversion, &dwSentence))
            return 1L;

        return (LONG)dwConversion;

    case IMC_GETSENTENCEMODE:
        if (!fpImmGetConversionStatus(hImc,&dwConversion, &dwSentence))
            return 1L;

        return (LONG)dwSentence;

    case IMC_GETOPENSTATUS:
        return (LONG)fpImmGetOpenStatus(hImc);

    case IMC_GETCOMPOSITIONFONT:
        if (fAnsi) {
            if (!fpImmGetCompositionFontA(hImc, (LPLOGFONTA)lParam))
                return 1L;
        }
        else {
            if (!fpImmGetCompositionFontW(hImc, (LPLOGFONTW)lParam))
                return 1L;
        }
        break;

    case IMC_SETCOMPOSITIONWINDOW:
        if (!fpImmSetCompositionWindow(hImc, (LPCOMPOSITIONFORM)lParam))
            return 1L;
        break;

    case IMC_SETSTATUSWINDOWPOS:
        {
            POINT ppt;

            ppt.x = (LONG)((LPPOINTS)&lParam)->x;
            ppt.y = (LONG)((LPPOINTS)&lParam)->y;

            if (!fpImmSetStatusWindowPos(hImc, &ppt))
                return 1L;
        }
        break;

    case IMC_SETCANDIDATEPOS:
        if (!fpImmSetCandidateWindow(hImc, (LPCANDIDATEFORM)lParam))
            return 1;
        break;

    /*
     * Followings are the messsages to be sent to UI.
     */
    case IMC_GETCANDIDATEPOS:
    case IMC_GETSTATUSWINDOWPOS:
    case IMC_GETCOMPOSITIONWINDOW:
    case IMC_GETSOFTKBDPOS:
    case IMC_SETSOFTKBDPOS:
        return SendMessageToUI(pimeui, message, wParam, lParam, fAnsi);

    default:
        break;
    }

    return 0L;
}



LRESULT ImeSetContextHandler(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND  hwndPrevIMC, hwndFocus;   // focus window in the thread
    HIMC  hFocusImc;                // focus window's IMC
    LRESULT lRet;

    pimeui->fActivate = (BOOL)wParam ? 1 : 0;
    hwndPrevIMC = KHWND_TO_HWND(pimeui->hwndIMC);

    if (wParam) {
        /*
         * if it's being activated
         */
#ifdef LATE_CREATEUI
        if (!GETUI(pimeui))
            SETUI(pimeui, CreateIMEUI(pimeui, GETHKL(pimeui)));
#endif

        /*
         * Check if this process a console IME ?
         */
        if (gfConIme == UNKNOWN_CONIME) {
            gfConIme = (DWORD)NtUserGetThreadState(UserThreadStateIsConImeThread);
            if (gfConIme) {
                RIPMSG0(RIP_VERBOSE, "ImmSetContextHandler: This thread is console IME.\n");
                UserAssert(pimeui);
                // Console IME will never show the IME status window.
                pimeui->fCtrlShowStatus = FALSE;
            }
        }

        if (gfConIme) {
            /*
             * Special handling for Console IME is needed
             */
            PWND pwndOwner;

            UserAssert(pimeui->spwnd);
            pwndOwner = REBASEPWND(pimeui->spwnd, spwndOwner);
            if (pwndOwner != NULL) {
                /*
                 * Set current associated hIMC in IMEUI.
                 */
                SETIMC(pimeui, pwndOwner->hImc);
                /*
                 * Store it to the window memory.
                 */
                if (GETUI(pimeui) != NULL)
                    SetWindowLongPtr(GETUI(pimeui), IMMGWLP_IMC, (LONG_PTR)pwndOwner->hImc);
            }

            hwndFocus = NtUserQueryWindow(HW(pimeui->spwnd), WindowFocusWindow);
            hFocusImc = KHIMC_TO_HIMC(pwndOwner->hImc);
            RIPMSG2(RIP_VERBOSE, "CONSOLE IME: hwndFocus = %x, hFocusImc = %x", hwndFocus, hFocusImc);

            return SendMessageToUI(pimeui, message, wParam, lParam, FALSE);
        }
        else {
            hwndFocus = NtUserQueryWindow(HW(pimeui->spwnd), WindowFocusWindow);
            hFocusImc = fpImmGetContext(hwndFocus);
        }

        /*
         * Cannot share input context with other IME window.
         */
        if (hFocusImc != NULL_HIMC &&
                !ImeIsUsableContext(HW(pimeui->spwnd), hFocusImc)) {
            SETIMC(pimeui, NULL_HIMC);
            return 0L;
        }

        SETIMC(pimeui, hFocusImc);

        /*
         * Store it to the window memory.
         */
        if (GETUI(pimeui) != NULL)
            SetWindowLongPtr(GETUI(pimeui), IMMGWLP_IMC, (LONG_PTR)hFocusImc);

        /*
         * When we're receiving context,
         * it is necessary to set the owner to this window.
         * This is for:
         *     Give the UI moving information.
         *     Give the UI automatic Z-ordering.
         *     Hide the UI when the owner is minimized.
         */
        if (hFocusImc != NULL_HIMC) {
            PINPUTCONTEXT pInputContext;

            /*
             * Get the window who's given the context.
             */
            if ((pInputContext = fpImmLockIMC(hFocusImc)) != NULL) {
                //UserAssert(hwndFocus == pInputContext->hWnd);
                if (hwndFocus != pInputContext->hWnd) {
                    /*
                     * Pq->spwndFocus has been changed so far...
                     * All we can do is just to bail out.
                     */
                    return 0L;
                }
            }
            else
                return 0L; // the context was broken

            if ((pInputContext->fdw31Compat & F31COMPAT_ECSETCFS) &&
                    hwndPrevIMC != hwndFocus) {
                COMPOSITIONFORM cf;

                /*
                 * Set CFS_DEFAULT....
                 */
                RtlZeroMemory(&cf, sizeof(cf));
                fpImmSetCompositionWindow(hFocusImc, &cf);
                pInputContext->fdw31Compat &= ~F31COMPAT_ECSETCFS;
            }

            fpImmUnlockIMC(hFocusImc);

            if (NtUserSetImeOwnerWindow(HW(pimeui->spwnd), hwndFocus))
                pimeui->hwndIMC = hwndFocus;

        }
        else {
            /*
             * NULL IMC is getting activated
             */
            pimeui->hwndIMC = hwndFocus;

            NtUserSetImeOwnerWindow(HW(pimeui->spwnd), NULL);

        }
    }

    lRet = SendMessageToUI(pimeui, message, wParam, lParam, FALSE);

    if (pimeui->spwnd == NULL) {
        // Unusual case in stress..
        // IME window has been destroyed during the callback
        RIPMSG0(RIP_WARNING, "ImmSetContextHandler: pimeui->spwnd is NULL after SendMessageToUI.");
        return 0L;
    }

    if (pimeui->fCtrlShowStatus && GetIMEShowStatus()) {
        PWND pwndFocus, pwndIMC, pwndPrevIMC;
        HWND hwndActive;

        hwndFocus = NtUserQueryWindow(HWq(pimeui->spwnd), WindowFocusWindow);
        pwndFocus = ValidateHwndNoRip(hwndFocus);

        if ((BOOL)wParam == TRUE) {
            HWND hwndIme;

            /*
             * BOGUS BOGUS
             * The following if statement is still insufficient
             * it needs to think what WM_IME_SETCONTEXT:TRUE should do
             * in the case of WINNLSEnableIME(true) - ref.win95c B#8548.
             */
            UserAssert(pimeui->spwnd);
            if (pwndFocus != NULL && GETPTI(pimeui->spwnd) == GETPTI(pwndFocus)) {

                if (!pimeui->fShowStatus) {
                    /*
                     * We have never sent IMN_OPENSTATUSWINDOW yet....
                     */
                    if (ValidateHwndNoRip(KHWND_TO_HWND(pimeui->hwndIMC))) {
                        SendOpenStatusNotify(pimeui, KHWND_TO_HWND(pimeui->hwndIMC), TRUE);
                    }
                }
                else if ((pwndIMC = ValidateHwndNoRip(KHWND_TO_HWND(pimeui->hwndIMC))) != NULL &&
                         (pwndPrevIMC = ValidateHwndNoRip(hwndPrevIMC)) != NULL &&
                         GetTopLevelWindow(pwndIMC) != GetTopLevelWindow(pwndPrevIMC)) {
                    /*
                     * Because the top level window of IME Wnd was changed.
                     */
                    SendOpenStatusNotify(pimeui, hwndPrevIMC, FALSE);
                    SendOpenStatusNotify(pimeui, KHWND_TO_HWND(pimeui->hwndIMC), TRUE);
                }
            }
            /*
             * There may have other IME windows that have fShowStatus.
             * We need to check the fShowStatus in the window list.
             */
            hwndIme = HW(pimeui->spwnd);
            if (hwndIme) {
                NtUserCheckImeShowStatusInThread(hwndIme);
            }
        }
        else {
            /*
             * When focus was removed from this thread, we close the
             * status window.
             * Because focus was already removed from whndPrevIMC,
             * hwndPrevIMC may be destroyed but we need to close the
             * status window.
             */
            hwndActive = NtUserQueryWindow(HW(pimeui->spwnd), WindowActiveWindow);
            UserAssert(pimeui->spwnd);
            if (pwndFocus == NULL || GETPTI(pimeui->spwnd) != GETPTI(pwndFocus) ||
                    hwndActive == NULL) {

                if (IsWindow(hwndPrevIMC)) {
                    RIPMSG1(RIP_VERBOSE, "ImeSetContextHandler: notifying OpenStatus (FALSE) to hwnd=%p", hwndPrevIMC);
                    SendOpenStatusNotify(pimeui, hwndPrevIMC, FALSE);
                }
                else {
                    RIPMSG1(RIP_VERBOSE, "ImeSetContextHandler: sending IMN_CLOSESTATUSWINDOW to UIwnd=%p", pimeui->hwndUI);
                    pimeui->fShowStatus = FALSE;
                    SendMessageToUI(pimeui, WM_IME_NOTIFY, IMN_CLOSESTATUSWINDOW, 0L, FALSE);
                }
            }
        }
    }

    return lRet;
}


LRESULT ImeNotifyHandler(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndUI;
    LRESULT lRet = 0L;
    HIMC hImc;
    PINPUTCONTEXT pInputContext;

    switch (wParam) {
    case IMN_PRIVATE:
        hwndUI = GETUI(pimeui);
        if (IsWindow(hwndUI))
            lRet = SendMessage(hwndUI, message, wParam, lParam);
        break;

    case IMN_SETCONVERSIONMODE:
    case IMN_SETOPENSTATUS:
        //
        // notify shell and keyboard the conversion mode change
        //
        // if this message is sent from ImmSetOpenStatus or
        // ImmSetConversionStatus, we have already notified
        // kernel the change. This is a little bit redundant.
        //
        // if application has eaten the message, we won't be here.
        // We need to think about the possibility later.
        //
        hImc = GETIMC(pimeui);
        if ((pInputContext = fpImmLockIMC(hImc)) != NULL) {
            if ( IsWindow(KHWND_TO_HWND(pimeui->hwndIMC)) ) {
                NtUserNotifyIMEStatus( KHWND_TO_HWND(pimeui->hwndIMC),
                                       (DWORD)pInputContext->fOpen,
                                       pInputContext->fdwConversion );
            }
            else if (gfConIme == TRUE) {
                /*
                 * Special handling for Console IME is needed
                 */
                if (pimeui->spwnd) {    // If IME window is still there.
                    PWND pwndOwner = REBASEPWND(pimeui->spwnd, spwndOwner);

                    if (pwndOwner != NULL) {
                        NtUserNotifyIMEStatus(HWq(pwndOwner),
                                              (DWORD)pInputContext->fOpen,
                                              pInputContext->fdwConversion);
                    }
                }
            }
            fpImmUnlockIMC(hImc);
        }
        /*** FALL THROUGH ***/
    default:
        TAGMSG4(DBGTAG_IMM, "ImeNotifyHandler: sending to pimeui->ui=%p, msg=%x, wParam=%x, lParam=%x\n", GETUI(pimeui), message, wParam, lParam);
        lRet = SendMessageToUI(pimeui, message, wParam, lParam, FALSE);
    }

    return lRet;
}


HWND CreateIMEUI(
    PIMEUI pimeui,
    HKL    hKL)
{
    PWND      pwndIme = pimeui->spwnd;
    HWND      hwndUI;
    IMEINFOEX iiex;
    PIMEDPI   pimedpi;
    WNDCLASS  wndcls;

    if (!fpImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return (HWND)NULL;

    if ((pimedpi = fpImmLockImeDpi(hKL)) == NULL) {
        RIPMSG1(RIP_WARNING, "CreateIMEUI: ImmLockImeDpi(%lx) failed.", hKL);
        return (HWND)NULL;
    }

    if (!GetClassInfoW(pimedpi->hInst, iiex.wszUIClass, &wndcls)) {
        RIPMSG1(RIP_WARNING, "CreateIMEUI: GetClassInfoW(%ws) failed\n", iiex.wszUIClass);
        fpImmUnlockImeDpi(pimedpi);
        return (HWND)NULL;
    }

    // HACK HACK HACK
    if ((wndcls.style & CS_IME) == 0) {
        RIPMSG1(RIP_ERROR, "CreateIMEUI: the Window Class (%S) does not have CS_IME flag on !!!\n",
                wndcls.lpszClassName);
    }

    if (iiex.ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * For Unicode IME, we create an Unicode IME UI window.
         */
        hwndUI = CreateWindowExW(0L,
                        iiex.wszUIClass,
                        iiex.wszUIClass,
                        WS_POPUP|WS_DISABLED,
                        0, 0, 0, 0,
                        HWq(pwndIme), 0, wndcls.hInstance, NULL);
    }
    else {
        /*
         * For ANSI IME, we create an ANSI IME UI window.
         */

        LPSTR pszClass;
        int i;
        i = WCSToMB(iiex.wszUIClass, -1, &pszClass, -1, TRUE);
        if (i == 0) {
            RIPMSG1(RIP_WARNING, "CreateIMEUI: failed in W->A conversion (%S)", iiex.wszUIClass);
            return (HWND)NULL;
        }
        pszClass[i] = '\0';

        hwndUI = CreateWindowExA(0L,
                        pszClass,
                        pszClass,
                        WS_POPUP|WS_DISABLED,
                        0, 0, 0, 0,
                        HWq(pwndIme), 0, wndcls.hInstance, NULL);

        UserLocalFree(pszClass);
    }

    if (hwndUI)
        NtUserSetWindowLongPtr(hwndUI, IMMGWLP_IMC, (LONG_PTR)GETIMC(pimeui), FALSE);

    fpImmUnlockImeDpi(pimedpi);

    return hwndUI;
}


VOID DestroyIMEUI(
    PIMEUI pimeui)
{
    // This has currently nothing to do except for destroying the UI.
    // Review: Need to notify the UI with WM_IME_SETCONTEXT ?
    // Review: This doesn't support Multiple IME install yet.

    HWND hwndUI = GETUI(pimeui);

    if (IsWindow(hwndUI)) {
        pimeui->fDestroy = TRUE;
        /*
         * We need this verify because the owner might have already
         * killed it during its termination.
         */
        NtUserDestroyWindow(hwndUI);
    }
    pimeui->fDestroy = FALSE;

    /*
     * Reinitialize show status of the IME status window so that
     * notification message will be sent when needed.
     */
    pimeui->fShowStatus = FALSE;

    SETUI(pimeui, NULL);

    return;
}


/***************************************************************************\
* SendMessageToUI
*
* History:
* 09-Apr-1996 wkwok       Created
\***************************************************************************/

LRESULT SendMessageToUI(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL   fAnsi)
{
    PWND  pwndUI;
    LRESULT lRet;

    TAGMSG1(DBGTAG_IMM, "Sending to UI msg[%04X]\n", message);

    pwndUI = ValidateHwndNoRip(GETUI(pimeui));

    if (pwndUI == NULL || pimeui->spwnd == NULL)
        return 0L;

    if (TestWF(pimeui->spwnd, WFINDESTROY) || TestWF(pimeui->spwnd, WFDESTROYED) ||
            TestWF(pwndUI, WFINDESTROY) || TestWF(pwndUI, WFDESTROYED)) {
        return 0L;
    }

    InterlockedIncrement(&pimeui->nCntInIMEProc); // Mark to avoid recursion.

    lRet = SendMessageWorker(pwndUI, message, wParam, lParam, fAnsi);

    InterlockedDecrement(&pimeui->nCntInIMEProc); // Mark to avoid recursion.

    return lRet;
}


/***************************************************************************\
* SendOpenStatusNotify
*
* History:
* 09-Apr-1996 wkwok       Created
\***************************************************************************/

VOID SendOpenStatusNotify(
    PIMEUI pimeui,
    HWND   hwndApp,
    BOOL   fOpen)
{
    WPARAM wParam = fOpen ? IMN_OPENSTATUSWINDOW : IMN_CLOSESTATUSWINDOW;

    pimeui->fShowStatus = fOpen;


    if (Is400Compat(GetClientInfo()->dwExpWinVer)) {
        TAGMSG2(DBGTAG_IMM, "SendOpenStatusNotify: sending to hwnd=%lx, wParam=%d\n", hwndApp, wParam);
        SendMessage(hwndApp, WM_IME_NOTIFY, wParam, 0L);
    }
    else {
        TAGMSG2(DBGTAG_IMM, "SendOpenStatusNotify:sending to imeui->UI=%p, wParam=%d\n", GETUI(pimeui), wParam);
        SendMessageToUI(pimeui, WM_IME_NOTIFY, wParam, 0L, FALSE);
    }

    return;
}


VOID ImeSetImc(
    PIMEUI pimeui,
    HIMC hImc)
{
    HWND hImeWnd = HW(pimeui->spwnd);
    HIMC hOldImc = GETIMC(pimeui);

    /*
     * return if nothing to change.
     */
    if (hImc == hOldImc)
        return;

    /*
     * Unmark the old input context.
     */
    if (hOldImc != NULL_HIMC)
        ImeMarkUsedContext(NULL, hOldImc);

    /*
     * Update the in use input context for this IME window.
     */
    pimeui->hIMC = hImc;

    /*
     * Mark the new input context.
     */
    if (hImc != NULL_HIMC)
        ImeMarkUsedContext(hImeWnd, hImc);
}


/***************************************************************************\
*  FocusSetIMCContext()
*
* History:
* 21-Mar-1996 wkwok       Created
\***************************************************************************/

VOID FocusSetIMCContext(
    HWND hWnd,
    BOOL fActivate)
{
    HIMC hImc;

    if (IsWindow(hWnd)) {
        hImc = fpImmGetContext(hWnd);
        fpImmSetActiveContext(hWnd, hImc, fActivate);
        fpImmReleaseContext(hWnd, hImc);
    }
    else {
        fpImmSetActiveContext(NULL, NULL_HIMC, fActivate);
    }

    return;
}


BOOL ImeBroadCastMsg(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    UNREFERENCED_PARAMETER(pimeui);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    return TRUE;
}

/***************************************************************************\
*  ImeMarkUsedContext()
*
*  Some IME windows can not share the same input context. This function
*  marks the specified hImc to be in used by the specified IME window.
*
* History:
* 12-Mar-1996 wkwok       Created
\***************************************************************************/

VOID ImeMarkUsedContext(
    HWND hImeWnd,
    HIMC hImc)
{
    PIMC pImc;

    pImc = HMValidateHandle((HANDLE)hImc, TYPE_INPUTCONTEXT);
    if (pImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImeMarkUsedContext: Invalid hImc (=%lx).", hImc);
        return;
    }

    UserAssert( ValidateHwndNoRip(pImc->hImeWnd) == NULL || hImeWnd == NULL );

    /*
     * Nothing to change?
     */
    if (pImc->hImeWnd == hImeWnd)
        return;

    NtUserUpdateInputContext(hImc, UpdateInUseImeWindow, (ULONG_PTR)hImeWnd);

    return;
}


/***************************************************************************\
*  ImeIsUsableContext()
*
*  Some IME windows can not share the same input context. This function
*  checks whether the specified hImc can be used (means 'Set activated')
*  by the specified IME window.
*
*  Return: TRUE  - OK to use the hImc by hImeWnd.
*          FALSE - otherwise.
*
* History:
* 12-Mar-1996 wkwok       Created
\***************************************************************************/

BOOL ImeIsUsableContext(
    HWND hImeWnd,
    HIMC hImc)
{
    PIMC pImc;

    UserAssert(hImeWnd != NULL);

    pImc = HMValidateHandle((HANDLE)hImc, TYPE_INPUTCONTEXT);
    if (pImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImeIsUsableContext: Invalid hImc (=%lx).", hImc);
        return FALSE;
    }

    if ( pImc->hImeWnd == NULL     ||
         pImc->hImeWnd == hImeWnd  ||
         ValidateHwndNoRip(pImc->hImeWnd) == NULL )
    {
        return TRUE;
    }


    return FALSE;
}

/***************************************************************************\
* GetIMEShowStatus()
*
* Get the global IME show status from kernel.
*
* History:
* 19-Sep-1996 takaok       Ported from internat.exe.
\***************************************************************************/

BOOL GetIMEShowStatus(void)
{
    return (BOOL)NtUserCallNoParam(SFI__GETIMESHOWSTATUS);
}



/***************************************************************************\
*  IMEIndicatorGetMenuIDData
*
* History:
* 3-Nov-97 Hiroyama
\***************************************************************************/

BOOL IMEIndicatorGetMenuIDData(PUINT puMenuID, PDWORD pdwData)
{
    HANDLE hinstIndic;

    hinstIndic = GetModuleHandle(szIndicDLL);
    if (hinstIndic == NULL) {
        gpfnGetIMEMenuItemData = NULL;
        return FALSE;
    }

    if (!gpfnGetIMEMenuItemData) {
        gpfnGetIMEMenuItemData = GetProcAddress(hinstIndic, (LPSTR)ORD_GETIMEMENUITEMDATA);
    }
    if (!gpfnGetIMEMenuItemData)
        return FALSE;

    (*(FPGETIMEMENUITEMDATA)gpfnGetIMEMenuItemData)(puMenuID, pdwData);
    return TRUE;
}


BOOL SyncSoftKbdState(
    HIMC hImc,
    LPARAM lParam)
{
    DWORD fdwConversion, fdwSentence, fdwNewConversion;

    fpImmGetConversionStatus(hImc, &fdwConversion, &fdwSentence);

    if (lParam) {
        fdwNewConversion = fdwConversion | IME_CMODE_SOFTKBD;
    } else {
        fdwNewConversion = fdwConversion & ~IME_CMODE_SOFTKBD;
    }

    if (fdwNewConversion != fdwConversion) {
        fpImmSetConversionStatus(hImc, fdwNewConversion, fdwSentence);
    }

    return TRUE;
}

/***************************************************************************\
*  ImeCopyDataHandler
*
* History:
* 10-Nov-98 Hiroyama
\***************************************************************************/

LRESULT ImeCopyDataHandler(
    WPARAM wParam,
    LPARAM lParam)
{
    HINSTANCE hInstImm;
    BOOL (WINAPI* fpImmPenAuxInput)(HWND, LPVOID);

    hInstImm = GetModuleHandleW(L"IMM32.DLL");
    if (hInstImm == NULL) {
        return FALSE;
    }

    fpImmPenAuxInput = (LPVOID)GetProcAddress(hInstImm, "ImmPenAuxInput");
    if (fpImmPenAuxInput == NULL) {
        return FALSE;
    }

    return fpImmPenAuxInput((HWND)wParam, (LPVOID)lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\hdata.c ===
/****************************** Module Header ******************************\
* Module Name: hdata.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager data handle functions
*
* Created: 11/12/91 Sanford Staab
*
\***************************************************************************/

#define DDEMLDB
#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* DdeCreateDataHandle (DDEML API)
*
* Description
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG7(LOG_GENERAL, HDDEDATA, DUMMYCALLINGTYPE, DdeCreateDataHandle, DWORD, idInst, LPBYTE, pSrc, DWORD, cb, DWORD, cbOff, HSZ, hszItem, UINT, wFmt, UINT, afCmd)
HDDEDATA DdeCreateDataHandle(
DWORD idInst,
LPBYTE pSrc,
DWORD cb,
DWORD cbOff,
HSZ hszItem,
UINT wFmt,
UINT afCmd)
{
    PCL_INSTANCE_INFO pcii;
    HDDEDATA hRet = 0;

    if (cb == -1) {
        RIPMSG0(RIP_ERROR, "DdeCreateDataHandle called with cb == -1\n");
        return NULL;
    }

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (afCmd & ~HDATA_APPOWNED) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (cb + cbOff < sizeof(DWORD) && pSrc == NULL &&
            (wFmt == CF_METAFILEPICT ||
             wFmt == CF_DSPMETAFILEPICT ||
             wFmt == CF_DIB ||
             wFmt == CF_BITMAP ||
             wFmt == CF_DSPBITMAP ||
             wFmt == CF_PALETTE ||
             wFmt == CF_ENHMETAFILE ||
             wFmt == CF_DSPENHMETAFILE)) {
        /*
         * We have the nasty possibility of blowing up in FreeDDEData if we
         * don't initialize the data for formats with indirect data to 0.
         * This is because GlobalLock/GlobalSize do not adequately validate
         * random numbers given to them.
         */
        cb += 4;
    }
    hRet = InternalCreateDataHandle(pcii, pSrc, cb, cbOff,
            hszItem ? afCmd : (afCmd | HDATA_EXECUTE),
            (WORD)((afCmd & HDATA_APPOWNED) ? 0 : DDE_FRELEASE), (WORD)wFmt);

    if (!hRet) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
    }
Exit:
    LeaveDDECrit;
    return (hRet);
}


/***************************************************************************\
* InternalCreateDataHandle
*
* Description:
* Worker function for creating a data handle. If cb is -1, pSrc is
* a GMEM_DDESHARE data handle. 0 is return ed on error.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
HDDEDATA InternalCreateDataHandle(
PCL_INSTANCE_INFO pcii,
LPBYTE pSrc,
DWORD cb, // cb of actual data to initialize with
DWORD cbOff, // offset from start of data
DWORD flags,
WORD wStatus,
WORD wFmt)
{
    PDDEMLDATA pdd;
    HDDEDATA hRet;
    LPBYTE p;
    DWORD cbOff2;

    CheckDDECritIn;

    pdd = (PDDEMLDATA)DDEMLAlloc(sizeof(DDEMLDATA));
    if (pdd == NULL) {
        return (0);
    }
    if (cb == -1) {
        pdd->hDDE = (HANDLE)pSrc;
    } else {
        if (flags & HDATA_EXECUTE) {
            cbOff2 = 0;
        } else {
            cbOff2 = sizeof(WORD) + sizeof(WORD); // skip wStatus, wFmt
        }
        pdd->hDDE = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE | GMEM_ZEROINIT,
                cb + cbOff + cbOff2);
        if (pdd->hDDE == NULL) {
            DDEMLFree(pdd);
            return (0);
        }

        if (!(flags & HDATA_EXECUTE)) {
            PDDE_DATA pdde;

            USERGLOBALLOCK(pdd->hDDE, pdde);
            UserAssert(pdde);
            pdde->wStatus = wStatus;
            pdde->wFmt = wFmt;
            USERGLOBALUNLOCK(pdd->hDDE);
        }
    }
    pdd->flags = (WORD)flags;
    hRet = (HDDEDATA)CreateHandle((ULONG_PTR)pdd, HTYPE_DATA_HANDLE,
            InstFromHandle(pcii->hInstClient));
    if (!hRet) {
        WOWGLOBALFREE(pdd->hDDE);
        DDEMLFree(pdd);
        return (0);
    }
    if (cb != -1 && pSrc != NULL) {
        USERGLOBALLOCK(pdd->hDDE, p);
        UserAssert(p);
        RtlCopyMemory(p + cbOff + cbOff2, pSrc, cb);
        USERGLOBALUNLOCK(pdd->hDDE);
        pdd->flags |= HDATA_INITIALIZED;
    }
    return (hRet);
}

/***************************************************************************\
* DdeAddData (DDEML API)
*
* Description:
* Copys data from a user buffer to a data handles. Reallocates if needed.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, HDDEDATA, DUMMYCALLINGTYPE, DdeAddData, HDDEDATA, hData, LPBYTE, pSrc, DWORD, cb, DWORD, cbOff)
HDDEDATA DdeAddData(
HDDEDATA hData,
LPBYTE pSrc,
DWORD cb,
DWORD cbOff)
{
    LPSTR pMem;
    PDDEMLDATA pdd;
    PCL_INSTANCE_INFO pcii;
    HDDEDATA hRet = 0;

    EnterDDECrit;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData, HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hData);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (!(pdd->flags & HDATA_EXECUTE)) {
        cbOff += 4;
    }
    if (cb + cbOff > UserGlobalSize(pdd->hDDE)) {
        pdd->hDDE = UserGlobalReAlloc(pdd->hDDE, cb + cbOff,
                GMEM_MOVEABLE | GMEM_ZEROINIT);
    }

    USERGLOBALLOCK(pdd->hDDE, pMem);

    if (pMem == NULL) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
        goto Exit;
    }

    hRet = hData;

    if (pSrc != NULL) {
        try {
            RtlCopyMemory(pMem + cbOff, pSrc, cb);
            pdd->flags |= HDATA_INITIALIZED;
        } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            hRet = 0;
        }
    }

    USERGLOBALUNLOCK(pdd->hDDE);

Exit:
    LeaveDDECrit;
    return (hRet);
}




/***************************************************************************\
* DdeGetData (DDEML API)
*
* Description:
* Copys data from a data handle into a user buffer.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, DdeGetData, HDDEDATA, hData, LPBYTE, pDst, DWORD, cbMax, DWORD, cbOff)
DWORD DdeGetData(
HDDEDATA hData,
LPBYTE pDst,
DWORD cbMax,
DWORD cbOff)
{
    DWORD cbCopied = 0;
    DWORD cbSize;
    PDDEMLDATA pdd;
    PCL_INSTANCE_INFO pcii;

    EnterDDECrit;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData,
            HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hData);
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (!(pdd->flags & HDATA_EXECUTE)) {
        cbOff += 4;
    }
    cbSize = (DWORD)UserGlobalSize(pdd->hDDE);
    if (cbOff >= cbSize) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if (pDst == NULL) {
        cbCopied = cbSize - cbOff;
        goto Exit;
    } else {
        LPSTR pMem;

        cbCopied = min(cbMax, cbSize - cbOff);
        USERGLOBALLOCK(pdd->hDDE, pMem);
        UserAssert(pMem);
        try {
            RtlCopyMemory(pDst, pMem + cbOff, cbCopied);
        } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            cbCopied = 0;
        }
        if (pMem != NULL) {
            USERGLOBALUNLOCK(pdd->hDDE);
        }
    }

Exit:
    LeaveDDECrit;
    return (cbCopied);
}





/***************************************************************************\
* DdeAccessData (DDEML API)
*
* Description:
* Locks a data handle for access.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, LPBYTE, DUMMYCALLINGTYPE, DdeAccessData, HDDEDATA, hData, LPDWORD, pcbDataSize)
LPBYTE DdeAccessData(
HDDEDATA hData,
LPDWORD pcbDataSize)
{
    PCL_INSTANCE_INFO pcii;
    PDDEMLDATA pdd;
    LPBYTE pRet = NULL;
    DWORD cbOff;

    EnterDDECrit;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData,
            HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        goto Exit;
    }
    pcii = PciiFromHandle((HANDLE)hData);
    cbOff = pdd->flags & HDATA_EXECUTE ? 0 : 4;
    if (pcbDataSize != NULL) {
        *pcbDataSize = (DWORD)UserGlobalSize(pdd->hDDE) - cbOff;
    }
    USERGLOBALLOCK(pdd->hDDE, pRet);
    UserAssert(pRet);
    pRet = (LPBYTE)pRet + cbOff;

Exit:
    LeaveDDECrit;
    return (pRet);
}




/***************************************************************************\
* DdeUnaccessData (DDEML API)
*
* Description:
* Unlocks a data handle
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeUnaccessData, HDDEDATA, hData)
BOOL DdeUnaccessData(
HDDEDATA hData)
{
    PDDEMLDATA pdd;
    BOOL fSuccess = FALSE;

    EnterDDECrit;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData,
            HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        goto Exit;
    }
    USERGLOBALUNLOCK(pdd->hDDE);
    fSuccess = TRUE;

Exit:
    LeaveDDECrit;
    return (fSuccess);
}



/***************************************************************************\
* DdeFreeDataHandle (DDEML API)
*
* Description:
* Releases application interest in a data handle.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeFreeDataHandle, HDDEDATA, hData)
BOOL DdeFreeDataHandle(
HDDEDATA hData)
{
    PDDEMLDATA pdd;
    BOOL fSuccess = FALSE;

    EnterDDECrit;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData,
            HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        goto Exit;
    }
    if (pdd->flags & HDATA_NOAPPFREE) {
        fSuccess = TRUE;
        goto Exit;
    }

    fSuccess = InternalFreeDataHandle(hData, TRUE);

Exit:
    LeaveDDECrit;
    return (fSuccess);
}




/***************************************************************************\
* InternalFreeDataHandle
*
* Description:
* Frees a data handle and its contents. The contents are NOT freed for
* APPOWNED data handles unless fIgnorefRelease is set.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL InternalFreeDataHandle(
HDDEDATA hData,
BOOL fIgnorefRelease)
{
    PDDEMLDATA pdd;

    CheckDDECritIn;

    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData,
            HTYPE_DATA_HANDLE, HINST_ANY);
    if (pdd == NULL) {
        return (FALSE);
    }
    if (pdd->flags & HDATA_EXECUTE) {
        if (!(pdd->flags & HDATA_APPOWNED) || fIgnorefRelease) {
            WOWGLOBALFREE(pdd->hDDE);
        }
    } else {
        FreeDDEData(pdd->hDDE, fIgnorefRelease, TRUE);
    }
    DDEMLFree(pdd);
    DestroyHandle((HANDLE)hData);
    return (TRUE);
}


/***************************************************************************\
* ApplyFreeDataHandle
*
* Description:
* Used during data handle cleanup.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ApplyFreeDataHandle(
HANDLE hData)
{
    BOOL fRet;

    CheckDDECritOut;
    EnterDDECrit;
    fRet = InternalFreeDataHandle((HDDEDATA)hData, FALSE);
    LeaveDDECrit;
    return(fRet);
}


/***************************************************************************\
* FreeDDEData
*
* Description:
* Used for freeing DDE data including any special indirect objects
* associated with the data depending on the format. This function
* SHOULD NOT BE USED TO FREE EXECUTE DATA!
*
* The data is not freed if the fRelease bit is clear and fIgnoreRelease
* is FALSE.
*
*   The fFreeTruelyGlobalObjects parameter is used to distinguish tracking
*   layer frees from DDEML frees.  Data in certain formats (CF_BITMAP,
*   CF_PALETTE) is maintained on the gdi CSR server side.  When this is
*   passed between processes, gdi is not able to maintain multiple process
*   ownership on these objects so the objects must be made global.  Thus
*   the tracking layer should NOT free these objects on behalf of another
*   process because they are truely global- however, DDEML can do this
*   because it is following the protocol which delclares who is in charge
*   of freeing global data.  (YUCK!)
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
/*
 * WARNING: This is exported for NetDDE use - DO NOT CHANGE THE PARAMETERS!
 */
VOID FreeDDEData(
HANDLE hDDE,
BOOL fIgnorefRelease,
BOOL fFreeTruelyGlobalObjects)
{
    PDDE_DATA pdde;
    LPMETAFILEPICT pmfPict;
    DWORD cb;

    USERGLOBALLOCK(hDDE, pdde);
    if (pdde == NULL) {
        return ;
    }

    if ((pdde->wStatus & DDE_FRELEASE) || fIgnorefRelease) {
        cb = (DWORD)GlobalSize(hDDE);
        /*
         * Because there is the possibility that the data never got
         * initialized we need to do this in a try-except so we
         * behave nicely.
         */
        switch (pdde->wFmt) {
        case CF_BITMAP:
        case CF_DSPBITMAP:
        case CF_PALETTE:
            if (cb >= sizeof(HANDLE)) {
                if (fFreeTruelyGlobalObjects) {
                    if (pdde->Data != 0) {
                        DeleteObject((HANDLE)pdde->Data);
                    }
                } else {
                    /*
                     * !fFreeTruelyGlobalObject implies we are only freeing
                     * the Gdi proxy.  (another process may still have this
                     * object in use.)
                     *
                     * ChrisWil: removed this call.  No longer
                     *           applicable in KMode.
                     *
                     * GdiDeleteLocalObject((ULONG)pdde->Data);
                     *
                     */
                }
            }
            break;

        case CF_DIB:
            if (cb >= sizeof(HANDLE)) {
                if (pdde->Data != 0) {
                    WOWGLOBALFREE((HANDLE)pdde->Data);
                }
            }
            break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
            if (cb >= sizeof(HANDLE)) {
                if (pdde->Data != 0) {
                    USERGLOBALLOCK(pdde->Data, pmfPict);
                    if (pmfPict != NULL) {
                        if (GlobalSize((HANDLE)pdde->Data) >= sizeof(METAFILEPICT)) {
                            DeleteMetaFile(pmfPict->hMF);
                        }
                        USERGLOBALUNLOCK((HANDLE)pdde->Data);
                        WOWGLOBALFREE((HANDLE)pdde->Data);
                    }
                }
            }
            break;

        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
            if (cb >= sizeof(HANDLE)) {
                if (pdde->Data != 0) {
                    DeleteEnhMetaFile((HANDLE)pdde->Data);
                }
            }
            break;
        }
        USERGLOBALUNLOCK(hDDE);
        WOWGLOBALFREE(hDDE);
    } else {
        USERGLOBALUNLOCK(hDDE);
    }
}



HBITMAP CopyBitmap(
HBITMAP hbm)
{
    BITMAP bm;
    HBITMAP hbm2 = NULL, hbmOld1, hbmOld2;
    HDC hdc, hdcMem1, hdcMem2;

    if (!GetObject(hbm, sizeof(BITMAP), &bm)) {
        return(0);
    }
    hdc = NtUserGetDC(NULL);  // screen DC
    if (!hdc) {
        return(0);
    }
    hdcMem1 = CreateCompatibleDC(hdc);
    if (!hdcMem1) {
        goto Cleanup3;
    }
    hdcMem2 = CreateCompatibleDC(hdc);
    if (!hdcMem2) {
        goto Cleanup2;
    }
    hbmOld1 = SelectObject(hdcMem1, hbm);
    hbm2 = CreateCompatibleBitmap(hdcMem1, bm.bmWidth, bm.bmHeight);
    if (!hbm2) {
        goto Cleanup1;
    }
    hbmOld2 = SelectObject(hdcMem2, hbm2);
    BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);
    SelectObject(hdcMem1, hbmOld1);
    SelectObject(hdcMem2, hbmOld2);
Cleanup1:
    DeleteDC(hdcMem2);
Cleanup2:
    DeleteDC(hdcMem1);
Cleanup3:
    NtUserReleaseDC(NULL, hdc);
    return(hbm2);
}


HPALETTE CopyPalette(
HPALETTE hpal)
{
    int cPalEntries;
    LOGPALETTE *plp;

    if (!GetObject(hpal, sizeof(int), &cPalEntries)) {
        return(0);
    }
    plp = (LOGPALETTE *)DDEMLAlloc(sizeof(LOGPALETTE) +
            (cPalEntries - 1) * sizeof(PALETTEENTRY));
    if (!plp) {
        return(0);
    }
    if (!GetPaletteEntries(hpal, 0, cPalEntries, plp->palPalEntry)) {
        DDEMLFree(plp);
        return(0);
    }
    plp->palVersion = 0x300;
    plp->palNumEntries = (WORD)cPalEntries;
    hpal = CreatePalette(plp);
    if (hpal != NULL) {
        if (!SetPaletteEntries(hpal, 0, cPalEntries, plp->palPalEntry)) {
            DeleteObject(hpal);
            hpal = NULL;
        }
    }
    DDEMLFree(plp);
    return(hpal);
}



/***************************************************************************\
* CopyDDEData
*
* Description:
* Used to copy DDE data apropriately.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
HANDLE CopyDDEData(
HANDLE hDDE,
BOOL fIsExecute)
{
    HANDLE hDDENew;
    PDDE_DATA pdde, pddeNew;
    LPMETAFILEPICT pmfPict;
    HANDLE hmfPict;

    hDDENew = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE,
            UserGlobalSize(hDDE));
    if (!hDDENew) {
        return (0);
    }
    USERGLOBALLOCK(hDDE, pdde);
    if (pdde == NULL) {
        UserGlobalFree(hDDENew);
        return (0);
    }
    USERGLOBALLOCK(hDDENew, pddeNew);
    UserAssert(pddeNew);
    RtlCopyMemory(pddeNew, pdde, UserGlobalSize(hDDE));

    if (!fIsExecute) {
        switch (pdde->wFmt) {
        case CF_BITMAP:
        case CF_DSPBITMAP:
            pddeNew->Data = (KERNEL_PVOID)CopyBitmap((HBITMAP)pdde->Data);
            break;

        case CF_PALETTE:
            pddeNew->Data = (KERNEL_PVOID)CopyPalette((HPALETTE)pdde->Data);
            break;

        case CF_DIB:
            pddeNew->Data = (KERNEL_PVOID)CopyDDEData((HANDLE)pdde->Data, TRUE);
            break;

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
            hmfPict = CopyDDEData((HANDLE)pdde->Data, TRUE);
            USERGLOBALLOCK(hmfPict, pmfPict);
            if (pmfPict == NULL) {
                WOWGLOBALFREE(hmfPict);
                USERGLOBALUNLOCK(hDDENew);
                WOWGLOBALFREE(hDDENew);
                USERGLOBALUNLOCK(hDDE);
                return (FALSE);
            }
            pmfPict->hMF = CopyMetaFile(pmfPict->hMF, NULL);
            USERGLOBALUNLOCK(hmfPict);
            pddeNew->Data = (KERNEL_PVOID)hmfPict;
            break;

        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
            pddeNew->Data = (KERNEL_PVOID)CopyEnhMetaFile((HANDLE)pdde->Data, NULL);
            break;
        }
    }
    USERGLOBALUNLOCK(hDDENew);
    USERGLOBALUNLOCK(hDDE);
    return (hDDENew);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\immhotky.c ===
/**************************************************************************\
* Module Name: immhotky.c (user32 side IME hotkey handling)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME hot key management routines for imm32 dll
*
* History:
* 03-Jan-1996 hiroyama      Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


typedef struct tagFE_KEYBOARDS {
    BOOLEAN fJPN : 1;
    BOOLEAN fCHT : 1;
    BOOLEAN fCHS : 1;
    BOOLEAN fKOR : 1;
} FE_KEYBOARDS;

//
// internal functions
//
BOOL CliSaveImeHotKey(DWORD dwID, UINT uModifiers, UINT uVKey, HKL hkl, BOOL fDelete);
BOOL CliImmSetHotKeyWorker(DWORD dwID, UINT uModifiers, UINT uVKey, HKL hkl, DWORD dwAction);
VOID NumToHexAscii(DWORD, PTSTR);
BOOL CliGetImeHotKeysFromRegistry(void);
BOOL CliSetSingleHotKey(PKEY_BASIC_INFORMATION pKeyInfo, HANDLE hKey);
VOID CliSetDefaultImeHotKeys(PCIMEHOTKEY ph, INT num, BOOL fCheckExistingHotKey);
VOID CliGetPreloadKeyboardLayouts(FE_KEYBOARDS* pFeKbds);

//
// IMM hotkey related registry keys under HKEY_CURRENT_USER
//
CONST TCHAR *szaRegImmHotKeys[] = {
    TEXT("Control Panel"),
    TEXT("Input Method"),
    TEXT("Hot Keys"),
    NULL
};

CONST TCHAR szRegImeHotKey[] = TEXT("Control Panel\\Input Method\\Hot Keys");
CONST TCHAR szRegKeyboardPreload[] = TEXT("Keyboard Layout\\Preload");

CONST TCHAR szRegVK[] = TEXT("Virtual Key");
CONST TCHAR szRegMOD[] = TEXT("Key Modifiers");
CONST TCHAR szRegHKL[] = TEXT("Target IME");

//
// Default IME HotKey Tables
//
// CR:takaok - move this to the resource if you have time
//
CONST IMEHOTKEY DefaultHotKeyTableJ[]= {
    {IME_JHOTKEY_CLOSE_OPEN, VK_KANJI, MOD_IGNORE_ALL_MODIFIER, NULL}
};
CONST INT DefaultHotKeyNumJ = sizeof(DefaultHotKeyTableJ) / sizeof(IMEHOTKEY);

CONST IMEHOTKEY DefaultHotKeyTableT[] = {
    { IME_THOTKEY_IME_NONIME_TOGGLE, VK_SPACE, MOD_BOTH_SIDES|MOD_CONTROL, NULL },
    { IME_THOTKEY_SHAPE_TOGGLE, VK_SPACE, MOD_BOTH_SIDES|MOD_SHIFT,  NULL }
};
CONST INT DefaultHotKeyNumT = sizeof(DefaultHotKeyTableT) / sizeof(IMEHOTKEY);

CONST IMEHOTKEY DefaultHotKeyTableC[] = {
    { IME_CHOTKEY_IME_NONIME_TOGGLE, VK_SPACE, MOD_BOTH_SIDES|MOD_CONTROL, NULL },
    { IME_CHOTKEY_SHAPE_TOGGLE, VK_SPACE, MOD_BOTH_SIDES|MOD_SHIFT,  NULL }
};
CONST INT DefaultHotKeyNumC = sizeof(DefaultHotKeyTableC) / sizeof(IMEHOTKEY);

#if 0   // just FYI.
CONST IMEHOTKEY DefaultHotKeyTableK[] = {
    { IME_KHOTKEY_ENGLISH,  VK_HANGEUL, MOD_IGNORE_ALL_MODIFIER,  NULL },
    { IME_KHOTKEY_SHAPE_TOGGLE, VK_JUNJA, MOD_IGNORE_ALL_MODIFIER,  NULL },
    { IME_KHOTKEY_HANJACONVERT, VK_HANJA, MOD_IGNORE_ALL_MODIFIER, NULL }
};
CONST INT DefaultHotKeyNumK = sizeof(DefaultHotKeyTableK) / sizeof(IMEHOTKEY);
#endif

//
// Set language flags.
//
VOID SetFeKeyboardFlags(LANGID langid, FE_KEYBOARDS* pFeKbds)
{
    switch (langid) {
    case MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL):
    case MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_HONGKONG):
        pFeKbds->fCHT = TRUE;
        break;
    case MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED):
    case MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SINGAPORE):
        pFeKbds->fCHS = TRUE;
        break;
    case MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT):
        pFeKbds->fJPN = TRUE;
        break;
    case MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT):
        pFeKbds->fKOR = TRUE;
        break;
    }
}

/***************************************************************************\
* ImmInitializeHotkeys()
*
* Called from user\client\UpdatePerUserSystemParameters()
*
*  Read the User registry and set the IME hotkey.
*
* History:
* 25-Mar-1996 TakaoK       Created
\***************************************************************************/
VOID CliImmInitializeHotKeys(DWORD dwAction, HKL hkl)
{
    FE_KEYBOARDS feKbds = { 0, 0, 0, 0, };
    BOOL fFoundAny;

    UNREFERENCED_PARAMETER(hkl);

    // First, initialize the hotkey list
    CliImmSetHotKeyWorker(0, 0, 0, NULL, ISHK_INITIALIZE);

    // Check if the user has customized IME hotkeys
    // (they're stored in the registry)
    fFoundAny = CliGetImeHotKeysFromRegistry();

    if (dwAction == ISHK_INITIALIZE) {
        TAGMSG0(DBGTAG_IMM, "Setting IME HotKeys for Init.\n");

        // Get the user's default locale and set its flag
        SetFeKeyboardFlags(LANGIDFROMLCID(GetUserDefaultLCID()), &feKbds);

        // Get preloaded keyboards' locales and set their flags
        CliGetPreloadKeyboardLayouts(&feKbds);

    }
    else {
        UINT i;
        UINT nLayouts;
        LPHKL lphkl;

        TAGMSG0(DBGTAG_IMM, "Setting IME HotKeys for Add.\n");

        nLayouts = NtUserGetKeyboardLayoutList(0, NULL);
        if (nLayouts == 0) {
            return;
        }
        lphkl = UserLocalAlloc(0, nLayouts * sizeof(HKL));
        if (lphkl == NULL) {
            return;
        }
        NtUserGetKeyboardLayoutList(nLayouts, lphkl);
        for (i = 0; i < nLayouts; ++i) {
            //
            // Set language flags. By its definition, LOWORD(hkl) is LANGID
            //
            SetFeKeyboardFlags(LOWORD(HandleToUlong(lphkl[i])), &feKbds);
        }
        UserLocalFree(lphkl);
    }

    if (feKbds.fJPN) {
        TAGMSG0(DBGTAG_IMM, "JPN KL Preloaded.\n");
        CliSetDefaultImeHotKeys(DefaultHotKeyTableJ, DefaultHotKeyNumJ, fFoundAny);
    }

    if (feKbds.fKOR) {
        TAGMSG0(DBGTAG_IMM, "KOR KL Preloaded, but KOR hotkeys will not be registered.\n");
    }

    if (feKbds.fCHT) {
        TAGMSG0(DBGTAG_IMM, "CHT KL Preloaded.\n");
        CliSetDefaultImeHotKeys(DefaultHotKeyTableT, DefaultHotKeyNumT, fFoundAny);
    }
    if (feKbds.fCHS) {
        TAGMSG0(DBGTAG_IMM, "CHS KL Preloaded.\n");
        CliSetDefaultImeHotKeys(DefaultHotKeyTableC, DefaultHotKeyNumC, fFoundAny);
    }
}

VOID CliSetDefaultImeHotKeys(PCIMEHOTKEY ph, INT num, BOOL fNeedToCheckExistingHotKey)
{
    IMEHOTKEY hkt;

    while( num-- > 0 ) {
        //
        // Set IME hotkey only if there is no such
        // hotkey in the registry
        //
        if (!fNeedToCheckExistingHotKey ||
                !NtUserGetImeHotKey(ph->dwHotKeyID, &hkt.uModifiers, &hkt.uVKey, &hkt.hKL)) {

            CliImmSetHotKeyWorker(ph->dwHotKeyID,
                                    ph->uModifiers,
                                    ph->uVKey,
                                    ph->hKL,
                                    ISHK_ADD);
        }
        ph++;
    }
}

/***************************************************************************\
* CliGetPreloadKeyboardLayouts()
*
*  Read the User registry and enumerate values in Keyboard Layouts\Preload
* to see which FE languages are to be preloaded.
*
* History:
* 03-Dec-1997 Hiroyama     Created
\***************************************************************************/

VOID CliGetPreloadKeyboardLayouts(FE_KEYBOARDS* pFeKbds)
{
    UINT  i;
    WCHAR szPreLoadee[4];   // up to 999 preloads
    WCHAR lpszName[KL_NAMELENGTH];
    UNICODE_STRING UnicodeString;
    HKL hkl;

    for (i = 1; i < 1000; i++) {
        wsprintf(szPreLoadee, L"%d", i);
        if ((GetPrivateProfileStringW(
                 L"Preload",
                 szPreLoadee,
                 L"",                            // default = NULL
                 lpszName,                       // output buffer
                 KL_NAMELENGTH,
                 L"keyboardlayout.ini") == -1 ) || (*lpszName == L'\0')) {
            break;
        }
        RtlInitUnicodeString(&UnicodeString, lpszName);
        RtlUnicodeStringToInteger(&UnicodeString, 16L, (PULONG)&hkl);

        RIPMSG2(RIP_VERBOSE, "PreLoaded HKL(%d): %08X\n", i, hkl);

        //
        // Set language flags. By its definition, LOWORD(hkl) is LANGID
        //
        SetFeKeyboardFlags(LOWORD(HandleToUlong(hkl)), pFeKbds);
    }
}

BOOL CliGetImeHotKeysFromRegistry()
{
    BOOL    fFoundAny = FALSE;

    HANDLE hCurrentUserKey;
    HANDLE hKeyHotKeys;

    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKeyName;

    NTSTATUS Status;
    ULONG uIndex;

    //
    // Open the current user registry key
    //
    Status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hCurrentUserKey);
    if (!NT_SUCCESS(Status)) {
        return fFoundAny;
    }

    RtlInitUnicodeString( &SubKeyName, szRegImeHotKey );
    InitializeObjectAttributes( &Obja,
                                &SubKeyName,
                                OBJ_CASE_INSENSITIVE,
                                hCurrentUserKey,
                                NULL);
    Status = NtOpenKey( &hKeyHotKeys, KEY_READ, &Obja );
    if (!NT_SUCCESS(Status)) {
        NtClose( hCurrentUserKey );
        return fFoundAny;
    }

    for (uIndex = 0; TRUE; uIndex++) {
        BYTE KeyBuffer[sizeof(KEY_BASIC_INFORMATION) + 16 * sizeof(WCHAR)];
        PKEY_BASIC_INFORMATION pKeyInfo;
        ULONG ResultLength;

        pKeyInfo = (PKEY_BASIC_INFORMATION)KeyBuffer;
        Status = NtEnumerateKey(hKeyHotKeys,
                                 uIndex,
                                 KeyBasicInformation,
                                 pKeyInfo,
                                 sizeof( KeyBuffer ),
                                 &ResultLength );

        if (NT_SUCCESS(Status)) {

            if (CliSetSingleHotKey(pKeyInfo, hKeyHotKeys)) {

                    fFoundAny = TRUE;
            }

        } else if (Status == STATUS_NO_MORE_ENTRIES) {
            break;
        }
    }

    NtClose(hKeyHotKeys);
    NtClose(hCurrentUserKey);

    return fFoundAny;
}

DWORD CliReadRegistryValue(HANDLE hKey, PCWSTR pName)
{
    BYTE ValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 16 * sizeof(UCHAR)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValue;
    UNICODE_STRING      ValueName;
    ULONG ResultLength;
    NTSTATUS Status;

    pKeyValue = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;

    RtlInitUnicodeString(&ValueName, pName);
    Status = NtQueryValueKey(hKey,
                             &ValueName,
                             KeyValuePartialInformation,
                             pKeyValue,
                             sizeof(ValueBuffer),
                             &ResultLength );

    if (NT_SUCCESS(Status) && pKeyValue->DataLength > 3) {
        //
        // In Win95 registry, these items are written as BYTE data...
        //
        return (DWORD)(MAKEWORD( pKeyValue->Data[0], pKeyValue->Data[1])) |
                 (((DWORD)(MAKEWORD( pKeyValue->Data[2], pKeyValue->Data[3]))) << 16);
    }

    return 0;
}

BOOL CliSetSingleHotKey(PKEY_BASIC_INFORMATION pKeyInfo, HANDLE hKey)
{
    UNICODE_STRING      SubKeyName;
    HANDLE    hKeySingleHotKey;
    OBJECT_ATTRIBUTES   Obja;

    DWORD dwID = 0;
    UINT  uVKey = 0;
    UINT  uModifiers = 0;
    HKL   hKL = NULL;

    NTSTATUS Status;

    SubKeyName.Buffer = (PWSTR)&(pKeyInfo->Name[0]);
    SubKeyName.Length = (USHORT)pKeyInfo->NameLength;
    SubKeyName.MaximumLength = (USHORT)pKeyInfo->NameLength;
    InitializeObjectAttributes(&Obja,
                               &SubKeyName,
                               OBJ_CASE_INSENSITIVE,
                               hKey,
                               NULL);

    Status = NtOpenKey(&hKeySingleHotKey, KEY_READ, &Obja);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    RtlUnicodeStringToInteger(&SubKeyName, 16L, &dwID);
    uVKey = CliReadRegistryValue(hKeySingleHotKey, szRegVK);
    uModifiers = CliReadRegistryValue(hKeySingleHotKey, szRegMOD);
    hKL = (HKL)LongToHandle( CliReadRegistryValue(hKeySingleHotKey, szRegHKL) );

    NtClose(hKeySingleHotKey);

    return CliImmSetHotKeyWorker(dwID, uModifiers, uVKey, hKL, ISHK_ADD);
}

/***************************************************************************\
* ImmSetHotKey()
*
* Private API for IMEs and the control panel.
*
* History:
* 25-Mar-1996 TakaoK       Created
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, BOOL, WINAPI, CliImmSetHotKey, DWORD, dwID, UINT, uModifiers, UINT, uVKey, HKL, hkl)
BOOL WINAPI CliImmSetHotKey(
    DWORD dwID,
    UINT uModifiers,
    UINT uVKey,
    HKL hkl)
{
    BOOL fResult;
    BOOL fTmp;
    BOOL fDelete = (uVKey == 0 );

    if (fDelete) {
        //
        // Removing an IME hotkey from the list in the kernel side
        // should not be failed, if we succeed to remove the IME
        // hotkey entry from the registry. Therefore CliSaveImeHotKey
        // is called first.
        //
        fResult = CliSaveImeHotKey( dwID, uModifiers, uVKey, hkl,  fDelete );
        if (fResult) {
            fTmp = CliImmSetHotKeyWorker( dwID, uModifiers, uVKey, hkl, ISHK_REMOVE );
            UserAssert(fTmp);
        }
    } else {
        //
        // CliImmSetHotKeyWorker should be called first since
        // adding an IME hotkey into the list in the kernel side
        // will be failed in various reasons.
        //
        fResult = CliImmSetHotKeyWorker(dwID, uModifiers, uVKey, hkl, ISHK_ADD);
        if (fResult) {
            fResult = CliSaveImeHotKey(dwID, uModifiers, uVKey, hkl, fDelete);
            if (!fResult) {
                //
                // We failed to save the hotkey to the registry.
                // We need to remove the entry from the IME hotkey
                // list in the kernel side.
                //
                fTmp = CliImmSetHotKeyWorker(dwID, uModifiers, uVKey, hkl, ISHK_REMOVE);
                UserAssert(fTmp);
            }
        }
    }
    return fResult;
}

/***************************************************************************\
* CliSaveImeHotKey()
*
*  Put/Remove the specified IME hotkey entry from the registry
*
* History:
* 25-Mar-1996 TakaoK       Created
\***************************************************************************/
BOOL CliSaveImeHotKey(DWORD id, UINT mod, UINT vk, HKL hkl, BOOL fDelete)
{
    HKEY hKey, hKeyParent;
    INT i;
    LONG lResult;
    TCHAR szHex[16];

    if (fDelete) {
        TCHAR szRegTmp[(sizeof(szRegImeHotKey) / sizeof(TCHAR) + 1 + 8 + 1)];

        lstrcpy(szRegTmp, szRegImeHotKey);
        lstrcat(szRegTmp, TEXT("\\"));
        NumToHexAscii(id, szHex);
        lstrcat(szRegTmp, szHex);

        lResult = RegDeleteKeyW(HKEY_CURRENT_USER, szRegTmp);
        if (lResult != ERROR_SUCCESS) {
            RIPERR1(lResult, RIP_WARNING,
                     "CliSaveImeHotKey: deleting %s failed", szRegTmp);
            return FALSE;
        }
        return TRUE;
    }

    hKeyParent = HKEY_CURRENT_USER;
    for (i = 0; szaRegImmHotKeys[i] != NULL; i++) {
        lResult = RegCreateKeyExW(hKeyParent,
                                  szaRegImmHotKeys[i],
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_WRITE|KEY_READ,
                                  NULL,
                                  &hKey,
                                  NULL );
        RegCloseKey(hKeyParent);
        if (lResult == ERROR_SUCCESS) {
            hKeyParent = hKey;
        } else {
            RIPERR1(lResult, RIP_WARNING,
                    "CliSaveImeHotKey: creating %s failed", szaRegImmHotKeys[i]);

            return FALSE;
        }
    }

    NumToHexAscii(id, szHex);
    lResult = RegCreateKeyExW(hKeyParent,
                             szHex,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE|KEY_READ,
                             NULL,
                             &hKey,
                             NULL );
    RegCloseKey(hKeyParent);
    if (lResult != ERROR_SUCCESS) {
        RIPERR1(lResult, RIP_WARNING,
                "CliSaveImeHotKey: creating %s failed", szHex );
        return FALSE;
    }

    lResult = RegSetValueExW(hKey,
                             szRegVK,
                             0,
                             REG_BINARY,
                            (LPBYTE)&vk,
                            sizeof(DWORD));
    if (lResult != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        CliSaveImeHotKey(id, vk, mod, hkl, TRUE);
        RIPERR1( lResult, RIP_WARNING,
                 "SaveImeHotKey:setting value on %s failed", szRegVK );
        return ( FALSE );
    }
    lResult = RegSetValueExW(hKey,
                             szRegMOD,
                             0,
                             REG_BINARY,
                             (LPBYTE)&mod,
                             sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        CliSaveImeHotKey(id, vk, mod, hkl, TRUE);
        RIPERR1(lResult, RIP_WARNING,
                "CliSaveImeHotKey: setting value on %s failed", szRegMOD);
        return FALSE;
    }

    lResult = RegSetValueExW(hKey,
                             szRegHKL,
                             0,
                             REG_BINARY,
                             (LPBYTE)&hkl,
                             sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        CliSaveImeHotKey(id, vk, mod, hkl, TRUE);
        RIPERR1(lResult, RIP_WARNING,
                "CliSaveImeHotKey: setting value on %s failed", szRegHKL);
        return FALSE;
    }

    RegCloseKey(hKey);
    return TRUE;
}

BOOL CliImmSetHotKeyWorker(
    DWORD dwID,
    UINT uModifiers,
    UINT uVKey,
    HKL hkl,
    DWORD dwAction)
{
    //
    // if we're adding an IME hotkey entry, let's check
    // the parameters before calling the kernel side code
    //
    if (dwAction == ISHK_ADD) {

        if (dwID >= IME_HOTKEY_DSWITCH_FIRST &&
                dwID <= IME_HOTKEY_DSWITCH_LAST) {
            //
            // IME direct switching hot key - switch to
            // the keyboard layout specified.
            // We need to specify keyboard layout.
            //
            if (hkl == NULL) {
                RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "hkl should be specified");
                return FALSE;
            }

        } else {
            //
            // normal hot keys - change the mode of current iME
            //
            // Because it should be effective in all IME no matter
            // which IME is active we should not specify a target IME
            //
            if (hkl != NULL) {
                RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "hkl shouldn't be specified");
                return FALSE;
            }

            if (dwID >= IME_KHOTKEY_FIRST && dwID <= IME_KHOTKEY_LAST) {
                RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Hotkey for Korean IMEs are invalid.");
                return FALSE;
            }
        }

        if (uModifiers & MOD_MODIFY_KEYS) {
            //
            // Because normal keyboard has left and right key for
            // these keys, you should specify left or right ( or both )
            //
            if ((uModifiers & MOD_BOTH_SIDES) == 0) {
                RIPERR3(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid modifiers %x for id %x vKey %x", uModifiers, dwID, uVKey);
                return FALSE;
            }
        }

#if 0   // Skip this check for now
        //
        // It doesn't make sense if vkey is same as modifiers
        //
        if ( ((uModifiers & MOD_ALT) && (uVKey == VK_MENU))        ||
             ((uModifiers & MOD_CONTROL) && (uVKey == VK_CONTROL)) ||
             ((uModifiers & MOD_SHIFT) && (uVKey == VK_SHIFT))     ||
             ((uModifiers & MOD_WIN) && ((uVKey == VK_LWIN)||(uVKey == VK_RWIN)))
           ) {

            RIPERR0( ERROR_INVALID_PARAMETER, RIP_WARNING, "vkey and modifiers are same");
            return FALSE;
        }
#endif
    }
    return NtUserSetImeHotKey(dwID, uModifiers, uVKey, hkl, dwAction);
}

//
// NumToHexAscii
//
// convert a DWORD into the hex string
// (e.g. 0x31 -> "00000031")
//
// 29-Jan-1996 takaok   ported from Win95.
//
static CONST TCHAR szHexString[] = TEXT("0123456789ABCDEF");

VOID
NumToHexAscii(
    DWORD dwNum,
    PWSTR szAscii)
{
    int i;

    for (i = 7; i >= 0; i--) {
        szAscii[i] = szHexString[dwNum & 0x0000000f];
        dwNum >>= 4;
    }
    szAscii[8] = TEXT('\0');

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\keybrdc.c ===
/****************************** Module Header ******************************\
* Module Name: keybrdc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 11-11-90 DavidPe      Created.
* 13-Feb-1991 mikeke    Added Revalidation code (None)
* 12-Mar-1993 JerrySh   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/**************************************************************************\
* GetKBCodePage
*
* 28-May-1992 IanJa    Created
\**************************************************************************/

UINT GetKBCodePage(VOID)
{
    return GetOEMCP();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\lboxctl1.c ===
/**************************** Module Header ********************************\
* Module Name: lboxctl1.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* List Box Handling Routines
*
* History:
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

INT xxxLBBinarySearchString(PLBIV plb,LPWSTR lpstr);

/***************************************************************************\
*
*  SetLBScrollParms()
*
*  Sets the scroll range, page, and position
*
\***************************************************************************/

int xxxSetLBScrollParms(PLBIV plb, int nCtl)
{
    int         iPos;
    int         cItems;
    UINT        iPage;
    SCROLLINFO  si;
    BOOL        fNoScroll = FALSE;
    PSCROLLPOS  psp;
    BOOL        fCacheInitialized;
    int         iReturn;

    if (nCtl == SB_VERT) {
        iPos = plb->iTop;
        cItems = plb->cMac;
        iPage = plb->cItemFullMax;
        if (!plb->fVertBar)
            fNoScroll = TRUE;
        psp = &plb->VPos;
        fCacheInitialized = plb->fVertInitialized;
    } else {
        if (plb->fMultiColumn) {
            iPos   = plb->iTop / plb->itemsPerColumn;
            cItems = plb->cMac ? ((plb->cMac - 1) / plb->itemsPerColumn) + 1 : 0;
            iPage = plb->numberOfColumns;
            if (plb->fRightAlign && cItems)
                iPos = cItems - iPos - 1;
        } else {
            iPos = plb->xOrigin;
            cItems = plb->maxWidth;
            iPage = plb->spwnd->rcClient.right - plb->spwnd->rcClient.left;
        }

        if (!plb->fHorzBar)
            fNoScroll = TRUE;
        psp = &plb->HPos;
        fCacheInitialized = plb->fHorzInitialized;
    }

    if (cItems)
        cItems--;

    if (fNoScroll) {
        // Limit page to 0, posMax + 1
        iPage = max(min((int)iPage, cItems + 1), 0);

        // Limit pos to 0, posMax - (page - 1).
        return(max(min(iPos, cItems - ((iPage) ? (int)(iPage - 1) : 0)), 0));
    } else {
        si.fMask    = SIF_ALL;
        if (plb->fDisableNoScroll)
            si.fMask |= SIF_DISABLENOSCROLL;

        /*
         * If the scrollbar is already where we want it, do nothing.
         */
        if (fCacheInitialized) {
            if (psp->fMask == si.fMask &&
                    psp->cItems == cItems && psp->iPage == iPage &&
                    psp->iPos == iPos)
                return psp->iReturn;
        } else if (nCtl == SB_VERT) {
            plb->fVertInitialized = TRUE;
        } else {
            plb->fHorzInitialized = TRUE;
        }

        si.cbSize   = sizeof(SCROLLINFO);
        si.nMin     = 0;
        si.nMax     = cItems;
        si.nPage    = iPage;

        if (plb->fMultiColumn && plb->fRightAlign)
            si.nPos =  (iPos+1) > (int)iPage ? iPos - iPage + 1 : 0;
        else
            si.nPos = iPos;

        iReturn = SetScrollInfo(HWq(plb->spwnd), nCtl, &si, plb->fRedraw);
        if (plb->fMultiColumn && plb->fRightAlign)
            iReturn = cItems - (iReturn + iPage - 1);

        /*
         * Update the position cache
         */
        psp->fMask = si.fMask;
        psp->cItems = cItems;
        psp->iPage = iPage;
        psp->iPos = iPos;
        psp->iReturn = iReturn;

        return iReturn;
    }
}

/***************************************************************************\
* xxxLBShowHideScrollBars
*
* History:
\***************************************************************************/

void xxxLBShowHideScrollBars(
    PLBIV plb)
{
    BOOL fVertDone = FALSE;
    BOOL fHorzDone = FALSE;

    // Don't do anything if there are no scrollbars or if parents
    // are invisible.
    if ((!plb->fHorzBar && !plb->fVertBar) || !plb->fRedraw)
        return;

    //
    // Adjust iTop if necessary but DO NOT REDRAW PERIOD.  We never did
    // in 3.1.  There's a potential bug:
    //      If someone doesn't have redraw off and inserts an item in the
    // same position as the caret, we'll tell them to draw before they may
    // have called LB_SETITEMDATA for their item.  This is because we turn
    // the caret off & on inside of NewITop(), even if the item isn't
    // changing.
    //      So we just want to reflect the position/scroll changes.
    // CheckRedraw() will _really_ redraw the visual changes later if
    // redraw isn't off.
    //

    if (!plb->fFromInsert) {
        xxxNewITop(plb, plb->iTop);
        fVertDone = TRUE;
    }

    if (!plb->fMultiColumn) {
        if (!plb->fFromInsert) {
            fHorzDone = TRUE;
            xxxLBoxCtlHScroll(plb, SB_THUMBPOSITION, plb->xOrigin);
        }

        if (!fVertDone)
            xxxSetLBScrollParms(plb, SB_VERT);
    }
    if (!fHorzDone)
        xxxSetLBScrollParms(plb, SB_HORZ);
}

/***************************************************************************\
* LBGetItemData
*
* returns the long value associated with listbox items. -1 if error
*
* History:
* 16-Apr-1992 beng      The NODATA listbox case
\***************************************************************************/

LONG_PTR LBGetItemData(
    PLBIV plb,
    INT sItem)
{
    LONG_PTR buffer;
    LPBYTE lpItem;

    if (sItem < 0 || sItem >= plb->cMac) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return LB_ERR;
    }

    // No-data listboxes always return 0L
    //
    if (!plb->fHasData) {
        return 0L;
    }

    lpItem = (plb->rgpch +
            (sItem * (plb->fHasStrings ? sizeof(LBItem) : sizeof(LBODItem))));
    buffer = (plb->fHasStrings ? ((lpLBItem)lpItem)->itemData : ((lpLBODItem)lpItem)->itemData);
    return buffer;
}


/***************************************************************************\
* LBGetText
*
* Copies the text associated with index to lpbuffer and returns its length.
* If fLengthOnly, just return the length of the text without doing a copy.
*
* Waring: for size only querries lpbuffer is the count of ANSI characters
*
* Returns count of chars
*
* History:
\***************************************************************************/

INT LBGetText(
    PLBIV plb,
    BOOL fLengthOnly,
    BOOL fAnsi,
    INT index,
    LPWSTR lpbuffer)
{
    LPWSTR lpItemText;
    INT cchText;

    if (index < 0 || index >= plb->cMac) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return LB_ERR;
    }

    if (!plb->fHasStrings && plb->OwnerDraw) {

        /*
         * Owner draw without strings so we must copy the app supplied DWORD
         * value.
         */
        cchText = sizeof(ULONG_PTR);

        if (!fLengthOnly) {
            LONG_PTR UNALIGNED *p = (LONG_PTR UNALIGNED *)lpbuffer;
            *p = LBGetItemData(plb, index);
        }
    } else {
        lpItemText = GetLpszItem(plb, index);
        if (!lpItemText)
            return LB_ERR;

        /*
         * These are strings so we are copying the text and we must include
         * the terminating 0 when doing the RtlMoveMemory.
         */
        cchText = wcslen(lpItemText);

        if (fLengthOnly) {
            if (fAnsi)
                RtlUnicodeToMultiByteSize(&cchText, lpItemText, cchText*sizeof(WCHAR));
        } else {
            if (fAnsi) {
#ifdef FE_SB // LBGetText()
                cchText = WCSToMB(lpItemText, cchText+1, &((LPSTR)lpbuffer), (cchText+1)*sizeof(WORD), FALSE);
                /*
                 * Here.. cchText contains null-terminate char, subtract it... Because, we pass cchText+1 to
                 * above Unicode->Ansi convertsion to make sure the string is terminated with null.
                 */
                cchText--;
#else
                WCSToMB(lpItemText, cchText+1, &((LPSTR)lpbuffer), cchText+1, FALSE);
#endif // FE_SB
            } else {
                RtlCopyMemory(lpbuffer, lpItemText, (cchText+1)*sizeof(WCHAR));
            }
        }

    }

    return cchText;
}

/***************************************************************************\
* GrowMem
*
* History:
* 16-Apr-1992 beng      NODATA listboxes
* 23-Jul-1996 jparsons  Added numItems parameter for LB_INITSTORAGE support
\***************************************************************************/

BOOL GrowMem(
    PLBIV plb,
    INT   numItems)

{
    LONG cb;
    HANDLE hMem;

    /*
     * Allocate memory for pointers to the strings.
     */
    cb = (plb->cMax + numItems) *
            (plb->fHasStrings ? sizeof(LBItem)
                              : (plb->fHasData ? sizeof(LBODItem)
                                              : 0));

    /*
     * If multiple selection list box (MULTIPLESEL or EXTENDEDSEL), then
     * allocate an extra byte per item to keep track of it's selection state.
     */
    if (plb->wMultiple != SINGLESEL) {
        cb += (plb->cMax + numItems);
    }

    /*
     * Extra bytes for each item so that we can store its height.
     */
    if (plb->OwnerDraw == OWNERDRAWVAR) {
        cb += (plb->cMax + numItems);
    }

    /*
     * Don't allocate more than 2G of memory
     */
    if (cb > MAXLONG)
        return FALSE;

    if (plb->rgpch == NULL) {
        if ((plb->rgpch = UserLocalAlloc(HEAP_ZERO_MEMORY, (LONG)cb)) == NULL)
            return FALSE;
    } else {
        if ((hMem = UserLocalReAlloc(plb->rgpch, (LONG)cb, HEAP_ZERO_MEMORY)) == NULL)
            return FALSE;
        plb->rgpch = hMem;
    }

    plb->cMax += numItems;

    return TRUE;
}

/***************************************************************************\
* xxxLBInitStorage
*
* History:
* 23-Jul-1996 jparsons  Added support for pre-allocation
\***************************************************************************/
LONG xxxLBInitStorage(PLBIV plb, BOOL fAnsi, INT cItems, INT cb)
{
    HANDLE hMem;
    INT    cbChunk;

    /*
     * if the app is talking ANSI, then adjust for the worst case in unicode
     * where each single ansi byte translates to one 16 bit unicode value
     */
    if (fAnsi) {
        cb *= sizeof(WCHAR) ;
    } /* if */

    /*
     * Fail if either of the parameters look bad.
     */
    if ((cItems < 0) || (cb < 0)) {
        xxxNotifyOwner(plb, LBN_ERRSPACE);
        return LB_ERRSPACE;
    } /* if */

    /*
     * try to grow the pointer array (if necessary) accounting for the free space
     * already available.
     */
    cItems -= plb->cMax - plb->cMac ;
    if ((cItems > 0) && !GrowMem(plb, cItems)) {
        xxxNotifyOwner(plb, LBN_ERRSPACE);
        return LB_ERRSPACE;
    } /* if */

    /*
     * now grow the string space if necessary
     */
    if (plb->fHasStrings) {
        if ((cbChunk = (plb->ichAlloc + cb)) > plb->cchStrings) {

            /*
             * Round up to the nearest 256 byte chunk.
             */
            cbChunk = (cbChunk & ~0xff) + 0x100;
            if (!(hMem = UserLocalReAlloc(plb->hStrings, (LONG)cbChunk, 0))) {
                xxxNotifyOwner(plb, LBN_ERRSPACE);
                return LB_ERRSPACE;
            }
            plb->hStrings = hMem;
            plb->cchStrings = cbChunk;
        } /* if */
    } /* if */

    /*
     * return the number of items that can be stored
     */
    return plb->cMax ;
}

/***************************************************************************\
* xxxInsertString
*
* Insert an item at a specified position.
*
* History:
* 16-Apr-1992 beng      NODATA listboxes
\***************************************************************************/

INT xxxLBInsertItem(
    PLBIV plb,

    /*
     * For owner draw listboxes without LBS_HASSTRINGS style, this is not a
     * string but rather a 4 byte value we will store for the app.
     */
    LPWSTR lpsz,
    INT index,
    UINT wFlags)
{
    MEASUREITEMSTRUCT measureItemStruct;
    INT cbString = 0;
    INT cbChunk;
    PBYTE lp;
    PBYTE lpT;
    PBYTE lpHeightStart;
    LONG cbItem;     /* sizeof the Item in rgpch */
    HANDLE hMem;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    if (wFlags & LBI_ADD)
        index = (plb->fSort) ? xxxLBBinarySearchString(plb, lpsz) : -1;

    if (!plb->rgpch) {
        if (index != 0 && index != -1) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return LB_ERR;
        }

        plb->iSel = -1;
        plb->iSelBase = 0;
        plb->cMax = 0;
        plb->cMac = 0;
        plb->iTop = 0;
        plb->rgpch = UserLocalAlloc(HEAP_ZERO_MEMORY, 0L);
        if (!plb->rgpch)
            return LB_ERR;
    }

    if (index == -1) {
        index = plb->cMac;
    }

    if (index > plb->cMac || plb->cMac >= MAXLONG) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return LB_ERR;
    }

    if (plb->fHasStrings) {

        /*
         * we must store the string in the hStrings memory block.
         */
        cbString = (wcslen(lpsz) + 1)*sizeof(WCHAR);  /* include 0 terminator */

        if ((cbChunk = (plb->ichAlloc + cbString)) > plb->cchStrings) {

            /*
             * Round up to the nearest 256 byte chunk.
             */
            cbChunk = (cbChunk & ~0xff) + 0x100;
            if (!(hMem = UserLocalReAlloc(plb->hStrings, (LONG)cbChunk,
                    0))) {
                xxxNotifyOwner(plb, LBN_ERRSPACE);
                return LB_ERRSPACE;
            }
            plb->hStrings = hMem;

            plb->cchStrings = cbChunk;
        }

        /*
         * Note difference between Win 95 code with placement of new string
         */
        if (wFlags & UPPERCASE)
            CharUpperBuffW((LPWSTR)lpsz, cbString / sizeof(WCHAR));
        else if (wFlags & LOWERCASE)
            CharLowerBuffW((LPWSTR)lpsz, cbString / sizeof(WCHAR));

        lp = (PBYTE)(plb->hStrings);
        RtlMoveMemory(lp + plb->ichAlloc, lpsz, cbString);
    }

    /*
     * Now expand the pointer array.
     */
    if (plb->cMac >= plb->cMax) {
        if (!GrowMem(plb, CITEMSALLOC)) {
            xxxNotifyOwner(plb, LBN_ERRSPACE);
            return LB_ERRSPACE;
        }
    }

    lpHeightStart = lpT = lp = plb->rgpch;

    /*
     * Now calculate how much room we must make for the string pointer (lpsz).
     * If we are ownerdraw without LBS_HASSTRINGS, then a single DWORD
     * (LBODItem.itemData) stored for each item, but if we have strings with
     * each item then a LONG string offset (LBItem.offsz) is also stored.
     */
    cbItem = (plb->fHasStrings ? sizeof(LBItem)
                               : (plb->fHasData ? sizeof(LBODItem):0));
    cbChunk = (plb->cMac - index) * cbItem;

    if (plb->wMultiple != SINGLESEL) {

        /*
         * Extra bytes were allocated for selection flag for each item
         */
        cbChunk += plb->cMac;
    }

    if (plb->OwnerDraw == OWNERDRAWVAR) {

        /*
         * Extra bytes were allocated for each item's height
         */
        cbChunk += plb->cMac;
    }

    /*
     * First, make room for the 2 byte pointer to the string or the 4 byte app
     * supplied value.
     */
    lpT += (index * cbItem);
    RtlMoveMemory(lpT + cbItem, lpT, cbChunk);
    if (!plb->fHasStrings && plb->OwnerDraw) {
        if (plb->fHasData) {
            /*
             * Ownerdraw so just save the DWORD value
             */
            lpLBODItem p = (lpLBODItem)lpT;
            p->itemData = (ULONG_PTR)lpsz;
        }
    } else {
        lpLBItem p = ((lpLBItem)lpT);

        /*
         * Save the start of the string.  Let the item data field be 0
         */
        p->offsz = (LONG)(plb->ichAlloc);
        p->itemData = 0;
        plb->ichAlloc += cbString;
    }

    /*
     * Now if Multiple Selection lbox, we have to insert a selection status
     * byte.  If var height ownerdraw, then we also have to move up the height
     * bytes.
     */
    if (plb->wMultiple != SINGLESEL) {
        lpT = lp + ((plb->cMac + 1) * cbItem) + index;
        RtlMoveMemory(lpT + 1, lpT, plb->cMac - index +
                (plb->OwnerDraw == OWNERDRAWVAR ? plb->cMac : 0));
        *lpT = 0;  /* fSelected = FALSE */
    }

    /*
     * Increment count of items in the listbox now before we send a message to
     * the app.
     */
    plb->cMac++;

    /*
     * If varheight ownerdraw, we much insert an extra byte for the item's
     * height.
     */
    if (plb->OwnerDraw == OWNERDRAWVAR) {

        /*
         * Variable height owner draw so we need to get the height of each item.
         */
        lpHeightStart += (plb->cMac * cbItem) + index +
                (plb->wMultiple ? plb->cMac : 0);

        RtlMoveMemory(lpHeightStart + 1, lpHeightStart, plb->cMac - 1 - index);

        /*
         * Query for item height only if we are var height owner draw.
         */
        measureItemStruct.CtlType = ODT_LISTBOX;
        measureItemStruct.CtlID = PtrToUlong(plb->spwnd->spmenu);
        measureItemStruct.itemID = index;

        /*
         * System font height is default height
         */
        measureItemStruct.itemHeight = (UINT)gpsi->cySysFontChar;
        measureItemStruct.itemData = (ULONG_PTR)lpsz;

        /*
         * If "has strings" then add the special thunk bit so the client data
         * will be thunked to a client side address.  LB_DIR sends a string
         * even if the listbox is not HASSTRINGS so we need to special
         * thunk this case.  HP Dashboard for windows send LB_DIR to a non
         * HASSTRINGS listbox needs the server string converted to client.
         * WOW needs to know about this situation as well so we mark the
         * previously uninitialized itemWidth as FLAT.
         */
        if (plb->fHasStrings || (wFlags & MSGFLAG_SPECIAL_THUNK)) {
            measureItemStruct.itemWidth = MIFLAG_FLAT;
        }

        ThreadLock(plb->spwndParent, &tlpwndParent);
        SendMessage(HW(plb->spwndParent),
                WM_MEASUREITEM,
                measureItemStruct.CtlID,
                (LPARAM)&measureItemStruct);
        ThreadUnlock(&tlpwndParent);
        *lpHeightStart = (BYTE)measureItemStruct.itemHeight;
    }


    /*
     * If the item was inserted above the current selection then move
     * the selection down one as well.
     */
    if ((plb->wMultiple == SINGLESEL) && (plb->iSel >= index))
        plb->iSel++;

    if (plb->OwnerDraw == OWNERDRAWVAR)
        LBSetCItemFullMax(plb);

    /*
     * Check if scroll bars need to be shown/hidden
     */
    plb->fFromInsert = TRUE;
    xxxLBShowHideScrollBars(plb);
    if (plb->fHorzBar && plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw)) {
        /*
         * origin to right
         */
        xxxLBoxCtlHScroll(plb, SB_BOTTOM, 0);
    }
    plb->fFromInsert = FALSE;

    xxxCheckRedraw(plb, TRUE, index);

    LBEvent(plb, EVENT_OBJECT_CREATE, index);

    return index;
}


/***************************************************************************\
* LBlstrcmpi
*
* This is a version of lstrcmpi() specifically used for listboxes
* This gives more weight to '[' characters than alpha-numerics;
* The US version of lstrcmpi() and lstrcmp() are similar as far as
* non-alphanumerals are concerned; All non-alphanumerals get sorted
* before alphanumerals; This means that subdirectory strings that start
* with '[' will get sorted before; But we don't want that; So, this
* function takes care of it;
*
* History:
\***************************************************************************/

INT LBlstrcmpi(
    LPWSTR lpStr1,
    LPWSTR lpStr2,
    DWORD dwLocaleId)
{

    /*
     * NOTE: This function is written so as to reduce the number of calls
     * made to the costly IsCharAlphaNumeric() function because that might
     * load a language module; It 'traps' the most frequently occurring cases
     * like both strings starting with '[' or both strings NOT starting with '['
     * first and only in abosolutely necessary cases calls IsCharAlphaNumeric();
     */
    if (*lpStr1 == TEXT('[')) {
        if (*lpStr2 == TEXT('[')) {
            goto LBL_End;
        }
        if (IsCharAlphaNumeric(*lpStr2)) {
            return 1;
        }
    }

    if ((*lpStr2 == TEXT('[')) && IsCharAlphaNumeric(*lpStr1)) {
        return -1;
    }

LBL_End:
    if ((GetClientInfo()->dwTIFlags & TIF_16BIT) &&
        dwLocaleId == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)) {
        /*
         * This is how Windows95 does, bug #4199
         */
        return (*pfnWowIlstrcmp)(lpStr1, lpStr2);
    }
    return (INT)CompareStringW((LCID)dwLocaleId, NORM_IGNORECASE,
            lpStr1, -1, lpStr2, -1 ) - 2;
}


/***************************************************************************\
* xxxLBBinarySearchString
*
* Does a binary search of the items in the SORTED listbox to find
* out where this item should be inserted.  Handles both HasStrings and item
* long WM_COMPAREITEM cases.
*
* History:
*    27 April 1992  GregoryW
*          Modified to support sorting based on current list box locale.
\***************************************************************************/

INT xxxLBBinarySearchString(
    PLBIV plb,
    LPWSTR lpstr)
{
    BYTE *FAR *lprgpch;
    INT sortResult;
    COMPAREITEMSTRUCT cis;
    LPWSTR pszLBBase;
    LPWSTR pszLB;
    INT itemhigh;
    INT itemnew = 0;
    INT itemlow = 0;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    if (!plb->cMac)
        return 0;

    lprgpch = (BYTE *FAR *)(plb->rgpch);
    if (plb->fHasStrings) {
        pszLBBase = plb->hStrings;
    }

    itemhigh = plb->cMac - 1;
    while (itemlow <= itemhigh) {
        itemnew = (itemhigh + itemlow) / 2;

        if (plb->fHasStrings) {

            /*
             * Searching for string matches.
             */
            pszLB = (LPWSTR)((LPSTR)pszLBBase + ((lpLBItem)lprgpch)[itemnew].offsz);
            sortResult = LBlstrcmpi(pszLB, lpstr, plb->dwLocaleId);
        } else {

            /*
             * Send compare item messages to the parent for sorting
             */
            cis.CtlType = ODT_LISTBOX;
            cis.CtlID = PtrToUlong(plb->spwnd->spmenu);
            cis.hwndItem = HWq(plb->spwnd);
            cis.itemID1 = itemnew;
            cis.itemData1 = ((lpLBODItem)lprgpch)[itemnew].itemData;
            cis.itemID2 = (UINT)-1;
            cis.itemData2 = (ULONG_PTR)lpstr;
            cis.dwLocaleId = plb->dwLocaleId;
            ThreadLock(plb->spwndParent, &tlpwndParent);
            sortResult = (INT)SendMessage(HW(plb->spwndParent), WM_COMPAREITEM,
                    cis.CtlID, (LPARAM)&cis);
            ThreadUnlock(&tlpwndParent);
        }

        if (sortResult < 0) {
            itemlow = itemnew + 1;
        } else if (sortResult > 0) {
            itemhigh = itemnew - 1;
        } else {
            itemlow = itemnew;
            goto FoundIt;
        }
    }

FoundIt:

    return max(0, itemlow);
}

/***************************************************************************\
* xxxLBResetContent
*
* History:
\***************************************************************************/

BOOL xxxLBResetContent(
    PLBIV plb)
{
    if (!plb->cMac)
        return TRUE;

    xxxLBoxDoDeleteItems(plb);

    if (plb->rgpch != NULL) {
        UserLocalFree(plb->rgpch);
        plb->rgpch = NULL;
    }

    if (plb->hStrings != NULL) {
        UserLocalFree(plb->hStrings);
        plb->hStrings = NULL;
    }

    InitHStrings(plb);

    if (TestWF(plb->spwnd, WFWIN31COMPAT))
        xxxCheckRedraw(plb, FALSE, 0);
    else if (IsVisible(plb->spwnd))
        NtUserInvalidateRect(HWq(plb->spwnd), NULL, TRUE);

    plb->iSelBase =  0;
    plb->iTop =  0;
    plb->cMac =  0;
    plb->cMax =  0;
    plb->xOrigin =  0;
    plb->iLastSelection =  0;
    plb->iSel = -1;

    xxxLBShowHideScrollBars(plb);
    return TRUE;
}


/***************************************************************************\
* xxxLBoxCtlDelete
*
* History:
* 16-Apr-1992 beng      NODATA listboxes
\***************************************************************************/

INT xxxLBoxCtlDelete(
    PLBIV plb,
    INT sItem)  /* Item number to delete */
{
    LONG cb;
    LPBYTE lp;
    LPBYTE lpT;
    RECT rc;
    int cbItem;    /* size of Item in rgpch */
    LPWSTR lpString;
    PBYTE pbStrings;
    INT cbStringLen;
    LPBYTE itemNumbers;
    INT sTmp;
    TL tlpwnd;

    CheckLock(plb->spwnd);

    if (sItem < 0 || sItem >= plb->cMac) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return LB_ERR;
    }

    LBEvent(plb, EVENT_OBJECT_DESTROY, sItem);

    if (plb->cMac == 1) {

        /*
         * When the item count is 0, we send a resetcontent message so that we
         * can reclaim our string space this way.
         */
        SendMessageWorker(plb->spwnd, LB_RESETCONTENT, 0, 0, FALSE);
        goto FinishUpDelete;
    }

    /*
     * Get the rectangle associated with the last item in the listbox.  If it is
     * visible, we need to invalidate it.  When we delete an item, everything
     * scrolls up to replace the item deleted so we must make sure we erase the
     * old image of the last item in the listbox.
     */
    if (LBGetItemRect(plb, (INT)(plb->cMac - 1), &rc)) {
        xxxLBInvalidateRect(plb, &rc, TRUE);
    }

    // 3.1 and earlier used to only send WM_DELETEITEMs if it was an ownerdraw
    // listbox.  4.0 and above will send WM_DELETEITEMs for every item that has
    // nonzero item data.
    if (TestWF(plb->spwnd, WFWIN40COMPAT) || (plb->OwnerDraw && plb->fHasData)) {
        xxxLBoxDeleteItem(plb, sItem);
    }

    plb->cMac--;

    cbItem = (plb->fHasStrings ? sizeof(LBItem)
                               : (plb->fHasData ? sizeof(LBODItem): 0));
    cb = ((plb->cMac - sItem) * cbItem);

    /*
     * Byte for the selection status of the item.
     */
    if (plb->wMultiple != SINGLESEL) {
        cb += (plb->cMac + 1);
    }

    if (plb->OwnerDraw == OWNERDRAWVAR) {

        /*
         * One byte for the height of the item.
         */
        cb += (plb->cMac + 1);
    }

    /*
     * Might be nodata and singlesel, for instance.
     * but what out for the case where cItem == cMac (and cb == 0).
     */
    if ((cb != 0) || plb->fHasStrings) {
        lp = plb->rgpch;

        lpT = (lp + (sItem * cbItem));

        if (plb->fHasStrings) {
            /*
             * If we has strings with each item, then we want to compact the string
             * heap so that we can recover the space occupied by the string of the
             * deleted item.
             */
            /*
             * Get the string which we will be deleting
             */
            pbStrings = (PBYTE)(plb->hStrings);
            lpString = (LPTSTR)(pbStrings + ((lpLBItem)lpT)->offsz);
            cbStringLen = (wcslen(lpString) + 1) * sizeof(WCHAR);  /* include null terminator */

            /*
             * Now compact the string array
             */
            plb->ichAlloc = plb->ichAlloc - cbStringLen;

            RtlMoveMemory(lpString, (PBYTE)lpString + cbStringLen,
                    plb->ichAlloc + (pbStrings - (LPBYTE)lpString));

            /*
             * We have to update the string pointers in plb->rgpch since all the
             * string after the deleted string have been moved down stringLength
             * bytes.  Note that we have to explicitly check all items in the list
             * box if the string was allocated after the deleted item since the
             * LB_SORT style allows a lower item number to have a string allocated
             * at the end of the string heap for example.
             */
            itemNumbers = lp;
            for (sTmp = 0; sTmp <= plb->cMac; sTmp++) {
                lpLBItem p =(lpLBItem)itemNumbers;
                if ( (LPTSTR)(p->offsz + pbStrings) > lpString ) {
                    p->offsz -= cbStringLen;
                }
                p++;
                itemNumbers=(LPBYTE)p;
            }
        }

        /*
         * Now compact the pointers to the strings (or the long app supplied values
         * if ownerdraw without strings).
         */
        RtlMoveMemory(lpT, lpT + cbItem, cb);

        /*
         * Compress the multiselection bytes
         */
        if (plb->wMultiple != SINGLESEL) {
            lpT = (lp + (plb->cMac * cbItem) + sItem);
            RtlMoveMemory(lpT, lpT + 1, plb->cMac - sItem +
                    (plb->OwnerDraw == OWNERDRAWVAR ? plb->cMac + 1 : 0));
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) {
            /*
             * Compress the height bytes
             */
            lpT = (lp + (plb->cMac * cbItem) + (plb->wMultiple ? plb->cMac : 0)
                    + sItem);
            RtlMoveMemory(lpT, lpT + 1, plb->cMac - sItem);
        }

    }

    if (plb->wMultiple == SINGLESEL) {
        if (plb->iSel == sItem) {
            plb->iSel = -1;

            if (plb->pcbox != NULL) {
                ThreadLock(plb->pcbox->spwnd, &tlpwnd);
                xxxCBInternalUpdateEditWindow(plb->pcbox, NULL);
                ThreadUnlock(&tlpwnd);
            }
        } else if (plb->iSel > sItem)
            plb->iSel--;
    }

    if ((plb->iMouseDown != -1) && (sItem <= plb->iMouseDown))
        plb->iMouseDown = -1;

    if (plb->iSelBase && sItem == plb->iSelBase)
        plb->iSelBase--;

    if (plb->cMac) {
        plb->iSelBase = min(plb->iSelBase, plb->cMac - 1);
    } else {
        plb->iSelBase = 0;
    }

    if ((plb->wMultiple == EXTENDEDSEL) && (plb->iSel == -1))
        plb->iSel = plb->iSelBase;

    if (plb->OwnerDraw == OWNERDRAWVAR)
        LBSetCItemFullMax(plb);

    /*
     * We always set a new iTop.  The iTop won't change if it doesn't need to
     * but it will change if:  1.  The iTop was deleted or 2.  We need to change
     * the iTop so that we fill the listbox.
     */
    xxxInsureVisible(plb, plb->iTop, FALSE);

FinishUpDelete:

    /*
     * Check if scroll bars need to be shown/hidden
     */
    plb->fFromInsert = TRUE;
    xxxLBShowHideScrollBars(plb);
    plb->fFromInsert = FALSE;

    xxxCheckRedraw(plb, TRUE, sItem);
    xxxInsureVisible(plb, plb->iSelBase, FALSE);

    return plb->cMac;
}

/***************************************************************************\
* xxxLBoxDeleteItem
*
* Sends a WM_DELETEITEM message to the owner of an ownerdraw listbox
*
* History:
\***************************************************************************/

void xxxLBoxDeleteItem(
    PLBIV plb,
    INT sItem)
{
    DELETEITEMSTRUCT dis;
    TL tlpwndParent;

    CheckLock(plb->spwnd);
    if (plb->spwnd == NULL)
        return;

    /*
     * Bug 262122 - joejo
     * No need to send message if no data!
     */
    if (!plb->fHasData) {
        return;
    }

    /*
     * Fill the DELETEITEMSTRUCT
     */
    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = PtrToUlong(plb->spwnd->spmenu);
    dis.itemID = sItem;
    dis.hwndItem = HWq(plb->spwnd);

    /*
     * Bug 262122 - joejo
     * Fixed in 93 so that ItemData was passed. For some reason, not
     * merged in.
     */
    dis.itemData = LBGetItemData(plb, sItem);

    if (plb->spwndParent != NULL) {
        ThreadLock(plb->spwndParent, &tlpwndParent);
        SendMessage(HWq(plb->spwndParent), WM_DELETEITEM, dis.CtlID,
                (LPARAM)&dis);
        ThreadUnlock(&tlpwndParent);
    }
}

/**************************************************************************\
* xxxLBSetCount
*
* Sets the number of items in a lazy-eval (fNoData) listbox.
*
* Calling SetCount scorches any existing selection state.  To preserve
* selection state, call Insert/DeleteItem instead.
*
* History
* 16-Apr-1992 beng      Created
\**************************************************************************/

INT xxxLBSetCount(
    PLBIV plb,
    INT cItems)
{
    UINT  cbRequired;
    BOOL    fRedraw;

    CheckLock(plb->spwnd);

    /*
     * SetCount is only valid on lazy-eval ("nodata") listboxes.
     * All other lboxen must add their items one at a time, although
     * they may SetCount(0) via RESETCONTENT.
     */
    if (plb->fHasStrings || plb->fHasData) {
        RIPERR0(ERROR_SETCOUNT_ON_BAD_LB, RIP_VERBOSE, "");
        return LB_ERR;
    }

    if (cItems == 0) {
        SendMessageWorker(plb->spwnd, LB_RESETCONTENT, 0, 0, FALSE);
        return 0;
    }

    // If redraw isn't turned off, turn it off now
    if (fRedraw = plb->fRedraw)
        xxxLBSetRedraw(plb, FALSE);

    cbRequired = LBCalcAllocNeeded(plb, cItems);

    /*
     * Reset selection and position
     */
    plb->iSelBase = 0;
    plb->iTop = 0;
    plb->cMax = 0;
    plb->xOrigin = 0;
    plb->iLastSelection = 0;
    plb->iSel = -1;

    if (cbRequired != 0) { // Only if record instance data required

        /*
         * If listbox was previously empty, prepare for the
         * realloc-based alloc strategy ahead.
         */
        if (plb->rgpch == NULL) {
            plb->rgpch = UserLocalAlloc(HEAP_ZERO_MEMORY, 0L);
            plb->cMax = 0;

            if (plb->rgpch == NULL) {
                xxxNotifyOwner(plb, LBN_ERRSPACE);
                return LB_ERRSPACE;
            }
        }

        /*
         * rgpch might not have enough room for the new record instance
         * data, so check and realloc as necessary.
         */
        if (cItems >= plb->cMax) {
            INT    cMaxNew;
            UINT   cbNew;
            HANDLE hmemNew;

            /*
             * Since GrowMem presumes a one-item-at-a-time add schema,
             * SetCount can't use it.  Too bad.
             */
            cMaxNew = cItems+CITEMSALLOC;
            cbNew = LBCalcAllocNeeded(plb, cMaxNew);
            hmemNew = UserLocalReAlloc(plb->rgpch, cbNew, HEAP_ZERO_MEMORY);

            if (hmemNew == NULL) {
                xxxNotifyOwner(plb, LBN_ERRSPACE);
                return LB_ERRSPACE;
            }

            plb->rgpch = hmemNew;
            plb->cMax = cMaxNew;
        }

        /*
         * Reset the item instance data (multisel annotations)
         */
        RtlZeroMemory(plb->rgpch, cbRequired);
    }

    plb->cMac = cItems;

    // Turn redraw back on
    if (fRedraw)
        xxxLBSetRedraw(plb, TRUE);

    xxxLBInvalidateRect(plb, NULL, TRUE);
// Not In Chicago -- FritzS
//    NtUserSetScrollPos(plb->spwnd, SB_HORZ, 0, plb->fRedraw);
//    NtUserSetScrollPos(plb->spwnd, SB_VERT, 0, plb->fRedraw);
    xxxLBShowHideScrollBars(plb); // takes care of fRedraw

    return 0;
}

/**************************************************************************\
* LBCalcAllocNeeded
*
* Calculate the number of bytes needed in rgpch to accommodate a given
* number of items.
*
* History
* 16-Apr-1992 beng      Created
\**************************************************************************/

UINT LBCalcAllocNeeded(
    PLBIV plb,
    INT cItems)
{
    UINT cb;

    /*
     * Allocate memory for pointers to the strings.
     */
    cb = cItems * (plb->fHasStrings ? sizeof(LBItem)
                                    : (plb->fHasData ? sizeof(LBODItem)
                                                    : 0));

    /*
     * If multiple selection list box (MULTIPLESEL or EXTENDEDSEL), then
     * allocate an extra byte per item to keep track of it's selection state.
     */
    if (plb->wMultiple != SINGLESEL) {
        cb += cItems;
    }

    /*
     * Extra bytes for each item so that we can store its height.
     */
    if (plb->OwnerDraw == OWNERDRAWVAR) {
        cb += cItems;
    }

    return cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\instance.c ===
/****************************** Module Header ******************************\
* Module Name: instance.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module handles conversion of instance handles (server side handles)
* to instance indecies used by the handle manager for associating a handle
* with a particular instance.
*
* History:
* 11-5-91 Sanfords Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define INST_GROW_COUNT 4

// globals

PHANDLE aInstance = NULL;
int cInstAllocated = 0;
int iFirstFreeInst = 0;


/***************************************************************************\
* AddInstance
*
* Description:
* Adds a server side instance handle to the instance handle array.
* The array index becomes the client-side unique instance index used for
* identifying other client side handles.
*
* Returns:
* client side instance handle or 0 on error.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
HANDLE AddInstance(
HANDLE hInstServer)
{
    int i, iNextFree;
    PHANDLE ph;

    if (iFirstFreeInst >= cInstAllocated) {
        if (cInstAllocated == 0) {
           aInstance = (PHANDLE)DDEMLAlloc(sizeof(HANDLE) * INST_GROW_COUNT);
        } else {
           aInstance = (PHANDLE)DDEMLReAlloc((PVOID)aInstance,
                 sizeof(HANDLE) * (cInstAllocated + INST_GROW_COUNT));
        }
        if (aInstance == 0) {
            return (0);
        }
        ph = &aInstance[cInstAllocated];
        i = cInstAllocated + 1;
        while (i <= cInstAllocated + INST_GROW_COUNT) {
           *ph++ = (HANDLE)(UINT_PTR)(UINT)i++;
        }
        cInstAllocated += INST_GROW_COUNT;
    }
    iNextFree = HandleToUlong(aInstance[iFirstFreeInst]);
    if (iNextFree > MAX_INST) {
        /*
         * Instance limit for this process exceeded!
         */
        return(0);
    }
    aInstance[iFirstFreeInst] = hInstServer;
    i = iFirstFreeInst;
    iFirstFreeInst = iNextFree;
    return (CreateHandle(0, HTYPE_INSTANCE, i));
}


/***************************************************************************\
* DestroyInstance
*
* Description:
* Removes an instance from the aInstance table. This does nothing for
* the server side instance info.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
HANDLE DestroyInstance(
HANDLE hInstClient)
{
    register HANDLE hInstServerRet = 0;

    DestroyHandle(hInstClient);
    hInstServerRet = aInstance[InstFromHandle(hInstClient)];
    aInstance[InstFromHandle(hInstClient)] = (HANDLE)UIntToPtr( iFirstFreeInst );
    iFirstFreeInst = InstFromHandle(hInstClient);

    return (hInstServerRet);
}


/***************************************************************************\
* ValidateInstance
*
* Description:
* Verifies the current validity of an instance handle - which is a server
* side handle that also references a client side data structure (pcii).
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
PCL_INSTANCE_INFO ValidateInstance(
HANDLE hInstClient)
{
    PCL_INSTANCE_INFO pcii;

    pcii = (PCL_INSTANCE_INFO)ValidateCHandle(hInstClient, HTYPE_INSTANCE, HINST_ANY);

    if (pcii != NULL) {
        if (pcii->tid != GetCurrentThreadId() ||
                pcii->hInstClient != hInstClient) {
            return (NULL);
        }
    }
    return (pcii);
}


/***************************************************************************\
* SetLastDDEMLError
*
* Description:
* Sets last error value and generates monitor events if monitoring.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
VOID SetLastDDEMLError(
PCL_INSTANCE_INFO pcii,
DWORD error)
{
    PEVENT_PACKET pep;

    if (pcii->MonitorFlags & MF_ERRORS && !(pcii->afCmd & APPCLASS_MONITOR)) {
        pep = (PEVENT_PACKET)DDEMLAlloc(sizeof(EVENT_PACKET) - sizeof(DWORD) +
                sizeof(MONERRSTRUCT));
        if (pep != NULL) {
            pep->EventType =    MF_ERRORS;
            pep->fSense =       TRUE;
            pep->cbEventData =  sizeof(MONERRSTRUCT);
#define perrs ((MONERRSTRUCT *)&pep->Data)
            perrs->cb =      sizeof(MONERRSTRUCT);
            perrs->wLastError = (WORD)error;
            perrs->dwTime =  NtGetTickCount();
            perrs->hTask =   (HANDLE)LongToHandle( pcii->tid );
#undef perrs
            LeaveDDECrit;
            Event(pep);
            EnterDDECrit;
        }
    }
#if DBG
    if (error != 0 && error != DMLERR_NO_CONV_ESTABLISHED) {
        RIPMSG3(RIP_WARNING,
                "DDEML Error set=%x, Client Instance=%p, Process=%x.",
                error, pcii, GetCurrentProcessId());
    }
#endif
    pcii->LastError = error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\lboxmult.c ===
/**************************** Module Header ********************************\
* Module Name: lboxmult.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Multi column list box routines
*
* History:
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* LBCalcItemRowsAndColumns
*
* Calculates the number of columns (including partially visible)
* in the listbox and calculates the number of items per column
*
* History:
\***************************************************************************/

void LBCalcItemRowsAndColumns(
    PLBIV plb)
{
    RECT rc;

    _GetClientRect(plb->spwnd, &rc);

    //
    // B#4155
    // We need to check if plb->cyChar has been initialized.  This is because
    // we remove WS_BORDER from old listboxes and add on WS_EX_CLIENTEDGE.
    // Since listboxes are always inflated by CXBORDER and CYBORDER, a
    // listbox that was created empty always ends up 2 x 2.  Since this isn't
    // big enough to fit the entire client border, we don't mark it as
    // present.  Thus the client isn't empty in VER40, although it was in
    // VER31 and before.  It is possible to get to this spot without
    // plb->cyChar having been initialized yet if the listbox  is
    // multicolumn && ownerdraw variable.
    //

    if (rc.bottom && rc.right && plb->cyChar) {

        /*
         * Only make these calculations if the width & height are positive
         */
        plb->itemsPerColumn = (INT)max(rc.bottom / plb->cyChar, 1);
        plb->numberOfColumns = (INT)max(rc.right / plb->cxColumn, 1);

        plb->cItemFullMax = plb->itemsPerColumn * plb->numberOfColumns;

        /*
         * Adjust iTop so it's at the top of a column
         */
        xxxNewITop(plb, plb->iTop);
    }
}


/***************************************************************************\
* xxxLBoxCtlHScrollMultiColumn
*
* Supports horizontal scrolling of multicolumn listboxes
*
* History:
\***************************************************************************/

void xxxLBoxCtlHScrollMultiColumn(
    PLBIV plb,
    INT cmd,
    INT xAmt)
{
    INT iTop = plb->iTop;

    CheckLock(plb->spwnd);

    if (!plb->cMac)  return;

    switch (cmd) {
    case SB_LINEUP:
        if (plb->fRightAlign)
            goto ReallyLineDown;
ReallyLineUp:
        iTop -= plb->itemsPerColumn;
        break;
    case SB_LINEDOWN:
        if (plb->fRightAlign)
            goto ReallyLineUp;
ReallyLineDown:
        iTop += plb->itemsPerColumn;
        break;
    case SB_PAGEUP:
        if (plb->fRightAlign)
            goto ReallyPageDown;
ReallyPageUp:
        iTop -= plb->itemsPerColumn * plb->numberOfColumns;
        break;
    case SB_PAGEDOWN:
        if (plb->fRightAlign)
            goto ReallyPageUp;
ReallyPageDown:
        iTop += plb->itemsPerColumn * plb->numberOfColumns;
        break;
    case SB_THUMBTRACK:
    case SB_THUMBPOSITION:
        if (plb->fRightAlign) {
            int  iCols = plb->cMac ? ((plb->cMac-1) / plb->itemsPerColumn) + 1 : 0;

            xAmt = iCols - (xAmt + plb->numberOfColumns);
            if (xAmt<0)
                xAmt=0;
        }
        iTop = xAmt * plb->itemsPerColumn;
        break;
    case SB_TOP:
        if (plb->fRightAlign)
            goto ReallyBottom;
ReallyTop:
        iTop = 0;
        break;
    case SB_BOTTOM:
        if (plb->fRightAlign)
            goto ReallyTop;
ReallyBottom:
        iTop = plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn);
        break;
    case SB_ENDSCROLL:
        plb->fSmoothScroll = TRUE;
        xxxLBShowHideScrollBars(plb);
        break;
    }

    xxxNewITop(plb, iTop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\lboxctl3.c ===
/****************************************************************************\
*
*  LBOXCTL3.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Directory List Box Routines
*
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\****************************************************************************/

#define CTLMGR
#define LSTRING

#include "precomp.h"
#pragma hdrstop

#define DATESEPARATOR TEXT('-')
#define TIMESEPARATOR  TEXT(':')
#define TABCHAR        TEXT('\t')

#define MAXDIGITSINSIZE 9

void LB_CreateLBLine(LPWIN32_FIND_DATA, LPWSTR);

#define DDL_PRIVILEGES  (DDL_READONLY | DDL_HIDDEN | DDL_SYSTEM | DDL_ARCHIVE)
#define DDL_TYPE        (DDL_DRIVES | DDL_DIRECTORY | DDL_POSTMSGS)

/***************************************************************************\
* ChopText
*
* Chops the given path at 'lpchBuffer' + CCH_CHOPTEXT_EXTRA to fit in the
* field of the static control with id 'idStatic' in the dialog box 'hwndDlg'.
* If the path is too long, an ellipsis prefix is added to the beginning of the
* chopped text ("x:\...\")
*
* If the supplied path does not fit and the last directory appended to
* ellipsis (i.e. "c:\...\eee" in the case of "c:\aaa\bbb\ccc\ddd\eee")
* does not fit, then "x:\..." is returned.
*
* Pathological case:
* "c:\SW\MW\R2\LIB\SERVICES\NT" almost fits into static control, while
* "c:\...\MW\R2\LIB\SERVICES\NT" does fit - although it is more characters.
* In this case, ChopText substitutes the first 'n' characters of the path with
* a prefix containing MORE than 'n' characters!  The extra characters will
* be put in front of lpch, so there must be space reserved for them or they
* will trash the stack.  lpch contains CCH_CHOPTEXT_EXTRA chars followed by
* the path.
*
* History:
\***************************************************************************/

/*
 * In practice CCH_CHOPTEXT_EXTRA probably never has to be more than 1 or 2,
 * but in case the font is weird, set it to the number of chars in the prefix.
 * This guarantees enough space to prepend the prefix.
 */
#define CCH_CHOPTEXT_EXTRA 7

LPWSTR ChopText(
    PWND pwndDlg,
    int idStatic,
    LPWSTR lpchBuffer)
{
#define AWCHLEN(a) ((sizeof(a)/sizeof(a[0])) - 1)

    /*
     * Declaring szPrefix this way ensures CCH_CHOPTEXT_EXTRA is big enough
     */
    WCHAR szPrefix[CCH_CHOPTEXT_EXTRA + 1] = L"x:\\...\\";
    int cxField;
    RECT rc;
    SIZE size;
    PWND pwndStatic;
    PSTAT pstat;
    HDC hdc;
    HFONT hOldFont;
    int cchPath;
    PWCHAR lpch;
    PWCHAR lpchPath;

    /*
     * Get length of static field.
     */
    pwndStatic = _GetDlgItem(pwndDlg, idStatic);
    if (pwndStatic == NULL)
        return NULL;

    _GetClientRect(pwndStatic, &rc);
    cxField = rc.right - rc.left;

    /*
     * Set up DC appropriately for the static control.
     */
    hdc = NtUserGetDC(HWq(pwndStatic));

    /*
     * Only assume this is a static window if this window uses the static
     * window wndproc.
     */
    hOldFont = NULL;
    if (GETFNID(pwndStatic) == FNID_STATIC) {
        pstat = ((PSTATWND)pwndStatic)->pstat;
        if (pstat != NULL && pstat != (PSTAT)-1 && pstat->hFont)
            hOldFont = SelectObject(hdc, pstat->hFont);
    }

    /*
     * Check horizontal extent of string.
     */
    lpch = lpchPath = lpchBuffer + CCH_CHOPTEXT_EXTRA;
    cchPath = wcslen(lpchPath);
    GetTextExtentPoint(hdc, lpchPath, cchPath, &size);
    if (size.cx > cxField) {

        /*
         * String is too long to fit in the static control; chop it.
         * Set up new prefix and determine remaining space in control.
         */
        szPrefix[0] = *lpchPath;
        GetTextExtentPoint(hdc, szPrefix, AWCHLEN(szPrefix), &size);

        /*
         * If the field is too small to display all of the prefix,
         * copy only the prefix.
         */
        if (cxField < size.cx) {
            RtlCopyMemory(lpch, szPrefix, sizeof(szPrefix));
            goto DoneChop;
        } else
            cxField -= size.cx;

        /*
         * Advance a directory at a time until the remainder of the
         * string fits into the static control after the "x:\...\" prefix.
         */
        while (TRUE) {
            int cchT;
            while (*lpch && (*lpch++ != L'\\')) {
                ;
            }
            cchT = cchPath - (int)(lpch - lpchPath);
            GetTextExtentPoint(hdc, lpch, cchT, &size);
            if (*lpch == 0 || size.cx <= cxField) {

                if (*lpch == 0) {

                    /*
                     * Nothing could fit after the prefix; remove the
                     * final "\" from the prefix
                     */
                    szPrefix[AWCHLEN(szPrefix) - 1] = 0;
                }

                /*
                 * rest of string fits -- back up and stick prefix on front
                 * We are guaranteed to have at least CCH_CHOPTEXT_EXTRA chars
                 * backing up space, so we won't trash any stack. #26453
                 */
                lpch -= AWCHLEN(szPrefix);

                UserAssert(lpch >= lpchBuffer);

                RtlCopyMemory(lpch, szPrefix, sizeof(szPrefix) - sizeof(WCHAR));
                goto DoneChop;
            }
        }
    }

DoneChop:
    if (hOldFont)
        SelectObject(hdc, hOldFont);

    ReleaseDC(HWq(pwndStatic), hdc);

    return lpch;
}


/***************************************************************************\
* xxxDlgDirListHelper
*
*  NOTE:  If idStaticPath is < 0, then that parameter contains the details
*         about what should be in each line of the list box
*
* History:
\***************************************************************************/

BOOL xxxDlgDirListHelper(
    PWND pwndDlg,
    LPWSTR lpszPathSpec,
    LPBYTE lpszPathSpecClient,
    int idListBox,
    int idStaticPath,
    UINT attrib,
    BOOL fListBox)  /* Listbox or ComboBox? */
{
    PWND pwndLB;
    TL tlpwndLB;
    BOOL fDir = TRUE;
    BOOL fRoot, bRet;
    BOOL fPostIt;
    INT   cch;
    WCHAR ch;
    WCHAR szStaticPath[CCH_CHOPTEXT_EXTRA + MAX_PATH];
    PWCHAR pszCurrentDir;
    UINT wDirMsg;
    LPWSTR lpchFile;
    LPWSTR lpchDirectory;
    PLBIV plb;
    BOOL fWasVisible = FALSE;
    BOOL        fWin40Compat;
    PCBOX pcbox;

    CheckLock(pwndDlg);

    /*
     * Strip the private bit DDL_NOFILES out - KidPix passes it in my mistake!
     */
    if (attrib & ~DDL_VALID) {
        RIPERR2(ERROR_INVALID_FLAGS, RIP_WARNING, "Invalid flags, %x & ~%x != 0",
              attrib, DDL_VALID);
        return FALSE;
    }

    if (attrib & DDL_NOFILES) {
        RIPMSG0(RIP_WARNING, "DlgDirListHelper: stripping DDL_NOFILES");
        attrib &= ~DDL_NOFILES;
    }

    /*
     * Case:Works is an app that calls DlgDirList with a NULL has hwndDlg;
     * This is allowed because he uses NULL for idStaticPath and idListBox.
     * So, the validation layer has been modified to allow a NULL for hwndDlg.
     * But, we catch the bad apps with the following check.
     * Fix for Bug #11864 --SANKAR-- 08/22/91 --
     */
    if (!pwndDlg && (idStaticPath || idListBox)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return FALSE;
    }

    plb = NULL;

    /*
     * Do we need to add date, time, size or attribute info?
     * Windows checks the Atom but misses if the class has been sub-classed
     * as in VB.
     */
    if (pwndLB = (PWND)_GetDlgItem(pwndDlg, idListBox)) {
        WORD fnid = GETFNID(pwndLB);

        if ((fnid == FNID_LISTBOX && fListBox) ||
                (fnid == FNID_COMBOBOX && !fListBox) ||
                (fnid == FNID_COMBOLISTBOX && fListBox)) {
            if (fListBox) {
                plb = ((PLBWND)pwndLB)->pLBIV;
            } else {

                pcbox = ((PCOMBOWND)pwndLB)->pcbox;
                plb = ((PLBWND)(pcbox->spwndList))->pLBIV;
            }
        } else {
            RIPERR0(ERROR_LISTBOX_ID_NOT_FOUND, RIP_VERBOSE, "");
        }
    } else if (idListBox != 0) {

        /*
         * Yell if the app passed an invalid list box id and keep from using a
         * bogus plb.  PLB is NULLed above.
         */
        RIPERR0(ERROR_LISTBOX_ID_NOT_FOUND, RIP_VERBOSE, "");
    }

    if (idStaticPath < 0 && plb != NULL) {

        /*
         * Clear idStaticPath because its purpose is over.
         */
        idStaticPath = 0;

    }

    fPostIt = (attrib & DDL_POSTMSGS);

    if (lpszPathSpec) {
        cch = lstrlenW(lpszPathSpec);
        if (!cch) {
            if (lpszPathSpecClient != (LPBYTE)lpszPathSpec) {
                lpszPathSpecClient = achSlashStar;
            }
            lpszPathSpec = awchSlashStar;
        } else {
            /*
             * Make sure we won't overflow our buffers...
             */
            if (cch > CCHFILEMAX)
                return FALSE;

            /*
             * Convert lpszPathSpec into an upper case, OEM string.
             */
            CharUpper(lpszPathSpec);
            lpchDirectory = lpszPathSpec;

            lpchFile = szSLASHSTARDOTSTAR + 1;

            if (*lpchDirectory) {

                cch = wcslen(lpchDirectory);

                /*
                 * If the directory name has a * or ? in it, don't bother trying
                 * the (slow) SetCurrentDirectory.
                 */
                if (((INT)FindCharPosition(lpchDirectory, TEXT('*')) != cch) ||
                    ((INT)FindCharPosition(lpchDirectory, TEXT('?')) != cch) ||
                    !SetCurrentDirectory(lpchDirectory)) {

                    /*
                     * Set 'fDir' and 'fRoot' accordingly.
                     */
                    lpchFile = lpchDirectory + cch;
                    fDir = *(lpchFile - 1) == TEXT('\\');
                    fRoot = 0;
                    while (cch--) {
                        ch = *(lpchFile - 1);
                        if (ch == TEXT('*') || ch == TEXT('?'))
                            fDir = TRUE;

                        if (ch == TEXT('\\') || ch == TEXT('/') || ch == TEXT(':')) {
                            fRoot = (cch == 0 || *(lpchFile - 2) == TEXT(':') ||
                                    (ch == TEXT(':')));
                            break;
                        }
                        lpchFile--;
                    }

                    /*
                     * To remove Bug #16, the following error return is to be removed.
                     * In order to prevent the existing apps from breaking up, it is
                     * decided that the bug will not be fixed and will be mentioned
                     * in the documentation.
                     * --SANKAR-- Sep 21
                     */

                    /*
                     * If no wildcard characters, return error.
                     */
                    if (!fDir) {
                        RIPERR0(ERROR_NO_WILDCARD_CHARACTERS, RIP_VERBOSE, "");
                        return FALSE;
                    }

                    /*
                     * Special case for lpchDirectory == "\"
                     */
                    if (fRoot)
                        lpchFile++;

                    /*
                     * Do we need to change directories?
                     */
                    if (fRoot || cch >= 0) {

                        /*
                         * Replace the Filename's first char with a nul.
                         */
                        ch = *--lpchFile;
                        *lpchFile = TEXT('\0');

                        /*
                         * Change the current directory.
                         */
                        if (*lpchDirectory) {
                            bRet = SetCurrentDirectory(lpchDirectory);
                            if (!bRet) {

                                /*
                                 * Restore the filename before we return...
                                 */
                                *((LPWSTR)lpchFile)++ = ch;
                                return FALSE;
                            }
                        }

                        /*
                         * Restore the filename's first character.
                         */
                        *lpchFile++ = ch;
                    }

                    /*
                     * Undo damage caused by special case above.
                     */
                    if (fRoot) {
                        lpchFile--;
                    }
                }
            }

            /*
             * This is copying on top of the data the client passed us! Since
             * the LB_DIR or CB_DIR could be posted, and since we need to
             * pass a client side string pointer when we do that, we need
             * to copy this new data back to the client!
             */
            if (fPostIt && lpszPathSpecClient != (LPBYTE)lpszPathSpec) {
                WCSToMB(lpchFile, -1, &lpszPathSpecClient, MAXLONG, FALSE);
            }
            wcscpy(lpszPathSpec, lpchFile);
        }
    }
    /*
     * In some cases, the ChopText requires extra space ahead of the path:
     * Give it CCH_CHOPTEXT_EXTRA extra spaces. (See ChopText() above).
     */
    pszCurrentDir = szStaticPath + CCH_CHOPTEXT_EXTRA;
    GetCurrentDirectory(
            sizeof(szStaticPath)/sizeof(WCHAR) - CCH_CHOPTEXT_EXTRA,
            pszCurrentDir);

    /*
     * If we have a listbox, lock it down
     */
    if (pwndLB != NULL) {
        ThreadLockAlways(pwndLB, &tlpwndLB);
    }

    /*
     * Fill in the static path item.
     */
    if (idStaticPath) {

        /*
         * To fix a bug OemToAnsi() call is inserted; SANKAR--Sep 16th
         */
// OemToChar(szCurrentDir, szCurrentDir);
        CharLower(pszCurrentDir);
        SetDlgItemText(HWq(pwndDlg), idStaticPath, ChopText(pwndDlg, idStaticPath, szStaticPath));
    }

    /*
     * Fill in the directory List/ComboBox if it exists.
     */
    if (idListBox && pwndLB != NULL) {

        HWND hwndLB = HWq(pwndLB);

        wDirMsg = (UINT)(fListBox ? LB_RESETCONTENT : CB_RESETCONTENT);

        if (fPostIt) {
            PostMessage(hwndLB, wDirMsg, 0, 0L);
        } else {
            if (plb != NULL && (fWasVisible = IsLBoxVisible(plb))) {
                SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
            }
            SendMessage(hwndLB, wDirMsg, 0, 0L);
        }

        wDirMsg = (UINT)(fListBox ? LB_DIR : CB_DIR);

        if (attrib == DDL_DRIVES)
            attrib |= DDL_EXCLUSIVE;

        //
        // Hack for DDL_EXCLUSIVE to REALLY work.
        //
        fWin40Compat = TestWF(pwndLB, WFWIN40COMPAT);

        //
        // BACKWARDS COMPATIBILITY HACK
        //
        // We want DDL_EXCLUSIVE to _really_ work for new apps.  I.E., we
        // want apps to be able to specify DDL_DRIVES/DDL_VOLUMES with
        // DDL_EXCLUSIVE and privilege bits -- and have only those items
        // matching show up, w/out files.
        //
        if (attrib & DDL_EXCLUSIVE)
        {
            if (fWin40Compat)
            {
                if (attrib & (DDL_DRIVES | DDL_DIRECTORY))
                    attrib |= DDL_NOFILES;
            }
            else
            {
                if (attrib == (DDL_DRIVES | DDL_EXCLUSIVE))
                    attrib |= DDL_NOFILES;
            }
        }

        if (!(attrib & DDL_NOFILES)) {

            /*
             * Add everything except the subdirectories and disk drives.
             */
            if (fPostIt) {
                /*
                 * Post lpszPathSpecClient, the client side pointer.
                 */
#ifdef WASWIN31
                PostMessage(hwndLB, wDirMsg, attrib &
                        ~(DDL_DIRECTORY | DDL_DRIVES | DDL_POSTMSGS),
                        (LPARAM)lpszPathSpecClient);
#else
                /*
                 * On NT, keep DDL_POSTMSGS in wParam because we need to know
                 * in the wndproc whether the pointer is clientside or server
                 * side.
                 */
                PostMessage(hwndLB, wDirMsg,
                        attrib & ~(DDL_DIRECTORY | DDL_DRIVES),
                        (LPARAM)lpszPathSpecClient);
#endif

            } else {

                /*
                 * IanJa: #ifndef WIN16 (32-bit Windows), attrib gets extended
                 * to LONG wParam automatically by the compiler
                 */
                SendMessage(hwndLB, wDirMsg,
                        attrib & ~(DDL_DIRECTORY | DDL_DRIVES),
                        (LPARAM)lpszPathSpec);
            }

#ifdef WASWIN31
            /*
             * Strip out just the subdirectory and drive bits.
             */
            attrib &= (DDL_DIRECTORY | DDL_DRIVES);
#else
            //
            // B#1433
            // The old code stripped out read-only, hidden, system, and archive
            // information for subdirectories, making it impossible to have
            // a listbox w/ hidden directories!
            //

            /*
             * Strip out just the subdirectory and drive bits. ON NT, keep
             * the DDL_POSTMSG bit so we know how to thunk this message.
             */
            if (!fWin40Compat)
                attrib &= DDL_TYPE;
            else
            {
                attrib &= (DDL_TYPE | (attrib & DDL_PRIVILEGES));
                attrib |= DDL_NOFILES;
            }
//            attrib &= (DDL_DIRECTORY | DDL_DRIVES | DDL_POSTMSGS);
#endif
        }

        //
        // Add directories and volumes to the listbox.
        //
        if (attrib & DDL_TYPE) {

            /*
             * Add the subdirectories and disk drives.
             */
            lpszPathSpec = szSLASHSTARDOTSTAR + 1;

            attrib |= DDL_EXCLUSIVE;

            if (fPostIt) {
                /*
                 * Post lpszPathSpecClient, the client side pointer (see text
                 * above).
                 */
                PostMessage(hwndLB, wDirMsg, attrib, (LPARAM)lpszPathSpecClient);
            } else {
                SendMessage(hwndLB, wDirMsg, attrib, (LPARAM)lpszPathSpec);
            }
        }

        if (!fPostIt && fWasVisible) {
            SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
            NtUserInvalidateRect(hwndLB, NULL, TRUE);
        }
    }

    if (pwndLB != NULL) {
        ThreadUnlock(&tlpwndLB);
    }

    return TRUE;
}


/***************************************************************************\
* xxxDlgDirList
*
* History:
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DlgDirListA, HWND, hwndDlg, LPSTR, lpszPathSpecClient, int, idListBox, int, idStaticPath, UINT, attrib)
BOOL DlgDirListA(
    HWND hwndDlg,
    LPSTR lpszPathSpecClient,
    int idListBox,
    int idStaticPath,
    UINT attrib)
{
    LPWSTR lpszPathSpec;
    PWND pwndDlg;
    TL tlpwndDlg;
    BOOL fRet;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return FALSE;

    lpszPathSpec = NULL;
    if (lpszPathSpecClient) {
        if (!MBToWCS(lpszPathSpecClient, -1, &lpszPathSpec, -1, TRUE))
            return FALSE;
    }

    /*
     * The last parameter is TRUE to indicate ListBox (not ComboBox)
     */
    ThreadLock(pwndDlg, &tlpwndDlg);
    fRet = xxxDlgDirListHelper(pwndDlg, lpszPathSpec, lpszPathSpecClient,
            idListBox, idStaticPath, attrib, TRUE);
    ThreadUnlock(&tlpwndDlg);

    if (lpszPathSpec) {
        if (fRet) {
            /*
             * Non-zero retval means some text to copy out.  Copy out up to
             * the nul terminator (buffer will be big enough).
             */
            WCSToMB(lpszPathSpec, -1, &lpszPathSpecClient, MAXLONG, FALSE);
        }
        UserLocalFree(lpszPathSpec);
    }

    return fRet;
}


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DlgDirListW, HWND, hwndDlg, LPWSTR, lpszPathSpecClient, int, idListBox, int, idStaticPath, UINT, attrib)
BOOL DlgDirListW(
    HWND hwndDlg,
    LPWSTR lpszPathSpecClient,
    int idListBox,
    int idStaticPath,
    UINT attrib)
{
    LPWSTR lpszPathSpec;
    PWND pwndDlg;
    TL tlpwndDlg;
    BOOL fRet;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return FALSE;

    lpszPathSpec = lpszPathSpecClient;

    /*
     * The last parameter is TRUE to indicate ListBox (not ComboBox)
     */
    ThreadLock(pwndDlg, &tlpwndDlg);
    fRet = xxxDlgDirListHelper(pwndDlg, lpszPathSpec, (LPBYTE)lpszPathSpecClient,
            idListBox, idStaticPath, attrib, TRUE);
    ThreadUnlock(&tlpwndDlg);

    return fRet;
}


/***************************************************************************\
* DlgDirSelectHelper
*
* History:
\***************************************************************************/

BOOL DlgDirSelectHelper(
    LPWSTR lpszPathSpec,
    int chCount,
    HWND hwndListBox)
{
    INT   cch;
    LPWSTR lpchFile;
    BOOL fDir;
    INT sItem;
    LPWSTR lpchT;
    WCHAR rgch[CCHFILEMAX + 2];
    int cchT;
    LARGE_UNICODE_STRING str;

    /*
     * Callers such as DlgDirSelectEx do not validate the existance
     * of hwndListBox
     */
    if (hwndListBox == NULL) {
        RIPERR0(ERROR_CONTROL_ID_NOT_FOUND, RIP_VERBOSE, "");
        return 0;
    }

    sItem = (INT)SendMessage(hwndListBox, LB_GETCURSEL, 0, 0L);
    if (sItem < 0)
        return FALSE;

    cchT = (INT)SendMessage(hwndListBox, LB_GETTEXT, sItem, (LPARAM)rgch);
    UserAssert(cchT < (sizeof(rgch)/sizeof(rgch[0])));

    lpchFile = rgch;
    fDir = (*rgch == TEXT('['));

    /*
     * Check if all details along with file name are to be returned.  Make sure
     * we can find the listbox because with drop down combo boxes, the
     * GetDlgItem will fail.
     *
     * Make sure this window has been using the listbox window proc because
     * we store some data as a window long.
     */

    /*
     * Only the file name is to be returned.  Find the end of the filename.
     */
    lpchT = lpchFile;
    while ((*lpchT) && (*lpchT != TABCHAR))
        lpchT++;
    *lpchT = TEXT('\0');

    cch = wcslen(lpchFile);

    /*
     * Selection is drive or directory.
     */
    if (fDir) {
        lpchFile++;
        cch--;
        *(lpchFile + cch - 1) = TEXT('\\');

        /*
         * Selection is drive
         */
        if (rgch[1] == TEXT('-')) {
            lpchFile++;
            cch--;
            *(lpchFile + 1) = TEXT(':');
            *(lpchFile + 2) = 0;
        }
    } else {

        /*
         * Selection is file.  If filename has no extension, append '.'
         */
        lpchT = lpchFile;
        for (; (cch > 0) && (*lpchT != TABCHAR);
                cch--, lpchT++) {
            if (*lpchT == TEXT('.'))
                goto Exit;
        }
        if (*lpchT == TABCHAR) {
            memmove(lpchT + 1, lpchT, CHARSTOBYTES(cch + 1));
            *lpchT = TEXT('.');
        } else {
            *lpchT++ = TEXT('.');
            *lpchT = 0;
        }
    }

Exit:
    RtlInitLargeUnicodeString(&str, lpchFile, (UINT)-1);
    TextCopy(&str, lpszPathSpec, (UINT)chCount);
    return fDir;
}


/***************************************************************************\
* DlgDirSelectEx
*
* History:
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DlgDirSelectExA, HWND, hwndDlg, LPSTR, lpszPathSpec, int, chCount, int, idListBox)
BOOL DlgDirSelectExA(
    HWND hwndDlg,
    LPSTR lpszPathSpec,
    int chCount,
    int idListBox)
{
    LPWSTR lpwsz;
    BOOL fRet;

    lpwsz = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, chCount * sizeof(WCHAR));
    if (!lpwsz) {
        return FALSE;
    }

    fRet = DlgDirSelectHelper(lpwsz, chCount, GetDlgItem(hwndDlg, idListBox));

    WCSToMB(lpwsz, -1, &lpszPathSpec, chCount, FALSE);

    UserLocalFree(lpwsz);

    return fRet;
}


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DlgDirSelectExW, HWND, hwndDlg, LPWSTR, lpszPathSpec, int, chCount, int, idListBox)
BOOL DlgDirSelectExW(
    HWND hwndDlg,
    LPWSTR lpszPathSpec,
    int chCount,
    int idListBox)
{
    return DlgDirSelectHelper(lpszPathSpec, chCount, GetDlgItem(hwndDlg, idListBox));
}


/***************************************************************************\
* xxxLbDir
*
* History:
\***************************************************************************/

/*
 * Note that these FILE_ATTRIBUTE_* values map directly with
 * their DDL_* counterparts, with the exception of FILE_ATTRIBUTE_NORMAL.
 */
#define FIND_ATTR ( \
        FILE_ATTRIBUTE_NORMAL | \
        FILE_ATTRIBUTE_DIRECTORY | \
        FILE_ATTRIBUTE_HIDDEN | \
        FILE_ATTRIBUTE_SYSTEM | \
        FILE_ATTRIBUTE_ARCHIVE | \
        FILE_ATTRIBUTE_READONLY )
#define EXCLUDE_ATTR ( \
        FILE_ATTRIBUTE_DIRECTORY | \
        FILE_ATTRIBUTE_HIDDEN | \
        FILE_ATTRIBUTE_SYSTEM )

INT xxxLbDir(
    PLBIV plb,
    UINT attrib,
    LPWSTR lhszFileSpec)
{
    INT result;
    BOOL fWasVisible, bRet;
    WCHAR Buffer[CCHFILEMAX + 1];
    WCHAR Buffer2[CCHFILEMAX + 1];
    HANDLE hFind;
    WIN32_FIND_DATA ffd;
    UINT attribFile;
    DWORD mDrives;
    INT cDrive;
    UINT attribInclMask, attribExclMask;

    CheckLock(plb->spwnd);

    /*
     * Make sure the buffer is valid and copy it onto the stack. Why? Because
     * there is a chance that lhszFileSpec is pointing to an invalid string
     * because some app posted a CB_DIR or LB_DIR without the DDL_POSTMSGS
     * bit set.
     */
    try {
        wcscpy(Buffer2, lhszFileSpec);
        lhszFileSpec = Buffer2;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return -1;
    }

    result = -1;

#ifndef UNICODE
    CharToOem(lhszFileSpec, lhszFileSpec);
#endif

    if (fWasVisible = IsLBoxVisible(plb)) {
        SendMessage(HWq(plb->spwnd), WM_SETREDRAW, FALSE, 0);
    }

    /*
     * First we add the files then the directories and drives.
     * If they only wanted drives then skip the file query
     * Also under Windows specifing only 0x8000 (DDL_EXCLUSIVE) adds no files).
     */


//    if ((attrib != (DDL_EXCLUSIVE | DDL_DRIVES)) && (attrib != DDL_EXCLUSIVE) &&
    if (attrib != (DDL_EXCLUSIVE | DDL_DRIVES | DDL_NOFILES)) {
        hFind = FindFirstFile(lhszFileSpec, &ffd);

        if (hFind != INVALID_HANDLE_VALUE) {

            /*
             * If this is not an exclusive search, include normal files.
             */
            attribInclMask = attrib & FIND_ATTR;
            if (!(attrib & DDL_EXCLUSIVE))
                attribInclMask |= FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_READONLY |
                        FILE_ATTRIBUTE_ARCHIVE;

            /*
             * Make a mask of the attributes to be excluded from
             * the search.
             */
            attribExclMask = ~attrib & EXCLUDE_ATTR;

// LATER BUG - scottlu
// Win3 assumes doing a LoadCursor here will return the same wait cursor that
// has already been created, whereas calling ServerLoadCursor creates a new
// one every time!
// hCursorT = NtUserSetCursor(ServerLoadCursor(NULL, IDC_WAIT));


// FindFirst/Next works different in NT then DOS.  Under DOS you passed in
// a set of attributes under NT you get back a set of attributes and have
// to test for those attributes (Dos input attributes were Hidden, System
// and Directoy) the dos find first always returned ReadOnly and archive files

// we are going to select a file in one of two cases.
// 1) if any of the attrib bits are set on the file.
// 2) if we want normal files and the file is a notmal file (the file attrib
//    bits don't contain any NOEXCLBITS

            do {
                attribFile = (UINT)ffd.dwFileAttributes;
                if (attribFile == FILE_ATTRIBUTE_COMPRESSED) {
                    attribFile = FILE_ATTRIBUTE_NORMAL;
                }
                attribFile &= ~FILE_ATTRIBUTE_COMPRESSED;

                /*
                 * Accept those files that have only the
                 * attributes that we are looking for.
                 */
                if ((attribFile & attribInclMask) != 0 &&
                        (attribFile & attribExclMask) == 0) {
                    if (attribFile & DDL_DIRECTORY) {

                        /*
                         * Don't include '.' (current directory) in list.
                         */
                        if (*((LPDWORD)&ffd.cFileName[0]) == 0x0000002E)
                            goto cfnf;

                        /*
                         * If we're not looking for dirs, ignore it
                         */
                        if (!(attrib & DDL_DIRECTORY))
                            goto cfnf;

                    } else if (attrib & DDL_NOFILES) {
                        /*
                         * Don't include files if DDL_NOFILES is set.
                         */
                        goto cfnf;
                    }

                    LB_CreateLBLine(&ffd,
                            Buffer);
                    result = xxxLBInsertItem(plb, Buffer, 0, MSGFLAG_SPECIAL_THUNK | LBI_ADD);
                }
cfnf:
                bRet = FindNextFile(hFind, &ffd);

            } while (result >= -1 && bRet);
            FindClose(hFind);

// LATER see above comment
// NtUserSetCursor(hCursorT);
        }
    }

    /*
     * If drive bit set, include drives in the list.
     */
    if (result != LB_ERRSPACE && (attrib & DDL_DRIVES)) {
        ffd.cFileName[0] = TEXT('[');
        ffd.cFileName[1] = ffd.cFileName[3] = TEXT('-');
        ffd.cFileName[4] = TEXT(']');
        ffd.cFileName[5] = 0;
        mDrives = GetLogicalDrives();
        for (cDrive = 0; mDrives; mDrives >>= 1, cDrive++) {
            if (mDrives & 1) {
                ffd.cFileName[2] = (WCHAR)(TEXT('A') + cDrive);

                /*
                 * We have to set the SPECIAL_THUNK bit because we are
                 * adding a server side string to a list box that may not
                 * be HASSTRINGS so we have to force the server-client
                 * string thunk.
                 */
                if ((result = xxxLBInsertItem(plb, CharLower(ffd.cFileName), -1,
                        MSGFLAG_SPECIAL_THUNK)) < 0) {
                    break;
                }
            }
        }
    }

    if (result == LB_ERRSPACE) {
        xxxNotifyOwner(plb, LB_ERRSPACE);
    }

    if (fWasVisible) {
        SendMessage(HWq(plb->spwnd), WM_SETREDRAW, TRUE, 0);
    }

    xxxLBShowHideScrollBars(plb);

    xxxCheckRedraw(plb, FALSE, 0);

    if (result != LB_ERRSPACE) {

        /*
         * Return index of last item in the listbox.  We can't just return
         * result because that is the index of the last item added which may
         * be in the middle somewhere if the LBS_SORT style is on.
         */
        return plb->cMac - 1;
    } else {
        return result;
    }
}

/***************************************************************************\
* xxxLbInsertFile
*
* Yet another CraigC shell hack... This responds to LB_ADDFILE messages
* sent to directory windows in the file system as a response to the
* WM_FILESYSCHANGE message.  That way, we don't reread the whole
* directory when we copy files.
*
* History:
\***************************************************************************/

INT xxxLbInsertFile(
    PLBIV plb,
    LPWSTR lpFile)
{
    WCHAR chBuffer[CCHFILEMAX + 1];
    INT result = -1;
    HANDLE hFind;
    WIN32_FIND_DATA ffd;

    CheckLock(plb->spwnd);

    hFind = FindFirstFile(lpFile, &ffd);
    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
        LB_CreateLBLine(&ffd, chBuffer);
        result = xxxLBInsertItem(plb, chBuffer, 0, MSGFLAG_SPECIAL_THUNK | LBI_ADD);
    }

    if (result == LB_ERRSPACE) {
        xxxNotifyOwner(plb, result);
    }

    xxxCheckRedraw(plb, FALSE, 0);
    return result;
}

/***************************************************************************\
* LB_CreateLBLine
*
* This creates a character string that contains all the required
* details of a file;( Name)
*
* History:
\***************************************************************************/

void LB_CreateLBLine(
    PWIN32_FIND_DATA pffd,
    LPWSTR lpBuffer)
{
    BYTE bAttribute;
    LPWSTR lpch;

    lpch = lpBuffer;

    bAttribute = (BYTE)pffd->dwFileAttributes;
    if (bAttribute & DDL_DIRECTORY)  /* Is it a directory */
        *lpch++ = TEXT('[');

    /*
     * Copy the file name
     *
     * If we are running from wow, check if the shortname exists
     */
    if (GetClientInfo()->dwTIFlags & TIF_16BIT) {
        UNICODE_STRING Name;
        BOOLEAN fSpace = FALSE;

        RtlInitUnicodeString(&Name, pffd->cFileName);
        if (RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) && !fSpace) {
            /*
             * Legal 8.3 name and no spaces, so use the principal
             * file name.
             */
            wcscpy(lpch, pffd->cFileName);
        } else {
            if (pffd->cAlternateFileName[0] == 0)
                wcscpy(lpch, pffd->cFileName);
            else
                /*
                 * Use the alternate file name.
                 */
                wcscpy(lpch, pffd->cAlternateFileName);
        }
        /*
         * Make filename lower-case for 16-bit apps.  Some Corel apps
         * require this.
         */
        CharLower(lpch);

    }
    else
       wcscpy(lpch, pffd->cFileName);

    lpch = (LPWSTR)(lpch + wcslen(lpch));

    if (bAttribute & DDL_DIRECTORY)  /* Is it a directory */
        *lpch++ = TEXT(']');

    *lpch = TEXT('\0');

#ifndef UNICODE
    OemToChar(lpBuffer, lpBuffer);
#endif

    *lpch = TEXT('\0');  /* Null terminate */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\lb1.c ===
/****************************** Module Header ********************************\
* Module Name: lb1.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* ListBox routines
*
* History:
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\*****************************************************************************/

#include "precomp.h"
#pragma hdrstop

LOOKASIDE ListboxLookaside;


/***************************************************************************\
* xxxLBoxCtlWndProc
*
* Window Procedure for ListBox AND ComboLBox control.
* NOTE: All window procedures are APIENTRY
* WARNING: This listbox code contains some internal messages and styles which
* are defined in combcom.h and in combcom.inc.  They may be redefined
* (or renumbered) as needed to extend the windows API.
*
* History:
* 16-Apr-1992 beng      Added LB_SETCOUNT
\***************************************************************************/

LRESULT APIENTRY ListBoxWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    PAINTSTRUCT ps;
    HDC         hdc;
    LPRECT      lprc;
    PLBIV plb;    /* List Box Instance Variable */
    INT iSel;     /* Index of selected item */
    DWORD dw;
    TL tlpwndParent;
    UINT wFlags;
    LPWSTR lpwsz = NULL;
    LRESULT lReturn = 0;
    static BOOL fInit = TRUE;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, FNID_LISTBOX);
    INITCONTROLLOOKASIDE(&ListboxLookaside, LBIV, spwnd, 4);

    /*
     * Get the plb for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,plb)
     * when the listbox was first created (by INITCONTROLLOOKASIDE above)
     */
    plb = ((PLBWND)pwnd)->pLBIV;

    /*
     * Handle ANSI translations of input parameters
     */
    if (fAnsi) {
        switch (message) {
        case LB_ADDSTRING:
        case LB_ADDSTRINGUPPER:
        case LB_ADDSTRINGLOWER:
        case LB_FINDSTRING:
        case LB_FINDSTRINGEXACT:
        case LB_INSERTSTRING:
        case LB_INSERTSTRINGUPPER:
        case LB_INSERTSTRINGLOWER:
        case LB_SELECTSTRING:
            if (!plb->fHasStrings) {
                break;
            }
            // Fall through...
        case LB_ADDFILE:
        case LB_DIR:
            if (lParam) {
                if (!MBToWCS((LPSTR)lParam, -1, &lpwsz, -1, TRUE))
                    return LB_ERR;
            }
            break;
        default:
            break;
        }
        if (lpwsz) {
            lParam = (LPARAM)lpwsz;
        }
    }

    switch (message) {

    case LB_GETTOPINDEX:        // Return index of top item displayed.
        return plb->iTop;

    case LB_SETTOPINDEX:
        if (wParam && ((INT)wParam < 0 || (INT)wParam >= plb->cMac)) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return LB_ERR;
        }
        if (plb->cMac) {
            xxxNewITop(plb, (INT)wParam);
        }
        break;

    case WM_STYLECHANGED:
        plb->fRtoLReading = (TestWF(pwnd, WEFRTLREADING) != 0);
        plb->fRightAlign  = (TestWF(pwnd, WEFRIGHT) != 0);
        xxxCheckRedraw(plb, FALSE, 0);
        break;

    case WM_WINDOWPOSCHANGED:

        /*
         * If we are in the middle of creation, ignore this
         * message because it will generate a WM_SIZE message.
         * See xxxLBCreate().
         */
        if (!plb->fIgnoreSizeMsg)
            goto CallDWP;
        break;

    case WM_SIZE:

        /*
         * If we are in the middle of creation, ignore size
         * messages.  See xxxLBCreate().
         */
        if (!plb->fIgnoreSizeMsg)
            xxxLBSize(plb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        break;

    case WM_ERASEBKGND:
        ThreadLock(plb->spwndParent, &tlpwndParent);
        FillWindow(HW(plb->spwndParent), hwnd, (HDC)wParam,
                (HBRUSH)CTLCOLOR_LISTBOX);
        ThreadUnlock(&tlpwndParent);
        return TRUE;

    case LB_RESETCONTENT:
        xxxLBResetContent(plb);
        break;

    case WM_TIMER:
        if (wParam == IDSYS_LBSEARCH) {
            plb->iTypeSearch = 0;
            NtUserKillTimer(hwnd, IDSYS_LBSEARCH);
            xxxInvertLBItem(plb, plb->iSel, TRUE);
            break;
        }

        message = WM_MOUSEMOVE;
        xxxTrackMouse(plb, message, plb->ptPrev);
        break;

        /*
         * Fall through
         */
    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
        {
            POINT pt;

            POINTSTOPOINT(pt, lParam);
            xxxTrackMouse(plb, message, pt);
        }
        break;

    case WM_MBUTTONDOWN:
        EnterReaderModeHelper(hwnd);
        break;

    case WM_CAPTURECHANGED:
            //
            // Note that this message should be handled only on unexpected
            // capture changes currently.
            //
        UserAssert(TestWF(pwnd, WFWIN40COMPAT));
        if (plb->fCaptured)
            xxxLBButtonUp(plb, LBUP_NOTIFY);
        break;

    case LBCB_STARTTRACK:
        //
        // Start tracking mouse moves in the listbox, setting capture
        //
        if (!plb->pcbox)
            break;

        plb->fCaptured = FALSE;
        if (wParam) {
            POINT pt;

            POINTSTOPOINT(pt, lParam);

            _ScreenToClient(pwnd, &pt);
            xxxTrackMouse(plb, WM_LBUTTONDOWN, pt);
        } else {
            NtUserSetCapture(hwnd);
            plb->fCaptured = TRUE;
            plb->iLastSelection = plb->iSel;
        }
        break;

    case LBCB_ENDTRACK:
        // Kill capture, tracking, etc.
        if (plb->fCaptured)
            xxxLBButtonUp(plb, LBUP_RELEASECAPTURE | (wParam ? LBUP_SELCHANGE :
                LBUP_RESETSELECTION));
        break;

    case WM_PRINTCLIENT:
        xxxLBPaint(plb, (HDC) wParam, NULL);
        break;

    case WM_PAINT:
        if (wParam) {
            hdc = (HDC) wParam;
            lprc = NULL;
        } else {
            hdc = NtUserBeginPaint(hwnd, &ps);
            lprc = &(ps.rcPaint);
        }

        if (IsLBoxVisible(plb))
            xxxLBPaint(plb, hdc, lprc);

        if (!wParam)
            NtUserEndPaint(hwnd, &ps);
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        xxxDestroyLBox(plb, pwnd);
        break;

    case WM_SETFOCUS:
// DISABLED in Win 3.1        xxxUpdateWindow(pwnd);
        CaretCreate(plb);
        xxxLBSetCaret(plb, TRUE);
        xxxNotifyOwner(plb, LBN_SETFOCUS);

        /*
         * We need to send this event even if the listbox isn't visible. See
         * bug #88548.
         */
         LBEvent(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);
        break;

    case WM_KILLFOCUS:
        /*
         * Reset the wheel delta count.
         */
        gcWheelDelta = 0;

        xxxLBSetCaret(plb, FALSE);
        xxxCaretDestroy(plb);
        xxxNotifyOwner(plb, LBN_KILLFOCUS);
        if (plb->iTypeSearch) {
            plb->iTypeSearch = 0;
            NtUserKillTimer(hwnd, IDSYS_LBSEARCH);
        }
        if (plb->pszTypeSearch) {
            UserLocalFree(plb->pszTypeSearch);
            plb->pszTypeSearch = NULL;
        }
        break;

    case WM_MOUSEWHEEL:
        {
            int     cDetants;
            int     cPage;
            int     cLines;
            RECT    rc;
            int     windowWidth;
            int     cPos;

            /*
             * Don't handle zoom and datazoom.
             */
            if (wParam & (MK_SHIFT | MK_CONTROL)) {
                goto CallDWP;
            }

            lReturn = 1;
            gcWheelDelta -= (short) HIWORD(wParam);
            cDetants = gcWheelDelta / WHEEL_DELTA;
            if (    cDetants != 0 &&
                    gpsi->ucWheelScrollLines > 0 &&
                    (pwnd->style & (WS_VSCROLL | WS_HSCROLL))) {

                gcWheelDelta = gcWheelDelta % WHEEL_DELTA;

                if (pwnd->style & WS_VSCROLL) {
                    cPage = max(1, (plb->cItemFullMax - 1));
                    cLines = cDetants *
                            (int) min((UINT) cPage, gpsi->ucWheelScrollLines);

                    cPos = max(0, min(plb->iTop + cLines, plb->cMac - 1));
                    if (cPos != plb->iTop) {
                        xxxLBoxCtlScroll(plb, SB_THUMBPOSITION, cPos);
                        xxxLBoxCtlScroll(plb, SB_ENDSCROLL, 0);
                    }
                } else if (plb->fMultiColumn) {
                    cPage = max(1, plb->numberOfColumns);
                    cLines = cDetants * (int) min((UINT) cPage, gpsi->ucWheelScrollLines);
                    cPos = max(
                            0,
                            min((plb->iTop / plb->itemsPerColumn) + cLines,
                                plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn)));

                    if (cPos != plb->iTop) {
                        xxxLBoxCtlHScrollMultiColumn(plb, SB_THUMBPOSITION, cPos);
                        xxxLBoxCtlHScrollMultiColumn(plb, SB_ENDSCROLL, 0);
                    }
                } else {
                    _GetClientRect(plb->spwnd, &rc);
                    windowWidth = rc.right;
                    cPage = max(plb->cxChar, (windowWidth / 3) * 2) /
                            plb->cxChar;

                    cLines = cDetants *
                            (int) min((UINT) cPage, gpsi->ucWheelScrollLines);

                    cPos = max(
                            0,
                            min(plb->xOrigin + (cLines * plb->cxChar),
                                plb->maxWidth));

                    if (cPos != plb->xOrigin) {
                        xxxLBoxCtlHScroll(plb, SB_THUMBPOSITION, cPos);
                        xxxLBoxCtlHScroll(plb, SB_ENDSCROLL, 0);
                    }
                }
            }
        }
        break;

    case WM_VSCROLL:
        xxxLBoxCtlScroll(plb, LOWORD(wParam), HIWORD(wParam));
        break;

    case WM_HSCROLL:
        xxxLBoxCtlHScroll(plb, LOWORD(wParam), HIWORD(wParam));
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTCHARS;

    case WM_CREATE:
        return xxxLBCreate(plb, pwnd, (LPCREATESTRUCT) lParam);

    case WM_SETREDRAW:

        /*
         * If wParam is nonzero, the redraw flag is set
         * If wParam is zero, the flag is cleared
         */
        xxxLBSetRedraw(plb, (wParam != 0));
        break;

    case WM_ENABLE:
        xxxLBInvalidateRect(plb, NULL, !plb->OwnerDraw);
        break;

    case WM_SETFONT:
        xxxLBSetFont(plb, (HANDLE)wParam, LOWORD(lParam));
        break;

    case WM_GETFONT:
        return (LRESULT)plb->hFont;

    case WM_DRAGSELECT:
    case WM_DRAGLOOP:
    case WM_DRAGMOVE:
    case WM_DROPFILES:
        ThreadLock(plb->spwndParent, &tlpwndParent);
        lReturn = SendMessage(HW(plb->spwndParent), message, wParam, lParam);
        ThreadUnlock(&tlpwndParent);
        return lReturn;


    case WM_QUERYDROPOBJECT:
    case WM_DROPOBJECT:

        /*
         * fix up control data, then pass message to parent
         */
        LBDropObjectHandler(plb, (PDROPSTRUCT)lParam);
        ThreadLock(plb->spwndParent, &tlpwndParent);
        lReturn = SendMessage(HW(plb->spwndParent), message, wParam, lParam);
        ThreadUnlock(&tlpwndParent);
        return lReturn;

    case LB_GETITEMRECT:
        return LBGetItemRect(plb, (INT)wParam, (LPRECT)lParam);

    case LB_GETITEMDATA:
        return LBGetItemData(plb, (INT)wParam);  // wParam = item index

    case LB_SETITEMDATA:

        /*
         * wParam is item index
         */
        return LBSetItemData(plb, (INT)wParam, lParam);

    case LB_ADDSTRINGUPPER:
        wFlags = UPPERCASE | LBI_ADD;
        goto CallInsertItem;

    case LB_ADDSTRINGLOWER:
        wFlags = LOWERCASE | LBI_ADD;
        goto CallInsertItem;

    case LB_ADDSTRING:
        wFlags = LBI_ADD;
        goto CallInsertItem;

    case LB_INSERTSTRINGUPPER:
        wFlags = UPPERCASE;
        goto CallInsertItem;

    case LB_INSERTSTRINGLOWER:
        wFlags = LOWERCASE;
        goto CallInsertItem;

    case LB_INSERTSTRING:
        wFlags = 0;
CallInsertItem:
        lReturn = ((LRESULT) xxxLBInsertItem(plb, (LPWSTR) lParam, (int) wParam, wFlags));
        break;

    case LB_INITSTORAGE:
        return xxxLBInitStorage(plb, fAnsi, (INT)wParam, (INT)lParam);

    case LB_DELETESTRING:
        return xxxLBoxCtlDelete(plb, (INT)wParam);

    case LB_DIR:
        /*
         * wParam - Dos attribute value.
         * lParam - Points to a file specification string
         */
        lReturn = xxxLbDir(plb, (INT)wParam, (LPWSTR)lParam);
        break;

    case LB_ADDFILE:
        lReturn = xxxLbInsertFile(plb, (LPWSTR)lParam);
        break;

    case LB_SETSEL:
        return xxxLBSetSel(plb, (wParam != 0), (INT)lParam);

    case LB_SETCURSEL:
        /*
         * If window obscured, update so invert will work correctly
         */
// DISABLED in Win 3.1        xxxUpdateWindow(pwnd);
        return xxxLBSetCurSel(plb, (INT)wParam);

    case LB_GETSEL:
        if (wParam >= (UINT) plb->cMac)
                return((LRESULT) LB_ERR);

        return IsSelected(plb, (INT)wParam, SELONLY);

    case LB_GETCURSEL:
        if (plb->wMultiple == SINGLESEL) {
            return plb->iSel;
        }
        return plb->iSelBase;

    case LB_SELITEMRANGE:
        if (plb->wMultiple == SINGLESEL) {
            /*
             * Can't select a range if only single selections are enabled
             */
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE,"Invalid index passed to LB_SELITEMRANGE");
            return LB_ERR;
        }

        xxxLBSelRange(plb, LOWORD(lParam), HIWORD(lParam), (wParam != 0));
        break;

    case LB_SELITEMRANGEEX:
        if (plb->wMultiple == SINGLESEL) {
            /*
             * Can't select a range if only single selections are enabled
             */
            RIPERR0(ERROR_INVALID_LB_MESSAGE, RIP_VERBOSE,"LB_SELITEMRANGEEX:Can't select a range if only single selections are enabled");
            return LB_ERR;
        } else {
            BOOL fHighlight = ((DWORD)lParam > (DWORD)wParam);
            if (fHighlight == FALSE) {
                ULONG_PTR temp = lParam;
                lParam = wParam;
                wParam = temp;
            }
            xxxLBSelRange(plb, (INT)wParam, (INT)lParam, fHighlight);
        }
        break;

    case LB_GETTEXTLEN:
        if (lParam != 0) {
            RIPMSG1(RIP_WARNING, "LB_GETTEXTLEN with lParam = %lx\n", lParam);
        }
        lReturn = LBGetText(plb, TRUE, fAnsi, (INT)wParam, NULL);
        break;

    case LB_GETTEXT:
        lReturn = LBGetText(plb, FALSE, fAnsi, (INT)wParam, (LPWSTR)lParam);
        break;

    case LB_GETCOUNT:
        // Lotus Approach calls CallWndProc(ListWndProc, LB_GETCOUNT,...)
        // on a window that doesn't have a plb yet. So, we need to make
        // this check. Bug #6675 - 11/7/94 --
        if(plb)
            return((LRESULT) plb->cMac);
        else
            return(0);

    case LB_SETCOUNT:
        return xxxLBSetCount(plb, (INT)wParam);

    case LB_SELECTSTRING:
    case LB_FINDSTRING:
        iSel = xxxFindString(plb, (LPWSTR)lParam, (INT)wParam, PREFIX, TRUE);
        if (message == LB_FINDSTRING || iSel == LB_ERR) {
            lReturn = iSel;
        } else {
            lReturn = xxxLBSetCurSel(plb, iSel);
        }
        break;

    case LB_GETLOCALE:
        return plb->dwLocaleId;

    case LB_SETLOCALE:

        /*
         * Validate locale
         */
        wParam = ConvertDefaultLocale((LCID)wParam);
        if (!IsValidLocale((LCID)wParam, LCID_INSTALLED))
            return LB_ERR;

        dw = plb->dwLocaleId;
        plb->dwLocaleId = (DWORD)wParam;
        return dw;

    case WM_KEYDOWN:

        /*
         * IanJa: Use LOWORD() to get low 16-bits of wParam - this should
         * work for Win16 & Win32.  The value obtained is the virtual key
         */
        xxxLBoxCtlKeyInput(plb, message, LOWORD(wParam));
        break;

    case WM_CHAR:
        xxxLBoxCtlCharInput(plb, LOWORD(wParam), fAnsi);
        break;

    case LB_GETSELITEMS:
    case LB_GETSELCOUNT:

        /*
         * IanJa/Win32 should this be LPWORD now?
         */
        return LBoxGetSelItems(plb, (message == LB_GETSELCOUNT), (INT)wParam,
                (LPINT)lParam);

    case LB_SETTABSTOPS:

        /*
         * IanJa/Win32: Tabs given by array of INT for backwards compatability
         */
        return LBSetTabStops(plb, (INT)wParam, (LPINT)lParam);

    case LB_GETHORIZONTALEXTENT:

        /*
         * Return the max width of the listbox used for horizontal scrolling
         */
        return plb->maxWidth;

    case LB_SETHORIZONTALEXTENT:

        /*
         * Set the max width of the listbox used for horizontal scrolling
         */
        if (plb->maxWidth != (INT)wParam) {
            plb->maxWidth = (INT)wParam;

            /*
             * When horizontal extent is set, Show/hide the scroll bars.
             * NOTE: LBShowHideScrollBars() takes care if Redraw is OFF.
             * Fix for Bug #2477 -- 01/14/91 -- SANKAR --
             */
            xxxLBShowHideScrollBars(plb); //Try to show or hide scroll bars
            if (plb->fHorzBar && plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw)) {
                /*
                 * origin to right
                 */
                xxxLBoxCtlHScroll(plb, SB_BOTTOM, 0);
            }
        }
        break;    /* originally returned register ax (message) ! */

    case LB_SETCOLUMNWIDTH:

        /*
         * Set the width of a column in a multicolumn listbox
         */
        plb->cxColumn = (INT)wParam;
        LBCalcItemRowsAndColumns(plb);
        if (IsLBoxVisible(plb))
            NtUserInvalidateRect(hwnd, NULL, TRUE);
        xxxLBShowHideScrollBars(plb);
        break;

    case LB_SETANCHORINDEX:
        if ((INT)wParam >= plb->cMac) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE,"Invalid index passed to LB_SETANCHORINDEX");
            return LB_ERR;
        }
        plb->iMouseDown = (INT)wParam;
        plb->iLastMouseMove = (INT)wParam;
        xxxInsureVisible(plb, (int) wParam, (BOOL)(lParam != 0));
        break;

    case LB_GETANCHORINDEX:
        return plb->iMouseDown;

    case LB_SETCARETINDEX:
        if ( (plb->iSel == -1) || ((plb->wMultiple != SINGLESEL) &&
                    (plb->cMac > (INT)wParam))) {

            /*
             * Set's the iSelBase to the wParam
             * if lParam, then don't scroll if partially visible
             * else scroll into view if not fully visible
             */
            xxxInsureVisible(plb, (INT)wParam, (BOOL)LOWORD(lParam));
            xxxSetISelBase(plb, (INT)wParam);
            break;
        } else {
            if ((INT)wParam >= plb->cMac) {
                RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE,"Invalid index passed to LB_SETCARETINDEX");
            }
            return LB_ERR;
        }
        break;

    case LB_GETCARETINDEX:
        return plb->iSelBase;

    case LB_SETITEMHEIGHT:
    case LB_GETITEMHEIGHT:
        return LBGetSetItemHeightHandler(plb, message, (INT)wParam, LOWORD(lParam));
        break;

    case LB_FINDSTRINGEXACT:
        lReturn = xxxFindString(plb, (LPWSTR)lParam, (INT)wParam, EQ, TRUE);
        break;

    case LB_ITEMFROMPOINT: {
        POINT pt;
        BOOL bOutside;
        DWORD dwItem;

        POINTSTOPOINT(pt, lParam);
        bOutside = ISelFromPt(plb, pt, &dwItem);
        UserAssert(bOutside == 1 || bOutside == 0);
        return (LRESULT)MAKELONG(dwItem, bOutside);
    }

    case LBCB_CARETON:

        /*
         * Internal message for combo box support
         */
        CaretCreate(plb);
        // Set up the caret in the proper location for drop downs.
        plb->iSelBase = plb->iSel;
        xxxLBSetCaret(plb, TRUE);
            
        /*
         * We need to send this event even if the listbox isn't visible. See
         * bug #88548.  Also see 355612.
         */
        if (_IsWindowVisible(pwnd) || (GetFocus() == hwnd)) {
            LBEvent(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);
        }

        return(plb->iSel);

    case LBCB_CARETOFF:

        /*
         * Internal message for combo box support
         */
        xxxLBSetCaret(plb, FALSE);
        xxxCaretDestroy(plb);
        break;

    case LB_GETLISTBOXINFO:
       return NtUserGetListBoxInfo(hwnd);

    case WM_NCCREATE:
        if ((pwnd->style & LBS_MULTICOLUMN) && (pwnd->style & WS_VSCROLL))
        {
            DWORD mask = WS_VSCROLL;
            DWORD flags = 0;
            if (!TestWF(pwnd, WFWIN40COMPAT)) {
                mask |= WS_HSCROLL;
                flags = WS_HSCROLL;
            }
            NtUserAlterWindowStyle(hwnd, mask, flags);
        }
        goto CallDWP;

     default:
CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }

    /*
     * Handle translation of ANSI output data and free buffer
     */
    if (lpwsz) {
        UserLocalFree(lpwsz);
    }

    return lReturn;
}


/***************************************************************************\
\***************************************************************************/

LRESULT WINAPI ListBoxWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_LISTBOX))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, TRUE);

    return ListBoxWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI ListBoxWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_LISTBOX))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, FALSE);

    return ListBoxWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}

LRESULT WINAPI ComboListBoxWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_LISTBOX))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, TRUE);

    return ListBoxWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI ComboListBoxWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_LISTBOX))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, FALSE);

    return ListBoxWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}


/***************************************************************************\
* GetLpszItem
*
* Returns a far pointer to the string belonging to item sItem
* ONLY for Listboxes maintaining their own strings (pLBIV->fHasStrings == TRUE)
*
* History:
\***************************************************************************/

LPWSTR GetLpszItem(
    PLBIV pLBIV,
    INT sItem)
{
    LONG offsz;
    lpLBItem plbi;

    if (sItem < 0 || sItem >= pLBIV->cMac) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"sItem\" (%ld) to GetLpszItem",
                sItem);

        return NULL;
    }

    /*
     * get pointer to item index array
     * NOTE: NOT OWNERDRAW
     */
    plbi = (lpLBItem)(pLBIV->rgpch);
    offsz = plbi[sItem].offsz;
    return (LPWSTR)((PBYTE)(pLBIV->hStrings) + offsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\lboxctl2.c ===
/***************************************************************************\
*
*  LBOXCTL2.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      List box handling routines
*
* 18-Dec-1990 ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define LB_KEYDOWN WM_USER+1
#define NOMODIFIER  0  /* No modifier is down */
#define SHIFTDOWN   1  /* Shift alone */
#define CTLDOWN     2  /* Ctl alone */
#define SHCTLDOWN   (SHIFTDOWN + CTLDOWN)  /* Ctrl + Shift */

/*
 * Variables for incremental type search support
 */
#define MAX_TYPESEARCH  256

BOOL LBGetDC(PLBIV plb);
void LBReleaseDC(PLBIV plb);

/***************************************************************************\
*
*  LBInvalidateRect()
*
*  If the listbox is visible, invalidates a rectangle in the listbox.
*  If the listbox is not visible, sets the defer update flag for the listbox
*
\***************************************************************************/
BOOL xxxLBInvalidateRect(PLBIV plb, LPRECT lprc, BOOL fErase)
{
    CheckLock(plb->spwnd);

    if (IsLBoxVisible(plb)) {
        NtUserInvalidateRect(HWq(plb->spwnd), lprc, fErase);
        return(TRUE);
    }

    if (!plb->fRedraw)
        plb->fDeferUpdate = TRUE;

    return(FALSE);
}

/***************************************************************************\
*
*  LBGetBrush()
*
*  Gets background brush & colors for listbox.
*
\***************************************************************************/
HBRUSH xxxLBGetBrush(PLBIV plb, HBRUSH *phbrOld)
{
    HBRUSH  hbr;
    HBRUSH  hbrOld;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    SetBkMode(plb->hdc, OPAQUE);

    //
    // Get brush & colors
    //
    if ((plb->spwnd->spwndParent == NULL) ||
        (REBASEPWND(plb->spwnd, spwndParent) == _GetDesktopWindow())) {
        ThreadLock(plb->spwndParent, &tlpwndParent);
        hbr = GetControlColor(HW(plb->spwndParent), HWq(plb->spwnd),
                              plb->hdc, WM_CTLCOLORLISTBOX);
        ThreadUnlock(&tlpwndParent);
    } else
        hbr = GetControlBrush(HWq(plb->spwnd), plb->hdc, WM_CTLCOLORLISTBOX);

    //
    // Select brush into dc
    //
    if (hbr != NULL) {
        hbrOld = SelectObject(plb->hdc, hbr);
        if (phbrOld)
            *phbrOld = hbrOld;
    }

    return(hbr);
}


/***************************************************************************\
*
*  LBInitDC()
*
*  Initializes dc for listbox
*
\***************************************************************************/
void LBInitDC(PLBIV plb)
{
    RECT    rc;

    // Set font
    if (plb->hFont)
        SelectObject(plb->hdc, plb->hFont);

    // Set clipping area
    _GetClientRect(plb->spwnd, &rc);
    IntersectClipRect(plb->hdc, rc.left, rc.top, rc.right, rc.bottom);

    OffsetWindowOrgEx(plb->hdc, plb->xOrigin, 0, NULL);
}


/***************************************************************************\
* LBGetDC
*
* Returns a DC which can be used by a list box even if parentDC is in effect
*
* History:
\***************************************************************************/

BOOL LBGetDC(
    PLBIV plb)
{
    if (plb->hdc)
        return(FALSE);

    plb->hdc = NtUserGetDC(HWq(plb->spwnd));

    LBInitDC(plb);

    return TRUE;
}

/***************************************************************************\
*
*  LBTermDC()
*
*  Cleans up when done with listbox dc.
*
\***************************************************************************/
void LBTermDC(PLBIV plb)
{
    if (plb->hFont)
        SelectObject(plb->hdc, ghFontSys);
}



/***************************************************************************\
* LBReleaseDC
*
* History:
\***************************************************************************/

void LBReleaseDC(
    PLBIV plb)
{
    LBTermDC(plb);
    NtUserReleaseDC(HWq(plb->spwnd), plb->hdc);
    plb->hdc = NULL;
}


/***************************************************************************\
* LBGetItemRect
*
* Return the rectangle that the item will be drawn in with respect to the
* listbox window.  Returns TRUE if any portion of the item's rectangle
* is visible (ie. in the listbox client rect) else returns FALSE.
*
* History:
\***************************************************************************/

BOOL LBGetItemRect(
    PLBIV plb,
    INT sItem,
    LPRECT lprc)
{
    INT sTmp;
    int clientbottom;

    /*
     * Always allow an item number of 0 so that we can draw the caret which
     * indicates the listbox has the focus even though it is empty.

     * FreeHand 3.1 passes in -1 as the itemNumber and expects
     * a non-null rectangle. So we check for -1 specifically.
     * BUGTAG: Fix for Bug #540 --Win95B-- SANKAR -- 2/20/95 --
     */

    if (sItem && (sItem != -1) && ((UINT)sItem >= (UINT)plb->cMac))
    {
        SetRectEmpty(lprc);
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return (LB_ERR);
    }

    _GetClientRect(plb->spwnd, lprc);

    if (plb->fMultiColumn) {

        /*
         * itemHeight * sItem mod number ItemsPerColumn (itemsPerColumn)
         */
        lprc->top = plb->cyChar * (sItem % plb->itemsPerColumn);
        lprc->bottom = lprc->top + plb->cyChar  /*+(plb->OwnerDraw ? 0 : 1)*/;

        UserAssert(plb->itemsPerColumn);

        if (plb->fRightAlign) {
            lprc->right = lprc->right - plb->cxColumn *
                 ((sItem / plb->itemsPerColumn) - (plb->iTop / plb->itemsPerColumn));

            lprc->left = lprc->right - plb->cxColumn;
        } else {
            /*
             * Remember, this is integer division here...
             */
            lprc->left += plb->cxColumn *
                      ((sItem / plb->itemsPerColumn) - (plb->iTop / plb->itemsPerColumn));

            lprc->right = lprc->left + plb->cxColumn;
        }
    } else if (plb->OwnerDraw == OWNERDRAWVAR) {

        /*
         * Var height owner draw
         */
        lprc->right += plb->xOrigin;
        clientbottom = lprc->bottom;

        if (sItem >= plb->iTop) {
            for (sTmp = plb->iTop; sTmp < sItem; sTmp++) {
                lprc->top = lprc->top + LBGetVariableHeightItemHeight(plb, sTmp);
            }

            /*
             * If item number is 0, it may be we are asking for the rect
             * associated with a nonexistant item so that we can draw a caret
             * indicating focus on an empty listbox.
             */
            lprc->bottom = lprc->top + (sItem < plb->cMac ? LBGetVariableHeightItemHeight(plb, sItem) : plb->cyChar);
            return (lprc->top < clientbottom);
        } else {

            /*
             * Item we want the rect of is before plb->iTop.  Thus, negative
             * offsets for the rect and it is never visible.
             */
            for (sTmp = sItem; sTmp < plb->iTop; sTmp++) {
                lprc->top = lprc->top - LBGetVariableHeightItemHeight(plb, sTmp);
            }
            lprc->bottom = lprc->top + LBGetVariableHeightItemHeight(plb, sItem);
            return FALSE;
        }
    } else {

        /*
         * For fixed height listboxes
         */
        if (plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw) && plb->fHorzBar)
            lprc->right += plb->xOrigin + (plb->xRightOrigin - plb->xOrigin);
        else
            lprc->right += plb->xOrigin;
        lprc->top = (sItem - plb->iTop) * plb->cyChar;
        lprc->bottom = lprc->top + plb->cyChar;
    }

    return (sItem >= plb->iTop) &&
            (sItem < (plb->iTop + CItemInWindow(plb, TRUE)));
}


/***************************************************************************\
*
*  LBPrintCallback
*
*  Called back from DrawState()
*
\***************************************************************************/
BOOL CALLBACK LBPrintCallback(
    HDC hdc,
    LPARAM lData,
    WPARAM wData,
    int cx,
    int cy)
{
    LPWSTR  lpstr = (LPWSTR)lData;
    PLBIV   plb = (PLBIV)wData;
    int     xStart;
    UINT    cLen;
    RECT    rc;
    UINT    oldAlign;

    if (!lpstr) {
        return FALSE;
    }

    if (plb->fMultiColumn)
        xStart = 0;
    else
        xStart = 2;

    if (plb->fRightAlign) {
        oldAlign = SetTextAlign(hdc, TA_RIGHT | GetTextAlign(hdc));
        xStart = cx - xStart;
    }

    cLen = wcslen(lpstr);

    if (plb->fUseTabStops) {
        TabTextOut(hdc, xStart, 0, lpstr, cLen,
            (plb->iTabPixelPositions ? plb->iTabPixelPositions[0] : 0),
            (plb->iTabPixelPositions ? (LPINT)&plb->iTabPixelPositions[1] : NULL),
            plb->fRightAlign ? cx : 0, TRUE, GetTextCharset(plb->hdc));
    } else {
        rc.left     = 0;
        rc.top      = 0;
        rc.right    = cx;
        rc.bottom   = cy;

        if (plb->wMultiple)
            ExtTextOut(hdc, xStart, 0, ETO_OPAQUE, &rc, lpstr, cLen, NULL);
        else if (plb->fMultiColumn)
            ExtTextOut(hdc, xStart, 0, ETO_CLIPPED, &rc, lpstr, cLen, NULL);
        else {
            ExtTextOut(hdc, xStart, 0, 0, NULL, lpstr, cLen, NULL);

            /*
             * When the listbox is in the incremental search mode and the item
             * is highlighted (so we only draw in the current item), draw the
             * caret for search indication.
             */
            if ((plb->iTypeSearch != 0) && (plb->OwnerDraw == 0) &&
                    (GetBkColor(hdc) == SYSRGB(HIGHLIGHT))) {
                SIZE size;
                GetTextExtentPointW(hdc, lpstr, plb->iTypeSearch, &size);
                PatBlt(hdc, xStart + size.cx - 1, 1, 1, cy - 2, DSTINVERT);
            }
        }
    }

    if (plb->fRightAlign)
        SetTextAlign(hdc, oldAlign);

    return(TRUE);
}


/***************************************************************************\
* xxxLBDrawLBItem
*
* History:
\***************************************************************************/

void xxxLBDrawLBItem(
    PLBIV plb,
    INT sItem,
    LPRECT lprect,
    BOOL fHilite,
    HBRUSH hbr)
{
    LPWSTR lpstr;
    DWORD rgbSave;
    DWORD rgbBkSave;
    UINT    uFlags;
    HDC     hdc = plb->hdc;
    UINT  oldAlign;

    CheckLock(plb->spwnd);

    /*
     * If the item is selected, then fill with highlight color
     */
    if (fHilite) {
        FillRect(hdc, lprect, SYSHBR(HIGHLIGHT));
        rgbBkSave = SetBkColor(hdc, SYSRGB(HIGHLIGHT));
        rgbSave = SetTextColor(hdc, SYSRGB(HIGHLIGHTTEXT));
    } else {

        /*
         * If fUseTabStops, we must fill the background, because later we use
         * LBTabTheTextOutForWimps(), which fills the background only partially
         * Fix for Bug #1509 -- 01/25/91 -- SANKAR --
         */
        if ((hbr != NULL) && ((sItem == plb->iSelBase) || (plb->fUseTabStops))) {
            FillRect(hdc, lprect, hbr);
        }
    }

    uFlags = DST_COMPLEX;
    lpstr = GetLpszItem(plb, sItem);

    if (TestWF(plb->spwnd, WFDISABLED)) {
        if ((COLORREF)SYSRGB(GRAYTEXT) != GetBkColor(hdc))
            SetTextColor(hdc, SYSRGB(GRAYTEXT));
        else
            uFlags |= DSS_UNION;
    }

    if (plb->fRightAlign)
        uFlags |= DSS_RIGHT;

    if (plb->fRtoLReading)
        oldAlign = SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));

    DrawState(hdc, SYSHBR(WINDOWTEXT),
        LBPrintCallback,
        (LPARAM)lpstr,
        (WPARAM)plb,
        lprect->left,
        lprect->top,
        lprect->right-lprect->left,
        lprect->bottom-lprect->top,
        uFlags);

    if (plb->fRtoLReading)
        SetTextAlign(hdc, oldAlign);

    if (fHilite) {
        SetTextColor(hdc, rgbSave);
        SetBkColor(hdc, rgbBkSave);
    }
}


/***************************************************************************\
*
* LBSetCaret()
*
\***************************************************************************/
void xxxLBSetCaret(PLBIV plb, BOOL fSetCaret)
{
    RECT    rc;
    BOOL    fNewDC;

    if (plb->fCaret && ((BOOL) plb->fCaretOn != !!fSetCaret)) {
        if (IsLBoxVisible(plb)) {
            /* Turn the caret (located at plb->iSelBase) on */
            fNewDC = LBGetDC(plb);

            LBGetItemRect(plb, plb->iSelBase, &rc);

            if (fNewDC) {
                SetBkColor(plb->hdc, SYSRGB(WINDOW));
                SetTextColor(plb->hdc, SYSRGB(WINDOWTEXT));
            }

            if (plb->OwnerDraw) {
                /* Fill in the drawitem struct */
                UINT itemState = (fSetCaret) ? ODS_FOCUS : 0;

                if (IsSelected(plb, plb->iSelBase, HILITEONLY))
                    itemState |= ODS_SELECTED;

                xxxLBoxDrawItem(plb, plb->iSelBase, ODA_FOCUS, itemState, &rc);
            } else if (!TestWF(plb->spwnd, WEFPUIFOCUSHIDDEN)) {
                COLORREF crBk = SetBkColor(plb->hdc, SYSRGB(WINDOW));
                COLORREF crText = SetTextColor(plb->hdc, SYSRGB(WINDOWTEXT));

                DrawFocusRect(plb->hdc, &rc);

                SetBkColor(plb->hdc, crBk);
                SetTextColor(plb->hdc, crText);
            }

            if (fNewDC)
                LBReleaseDC(plb);
        }
        plb->fCaretOn = !!fSetCaret;
    }
}


/***************************************************************************\
* IsSelected
*
* History:
* 16-Apr-1992 beng      The NODATA listbox case
\***************************************************************************/

BOOL IsSelected(
    PLBIV plb,
    INT sItem,
    UINT wOpFlags)
{
    LPBYTE lp;

    if ((sItem >= plb->cMac) || (sItem < 0)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
//        return LB_ERR;
        return(FALSE);
    }

    if (plb->wMultiple == SINGLESEL) {
        return (sItem == plb->iSel);
    }

    lp = plb->rgpch + sItem +
             (plb->cMac * (plb->fHasStrings
                                ? sizeof(LBItem)
                                : (plb->fHasData
                                    ? sizeof(LBODItem)
                                    : 0)));
    sItem = *lp;

    if (wOpFlags == HILITEONLY) {
        sItem >>= 4;
    } else {
        sItem &= 0x0F;  /* SELONLY */
    }

    return sItem;
}


/***************************************************************************\
* CItemInWindow
*
* Returns the number of items which can fit in a list box.  It
* includes the partially visible one at the bottom if fPartial is TRUE. For
* var height ownerdraw, return the number of items visible starting at iTop
* and going to the bottom of the client rect.
*
* History:
\***************************************************************************/

INT CItemInWindow(
    PLBIV plb,
    BOOL fPartial)
{
    RECT rect;

    if (plb->OwnerDraw == OWNERDRAWVAR) {
        return CItemInWindowVarOwnerDraw(plb, fPartial);
    }

    if (plb->fMultiColumn) {
        return plb->itemsPerColumn * (plb->numberOfColumns + (fPartial ? 1 : 0));
    }

    _GetClientRect(plb->spwnd, &rect);

    /*
     * fPartial must be considered only if the listbox height is not an
     * integral multiple of character height.
     * A part of the fix for Bug #3727 -- 01/14/91 -- SANKAR --
     */
    UserAssert(plb->cyChar);
    return (INT)((rect.bottom / plb->cyChar) +
            ((rect.bottom % plb->cyChar)? (fPartial ? 1 : 0) : 0));
}


/***************************************************************************\
* xxxLBoxCtlScroll
*
* Handles vertical scrolling of the listbox
*
* History:
\***************************************************************************/

void xxxLBoxCtlScroll(
    PLBIV plb,
    INT cmd,
    int yAmt)
{
    INT iTopNew;
    INT cItemPageScroll;
    DWORD dwTime = 0;

    CheckLock(plb->spwnd);

    if (plb->fMultiColumn) {

        /*
         * Don't allow vertical scrolling on a multicolumn list box.  Needed
         * in case app sends WM_VSCROLL messages to the listbox.
         */
        return;
    }

    cItemPageScroll = plb->cItemFullMax;

    if (cItemPageScroll > 1)
        cItemPageScroll--;

    if (plb->cMac) {
        iTopNew = plb->iTop;
        switch (cmd) {
        case SB_LINEUP:
            dwTime = yAmt;
            iTopNew--;
            break;

        case SB_LINEDOWN:
            dwTime = yAmt;
            iTopNew++;
            break;

        case SB_PAGEUP:
            if (plb->OwnerDraw == OWNERDRAWVAR) {
                iTopNew = LBPage(plb, plb->iTop, FALSE);
            } else {
                iTopNew -= cItemPageScroll;
            }
            break;

        case SB_PAGEDOWN:
            if (plb->OwnerDraw == OWNERDRAWVAR) {
                iTopNew = LBPage(plb, plb->iTop, TRUE);
            } else {
                iTopNew += cItemPageScroll;
            }
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION: {

            /*
             * If the listbox contains more than 0xFFFF items
             * it means that the scrolbar can return a position
             * that cannot fit in a WORD (16 bits), so use
             * GetScrollInfo (which is slower) in this case.
             */
            if (plb->cMac < 0xFFFF) {
                iTopNew = yAmt;
            } else {
                SCROLLINFO si;

                si.cbSize   = sizeof(SCROLLINFO);
                si.fMask    = SIF_TRACKPOS;

                GetScrollInfo( HWq(plb->spwnd), SB_VERT, &si);

                iTopNew = si.nTrackPos;
            }
            break;
        }
        case SB_TOP:
            iTopNew = 0;
            break;

        case SB_BOTTOM:
            iTopNew = plb->cMac - 1;
            break;

        case SB_ENDSCROLL:
            plb->fSmoothScroll = TRUE;
            xxxLBSetCaret(plb, FALSE);
            xxxLBShowHideScrollBars(plb);
            xxxLBSetCaret(plb, TRUE);
            return;
        }

        xxxNewITopEx(plb, iTopNew, dwTime);
    }
}

/***************************************************************************\
* LBGetScrollFlags
*
\***************************************************************************/

DWORD LBGetScrollFlags(PLBIV plb, DWORD dwTime)
{
    DWORD dwFlags;

    if (GetAppCompatFlags(NULL) & GACF_NOSMOOTHSCROLLING)
        goto NoSmoothScrolling;

    if (dwTime != 0) {
        dwFlags = MAKELONG(SW_SCROLLWINDOW | SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime);
    } else if (TEST_EffectPUSIF(PUSIF_LISTBOXSMOOTHSCROLLING) && plb->fSmoothScroll) {
        dwFlags = SW_SCROLLWINDOW | SW_SMOOTHSCROLL | SW_SCROLLCHILDREN;
        plb->fSmoothScroll = FALSE;
    } else {
NoSmoothScrolling:
        dwFlags = SW_SCROLLWINDOW | SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN;
    }

    return dwFlags;
}

/***************************************************************************\
* xxxLBoxCtlHScroll
*
* Supports horizontal scrolling of listboxes
*
* History:
\***************************************************************************/

void xxxLBoxCtlHScroll(
    PLBIV plb,
    INT cmd,
    int xAmt)
{
    int newOrigin = plb->xOrigin;
    int oldOrigin = plb->xOrigin;
    int windowWidth;
    RECT rc;
    DWORD dwTime = 0;

    CheckLock(plb->spwnd);

    /*
     * Update the window so that we don't run into problems with invalid
     * regions during the horizontal scroll.
     */
    if (plb->fMultiColumn) {

        /*
         * Handle multicolumn scrolling in a separate segment
         */
        xxxLBoxCtlHScrollMultiColumn(plb, cmd, xAmt);
        return;
    }

    _GetClientRect(plb->spwnd, &rc);
    windowWidth = rc.right;

    if (plb->cMac) {

        switch (cmd) {
        case SB_LINEUP:
            dwTime = xAmt;
            newOrigin -= plb->cxChar;
            break;

        case SB_LINEDOWN:
            dwTime = xAmt;
            newOrigin += plb->cxChar;
            break;

        case SB_PAGEUP:
            newOrigin -= (windowWidth / 3) * 2;
            break;

        case SB_PAGEDOWN:
            newOrigin += (windowWidth / 3) * 2;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            newOrigin = xAmt;
            break;

        case SB_TOP:
            newOrigin = 0;
            break;

        case SB_BOTTOM:
            newOrigin = plb->maxWidth;
            break;

        case SB_ENDSCROLL:
            plb->fSmoothScroll = TRUE;
            xxxLBSetCaret(plb, FALSE);
            xxxLBShowHideScrollBars(plb);
            xxxLBSetCaret(plb, TRUE);
            return;
        }

        xxxLBSetCaret(plb, FALSE);
        plb->xOrigin = newOrigin;
        plb->xOrigin = xxxSetLBScrollParms(plb, SB_HORZ);

        if ((cmd == SB_BOTTOM) && plb->fRightAlign) {
            /*
             * so we know where to draw from.
             */
            plb->xRightOrigin = plb->xOrigin;
        }

        if(oldOrigin != plb->xOrigin)  {
            HWND hwnd = HWq(plb->spwnd);
            DWORD dwFlags;

            dwFlags = LBGetScrollFlags(plb, dwTime);
            ScrollWindowEx(hwnd, oldOrigin-plb->xOrigin,
                0, NULL, &rc, NULL, NULL, dwFlags);
            UpdateWindow(hwnd);
        }

        xxxLBSetCaret(plb, TRUE);
    } else {
        // this is a less-than-ideal fix for ImageMind ScreenSaver (Win95
        // B#8252) but it works and it doesn't hurt anybody -- JEFFBOG 10/28/94
        xxxSetLBScrollParms(plb, SB_HORZ);
    }
}


/***************************************************************************\
* xxxLBoxCtlPaint
*
* History:
\***************************************************************************/

void xxxLBPaint(
    PLBIV plb,
    HDC hdc,
    LPRECT lprcBounds)
{
    INT i;
    RECT rect;
    RECT    scratchRect;
    BOOL    fHilite;
    INT iLastItem;
    HBRUSH hbrSave = NULL;
    HBRUSH hbrControl;
    BOOL fCaretOn;
    RECT    rcBounds;
    HDC     hdcSave;

    CheckLock(plb->spwnd);

    if (lprcBounds == NULL) {
        lprcBounds = &rcBounds;
        _GetClientRect(plb->spwnd, lprcBounds);
    }

    hdcSave = plb->hdc;
    plb->hdc = hdc;

    // Initialize dc.
    LBInitDC(plb);

    // Turn caret off
    if (fCaretOn = plb->fCaretOn)
        xxxLBSetCaret(plb, FALSE);

    hbrSave = NULL;
    hbrControl = xxxLBGetBrush(plb, &hbrSave);

    // Get listbox's client
    _GetClientRect(plb->spwnd, &rect);

    // Adjust width of client rect for scrolled amount
    // fix for #140, t-arthb
    if (plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw) && plb->fHorzBar)
        rect.right += plb->xOrigin + (plb->xRightOrigin - plb->xOrigin);
    else
        rect.right += plb->xOrigin;

    // Get the index of the last item visible on the screen. This is also
    // valid for var height ownerdraw.
    iLastItem = plb->iTop + CItemInWindow(plb,TRUE);
    iLastItem = min(iLastItem, plb->cMac - 1);

    // Fill in the background of the listbox if it's an empty listbox
    // or if we're doing a control print
    if (iLastItem == -1)
        FillRect(plb->hdc, &rect, hbrControl);


    // Allow AnimateWindow() catch the apps that do not use our DC when
    // drawing the list box
    SetBoundsRect(plb->hdc, NULL, DCB_RESET | DCB_ENABLE);

    for (i = plb->iTop; i <= iLastItem; i++) {

        /*
         * Note that rect contains the clientrect from when we did the
         * _GetClientRect so the width is correct.  We just need to adjust
         * the top and bottom of the rectangle to the item of interest.
         */
        rect.bottom = rect.top + plb->cyChar;

        if ((UINT)i < (UINT)plb->cMac) {

            /*
             * If var height, get the rectangle for the item.
             */
            if (plb->OwnerDraw == OWNERDRAWVAR || plb->fMultiColumn) {
                LBGetItemRect(plb, i, &rect);
            }

            if (IntersectRect(&scratchRect, lprcBounds, &rect)) {
                fHilite = !plb->fNoSel && IsSelected(plb, i, HILITEONLY);

                if (plb->OwnerDraw) {

                    /*
                     * Fill in the drawitem struct
                     */
                    xxxLBoxDrawItem(plb, i, ODA_DRAWENTIRE,
                            (UINT)(fHilite ? ODS_SELECTED : 0), &rect);
                } else {
                    xxxLBDrawLBItem(plb, i, &rect, fHilite, hbrControl);
                }
            }
        }
        rect.top = rect.bottom;
    }

    if (hbrSave != NULL)
        SelectObject(hdc, hbrSave);

    if (fCaretOn)
        xxxLBSetCaret(plb, TRUE);

    LBTermDC(plb);

    plb->hdc = hdcSave;
}


/***************************************************************************\
* ISelFromPt
*
* In the loword, returns the closest item number the pt is on. The high
* word is 0 if the point is within bounds of the listbox client rect and is
* 1 if it is outside the bounds.  This will allow us to make the invertrect
* disappear if the mouse is outside the listbox yet we can still show the
* outline around the item that would be selected if the mouse is brought back
* in bounds...
*
* History:
\***************************************************************************/

BOOL ISelFromPt(
    PLBIV plb,
    POINT pt,
    LPDWORD piItem)
{
    RECT rect;
    int y;
    UINT mouseHighWord = 0;
    INT sItem;
    INT sTmp;

    _GetClientRect(plb->spwnd, &rect);

    if (pt.y < 0) {

        /*
         * Mouse is out of bounds above listbox
         */
        *piItem = plb->iTop;
        return TRUE;
    } else if ((y = pt.y) > rect.bottom) {
        y = rect.bottom;
        mouseHighWord = 1;
    }

    if (pt.x < 0 || pt.x > rect.right)
        mouseHighWord = 1;

    /*
     * Now just need to check if y mouse coordinate intersects item's rectangle
     */
    if (plb->OwnerDraw != OWNERDRAWVAR) {
        if (plb->fMultiColumn) {
            if (y < plb->itemsPerColumn * plb->cyChar) {
                if (plb->fRightAlign)
                    sItem = plb->iTop + (INT)((y / plb->cyChar) +
                            ((rect.right - pt.x) / plb->cxColumn) * plb->itemsPerColumn);
                else
                    sItem = plb->iTop + (INT)((y / plb->cyChar) +
                            (pt.x / plb->cxColumn) * plb->itemsPerColumn);

            } else {

                /*
                 * User clicked in blank space at the bottom of a column.
                 * Just select the last item in the column.
                 */
                mouseHighWord = 1;
                sItem = plb->iTop + (plb->itemsPerColumn - 1) +
                        (INT)((pt.x / plb->cxColumn) * plb->itemsPerColumn);
            }
        } else {
            sItem = plb->iTop + (INT)(y / plb->cyChar);
        }
    } else {

        /*
         * VarHeightOwnerdraw so we gotta do this the hardway...   Set the x
         * coordinate of the mouse down point to be inside the listbox client
         * rectangle since we no longer care about it.  This lets us use the
         * point in rect calls.
         */
        pt.x = 8;
        pt.y = y;
        for (sTmp = plb->iTop; sTmp < plb->cMac; sTmp++) {
            (void)LBGetItemRect(plb, sTmp, &rect);
            if (PtInRect(&rect, pt)) {
                *piItem = sTmp;
                return mouseHighWord;
            }
        }

        /*
         * Point was at the empty area at the bottom of a not full listbox
         */
        *piItem = plb->cMac - 1;
        return mouseHighWord;
    }

    /*
     * Check if user clicked on the blank area at the bottom of a not full list.
     * Assumes > 0 items in the listbox.
     */
    if (sItem > plb->cMac - 1) {
        mouseHighWord = 1;
        sItem = plb->cMac - 1;
    }

    *piItem = sItem;
    return mouseHighWord;
}


/***************************************************************************\
* SetSelected
*
* This is used for button initiated changes of selection state.
*
*  fSelected : TRUE  if the item is to be set as selected, FALSE otherwise
*
*  wOpFlags : HILITEONLY = Modify only the Display state (hi-nibble)
*             SELONLY    = Modify only the Selection state (lo-nibble)
*             HILITEANDSEL = Modify both of them;
*
* History:
* 16-Apr-1992 beng      The NODATA listbox case
\***************************************************************************/

void SetSelected(
    PLBIV plb,
    INT iSel,
    BOOL fSelected,
    UINT wOpFlags)
{
    LPSTR lp;
    BYTE cMask;
    BYTE cSelStatus;

    if (iSel < 0 || iSel >= plb->cMac)
        return;

    if (plb->wMultiple == SINGLESEL) {
        if (fSelected)
            plb->iSel = iSel;
    } else {
        cSelStatus = (BYTE)fSelected;
        switch (wOpFlags) {
        case HILITEONLY:

            /*
             * Mask out lo-nibble
             */
            cSelStatus = (BYTE)(cSelStatus << 4);
            cMask = 0x0F;
            break;
        case SELONLY:

            /*
             * Mask out hi-nibble
             */
            cMask = 0xF0;
            break;
        case HILITEANDSEL:

            /*
             * Mask the byte fully
             */
            cSelStatus |= (cSelStatus << 4);
            cMask = 0;
            break;
        }
        lp = (LPSTR)(plb->rgpch) + iSel +
                (plb->cMac * (plb->fHasStrings
                                ? sizeof(LBItem)
                                : (plb->fHasData ? sizeof(LBODItem) : 0)));

        *lp = (*lp & cMask) | cSelStatus;
    }
}


/***************************************************************************\
* LastFullVisible
*
* Returns the last fully visible item in the listbox. This is valid
* for ownerdraw var height and fixed height listboxes.
*
* History:
\***************************************************************************/

INT LastFullVisible(
    PLBIV plb)
{
    INT iLastItem;

    if (plb->OwnerDraw == OWNERDRAWVAR || plb->fMultiColumn) {
        iLastItem = plb->iTop + CItemInWindow(plb, FALSE) - 1;
        iLastItem = max(iLastItem, plb->iTop);
    } else {
        iLastItem = min(plb->iTop + plb->cItemFullMax - 1, plb->cMac - 1);
    }
    return iLastItem;
}


/***************************************************************************\
* xxxInvertLBItem
*
* History:
\***************************************************************************/

void xxxInvertLBItem(
    PLBIV plb,
    INT i,
    BOOL fHilite)  /* The new selection state of the item */
{
    RECT rect;
    BOOL fCaretOn;
    HBRUSH hbrControl;
    BOOL    fNewDC;

    CheckLock(plb->spwnd);

    // Skip if item isn't showing.
    if (plb->fNoSel || (i < plb->iTop) || (i >= (plb->iTop + CItemInWindow(plb, TRUE))))
        return;

    if (IsLBoxVisible(plb)) {
        LBGetItemRect(plb, i, &rect);

        /*
         * Only turn off the caret if it is on.  This avoids annoying caret
         * flicker when nesting xxxCaretOns and xxxCaretOffs.
         */
        if (fCaretOn = plb->fCaretOn) {
            xxxLBSetCaret(plb, FALSE);
        }

        fNewDC = LBGetDC(plb);

        hbrControl = xxxLBGetBrush(plb, NULL);

        if (!plb->OwnerDraw) {
            if (!fHilite) {
                FillRect(plb->hdc, &rect, hbrControl);
                hbrControl = NULL;
            }

            xxxLBDrawLBItem(plb, i, &rect, fHilite, hbrControl);
        } else {

            /*
             * We are ownerdraw so fill in the drawitem struct and send off
             * to the owner.
             */
            xxxLBoxDrawItem(plb, i, ODA_SELECT,
                    (UINT)(fHilite ? ODS_SELECTED : 0), &rect);
        }

        if (fNewDC)
            LBReleaseDC(plb);

        /*
         * Turn the caret back on only if it was originally on.
         */
        if (fCaretOn) {
            xxxLBSetCaret(plb, TRUE);
        }
    }
}


/***************************************************************************\
* xxxResetWorld
*
* Resets everyone's selection and hilite state except items in the
* range sStItem to sEndItem (Both inclusive).
*
* History:
\***************************************************************************/

void xxxResetWorld(
    PLBIV plb,
    INT iStart,
    INT iEnd,
    BOOL fSelect)
{
    INT i;
    INT iLastInWindow;
    BOOL fCaretOn;

    CheckLock(plb->spwnd);

    /*
     * If iStart and iEnd are not in correct order we swap them
     */

    if (iStart > iEnd) {
        i = iStart;
        iStart = iEnd;
        iEnd = i;
    }

    if (plb->wMultiple == SINGLESEL) {
        if (plb->iSel != -1 && ((plb->iSel < iStart) || (plb->iSel > iEnd))) {
            xxxInvertLBItem(plb, plb->iSel, fSelect);
            plb->iSel = -1;
        }
        return;
    }

    iLastInWindow = plb->iTop + CItemInWindow(plb, TRUE);

    if (fCaretOn = plb->fCaretOn)
        xxxLBSetCaret(plb, FALSE);

    for (i = 0; i < plb->cMac; i++) {
        if (i == iStart)
            // skip range to be preserved
            i = iEnd;
        else {
            if ((plb->iTop <= i) && (i <= iLastInWindow) &&
                (fSelect != IsSelected(plb, i, HILITEONLY)))
                // Only invert the item if it is visible and present Selection
                // state is different from what is required.
                xxxInvertLBItem(plb, i, fSelect);

            // Set all items outside of preserved range to unselected
            SetSelected(plb, i, fSelect, HILITEANDSEL);
        }
    }

    if (fCaretOn)
        xxxLBSetCaret(plb, TRUE);

}


/***************************************************************************\
* xxxNotifyOwner
*
* History:
\***************************************************************************/

void xxxNotifyOwner(
    PLBIV plb,
    INT sEvt)
{
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    ThreadLock(plb->spwndParent, &tlpwndParent);
    SendMessage(HW(plb->spwndParent), WM_COMMAND,
            MAKELONG(PTR_TO_ID(plb->spwnd->spmenu), sEvt), (LPARAM)HWq(plb->spwnd));
    ThreadUnlock(&tlpwndParent);
}


/***************************************************************************\
* xxxSetISelBase
*
* History:
\***************************************************************************/

void xxxSetISelBase(
    PLBIV plb,
    INT sItem)
{
    CheckLock(plb->spwnd);

    xxxLBSetCaret(plb, FALSE);
    plb->iSelBase = sItem;
    xxxLBSetCaret(plb, TRUE);

    xxxInsureVisible(plb, plb->iSelBase, FALSE);
    
    /*
     * We need to send this event even if the listbox isn't visible. See
     * bug #88548. Also see 355612.
     */
    if (_IsWindowVisible(plb->spwnd) || (GetFocus() == HWq(plb->spwnd))) {
        LBEvent(plb, EVENT_OBJECT_FOCUS, sItem);
    }
}


/***************************************************************************\
* xxxTrackMouse
*
* History:
\***************************************************************************/

void xxxTrackMouse(
    PLBIV plb,
    UINT wMsg,
    POINT pt)
{
    INT iSelFromPt;
    INT iSelTemp;
    BOOL mousetemp;
    BOOL fMouseInRect;
    RECT rcClient;
    UINT wModifiers = 0;
    BOOL fSelected;
    UINT uEvent = 0;
    INT trackPtRetn;
    HWND hwnd = HWq(plb->spwnd);
    TL tlpwndEdit;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    /*
     * Optimization:  do nothing if mouse not captured
     */
    if ((wMsg != WM_LBUTTONDOWN) && (wMsg != WM_LBUTTONDBLCLK)) {
        if (!plb->fCaptured) {
            return;
        }
        /*
         * If we are processing a WM_MOUSEMOVE but the mouse has not moved from
         * the previous point, then we may be dealing with a mouse "jiggle" sent
         * from the kernel (see zzzInvalidateDCCache).  If we process this, we will
         * snap the listbox selection back to where the mouse cursor is pointing,
         * even if the user has not touched the mouse.  FritzS: NT5 bug 220722.
         *  Some apps (like MSMoney98) rely on this, so added the bLastRITWasKeyboard
         * check.  MCostea #244450
         */
        if ((wMsg == WM_MOUSEMOVE) && RtlEqualMemory(&pt, &(plb->ptPrev), sizeof(POINT))
            && gpsi->bLastRITWasKeyboard) {
                RIPMSG0(RIP_WARNING, "xxxTrackMouse ignoring WM_MOUSEMOVE with no mouse movement");
                return;
        }
    }

    mousetemp = ISelFromPt(plb, pt, &iSelFromPt);

    /*
     * If we allow the user to cancel his selection then fMouseInRect is true if
     * the mouse is in the listbox client area otherwise it is false.  If we
     * don't allow the user to cancel his selection, then fMouseInRect will
     * always be true.  This allows us to implement cancelable selection
     * listboxes ie.  The selection reverts to the origional one if the user
     * releases the mouse outside of the listbox.
     */
    fMouseInRect = !mousetemp || !plb->pcbox;

    _GetClientRect(plb->spwnd, &rcClient);

    switch (wMsg) {
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
        /*
         * We want to divert mouse clicks.  If the user clicks outside
         * of a dropped down listbox, we want to popup it up, using
         * the current selection.
         */
        if (plb->fCaptured) {
            /*
             * If plb->pcbox is NULL, this is a listbox that
             * received a WM_LBUTTONDOWN again w/o receiving
             * a WM_LBUTTONUP for the previous WM_LBUTTONDOWN
             * bug
             */
            if (plb->pcbox && mousetemp) {
                _ClientToScreen(plb->spwnd, &pt);

                if (!PtInRect(KPRECT_TO_PRECT(&plb->spwnd->rcWindow), pt)) {
                    /*
                     * Cancel selection if clicked outside of combo;
                     * Accept if clicked on combo button or item.
                     */
                    xxxCBHideListBoxWindow(plb->pcbox, TRUE, FALSE);
                } else if (!PtInRect(KPRECT_TO_PRECT(&plb->spwnd->rcClient), pt)) {
                    /*
                     * Let it pass through.  Save, restore capture in
                     * case user is clicking on scrollbar.
                     */
                    plb->fCaptured = FALSE;
                    NtUserReleaseCapture();

                    SendMessageWorker(plb->spwnd, WM_NCLBUTTONDOWN,
                        FindNCHit(plb->spwnd, POINTTOPOINTS(pt)),
                        MAKELONG(pt.x, pt.y), FALSE);

                    NtUserSetCapture(hwnd);
                    plb->fCaptured = TRUE;
                }

                break;
            }

            plb->fCaptured = FALSE;
            NtUserReleaseCapture();
        }

        if (plb->pcbox) {

            /*
             * If this listbox is in a combo box, set the focus to the combo
             * box window so that the edit control/static text is also
             * activated
             */
            ThreadLock(plb->pcbox->spwndEdit, &tlpwndEdit);
            NtUserSetFocus(HWq(plb->pcbox->spwndEdit));
            ThreadUnlock(&tlpwndEdit);
        } else {

            /*
             * Get the focus if the listbox is clicked in and we don't
             * already have the focus.  If we don't have the focus after
             * this, run away...
             */
            NtUserSetFocus(hwnd);
            if (!plb->fCaret)
                return;
        }

        if (plb->fAddSelMode) {

            /*
             * If it is in "Add" mode, quit it using shift f8 key...
             * However, since we can't send shift key state, we have to turn
             * this off directly...
             */

            /*
             *SendMessage(HW(plb->spwnd),WM_KEYDOWN, (UINT)VK_F8, 0L);
             */

            /*
             * Switch off the Caret blinking
             */
            NtUserKillTimer(hwnd, IDSYS_CARET);

            /*
             * Make sure the caret does not vanish
             */
            xxxLBSetCaret(plb, TRUE);
            plb->fAddSelMode = FALSE;
        }

        if (!plb->cMac) {

            /*
             * Don't even bother handling the mouse if no items in the
             * listbox since the code below assumes >0 items in the
             * listbox.  We will just get the focus (the statement above) if
             * we don't already have it.
             */
            break;
        }

        if (mousetemp) {

            /*
             * Mouse down occurred in a empty spot.  Just ignore it.
             */
            break;
        }

        plb->fDoubleClick = (wMsg == WM_LBUTTONDBLCLK);

        if (!plb->fDoubleClick) {

            /*
             * This hack put in for the shell.  Tell the shell where in the
             * listbox the user clicked and at what item number.  The shell
             * can return 0 to continue normal mouse tracking or TRUE to
             * abort mouse tracking.
             */
            ThreadLock(plb->spwndParent, &tlpwndParent);
            trackPtRetn = (INT)SendMessage(HW(plb->spwndParent), WM_LBTRACKPOINT,
                    (DWORD)iSelFromPt, MAKELONG(pt.x+plb->xOrigin, pt.y));
            ThreadUnlock(&tlpwndParent);
            if (trackPtRetn) {
                if (trackPtRetn == 2) {

                    /*
                     * Ignore double clicks
                     */
                    NtUserCallNoParam(SFI__RESETDBLCLK);
                }
                return;
            }
        }

        if (plb->pcbox) {

            /*
             * Save the last selection if this is a combo box.  So that it
             * can be restored if user decides to cancel the selection by up
             * clicking outside the listbox.
             */
            plb->iLastSelection = plb->iSel;
        }

        /*
         * Save for timer
         */
        plb->ptPrev = pt;

        plb->fMouseDown = TRUE;
        NtUserSetCapture(hwnd);
        plb->fCaptured = TRUE;

        if (plb->fDoubleClick) {

            /*
             * Double click.  Fake a button up and exit
             */
            xxxTrackMouse(plb, WM_LBUTTONUP, pt);
            return;
        }

        /*
         * Set the system timer so that we can autoscroll if the mouse is
         * outside the bounds of the listbox rectangle
         */
        NtUserSetTimer(hwnd, IDSYS_SCROLL, gpsi->dtScroll, NULL);



        /*
         * If extended multiselection listbox, are any modifier key pressed?
         */
        if (plb->wMultiple == EXTENDEDSEL) {
            if (GetKeyState(VK_SHIFT) < 0)
                wModifiers = SHIFTDOWN;
            if (GetKeyState(VK_CONTROL) < 0)
                wModifiers += CTLDOWN;

            /*
             * Please Note that (SHIFTDOWN + CTLDOWN) == (SHCTLDOWN)
             */
        }


        switch (wModifiers) {
        case NOMODIFIER:
MouseMoveHandler:
            if (plb->iSelBase != iSelFromPt) {
                xxxLBSetCaret(plb, FALSE);
            }

            /*
             * We only look at the mouse if the point it is pointing to is
             * not selected.  Since we are not in ExtendedSelMode, anywhere
             * the mouse points, we have to set the selection to that item.
             * Hence, if the item isn't selected, it means the mouse never
             * pointed to it before so we can select it.  We ignore already
             * selected items so that we avoid flashing the inverted
             * selection rectangle.  Also, we could get WM_SYSTIMER simulated
             * mouse moves which would cause flashing otherwise...
             */

            iSelTemp = (fMouseInRect ? iSelFromPt : -1);

            /*
             * If the LB is either SingleSel or Extended multisel, clear all
             * old selections except the new one being made.
             */
            if (plb->wMultiple != MULTIPLESEL) {
                xxxResetWorld(plb, iSelTemp, iSelTemp, FALSE);
                /*
                 * This will be TRUE if iSelTemp isn't -1 (like below)
                 * and also if it is but there is a current selection.
                 */
                if ((iSelTemp == -1) && (plb->iSel != -1)) {
                    uEvent = EVENT_OBJECT_SELECTIONREMOVE;
                }
            }

            fSelected = IsSelected(plb, iSelTemp, HILITEONLY);
            if (iSelTemp != -1) {

                /*
                 * If it is MULTIPLESEL, then toggle; For others, only if
                 * not selected already, select it.
                 */
                if (((plb->wMultiple == MULTIPLESEL) && (wMsg != WM_LBUTTONDBLCLK)) || !fSelected) {
                    SetSelected(plb, iSelTemp, !fSelected, HILITEANDSEL);

                    /*
                     * And invert it
                     */
                    xxxInvertLBItem(plb, iSelTemp, !fSelected);
                    fSelected = !fSelected;  /* Set the new state */
                    if (plb->wMultiple == MULTIPLESEL) {
                        uEvent = (fSelected ? EVENT_OBJECT_SELECTIONADD :
                                EVENT_OBJECT_SELECTIONREMOVE);
                    } else {
                        uEvent = EVENT_OBJECT_SELECTION;
                    }
                }
            }

            /*
             * We have to set iSel in case this is a multisel lb.
             */
            plb->iSel = iSelTemp;

            /*
             * Set the new anchor point
             */
            plb->iMouseDown = iSelFromPt;
            plb->iLastMouseMove = iSelFromPt;
            plb->fNewItemState = fSelected;

            break;
        case SHIFTDOWN:

            /*
             * This is so that we can handle click and drag for multisel
             * listboxes using Shift modifier key .
             */
            plb->iLastMouseMove = plb->iSel = iSelFromPt;



            /*
             * Check if an anchor point already exists
             */
            if (plb->iMouseDown == -1) {
                plb->iMouseDown = iSelFromPt;

                /*
                 * Reset all the previous selections
                 */
                xxxResetWorld(plb, plb->iMouseDown, plb->iMouseDown, FALSE);

                /*
                 * Select the current position
                 */
                SetSelected(plb, plb->iMouseDown, TRUE, HILITEANDSEL);
                xxxInvertLBItem(plb, plb->iMouseDown, TRUE);
                /*
                 * We are changing the selction to this item only
                 */
                uEvent = EVENT_OBJECT_SELECTION;
            } else {

                /*
                 * Reset all the previous selections
                 */
                xxxResetWorld(plb, plb->iMouseDown, plb->iMouseDown, FALSE);

                /*
                 * Select all items from anchor point upto current click pt
                 */
                xxxAlterHilite(plb, plb->iMouseDown, iSelFromPt, HILITE, HILITEONLY, FALSE);
                uEvent = EVENT_OBJECT_SELECTIONWITHIN;
            }
            plb->fNewItemState = (UINT)TRUE;
            break;

        case CTLDOWN:

            /*
             * This is so that we can handle click and drag for multisel
             * listboxes using Control modifier key.
             */

            /*
             * Reset the anchor point to the current point
             */
            plb->iMouseDown = plb->iLastMouseMove = plb->iSel = iSelFromPt;

            /*
             * The state we will be setting items to
             */
            plb->fNewItemState = (UINT)!IsSelected(plb, iSelFromPt, (UINT)HILITEONLY);

            /*
             * Toggle the current point
             */
            SetSelected(plb, iSelFromPt, plb->fNewItemState, HILITEANDSEL);
            xxxInvertLBItem(plb, iSelFromPt, plb->fNewItemState);
            uEvent = (plb->fNewItemState ? EVENT_OBJECT_SELECTIONADD :
                    EVENT_OBJECT_SELECTIONREMOVE);
            break;

        case SHCTLDOWN:

            /*
             * This is so that we can handle click and drag for multisel
             * listboxes using Shift and Control modifier keys.
             */

            /*
             * Preserve all the previous selections
             */

            /*
             * Deselect only the selection connected with the last
             * anchor point; If the last anchor point is associated with a
             * de-selection, then do not do it
             */
            if (plb->fNewItemState) {
                xxxAlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove, FALSE, HILITEANDSEL, FALSE);
            }
            plb->iLastMouseMove = plb->iSel = iSelFromPt;

            /*
             * Check if an anchor point already exists
             */
            if (plb->iMouseDown == -1) {

                /*
                 * No existing anchor point; Make the current pt as anchor
                 */
                plb->iMouseDown = iSelFromPt;
            }

            /*
             * If one exists preserve the most recent anchor point
             */

            /*
             * The state we will be setting items to
             */
            plb->fNewItemState = (UINT)IsSelected(plb, plb->iMouseDown, HILITEONLY);

            /*
             * Select all items from anchor point upto current click pt
             */
            xxxAlterHilite(plb, plb->iMouseDown, iSelFromPt, plb->fNewItemState, HILITEONLY, FALSE);
            uEvent = EVENT_OBJECT_SELECTIONWITHIN;
            break;
        }

        /*
         * Set the new base point (the outline frame caret).  We do the check
         * first to avoid flashing the caret unnecessarly.
         */
        if (plb->iSelBase != iSelFromPt) {

            /*
             * Since xxxSetISelBase always turns on the caret, we don't need to
             * do it here...
             */
            xxxSetISelBase(plb, iSelFromPt);
        }

        /*
         * SetISelBase will change the focus and send a focus event.
         * Then we send the selection event.
         */
        if (uEvent) {
            LBEvent(plb, uEvent, iSelFromPt);
        }
        if (wMsg == WM_LBUTTONDOWN && TestWF(plb->spwnd, WEFDRAGOBJECT)) {
            if (NtUserDragDetect(hwnd, pt)) {

                /*
                 * User is trying to drag object...
                 */

                /*
                 *  Fake an up click so that the item is selected...
                 */
                xxxTrackMouse(plb, WM_LBUTTONUP, pt);

                /*
                 * Notify parent
                 * #ifndef WIN16 (32-bit Windows), plb->iSelBase gets
                 * zero-extended to LONG wParam automatically by the compiler.
                 */
                ThreadLock(plb->spwndParent, &tlpwndParent);
                SendMessage(HW(plb->spwndParent), WM_BEGINDRAG, plb->iSelBase,
                        (LPARAM)hwnd);
                ThreadUnlock(&tlpwndParent);
            } else {
                xxxTrackMouse(plb, WM_LBUTTONUP, pt);
            }
            return;
        }
        break;

    case WM_MOUSEMOVE: {
        int dist;
        int iTimer;

        /*
         * Save for timer.
         */
        plb->ptPrev = pt;
        /*
         * Autoscroll listbox if mouse button is held down and mouse is
         * moved outside of the listbox
         */
        if (plb->fMouseDown) {
            if (plb->fMultiColumn) {
                if ((pt.x < 0) || (pt.x >= rcClient.right - 1)) {
                    /*
                     * Reset timer interval based on distance from listbox.
                     * use a longer default interval because each multicolumn
                     * scrolling increment is larger
                     */
                    dist = pt.x < 0 ? -pt.x : (pt.x - rcClient.right + 1);
                    iTimer = ((gpsi->dtScroll * 3) / 2) - ((WORD) dist << 4);

                    if (plb->fRightAlign)
                        xxxLBoxCtlHScrollMultiColumn(plb, (pt.x < 0 ? SB_LINEDOWN : SB_LINEUP), 0);
                    else
                        xxxLBoxCtlHScrollMultiColumn(plb, (pt.x < 0 ? SB_LINEUP : SB_LINEDOWN), 0);

                    goto SetTimerAndSel;
                }
            } else if ((pt.y < 0) || (pt.y >= rcClient.bottom - 1)) {
                /*
                 * Reset timer interval based on distance from listbox.
                 */
                dist = pt.y < 0 ? -pt.y : (pt.y - rcClient.bottom + 1);
                iTimer = gpsi->dtScroll - ((WORD) dist << 4);

                xxxLBoxCtlScroll(plb, (pt.y < 0 ? SB_LINEUP : SB_LINEDOWN), 0);
SetTimerAndSel:
                NtUserSetTimer(hwnd, IDSYS_SCROLL, max(iTimer, 1), NULL);
                ISelFromPt(plb, pt, &iSelFromPt);
            }
        } else {
            /*
             * Ignore if not in client since we don't autoscroll
             */
            if (!PtInRect(&rcClient, pt))
                break;
        }

        switch (plb->wMultiple) {
        case SINGLESEL:

            /*
             * If it is a single selection or plain multisel list box
             */
            goto MouseMoveHandler;
            break;

        case MULTIPLESEL:
        case EXTENDEDSEL:

            /*
             * Handle mouse movement with extended selection of items
             */
            if (plb->iSelBase != iSelFromPt) {
                xxxSetISelBase(plb, iSelFromPt);

                /*
                 * If this is an extended Multi sel list box, then
                 * adjust the display of the range due to the mouse move
                 */
                if (plb->wMultiple == EXTENDEDSEL) {
                    xxxLBBlockHilite(plb, iSelFromPt, FALSE);
                    LBEvent(plb, EVENT_OBJECT_SELECTIONWITHIN, iSelFromPt);
                }
                plb->iLastMouseMove = iSelFromPt;
            }
            break;
        }
        break;
    }
    case WM_LBUTTONUP:
        if (plb->fMouseDown)
            xxxLBButtonUp(plb, LBUP_RELEASECAPTURE | LBUP_NOTIFY |
                (mousetemp ? LBUP_RESETSELECTION : 0) |
                (fMouseInRect ? LBUP_SUCCESS : 0));
    }
}

/***************************************************************************\
*
*  LBButtonUp()
*
*  Called in response to both WM_CAPTURECHANGED and WM_LBUTTONUP.
*
\***************************************************************************/
void xxxLBButtonUp(PLBIV plb, UINT uFlags)
{

    CheckLock(plb->spwnd);

    /*
     * If the list box is an Extended listbox, then change the select status
     * of all items between the anchor and the last mouse position to the
     * newItemState
     */
    if (plb->wMultiple == EXTENDEDSEL)
        xxxAlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove,
            plb->fNewItemState, SELONLY, FALSE);

    /*
     * This is a combo box and user upclicked outside the listbox
     * so we want to restore the original selection.
     */
    if (plb->pcbox && (uFlags & LBUP_RESETSELECTION)) {
        int iSelOld;

        iSelOld = plb->iSel;

        if (iSelOld >= 0)
            xxxInvertLBItem(plb, plb->iSel, FALSE);

        plb->iSel = plb->iLastSelection;
        xxxInvertLBItem(plb, plb->iSel, TRUE);

        /*
         * Note that we always send selection events before we tell the
         * app.  This is on purpose--the app may turn around and select
         * something else when notified.  In which case our event would
         * be out of order.
         */
        LBEvent(plb, EVENT_OBJECT_SELECTION, plb->iSel);

        /*
         * On win-95 and NT4 the check used to be !(uFlags & LBUP_NOTIFY) which
         * is a bug because we would notify even when the lb is not LBUP_NOTIFY
         */
        if ((uFlags & LBUP_NOTIFY) && plb->fNotify && (iSelOld != plb->iSel))
            xxxNotifyOwner(plb, LBN_SELCHANGE);
    }

    NtUserKillTimer(HWq(plb->spwnd), IDSYS_SCROLL);
    plb->fMouseDown = FALSE;
    if (plb->fCaptured) {
        plb->fCaptured = FALSE;
        if (uFlags & LBUP_RELEASECAPTURE)
            NtUserReleaseCapture();
    }
    /*
     * Don't scroll item as long as any part of it is visible
     */
    if (plb->iSelBase < plb->iTop ||
        plb->iSelBase > plb->iTop + CItemInWindow(plb, TRUE))
        xxxInsureVisible(plb, plb->iSelBase, FALSE);

    if (plb->fNotify) {
        if (uFlags & LBUP_NOTIFY)  {
            if (uFlags & LBUP_SUCCESS) {
                /*
                 * ArtMaster needs this SELCHANGE notification now!
                 */
                if ((plb->fDoubleClick) && !TestWF(plb->spwnd, WFWIN31COMPAT))
                    xxxNotifyOwner(plb, LBN_SELCHANGE);

                /*
                 * Notify owner of click or double click on selection
                 */
                xxxNotifyOwner(plb, (plb->fDoubleClick) ? LBN_DBLCLK : LBN_SELCHANGE);
            } else {
                /*
                 * Notify owner that the attempted selection was cancelled.
                 */
                xxxNotifyOwner(plb, LBN_SELCANCEL);
            }
        } else if (uFlags & LBUP_SELCHANGE) {
            /*
             * Did we do some semi-selecting with mouse moves, then hit Enter?
             * If so, we need to make sure the app knows that something was
             * really truly selected.
             */
            UserAssert(TestWF(plb->spwnd, WFWIN40COMPAT));
            if (plb->iLastSelection != plb->iSel)
                xxxNotifyOwner(plb, LBN_SELCHANGE);

        }
    }

}


/***************************************************************************\
* IncrementISel
*
* History:
\***************************************************************************/

INT IncrementISel(
    PLBIV plb,
    INT iSel,
    INT sInc)
{

    /*
     * Assumes cMac > 0, return iSel+sInc in range [0..cmac).
     */
    iSel += sInc;
    if (iSel < 0) {
        return 0;
    } else if (iSel >= plb->cMac) {
        return plb->cMac - 1;
    }
    return iSel;
}


/***************************************************************************\
* NewITop
*
\***************************************************************************/

void xxxNewITop(PLBIV plb, INT iTopNew)
{
    xxxNewITopEx(plb, iTopNew, 0);
}


/***************************************************************************\
* xxxNewITopEx
*
* History:
\***************************************************************************/

void xxxNewITopEx(
    PLBIV plb,
    INT iTopNew,
    DWORD dwTime)
{
    int     iTopOld;
    BOOL fCaretOn;
    BOOL fMulti = plb->fMultiColumn;

    CheckLock(plb->spwnd);

    // Always try to turn off caret whether or not redraw is on
    if (fCaretOn = plb->fCaretOn)
        xxxLBSetCaret(plb, FALSE);

    iTopOld = (fMulti) ? (plb->iTop / plb->itemsPerColumn) : plb->iTop;
    plb->iTop = iTopNew;
    iTopNew = xxxSetLBScrollParms(plb, (fMulti) ? SB_HORZ : SB_VERT);
    plb->iTop = (fMulti) ? (iTopNew * plb->itemsPerColumn) : iTopNew;

    if (!IsLBoxVisible(plb)) {
        return;
    }

    if (iTopNew != iTopOld) {
        int     xAmt, yAmt;
        RECT    rc;
        DWORD   dwFlags;

        _GetClientRect(plb->spwnd, &rc);

        if (fMulti) {
            yAmt = 0;
            if (abs(iTopNew - iTopOld) > plb->numberOfColumns)
                // Handle scrolling a large number of columns properly so that
                // we don't overflow the size of a rect.
                xAmt = 32000;
            else {
                xAmt = (iTopOld - iTopNew) * plb->cxColumn;
                if (plb->fRightAlign)
                    xAmt = -xAmt;
            }
        } else {
            xAmt = 0;
            if (plb->OwnerDraw == OWNERDRAWVAR) {
                //
                // Have to fake iTopOld for OWNERDRAWVAR listboxes so that
                // the scrolling amount calculations work properly.
                //
                plb->iTop = iTopOld;
                yAmt = LBCalcVarITopScrollAmt(pl